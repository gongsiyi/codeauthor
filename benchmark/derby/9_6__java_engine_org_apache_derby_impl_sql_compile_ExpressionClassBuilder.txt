1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ExpressionClassBuilder
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
26:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: 
1:d11ed08: import java.io.Serializable;
1:d11ed08: import java.lang.reflect.Modifier;
1:d11ed08: import org.apache.derby.iapi.error.StandardException;
1:d11ed08: import org.apache.derby.iapi.reference.ClassName;
1:d11ed08: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.ClassBuilder;
1:eac0369: import org.apache.derby.iapi.services.compiler.JavaFactory;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:d11ed08: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:d11ed08: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:d11ed08: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1:eac0369: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:d11ed08: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:d11ed08: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:d11ed08: import org.apache.derby.impl.sql.execute.IndexColumnOrder;
1:eac0369: 
7:eac0369: /**
1:eac0369:  * ExpressionClassBuilder
1:eac0369:  * provides an interface to satisfy generation's
1:eac0369:  * common tasks in building classes that involve expressions.
1:eac0369:  * This is the common superclass of ActivationClassBuilder and
1:eac0369:  * FilterClassBuilder. See the documentation on ActivationClassBuilder.
13:eac0369:  *
1:eac0369:  */
1:a1aaa63: abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
1:eac0369: {
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CONSTANTS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	static final protected String currentDatetimeFieldName = "cdt";
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// STATE
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	protected ClassBuilder cb;
1:eac0369: 	protected GeneratedClass gc;
1:eac0369: 	protected int nextExprNum;
1:eac0369: 	protected int nextNonFastExpr;
1:eac0369: 	protected int nextFieldNum;
1:eac0369: 	protected MethodBuilder constructor;
1:e077c88: 	CompilerContext myCompCtx;
1:e077c88: 	MethodBuilder executeMethod; // to find it fast
1:eac0369: 
1:eac0369: 	protected LocalField cdtField;
1:eac0369: 
1:eac0369: 	//protected final JavaFactory javaFac;
1:eac0369: 
1:eac0369: 	private String currentRowScanResultSetName;
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * By the time this is done, it has constructed the following class:
1:eac0369: 	 * <pre>
1:ab2cc4a:      *    final public class #className extends #superClass {
1:ab2cc4a:      *      public #className() { super(); }
1:eac0369: 	 *    }
1:eac0369: 	 * </pre>
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:e077c88: 	ExpressionClassBuilder (String superClass, String className, CompilerContext cc ) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int modifiers = Modifier.PUBLIC | Modifier.FINAL;
1:eac0369: 
1:eac0369: 		myCompCtx = cc;
1:eac0369: 		JavaFactory javaFac = myCompCtx.getJavaFactory();
1:eac0369: 
1:eac0369: 		if ( className == null ) { className = myCompCtx.getUniqueClassName(); }
1:eac0369: 
1:eac0369: 		// start the class
1:eac0369: 		cb = javaFac.newClassBuilder(myCompCtx.getClassFactory(),
1:eac0369: 			getPackageName(), modifiers,
1:eac0369: 			className, superClass);
1:eac0369: 
1:eac0369: 		beginConstructor();
6:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:0393775: 	/**
1:eac0369: 	 * Get the name of the package that the generated class will live in.
1:eac0369: 	 *
1:eac0369: 	 *	@return	name of package that the generated class will live in.
1:eac0369: 	 */
1:e077c88: 	abstract	String	getPackageName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of ExecRows that must be allocated
1:eac0369: 	 *
1:eac0369: 	 *	@return	number of ExecRows that must be allocated
1:eac0369: 	 *
4:eac0369: 	 * 	@exception StandardException thrown on failure
1:eac0369: 	 */
1:e077c88: 	abstract	int		getRowCount()
4:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the number of subqueries under this expression
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * 	@exception StandardException thrown on failure
1:eac0369: 	 */
1:e077c88: 	abstract	void 	setNumSubqueries()
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ACCESSORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the base class of the activation's hierarchy
1:eac0369: 		(the subclass of Object).
1:eac0369: 
1:eac0369: 		This class is expected to hold methods used by all
1:eac0369: 		compilation code, such as datatype compilation code,
1:eac0369: 		e.g. getDataValueFactory.
1:eac0369: 	 */
1:e077c88: 	abstract String getBaseClassName();
1:eac0369: 
1:e077c88: 	MethodBuilder getConstructor() {
1:eac0369: 		return constructor;
1:0393775: 	}
1:0393775: 
1:e077c88: 	ClassBuilder getClassBuilder() {
1:eac0369: 		return cb;
1:0393775: 	}
1:eac0369: 
1:eac0369: 	/**
1:d11ed08:      * Get a method builder for adding code to the execute() method.
1:d11ed08:      * The method builder does not actually build a method called execute.
1:d11ed08:      * Instead, it creates a method that overrides the reinit() method,
1:d11ed08:      * which is called from execute() on every execution in order to
1:d11ed08:      * reinitialize the data structures.
1:eac0369: 	 */
1:e077c88: 	MethodBuilder getExecuteMethod() {
1:d11ed08:         if (executeMethod == null) {
1:d11ed08:             executeMethod =
1:d11ed08:                     cb.newMethodBuilder(Modifier.PROTECTED, "void", "reinit");
1:d11ed08:             executeMethod.addThrownException(ClassName.StandardException);
1:d11ed08:         }
1:eac0369: 		return executeMethod;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CONSTRUCTOR MANAGEMENT
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:3bb140c:     private void beginConstructor()
1:eac0369: 	{
1:eac0369: 		// create a constructor that just calls super.  
1:eac0369: 		MethodBuilder realConstructor =
1:eac0369: 			cb.newConstructorBuilder(Modifier.PUBLIC);
1:eac0369: 		realConstructor.callSuper();
1:eac0369: 		realConstructor.methodReturn();
1:eac0369: 		realConstructor.complete();
1:eac0369: 
1:eac0369: 		constructor = cb.newMethodBuilder(Modifier.PUBLIC, "void", "postConstructor");
1:eac0369: 		constructor.addThrownException(ClassName.StandardException);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Finish the constructor by newing the array of Rows and putting a return 
1:0393775: 	 * at the end of it.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:0393775: 	 */
1:eac0369: 
1:e077c88: 	void finishConstructor()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		int				numResultSets;
1:eac0369: 
1:eac0369: 		/* Set the number of subqueries */
1:eac0369: 		setNumSubqueries();
1:eac0369: 
1:eac0369: 		numResultSets = getRowCount();
1:eac0369: 
1:eac0369: 		/* Generate the new of ExecRow[numResultSets] when there are ResultSets
1:eac0369: 		 * which return Rows.
1:eac0369: 		 */
1:eac0369: 		if (numResultSets >= 1)
1:eac0369: 		{
1:eac0369: 			addNewArrayOfRows(numResultSets);
1:0393775: 		}
1:eac0369: 
1:eac0369: 		/* Generated code is:
1:eac0369: 		 *		return;
1:eac0369: 		 */
1:eac0369: 		constructor.methodReturn();
1:eac0369: 		constructor.complete();
1:0393775: 	}
1:0393775: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the assignment for row = new ExecRow[numResultSets]
1:eac0369: 	 *
1:eac0369: 	 * @param numResultSets	The size of the array.
1:eac0369: 	 */
1:eac0369: 	private void addNewArrayOfRows(int numResultSets)
1:eac0369: 	{
1:eac0369: 		/* Generated code is:
1:eac0369: 		 *		row = new ExecRow[numResultSets];
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		constructor.pushThis();
1:eac0369: 		constructor.pushNewArray(ClassName.ExecRow, numResultSets);
1:eac0369: 		constructor.putField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
2:eac0369: 		constructor.endStatement();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ADD FIELDS TO GENERATED CLASS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a field declaration to the generated class
1:eac0369: 	 * 
1:eac0369: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
1:eac0369: 	 * @param type		The type of the field in java language.
1:eac0369: 	 * @param name		The name of the field.
1:eac0369: 	 *
1:eac0369: 	 * @return None.
1:eac0369: 	 */
1:e077c88: 	LocalField newFieldDeclaration(int modifiers, String type, String name)
1:eac0369: 	{
1:eac0369: 		return cb.addField(type, name, modifiers);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add an arbitrarily named field to the generated class.
1:eac0369: 	 *
1:eac0369: 	 * This is used to generate fields where the caller doesn't care what
1:eac0369: 	 * the field is named.  It is especially useful for generating arbitrary
1:eac0369: 	 * numbers of fields, where the caller doesn't know in advance how many
1:eac0369: 	 * fields will be used.  For example, it is used for generating fields
1:eac0369: 	 * to hold intermediate values from expressions.
1:eac0369: 	 *
1:eac0369: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
1:eac0369: 	 * @param type		The type of the field in java language.
1:eac0369: 	 *
1:eac0369: 	 * @return	The name of the new field
1:eac0369: 	 */
1:eac0369: 
1:e077c88: 	LocalField newFieldDeclaration(int modifiers, String type)
1:eac0369: 	{
1:eac0369: 		return cb.addField(type, newFieldName(), modifiers);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ADD FUNCTIONS TO GENERATED CLASS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Activations might have need of internal functions
1:eac0369: 	 * that are not used by the result sets, but by other
1:eac0369: 	 * activation functions. Thus, we make it possible
1:eac0369: 	 * for functions to be generated directly as well
1:eac0369: 	 * as through the newExprFun interface.  newExprFun
1:eac0369: 	 * should be used when a static field pointing to the
1:eac0369: 	 * expression function is needed.
1:eac0369: 	 * <p>
1:eac0369: 	 * The generated function will generally have a generated name
1:eac0369: 	 * that can be viewed through the MethodBuilder interface.
1:eac0369: 	 * This name is generated to ensure uniqueness from other
1:eac0369: 	 * function names in the activation class. If you pass in a function
1:eac0369: 	 * name, think carefully about whether it will collide with other names.
1:eac0369: 	 *
1:eac0369: 	 * @param returnType the return type of the function
1:eac0369: 	 * @param modifiers the modifiers on the function
1:eac0369: 	 *
1:eac0369: 	 * @see #newExprFun
1:eac0369: 	 */
1:e077c88: 	MethodBuilder newGeneratedFun(String returnType, int modifiers) {
1:eac0369: 
1:eac0369: 		return newGeneratedFun(returnType, modifiers,
1:eac0369: 							   (String[]) null);
1:eac0369: 	}
1:eac0369: 
1:e077c88: 	MethodBuilder newGeneratedFun(String returnType, 
1:eac0369: 										 int modifiers,
1:eac0369: 										 String[] params) {
1:eac0369: 
1:eac0369: 		String exprName = "g".concat(Integer.toString(nextNonFastExpr++));
1:eac0369: 		return newGeneratedFun(exprName, returnType, modifiers,
1:eac0369: 							   params);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private MethodBuilder newGeneratedFun(String exprName, String returnType, 
1:eac0369: 										 int modifiers,
1:eac0369: 										 String[] params) {
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// create a new method supplying the given modifiers and return Type
1:eac0369: 		// Java: #modifiers #returnType #exprName { }
1:eac0369: 		//
1:eac0369: 		MethodBuilder exprMethod;
1:eac0369: 		if (params == null)
1:eac0369: 		{
1:eac0369: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, exprName);
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, 
1:eac0369: 										     exprName, params);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// declare it to throw StandardException
1:eac0369: 		// Java: #modifiers #returnType #exprName throws StandardException { }
1:eac0369: 		//
1:eac0369: 		exprMethod.addThrownException(ClassName.StandardException);
1:eac0369: 
1:eac0369: 		return exprMethod;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * "ExprFun"s are the "expression functions" that
1:eac0369: 	 * are specific to a given JSQL statement. For example,
1:eac0369: 	 * an ExprFun is generated to evaluate the where clause
1:eac0369: 	 * of a select statement and return a boolean result.
1:eac0369: 	 * <p>
1:eac0369: 	 *
1:eac0369: 	 * All methods return by this are expected to be called
1:eac0369: 	 * via the GeneratedMethod interface. Thus the methods
1:eac0369: 	 * are public and return java.lang.Object.
1:eac0369: 	 * <p>
1:eac0369: 	 * Once the exprfun has been created, the
1:eac0369: 	 * caller will need to add statements to it,
1:eac0369: 	 * minimally a return statement.
1:eac0369: 	 * <p>
1:eac0369: 	 * ExprFuns  return Object types, since they
1:eac0369: 	 * are invoked through reflection and thus their
1:eac0369: 	 * return type would get wrapped in an object anyway.
1:eac0369: 	 * For example: return java.lang.Boolean, not boolean.
1:eac0369: 	 */
1:e077c88: 	MethodBuilder newExprFun()
1:eac0369: 	{
1:eac0369: 		// get next generated function 
1:eac0369: 		String exprName = "e".concat(Integer.toString(nextExprNum++));
1:eac0369: 
1:eac0369: 		return newGeneratedFun(exprName, "java.lang.Object", Modifier.PUBLIC, (String[]) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push an expression that is a GeneratedMethod reference to the
1:eac0369: 		passed in method. aka. a "function pointer".
1:eac0369: 	*/
1:e077c88: 	void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {
1:eac0369: 
1:eac0369: 		mb.pushThis(); // instance
1:eac0369: 		mb.push(exprMethod.getName()); // arg
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,
1:eac0369: 				"getMethod",
1:eac0369: 				ClassName.GeneratedMethod,
1:eac0369: 				1
1:eac0369: 				);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Start a user expression.  The difference between a normal expression
1:eac0369: 	 * (returned by newExprFun)
1:eac0369: 	 * and a user expression is that a user expression catches all exceptions
1:eac0369: 	 * (because we don't want random exceptions thrown from user methods to
1:eac0369: 	 * propagate to the rest of the system.
1:eac0369: 	 *
1:eac0369: 	 * @return	A new MethodBuilder
1:eac0369: 	 */
1:e077c88: 	MethodBuilder newUserExprFun() {
1:eac0369: 
1:eac0369: 		MethodBuilder mb = newExprFun();
1:eac0369: 		mb.addThrownException("java.lang.Exception");
1:eac0369: 		return mb;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CURRENT DATE/TIME SUPPORT
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This utility method returns an expression for CURRENT_DATE.
1:eac0369: 		Get the expression this way, because the activation needs to 
1:eac0369: 		generate support information for CURRENT_DATE,
1:eac0369: 		that would otherwise be painful to create manually.
1:eac0369: 	 */
1:e077c88: 	void getCurrentDateExpression(MethodBuilder mb) {
1:eac0369: 		// do any needed setup
1:eac0369: 		LocalField lf = getCurrentSetup();
1:eac0369: 
1:eac0369: 		// generated Java:
1:eac0369: 		//	  this.cdt.getCurrentDate();
1:eac0369: 		mb.getField(lf);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentDate", "java.sql.Date", 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This utility method returns an expression for CURRENT_TIME.
1:eac0369: 		Get the expression this way, because the activation needs to 
1:eac0369: 		generate support information for CURRENT_TIME,
1:eac0369: 		that would otherwise be painful to create manually.
1:eac0369: 	 */
1:e077c88: 	void getCurrentTimeExpression(MethodBuilder mb) {
1:eac0369: 		// do any needed setup
1:eac0369: 		LocalField lf = getCurrentSetup();
1:eac0369: 
1:eac0369: 		// generated Java:
1:eac0369: 		//	  this.cdt.getCurrentTime();
1:eac0369: 		mb.getField(lf);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentTime", "java.sql.Time", 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This utility method generates an expression for CURRENT_TIMESTAMP.
1:eac0369: 		Get the expression this way, because the activation needs to 
1:eac0369: 		generate support information for CURRENT_TIMESTAMP,
1:eac0369: 		that would otherwise be painful to create manually.
1:eac0369: 	 */
1:e077c88: 	void getCurrentTimestampExpression(MethodBuilder mb) {
1:eac0369: 		// do any needed setup
1:eac0369: 		LocalField lf = getCurrentSetup();
1:eac0369: 
1:eac0369: 		// generated Java:
1:eac0369: 		//	  this.cdt.getCurrentTimestamp();
1:eac0369: 		mb.getField(lf);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
1:eac0369: 			"getCurrentTimestamp", "java.sql.Timestamp", 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// COLUMN ORDERING
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369:     /**
1:eac0369: 		These utility methods buffers compilation from the IndexColumnOrder
1:eac0369: 		class.
1:eac0369: 
1:eac0369: 		They create an ordering based on their parameter, stuff that into
1:eac0369: 		the prepared statement, and then return the entry # for
1:eac0369: 		use in the generated code.
1:eac0369: 
1:eac0369: 		We could write another utility method to generate code to
1:eac0369: 		turn an entry # back into an object, but so far no-one needs it.
1:eac0369: 	
1:eac0369: 		WARNING: this is a crafty method that ASSUMES that 
1:eac0369: 		you want every column in the list ordered, and that every
1:eac0369: 		column in the list is the entire actual result colunm.
1:eac0369: 		It is only useful for DISTINCT in select.	
1:eac0369: 	 */
1:e077c88: 	FormatableArrayHolder getColumnOrdering(ResultColumnList rclist)
1:eac0369: 	{
1:eac0369: 		IndexColumnOrder[] ordering;
1:eac0369: 		int numCols = (rclist == null) ? 0 : rclist.size();
1:eac0369: 		//skip the columns which are not exclusively part of the insert list
1:eac0369:     //ie columns with default and autoincrement. These columns will not
1:eac0369:     //be part of ordering.
1:eac0369: 		int numRealCols = 0;
1:eac0369: 		for (int i=0; i<numCols; i++)
1:eac0369: 		{
1:eac0369: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
1:eac0369: 				numRealCols++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ordering = new IndexColumnOrder[numRealCols];
1:eac0369: 		for (int i=0, j=0; i<numCols; i++)
1:eac0369: 		{
1:eac0369: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
1:eac0369: 			{
1:eac0369: 				ordering[j] = new IndexColumnOrder(i);
1:eac0369: 				j++;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return new FormatableArrayHolder(ordering);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a column to the existing Ordering list.  Takes
1:eac0369: 	 * a column id and only adds it if it isn't in the list.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return the ColumnOrdering array
1:eac0369: 	 */
1:e077c88: 	FormatableArrayHolder addColumnToOrdering(
1:eac0369: 						FormatableArrayHolder orderingHolder,
1:eac0369: 						int columnNum)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** We don't expect a lot of order by columns, so
1:eac0369: 		** linear search.
1:eac0369: 		*/
1:473d692:         ColumnOrdering[] ordering =
1:473d692:                 orderingHolder.getArray(ColumnOrdering[].class);
1:eac0369: 		int length = ordering.length;
1:eac0369: 		for (int i = 0; i < length; i++)
1:eac0369: 		{
1:eac0369: 			if (ordering[i].getColumnId() == columnNum)
1:eac0369: 				return orderingHolder;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Didn't find it.  Allocate a bigger array
1:eac0369: 		** and add it to the end
1:eac0369: 		*/
1:eac0369: 		IndexColumnOrder[] newOrdering = new IndexColumnOrder[length+1];
1:eac0369: 		System.arraycopy(ordering, 0, newOrdering, 0, length);
1:eac0369: 		newOrdering[length] = new IndexColumnOrder(columnNum);
1:eac0369: 		
1:eac0369: 		return new FormatableArrayHolder(newOrdering);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 
1:e1f49ca:     FormatableArrayHolder getColumnOrdering(OrderedColumnList<?>  oclist) {
1:eac0369: 		int numCols = (oclist == null) ? 0 : oclist.size();
1:eac0369: 
1:eac0369: 		if (numCols == 0)
1:eac0369: 		{
1:eac0369: 			return new FormatableArrayHolder(new IndexColumnOrder[0]);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return new FormatableArrayHolder(oclist.getColumnOrdering());
1:eac0369: 	}
1:eac0369: 
1:e077c88: 	int addItem(Object o) 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if ((o != null) && !(o instanceof Serializable))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"o (" + o.getClass().getName() +
1:eac0369: 					") expected to be instanceof java.io.Serializable");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return myCompCtx.addSavedObject(o);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// Caching resuable Expressions
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get/reuse the Expression for getting the DataValueFactory
1:eac0369: 	 */
1:eac0369: 	private Object getDVF;
1:e077c88: 	void pushDataValueFactory(MethodBuilder mb)
1:eac0369: 	{
1:eac0369: 		// generates:
1:eac0369: 		//	   getDataValueFactory()
1:eac0369: 		//
1:eac0369: 
1:eac0369: 		if (getDVF == null) {
1:eac0369: 			getDVF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL,
1:eac0369: 										getBaseClassName(),
1:eac0369: 										"getDataValueFactory",
1:eac0369: 										ClassName.DataValueFactory);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.callMethod(getDVF);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// RESULT SET SUPPORT
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This is a utility method to get a common expression --
1:eac0369: 		"BaseActivation.getResultSetFactory()".
1:eac0369: 		<p>
1:eac0369: 		BaseActivation gets the factory from the context and
1:eac0369: 		caches it for faster retrieval.
1:eac0369: 	 */
1:eac0369: 	private Object getRSF;
1:e077c88: 	void pushGetResultSetFactoryExpression(MethodBuilder mb) {
1:eac0369: 		// generated Java:
1:eac0369: 		//	this.getResultSetFactory()
1:eac0369: 		//
1:eac0369: 		if (getRSF == null) {
1:eac0369: 			getRSF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
1:eac0369: 					"getResultSetFactory",
1:eac0369: 					ClassName.ResultSetFactory);
1:eac0369: 		}
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.callMethod(getRSF);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This is a utility method to get a common expression --
1:eac0369: 		"BaseActivation.getExecutionFactory()".
1:eac0369: 		REVISIT: could the same expression objects be reused within
1:eac0369: 		the tree and have the correct java generated each time?
1:eac0369: 		<p>
1:eac0369: 		BaseActivation gets the factory from the context and
1:eac0369: 		caches it for faster retrieval. 
1:eac0369: 	 */
1:eac0369: 	private Object getEF;
1:e077c88: 	void pushGetExecutionFactoryExpression(MethodBuilder mb) {
1:eac0369: 		if (getEF == null) {
1:eac0369: 			getEF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
1:eac0369: 					"getExecutionFactory",
1:eac0369: 					ClassName.ExecutionFactory);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// generated Java:
1:eac0369: 		//	this.getExecutionFactory()
1:eac0369: 		//
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.callMethod(getEF);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate a reference to the row array that
1:eac0369: 	 * all activations use.
1:eac0369: 	 * 
3:eac0369: 	 * @param eb the expression block
1:eac0369: 	 *
3:eac0369: 	 * @return expression
1:eac0369: 	 */
1:eac0369: 	//private void pushRowArrayReference(MethodBuilder mb)
1:eac0369: 	//{ 		
1:eac0369: 		// PUSHCOMPILE - cache
1:eac0369: 	//	mb.pushThis();
1:eac0369: 	//	mb.getField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
1:eac0369: 	//}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate a reference to a colunm in a result set.
1:eac0369: 	 * 
1:eac0369: 	 * @param rsNumber the result set number
1:eac0369: 	 * @param colId the column number
1:eac0369: 	 */
1:e077c88: 	void pushColumnReference(MethodBuilder mb, int rsNumber, int colId)
1:eac0369: 	{
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.push(rsNumber);
1:eac0369: 		mb.push(colId);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getColumnFromRow",
1:eac0369: 						ClassName.DataValueDescriptor, 2);
1:eac0369: 
1:eac0369: 		//System.out.println("pushColumnReference ");
1:eac0369: 		//pushRowArrayReference(mb);
1:eac0369: 		//mb.getArrayElement(rsNumber); // instance for getColumn
1:eac0369: 		//mb.push(colId); // first arg
1:eac0369: 		//mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Row, "getColumn", ClassName.DataValueDescriptor, 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate a reference to the parameter value
1:eac0369: 	 * set that all activations use.
1:eac0369: 	 * 
1:eac0369: 	 */
1:e077c88: 	void pushPVSReference(MethodBuilder mb)
1:eac0369: 	{
1:eac0369: 		// PUSHCOMPILER-WASCACHED
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.getField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CLASS IMPLEMENTATION
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		The first time a current datetime is needed, create the class
1:eac0369: 		level support for it.
1:eac0369: 	 */
1:eac0369: 	protected LocalField getCurrentSetup() {
1:eac0369: 		if (cdtField != null)
1:eac0369: 			return cdtField;
1:eac0369: 
1:eac0369: 		// generated Java:
1:eac0369: 		// 1) the field "cdt" is created:
1:eac0369: 		//    private CurrentDatetime cdt;
1:eac0369: 		cdtField = newFieldDeclaration(
1:eac0369: 			Modifier.PRIVATE,
1:eac0369: 			ClassName.CurrentDatetime,
1:eac0369: 			currentDatetimeFieldName);
1:eac0369: 
1:eac0369: 		// 2) the constructor gets a statement to init CurrentDatetime:
1:eac0369: 		//	  cdt = new CurrentDatetime();
1:eac0369: 
1:eac0369: 		constructor.pushNewStart(ClassName.CurrentDatetime);
1:eac0369: 		constructor.pushNewComplete(0);
1:afa871e: 		constructor.setField(cdtField);
1:eac0369: 
1:eac0369: 		return cdtField;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * generated the next field name available.
1:f873863: 	 * these are of the form 'e#', where # is
1:eac0369: 	 * incremented each time.
1:f873863: 	 * This shares the name space with the expression methods
1:f873863: 	 * as Java allows names and fields to have the same name.
1:f873863: 	 * This reduces the number of constant pool entries created
1:f873863: 	 * for a generated class file.
1:eac0369: 	 */
1:eac0369: 	private String newFieldName()
1:eac0369: 	{
1:f873863: 		return "e".concat(Integer.toString(nextFieldNum++));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// DEBUG
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// DATATYPES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeCompiler associated with the given TypeId
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The TypeId to get a TypeCompiler for
1:eac0369: 	 *
1:eac0369: 	 * @return	The corresponding TypeCompiler
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
1:eac0369: 	{
1:eac0369: 		return myCompCtx.getTypeCompilerFactory().getTypeCompiler(typeId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// GENERATE BYTE CODE
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Take the generated class, and turn it into an
1:eac0369: 	 * actual class.
1:eac0369: 	 * <p> This method assumes, does not check, that
1:eac0369: 	 * the class and its parts are all complete.
1:eac0369:  	 *
1:eac0369: 	 * @param savedBytes place to save generated bytes.
1:eac0369: 	 *	if null, it is ignored
1:eac0369: 	 * @exception StandardException thrown when exception occurs
1:eac0369: 	 */
1:e077c88: 	GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {
1:eac0369: 		if (gc != null) return gc;
1:eac0369: 
1:eac0369: 		if (savedBytes != null)
1:eac0369: 		{
1:eac0369: 			ByteArray classBytecode = cb.getClassBytecode();
1:eac0369: 
1:eac0369: 			// note: be sure to set the length since
1:eac0369: 			// the class builder allocates the byte array
1:eac0369: 			// in big chunks
1:eac0369: 			savedBytes.setBytes(classBytecode.getArray());
1:eac0369: 			savedBytes.setLength(classBytecode.getLength());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    gc =  cb.getGeneratedClass();
1:eac0369: 
1:eac0369: 		return gc; // !! yippee !! here it is...
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a "this" expression declared as an Activation.
1:eac0369: 	 * This is the commonly used type of the this expression.
1:eac0369: 	 *
1:eac0369: 	 */
1:e077c88: 	void pushThisAsActivation(MethodBuilder mb) {
1:eac0369: 		// PUSHCOMPILER - WASCACHED
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.upCast(ClassName.Activation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Generate a Null data value.
1:eac0369: 		Nothing is required on the stack, a SQL null data value
1:eac0369: 		is pushed.
1:eac0369: 	*/
1:ba7683c: 	void generateNull(MethodBuilder mb, TypeCompiler tc, int collationType) {
1:eac0369: 		pushDataValueFactory(mb);
1:eac0369: 		mb.pushNull(tc.interfaceName());
1:a1aaa63: 		tc.generateNull(mb, collationType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Generate a Null data value.
1:eac0369: 		The express value is required on the stack and will be popped, a SQL null data value
1:eac0369: 		is pushed.
1:eac0369: 	*/
1:ba7683c: 	void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc, 
1:ba7683c: 			int collationType) {
1:eac0369: 		pushDataValueFactory(mb);
1:eac0369: 		mb.swap(); // need the dvf as the instance
1:eac0369: 		mb.cast(tc.interfaceName());
1:a1aaa63: 		tc.generateNull(mb, collationType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Generate a data value.
1:eac0369: 		The value is to be set in the SQL data value is required
1:eac0369: 		on the stack and will be popped, a SQL data value
1:eac0369: 		is pushed.
1:eac0369: 	*/
1:ba7683c: 	void generateDataValue(MethodBuilder mb, TypeCompiler tc, 
1:ba7683c: 			int collationType, LocalField field) {
1:eac0369: 		pushDataValueFactory(mb);
1:eac0369: 		mb.swap(); // need the dvf as the instance
1:a1aaa63: 		tc.generateDataValue(mb, collationType, field);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 *generates a variable name for the rowscanresultset.
1:eac0369: 	 *This can not be a fixed name because in cases like
1:eac0369: 	 *cascade delete same activation class will be dealing 
1:eac0369: 	 * more than one RowScanResultSets for dependent tables.
1:eac0369: 	*/
1:eac0369: 
1:e077c88: 	String newRowLocationScanResultSetName()
1:eac0369: 	{
1:eac0369: 		currentRowScanResultSetName = newFieldName();
1:eac0369: 		return currentRowScanResultSetName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// return the Name of ResultSet with the RowLocations to be modified (deleted or updated).
1:e077c88: 	String getRowLocationScanResultSetName()
1:eac0369: 	{
1:eac0369: 		return currentRowScanResultSetName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:         ColumnOrdering[] ordering =
1:                 orderingHolder.getArray(ColumnOrdering[].class);
commit:f542632
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1: import java.io.Serializable;
1: import java.lang.reflect.Modifier;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.impl.sql.execute.IndexColumnOrder;
/////////////////////////////////////////////////////////////////////////
1:      * Get a method builder for adding code to the execute() method.
1:      * The method builder does not actually build a method called execute.
1:      * Instead, it creates a method that overrides the reinit() method,
1:      * which is called from execute() on every execution in order to
1:      * reinitialize the data structures.
1:         if (executeMethod == null) {
1:             executeMethod =
1:                     cb.newMethodBuilder(Modifier.PROTECTED, "void", "reinit");
1:             executeMethod.addThrownException(ClassName.StandardException);
1:         }
commit:0393775
/////////////////////////////////////////////////////////////////////////
0:     protected MethodBuilder staticInitializer;
/////////////////////////////////////////////////////////////////////////
0:     MethodBuilder getStaticInitializer() {
0:         if (staticInitializer == null) {
0:             staticInitializer = cb.newConstructorBuilder(Modifier.STATIC);
1:         }
0:         return staticInitializer;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Finish the static initializer, if there is one, by putting a return
1:      * at the end of it.
1:      */
0:     void finishStaticInitializer() throws StandardException {
0:         if (staticInitializer != null) {
0:             staticInitializer.methodReturn();
0:             staticInitializer.complete();
1:         }
1:     }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     FormatableArrayHolder getColumnOrdering(OrderedColumnList<?>  oclist) {
commit:ab2cc4a
/////////////////////////////////////////////////////////////////////////
1:      *    final public class #className extends #superClass {
1:      *      public #className() { super(); }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0:      *    class #className extends #superClass {
0:      *      #className() { super(); }
/////////////////////////////////////////////////////////////////////////
1:     private void beginConstructor()
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a1aaa63
/////////////////////////////////////////////////////////////////////////
1: abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
/////////////////////////////////////////////////////////////////////////
1: 		tc.generateNull(mb, collationType);
/////////////////////////////////////////////////////////////////////////
1: 		tc.generateNull(mb, collationType);
/////////////////////////////////////////////////////////////////////////
1: 		tc.generateDataValue(mb, collationType, field);
commit:a57c280
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateNull(this, mb, collationType);
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateNull(this, mb, collationType);
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateDataValue(this, mb, collationType, field);
commit:95e850d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * Get the execute method in order to add code to it.
0:      * Added code will be executed for each execution
0:      * of the activation. StatementNode completes the
0:      * execute method so that code added by other nodes
0:      * will be executed before the ResultSet is created
0:      * using fillResultSet. 
commit:bb579f8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e077c88
/////////////////////////////////////////////////////////////////////////
0: abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
/////////////////////////////////////////////////////////////////////////
1: 	CompilerContext myCompCtx;
1: 	MethodBuilder executeMethod; // to find it fast
/////////////////////////////////////////////////////////////////////////
1: 	ExpressionClassBuilder (String superClass, String className, CompilerContext cc ) 
/////////////////////////////////////////////////////////////////////////
1: 	abstract	String	getPackageName();
/////////////////////////////////////////////////////////////////////////
1: 	abstract	int		getRowCount()
/////////////////////////////////////////////////////////////////////////
1: 	abstract	void 	setNumSubqueries()
/////////////////////////////////////////////////////////////////////////
0: 	abstract	MethodBuilder	beginExecuteMethod()
/////////////////////////////////////////////////////////////////////////
0: 	abstract		void 			finishExecuteMethod(boolean		genMarkAsTopNode )
/////////////////////////////////////////////////////////////////////////
1: 	abstract String getBaseClassName();
1: 	MethodBuilder getConstructor() {
1: 	ClassBuilder getClassBuilder() {
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder getExecuteMethod() {
/////////////////////////////////////////////////////////////////////////
1: 	void finishConstructor()
/////////////////////////////////////////////////////////////////////////
1: 	LocalField newFieldDeclaration(int modifiers, String type, String name)
/////////////////////////////////////////////////////////////////////////
1: 	LocalField newFieldDeclaration(int modifiers, String type)
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder newGeneratedFun(String returnType, int modifiers) {
1: 	MethodBuilder newGeneratedFun(String returnType, 
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder newExprFun()
/////////////////////////////////////////////////////////////////////////
1: 	void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder newUserExprFun() {
/////////////////////////////////////////////////////////////////////////
1: 	void getCurrentDateExpression(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	void getCurrentTimeExpression(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	void getCurrentTimestampExpression(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	FormatableArrayHolder getColumnOrdering(ResultColumnList rclist)
/////////////////////////////////////////////////////////////////////////
1: 	FormatableArrayHolder addColumnToOrdering(
/////////////////////////////////////////////////////////////////////////
0: 	FormatableArrayHolder getColumnOrdering(OrderedColumnList  oclist) {
/////////////////////////////////////////////////////////////////////////
1: 	int addItem(Object o) 
/////////////////////////////////////////////////////////////////////////
1: 	void pushDataValueFactory(MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1: 	void pushGetResultSetFactoryExpression(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	void pushGetExecutionFactoryExpression(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
0: 	void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	void pushColumnReference(MethodBuilder mb, int rsNumber, int colId)
/////////////////////////////////////////////////////////////////////////
1: 	void pushPVSReference(MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1: 	GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1: 	void pushThisAsActivation(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
0: 	void generateNull(MethodBuilder mb, TypeCompiler tc) {
/////////////////////////////////////////////////////////////////////////
0: 	void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {
/////////////////////////////////////////////////////////////////////////
0: 	void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {
/////////////////////////////////////////////////////////////////////////
1: 	String newRowLocationScanResultSetName()
1: 	String getRowLocationScanResultSetName()
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		constructor.setField(cdtField);
commit:f873863
/////////////////////////////////////////////////////////////////////////
1: 	 * these are of the form 'e#', where # is
1: 	 * This shares the name space with the expression methods
1: 	 * as Java allows names and fields to have the same name.
1: 	 * This reduces the number of constant pool entries created
1: 	 * for a generated class file.
1: 		return "e".concat(Integer.toString(nextFieldNum++));
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ExpressionClassBuilder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
1: 
1: import org.apache.derby.iapi.services.compiler.ClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.compiler.JavaFactory;
1: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1: 
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.Row;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.impl.sql.compile.OrderedColumnList;
0: import org.apache.derby.impl.sql.compile.ResultColumnList;
0: import org.apache.derby.impl.sql.execute.IndexColumnOrder;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.TypeId;
1: 
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.util.ByteArray;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: 
0: import java.io.Serializable;
1: 
1: /**
1:  * ExpressionClassBuilder
1:  * provides an interface to satisfy generation's
1:  * common tasks in building classes that involve expressions.
1:  * This is the common superclass of ActivationClassBuilder and
1:  * FilterClassBuilder. See the documentation on ActivationClassBuilder.
1:  *
0:  * @author Rick	Extracted out of ActivationClassBuilder
1:  */
0: public abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CONSTANTS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	static final protected String currentDatetimeFieldName = "cdt";
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// STATE
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	protected ClassBuilder cb;
1: 	protected GeneratedClass gc;
1: 	protected int nextExprNum;
1: 	protected int nextNonFastExpr;
1: 	protected int nextFieldNum;
1: 	protected MethodBuilder constructor;
0: 	public	  CompilerContext myCompCtx;
0: 	public MethodBuilder executeMethod; // to find it fast
1: 
1: 	protected LocalField cdtField;
1: 
1: 	//protected final JavaFactory javaFac;
1: 
0: 	protected MethodBuilder resultSetClosedMethod;
1: 
1: 	private String currentRowScanResultSetName;
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CONSTRUCTORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * By the time this is done, it has constructed the following class:
1: 	 * <pre>
0: 	 *    public class #className extends #superClass {
0: 	 *		public #className() { super(); }
1: 	 *    }
1: 	 * </pre>
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public	ExpressionClassBuilder (String superClass, String className, CompilerContext cc ) 
1: 		throws StandardException
1: 	{
1: 		int modifiers = Modifier.PUBLIC | Modifier.FINAL;
1: 
1: 		myCompCtx = cc;
1: 		JavaFactory javaFac = myCompCtx.getJavaFactory();
1: 
1: 		if ( className == null ) { className = myCompCtx.getUniqueClassName(); }
1: 
1: 		// start the class
1: 		cb = javaFac.newClassBuilder(myCompCtx.getClassFactory(),
1: 			getPackageName(), modifiers,
1: 			className, superClass);
1: 
1: 		beginConstructor();
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get the name of the package that the generated class will live in.
1: 	 *
1: 	 *	@return	name of package that the generated class will live in.
1: 	 */
0: 	public	abstract	String	getPackageName();
1: 
1: 	/**
1: 	 * Get the number of ExecRows that must be allocated
1: 	 *
1: 	 *	@return	number of ExecRows that must be allocated
1: 	 *
1: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public	abstract	int		getRowCount()
1: 		 throws StandardException;
1: 
1: 	/**
1: 	 * Sets the number of subqueries under this expression
1: 	 *
1: 	 *
1: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public	abstract	void 	setNumSubqueries()
1: 		 throws StandardException;
1: 
1: 	/**
0: 	 * Generates an expression to refer to a named parameter.
1: 	 *
0: 	 *	@param	name		Parameter name
0: 	 *	@param	position	Parameter number
0: 	 *	@param	dataType	Parameter datatype
0: 	 *  @param	mb			The method to put the generated code into
1: 	 *
0: 	 *	@return	an expression encoding a reference to the named parameter
1: 	 *
1: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public	abstract	void	getParameterReference( String				name,
0: 														   int					position,
0: 														   DataTypeDescriptor		dataType,
0: 														   MethodBuilder mb )
1: 		 throws StandardException;
1: 
1: 	/**
0: 	 * Build boiler plate for the Execute method
1: 	 *
1: 	 *
0: 	 *	@return	a method builder containing boiler plate for the Execute method
1: 	 *
1: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public	abstract	MethodBuilder	beginExecuteMethod()
1: 		throws StandardException;
1: 
1: 
1: 	/**
0: 	 * Finish up the Execute method.
1: 	 *
1: 	 *
1: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public abstract		void 			finishExecuteMethod(boolean		genMarkAsTopNode )
1: 		throws StandardException;
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ACCESSORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		Return the base class of the activation's hierarchy
1: 		(the subclass of Object).
1: 
1: 		This class is expected to hold methods used by all
1: 		compilation code, such as datatype compilation code,
1: 		e.g. getDataValueFactory.
1: 	 */
0: 	abstract public String getBaseClassName();
1: 
0: 	public MethodBuilder getConstructor() {
1: 		return constructor;
1: 	}
1: 
0: 	public ClassBuilder getClassBuilder() {
1: 		return cb;
1: 	}
1: 
1: 	/**
0: 	 * The execute method returns a result set that will evaluate the
0: 	 * statement this activation class is the compiled form of.
0: 	 * REVISIT: do we need to give the caller the ability to touch it
0: 	 * directly, or could we wrap the alterations to it in this class?
1: 	 */
0: 	public MethodBuilder getExecuteMethod() {
1: 		return executeMethod;
1: 	}
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CONSTRUCTOR MANAGEMENT
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
0: 	private	final void	beginConstructor()
1: 	{
1: 		// create a constructor that just calls super.  
1: 		MethodBuilder realConstructor =
1: 			cb.newConstructorBuilder(Modifier.PUBLIC);
1: 		realConstructor.callSuper();
1: 		realConstructor.methodReturn();
1: 		realConstructor.complete();
1: 
1: 		constructor = cb.newMethodBuilder(Modifier.PUBLIC, "void", "postConstructor");
1: 		constructor.addThrownException(ClassName.StandardException);
1: 	}
1: 
1: 	/**
1: 	 * Finish the constructor by newing the array of Rows and putting a return 
0: 	 * at the end of it.
1: 	 *
1: 	 * @exception StandardException thrown on failure
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void finishConstructor()
1: 		 throws StandardException
1: 	{
1: 		int				numResultSets;
1: 
1: 		/* Set the number of subqueries */
1: 		setNumSubqueries();
1: 
1: 		numResultSets = getRowCount();
1: 
1: 		/* Generate the new of ExecRow[numResultSets] when there are ResultSets
1: 		 * which return Rows.
1: 		 */
1: 		if (numResultSets >= 1)
1: 		{
1: 			addNewArrayOfRows(numResultSets);
1: 		}
1: 
1: 		/* Generated code is:
1: 		 *		return;
1: 		 */
1: 		constructor.methodReturn();
1: 		constructor.complete();
1: 	}
1: 
1: 	/**
1: 	 * Generate the assignment for row = new ExecRow[numResultSets]
1: 	 *
1: 	 * @param numResultSets	The size of the array.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	private void addNewArrayOfRows(int numResultSets)
1: 	{
1: 		/* Generated code is:
1: 		 *		row = new ExecRow[numResultSets];
1: 		 */
1: 
1: 		constructor.pushThis();
1: 		constructor.pushNewArray(ClassName.ExecRow, numResultSets);
1: 		constructor.putField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
1: 		constructor.endStatement();
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ADD FIELDS TO GENERATED CLASS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Add a field declaration to the generated class
1: 	 * 
1: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
1: 	 * @param type		The type of the field in java language.
1: 	 * @param name		The name of the field.
1: 	 *
1: 	 * @return None.
1: 	 */
0: 	public LocalField newFieldDeclaration(int modifiers, String type, String name)
1: 	{
1: 		return cb.addField(type, name, modifiers);
1: 	}
1: 
1: 	/**
1: 	 * Add an arbitrarily named field to the generated class.
1: 	 *
1: 	 * This is used to generate fields where the caller doesn't care what
1: 	 * the field is named.  It is especially useful for generating arbitrary
1: 	 * numbers of fields, where the caller doesn't know in advance how many
1: 	 * fields will be used.  For example, it is used for generating fields
1: 	 * to hold intermediate values from expressions.
1: 	 *
1: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
1: 	 * @param type		The type of the field in java language.
1: 	 *
1: 	 * @return	The name of the new field
1: 	 */
1: 
0: 	public LocalField newFieldDeclaration(int modifiers, String type)
1: 	{
1: 		return cb.addField(type, newFieldName(), modifiers);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ADD FUNCTIONS TO GENERATED CLASS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Activations might have need of internal functions
1: 	 * that are not used by the result sets, but by other
1: 	 * activation functions. Thus, we make it possible
1: 	 * for functions to be generated directly as well
1: 	 * as through the newExprFun interface.  newExprFun
1: 	 * should be used when a static field pointing to the
1: 	 * expression function is needed.
1: 	 * <p>
1: 	 * The generated function will generally have a generated name
1: 	 * that can be viewed through the MethodBuilder interface.
1: 	 * This name is generated to ensure uniqueness from other
1: 	 * function names in the activation class. If you pass in a function
1: 	 * name, think carefully about whether it will collide with other names.
1: 	 *
0: 	 * @param exprName	Name of function. Usually null, which causes us to
0: 	 *					generate a unique name.
1: 	 * @param returnType the return type of the function
1: 	 * @param modifiers the modifiers on the function
1: 	 *
1: 	 * @see #newExprFun
1: 	 */
0: 	public MethodBuilder newGeneratedFun(String returnType, int modifiers) {
1: 
1: 		return newGeneratedFun(returnType, modifiers,
1: 							   (String[]) null);
1: 	}
1: 
0: 	public MethodBuilder newGeneratedFun(String returnType, 
1: 										 int modifiers,
1: 										 String[] params) {
1: 
1: 		String exprName = "g".concat(Integer.toString(nextNonFastExpr++));
1: 		return newGeneratedFun(exprName, returnType, modifiers,
1: 							   params);
1: 
1: 	}
1: 
1: 	private MethodBuilder newGeneratedFun(String exprName, String returnType, 
1: 										 int modifiers,
1: 										 String[] params) {
1: 
1: 
1: 
1: 		//
1: 		// create a new method supplying the given modifiers and return Type
1: 		// Java: #modifiers #returnType #exprName { }
1: 		//
1: 		MethodBuilder exprMethod;
1: 		if (params == null)
1: 		{
1: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, exprName);
1: 		}
1: 		else
1: 		{
1: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, 
1: 										     exprName, params);
1: 		}
1: 
1: 		//
1: 		// declare it to throw StandardException
1: 		// Java: #modifiers #returnType #exprName throws StandardException { }
1: 		//
1: 		exprMethod.addThrownException(ClassName.StandardException);
1: 
1: 		return exprMethod;
1: 	}
1: 
1: 	/**
1: 	 * "ExprFun"s are the "expression functions" that
1: 	 * are specific to a given JSQL statement. For example,
1: 	 * an ExprFun is generated to evaluate the where clause
1: 	 * of a select statement and return a boolean result.
1: 	 * <p>
1: 	 *
1: 	 * All methods return by this are expected to be called
1: 	 * via the GeneratedMethod interface. Thus the methods
1: 	 * are public and return java.lang.Object.
1: 	 * <p>
1: 	 * Once the exprfun has been created, the
1: 	 * caller will need to add statements to it,
1: 	 * minimally a return statement.
1: 	 * <p>
1: 	 * ExprFuns  return Object types, since they
1: 	 * are invoked through reflection and thus their
1: 	 * return type would get wrapped in an object anyway.
1: 	 * For example: return java.lang.Boolean, not boolean.
1: 	 */
0: 	public MethodBuilder newExprFun()
1: 	{
1: 		// get next generated function 
1: 		String exprName = "e".concat(Integer.toString(nextExprNum++));
1: 
1: 		return newGeneratedFun(exprName, "java.lang.Object", Modifier.PUBLIC, (String[]) null);
1: 	}
1: 
1: 	/**
1: 		Push an expression that is a GeneratedMethod reference to the
1: 		passed in method. aka. a "function pointer".
1: 	*/
0: 	public void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {
1: 
1: 		mb.pushThis(); // instance
1: 		mb.push(exprMethod.getName()); // arg
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,
1: 				"getMethod",
1: 				ClassName.GeneratedMethod,
1: 				1
1: 				);
1: 	}
1: 
1: 	/**
1: 	 * Start a user expression.  The difference between a normal expression
1: 	 * (returned by newExprFun)
1: 	 * and a user expression is that a user expression catches all exceptions
1: 	 * (because we don't want random exceptions thrown from user methods to
1: 	 * propagate to the rest of the system.
1: 	 *
0: 	 * @param functionName	Name to give to the function. If null, we'll generate a
0: 	 *						unique name.
0: 	 * @param returnType	A String telling the return type from the expression
1: 	 *
1: 	 * @return	A new MethodBuilder
1: 	 */
0: 	public MethodBuilder newUserExprFun() {
1: 
1: 		MethodBuilder mb = newExprFun();
1: 		mb.addThrownException("java.lang.Exception");
1: 		return mb;
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CURRENT DATE/TIME SUPPORT
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		This utility method returns an expression for CURRENT_DATE.
1: 		Get the expression this way, because the activation needs to 
1: 		generate support information for CURRENT_DATE,
1: 		that would otherwise be painful to create manually.
1: 	 */
0: 	public void getCurrentDateExpression(MethodBuilder mb) {
1: 		// do any needed setup
1: 		LocalField lf = getCurrentSetup();
1: 
1: 		// generated Java:
1: 		//	  this.cdt.getCurrentDate();
1: 		mb.getField(lf);
1: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentDate", "java.sql.Date", 0);
1: 	}
1: 
1: 	/**
1: 		This utility method returns an expression for CURRENT_TIME.
1: 		Get the expression this way, because the activation needs to 
1: 		generate support information for CURRENT_TIME,
1: 		that would otherwise be painful to create manually.
1: 	 */
0: 	public void getCurrentTimeExpression(MethodBuilder mb) {
1: 		// do any needed setup
1: 		LocalField lf = getCurrentSetup();
1: 
1: 		// generated Java:
1: 		//	  this.cdt.getCurrentTime();
1: 		mb.getField(lf);
1: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentTime", "java.sql.Time", 0);
1: 	}
1: 
1: 	/**
1: 		This utility method generates an expression for CURRENT_TIMESTAMP.
1: 		Get the expression this way, because the activation needs to 
1: 		generate support information for CURRENT_TIMESTAMP,
1: 		that would otherwise be painful to create manually.
1: 	 */
0: 	public void getCurrentTimestampExpression(MethodBuilder mb) {
1: 		// do any needed setup
1: 		LocalField lf = getCurrentSetup();
1: 
1: 		// generated Java:
1: 		//	  this.cdt.getCurrentTimestamp();
1: 		mb.getField(lf);
1: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
1: 			"getCurrentTimestamp", "java.sql.Timestamp", 0);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// COLUMN ORDERING
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1:     /**
1: 		These utility methods buffers compilation from the IndexColumnOrder
1: 		class.
1: 
1: 		They create an ordering based on their parameter, stuff that into
1: 		the prepared statement, and then return the entry # for
1: 		use in the generated code.
1: 
1: 		We could write another utility method to generate code to
1: 		turn an entry # back into an object, but so far no-one needs it.
1: 	
1: 		WARNING: this is a crafty method that ASSUMES that 
1: 		you want every column in the list ordered, and that every
1: 		column in the list is the entire actual result colunm.
1: 		It is only useful for DISTINCT in select.	
1: 	 */
0: 	public FormatableArrayHolder getColumnOrdering(ResultColumnList rclist)
1: 	{
1: 		IndexColumnOrder[] ordering;
1: 		int numCols = (rclist == null) ? 0 : rclist.size();
1: 		//skip the columns which are not exclusively part of the insert list
1:     //ie columns with default and autoincrement. These columns will not
1:     //be part of ordering.
1: 		int numRealCols = 0;
1: 		for (int i=0; i<numCols; i++)
1: 		{
1: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
1: 				numRealCols++;
1: 		}
1: 
1: 		ordering = new IndexColumnOrder[numRealCols];
1: 		for (int i=0, j=0; i<numCols; i++)
1: 		{
1: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
1: 			{
1: 				ordering[j] = new IndexColumnOrder(i);
1: 				j++;
1: 			}
1: 		}
1: 		return new FormatableArrayHolder(ordering);
1: 	}
1: 
1: 	/**
1: 	 * Add a column to the existing Ordering list.  Takes
1: 	 * a column id and only adds it if it isn't in the list.
1: 	 *
0: 	 * @param columNum	the column to add
1: 	 *
1: 	 * @return the ColumnOrdering array
1: 	 */
0: 	public FormatableArrayHolder addColumnToOrdering(
1: 						FormatableArrayHolder orderingHolder,
1: 						int columnNum)
1: 	{
1: 		/*
1: 		** We don't expect a lot of order by columns, so
1: 		** linear search.
1: 		*/
0: 		ColumnOrdering[] ordering = (ColumnOrdering[])orderingHolder.
0: 										getArray(ColumnOrdering.class);
1: 		int length = ordering.length;
1: 		for (int i = 0; i < length; i++)
1: 		{
1: 			if (ordering[i].getColumnId() == columnNum)
1: 				return orderingHolder;
1: 		}
1: 
1: 		/*
1: 		** Didn't find it.  Allocate a bigger array
1: 		** and add it to the end
1: 		*/
1: 		IndexColumnOrder[] newOrdering = new IndexColumnOrder[length+1];
1: 		System.arraycopy(ordering, 0, newOrdering, 0, length);
1: 		newOrdering[length] = new IndexColumnOrder(columnNum);
1: 		
1: 		return new FormatableArrayHolder(newOrdering);
1: 	}	
1: 
1: 
0: 	public FormatableArrayHolder getColumnOrdering(OrderedColumnList  oclist) {
1: 		int numCols = (oclist == null) ? 0 : oclist.size();
1: 
1: 		if (numCols == 0)
1: 		{
1: 			return new FormatableArrayHolder(new IndexColumnOrder[0]);
1: 		}
1: 
1: 		return new FormatableArrayHolder(oclist.getColumnOrdering());
1: 	}
1: 
0: 	public int addItem(Object o) 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if ((o != null) && !(o instanceof Serializable))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"o (" + o.getClass().getName() +
1: 					") expected to be instanceof java.io.Serializable");
1: 			}
1: 		}
1: 		return myCompCtx.addSavedObject(o);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// Caching resuable Expressions
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get/reuse the Expression for getting the DataValueFactory
1: 	 */
1: 	private Object getDVF;
0: 	public void pushDataValueFactory(MethodBuilder mb)
1: 	{
1: 		// generates:
1: 		//	   getDataValueFactory()
1: 		//
1: 
1: 		if (getDVF == null) {
1: 			getDVF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL,
1: 										getBaseClassName(),
1: 										"getDataValueFactory",
1: 										ClassName.DataValueFactory);
1: 		}
1: 
1: 		mb.pushThis();
1: 		mb.callMethod(getDVF);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// RESULT SET SUPPORT
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		This is a utility method to get a common expression --
1: 		"BaseActivation.getResultSetFactory()".
1: 		<p>
1: 		BaseActivation gets the factory from the context and
1: 		caches it for faster retrieval.
1: 	 */
1: 	private Object getRSF;
0: 	public void pushGetResultSetFactoryExpression(MethodBuilder mb) {
1: 		// generated Java:
1: 		//	this.getResultSetFactory()
1: 		//
1: 		if (getRSF == null) {
1: 			getRSF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
1: 					"getResultSetFactory",
1: 					ClassName.ResultSetFactory);
1: 		}
1: 		mb.pushThis();
1: 		mb.callMethod(getRSF);
1: 	}
1: 
1: 	/**
1: 		This is a utility method to get a common expression --
1: 		"BaseActivation.getExecutionFactory()".
1: 		REVISIT: could the same expression objects be reused within
1: 		the tree and have the correct java generated each time?
1: 		<p>
1: 		BaseActivation gets the factory from the context and
1: 		caches it for faster retrieval. 
1: 	 */
1: 	private Object getEF;
0: 	public void pushGetExecutionFactoryExpression(MethodBuilder mb) {
1: 		if (getEF == null) {
1: 			getEF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
1: 					"getExecutionFactory",
1: 					ClassName.ExecutionFactory);
1: 		}
1: 
1: 		// generated Java:
1: 		//	this.getExecutionFactory()
1: 		//
1: 		mb.pushThis();
1: 		mb.callMethod(getEF);
1: 	}
1: 
1: 	/**
0: 		This utility method returns the resultSetClosed method reference that the
0: 		activation wants called when a result set closes, to let it clean up.
0: 		This will be null if none was needed.
1: 
0: 		REMIND: because ObjectManager returns exceptions on its invoke() method
0: 		and close() is not supposed to return exceptions, we may want to
0: 		move this to be something done on open() instead of on close().
0: 		Otherwise, we have to do try/catch/THROWASSERT in the close code,
0: 		which looks unfriendly.
1: 	 */
0: 	public void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {
0: 		if (resultSetClosedMethod != null)
0: 			pushMethodReference(mb, resultSetClosedMethod);
1: 		else
0: 			mb.pushNull(ClassName.GeneratedMethod);
1: 	}
1: 
1: 	/**
1: 	 * Generate a reference to the row array that
1: 	 * all activations use.
1: 	 * 
1: 	 * @param eb the expression block
1: 	 *
1: 	 * @return expression
1: 	 */
1: 	//private void pushRowArrayReference(MethodBuilder mb)
1: 	//{ 		
1: 		// PUSHCOMPILE - cache
1: 	//	mb.pushThis();
1: 	//	mb.getField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
1: 	//}
1: 
1: 	/**
1: 	 * Generate a reference to a colunm in a result set.
1: 	 * 
1: 	 * @param eb the expression block
1: 	 * @param rsNumber the result set number
1: 	 * @param colId the column number
1: 	 *
1: 	 * @return expression
1: 	 */
0: 	public void pushColumnReference(MethodBuilder mb, int rsNumber, int colId)
1: 	{
1: 		mb.pushThis();
1: 		mb.push(rsNumber);
1: 		mb.push(colId);
1: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getColumnFromRow",
1: 						ClassName.DataValueDescriptor, 2);
1: 
1: 		//System.out.println("pushColumnReference ");
1: 		//pushRowArrayReference(mb);
1: 		//mb.getArrayElement(rsNumber); // instance for getColumn
1: 		//mb.push(colId); // first arg
1: 		//mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Row, "getColumn", ClassName.DataValueDescriptor, 1);
1: 	}
1: 
1: 	/**
1: 	 * Generate a reference to the parameter value
1: 	 * set that all activations use.
1: 	 * 
1: 	 * @param eb the expression block
1: 	 *
1: 	 * @return expression
1: 	 */
0: 	public void pushPVSReference(MethodBuilder mb)
1: 	{
1: 		// PUSHCOMPILER-WASCACHED
1: 		mb.pushThis();
1: 		mb.getField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CLASS IMPLEMENTATION
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/*
1: 		The first time a current datetime is needed, create the class
1: 		level support for it.
1: 	 */
1: 	protected LocalField getCurrentSetup() {
1: 		if (cdtField != null)
1: 			return cdtField;
1: 
1: 		// generated Java:
1: 		// 1) the field "cdt" is created:
1: 		//    private CurrentDatetime cdt;
1: 		cdtField = newFieldDeclaration(
1: 			Modifier.PRIVATE,
1: 			ClassName.CurrentDatetime,
1: 			currentDatetimeFieldName);
1: 
1: 		// 2) the constructor gets a statement to init CurrentDatetime:
1: 		//	  cdt = new CurrentDatetime();
1: 
1: 		constructor.pushNewStart(ClassName.CurrentDatetime);
1: 		constructor.pushNewComplete(0);
0: 		constructor.putField(cdtField);
1: 		constructor.endStatement();
1: 
1: 		return cdtField;
1: 	}
1: 
1: 	/**
1: 	 * generated the next field name available.
0: 	 * these are of the form 'f#', where # is
1: 	 * incremented each time.
1: 	 */
1: 	private String newFieldName()
1: 	{
0: 		return "f".concat(Integer.toString(nextFieldNum++));
1: 	}
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// DEBUG
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// DATATYPES
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the TypeCompiler associated with the given TypeId
1: 	 *
1: 	 * @param typeId	The TypeId to get a TypeCompiler for
1: 	 *
1: 	 * @return	The corresponding TypeCompiler
1: 	 *
1: 	 */
1: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
1: 	{
1: 		return myCompCtx.getTypeCompilerFactory().getTypeCompiler(typeId);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// GENERATE BYTE CODE
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Take the generated class, and turn it into an
1: 	 * actual class.
1: 	 * <p> This method assumes, does not check, that
1: 	 * the class and its parts are all complete.
1:  	 *
1: 	 * @param savedBytes place to save generated bytes.
1: 	 *	if null, it is ignored
1: 	 * @exception StandardException thrown when exception occurs
1: 	 */
0: 	public GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {
1: 		if (gc != null) return gc;
1: 
1: 		if (savedBytes != null)
1: 		{
1: 			ByteArray classBytecode = cb.getClassBytecode();
1: 
1: 			// note: be sure to set the length since
1: 			// the class builder allocates the byte array
1: 			// in big chunks
1: 			savedBytes.setBytes(classBytecode.getArray());
1: 			savedBytes.setLength(classBytecode.getLength());
1: 		}
1: 
1: 	    gc =  cb.getGeneratedClass();
1: 
1: 		return gc; // !! yippee !! here it is...
1: 	}
1: 
1: 	/**
1: 	 * Get a "this" expression declared as an Activation.
1: 	 * This is the commonly used type of the this expression.
1: 	 *
1: 	 */
0: 	public void pushThisAsActivation(MethodBuilder mb) {
1: 		// PUSHCOMPILER - WASCACHED
1: 		mb.pushThis();
1: 		mb.upCast(ClassName.Activation);
1: 	}
1: 
1: 	/**
1: 		Generate a Null data value.
1: 		Nothing is required on the stack, a SQL null data value
1: 		is pushed.
1: 	*/
0: 	public void generateNull(MethodBuilder mb, TypeCompiler tc) {
1: 		pushDataValueFactory(mb);
1: 		mb.pushNull(tc.interfaceName());
0: 		tc.generateNull(mb);
1: 	}
1: 
1: 	/**
1: 		Generate a Null data value.
1: 		The express value is required on the stack and will be popped, a SQL null data value
1: 		is pushed.
1: 	*/
0: 	public void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {
1: 		pushDataValueFactory(mb);
1: 		mb.swap(); // need the dvf as the instance
1: 		mb.cast(tc.interfaceName());
0: 		tc.generateNull(mb);
1: 	}
1: 
1: 	/**
1: 		Generate a data value.
1: 		The value is to be set in the SQL data value is required
1: 		on the stack and will be popped, a SQL data value
1: 		is pushed.
1: 	*/
0: 	public void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {
1: 		pushDataValueFactory(mb);
1: 		mb.swap(); // need the dvf as the instance
0: 		tc.generateDataValue(mb, field);
1: 	}
1: 
1: 	
1: 	/**
1: 	 *generates a variable name for the rowscanresultset.
1: 	 *This can not be a fixed name because in cases like
1: 	 *cascade delete same activation class will be dealing 
1: 	 * more than one RowScanResultSets for dependent tables.
1: 	*/
1: 
0: 	public String newRowLocationScanResultSetName()
1: 	{
1: 		currentRowScanResultSetName = newFieldName();
1: 		return currentRowScanResultSetName;
1: 	}
1: 
1: 	// return the Name of ResultSet with the RowLocations to be modified (deleted or updated).
0: 	public String getRowLocationScanResultSetName()
1: 	{
1: 		return currentRowScanResultSetName;
1: 	}
1: 
1: 	
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:869152f
/////////////////////////////////////////////////////////////////////////
0: public abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateNull(this, mb, collationType, getBaseClassName());
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateNull(this, mb, collationType, getBaseClassName());
/////////////////////////////////////////////////////////////////////////
0: 		tc.generateDataValue(this, mb, collationType, getBaseClassName(), field);
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
1: 	void generateNull(MethodBuilder mb, TypeCompiler tc, int collationType) {
0: 		tc.generateNull(mb, collationType, getBaseClassName());
/////////////////////////////////////////////////////////////////////////
1: 	void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc, 
1: 			int collationType) {
0: 		tc.generateNull(mb, collationType, getBaseClassName());
/////////////////////////////////////////////////////////////////////////
1: 	void generateDataValue(MethodBuilder mb, TypeCompiler tc, 
1: 			int collationType, LocalField field) {
0: 		tc.generateDataValue(mb, collationType, getBaseClassName(), field);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: 
0: import org.apache.derby.iapi.services.compiler.ClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
0: 
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.impl.sql.compile.OrderedColumnList;
0: import org.apache.derby.impl.sql.compile.ResultColumnList;
0: import org.apache.derby.impl.sql.execute.IndexColumnOrder;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: 
0: import java.io.Serializable;
0: 
0: /**
0:  * ExpressionClassBuilder
0:  * provides an interface to satisfy generation's
0:  * common tasks in building classes that involve expressions.
0:  * This is the common superclass of ActivationClassBuilder and
0:  * FilterClassBuilder. See the documentation on ActivationClassBuilder.
0:  *
0:  * @author Rick	Extracted out of ActivationClassBuilder
0:  */
0: public abstract	class ExpressionClassBuilder implements ExpressionClassBuilderInterface
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CONSTANTS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	static final protected String currentDatetimeFieldName = "cdt";
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// STATE
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	protected ClassBuilder cb;
0: 	protected GeneratedClass gc;
0: 	protected int nextExprNum;
0: 	protected int nextNonFastExpr;
0: 	protected int nextFieldNum;
0: 	protected MethodBuilder constructor;
0: 	public	  CompilerContext myCompCtx;
0: 	public MethodBuilder executeMethod; // to find it fast
0: 
0: 	protected LocalField cdtField;
0: 
0: 	//protected final JavaFactory javaFac;
0: 
0: 	protected MethodBuilder resultSetClosedMethod;
0: 
0: 	private String currentRowScanResultSetName;
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CONSTRUCTORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * By the time this is done, it has constructed the following class:
0: 	 * <pre>
0: 	 *    public class #className extends #superClass {
0: 	 *		public #className() { super(); }
0: 	 *    }
0: 	 * </pre>
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public	ExpressionClassBuilder (String superClass, String className, CompilerContext cc ) 
0: 		throws StandardException
0: 	{
0: 		int modifiers = Modifier.PUBLIC | Modifier.FINAL;
0: 
0: 		myCompCtx = cc;
0: 		JavaFactory javaFac = myCompCtx.getJavaFactory();
0: 
0: 		if ( className == null ) { className = myCompCtx.getUniqueClassName(); }
0: 
0: 		// start the class
0: 		cb = javaFac.newClassBuilder(myCompCtx.getClassFactory(),
0: 			getPackageName(), modifiers,
0: 			className, superClass);
0: 
0: 		beginConstructor();
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Get the name of the package that the generated class will live in.
0: 	 *
0: 	 *	@return	name of package that the generated class will live in.
0: 	 */
0: 	public	abstract	String	getPackageName();
0: 
0: 	/**
0: 	 * Get the number of ExecRows that must be allocated
0: 	 *
0: 	 *	@return	number of ExecRows that must be allocated
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public	abstract	int		getRowCount()
0: 		 throws StandardException;
0: 
0: 	/**
0: 	 * Sets the number of subqueries under this expression
0: 	 *
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public	abstract	void 	setNumSubqueries()
0: 		 throws StandardException;
0: 
0: 	/**
0: 	 * Generates an expression to refer to a named parameter.
0: 	 *
0: 	 *	@param	name		Parameter name
0: 	 *	@param	position	Parameter number
0: 	 *	@param	dataType	Parameter datatype
0: 	 *  @param	mb			The method to put the generated code into
0: 	 *
0: 	 *	@return	an expression encoding a reference to the named parameter
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public	abstract	void	getParameterReference( String				name,
0: 														   int					position,
0: 														   DataTypeDescriptor		dataType,
0: 														   MethodBuilder mb )
0: 		 throws StandardException;
0: 
0: 	/**
0: 	 * Build boiler plate for the Execute method
0: 	 *
0: 	 *
0: 	 *	@return	a method builder containing boiler plate for the Execute method
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public	abstract	MethodBuilder	beginExecuteMethod()
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Finish up the Execute method.
0: 	 *
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public abstract		void 			finishExecuteMethod(boolean		genMarkAsTopNode )
0: 		throws StandardException;
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ACCESSORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 		Return the base class of the activation's hierarchy
0: 		(the subclass of Object).
0: 
0: 		This class is expected to hold methods used by all
0: 		compilation code, such as datatype compilation code,
0: 		e.g. getDataValueFactory.
0: 	 */
0: 	abstract public String getBaseClassName();
0: 
0: 	public MethodBuilder getConstructor() {
0: 		return constructor;
0: 	}
0: 
0: 	public ClassBuilder getClassBuilder() {
0: 		return cb;
0: 	}
0: 
0: 	/**
0: 	 * The execute method returns a result set that will evaluate the
0: 	 * statement this activation class is the compiled form of.
0: 	 * REVISIT: do we need to give the caller the ability to touch it
0: 	 * directly, or could we wrap the alterations to it in this class?
0: 	 */
0: 	public MethodBuilder getExecuteMethod() {
0: 		return executeMethod;
0: 	}
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CONSTRUCTOR MANAGEMENT
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	private	final void	beginConstructor()
0: 	{
0: 		// create a constructor that just calls super.  
0: 		MethodBuilder realConstructor =
0: 			cb.newConstructorBuilder(Modifier.PUBLIC);
0: 		realConstructor.callSuper();
0: 		realConstructor.methodReturn();
0: 		realConstructor.complete();
0: 
0: 		constructor = cb.newMethodBuilder(Modifier.PUBLIC, "void", "postConstructor");
0: 		constructor.addThrownException(ClassName.StandardException);
0: 	}
0: 
0: 	/**
0: 	 * Finish the constructor by newing the array of Rows and putting a return 
0: 	 * at the end of it.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void finishConstructor()
0: 		 throws StandardException
0: 	{
0: 		int				numResultSets;
0: 
0: 		/* Set the number of subqueries */
0: 		setNumSubqueries();
0: 
0: 		numResultSets = getRowCount();
0: 
0: 		/* Generate the new of ExecRow[numResultSets] when there are ResultSets
0: 		 * which return Rows.
0: 		 */
0: 		if (numResultSets >= 1)
0: 		{
0: 			addNewArrayOfRows(numResultSets);
0: 		}
0: 
0: 		/* Generated code is:
0: 		 *		return;
0: 		 */
0: 		constructor.methodReturn();
0: 		constructor.complete();
0: 	}
0: 
0: 	/**
0: 	 * Generate the assignment for row = new ExecRow[numResultSets]
0: 	 *
0: 	 * @param numResultSets	The size of the array.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	private void addNewArrayOfRows(int numResultSets)
0: 	{
0: 		/* Generated code is:
0: 		 *		row = new ExecRow[numResultSets];
0: 		 */
0: 
0: 		constructor.pushThis();
0: 		constructor.pushNewArray(ClassName.ExecRow, numResultSets);
0: 		constructor.putField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
0: 		constructor.endStatement();
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ADD FIELDS TO GENERATED CLASS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Add a field declaration to the generated class
0: 	 * 
0: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
0: 	 * @param type		The type of the field in java language.
0: 	 * @param name		The name of the field.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public LocalField newFieldDeclaration(int modifiers, String type, String name)
0: 	{
0: 		return cb.addField(type, name, modifiers);
0: 	}
0: 
0: 	/**
0: 	 * Add an arbitrarily named field to the generated class.
0: 	 *
0: 	 * This is used to generate fields where the caller doesn't care what
0: 	 * the field is named.  It is especially useful for generating arbitrary
0: 	 * numbers of fields, where the caller doesn't know in advance how many
0: 	 * fields will be used.  For example, it is used for generating fields
0: 	 * to hold intermediate values from expressions.
0: 	 *
0: 	 * @param modifiers	The | of the modifier values such as public, static, etc.
0: 	 * @param type		The type of the field in java language.
0: 	 *
0: 	 * @return	The name of the new field
0: 	 */
0: 
0: 	public LocalField newFieldDeclaration(int modifiers, String type)
0: 	{
0: 		return cb.addField(type, newFieldName(), modifiers);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ADD FUNCTIONS TO GENERATED CLASS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Activations might have need of internal functions
0: 	 * that are not used by the result sets, but by other
0: 	 * activation functions. Thus, we make it possible
0: 	 * for functions to be generated directly as well
0: 	 * as through the newExprFun interface.  newExprFun
0: 	 * should be used when a static field pointing to the
0: 	 * expression function is needed.
0: 	 * <p>
0: 	 * The generated function will generally have a generated name
0: 	 * that can be viewed through the MethodBuilder interface.
0: 	 * This name is generated to ensure uniqueness from other
0: 	 * function names in the activation class. If you pass in a function
0: 	 * name, think carefully about whether it will collide with other names.
0: 	 *
0: 	 * @param exprName	Name of function. Usually null, which causes us to
0: 	 *					generate a unique name.
0: 	 * @param returnType the return type of the function
0: 	 * @param modifiers the modifiers on the function
0: 	 *
0: 	 * @see #newExprFun
0: 	 */
0: 	public MethodBuilder newGeneratedFun(String returnType, int modifiers) {
0: 
0: 		return newGeneratedFun(returnType, modifiers,
0: 							   (String[]) null);
0: 	}
0: 
0: 	public MethodBuilder newGeneratedFun(String returnType, 
0: 										 int modifiers,
0: 										 String[] params) {
0: 
0: 		String exprName = "g".concat(Integer.toString(nextNonFastExpr++));
0: 		return newGeneratedFun(exprName, returnType, modifiers,
0: 							   params);
0: 
0: 	}
0: 
0: 	private MethodBuilder newGeneratedFun(String exprName, String returnType, 
0: 										 int modifiers,
0: 										 String[] params) {
0: 
0: 
0: 
0: 		//
0: 		// create a new method supplying the given modifiers and return Type
0: 		// Java: #modifiers #returnType #exprName { }
0: 		//
0: 		MethodBuilder exprMethod;
0: 		if (params == null)
0: 		{
0: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, exprName);
0: 		}
0: 		else
0: 		{
0: 			exprMethod = cb.newMethodBuilder(modifiers, returnType, 
0: 										     exprName, params);
0: 		}
0: 
0: 		//
0: 		// declare it to throw StandardException
0: 		// Java: #modifiers #returnType #exprName throws StandardException { }
0: 		//
0: 		exprMethod.addThrownException(ClassName.StandardException);
0: 
0: 		return exprMethod;
0: 	}
0: 
0: 	/**
0: 	 * "ExprFun"s are the "expression functions" that
0: 	 * are specific to a given JSQL statement. For example,
0: 	 * an ExprFun is generated to evaluate the where clause
0: 	 * of a select statement and return a boolean result.
0: 	 * <p>
0: 	 *
0: 	 * All methods return by this are expected to be called
0: 	 * via the GeneratedMethod interface. Thus the methods
0: 	 * are public and return java.lang.Object.
0: 	 * <p>
0: 	 * Once the exprfun has been created, the
0: 	 * caller will need to add statements to it,
0: 	 * minimally a return statement.
0: 	 * <p>
0: 	 * ExprFuns  return Object types, since they
0: 	 * are invoked through reflection and thus their
0: 	 * return type would get wrapped in an object anyway.
0: 	 * For example: return java.lang.Boolean, not boolean.
0: 	 */
0: 	public MethodBuilder newExprFun()
0: 	{
0: 		// get next generated function 
0: 		String exprName = "e".concat(Integer.toString(nextExprNum++));
0: 
0: 		return newGeneratedFun(exprName, "java.lang.Object", Modifier.PUBLIC, (String[]) null);
0: 	}
0: 
0: 	/**
0: 		Push an expression that is a GeneratedMethod reference to the
0: 		passed in method. aka. a "function pointer".
0: 	*/
0: 	public void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {
0: 
0: 		mb.pushThis(); // instance
0: 		mb.push(exprMethod.getName()); // arg
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,
0: 				"getMethod",
0: 				ClassName.GeneratedMethod,
0: 				1
0: 				);
0: 	}
0: 
0: 	/**
0: 	 * Start a user expression.  The difference between a normal expression
0: 	 * (returned by newExprFun)
0: 	 * and a user expression is that a user expression catches all exceptions
0: 	 * (because we don't want random exceptions thrown from user methods to
0: 	 * propagate to the rest of the system.
0: 	 *
0: 	 * @param functionName	Name to give to the function. If null, we'll generate a
0: 	 *						unique name.
0: 	 * @param returnType	A String telling the return type from the expression
0: 	 *
0: 	 * @return	A new MethodBuilder
0: 	 */
0: 	public MethodBuilder newUserExprFun() {
0: 
0: 		MethodBuilder mb = newExprFun();
0: 		mb.addThrownException("java.lang.Exception");
0: 		return mb;
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CURRENT DATE/TIME SUPPORT
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 		This utility method returns an expression for CURRENT_DATE.
0: 		Get the expression this way, because the activation needs to 
0: 		generate support information for CURRENT_DATE,
0: 		that would otherwise be painful to create manually.
0: 	 */
0: 	public void getCurrentDateExpression(MethodBuilder mb) {
0: 		// do any needed setup
0: 		LocalField lf = getCurrentSetup();
0: 
0: 		// generated Java:
0: 		//	  this.cdt.getCurrentDate();
0: 		mb.getField(lf);
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentDate", "java.sql.Date", 0);
0: 	}
0: 
0: 	/**
0: 		This utility method returns an expression for CURRENT_TIME.
0: 		Get the expression this way, because the activation needs to 
0: 		generate support information for CURRENT_TIME,
0: 		that would otherwise be painful to create manually.
0: 	 */
0: 	public void getCurrentTimeExpression(MethodBuilder mb) {
0: 		// do any needed setup
0: 		LocalField lf = getCurrentSetup();
0: 
0: 		// generated Java:
0: 		//	  this.cdt.getCurrentTime();
0: 		mb.getField(lf);
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentTime", "java.sql.Time", 0);
0: 	}
0: 
0: 	/**
0: 		This utility method generates an expression for CURRENT_TIMESTAMP.
0: 		Get the expression this way, because the activation needs to 
0: 		generate support information for CURRENT_TIMESTAMP,
0: 		that would otherwise be painful to create manually.
0: 	 */
0: 	public void getCurrentTimestampExpression(MethodBuilder mb) {
0: 		// do any needed setup
0: 		LocalField lf = getCurrentSetup();
0: 
0: 		// generated Java:
0: 		//	  this.cdt.getCurrentTimestamp();
0: 		mb.getField(lf);
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
0: 			"getCurrentTimestamp", "java.sql.Timestamp", 0);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// COLUMN ORDERING
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0:     /**
0: 		These utility methods buffers compilation from the IndexColumnOrder
0: 		class.
0: 
0: 		They create an ordering based on their parameter, stuff that into
0: 		the prepared statement, and then return the entry # for
0: 		use in the generated code.
0: 
0: 		We could write another utility method to generate code to
0: 		turn an entry # back into an object, but so far no-one needs it.
0: 	
0: 		WARNING: this is a crafty method that ASSUMES that 
0: 		you want every column in the list ordered, and that every
0: 		column in the list is the entire actual result colunm.
0: 		It is only useful for DISTINCT in select.	
0: 	 */
0: 	public FormatableArrayHolder getColumnOrdering(ResultColumnList rclist)
0: 	{
0: 		IndexColumnOrder[] ordering;
0: 		int numCols = (rclist == null) ? 0 : rclist.size();
0: 		//skip the columns which are not exclusively part of the insert list
0:     //ie columns with default and autoincrement. These columns will not
0:     //be part of ordering.
0: 		int numRealCols = 0;
0: 		for (int i=0; i<numCols; i++)
0: 		{
0: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
0: 				numRealCols++;
0: 		}
0: 
0: 		ordering = new IndexColumnOrder[numRealCols];
0: 		for (int i=0, j=0; i<numCols; i++)
0: 		{
0: 			if (!(rclist.getResultColumn(i+1).isGeneratedForUnmatchedColumnInInsert()))
0: 			{
0: 				ordering[j] = new IndexColumnOrder(i);
0: 				j++;
0: 			}
0: 		}
0: 		return new FormatableArrayHolder(ordering);
0: 	}
0: 
0: 	/**
0: 	 * Add a column to the existing Ordering list.  Takes
0: 	 * a column id and only adds it if it isn't in the list.
0: 	 *
0: 	 * @param columNum	the column to add
0: 	 *
0: 	 * @return the ColumnOrdering array
0: 	 */
0: 	public FormatableArrayHolder addColumnToOrdering(
0: 						FormatableArrayHolder orderingHolder,
0: 						int columnNum)
0: 	{
0: 		/*
0: 		** We don't expect a lot of order by columns, so
0: 		** linear search.
0: 		*/
0: 		ColumnOrdering[] ordering = (ColumnOrdering[])orderingHolder.
0: 										getArray(ColumnOrdering.class);
0: 		int length = ordering.length;
0: 		for (int i = 0; i < length; i++)
0: 		{
0: 			if (ordering[i].getColumnId() == columnNum)
0: 				return orderingHolder;
0: 		}
0: 
0: 		/*
0: 		** Didn't find it.  Allocate a bigger array
0: 		** and add it to the end
0: 		*/
0: 		IndexColumnOrder[] newOrdering = new IndexColumnOrder[length+1];
0: 		System.arraycopy(ordering, 0, newOrdering, 0, length);
0: 		newOrdering[length] = new IndexColumnOrder(columnNum);
0: 		
0: 		return new FormatableArrayHolder(newOrdering);
0: 	}	
0: 
0: 
0: 	public FormatableArrayHolder getColumnOrdering(OrderedColumnList  oclist) {
0: 		int numCols = (oclist == null) ? 0 : oclist.size();
0: 
0: 		if (numCols == 0)
0: 		{
0: 			return new FormatableArrayHolder(new IndexColumnOrder[0]);
0: 		}
0: 
0: 		return new FormatableArrayHolder(oclist.getColumnOrdering());
0: 	}
0: 
0: 	public int addItem(Object o) 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if ((o != null) && !(o instanceof Serializable))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"o (" + o.getClass().getName() +
0: 					") expected to be instanceof java.io.Serializable");
0: 			}
0: 		}
0: 		return myCompCtx.addSavedObject(o);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// Caching resuable Expressions
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Get/reuse the Expression for getting the DataValueFactory
0: 	 */
0: 	private Object getDVF;
0: 	public void pushDataValueFactory(MethodBuilder mb)
0: 	{
0: 		// generates:
0: 		//	   getDataValueFactory()
0: 		//
0: 
0: 		if (getDVF == null) {
0: 			getDVF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL,
0: 										getBaseClassName(),
0: 										"getDataValueFactory",
0: 										ClassName.DataValueFactory);
0: 		}
0: 
0: 		mb.pushThis();
0: 		mb.callMethod(getDVF);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// RESULT SET SUPPORT
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 		This is a utility method to get a common expression --
0: 		"BaseActivation.getResultSetFactory()".
0: 		<p>
0: 		BaseActivation gets the factory from the context and
0: 		caches it for faster retrieval.
0: 	 */
0: 	private Object getRSF;
0: 	public void pushGetResultSetFactoryExpression(MethodBuilder mb) {
0: 		// generated Java:
0: 		//	this.getResultSetFactory()
0: 		//
0: 		if (getRSF == null) {
0: 			getRSF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
0: 					"getResultSetFactory",
0: 					ClassName.ResultSetFactory);
0: 		}
0: 		mb.pushThis();
0: 		mb.callMethod(getRSF);
0: 	}
0: 
0: 	/**
0: 		This is a utility method to get a common expression --
0: 		"BaseActivation.getExecutionFactory()".
0: 		REVISIT: could the same expression objects be reused within
0: 		the tree and have the correct java generated each time?
0: 		<p>
0: 		BaseActivation gets the factory from the context and
0: 		caches it for faster retrieval. 
0: 	 */
0: 	private Object getEF;
0: 	public void pushGetExecutionFactoryExpression(MethodBuilder mb) {
0: 		if (getEF == null) {
0: 			getEF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL, getBaseClassName(),
0: 					"getExecutionFactory",
0: 					ClassName.ExecutionFactory);
0: 		}
0: 
0: 		// generated Java:
0: 		//	this.getExecutionFactory()
0: 		//
0: 		mb.pushThis();
0: 		mb.callMethod(getEF);
0: 	}
0: 
0: 	/**
0: 		This utility method returns the resultSetClosed method reference that the
0: 		activation wants called when a result set closes, to let it clean up.
0: 		This will be null if none was needed.
0: 
0: 		REMIND: because ObjectManager returns exceptions on its invoke() method
0: 		and close() is not supposed to return exceptions, we may want to
0: 		move this to be something done on open() instead of on close().
0: 		Otherwise, we have to do try/catch/THROWASSERT in the close code,
0: 		which looks unfriendly.
0: 	 */
0: 	public void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {
0: 		if (resultSetClosedMethod != null)
0: 			pushMethodReference(mb, resultSetClosedMethod);
0: 		else
0: 			mb.pushNull(ClassName.GeneratedMethod);
0: 	}
0: 
0: 	/**
0: 	 * Generate a reference to the row array that
0: 	 * all activations use.
0: 	 * 
0: 	 * @param eb the expression block
0: 	 *
0: 	 * @return expression
0: 	 */
0: 	//private void pushRowArrayReference(MethodBuilder mb)
0: 	//{ 		
0: 		// PUSHCOMPILE - cache
0: 	//	mb.pushThis();
0: 	//	mb.getField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
0: 	//}
0: 
0: 	/**
0: 	 * Generate a reference to a colunm in a result set.
0: 	 * 
0: 	 * @param eb the expression block
0: 	 * @param rsNumber the result set number
0: 	 * @param colId the column number
0: 	 *
0: 	 * @return expression
0: 	 */
0: 	public void pushColumnReference(MethodBuilder mb, int rsNumber, int colId)
0: 	{
0: 		mb.pushThis();
0: 		mb.push(rsNumber);
0: 		mb.push(colId);
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "getColumnFromRow",
0: 						ClassName.DataValueDescriptor, 2);
0: 
0: 		//System.out.println("pushColumnReference ");
0: 		//pushRowArrayReference(mb);
0: 		//mb.getArrayElement(rsNumber); // instance for getColumn
0: 		//mb.push(colId); // first arg
0: 		//mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Row, "getColumn", ClassName.DataValueDescriptor, 1);
0: 	}
0: 
0: 	/**
0: 	 * Generate a reference to the parameter value
0: 	 * set that all activations use.
0: 	 * 
0: 	 * @param eb the expression block
0: 	 *
0: 	 * @return expression
0: 	 */
0: 	public void pushPVSReference(MethodBuilder mb)
0: 	{
0: 		// PUSHCOMPILER-WASCACHED
0: 		mb.pushThis();
0: 		mb.getField(ClassName.BaseActivation, "pvs", ClassName.ParameterValueSet);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CLASS IMPLEMENTATION
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/*
0: 		The first time a current datetime is needed, create the class
0: 		level support for it.
0: 	 */
0: 	protected LocalField getCurrentSetup() {
0: 		if (cdtField != null)
0: 			return cdtField;
0: 
0: 		// generated Java:
0: 		// 1) the field "cdt" is created:
0: 		//    private CurrentDatetime cdt;
0: 		cdtField = newFieldDeclaration(
0: 			Modifier.PRIVATE,
0: 			ClassName.CurrentDatetime,
0: 			currentDatetimeFieldName);
0: 
0: 		// 2) the constructor gets a statement to init CurrentDatetime:
0: 		//	  cdt = new CurrentDatetime();
0: 
0: 		constructor.pushNewStart(ClassName.CurrentDatetime);
0: 		constructor.pushNewComplete(0);
0: 		constructor.putField(cdtField);
0: 		constructor.endStatement();
0: 
0: 		return cdtField;
0: 	}
0: 
0: 	/**
0: 	 * generated the next field name available.
0: 	 * these are of the form 'f#', where # is
0: 	 * incremented each time.
0: 	 */
0: 	private String newFieldName()
0: 	{
0: 		return "f".concat(Integer.toString(nextFieldNum++));
0: 	}
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// DEBUG
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// DATATYPES
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Get the TypeCompiler associated with the given TypeId
0: 	 *
0: 	 * @param typeId	The TypeId to get a TypeCompiler for
0: 	 *
0: 	 * @return	The corresponding TypeCompiler
0: 	 *
0: 	 */
0: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
0: 	{
0: 		return myCompCtx.getTypeCompilerFactory().getTypeCompiler(typeId);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// GENERATE BYTE CODE
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Take the generated class, and turn it into an
0: 	 * actual class.
0: 	 * <p> This method assumes, does not check, that
0: 	 * the class and its parts are all complete.
0:  	 *
0: 	 * @param savedBytes place to save generated bytes.
0: 	 *	if null, it is ignored
0: 	 * @exception StandardException thrown when exception occurs
0: 	 */
0: 	public GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {
0: 		if (gc != null) return gc;
0: 
0: 		if (savedBytes != null)
0: 		{
0: 			ByteArray classBytecode = cb.getClassBytecode();
0: 
0: 			// note: be sure to set the length since
0: 			// the class builder allocates the byte array
0: 			// in big chunks
0: 			savedBytes.setBytes(classBytecode.getArray());
0: 			savedBytes.setLength(classBytecode.getLength());
0: 		}
0: 
0: 	    gc =  cb.getGeneratedClass();
0: 
0: 		return gc; // !! yippee !! here it is...
0: 	}
0: 
0: 	/**
0: 	 * Get a "this" expression declared as an Activation.
0: 	 * This is the commonly used type of the this expression.
0: 	 *
0: 	 */
0: 	public void pushThisAsActivation(MethodBuilder mb) {
0: 		// PUSHCOMPILER - WASCACHED
0: 		mb.pushThis();
0: 		mb.upCast(ClassName.Activation);
0: 	}
0: 
0: 	/**
0: 		Generate a Null data value.
0: 		Nothing is required on the stack, a SQL null data value
0: 		is pushed.
0: 	*/
0: 	public void generateNull(MethodBuilder mb, TypeCompiler tc) {
0: 		pushDataValueFactory(mb);
0: 		mb.pushNull(tc.interfaceName());
0: 		tc.generateNull(mb);
0: 	}
0: 
0: 	/**
0: 		Generate a Null data value.
0: 		The express value is required on the stack and will be popped, a SQL null data value
0: 		is pushed.
0: 	*/
0: 	public void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {
0: 		pushDataValueFactory(mb);
0: 		mb.swap(); // need the dvf as the instance
0: 		mb.cast(tc.interfaceName());
0: 		tc.generateNull(mb);
0: 	}
0: 
0: 	/**
0: 		Generate a data value.
0: 		The value is to be set in the SQL data value is required
0: 		on the stack and will be popped, a SQL data value
0: 		is pushed.
0: 	*/
0: 	public void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {
0: 		pushDataValueFactory(mb);
0: 		mb.swap(); // need the dvf as the instance
0: 		tc.generateDataValue(mb, field);
0: 	}
0: 
0: 	
0: 	/**
0: 	 *generates a variable name for the rowscanresultset.
0: 	 *This can not be a fixed name because in cases like
0: 	 *cascade delete same activation class will be dealing 
0: 	 * more than one RowScanResultSets for dependent tables.
0: 	*/
0: 
0: 	public String newRowLocationScanResultSetName()
0: 	{
0: 		currentRowScanResultSetName = newFieldName();
0: 		return currentRowScanResultSetName;
0: 	}
0: 
0: 	// return the Name of ResultSet with the RowLocations to be modified (deleted or updated).
0: 	public String getRowLocationScanResultSetName()
0: 	{
0: 		return currentRowScanResultSetName;
0: 	}
0: 
0: 	
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================