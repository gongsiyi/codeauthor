1:1725dd1: /*
1:1725dd1: 
1:1725dd1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.TriggerWhenClauseTest
1:1725dd1: 
1:1725dd1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:1725dd1:    contributor license agreements.  See the NOTICE file distributed with
1:1725dd1:    this work for additional information regarding copyright ownership.
1:1725dd1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:1725dd1:    (the "License"); you may not use this file except in compliance with
1:1725dd1:    the License.  You may obtain a copy of the License at
1:1725dd1: 
1:1725dd1:       http://www.apache.org/licenses/LICENSE-2.0
1:1725dd1: 
1:1725dd1:    Unless required by applicable law or agreed to in writing, software
1:1725dd1:    distributed under the License is distributed on an "AS IS" BASIS,
1:1725dd1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1725dd1:    See the License for the specific language governing permissions and
1:1725dd1:    limitations under the License.
1:1725dd1: 
1:1725dd1:  */
1:1725dd1: 
1:1725dd1: package org.apache.derbyTesting.functionTests.tests.lang;
1:1725dd1: 
1:75fbb86: import java.sql.Connection;
1:a50f895: import java.sql.DriverManager;
1:00b0dbe: import java.sql.PreparedStatement;
1:a50f895: import java.sql.ResultSet;
1:1725dd1: import java.sql.SQLException;
1:d23659a: import java.sql.Savepoint;
1:1725dd1: import java.sql.Statement;
1:6a17f80: import java.util.ArrayList;
1:6a17f80: import java.util.Arrays;
1:6a17f80: import java.util.Collections;
1:6a17f80: import java.util.List;
1:1725dd1: import junit.framework.Test;
1:1725dd1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:c955b82: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1725dd1: import org.apache.derbyTesting.junit.JDBC;
1:1725dd1: import org.apache.derbyTesting.junit.TestConfiguration;
1:1725dd1: 
1:1725dd1: /**
1:1725dd1:  * Tests for the WHEN clause in CREATE TRIGGER statements, added in DERBY-534.
1:1725dd1:  */
1:1725dd1: public class TriggerWhenClauseTest extends BaseJDBCTestCase {
1:1725dd1: 
1:6a17f80:     /**
1:6a17f80:      * List that tracks calls to {@code intProcedure()}. It is used to verify
1:6a17f80:      * that triggers have fired.
1:6a17f80:      */
1:6a17f80:     private static List<Integer> procedureCalls;
1:6a17f80: 
1:df73e36:     private static final String SYNTAX_ERROR = "42X01";
1:51f910f:     private static final String REFERENCES_SESSION_SCHEMA = "XCL51";
1:df73e36:     private static final String NOT_BOOLEAN = "42X19";
1:df73e36:     private static final String HAS_PARAMETER = "42Y27";
1:d23659a:     private static final String HAS_DEPENDENTS = "X0Y25";
1:d23659a:     private static final String TABLE_DOES_NOT_EXIST = "42X05";
1:50734d8:     private static final String TRUNCATION = "22001";
1:c955b82:     private static final String NOT_AUTHORIZED = "42504";
1:c955b82:     private static final String NO_TABLE_PERMISSION = "42500";
1:c955b82:     private static final String USER_EXCEPTION = "38000";
1:c955b82:     private static final String JAVA_EXCEPTION = "XJ001";
1:05b022f:     private static final String NOT_SINGLE_COLUMN = "42X39";
1:05b022f:     private static final String NON_SCALAR_QUERY = "21000";
1:1061fd2:     private static final String TRIGGER_RECURSION = "54038";
1:a50f895:     private static final String PROC_USED_AS_FUNC = "42Y03";
1:51f910f: 
1:1725dd1:     public TriggerWhenClauseTest(String name) {
1:1725dd1:         super(name);
1:1725dd1:     }
1:1725dd1: 
1:1725dd1:     public static Test suite() {
1:c955b82:         return TestConfiguration.sqlAuthorizationDecorator(
1:c955b82:             new CleanDatabaseTestSetup(
1:c955b82:                 TestConfiguration.embeddedSuite(TriggerWhenClauseTest.class)));
1:1725dd1:     }
1:1725dd1: 
1:75fbb86:     @Override
1:75fbb86:     protected void initializeConnection(Connection conn) throws SQLException {
1:75fbb86:         // Run the test cases with auto-commit off so that all changes to
1:75fbb86:         // the database can be rolled back in tearDown().
1:75fbb86:         conn.setAutoCommit(false);
1:75fbb86:     }
1:75fbb86: 
1:6a17f80:     @Override
1:6a17f80:     protected void setUp() {
1:6a17f80:         procedureCalls = Collections.synchronizedList(new ArrayList<Integer>());
1:6a17f80:     }
1:6a17f80: 
1:6a17f80:     @Override
1:6a17f80:     protected void tearDown() throws Exception {
1:6a17f80:         procedureCalls = null;
1:6a17f80:         super.tearDown();
1:6a17f80:     }
1:6a17f80: 
1:6a17f80:     /**
1:6a17f80:      * A procedure that takes an {@code int} argument and adds it to the
1:6a17f80:      * {@link #procedureCalls} list. Can be used as a stored procedure to
1:6a17f80:      * verify that a trigger has been called. Particularly useful in BEFORE
1:6a17f80:      * triggers, as they are not allowed to modify SQL data.
1:6a17f80:      *
1:6a17f80:      * @param i an integer
1:6a17f80:      */
1:6a17f80:     public static void intProcedure(int i) {
1:6a17f80:         procedureCalls.add(i);
1:6a17f80:     }
1:6a17f80: 
1:1725dd1:     public void testBasicSyntax() throws SQLException {
1:1725dd1:         Statement s = createStatement();
1:1725dd1:         s.execute("create table t1(x int)");
1:1725dd1:         s.execute("create table t2(y varchar(20))");
1:1725dd1: 
1:1725dd1:         // Create after triggers that should always be executed. Create row
1:1725dd1:         // trigger, statement trigger and implicit statement trigger.
1:d9878ca:         s.execute("create trigger tr01 after insert on t1 for each row "
1:d9878ca:                 + "when (true) insert into t2 values 'Executed tr01'");
1:d9878ca:         s.execute("create trigger tr02 after insert on t1 for each statement "
1:d9878ca:                 + "when (true) insert into t2 values 'Executed tr02'");
1:d9878ca:         s.execute("create trigger tr03 after insert on t1 "
1:d9878ca:                 + "when (true) insert into t2 values 'Executed tr03'");
1:1725dd1: 
1:1725dd1:         // Create corresponding triggers that should never fire (their WHEN
1:1725dd1:         // clause is false).
1:d9878ca:         s.execute("create trigger tr04 after insert on t1 for each row "
1:d9878ca:                 + "when (false) insert into t2 values 'Executed tr04'");
1:d9878ca:         s.execute("create trigger tr05 after insert on t1 for each statement "
1:d9878ca:                 + "when (false) insert into t2 values 'Executed tr05'");
1:d9878ca:         s.execute("create trigger tr06 after insert on t1 "
1:d9878ca:                 + "when (false) insert into t2 values 'Executed tr06'");
1:1725dd1: 
1:1725dd1:         // Create triggers with EXISTS subqueries in the WHEN clause. The
1:1725dd1:         // first returns TRUE and the second returns FALSE.
1:d9878ca:         s.execute("create trigger tr07 after insert on t1 "
1:1725dd1:                 + "when (exists (select * from sysibm.sysdummy1)) "
1:d9878ca:                 + "insert into t2 values 'Executed tr07'");
1:d9878ca:         s.execute("create trigger tr08 after insert on t1 "
1:1725dd1:                 + "when (exists "
1:1725dd1:                 + "(select * from sysibm.sysdummy1 where ibmreqd <> 'Y')) "
1:d9878ca:                 + "insert into t2 values 'Executed tr08'");
1:1725dd1: 
1:1725dd1:         // WHEN clause returns NULL, trigger should not be fired.
1:d9878ca:         s.execute("create trigger tr09 after insert on t1 "
1:1725dd1:                 + "when (cast(null as boolean))"
1:d9878ca:                 + "insert into t2 values 'Executed tr09'");
1:d9878ca: 
1:d9878ca:         // WHEN clause contains reference to a transition variable.
1:d9878ca:         s.execute("create trigger tr10 after insert on t1 "
1:d9878ca:                 + "referencing new as new for each row "
1:d9878ca:                 + "when (new.x <> 2) insert into t2 values 'Executed tr10'");
1:d9878ca: 
1:d9878ca:         // WHEN clause contains reference to a transition table.
1:d9878ca:         s.execute("create trigger tr11 after insert on t1 "
1:d9878ca:                 + "referencing new table as new "
1:d9878ca:                 + "when (exists (select * from new where x > 5)) "
1:d9878ca:                 + "insert into t2 values 'Executed tr11'");
1:1725dd1: 
1:df73e36:         // Scalar subqueries are allowed in the WHEN clause, but they need an
1:df73e36:         // extra set of parantheses.
1:df73e36:         //
1:df73e36:         // The first set of parantheses is required by the WHEN clause syntax
1:df73e36:         // itself: WHEN ( <search condition> )
1:df73e36:         //
1:df73e36:         // The second set of parantheses is required by <search condition>.
1:df73e36:         // Follow this path through the SQL standard's syntax rules:
1:df73e36:         //    <search condition> -> <boolean value expression>
1:df73e36:         //      -> <boolean term> -> <boolean factor> -> <boolean test>
1:df73e36:         //      -> <boolean primary> -> <boolean predicand>
1:df73e36:         //      -> <nonparenthesized value expression primary>
1:df73e36:         //      -> <scalar subquery> -> <subquery> -> <left paren>
1:df73e36:         assertCompileError(SYNTAX_ERROR,
1:df73e36:                 "create trigger tr12 after insert on t1 "
1:df73e36:                 + "when (values true) insert into t2 values 'Executed tr12'");
1:df73e36:         assertCompileError(SYNTAX_ERROR,
1:df73e36:                 "create trigger tr13 after insert on t1 "
1:df73e36:                 + "when (select true from sysibm.sysdummy1) "
1:df73e36:                 + "insert into t2 values 'Executed tr13'");
1:df73e36:         s.execute("create trigger tr12 after insert on t1 "
1:df73e36:                 + "when ((values true)) insert into t2 values 'Executed tr12'");
1:df73e36:         s.execute("create trigger tr13 after insert on t1 "
1:df73e36:                 + "when ((select true from sysibm.sysdummy1)) "
1:df73e36:                 + "insert into t2 values 'Executed tr13'");
1:df73e36: 
1:1725dd1:         // Now fire the triggers and verify the results.
1:1725dd1:         assertUpdateCount(s, 3, "insert into t1 values 1, 2, 3");
1:1725dd1:         JDBC.assertFullResultSet(
1:1725dd1:             s.executeQuery("select y, count(*) from t2 group by y order by y"),
1:1725dd1:             new String[][] {
1:d9878ca:                 { "Executed tr01", "3" },
1:d9878ca:                 { "Executed tr02", "1" },
1:d9878ca:                 { "Executed tr03", "1" },
1:d9878ca:                 { "Executed tr07", "1" },
1:d9878ca:                 { "Executed tr10", "2" },
1:df73e36:                 { "Executed tr12", "1" },
1:df73e36:                 { "Executed tr13", "1" },
1:d9878ca:             });
1:d9878ca: 
1:d9878ca:         // Empty t2 before firing the triggers again.
1:d9878ca:         s.execute("delete from t2");
1:d9878ca: 
1:d9878ca:         // Insert more rows with different values and see that a slightly
1:d9878ca:         // different set of triggers get fired.
1:d9878ca:         assertUpdateCount(s, 2, "insert into t1 values 2, 6");
1:d9878ca:         JDBC.assertFullResultSet(
1:d9878ca:             s.executeQuery("select y, count(*) from t2 group by y order by y"),
1:d9878ca:             new String[][] {
1:d9878ca:                 { "Executed tr01", "2" },
1:d9878ca:                 { "Executed tr02", "1" },
1:d9878ca:                 { "Executed tr03", "1" },
1:d9878ca:                 { "Executed tr07", "1" },
1:d9878ca:                 { "Executed tr10", "1" },
1:d9878ca:                 { "Executed tr11", "1" },
1:df73e36:                 { "Executed tr12", "1" },
1:df73e36:                 { "Executed tr13", "1" },
1:1725dd1:             });
1:1725dd1:     }
1:1725dd1: 
1:75fbb86:     /**
1:05b022f:      * A row trigger whose WHEN clause contains a subquery, used to cause a
1:05b022f:      * NullPointerException in some situations.
1:75fbb86:      */
1:05b022f:     public void testSubqueryInWhenClauseNPE() throws SQLException {
1:75fbb86:         Statement s = createStatement();
1:75fbb86:         s.execute("create table t1(x int)");
1:75fbb86:         s.execute("create table t2(x int)");
1:75fbb86:         s.execute("create trigger tr1 after insert on t1 for each row "
1:75fbb86:                 + "when ((values true)) insert into t2 values 1");
1:75fbb86: 
1:05b022f:         // This statement used to result in a NullPointerException.
1:75fbb86:         s.execute("insert into t1 values 1,2,3");
1:75fbb86:     }
1:75fbb86: 
1:6a17f80:     /**
1:6a17f80:      * Test generated columns referenced from WHEN clauses. In particular,
1:6a17f80:      * test that references to generated columns are disallowed in the NEW
1:6a17f80:      * transition variable of BEFORE triggers. See DERBY-3948.
1:6a17f80:      *
1:6a17f80:      * @see GeneratedColumnsTest#test_024_beforeTriggers()
1:6a17f80:      */
1:6a17f80:     public void testGeneratedColumns() throws SQLException {
1:6a17f80:         Statement s = createStatement();
1:6a17f80:         s.execute("create table t1(x int, y int, "
1:6a17f80:                 + "z int generated always as (x+y))");
1:6a17f80:         s.execute("create table t2(x int)");
1:6a17f80:         s.execute("create procedure int_proc(i int) language java "
1:6a17f80:                 + "parameter style java external name '"
1:6a17f80:                 + getClass().getName() + ".intProcedure' no sql");
1:6a17f80: 
1:6a17f80:         // BEFORE INSERT trigger without generated column in WHEN clause, OK.
1:6a17f80:         s.execute("create trigger btr1 no cascade before insert on t1 "
1:6a17f80:                 + "referencing new as new for each row when (new.x < new.y) "
1:6a17f80:                 + "call int_proc(1)");
1:6a17f80: 
1:6a17f80:         // BEFORE INSERT trigger with generated column in WHEN clause, fail.
1:6a17f80:         assertCompileError(GeneratedColumnsHelper.BAD_BEFORE_TRIGGER,
1:6a17f80:                 "create trigger btr2 no cascade before insert on t1 "
1:6a17f80:                 + "referencing new as new for each row when (new.x < new.z) "
1:6a17f80:                 + "select * from sysibm.sysdummy1");
1:6a17f80: 
1:6a17f80:         // BEFORE UPDATE trigger without generated column in WHEN clause, OK.
1:6a17f80:         s.execute("create trigger btr3 no cascade before update on t1 "
1:6a17f80:                 + "referencing new as new old as old for each row "
1:6a17f80:                 + "when (new.x < old.x) call int_proc(3)");
1:6a17f80: 
1:6a17f80:         // BEFORE UPDATE trigger with generated column in WHEN clause. OK,
1:6a17f80:         // since the generated column is in the OLD transition variable.
1:6a17f80:         s.execute("create trigger btr4 no cascade before update on t1 "
1:6a17f80:                 + "referencing old as old for each row when (old.x < old.z) "
1:6a17f80:                 + "call int_proc(4)");
1:6a17f80: 
1:6a17f80:         // BEFORE UPDATE trigger with generated column in NEW transition
1:6a17f80:         // variable, fail.
1:6a17f80:         assertCompileError(GeneratedColumnsHelper.BAD_BEFORE_TRIGGER,
1:6a17f80:                 "create trigger btr5 no cascade before update on t1 "
1:6a17f80:                 + "referencing new as new for each row when (new.x < new.z) "
1:6a17f80:                 + "select * from sysibm.sysdummy1");
1:6a17f80: 
1:6a17f80:         // BEFORE DELETE trigger without generated column in WHEN clause, OK.
1:6a17f80:         s.execute("create trigger btr6 no cascade before delete on t1 "
1:6a17f80:                 + "referencing old as old for each row when (old.x < 3) "
1:6a17f80:                 + "call int_proc(6)");
1:6a17f80: 
1:6a17f80:         // BEFORE DELETE trigger with generated column in WHEN clause. OK,
1:6a17f80:         // since the generated column is in the OLD transition variable.
1:6a17f80:         s.execute("create trigger btr7 no cascade before delete on t1 "
1:6a17f80:                 + "referencing old as old for each row when (old.x < old.z) "
1:6a17f80:                 + "call int_proc(7)");
1:6a17f80: 
1:6a17f80:         // References to generated columns in AFTER triggers should always
1:6a17f80:         // be allowed.
1:6a17f80:         s.execute("create trigger atr1 after insert on t1 "
1:6a17f80:                 + "referencing new as new for each row "
1:6a17f80:                 + "when (new.x < new.z) insert into t2 values 1");
1:6a17f80:         s.execute("create trigger atr2 after update on t1 "
1:6a17f80:                 + "referencing new as new old as old for each row "
1:6a17f80:                 + "when (old.z < new.z) insert into t2 values 2");
1:6a17f80:         s.execute("create trigger atr3 after delete on t1 "
1:6a17f80:                 + "referencing old as old for each row "
1:6a17f80:                 + "when (old.x < old.z) insert into t2 values 3");
1:6a17f80: 
1:6a17f80:         // Finally, fire the triggers.
1:6a17f80:         s.execute("insert into t1(x, y) values (1, 2), (4, 3)");
1:6a17f80:         s.execute("update t1 set x = y");
1:6a17f80:         s.execute("delete from t1");
1:6a17f80: 
1:6a17f80:         // Verify that the before triggers were executed as expected.
1:6a17f80:         assertEquals(Arrays.asList(1, 3, 4, 4, 6, 7, 7), procedureCalls);
1:6a17f80: 
1:6a17f80:         // Verify that the after triggers were executed as expected.
1:6a17f80:         JDBC.assertFullResultSet(
1:6a17f80:                 s.executeQuery("select * from t2 order by x"),
1:6a17f80:                 new String[][]{{"1"}, {"1"}, {"2"}, {"3"}, {"3"}});
1:6a17f80:     }
1:51f910f: 
1:51f910f:     /**
1:df73e36:      * Test various illegal WHEN clauses.
1:51f910f:      */
1:df73e36:     public void testIllegalWhenClauses() throws SQLException {
1:51f910f:         Statement s = createStatement();
1:51f910f:         s.execute("declare global temporary table temptable (x int) "
1:51f910f:                 + "not logged");
1:51f910f:         s.execute("create table t1(x int)");
1:51f910f:         s.execute("create table t2(x int)");
1:df73e36:         s.execute("create procedure int_proc(i int) language java "
1:df73e36:                 + "parameter style java external name '"
1:df73e36:                 + getClass().getName() + ".intProcedure' no sql");
1:51f910f: 
1:df73e36:         // CREATE TRIGGER should fail if the WHEN clause references a table
1:df73e36:         // in the SESSION schema.
1:51f910f:         assertCompileError(REFERENCES_SESSION_SCHEMA,
1:51f910f:                 "create trigger tr1 after insert on t1 "
1:51f910f:                 + "when (exists (select * from session.temptable)) "
1:51f910f:                 + "insert into t2 values 1");
1:df73e36: 
1:df73e36:         // The WHEN clause expression must be BOOLEAN.
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr after insert on t1 "
1:df73e36:                 + "when (1) insert into t2 values 1");
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr after update on t1 "
1:df73e36:                 + "when ('abc') insert into t2 values 1");
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr after delete on t1 "
1:df73e36:                 + "when ((values 1)) insert into t2 values 1");
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr no cascade before insert on t1 "
1:df73e36:                 + "when ((select ibmreqd from sysibm.sysdummy1)) "
1:df73e36:                 + "call int_proc(1)");
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr no cascade before insert on t1 "
1:df73e36:                 + "when ((select ibmreqd from sysibm.sysdummy1)) "
1:df73e36:                 + "call int_proc(1)");
1:df73e36:         assertCompileError(NOT_BOOLEAN,
1:df73e36:                 "create trigger tr no cascade before update on t1 "
1:df73e36:                 + "referencing old as old for each row "
1:df73e36:                 + "when (old.x) call int_proc(1)");
1:df73e36: 
1:df73e36:         // Dynamic parameters (?) are not allowed in the WHEN clause.
1:df73e36:         assertCompileError(HAS_PARAMETER,
1:df73e36:                 "create trigger tr no cascade before delete on t1 "
1:df73e36:                 + "when (?) call int_proc(1)");
1:df73e36:         assertCompileError(HAS_PARAMETER,
1:df73e36:                 "create trigger tr after insert on t1 "
1:df73e36:                 + "when (cast(? as boolean)) call int_proc(1)");
1:df73e36:         assertCompileError(HAS_PARAMETER,
1:df73e36:                 "create trigger tr after delete on t1 "
1:df73e36:                 + "when ((select true from sysibm.sysdummy where ibmreqd = ?)) "
1:df73e36:                 + "call int_proc(1)");
1:05b022f: 
1:05b022f:         // Subqueries in the WHEN clause must have a single column
1:05b022f:         assertCompileError(NOT_SINGLE_COLUMN,
1:05b022f:                 "create trigger tr no cascade before insert on t1 "
1:05b022f:                 + "when ((values (true, false))) call int_proc(1)");
1:05b022f:         assertCompileError(NOT_SINGLE_COLUMN,
1:05b022f:                 "create trigger tr after update of x on t1 "
1:05b022f:                 + "when ((select tablename, schemaid from sys.systables)) "
1:05b022f:                 + "call int_proc(1)");
1:51f910f:     }
1:00b0dbe: 
1:00b0dbe:     /**
1:00b0dbe:      * Verify that the SPS of a WHEN clause is invalidated when one of its
1:00b0dbe:      * dependencies is changed in a way that requires recompilation.
1:00b0dbe:      */
1:00b0dbe:     public void testWhenClauseInvalidation() throws SQLException {
1:00b0dbe:         // Statement that checks the validity of the WHEN clause SPS.
1:00b0dbe:         PreparedStatement spsValid = prepareStatement(
1:00b0dbe:                 "select valid from sys.sysstatements "
1:00b0dbe:                 + "where stmtname like 'TRIGGERWHEN%'");
1:00b0dbe: 
1:00b0dbe:         Statement s = createStatement();
1:00b0dbe:         s.execute("create table t1(x int)");
1:00b0dbe:         s.execute("create table t2(x int)");
1:00b0dbe:         s.execute("create table t3(x int)");
1:00b0dbe:         s.execute("insert into t1 values 1");
1:00b0dbe: 
1:00b0dbe:         s.execute("create trigger tr after insert on t2 "
1:00b0dbe:                 + "referencing new as new for each row "
1:00b0dbe:                 + "when (exists (select * from t1 where x = new.x)) "
1:00b0dbe:                 + "insert into t3 values new.x");
1:00b0dbe: 
1:00b0dbe:         // SPS is initially valid.
1:00b0dbe:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "true");
1:00b0dbe: 
1:00b0dbe:         // Compressing the table referenced in the WHEN clause should
1:00b0dbe:         // invalidate the SPS.
1:00b0dbe:         PreparedStatement compress = prepareStatement(
1:00b0dbe:                 "call syscs_util.syscs_compress_table(?, 'T1', 1)");
1:00b0dbe:         compress.setString(1, TestConfiguration.getCurrent().getUserName());
1:00b0dbe:         compress.execute();
1:00b0dbe:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "false");
1:00b0dbe: 
1:00b0dbe:         // Invoking the trigger should recompile the SPS.
1:00b0dbe:         s.execute("insert into t2 values 0,1,2");
1:00b0dbe:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "true");
1:00b0dbe:         JDBC.assertSingleValueResultSet(
1:00b0dbe:                 s.executeQuery("select * from t3"), "1");
1:00b0dbe:     }
1:d23659a: 
1:d23659a:     /**
1:d23659a:      * Test that dropping objects referenced from the WHEN clause will
1:d23659a:      * detect that the trigger depends on the object.
1:d23659a:      */
1:d23659a:     public void testDependencies() throws SQLException {
1:d23659a:         Statement s = createStatement();
1:d23659a:         s.execute("create table t1(x int, y int, z int)");
1:d23659a:         s.execute("create table t2(x int, y int, z int)");
1:d23659a: 
1:d23659a:         Savepoint sp = getConnection().setSavepoint();
1:d23659a: 
1:d23659a:         // Dropping columns referenced via the NEW transition variable in
1:d23659a:         // a WHEN clause should fail.
1:d23659a:         s.execute("create trigger tr after insert on t1 "
1:d23659a:                 + "referencing new as new for each row "
1:d23659a:                 + "when (new.x < new.y) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         s.execute("alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // Dropping columns referenced via the OLD transition variable in
1:d23659a:         // a WHEN clause should fail.
1:d23659a:         s.execute("create trigger tr no cascade before delete on t1 "
1:d23659a:                 + "referencing old as old for each row "
1:d23659a:                 + "when (old.x < old.y) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         s.execute("alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // Dropping columns referenced via either the OLD or the NEW
1:d23659a:         // transition variable referenced in the WHEN clause should fail.
1:d23659a:         s.execute("create trigger tr no cascade before update on t1 "
1:d23659a:                 + "referencing old as old new as new for each row "
1:d23659a:                 + "when (old.x < new.y) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         s.execute("alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // Dropping columns referenced either in the WHEN clause or in the
1:d23659a:         // triggered SQL statement should fail.
1:d23659a:         s.execute("create trigger tr no cascade before insert on t1 "
1:d23659a:                 + "referencing new as new for each row "
1:d23659a:                 + "when (new.x < 5) values new.y");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         s.execute("alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // Dropping any column in a statement trigger with a NEW transition
1:d23659a:         // table fails, even if the column is not referenced in the WHEN clause
1:d23659a:         // or in the triggered SQL text.
1:d23659a:         s.execute("create trigger tr after update of x on t1 "
1:d23659a:                 + "referencing new table as new "
1:d23659a:                 + "when (exists (select 1 from new where x < y)) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         // Z is not referenced, but the transition table depends on all columns.
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // Dropping any column in a statement trigger with an OLD transition
1:d23659a:         // table fails, even if the column is not referenced in the WHEN clause
1:d23659a:         // or in the triggered SQL text.
1:d23659a:         s.execute("create trigger tr after delete on t1 "
1:d23659a:                 + "referencing old table as old "
1:d23659a:                 + "when (exists (select 1 from old where x < y)) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         // Z is not referenced, but the transition table depends on all columns.
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // References to columns in other ways than via transition variables
1:d23659a:         // or transition tables should also be detected.
1:d23659a:         s.execute("create trigger tr after delete on t1 "
1:d23659a:                 + "referencing old table as old "
1:d23659a:                 + "when (exists (select 1 from t1 where x < y)) values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t1 drop column y restrict");
1:d23659a:         s.execute("alter table t1 drop column z restrict");
1:d23659a:         getConnection().rollback(sp);
1:d23659a: 
1:d23659a:         // References to columns in another table than the trigger table
1:d23659a:         // should prevent them from being dropped.
1:d23659a:         s.execute("create trigger tr after insert on t1 "
1:d23659a:                 + "when (exists (select * from t2 where x < y)) "
1:d23659a:                 + "values 1");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t2 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t2 drop column y restrict");
1:d23659a:         s.execute("alter table t2 drop column z restrict");
1:d23659a: 
1:cc67949:         // Dropping a table referenced in a WHEN clause should fail and leave
1:cc67949:         // the trigger intact. Before DERBY-2041, DROP TABLE would succeed
1:cc67949:         // and leave the trigger in an invalid state so that subsequent
1:cc67949:         // INSERT statements would fail when trying to fire the trigger.
1:cc67949:         assertStatementError(HAS_DEPENDENTS, s, "drop table t2");
1:d23659a:         JDBC.assertSingleValueResultSet(
1:d23659a:             s.executeQuery("select triggername from sys.systriggers"), "TR");
1:cc67949:         s.executeUpdate("insert into t1 values (1, 2, 3)");
1:d23659a:         getConnection().rollback(sp);
1:50734d8: 
1:d23659a:         // Test references to columns in both the WHEN clause and the
1:d23659a:         // triggered SQL statement.
1:d23659a:         s.execute("create trigger tr after update on t1 "
1:d23659a:                 + "when (exists (select * from t2 where x < 5)) "
1:d23659a:                 + "select y from t2");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t2 drop column x restrict");
1:d23659a:         assertStatementError(HAS_DEPENDENTS, s,
1:d23659a:                 "alter table t2 drop column y restrict");
1:d23659a:         s.execute("alter table t2 drop column z restrict");
1:d23659a: 
1:cc67949:         // DROP TABLE should fail because of the dependencies (didn't before
1:cc67949:         // DERBY-2041).
1:cc67949:         assertStatementError(HAS_DEPENDENTS, s, "drop table t2");
1:d23659a:         JDBC.assertSingleValueResultSet(
1:d23659a:             s.executeQuery("select triggername from sys.systriggers"), "TR");
1:d23659a:         getConnection().rollback(sp);
1:d23659a:     }
1:d23659a: 
1:50734d8:     /**
1:50734d8:      * Verify that DERBY-4874, which was fixed before support for the WHEN
1:50734d8:      * clause was implemented, does not affect the WHEN clause.
1:50734d8:      * The first stab at the WHEN clause implementation did suffer from it.
1:50734d8:      */
1:50734d8:     public void testDerby4874() throws SQLException {
1:50734d8:         Statement s = createStatement();
1:50734d8:         s.execute("create table t(x varchar(3))");
1:50734d8:         s.execute("create trigger tr after update of x on t "
1:50734d8:                 + "referencing new as new for each row "
1:50734d8:                 + "when (new.x < 'abc') values 1");
1:50734d8:         s.execute("insert into t values 'aaa'");
1:50734d8: 
1:50734d8:         // Updating X to something longer than 3 characters should fail,
1:50734d8:         // since it's a VARCHAR(3).
1:50734d8:         assertStatementError(TRUNCATION, s, "update t set x = 'aaaa'");
1:50734d8: 
1:50734d8:         // Change the type of X to VARCHAR(4) and try again. This time it
1:50734d8:         // should succeed, but it used to fail because the trigger hadn't
1:50734d8:         // been recompiled and still thought the max length was 3.
1:50734d8:         s.execute("alter table t alter x set data type varchar(4)");
1:50734d8:         assertUpdateCount(s, 1, "update t set x = 'aaaa'");
1:50734d8: 
1:50734d8:         // Updating it to a longer value should still fail.
1:50734d8:         assertStatementError(TRUNCATION, s, "update t set x = 'aaaaa'");
1:50734d8:     }
1:50734d8: 
1:50734d8:     /**
1:50734d8:      * Verify that Cloudscape bug 4821, which was fixed long before support
1:50734d8:      * for the WHEN clause was implemented, does not affect the WHEN clause.
1:50734d8:      * The first stab at the WHEN clause implementation did suffer from it.
1:50734d8:      */
1:50734d8:     public void testCloudscapeBug4821() throws SQLException {
1:50734d8:         // First create a trigger, and immediately perform an ALTER TABLE
1:50734d8:         // statement on the trigger table to make sure the trigger's SPS is
1:50734d8:         // invalid and must be recompiled the first time it's fired.
1:50734d8:         Statement s = createStatement();
1:50734d8:         s.execute("create table cs4821.t(x int)");
1:50734d8:         s.execute("create trigger cs4821.tr after insert on cs4821.t "
1:50734d8:                 + "when (true) values 1");
1:50734d8:         s.execute("alter table cs4821.t add column y int");
1:50734d8:         commit();
1:50734d8: 
1:50734d8:         // Fire the trigger and leave the transaction open afterwards.
1:50734d8:         s.execute("insert into cs4821.t(x) values 1");
1:50734d8: 
1:50734d8:         // Now try to read all rows from the SYS.SYSSTATEMENTS table from
1:50734d8:         // another transaction. Used to time out because the transaction
1:50734d8:         // that recompiled the trigger kept the lock on the system table.
1:50734d8:         Connection c2 = openDefaultConnection();
1:50734d8:         Statement s2 = c2.createStatement();
1:50734d8:         JDBC.assertDrainResults(
1:50734d8:                 s2.executeQuery("select * from sys.sysstatements"));
1:50734d8:         s2.close();
1:50734d8:         JDBC.cleanup(c2);
1:50734d8: 
1:50734d8:         // Remove all tables and triggers created by this test case.
1:50734d8:         JDBC.dropSchema(getConnection().getMetaData(), "CS4821");
1:50734d8:     }
1:c955b82: 
1:c955b82:     /**
1:54844c3:      * Test for Derby-6783.
1:54844c3:      */
1:54844c3: 
1:54844c3:     public void testDerby6783() throws SQLException {
1:54844c3:         Statement s = createStatement();
1:54844c3: 
1:54844c3:         s.execute("CREATE TABLE tabDerby6783(id INTEGER, result VARCHAR(10), status CHAR(1))");
1:54844c3: 
1:54844c3:         s.execute("CREATE TRIGGER trigger6783 AFTER UPDATE OF status ON tabDerby6783 "
1:54844c3:                 + "REFERENCING NEW AS newrow FOR EACH ROW WHEN (newrow.status='d') "
1:54844c3:                 + "UPDATE tabDerby6783 SET result='completed' WHERE id=newrow.id");
1:54844c3:         s.execute("insert into tabDerby6783 values (1, null, 'a')");
1:54844c3:         // Fire the trigger.
1:54844c3:         s.execute("UPDATE tabDerby6783 SET status='d'");
1:54844c3:         
1:54844c3:         JDBC.assertSingleValueResultSet(
1:54844c3:                 s.executeQuery("SELECT result FROM tabDerby6783"), 
1:54844c3:                 "completed");
1:54844c3:     }
1:54844c3: 
1:54844c3:     /**
1:54844c3:      * Derby6783_1_1 test, this test has two trigger fields and
1:54844c3:      * more than 3 column references in the update statement.
1:54844c3:      */
1:54844c3: 
1:54844c3:     public void testDerby6783_1_1() throws SQLException 
1:54844c3:     {
1:54844c3:         Statement s = createStatement();
1:54844c3: 
1:54844c3:         s.execute("CREATE TABLE tabDerby6783_1_1(ID INTEGER, GRADE1 char(1), GRADE2 char(1),"
1:54844c3:                     + " MARKS1 integer, MARKS2 integer, TOTAL_MARKS integer)");
1:54844c3: 
1:54844c3:         s.execute("CREATE TRIGGER trigger6783_1 AFTER UPDATE OF GRADE1, GRADE2 ON tabDerby6783_1_1"
1:54844c3:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:54844c3:                     + " FOR EACH ROW WHEN (oldrow.GRADE1 <> newrow.GRADE1 OR oldrow.GRADE2 <> newrow.GRADE2)"
1:54844c3:                     + " UPDATE tabDerby6783_1_1 SET TOTAL_MARKS = oldrow.MARKS1 + oldrow.MARKS2 where id=newrow.id");
1:54844c3: 
1:54844c3:         s.execute("INSERT INTO tabDerby6783_1_1 VALUES (1, 'a', 'b', 30, 50, 0)");
1:54844c3:         // Fire the trigger.
1:54844c3:         s.execute("UPDATE tabDerby6783_1_1 SET GRADE1='b'");
1:54844c3: 
1:54844c3:         
1:54844c3:         JDBC.assertSingleValueResultSet(
1:54844c3:                 s.executeQuery("SELECT TOTAL_MARKS FROM tabDerby6783_1_1"), 
1:54844c3:                 "80");   
1:54844c3:     }
1:54844c3: 
1:54844c3:     /**
1:54844c3:      * Derby6783_1_2 test, is a less complex version of Derby6783_1_1
1:54844c3:      * It has only one column reference in trigger part and in update part.
1:54844c3:      */
1:54844c3: 
1:54844c3:     public void testDerby6783_1_2() throws SQLException 
1:54844c3:     {
1:54844c3:         Statement s = createStatement();
1:54844c3: 
1:54844c3:         s.execute("CREATE TABLE tabDerby6783_1_2(ID INTEGER, GRADE1 char(1), GRADE2 char(1),"
1:54844c3:                     + " MARKS1 integer, MARKS2 integer, FINAL_GRADE char(1))");
1:54844c3: 
1:54844c3:         s.execute("CREATE TRIGGER trigger6783_1 AFTER UPDATE OF MARKS1 ON tabDerby6783_1_2 "
1:54844c3:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:54844c3:                     + " FOR EACH ROW WHEN (oldrow.MARKS1 <> newrow.MARKS1)"
1:54844c3:                     + " UPDATE tabDerby6783_1_2 SET FINAL_GRADE = oldrow.GRADE1 where id=newrow.id");  
1:54844c3: 
1:54844c3:         s.execute("INSERT INTO tabDerby6783_1_2 VALUES (1, 'a', 'b', 30, 50, 'c')");
1:54844c3: 
1:54844c3:         s.execute("UPDATE tabDerby6783_1_2 SET MARKS1=20");
1:54844c3: 
1:54844c3:         JDBC.assertSingleValueResultSet(
1:54844c3:                 s.executeQuery("SELECT FINAL_GRADE FROM tabDerby6783_1_2"), 
1:54844c3:                 "a");  
1:54844c3:     }
1:54844c3: 
1:54844c3:     /**
1:54844c3:      * Derby6783_2 test, this test has a single trigger column reference
1:54844c3:      * and two column reference in update statement. Also the when clause
1:54844c3:      * has a different column reference than the trigger reference
1:54844c3:     */
1:54844c3: 
1:54844c3:     public void testDerby6783_2() throws SQLException
1:54844c3:     {
1:54844c3:         Statement s = createStatement();
1:54844c3:         s.execute("CREATE TABLE tabDerby6783_2(ACC_NUMBER INT, BALANCE FLOAT, RATE REAL,"
1:54844c3:                     + " INTEREST REAL)");
1:54844c3: 
1:54844c3:         s.execute("CREATE TRIGGER trigger_2 AFTER UPDATE OF BALANCE ON tabDerby6783_2 "
1:54844c3:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:54844c3:                     + " FOR EACH ROW WHEN (oldrow.RATE < 10.0)"
1:54844c3:                     + " UPDATE tabDerby6783_2 SET INTEREST = oldrow.balance + newrow.BALANCE * RATE");
1:54844c3: 
1:54844c3:         s.execute("INSERT INTO tabDerby6783_2 VALUES (123, 12383.4534, 8.98, 2340)");
1:54844c3: 
1:54844c3:         s.execute("UPDATE tabDerby6783_2 SET BALANCE=22383.4543");
1:54844c3: 
1:54844c3:         s.execute("select INTEREST from tabDerby6783_2");
1:54844c3: 
1:54844c3:         JDBC.assertSingleValueResultSet(
1:54844c3:                 s.executeQuery("SELECT INTEREST FROM tabDerby6783_2"), 
1:54844c3:                 "213386.86");         
1:54844c3:     }
1:54844c3: 
1:54844c3:     /**
1:54844c3:      * Derby6783_3 test, this test referes to different tables in
1:54844c3:      * when clause and update clause.
1:54844c3:     */
1:54844c3: 
1:54844c3:     public void testDerby6783_3() throws SQLException
1:54844c3:     {
1:54844c3:         Statement s = createStatement();
1:54844c3:         s.execute("CREATE TABLE tabDerby6783_3_1(FIELD1 VARCHAR(10),"
1:54844c3:                     + " FIELD2 DOUBLE)");
1:54844c3: 
1:54844c3:         s.execute("INSERT INTO tabDerby6783_3_1 VALUES ('helloworld', 5454567)");
1:54844c3: 
1:54844c3:         s.execute("CREATE TABLE tabDerby6783_3_2(FIELD3 NUMERIC (7,1))");
1:54844c3: 
1:54844c3:         s.execute("INSERT INTO tabDerby6783_3_2 VALUES (3.143)");
1:54844c3: 
1:54844c3:         s.execute("CREATE TRIGGER TRIGGER_3 AFTER UPDATE OF FIELD1 ON tabDerby6783_3_1"
1:54844c3:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:54844c3:                     + " FOR EACH ROW WHEN (newrow.FIELD2 > 3000)"
1:54844c3:                     + " UPDATE tabDerby6783_3_2 SET FIELD3 = newrow.FIELD2 / 10");
1:54844c3: 
1:54844c3:         s.execute("UPDATE tabDerby6783_3_1 set FIELD1='hello'");
1:54844c3: 
1:54844c3:         JDBC.assertSingleValueResultSet(
1:54844c3:                 s.executeQuery("SELECT FIELD3 FROM tabDerby6783_3_2"),
1:54844c3:                 "545456.7");
1:54844c3:     }
1:54844c3: 
1:54844c3:     /**
1:c955b82:      * When SQL authorization is enabled, the trigger action (including the
1:c955b82:      * WHEN clause) should execute with definer's rights. Verify that it is
1:c955b82:      * so.
1:c955b82:      */
1:c955b82:     public void testGrantRevoke() throws SQLException {
1:c955b82:         Connection c1 = openDefaultConnection("u1", "dummy");
1:c955b82:         c1.setAutoCommit(true);
1:c955b82:         Statement s1 = c1.createStatement();
1:c955b82: 
1:c955b82:         s1.execute("create table t1(x varchar(20))");
1:c955b82:         s1.execute("create table t2(x varchar(200))");
1:c955b82:         s1.execute("create table t3(x int)");
1:c955b82:         s1.execute("create function is_true(s varchar(128)) returns boolean "
1:c955b82:                 + "deterministic language java parameter style java "
1:c955b82:                 + "external name 'java.lang.Boolean.parseBoolean' no sql");
1:c955b82: 
1:c955b82:         // Trigger that fires on T1 if inserted value is 'true'.
1:c955b82:         s1.execute("create trigger tr1 after insert on t1 "
1:c955b82:                 + "referencing new as new for each row "
1:c955b82:                 + "when (is_true(new.x)) insert into t2(x) values new.x");
1:c955b82: 
1:c955b82:         // Trigger that fires on T1 on insert if T3 has more than 1 row.
1:c955b82:         s1.execute("create trigger tr2 after insert on t1 "
1:c955b82:                 + "when (exists (select * from t3 offset 1 row)) "
1:c955b82:                 + "insert into t2(x) values '***'");
1:c955b82: 
1:c955b82:         // Allow U2 to insert into T1, but nothing else on U1's schema.
1:c955b82:         s1.execute("grant insert on table t1 to u2");
1:c955b82: 
1:c955b82:         Connection c2 = openDefaultConnection("u2", "dummy");
1:c955b82:         c2.setAutoCommit(true);
1:c955b82:         Statement s2 = c2.createStatement();
1:c955b82: 
1:c955b82:         // User U2 is not authorized to invoke the function IS_TRUE, but
1:c955b82:         // is allowed to insert into T1.
1:c955b82:         assertStatementError(NOT_AUTHORIZED, s2, "values u1.is_true('abc')");
1:c955b82:         assertUpdateCount(s2, 4,
1:c955b82:                 "insert into u1.t1(x) values 'abc', 'true', 'TrUe', 'false'");
1:c955b82: 
1:c955b82:         // Verify that the trigger fired. Since the trigger runs with
1:c955b82:         // definer's rights, it should be allowed to invoke IS_TRUE in the
1:c955b82:         // WHEN clause even though U2 isn't allowed to invoke it directly.
1:c955b82:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:c955b82:                                  new String[][] {{"TrUe"}, {"true"}});
1:c955b82:         s1.execute("delete from t2");
1:c955b82: 
1:c955b82:         // Now test that TR1 will also fire, even though U2 isn't granted
1:c955b82:         // SELECT privileges on the table read by the WHEN clause.
1:c955b82:         s1.execute("insert into t3 values 1, 2");
1:c955b82:         assertUpdateCount(s2, 2, "insert into u1.t1(x) values 'x', 'y'");
1:c955b82:         JDBC.assertSingleValueResultSet(
1:c955b82:                 s1.executeQuery("select * from t2 order by x"), "***");
1:c955b82:         s1.execute("delete from t2");
1:c955b82: 
1:c955b82:         // Now invalidate the triggers and make sure they still work after
1:c955b82:         // recompilation.
1:c955b82:         s1.execute("alter table t1 alter column x set data type varchar(200)");
1:c955b82:         assertUpdateCount(s2, 2, "insert into u1.t1(x) values 'true', 'false'");
1:c955b82:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:c955b82:                                  new String[][] {{"***"}, {"true"}});
1:c955b82:         s1.execute("delete from t2");
1:c955b82: 
1:c955b82:         // Revoke U2's insert privilege on T1.
1:c955b82:         s1.execute("revoke insert on table t1 from u2 ");
1:c955b82: 
1:c955b82:         // U2 should not be allowed to insert into T1 anymore.
1:c955b82:         assertStatementError(NO_TABLE_PERMISSION, s2,
1:c955b82:                              "insert into u1.t1(x) values 'abc'");
1:c955b82: 
1:c955b82:         // U1 should still be allowed to do it (since U1 owns T1), and the
1:c955b82:         // triggers should still be working.
1:c955b82:         assertUpdateCount(s1, 2, "insert into t1(x) values 'true', 'false'");
1:c955b82:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:c955b82:                                  new String[][] {{"***"}, {"true"}});
1:c955b82:         s1.execute("delete from t2");
1:c955b82: 
1:c955b82:         // Now try to define a trigger in U2's schema that needs to invoke
1:c955b82:         // U1.IS_TRUE. Should fail because U2 isn't allowed to invoke it.
1:c955b82:         s2.execute("create table t(x varchar(200))");
1:c955b82:         assertStatementError(NOT_AUTHORIZED, s2,
1:c955b82:                              "create trigger tr after insert on t "
1:c955b82:                              + "referencing new as new for each row "
1:c955b82:                              + "when (u1.is_true(new.x)) values 1");
1:c955b82: 
1:c955b82:         // Try again after granting execute permission to U2.
1:c955b82:         s1.execute("grant execute on function is_true to u2");
1:c955b82:         s2.execute("create trigger tr after insert on t "
1:c955b82:                 + "referencing new as new for each row "
1:c955b82:                 + "when (u1.is_true(new.x)) values 1");
1:c955b82: 
1:c955b82:         // Fire trigger.
1:c955b82:         assertUpdateCount(s2, 3, "insert into t values 'ab', 'cd', 'ef'");
1:c955b82: 
1:c955b82:         // Revoking the execute permission will fail because the trigger
1:c955b82:         // depends on it.
1:c955b82:         assertStatementError(HAS_DEPENDENTS, s1,
1:c955b82:                 "revoke execute on function is_true from u2 restrict");
1:c955b82: 
1:c955b82:         s1.close();
1:c955b82:         s2.close();
1:c955b82: 
1:c955b82:         c2.setAutoCommit(false);
1:c955b82:         JDBC.dropSchema(c2.getMetaData(), "U2");
1:cc67949:         c1.setAutoCommit(false);
1:cc67949:         JDBC.dropSchema(c1.getMetaData(), "U1");
1:c955b82:     }
1:c955b82: 
1:c955b82:     /**
1:c955b82:      * Test that the trigger fails gracefully if the WHEN clause throws
1:c955b82:      * a RuntimeException.
1:c955b82:      */
1:c955b82:     public void testRuntimeException() throws SQLException {
1:c955b82:         Statement s = createStatement();
1:c955b82:         s.execute("create function f(x varchar(10)) returns int "
1:c955b82:                 + "deterministic language java parameter style java "
1:c955b82:                 + "external name 'java.lang.Integer.parseInt' no sql");
1:c955b82:         s.execute("create table t1(x varchar(10))");
1:c955b82:         s.execute("create table t2(x varchar(10))");
1:c955b82:         s.execute("create trigger tr after insert on t1 "
1:c955b82:                 + "referencing new as new for each row "
1:c955b82:                 + "when (f(new.x) < 100) insert into t2 values new.x");
1:c955b82: 
1:c955b82:         // Insert a value that causes Integer.parseInt() to throw a
1:c955b82:         // NumberFormatException. The NFE will be wrapped in two SQLExceptions.
1:c955b82:         assertStatementError(new String[] {USER_EXCEPTION, JAVA_EXCEPTION}, s,
1:c955b82:                 "insert into t1 values '1', '2', 'hello', '3', '121'");
1:c955b82: 
1:c955b82:         // The statement should be rolled back, so nothing should be in
1:c955b82:         // either of the tables.
1:c955b82:         assertTableRowCount("T1", 0);
1:c955b82:         assertTableRowCount("T2", 0);
1:c955b82: 
1:c955b82:         // Now try again with values that don't cause exceptions.
1:c955b82:         assertUpdateCount(s, 4, "insert into t1 values '1', '2', '3', '121'");
1:c955b82: 
1:c955b82:         // Verify that the trigger fired this time.
1:c955b82:         JDBC.assertFullResultSet(s.executeQuery("select * from t2 order by x"),
1:c955b82:                                  new String[][] {{"1"}, {"2"}, {"3"}});
1:c955b82:     }
1:05b022f: 
1:05b022f:     /**
1:05b022f:      * Test that scalar subqueries are allowed, and that non-scalar subqueries
1:05b022f:      * result in exceptions when the trigger fires.
1:05b022f:      */
1:05b022f:     public void testScalarSubquery() throws SQLException {
1:05b022f:         Statement s = createStatement();
1:05b022f:         s.execute("create table t1(x int)");
1:05b022f:         s.execute("create table t2(x int)");
1:05b022f:         s.execute("create table t3(x int)");
1:05b022f: 
1:05b022f:         s.execute("insert into t3 values 0,1,2,2");
1:05b022f: 
1:05b022f:         s.execute("create trigger tr1 after insert on t1 "
1:05b022f:                 + "referencing new as new for each row "
1:05b022f:                 + "when ((select x > 0 from t3 where x = new.x)) "
1:05b022f:                 + "insert into t2 values 1");
1:05b022f: 
1:05b022f:         // Subquery returns no rows, so the trigger should not fire.
1:05b022f:         s.execute("insert into t1 values 42");
1:05b022f:         assertTableRowCount("T2", 0);
1:05b022f: 
1:05b022f:         // Subquery returns a single value, which is false, so the trigger
1:05b022f:         // should not fire.
1:05b022f:         s.execute("insert into t1 values 0");
1:05b022f:         assertTableRowCount("T2", 0);
1:05b022f: 
1:05b022f:         // Subquery returns a single value, which is true, so the trigger
1:05b022f:         // should fire.
1:05b022f:         s.execute("insert into t1 values 1");
1:05b022f:         assertTableRowCount("T2", 1);
1:05b022f: 
1:05b022f:         // Subquery returns multiple values, so an error should be raised.
1:05b022f:         assertStatementError(NON_SCALAR_QUERY, s, "insert into t1 values 2");
1:05b022f:         assertTableRowCount("T2", 1);
1:05b022f:     }
1:1061fd2: 
1:1061fd2:     /**
1:1061fd2:      * Test that a WHEN clause can call the CURRENT_USER function.
1:1061fd2:      */
1:1061fd2:     public void testCurrentUser() throws SQLException {
1:1061fd2:         Statement s = createStatement();
1:1061fd2:         s.execute("create table t1(x int)");
1:1061fd2:         s.execute("create table t2(x varchar(10))");
1:1061fd2: 
1:1061fd2:         // Create one trigger that should only fire when current user is U2,
1:1061fd2:         // and one that should only fire when current user is different from
1:1061fd2:         // U2.
1:1061fd2:         s.execute("create trigger tr01 after insert on t1 "
1:1061fd2:                 + "when (current_user = 'U2') "
1:1061fd2:                 + "insert into t2 values 'TR01'");
1:1061fd2:         s.execute("create trigger tr02 after insert on t1 "
1:1061fd2:                 + "when (current_user <> 'U2') "
1:1061fd2:                 + "insert into t2 values 'TR02'");
1:1061fd2:         s.execute("grant insert on t1 to u2");
1:1061fd2: 
1:1061fd2:         commit();
1:1061fd2: 
1:1061fd2:         // Used to get an assert failure or a NullPointerException here before
1:1061fd2:         // DERBY-6348. Expect it to succeed, and expect TR02 to have fired.
1:1061fd2:         s.execute("insert into t1 values 1");
1:1061fd2:         JDBC.assertSingleValueResultSet(
1:1061fd2:                 s.executeQuery("select * from t2"), "TR02");
1:1061fd2: 
1:1061fd2:         rollback();
1:1061fd2: 
1:1061fd2:         // Now try the same insert as user U2.
1:1061fd2:         Connection c2 = openUserConnection("u2");
1:1061fd2:         c2.setAutoCommit(true);
1:1061fd2:         Statement s2 = c2.createStatement();
1:1061fd2:         s2.execute("insert into "
1:1061fd2:             + JDBC.escape(TestConfiguration.getCurrent().getUserName(), "T1")
1:1061fd2:             + " values 1");
1:1061fd2:         s2.close();
1:1061fd2:         c2.close();
1:1061fd2: 
1:1061fd2:         // Since the insert was performed by user U2, expect TR01 to have fired.
1:1061fd2:         JDBC.assertSingleValueResultSet(
1:1061fd2:                 s.executeQuery("select * from t2"), "TR01");
1:1061fd2: 
1:1061fd2:         // Cleanup.
1:1061fd2:         dropTable("T1");
1:1061fd2:         dropTable("T2");
1:1061fd2:         commit();
1:1061fd2:     }
1:1061fd2: 
1:1061fd2:     /**
1:1061fd2:      * Test that a trigger with a WHEN clause can be recursive.
1:1061fd2:      */
1:1061fd2:     public void testRecursiveTrigger() throws SQLException {
1:1061fd2:         Statement s = createStatement();
1:1061fd2:         s.execute("create table t(x int)");
1:1061fd2:         s.execute("create trigger tr1 after insert on t "
1:1061fd2:                 + "referencing new as new for each row "
1:1061fd2:                 + "when (new.x > 0) insert into t values new.x - 1");
1:1061fd2: 
1:1061fd2:         // Now fire the trigger. This used to cause an assert failure or a
1:1061fd2:         // NullPointerException before DERBY-6348.
1:1061fd2:         s.execute("insert into t values 15, 1, 2");
1:1061fd2: 
1:1061fd2:         // The row trigger will fire three times, so that the above statement
1:1061fd2:         // will insert the values { 15, 14, 13, ... , 0 }, { 1, 0 } and
1:1061fd2:         // { 2, 1, 0 }.
1:1061fd2:         String[][] expectedRows = {
1:1061fd2:             {"0"}, {"0"}, {"0"}, {"1"}, {"1"}, {"1"}, {"2"}, {"2"}, {"3"},
1:1061fd2:             {"4"}, {"5"}, {"6"}, {"7"}, {"8"}, {"9"}, {"10"}, {"11"},
1:1061fd2:             {"12"}, {"13"}, {"14"}, {"15"}
1:1061fd2:         };
1:1061fd2: 
1:1061fd2:         JDBC.assertFullResultSet(s.executeQuery("select * from t order by x"),
1:1061fd2:                                  expectedRows);
1:a50f895: 
1:1061fd2:         // Now fire the trigger with a value so that the maximum trigger
1:1061fd2:         // recursion depth (16) is exceeded, and verify that we get the
1:1061fd2:         // expected error.
1:1061fd2:         assertStatementError(TRIGGER_RECURSION, s, "insert into t values 16");
1:1061fd2: 
1:1061fd2:         // The contents of the table should not have changed, since the
1:1061fd2:         // above statement failed and was rolled back.
1:1061fd2:         JDBC.assertFullResultSet(s.executeQuery("select * from t order by x"),
1:1061fd2:                                  expectedRows);
1:1061fd2:     }
1:1061fd2: 
1:a50f895:     /**
1:a50f895:      * The WHEN clause text is stored in a LONG VARCHAR column in the
1:a50f895:      * SYS.SYSTRIGGERS table. This test case verifies that the WHEN clause
1:a50f895:      * is not limited to the usual LONG VARCHAR maximum length (32700
1:a50f895:      * characters).
1:a50f895:      */
1:a50f895:     public void testVeryLongWhenClause() throws SQLException {
1:a50f895:         Statement s = createStatement();
1:a50f895:         s.execute("create table t1(x int)");
1:a50f895:         s.execute("create table t2(x int)");
1:a50f895: 
1:a50f895:         // Construct a WHEN clause that is more than 32700 characters.
1:a50f895:         StringBuilder sb = new StringBuilder("(values /* a very");
1:a50f895:         for (int i = 0; i < 10000; i++) {
1:a50f895:             sb.append(", very");
1:a50f895:         }
1:a50f895:         sb.append(" long comment */ true)");
1:a50f895: 
1:a50f895:         String when = sb.toString();
1:a50f895:         assertTrue(when.length() > 32700);
1:a50f895: 
1:a50f895:         s.execute("create trigger very_long_trigger after insert on t1 "
1:a50f895:                 + "when (" + when + ") insert into t2 values 1");
1:a50f895: 
1:a50f895:         // Verify that the WHEN clause was stored in SYS.SYSTRIGGERS.
1:a50f895:         JDBC.assertSingleValueResultSet(
1:a50f895:             s.executeQuery("select whenclausetext from sys.systriggers "
1:a50f895:                          + "where triggername = 'VERY_LONG_TRIGGER'"),
1:a50f895:             when);
1:a50f895: 
1:a50f895:         // Verify that the trigger fires.
1:a50f895:         s.execute("insert into t1 values 1");
1:a50f895:         assertTableRowCount("T1", 1);
1:a50f895:         assertTableRowCount("T2", 1);
1:a50f895:     }
1:a50f895: 
1:a50f895:     /**
1:a50f895:      * Test a WHEN clause that invokes a function declared with READ SQL DATA.
1:a50f895:      */
1:a50f895:     public void testFunctionReadsSQLData() throws SQLException {
1:a50f895:         Statement s = createStatement();
1:a50f895:         s.execute("create function f(x varchar(10)) returns boolean "
1:a50f895:                 + "language java parameter style java external name '"
1:a50f895:                 + getClass().getName() + ".tableIsEmpty' reads sql data");
1:a50f895: 
1:a50f895:         s.execute("create table t1(x varchar(10))");
1:a50f895:         s.execute("create table t2(x varchar(10))");
1:a50f895:         s.execute("create table t3(x int)");
1:a50f895:         s.execute("create table t4(x int)");
1:a50f895:         s.execute("insert into t3 values 1");
1:a50f895: 
1:a50f895:         s.execute("create trigger tr after insert on t1 "
1:a50f895:                 + "referencing new as new for each row "
1:a50f895:                 + "when (f(new.x)) insert into t2 values new.x");
1:a50f895: 
1:a50f895:         s.execute("insert into t1 values 'T3', 'T4', 'T3', 'T4', 'T3', 'T4'");
1:a50f895: 
1:a50f895:         JDBC.assertFullResultSet(
1:a50f895:                 s.executeQuery("select x, count(x) from t2 group by x"),
1:a50f895:                 new String[][] {{"T4", "3"}});
1:a50f895:     }
1:a50f895: 
1:a50f895:     /**
1:a50f895:      * Stored function used by {@link #testFunctionReadsSQLData()}. It
1:a50f895:      * checks whether the given table is empty.
1:a50f895:      *
1:a50f895:      * @param table the table to check
1:a50f895:      * @return {@code true} if the table is empty, {@code false} otherwise
1:a50f895:      */
1:a50f895:     public static boolean tableIsEmpty(String table) throws SQLException {
1:a50f895:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:a50f895:         Statement s = c.createStatement();
1:a50f895:         ResultSet rs = s.executeQuery("select * from " + JDBC.escape(table));
1:a50f895:         boolean empty = !rs.next();
1:a50f895: 
1:a50f895:         rs.close();
1:a50f895:         s.close();
1:a50f895:         c.close();
1:a50f895: 
1:a50f895:         return empty;
1:a50f895:     }
1:a50f895: 
1:a50f895:     /**
1:a50f895:      * <p>
1:a50f895:      * SQL:2011, part 2, 11.49 &lt;trigger definition&gt;, syntax rule 11
1:a50f895:      * says that the WHEN clause shall not contain routines that possibly
1:a50f895:      * modifies SQL data. Derby does not currently allow functions to be
1:a50f895:      * declared as MODIFIES SQL DATA. It does allow procedures to be declared
1:a50f895:      * as MODIFIES SQL DATA, but the current grammar does not allow procedures
1:a50f895:      * to be invoked from a WHEN clause. So there's currently no way to
1:a50f895:      * invoke routines that possibly modifies SQL data from a WHEN clause.
1:a50f895:      * </p>
1:a50f895:      *
1:a50f895:      * <p>
1:a50f895:      * This test case verifies that it is not possible to declare a function
1:a50f895:      * as MODIFIES SQL DATA, and that it is not possible to call a procedure
1:a50f895:      * from a WHEN clause. If support for any of those features is added,
1:a50f895:      * this test case will start failing as a reminder that code must be
1:a50f895:      * added to prevent routines that possibly modifies SQL data from being
1:a50f895:      * invoked from a WHEN clause.
1:a50f895:      * </p>
1:a50f895:      */
1:a50f895:     public void testRoutineModifiesSQLData() throws SQLException {
1:a50f895:         // Functions cannot be declared as MODIFIES SQL DATA currently.
1:a50f895:         // Expect a syntax error.
1:a50f895:         assertCompileError(SYNTAX_ERROR,
1:a50f895:             "create function f(x int) returns int language java "
1:a50f895:             + "parameter style java external name 'java.lang.Math.abs' "
1:a50f895:             + "modifies sql data");
1:a50f895: 
1:a50f895:         // Declare a procedure as MODIFIES SQL DATA.
1:a50f895:         Statement s = createStatement();
1:a50f895:         s.execute("create procedure p(i int) language java "
1:a50f895:                 + "parameter style java external name '"
1:a50f895:                 + getClass().getName() + ".intProcedure' no sql");
1:a50f895: 
1:a50f895:         // Try to call that procedure from a WHEN clause. Expect it to fail
1:a50f895:         // because procedure invocations aren't allowed in a WHEN clause.
1:a50f895:         s.execute("create table t(x int)");
1:a50f895:         assertCompileError(SYNTAX_ERROR,
1:a50f895:             "create trigger tr after insert on t when (call p(1)) values 1");
1:a50f895:         assertCompileError(PROC_USED_AS_FUNC,
1:a50f895:             "create trigger tr after insert on t when (p(1)) values 1");
1:a50f895:     }
1:a50f895: 
1:a50f895:     /**
1:a50f895:      * Verify that aggregates (both built-in and user-defined) can be used
1:a50f895:      * in a WHEN clause.
1:a50f895:      */
1:a50f895:     public void testAggregates() throws SQLException {
1:a50f895:         Statement s = createStatement();
1:a50f895:         s.execute("create table t1(x int)");
1:a50f895:         s.execute("create table t2(y varchar(10))");
1:a50f895:         s.execute("create derby aggregate mode_int for int "
1:a50f895:                 + "external name '" + ModeAggregate.class.getName() + "'");
1:a50f895: 
1:a50f895:         s.execute("create trigger tr1 after insert on t1 "
1:a50f895:                 + "referencing new table as new "
1:a50f895:                 + "when ((select max(x) from new) between 0 and 3) "
1:a50f895:                 + "insert into t2 values 'tr1'");
1:a50f895: 
1:a50f895:         s.execute("create trigger tr2 after insert on t1 "
1:a50f895:                 + "referencing new table as new "
1:a50f895:                 + "when ((select count(x) from new) between 0 and 3) "
1:a50f895:                 + "insert into t2 values 'tr2'");
1:a50f895: 
1:a50f895:         s.execute("create trigger tr3 after insert on t1 "
1:a50f895:                 + "referencing new table as new "
1:a50f895:                 + "when ((select mode_int(x) from new) between 0 and 3) "
1:a50f895:                 + "insert into t2 values 'tr3'");
1:a50f895: 
1:a50f895:         s.execute("insert into t1 values 2, 4, 4");
1:a50f895:         JDBC.assertSingleValueResultSet(
1:a50f895:                 s.executeQuery("select * from t2 order by y"),
1:a50f895:                 "tr2");
1:a50f895: 
1:a50f895:         s.execute("delete from t2");
1:a50f895: 
1:a50f895:         s.execute("insert into t1 values 2, 2, 3, 1, 0");
1:a50f895:         JDBC.assertFullResultSet(
1:a50f895:                 s.executeQuery("select * from t2 order by y"),
1:a50f895:                 new String[][] {{"tr1"}, {"tr3"}});
1:a50f895:     }
1:1725dd1: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:54844c3
/////////////////////////////////////////////////////////////////////////
1:      * Test for Derby-6783.
1:      */
1: 
1:     public void testDerby6783() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         s.execute("CREATE TABLE tabDerby6783(id INTEGER, result VARCHAR(10), status CHAR(1))");
1: 
1:         s.execute("CREATE TRIGGER trigger6783 AFTER UPDATE OF status ON tabDerby6783 "
1:                 + "REFERENCING NEW AS newrow FOR EACH ROW WHEN (newrow.status='d') "
1:                 + "UPDATE tabDerby6783 SET result='completed' WHERE id=newrow.id");
1:         s.execute("insert into tabDerby6783 values (1, null, 'a')");
1:         // Fire the trigger.
1:         s.execute("UPDATE tabDerby6783 SET status='d'");
1:         
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("SELECT result FROM tabDerby6783"), 
1:                 "completed");
1:     }
1: 
1:     /**
1:      * Derby6783_1_1 test, this test has two trigger fields and
1:      * more than 3 column references in the update statement.
1:      */
1: 
1:     public void testDerby6783_1_1() throws SQLException 
1:     {
1:         Statement s = createStatement();
1: 
1:         s.execute("CREATE TABLE tabDerby6783_1_1(ID INTEGER, GRADE1 char(1), GRADE2 char(1),"
1:                     + " MARKS1 integer, MARKS2 integer, TOTAL_MARKS integer)");
1: 
1:         s.execute("CREATE TRIGGER trigger6783_1 AFTER UPDATE OF GRADE1, GRADE2 ON tabDerby6783_1_1"
1:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:                     + " FOR EACH ROW WHEN (oldrow.GRADE1 <> newrow.GRADE1 OR oldrow.GRADE2 <> newrow.GRADE2)"
1:                     + " UPDATE tabDerby6783_1_1 SET TOTAL_MARKS = oldrow.MARKS1 + oldrow.MARKS2 where id=newrow.id");
1: 
1:         s.execute("INSERT INTO tabDerby6783_1_1 VALUES (1, 'a', 'b', 30, 50, 0)");
1:         // Fire the trigger.
1:         s.execute("UPDATE tabDerby6783_1_1 SET GRADE1='b'");
1: 
1:         
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("SELECT TOTAL_MARKS FROM tabDerby6783_1_1"), 
1:                 "80");   
1:     }
1: 
1:     /**
1:      * Derby6783_1_2 test, is a less complex version of Derby6783_1_1
1:      * It has only one column reference in trigger part and in update part.
1:      */
1: 
1:     public void testDerby6783_1_2() throws SQLException 
1:     {
1:         Statement s = createStatement();
1: 
1:         s.execute("CREATE TABLE tabDerby6783_1_2(ID INTEGER, GRADE1 char(1), GRADE2 char(1),"
1:                     + " MARKS1 integer, MARKS2 integer, FINAL_GRADE char(1))");
1: 
1:         s.execute("CREATE TRIGGER trigger6783_1 AFTER UPDATE OF MARKS1 ON tabDerby6783_1_2 "
1:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:                     + " FOR EACH ROW WHEN (oldrow.MARKS1 <> newrow.MARKS1)"
1:                     + " UPDATE tabDerby6783_1_2 SET FINAL_GRADE = oldrow.GRADE1 where id=newrow.id");  
1: 
1:         s.execute("INSERT INTO tabDerby6783_1_2 VALUES (1, 'a', 'b', 30, 50, 'c')");
1: 
1:         s.execute("UPDATE tabDerby6783_1_2 SET MARKS1=20");
1: 
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("SELECT FINAL_GRADE FROM tabDerby6783_1_2"), 
1:                 "a");  
1:     }
1: 
1:     /**
1:      * Derby6783_2 test, this test has a single trigger column reference
1:      * and two column reference in update statement. Also the when clause
1:      * has a different column reference than the trigger reference
1:     */
1: 
1:     public void testDerby6783_2() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE tabDerby6783_2(ACC_NUMBER INT, BALANCE FLOAT, RATE REAL,"
1:                     + " INTEREST REAL)");
1: 
1:         s.execute("CREATE TRIGGER trigger_2 AFTER UPDATE OF BALANCE ON tabDerby6783_2 "
1:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:                     + " FOR EACH ROW WHEN (oldrow.RATE < 10.0)"
1:                     + " UPDATE tabDerby6783_2 SET INTEREST = oldrow.balance + newrow.BALANCE * RATE");
1: 
1:         s.execute("INSERT INTO tabDerby6783_2 VALUES (123, 12383.4534, 8.98, 2340)");
1: 
1:         s.execute("UPDATE tabDerby6783_2 SET BALANCE=22383.4543");
1: 
1:         s.execute("select INTEREST from tabDerby6783_2");
1: 
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("SELECT INTEREST FROM tabDerby6783_2"), 
1:                 "213386.86");         
1:     }
1: 
1:     /**
1:      * Derby6783_3 test, this test referes to different tables in
1:      * when clause and update clause.
1:     */
1: 
1:     public void testDerby6783_3() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE tabDerby6783_3_1(FIELD1 VARCHAR(10),"
1:                     + " FIELD2 DOUBLE)");
1: 
1:         s.execute("INSERT INTO tabDerby6783_3_1 VALUES ('helloworld', 5454567)");
1: 
1:         s.execute("CREATE TABLE tabDerby6783_3_2(FIELD3 NUMERIC (7,1))");
1: 
1:         s.execute("INSERT INTO tabDerby6783_3_2 VALUES (3.143)");
1: 
1:         s.execute("CREATE TRIGGER TRIGGER_3 AFTER UPDATE OF FIELD1 ON tabDerby6783_3_1"
1:                     + " REFERENCING NEW AS newrow OLD AS oldrow"
1:                     + " FOR EACH ROW WHEN (newrow.FIELD2 > 3000)"
1:                     + " UPDATE tabDerby6783_3_2 SET FIELD3 = newrow.FIELD2 / 10");
1: 
1:         s.execute("UPDATE tabDerby6783_3_1 set FIELD1='hello'");
1: 
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("SELECT FIELD3 FROM tabDerby6783_3_2"),
1:                 "545456.7");
1:     }
1: 
1:     /**
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1:         // Dropping a table referenced in a WHEN clause should fail and leave
1:         // the trigger intact. Before DERBY-2041, DROP TABLE would succeed
1:         // and leave the trigger in an invalid state so that subsequent
1:         // INSERT statements would fail when trying to fire the trigger.
1:         assertStatementError(HAS_DEPENDENTS, s, "drop table t2");
1:         s.executeUpdate("insert into t1 values (1, 2, 3)");
/////////////////////////////////////////////////////////////////////////
1:         // DROP TABLE should fail because of the dependencies (didn't before
1:         // DERBY-2041).
1:         assertStatementError(HAS_DEPENDENTS, s, "drop table t2");
/////////////////////////////////////////////////////////////////////////
1:         c1.setAutoCommit(false);
1:         JDBC.dropSchema(c1.getMetaData(), "U1");
commit:a50f895
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     private static final String PROC_USED_AS_FUNC = "42Y03";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * The WHEN clause text is stored in a LONG VARCHAR column in the
1:      * SYS.SYSTRIGGERS table. This test case verifies that the WHEN clause
1:      * is not limited to the usual LONG VARCHAR maximum length (32700
1:      * characters).
1:      */
1:     public void testVeryLongWhenClause() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x int)");
1: 
1:         // Construct a WHEN clause that is more than 32700 characters.
1:         StringBuilder sb = new StringBuilder("(values /* a very");
1:         for (int i = 0; i < 10000; i++) {
1:             sb.append(", very");
1:         }
1:         sb.append(" long comment */ true)");
1: 
1:         String when = sb.toString();
1:         assertTrue(when.length() > 32700);
1: 
1:         s.execute("create trigger very_long_trigger after insert on t1 "
1:                 + "when (" + when + ") insert into t2 values 1");
1: 
1:         // Verify that the WHEN clause was stored in SYS.SYSTRIGGERS.
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery("select whenclausetext from sys.systriggers "
1:                          + "where triggername = 'VERY_LONG_TRIGGER'"),
1:             when);
1: 
1:         // Verify that the trigger fires.
1:         s.execute("insert into t1 values 1");
1:         assertTableRowCount("T1", 1);
1:         assertTableRowCount("T2", 1);
1:     }
1: 
1:     /**
1:      * Test a WHEN clause that invokes a function declared with READ SQL DATA.
1:      */
1:     public void testFunctionReadsSQLData() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create function f(x varchar(10)) returns boolean "
1:                 + "language java parameter style java external name '"
1:                 + getClass().getName() + ".tableIsEmpty' reads sql data");
1: 
1:         s.execute("create table t1(x varchar(10))");
1:         s.execute("create table t2(x varchar(10))");
1:         s.execute("create table t3(x int)");
1:         s.execute("create table t4(x int)");
1:         s.execute("insert into t3 values 1");
1: 
1:         s.execute("create trigger tr after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (f(new.x)) insert into t2 values new.x");
1: 
1:         s.execute("insert into t1 values 'T3', 'T4', 'T3', 'T4', 'T3', 'T4'");
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select x, count(x) from t2 group by x"),
1:                 new String[][] {{"T4", "3"}});
1:     }
1: 
1:     /**
1:      * Stored function used by {@link #testFunctionReadsSQLData()}. It
1:      * checks whether the given table is empty.
1:      *
1:      * @param table the table to check
1:      * @return {@code true} if the table is empty, {@code false} otherwise
1:      */
1:     public static boolean tableIsEmpty(String table) throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         ResultSet rs = s.executeQuery("select * from " + JDBC.escape(table));
1:         boolean empty = !rs.next();
1: 
1:         rs.close();
1:         s.close();
1:         c.close();
1: 
1:         return empty;
1:     }
1: 
1:     /**
1:      * <p>
1:      * SQL:2011, part 2, 11.49 &lt;trigger definition&gt;, syntax rule 11
1:      * says that the WHEN clause shall not contain routines that possibly
1:      * modifies SQL data. Derby does not currently allow functions to be
1:      * declared as MODIFIES SQL DATA. It does allow procedures to be declared
1:      * as MODIFIES SQL DATA, but the current grammar does not allow procedures
1:      * to be invoked from a WHEN clause. So there's currently no way to
1:      * invoke routines that possibly modifies SQL data from a WHEN clause.
1:      * </p>
1:      *
1:      * <p>
1:      * This test case verifies that it is not possible to declare a function
1:      * as MODIFIES SQL DATA, and that it is not possible to call a procedure
1:      * from a WHEN clause. If support for any of those features is added,
1:      * this test case will start failing as a reminder that code must be
1:      * added to prevent routines that possibly modifies SQL data from being
1:      * invoked from a WHEN clause.
1:      * </p>
1:      */
1:     public void testRoutineModifiesSQLData() throws SQLException {
1:         // Functions cannot be declared as MODIFIES SQL DATA currently.
1:         // Expect a syntax error.
1:         assertCompileError(SYNTAX_ERROR,
1:             "create function f(x int) returns int language java "
1:             + "parameter style java external name 'java.lang.Math.abs' "
1:             + "modifies sql data");
1: 
1:         // Declare a procedure as MODIFIES SQL DATA.
1:         Statement s = createStatement();
1:         s.execute("create procedure p(i int) language java "
1:                 + "parameter style java external name '"
1:                 + getClass().getName() + ".intProcedure' no sql");
1: 
1:         // Try to call that procedure from a WHEN clause. Expect it to fail
1:         // because procedure invocations aren't allowed in a WHEN clause.
1:         s.execute("create table t(x int)");
1:         assertCompileError(SYNTAX_ERROR,
1:             "create trigger tr after insert on t when (call p(1)) values 1");
1:         assertCompileError(PROC_USED_AS_FUNC,
1:             "create trigger tr after insert on t when (p(1)) values 1");
1:     }
1: 
1:     /**
1:      * Verify that aggregates (both built-in and user-defined) can be used
1:      * in a WHEN clause.
1:      */
1:     public void testAggregates() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(y varchar(10))");
1:         s.execute("create derby aggregate mode_int for int "
1:                 + "external name '" + ModeAggregate.class.getName() + "'");
1: 
1:         s.execute("create trigger tr1 after insert on t1 "
1:                 + "referencing new table as new "
1:                 + "when ((select max(x) from new) between 0 and 3) "
1:                 + "insert into t2 values 'tr1'");
1: 
1:         s.execute("create trigger tr2 after insert on t1 "
1:                 + "referencing new table as new "
1:                 + "when ((select count(x) from new) between 0 and 3) "
1:                 + "insert into t2 values 'tr2'");
1: 
1:         s.execute("create trigger tr3 after insert on t1 "
1:                 + "referencing new table as new "
1:                 + "when ((select mode_int(x) from new) between 0 and 3) "
1:                 + "insert into t2 values 'tr3'");
1: 
1:         s.execute("insert into t1 values 2, 4, 4");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t2 order by y"),
1:                 "tr2");
1: 
1:         s.execute("delete from t2");
1: 
1:         s.execute("insert into t1 values 2, 2, 3, 1, 0");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from t2 order by y"),
1:                 new String[][] {{"tr1"}, {"tr3"}});
1:     }
commit:1061fd2
/////////////////////////////////////////////////////////////////////////
1:     private static final String TRIGGER_RECURSION = "54038";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that a WHEN clause can call the CURRENT_USER function.
1:      */
1:     public void testCurrentUser() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x varchar(10))");
1: 
1:         // Create one trigger that should only fire when current user is U2,
1:         // and one that should only fire when current user is different from
1:         // U2.
1:         s.execute("create trigger tr01 after insert on t1 "
1:                 + "when (current_user = 'U2') "
1:                 + "insert into t2 values 'TR01'");
1:         s.execute("create trigger tr02 after insert on t1 "
1:                 + "when (current_user <> 'U2') "
1:                 + "insert into t2 values 'TR02'");
1:         s.execute("grant insert on t1 to u2");
1: 
1:         commit();
1: 
1:         // Used to get an assert failure or a NullPointerException here before
1:         // DERBY-6348. Expect it to succeed, and expect TR02 to have fired.
1:         s.execute("insert into t1 values 1");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t2"), "TR02");
1: 
1:         rollback();
1: 
1:         // Now try the same insert as user U2.
1:         Connection c2 = openUserConnection("u2");
1:         c2.setAutoCommit(true);
1:         Statement s2 = c2.createStatement();
1:         s2.execute("insert into "
1:             + JDBC.escape(TestConfiguration.getCurrent().getUserName(), "T1")
1:             + " values 1");
1:         s2.close();
1:         c2.close();
1: 
1:         // Since the insert was performed by user U2, expect TR01 to have fired.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t2"), "TR01");
1: 
1:         // Cleanup.
1:         dropTable("T1");
1:         dropTable("T2");
1:         commit();
1:     }
1: 
1:     /**
1:      * Test that a trigger with a WHEN clause can be recursive.
1:      */
1:     public void testRecursiveTrigger() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t(x int)");
1:         s.execute("create trigger tr1 after insert on t "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x > 0) insert into t values new.x - 1");
1: 
1:         // Now fire the trigger. This used to cause an assert failure or a
1:         // NullPointerException before DERBY-6348.
1:         s.execute("insert into t values 15, 1, 2");
1: 
1:         // The row trigger will fire three times, so that the above statement
1:         // will insert the values { 15, 14, 13, ... , 0 }, { 1, 0 } and
1:         // { 2, 1, 0 }.
1:         String[][] expectedRows = {
1:             {"0"}, {"0"}, {"0"}, {"1"}, {"1"}, {"1"}, {"2"}, {"2"}, {"3"},
1:             {"4"}, {"5"}, {"6"}, {"7"}, {"8"}, {"9"}, {"10"}, {"11"},
1:             {"12"}, {"13"}, {"14"}, {"15"}
1:         };
1: 
1:         JDBC.assertFullResultSet(s.executeQuery("select * from t order by x"),
1:                                  expectedRows);
1: 
1:         // Now fire the trigger with a value so that the maximum trigger
1:         // recursion depth (16) is exceeded, and verify that we get the
1:         // expected error.
1:         assertStatementError(TRIGGER_RECURSION, s, "insert into t values 16");
1: 
1:         // The contents of the table should not have changed, since the
1:         // above statement failed and was rolled back.
1:         JDBC.assertFullResultSet(s.executeQuery("select * from t order by x"),
1:                                  expectedRows);
1:     }
commit:05b022f
/////////////////////////////////////////////////////////////////////////
1:     private static final String NOT_SINGLE_COLUMN = "42X39";
1:     private static final String NON_SCALAR_QUERY = "21000";
/////////////////////////////////////////////////////////////////////////
1:      * A row trigger whose WHEN clause contains a subquery, used to cause a
1:      * NullPointerException in some situations.
1:     public void testSubqueryInWhenClauseNPE() throws SQLException {
1:         // This statement used to result in a NullPointerException.
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Subqueries in the WHEN clause must have a single column
1:         assertCompileError(NOT_SINGLE_COLUMN,
1:                 "create trigger tr no cascade before insert on t1 "
1:                 + "when ((values (true, false))) call int_proc(1)");
1:         assertCompileError(NOT_SINGLE_COLUMN,
1:                 "create trigger tr after update of x on t1 "
1:                 + "when ((select tablename, schemaid from sys.systables)) "
1:                 + "call int_proc(1)");
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that scalar subqueries are allowed, and that non-scalar subqueries
1:      * result in exceptions when the trigger fires.
1:      */
1:     public void testScalarSubquery() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x int)");
1:         s.execute("create table t3(x int)");
1: 
1:         s.execute("insert into t3 values 0,1,2,2");
1: 
1:         s.execute("create trigger tr1 after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when ((select x > 0 from t3 where x = new.x)) "
1:                 + "insert into t2 values 1");
1: 
1:         // Subquery returns no rows, so the trigger should not fire.
1:         s.execute("insert into t1 values 42");
1:         assertTableRowCount("T2", 0);
1: 
1:         // Subquery returns a single value, which is false, so the trigger
1:         // should not fire.
1:         s.execute("insert into t1 values 0");
1:         assertTableRowCount("T2", 0);
1: 
1:         // Subquery returns a single value, which is true, so the trigger
1:         // should fire.
1:         s.execute("insert into t1 values 1");
1:         assertTableRowCount("T2", 1);
1: 
1:         // Subquery returns multiple values, so an error should be raised.
1:         assertStatementError(NON_SCALAR_QUERY, s, "insert into t1 values 2");
1:         assertTableRowCount("T2", 1);
1:     }
commit:c955b82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     private static final String NOT_AUTHORIZED = "42504";
1:     private static final String NO_TABLE_PERMISSION = "42500";
1:     private static final String USER_EXCEPTION = "38000";
1:     private static final String JAVA_EXCEPTION = "XJ001";
1:         return TestConfiguration.sqlAuthorizationDecorator(
1:             new CleanDatabaseTestSetup(
1:                 TestConfiguration.embeddedSuite(TriggerWhenClauseTest.class)));
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * When SQL authorization is enabled, the trigger action (including the
1:      * WHEN clause) should execute with definer's rights. Verify that it is
1:      * so.
1:      */
1:     public void testGrantRevoke() throws SQLException {
1:         Connection c1 = openDefaultConnection("u1", "dummy");
1:         c1.setAutoCommit(true);
1:         Statement s1 = c1.createStatement();
1: 
1:         s1.execute("create table t1(x varchar(20))");
1:         s1.execute("create table t2(x varchar(200))");
1:         s1.execute("create table t3(x int)");
1:         s1.execute("create function is_true(s varchar(128)) returns boolean "
1:                 + "deterministic language java parameter style java "
1:                 + "external name 'java.lang.Boolean.parseBoolean' no sql");
1: 
1:         // Trigger that fires on T1 if inserted value is 'true'.
1:         s1.execute("create trigger tr1 after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (is_true(new.x)) insert into t2(x) values new.x");
1: 
1:         // Trigger that fires on T1 on insert if T3 has more than 1 row.
1:         s1.execute("create trigger tr2 after insert on t1 "
1:                 + "when (exists (select * from t3 offset 1 row)) "
1:                 + "insert into t2(x) values '***'");
1: 
1:         // Allow U2 to insert into T1, but nothing else on U1's schema.
1:         s1.execute("grant insert on table t1 to u2");
1: 
1:         Connection c2 = openDefaultConnection("u2", "dummy");
1:         c2.setAutoCommit(true);
1:         Statement s2 = c2.createStatement();
1: 
1:         // User U2 is not authorized to invoke the function IS_TRUE, but
1:         // is allowed to insert into T1.
1:         assertStatementError(NOT_AUTHORIZED, s2, "values u1.is_true('abc')");
1:         assertUpdateCount(s2, 4,
1:                 "insert into u1.t1(x) values 'abc', 'true', 'TrUe', 'false'");
1: 
1:         // Verify that the trigger fired. Since the trigger runs with
1:         // definer's rights, it should be allowed to invoke IS_TRUE in the
1:         // WHEN clause even though U2 isn't allowed to invoke it directly.
1:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:                                  new String[][] {{"TrUe"}, {"true"}});
1:         s1.execute("delete from t2");
1: 
1:         // Now test that TR1 will also fire, even though U2 isn't granted
1:         // SELECT privileges on the table read by the WHEN clause.
1:         s1.execute("insert into t3 values 1, 2");
1:         assertUpdateCount(s2, 2, "insert into u1.t1(x) values 'x', 'y'");
1:         JDBC.assertSingleValueResultSet(
1:                 s1.executeQuery("select * from t2 order by x"), "***");
1:         s1.execute("delete from t2");
1: 
1:         // Now invalidate the triggers and make sure they still work after
1:         // recompilation.
1:         s1.execute("alter table t1 alter column x set data type varchar(200)");
1:         assertUpdateCount(s2, 2, "insert into u1.t1(x) values 'true', 'false'");
1:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:                                  new String[][] {{"***"}, {"true"}});
1:         s1.execute("delete from t2");
1: 
1:         // Revoke U2's insert privilege on T1.
1:         s1.execute("revoke insert on table t1 from u2 ");
1: 
1:         // U2 should not be allowed to insert into T1 anymore.
1:         assertStatementError(NO_TABLE_PERMISSION, s2,
1:                              "insert into u1.t1(x) values 'abc'");
1: 
1:         // U1 should still be allowed to do it (since U1 owns T1), and the
1:         // triggers should still be working.
1:         assertUpdateCount(s1, 2, "insert into t1(x) values 'true', 'false'");
1:         JDBC.assertFullResultSet(s1.executeQuery("select * from t2 order by x"),
1:                                  new String[][] {{"***"}, {"true"}});
1:         s1.execute("delete from t2");
1: 
1:         // Now try to define a trigger in U2's schema that needs to invoke
1:         // U1.IS_TRUE. Should fail because U2 isn't allowed to invoke it.
1:         s2.execute("create table t(x varchar(200))");
1:         assertStatementError(NOT_AUTHORIZED, s2,
1:                              "create trigger tr after insert on t "
1:                              + "referencing new as new for each row "
1:                              + "when (u1.is_true(new.x)) values 1");
1: 
1:         // Try again after granting execute permission to U2.
1:         s1.execute("grant execute on function is_true to u2");
1:         s2.execute("create trigger tr after insert on t "
1:                 + "referencing new as new for each row "
1:                 + "when (u1.is_true(new.x)) values 1");
1: 
1:         // Fire trigger.
1:         assertUpdateCount(s2, 3, "insert into t values 'ab', 'cd', 'ef'");
1: 
1:         // Revoking the execute permission will fail because the trigger
1:         // depends on it.
1:         assertStatementError(HAS_DEPENDENTS, s1,
1:                 "revoke execute on function is_true from u2 restrict");
1: 
1:         s1.close();
1:         s2.close();
1: 
0:         c1.setAutoCommit(false);
0:         JDBC.dropSchema(c1.getMetaData(), "U1");
1:         c2.setAutoCommit(false);
1:         JDBC.dropSchema(c2.getMetaData(), "U2");
1:     }
1: 
1:     /**
1:      * Test that the trigger fails gracefully if the WHEN clause throws
1:      * a RuntimeException.
1:      */
1:     public void testRuntimeException() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create function f(x varchar(10)) returns int "
1:                 + "deterministic language java parameter style java "
1:                 + "external name 'java.lang.Integer.parseInt' no sql");
1:         s.execute("create table t1(x varchar(10))");
1:         s.execute("create table t2(x varchar(10))");
1:         s.execute("create trigger tr after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (f(new.x) < 100) insert into t2 values new.x");
1: 
1:         // Insert a value that causes Integer.parseInt() to throw a
1:         // NumberFormatException. The NFE will be wrapped in two SQLExceptions.
1:         assertStatementError(new String[] {USER_EXCEPTION, JAVA_EXCEPTION}, s,
1:                 "insert into t1 values '1', '2', 'hello', '3', '121'");
1: 
1:         // The statement should be rolled back, so nothing should be in
1:         // either of the tables.
1:         assertTableRowCount("T1", 0);
1:         assertTableRowCount("T2", 0);
1: 
1:         // Now try again with values that don't cause exceptions.
1:         assertUpdateCount(s, 4, "insert into t1 values '1', '2', '3', '121'");
1: 
1:         // Verify that the trigger fired this time.
1:         JDBC.assertFullResultSet(s.executeQuery("select * from t2 order by x"),
1:                                  new String[][] {{"1"}, {"2"}, {"3"}});
1:     }
commit:50734d8
/////////////////////////////////////////////////////////////////////////
1:     private static final String TRUNCATION = "22001";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify that DERBY-4874, which was fixed before support for the WHEN
1:      * clause was implemented, does not affect the WHEN clause.
1:      * The first stab at the WHEN clause implementation did suffer from it.
1:      */
1:     public void testDerby4874() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t(x varchar(3))");
1:         s.execute("create trigger tr after update of x on t "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x < 'abc') values 1");
1:         s.execute("insert into t values 'aaa'");
1: 
1:         // Updating X to something longer than 3 characters should fail,
1:         // since it's a VARCHAR(3).
1:         assertStatementError(TRUNCATION, s, "update t set x = 'aaaa'");
1: 
1:         // Change the type of X to VARCHAR(4) and try again. This time it
1:         // should succeed, but it used to fail because the trigger hadn't
1:         // been recompiled and still thought the max length was 3.
1:         s.execute("alter table t alter x set data type varchar(4)");
1:         assertUpdateCount(s, 1, "update t set x = 'aaaa'");
1: 
1:         // Updating it to a longer value should still fail.
1:         assertStatementError(TRUNCATION, s, "update t set x = 'aaaaa'");
1:     }
1: 
1:     /**
1:      * Verify that Cloudscape bug 4821, which was fixed long before support
1:      * for the WHEN clause was implemented, does not affect the WHEN clause.
1:      * The first stab at the WHEN clause implementation did suffer from it.
1:      */
1:     public void testCloudscapeBug4821() throws SQLException {
1:         // First create a trigger, and immediately perform an ALTER TABLE
1:         // statement on the trigger table to make sure the trigger's SPS is
1:         // invalid and must be recompiled the first time it's fired.
1:         Statement s = createStatement();
1:         s.execute("create table cs4821.t(x int)");
1:         s.execute("create trigger cs4821.tr after insert on cs4821.t "
1:                 + "when (true) values 1");
1:         s.execute("alter table cs4821.t add column y int");
1:         commit();
1: 
1:         // Fire the trigger and leave the transaction open afterwards.
1:         s.execute("insert into cs4821.t(x) values 1");
1: 
1:         // Now try to read all rows from the SYS.SYSSTATEMENTS table from
1:         // another transaction. Used to time out because the transaction
1:         // that recompiled the trigger kept the lock on the system table.
1:         Connection c2 = openDefaultConnection();
1:         Statement s2 = c2.createStatement();
1:         JDBC.assertDrainResults(
1:                 s2.executeQuery("select * from sys.sysstatements"));
1:         s2.close();
1:         JDBC.cleanup(c2);
1: 
1:         // Remove all tables and triggers created by this test case.
1:         JDBC.dropSchema(getConnection().getMetaData(), "CS4821");
1:     }
commit:d23659a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Savepoint;
/////////////////////////////////////////////////////////////////////////
1:     private static final String HAS_DEPENDENTS = "X0Y25";
1:     private static final String TABLE_DOES_NOT_EXIST = "42X05";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that dropping objects referenced from the WHEN clause will
1:      * detect that the trigger depends on the object.
1:      */
1:     public void testDependencies() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int, y int, z int)");
1:         s.execute("create table t2(x int, y int, z int)");
1: 
1:         Savepoint sp = getConnection().setSavepoint();
1: 
1:         // Dropping columns referenced via the NEW transition variable in
1:         // a WHEN clause should fail.
1:         s.execute("create trigger tr after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x < new.y) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         s.execute("alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // Dropping columns referenced via the OLD transition variable in
1:         // a WHEN clause should fail.
1:         s.execute("create trigger tr no cascade before delete on t1 "
1:                 + "referencing old as old for each row "
1:                 + "when (old.x < old.y) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         s.execute("alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // Dropping columns referenced via either the OLD or the NEW
1:         // transition variable referenced in the WHEN clause should fail.
1:         s.execute("create trigger tr no cascade before update on t1 "
1:                 + "referencing old as old new as new for each row "
1:                 + "when (old.x < new.y) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         s.execute("alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // Dropping columns referenced either in the WHEN clause or in the
1:         // triggered SQL statement should fail.
1:         s.execute("create trigger tr no cascade before insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x < 5) values new.y");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         s.execute("alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // Dropping any column in a statement trigger with a NEW transition
1:         // table fails, even if the column is not referenced in the WHEN clause
1:         // or in the triggered SQL text.
1:         s.execute("create trigger tr after update of x on t1 "
1:                 + "referencing new table as new "
1:                 + "when (exists (select 1 from new where x < y)) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         // Z is not referenced, but the transition table depends on all columns.
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // Dropping any column in a statement trigger with an OLD transition
1:         // table fails, even if the column is not referenced in the WHEN clause
1:         // or in the triggered SQL text.
1:         s.execute("create trigger tr after delete on t1 "
1:                 + "referencing old table as old "
1:                 + "when (exists (select 1 from old where x < y)) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         // Z is not referenced, but the transition table depends on all columns.
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // References to columns in other ways than via transition variables
1:         // or transition tables should also be detected.
1:         s.execute("create trigger tr after delete on t1 "
1:                 + "referencing old table as old "
1:                 + "when (exists (select 1 from t1 where x < y)) values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t1 drop column y restrict");
1:         s.execute("alter table t1 drop column z restrict");
1:         getConnection().rollback(sp);
1: 
1:         // References to columns in another table than the trigger table
1:         // should prevent them from being dropped.
1:         s.execute("create trigger tr after insert on t1 "
1:                 + "when (exists (select * from t2 where x < y)) "
1:                 + "values 1");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t2 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t2 drop column y restrict");
1:         s.execute("alter table t2 drop column z restrict");
1: 
0:         // Because of DERBY-2041, dropping the whole table silently succeeds
0:         // and leaves the trigger around. It should have caused a warning and
0:         // dropped the trigger.
0:         s.execute("drop table t2");
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery("select triggername from sys.systriggers"), "TR");
0:         // The trigger wasn't dropped, but it is now invalid and causes the
0:         // triggering insert to fail.
0:         assertStatementError(TABLE_DOES_NOT_EXIST, s,
0:                 "insert into t1 values (1, 2, 3)");
1:         getConnection().rollback(sp);
1: 
1:         // Test references to columns in both the WHEN clause and the
1:         // triggered SQL statement.
1:         s.execute("create trigger tr after update on t1 "
1:                 + "when (exists (select * from t2 where x < 5)) "
1:                 + "select y from t2");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t2 drop column x restrict");
1:         assertStatementError(HAS_DEPENDENTS, s,
1:                 "alter table t2 drop column y restrict");
1:         s.execute("alter table t2 drop column z restrict");
1: 
0:         // Again, because of DERBY-2041, DROP TABLE fails to cascade and
0:         // drop the trigger.
0:         s.execute("drop table t2");
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery("select triggername from sys.systriggers"), "TR");
1:         getConnection().rollback(sp);
1:     }
commit:00b0dbe
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify that the SPS of a WHEN clause is invalidated when one of its
1:      * dependencies is changed in a way that requires recompilation.
1:      */
1:     public void testWhenClauseInvalidation() throws SQLException {
1:         // Statement that checks the validity of the WHEN clause SPS.
1:         PreparedStatement spsValid = prepareStatement(
1:                 "select valid from sys.sysstatements "
1:                 + "where stmtname like 'TRIGGERWHEN%'");
1: 
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x int)");
1:         s.execute("create table t3(x int)");
1:         s.execute("insert into t1 values 1");
1: 
1:         s.execute("create trigger tr after insert on t2 "
1:                 + "referencing new as new for each row "
1:                 + "when (exists (select * from t1 where x = new.x)) "
1:                 + "insert into t3 values new.x");
1: 
1:         // SPS is initially valid.
1:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "true");
1: 
1:         // Compressing the table referenced in the WHEN clause should
1:         // invalidate the SPS.
1:         PreparedStatement compress = prepareStatement(
1:                 "call syscs_util.syscs_compress_table(?, 'T1', 1)");
1:         compress.setString(1, TestConfiguration.getCurrent().getUserName());
1:         compress.execute();
1:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "false");
1: 
1:         // Invoking the trigger should recompile the SPS.
1:         s.execute("insert into t2 values 0,1,2");
1:         JDBC.assertSingleValueResultSet(spsValid.executeQuery(), "true");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t3"), "1");
1:     }
commit:df73e36
/////////////////////////////////////////////////////////////////////////
1:     private static final String SYNTAX_ERROR = "42X01";
1:     private static final String NOT_BOOLEAN = "42X19";
1:     private static final String HAS_PARAMETER = "42Y27";
/////////////////////////////////////////////////////////////////////////
1:         // Scalar subqueries are allowed in the WHEN clause, but they need an
1:         // extra set of parantheses.
1:         //
1:         // The first set of parantheses is required by the WHEN clause syntax
1:         // itself: WHEN ( <search condition> )
1:         //
1:         // The second set of parantheses is required by <search condition>.
1:         // Follow this path through the SQL standard's syntax rules:
1:         //    <search condition> -> <boolean value expression>
1:         //      -> <boolean term> -> <boolean factor> -> <boolean test>
1:         //      -> <boolean primary> -> <boolean predicand>
1:         //      -> <nonparenthesized value expression primary>
1:         //      -> <scalar subquery> -> <subquery> -> <left paren>
1:         assertCompileError(SYNTAX_ERROR,
1:                 "create trigger tr12 after insert on t1 "
1:                 + "when (values true) insert into t2 values 'Executed tr12'");
1:         assertCompileError(SYNTAX_ERROR,
1:                 "create trigger tr13 after insert on t1 "
1:                 + "when (select true from sysibm.sysdummy1) "
1:                 + "insert into t2 values 'Executed tr13'");
1:         s.execute("create trigger tr12 after insert on t1 "
1:                 + "when ((values true)) insert into t2 values 'Executed tr12'");
1:         s.execute("create trigger tr13 after insert on t1 "
1:                 + "when ((select true from sysibm.sysdummy1)) "
1:                 + "insert into t2 values 'Executed tr13'");
1: 
/////////////////////////////////////////////////////////////////////////
1:                 { "Executed tr12", "1" },
1:                 { "Executed tr13", "1" },
/////////////////////////////////////////////////////////////////////////
1:                 { "Executed tr12", "1" },
1:                 { "Executed tr13", "1" },
/////////////////////////////////////////////////////////////////////////
1:      * Test various illegal WHEN clauses.
1:     public void testIllegalWhenClauses() throws SQLException {
1:         s.execute("create procedure int_proc(i int) language java "
1:                 + "parameter style java external name '"
1:                 + getClass().getName() + ".intProcedure' no sql");
1:         // CREATE TRIGGER should fail if the WHEN clause references a table
1:         // in the SESSION schema.
1: 
1:         // The WHEN clause expression must be BOOLEAN.
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr after insert on t1 "
1:                 + "when (1) insert into t2 values 1");
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr after update on t1 "
1:                 + "when ('abc') insert into t2 values 1");
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr after delete on t1 "
1:                 + "when ((values 1)) insert into t2 values 1");
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr no cascade before insert on t1 "
1:                 + "when ((select ibmreqd from sysibm.sysdummy1)) "
1:                 + "call int_proc(1)");
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr no cascade before insert on t1 "
1:                 + "when ((select ibmreqd from sysibm.sysdummy1)) "
1:                 + "call int_proc(1)");
1:         assertCompileError(NOT_BOOLEAN,
1:                 "create trigger tr no cascade before update on t1 "
1:                 + "referencing old as old for each row "
1:                 + "when (old.x) call int_proc(1)");
1: 
1:         // Dynamic parameters (?) are not allowed in the WHEN clause.
1:         assertCompileError(HAS_PARAMETER,
1:                 "create trigger tr no cascade before delete on t1 "
1:                 + "when (?) call int_proc(1)");
1:         assertCompileError(HAS_PARAMETER,
1:                 "create trigger tr after insert on t1 "
1:                 + "when (cast(? as boolean)) call int_proc(1)");
1:         assertCompileError(HAS_PARAMETER,
1:                 "create trigger tr after delete on t1 "
1:                 + "when ((select true from sysibm.sysdummy where ibmreqd = ?)) "
1:                 + "call int_proc(1)");
commit:51f910f
/////////////////////////////////////////////////////////////////////////
1:     private static final String REFERENCES_SESSION_SCHEMA = "XCL51";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Test that CREATE TRIGGER fails if the WHEN clause references a table
0:      * in the SESSION schema.
1:      */
0:     public void testSessionSchema() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("declare global temporary table temptable (x int) "
1:                 + "not logged");
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x int)");
1: 
1:         assertCompileError(REFERENCES_SESSION_SCHEMA,
1:                 "create trigger tr1 after insert on t1 "
1:                 + "when (exists (select * from session.temptable)) "
1:                 + "insert into t2 values 1");
1:     }
commit:6a17f80
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * List that tracks calls to {@code intProcedure()}. It is used to verify
1:      * that triggers have fired.
1:      */
1:     private static List<Integer> procedureCalls;
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void setUp() {
1:         procedureCalls = Collections.synchronizedList(new ArrayList<Integer>());
1:     }
1: 
1:     @Override
1:     protected void tearDown() throws Exception {
1:         procedureCalls = null;
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * A procedure that takes an {@code int} argument and adds it to the
1:      * {@link #procedureCalls} list. Can be used as a stored procedure to
1:      * verify that a trigger has been called. Particularly useful in BEFORE
1:      * triggers, as they are not allowed to modify SQL data.
1:      *
1:      * @param i an integer
1:      */
1:     public static void intProcedure(int i) {
1:         procedureCalls.add(i);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test generated columns referenced from WHEN clauses. In particular,
1:      * test that references to generated columns are disallowed in the NEW
1:      * transition variable of BEFORE triggers. See DERBY-3948.
1:      *
1:      * @see GeneratedColumnsTest#test_024_beforeTriggers()
1:      */
1:     public void testGeneratedColumns() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int, y int, "
1:                 + "z int generated always as (x+y))");
1:         s.execute("create table t2(x int)");
1:         s.execute("create procedure int_proc(i int) language java "
1:                 + "parameter style java external name '"
1:                 + getClass().getName() + ".intProcedure' no sql");
1: 
1:         // BEFORE INSERT trigger without generated column in WHEN clause, OK.
1:         s.execute("create trigger btr1 no cascade before insert on t1 "
1:                 + "referencing new as new for each row when (new.x < new.y) "
1:                 + "call int_proc(1)");
1: 
1:         // BEFORE INSERT trigger with generated column in WHEN clause, fail.
1:         assertCompileError(GeneratedColumnsHelper.BAD_BEFORE_TRIGGER,
1:                 "create trigger btr2 no cascade before insert on t1 "
1:                 + "referencing new as new for each row when (new.x < new.z) "
1:                 + "select * from sysibm.sysdummy1");
1: 
1:         // BEFORE UPDATE trigger without generated column in WHEN clause, OK.
1:         s.execute("create trigger btr3 no cascade before update on t1 "
1:                 + "referencing new as new old as old for each row "
1:                 + "when (new.x < old.x) call int_proc(3)");
1: 
1:         // BEFORE UPDATE trigger with generated column in WHEN clause. OK,
1:         // since the generated column is in the OLD transition variable.
1:         s.execute("create trigger btr4 no cascade before update on t1 "
1:                 + "referencing old as old for each row when (old.x < old.z) "
1:                 + "call int_proc(4)");
1: 
1:         // BEFORE UPDATE trigger with generated column in NEW transition
1:         // variable, fail.
1:         assertCompileError(GeneratedColumnsHelper.BAD_BEFORE_TRIGGER,
1:                 "create trigger btr5 no cascade before update on t1 "
1:                 + "referencing new as new for each row when (new.x < new.z) "
1:                 + "select * from sysibm.sysdummy1");
1: 
1:         // BEFORE DELETE trigger without generated column in WHEN clause, OK.
1:         s.execute("create trigger btr6 no cascade before delete on t1 "
1:                 + "referencing old as old for each row when (old.x < 3) "
1:                 + "call int_proc(6)");
1: 
1:         // BEFORE DELETE trigger with generated column in WHEN clause. OK,
1:         // since the generated column is in the OLD transition variable.
1:         s.execute("create trigger btr7 no cascade before delete on t1 "
1:                 + "referencing old as old for each row when (old.x < old.z) "
1:                 + "call int_proc(7)");
1: 
1:         // References to generated columns in AFTER triggers should always
1:         // be allowed.
1:         s.execute("create trigger atr1 after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x < new.z) insert into t2 values 1");
1:         s.execute("create trigger atr2 after update on t1 "
1:                 + "referencing new as new old as old for each row "
1:                 + "when (old.z < new.z) insert into t2 values 2");
1:         s.execute("create trigger atr3 after delete on t1 "
1:                 + "referencing old as old for each row "
1:                 + "when (old.x < old.z) insert into t2 values 3");
1: 
1:         // Finally, fire the triggers.
1:         s.execute("insert into t1(x, y) values (1, 2), (4, 3)");
1:         s.execute("update t1 set x = y");
1:         s.execute("delete from t1");
1: 
1:         // Verify that the before triggers were executed as expected.
1:         assertEquals(Arrays.asList(1, 3, 4, 4, 6, 7, 7), procedureCalls);
1: 
1:         // Verify that the after triggers were executed as expected.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from t2 order by x"),
1:                 new String[][]{{"1"}, {"1"}, {"2"}, {"3"}, {"3"}});
1:     }
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:         s.execute("create trigger tr01 after insert on t1 for each row "
1:                 + "when (true) insert into t2 values 'Executed tr01'");
1:         s.execute("create trigger tr02 after insert on t1 for each statement "
1:                 + "when (true) insert into t2 values 'Executed tr02'");
1:         s.execute("create trigger tr03 after insert on t1 "
1:                 + "when (true) insert into t2 values 'Executed tr03'");
1:         s.execute("create trigger tr04 after insert on t1 for each row "
1:                 + "when (false) insert into t2 values 'Executed tr04'");
1:         s.execute("create trigger tr05 after insert on t1 for each statement "
1:                 + "when (false) insert into t2 values 'Executed tr05'");
1:         s.execute("create trigger tr06 after insert on t1 "
1:                 + "when (false) insert into t2 values 'Executed tr06'");
1:         s.execute("create trigger tr07 after insert on t1 "
1:                 + "insert into t2 values 'Executed tr07'");
1:         s.execute("create trigger tr08 after insert on t1 "
1:                 + "insert into t2 values 'Executed tr08'");
1:         s.execute("create trigger tr09 after insert on t1 "
1:                 + "insert into t2 values 'Executed tr09'");
1: 
1:         // WHEN clause contains reference to a transition variable.
1:         s.execute("create trigger tr10 after insert on t1 "
1:                 + "referencing new as new for each row "
1:                 + "when (new.x <> 2) insert into t2 values 'Executed tr10'");
1: 
1:         // WHEN clause contains reference to a transition table.
1:         s.execute("create trigger tr11 after insert on t1 "
1:                 + "referencing new table as new "
1:                 + "when (exists (select * from new where x > 5)) "
1:                 + "insert into t2 values 'Executed tr11'");
1:                 { "Executed tr01", "3" },
1:                 { "Executed tr02", "1" },
1:                 { "Executed tr03", "1" },
1:                 { "Executed tr07", "1" },
1:                 { "Executed tr10", "2" },
1:             });
1: 
1:         // Empty t2 before firing the triggers again.
1:         s.execute("delete from t2");
1: 
1:         // Insert more rows with different values and see that a slightly
1:         // different set of triggers get fired.
1:         assertUpdateCount(s, 2, "insert into t1 values 2, 6");
1:         JDBC.assertFullResultSet(
1:             s.executeQuery("select y, count(*) from t2 group by y order by y"),
1:             new String[][] {
1:                 { "Executed tr01", "2" },
1:                 { "Executed tr02", "1" },
1:                 { "Executed tr03", "1" },
1:                 { "Executed tr07", "1" },
1:                 { "Executed tr10", "1" },
1:                 { "Executed tr11", "1" },
commit:75fbb86
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void initializeConnection(Connection conn) throws SQLException {
1:         // Run the test cases with auto-commit off so that all changes to
1:         // the database can be rolled back in tearDown().
1:         conn.setAutoCommit(false);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * A row trigger whose WHEN clause contains a subquery, could cause a
0:      * NullPointerException. This test case is disabled until the bug is fixed.
1:      */
0:     public void xtestSubqueryInWhenClauseNPE() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(x int)");
1:         s.execute("create trigger tr1 after insert on t1 for each row "
1:                 + "when ((values true)) insert into t2 values 1");
1: 
0:         // This statement results in a NullPointerException.
1:         s.execute("insert into t1 values 1,2,3");
1:     }
1: 
commit:1725dd1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.TriggerWhenClauseTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests for the WHEN clause in CREATE TRIGGER statements, added in DERBY-534.
1:  */
1: public class TriggerWhenClauseTest extends BaseJDBCTestCase {
1: 
1:     public TriggerWhenClauseTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         return TestConfiguration.defaultSuite(TriggerWhenClauseTest.class);
1:     }
1: 
1:     public void testBasicSyntax() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t1(x int)");
1:         s.execute("create table t2(y varchar(20))");
1: 
1:         // Create after triggers that should always be executed. Create row
1:         // trigger, statement trigger and implicit statement trigger.
0:         s.execute("create trigger tr1 after insert on t1 for each row "
0:                 + "when (true) insert into t2 values 'Executed tr1'");
0:         s.execute("create trigger tr2 after insert on t1 for each statement "
0:                 + "when (true) insert into t2 values 'Executed tr2'");
0:         s.execute("create trigger tr3 after insert on t1 "
0:                 + "when (true) insert into t2 values 'Executed tr3'");
1: 
1:         // Create corresponding triggers that should never fire (their WHEN
1:         // clause is false).
0:         s.execute("create trigger tr4 after insert on t1 for each row "
0:                 + "when (false) insert into t2 values 'Executed tr4'");
0:         s.execute("create trigger tr5 after insert on t1 for each statement "
0:                 + "when (false) insert into t2 values 'Executed tr5'");
0:         s.execute("create trigger tr6 after insert on t1 "
0:                 + "when (false) insert into t2 values 'Executed tr6'");
1: 
1:         // Create triggers with EXISTS subqueries in the WHEN clause. The
1:         // first returns TRUE and the second returns FALSE.
0:         s.execute("create trigger tr7 after insert on t1 "
1:                 + "when (exists (select * from sysibm.sysdummy1)) "
0:                 + "insert into t2 values 'Executed tr7'");
0:         s.execute("create trigger tr8 after insert on t1 "
1:                 + "when (exists "
1:                 + "(select * from sysibm.sysdummy1 where ibmreqd <> 'Y')) "
0:                 + "insert into t2 values 'Executed tr8'");
1: 
1:         // WHEN clause returns NULL, trigger should not be fired.
0:         s.execute("create trigger tr9 after insert on t1 "
1:                 + "when (cast(null as boolean))"
0:                 + "insert into t2 values 'Executed tr9'");
1: 
1:         // Now fire the triggers and verify the results.
1:         assertUpdateCount(s, 3, "insert into t1 values 1, 2, 3");
1:         JDBC.assertFullResultSet(
1:             s.executeQuery("select y, count(*) from t2 group by y order by y"),
1:             new String[][] {
0:                 { "Executed tr1", "3" },
0:                 { "Executed tr2", "1" },
0:                 { "Executed tr3", "1" },
0:                 { "Executed tr7", "1" },
1:             });
1:     }
1: 
1: }
============================================================================