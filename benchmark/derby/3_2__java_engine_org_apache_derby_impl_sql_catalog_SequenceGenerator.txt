1:139ca85: /*
9:139ca85: 
1:139ca85:    Derby - Class org.apache.derby.impl.sql.catalog.SequenceGenerator
1:139ca85: 
1:139ca85:    Licensed to the Apache Software Foundation (ASF) under one or more
1:139ca85:    contributor license agreements.  See the NOTICE file distributed with
1:139ca85:    this work for additional information regarding copyright ownership.
1:139ca85:    The ASF licenses this file to you under the Apache License, Version 2.0
1:139ca85:    (the "License"); you may not use this file except in compliance with
1:139ca85:    the License.  You may obtain a copy of the License at
1:139ca85: 
1:139ca85:       http://www.apache.org/licenses/LICENSE-2.0
1:139ca85: 
1:139ca85:    Unless required by applicable law or agreed to in writing, software
1:139ca85:    distributed under the License is distributed on an "AS IS" BASIS,
1:139ca85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:139ca85:    See the License for the specific language governing permissions and
1:139ca85:    limitations under the License.
1:139ca85: 
2:139ca85:  */
1:139ca85: package org.apache.derby.impl.sql.catalog;
1:139ca85: 
1:311ee54: import org.apache.derby.catalog.SequencePreallocator;
1:139ca85: import org.apache.derby.iapi.error.StandardException;
1:139ca85: import org.apache.derby.iapi.reference.SQLState;
1:139ca85: 
2:139ca85: /**
1:139ca85:  * <p>
1:139ca85:  * This is a generic machine for pre-allocating ranges of sequence numbers in order
1:139ca85:  * to improve concurrency. The public methods are synchronized and should be brief.
1:139ca85:  * The caller of the methods in this class is responsible for updating values on disk
1:139ca85:  * when the generator is exhausted or when it needs to allocate a new range of values.
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * The most used method in this class is getCurrentValueAndAdvance(). This method
1:139ca85:  * returns the next number in the range managed by the sequence generator. This
1:139ca85:  * method will raise an exception if the sequence generator is exhausted. Otherwise
1:139ca85:  * getCurrentValueAndAdvance() hands back a tuple of return values:
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  * <blockquote>
1:139ca85:  * ( <i>status, currentValue, lastAllocatedValue, numberOfValuesAllocated</i> )
1:139ca85:  * </blockquote>
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * The <i>status</i> field takes the following values:
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  * <ul>
1:139ca85:  * <li><b>RET_I_AM_CONFUSED</b> - This value should never be returned. If this value comes back,
1:139ca85:  * then the sequence generator is confused.</li>
1:139ca85:  * <li><b>RET_OK</b> - This means that the generator has successfully obtained a
1:139ca85:  * next value. That value is <i>currentValue</i>.</li>
1:139ca85:  * <li><b>RET_MARK_EXHAUSTED</b> - This means that the generator has reached the end of its
1:139ca85:  * legal range and is handing back its very last value. The caller must mark the catalogs
1:139ca85:  * to indicate that the range is exhausted. The very last value being handed back
1:139ca85:  * is <i>currentValue</i>.</li>
1:139ca85:  * <li><b>RET_ALLOCATE_NEW_VALUES</b> - This means that the generator has come to the end
1:139ca85:  * of its pre-allocated values. The caller needs to update the catalog to grab a new range of
1:139ca85:  * legal values and then call allocateNewRange() to tell the generator that the range was
1:139ca85:  * successfully allocated. The remaining values in the return tuple have these meanings:
1:139ca85:  *  <ul>
1:139ca85:  *  <li><i>currentValue</i> - This is what is expected to be the current value in the catalog before
1:139ca85:  *   allocating a new range. If, in fact, this is not the value in the catalog, then we are racing with
1:139ca85:  *   another session to drain values from the generator and update the disk. Do not update
1:139ca85:  *   the catalog if the value there is not <i>currentValue</i>. Instead, assume that another session
1:139ca85:  *   got in ahead of us and grabbed a new range of values. Simply call getCurrentValueAndAdvance()
1:139ca85:  *   again.</li>
1:139ca85:  *  <li><i>lastAllocatedValue</i> - This is the next value to write to the catalog.</li>
1:139ca85:  *  <li><i>numberOfValuesAllocated</i> - This is the number of values which were allocated
1:139ca85:  *   if we successfully updated the catalog. If we successfully updated the catalog, then we
1:139ca85:  *   should call allocateNewRange(), handing it this value so that it can reset its range. As a
1:139ca85:  *   sanity check, we also hand allocateNewRange() the <i>currentValue</i> that we were
1:139ca85:  *   given. The allocateNewRange() method will assume we're racing another session and will
1:139ca85:  *   ignore us if its sense of <i>currentValue</i> does not agree with ours.</li>
1:139ca85:  *  </ul>
1:139ca85:  * </li>
1:139ca85:  * </ul>
1:139ca85:  *
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * It may happen that getCurrentValueAndAdvance() tells its caller to allocate a new
1:139ca85:  * range of sequence numbers in the system catalog. If the caller successfully allocates
1:139ca85:  * a new range, the caller should call allocateNewRange() to tell the generator to update
1:139ca85:  * its internal memory of that range.
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * The peekAtCurrentValue() method is provided so that unused, pre-allocated values can
1:139ca85:  * be flushed when the sequence generator is being discarded. The caller updates the
1:8e352d6:  * catalog with the value returned by peekAtCurrentValue(). The peekAtCurrentValue() method
1:8e352d6:  * is also called by the syscs_peek_at_sequence() function which users should call rather
1:8e352d6:  * than try to scan the underlying catalog themselves.
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  */
1:139ca85: public class SequenceGenerator
3:139ca85: {
3:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
3:139ca85:     //
1:139ca85:     // CONSTANTS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /** If pre-allocation drops below this level, then we need to grab another chunk of numbers */
1:139ca85:     private static final int PREALLOCATION_THRESHHOLD = 1;
1:139ca85: 
1:139ca85:     //
1:139ca85:     // Return values from dispatchCommand().
1:139ca85:     //
1:139ca85:     public static final int RET_I_AM_CONFUSED = 0; // should never see this
1:139ca85:     public static final int RET_OK = RET_I_AM_CONFUSED + 1;
1:139ca85:     public static final int RET_MARK_EXHAUSTED = RET_OK + 1;
1:139ca85:     public static final int RET_ALLOCATE_NEW_VALUES = RET_MARK_EXHAUSTED + 1;
1:139ca85: 
1:139ca85:     //
1:139ca85:     // Offsets into array of longs returned by getCurrentValueAndAdvance()
1:139ca85:     //
1:139ca85:     public static final int CVAA_STATUS = 0;
1:139ca85:     public static final int CVAA_CURRENT_VALUE = CVAA_STATUS + 1;
1:139ca85:     public static final int CVAA_LAST_ALLOCATED_VALUE = CVAA_CURRENT_VALUE + 1;
1:139ca85:     public static final int CVAA_NUMBER_OF_VALUES_ALLOCATED = CVAA_LAST_ALLOCATED_VALUE + 1;
1:139ca85:     public static final int CVAA_LENGTH = CVAA_NUMBER_OF_VALUES_ALLOCATED + 1;
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // CONSTANT STATE
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     //
1:139ca85:     // The following state is initialized when this SequenceGenerator is created.
1:139ca85:     //
1:139ca85: 
1:139ca85:     // True if the generator can wrap-around, that is, if the generator was declared to CYCLE.
1:139ca85:     private final boolean _CAN_CYCLE;
1:139ca85: 
1:139ca85:     // True if the increment value is positive.
1:139ca85:     private final boolean _STEP_INCREASES;
1:139ca85: 
1:139ca85:     // This is the step-size for the generator. It is non-zero. It is positive for
1:139ca85:     // generators which increment and it is negative for generators which decrement.
1:139ca85:     private final long _INCREMENT;
1:139ca85: 
1:139ca85:     // This is the highest (most positive) value which the generator is willing to hand out.
1:139ca85:     private final long _MAX_VALUE;
1:139ca85: 
1:139ca85:     // This is lowest (most negative) value which the generator is willing to hand out.
1:139ca85:     private final long _MIN_VALUE;
1:139ca85: 
1:139ca85:     // This is where we restart the sequence if we wrap around.
1:139ca85:     private final long _RESTART_VALUE;
1:139ca85: 
1:311ee54:     // Name of the schema that the sequence lives in.
1:311ee54:     private final String _SCHEMA_NAME;
1:311ee54: 
1:311ee54:     // Name of the sequence.
1:139ca85:     private final String _SEQUENCE_NAME;
1:139ca85: 
1:311ee54:     // Logic to determine how many values to pre-allocate
1:311ee54:     private final   SequencePreallocator    _PREALLOCATOR;
1:311ee54: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // VARIABLES
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     // True if the generator can not produce any more values.
1:139ca85:     private boolean _isExhausted;
1:139ca85: 
1:139ca85:     // This is the next value which the generator will hand out.
1:139ca85:     private long _currentValue;
1:139ca85: 
1:139ca85:     // This is the remaining number of values which were pre-allocated on disk
1:139ca85:     // by bumping the contents of SYSSEQUENCES.CURRENTVALUE.
1:139ca85:     private long _remainingPreallocatedValues;
1:139ca85: 
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // CONSTRUCTOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /** Normal constructor */
1:139ca85:     public SequenceGenerator
1:139ca85:         (
1:139ca85:          Long currentValue,
1:139ca85:          boolean canCycle,
1:139ca85:          long increment,
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long restartValue,
1:311ee54:          String schemaName,
1:311ee54:          String sequenceName,
1:311ee54:          SequencePreallocator   sequencePreallocator
1:139ca85:          )
1:139ca85:     {
1:139ca85:         if ( currentValue == null )
1:139ca85:         {
1:139ca85:             _isExhausted = true;
1:139ca85:             _currentValue = 0;
3:139ca85:         }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             _isExhausted = false;
1:139ca85:             _currentValue = currentValue.longValue();
1:139ca85:         }
1:139ca85: 
1:139ca85:         _CAN_CYCLE = canCycle;
1:139ca85:         _INCREMENT = increment;
1:139ca85:         _MAX_VALUE = maxValue;
1:139ca85:         _MIN_VALUE = minValue;
1:139ca85:         _RESTART_VALUE = restartValue;
1:139ca85:         _STEP_INCREASES = ( _INCREMENT > 0 );
1:311ee54:         _SCHEMA_NAME = schemaName;
1:139ca85:         _SEQUENCE_NAME = sequenceName;
1:311ee54:         _PREALLOCATOR = sequencePreallocator;
1:139ca85: 
1:139ca85:         //
1:139ca85:         // Next call to getCurrentValueAndAdvance() will cause  us to ask our caller to allocate a new range of values.
1:139ca85:         //
1:139ca85:         _remainingPreallocatedValues = 1L;
1:139ca85:     }
1:a180287: 
1:a180287:     /**
1:a180287:      * <p>
1:a180287:      * Clone this sequence generator. This method supports the special bulk-insert optimization in
1:a180287:      * InsertResultSet.
1:a180287:      * </p>
1:a180287:      *
1:a180287:      * @param restart   True if the clone should be reset to start at the beginning instead of at the current value.
1:a180287:      */
1:a180287:     public synchronized SequenceGenerator clone( boolean restart )
1:a180287:     {
1:a180287:         Long    startValue;
1:a180287: 
1:ce40a31:         if ( restart ) { startValue = _RESTART_VALUE; }
1:a180287:         else if ( _isExhausted ) { startValue = null; }
1:ce40a31:         else { startValue = _currentValue; }
1:a180287: 
1:a180287:         return new SequenceGenerator
1:a180287:             (
1:a180287:              startValue,
1:a180287:              _CAN_CYCLE,
1:a180287:              _INCREMENT,
1:a180287:              _MAX_VALUE,
1:a180287:              _MIN_VALUE,
1:a180287:              _RESTART_VALUE,
1:a180287:              _SCHEMA_NAME,
1:a180287:              _SEQUENCE_NAME,
1:a180287:              _PREALLOCATOR
1:a180287:              );
1:a180287:     }
1:a180287:     
1:a180287:     /**
1:a180287:      * <p>
1:a180287:      * Clone this sequence generator. This method supports the special bulk-insert optimization in
1:a180287:      * InsertResultSet.
1:a180287:      * </p>
1:a180287:      *
1:a180287:      * @param newStartValue New value to start with.
1:a180287:      */
1:a180287:     public synchronized SequenceGenerator clone( Long newStartValue )
1:a180287:     {
1:a180287:         return new SequenceGenerator
1:a180287:             (
1:a180287:              newStartValue,
1:a180287:              _CAN_CYCLE,
1:a180287:              _INCREMENT,
1:a180287:              _MAX_VALUE,
1:a180287:              _MIN_VALUE,
1:a180287:              _RESTART_VALUE,
1:a180287:              _SCHEMA_NAME,
1:a180287:              _SEQUENCE_NAME,
1:a180287:              _PREALLOCATOR
1:a180287:              );
1:a180287:     }
1:139ca85:     
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // PUBLIC BEHAVIOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:311ee54:      * Get the name of the schema of this sequence generator. Technically, this doesn't need to be
1:311ee54:      * synchronized. But it is simpler to just maintain a rule that all public methods
1:311ee54:      * should be synchronized.
1:311ee54:      * </p>
1:311ee54:      */
1:311ee54:     public synchronized String getSchemaName() { return _SCHEMA_NAME; }
1:311ee54:     
1:311ee54:     /**
1:311ee54:      * <p>
1:139ca85:      * Get the name of this sequence generator. Technically, this doesn't need to be
1:139ca85:      * synchronized. But it is simpler to just maintain a rule that all public methods
1:139ca85:      * should be synchronized.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public synchronized String getName() { return _SEQUENCE_NAME; }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Allocate a new range. Is a NOP if the current value is not what we expected. See the
1:139ca85:      * class header comment for more information on how this method is used.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public synchronized void allocateNewRange( long expectedCurrentValue, long numberOfAllocatedValues )
1:139ca85:     {
1:139ca85:         if ( _currentValue == expectedCurrentValue )
1:139ca85:         {
1:139ca85:             _remainingPreallocatedValues = numberOfAllocatedValues;
1:139ca85:         }
1:139ca85:     }
1:139ca85:      
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Peek at the current value of the sequence generator without advancing the
1:139ca85:      * generator. Returns null if the generator is exhausted.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public synchronized Long peekAtCurrentValue()
1:139ca85:     {
1:139ca85:         Long currentValue = null;
1:139ca85: 
1:ce40a31:         if ( !_isExhausted ) { currentValue = _currentValue; }
1:139ca85:         
1:139ca85:         return currentValue;
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Get the next sequence number managed by this generator and advance the number. Could raise an
1:139ca85:      * exception if the legal range is exhausted and wrap-around is not allowed--that is,
1:139ca85:      * if NO CYCLE was specified when the sequence was defined. See the class header comment
1:139ca85:      * for a description of how this method operates.
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      * @return Returns an array of longs indexed by the CVAA_* constants.
1:139ca85:      */
1:139ca85:     public synchronized long[] getCurrentValueAndAdvance()
1:139ca85:         throws StandardException
1:139ca85:     {
1:139ca85:         if ( _isExhausted )
1:139ca85:         {
1:139ca85:             throw StandardException.newException
1:311ee54:                 ( SQLState.LANG_SEQUENCE_GENERATOR_EXHAUSTED, _SCHEMA_NAME, _SEQUENCE_NAME );
1:139ca85:         }
1:139ca85: 
1:139ca85:         long retval[] = new long[ CVAA_LENGTH ];
1:139ca85:         retval[ CVAA_STATUS ] = RET_I_AM_CONFUSED;
1:139ca85:         retval[ CVAA_CURRENT_VALUE ] = _currentValue;
1:139ca85: 
1:139ca85:         advanceValue( retval );
1:139ca85:         
1:139ca85:         return retval;
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // PRIVATE BEHAVIOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Advance the sequence generator. Pre-allocate a range of new values if
1:139ca85:      * necessary.
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      * @param retval Array of return values to fill in: see CVAA_* constants
1:139ca85:      */
1:139ca85:     private void advanceValue( long[] retval ) throws StandardException
1:139ca85:     {
1:139ca85:         long nextValue = _currentValue + _INCREMENT;
1:139ca85: 
1:139ca85:         if ( overflowed( _currentValue, nextValue ) )
1:139ca85:         {
1:139ca85:             // Take this generator offline if we've wrapped around but cycling really isn't allowed.
1:139ca85:             if ( !_CAN_CYCLE )
1:139ca85:             {
1:139ca85:                 markExhausted( retval );
1:139ca85:                 return;
1:139ca85:             }
1:139ca85: 
1:139ca85:             // Otherwise, cycling is allowed.
1:d055adb: 	    if(_INCREMENT>0)
1:d055adb: 	        nextValue = _MIN_VALUE;
1:d055adb: 	    
1:d055adb: 	    else 
1:d055adb: 	        nextValue = _MAX_VALUE;
1:139ca85:         }
1:139ca85: 
1:139ca85:         _remainingPreallocatedValues--;
1:139ca85:         if ( _remainingPreallocatedValues < PREALLOCATION_THRESHHOLD )
1:139ca85:         {
1:139ca85:             computeNewAllocation( _currentValue, retval );
1:139ca85:             return;
1:139ca85:         }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             _currentValue = nextValue;
1:139ca85:             retval[ CVAA_STATUS ] = RET_OK;
1:139ca85:             return;
1:139ca85:         }
1:139ca85:     }
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Mark the generator as exhausted.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     private void markExhausted( long[] retval )
1:139ca85:     {
1:139ca85:         _isExhausted = true;
1:139ca85:         retval[ CVAA_STATUS ] = RET_MARK_EXHAUSTED;
1:139ca85: 
1:139ca85:         return;
1:139ca85:     }
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Return true if an overflow/underflow occurred. This happens if
1:139ca85:      * the originalValue and incrementedValue have opposite sign. Overflow
1:139ca85:      * also occurs if the incrementedValue falls outside the range of the
1:139ca85:      * sequence.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     private boolean overflowed( long originalValue, long incrementedValue )
1:139ca85:     {
1:139ca85:         boolean overflowed = ( _STEP_INCREASES == ( incrementedValue < originalValue ) );
1:139ca85:         
1:139ca85:         if ( !overflowed )
1:139ca85:         {
1:139ca85:             if ( _STEP_INCREASES ) { overflowed = ( incrementedValue > _MAX_VALUE ); }
1:139ca85:             else { overflowed = ( incrementedValue < _MIN_VALUE ); }
1:139ca85:         }
1:139ca85: 
1:139ca85:         return overflowed;
1:139ca85:     }
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Compute the number of values to allocate. The range may wrap around.
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      * @param oldCurrentValue INPUT Used to compute how many values need to be allocated
1:139ca85:      * @param retval OUTPUT Array of values to fill in (see CVAA_* constants)
1:139ca85:      *
1:139ca85:      * @throws StandardException if any error occurs.
1:139ca85:      */
1:139ca85:     private void computeNewAllocation( long oldCurrentValue, long[] retval ) throws StandardException
1:139ca85:     {
1:311ee54:         int preferredValuesPerAllocation = computePreAllocationCount();
1:311ee54:         
1:139ca85:         //
1:139ca85:         // The values are growing toward one of the endpoints of the legal range,
1:139ca85:         // either the largest legal value or the smallest legal value. First find out
1:139ca85:         // how many values are left between the current value and the endpoint
1:139ca85:         // we are growing toward.
1:139ca85:         //
1:139ca85:         long remainingLegalValues = computeRemainingValues( oldCurrentValue );
1:139ca85: 
1:139ca85:         long newValueOnDisk;
1:139ca85:         long valuesToAllocate;
1:139ca85: 
1:311ee54:         if ( remainingLegalValues >= preferredValuesPerAllocation )
1:139ca85:         {
1:311ee54:             newValueOnDisk = oldCurrentValue + ( preferredValuesPerAllocation * _INCREMENT );
1:311ee54:             valuesToAllocate = preferredValuesPerAllocation;
1:139ca85:         }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             // We wrapped around.
1:139ca85: 
1:139ca85:             if ( _CAN_CYCLE )
1:139ca85:             {
1:311ee54:                 long spillOverValues = preferredValuesPerAllocation - remainingLegalValues;
1:139ca85: 
1:139ca85:                 // account for the fact that the restart value itself is a legal value
1:139ca85:                 spillOverValues--;
1:139ca85: 
1:139ca85:                 newValueOnDisk = _RESTART_VALUE + ( spillOverValues * _INCREMENT );
1:311ee54:                 valuesToAllocate = preferredValuesPerAllocation;
1:139ca85:             }
1:139ca85:             else
1:139ca85:             {
1:139ca85:                 // wrap around not allowed
1:139ca85:                 
1:139ca85:                 if ( remainingLegalValues <= 0 )
1:139ca85:                 {
1:139ca85:                     markExhausted( retval );
1:139ca85:                     return;
1:139ca85:                 }
1:139ca85:                 else
1:139ca85:                 {
1:139ca85:                     valuesToAllocate = remainingLegalValues;
1:139ca85:                     newValueOnDisk = oldCurrentValue + ( valuesToAllocate * _INCREMENT );
1:139ca85:                 }
1:139ca85:             }
1:139ca85:         }
1:139ca85: 
1:139ca85:         //account for the fact that the current value is already allocated
1:139ca85:         retval[ CVAA_NUMBER_OF_VALUES_ALLOCATED ] = valuesToAllocate + 1;
1:139ca85:         retval[ CVAA_LAST_ALLOCATED_VALUE ] = newValueOnDisk ;
1:139ca85:         retval[ CVAA_STATUS ] = RET_ALLOCATE_NEW_VALUES;
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Get the number of values remaining until we bump against an endpoint of the legal range of values.
1:139ca85:      * This is a positive number and so may understate the number of remaining values if the datatype is BIGINT.
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      */
1:139ca85:     private long computeRemainingValues( long oldCurrentValue )
1:139ca85:     {
1:139ca85:         long spaceLeft = _STEP_INCREASES ? _MAX_VALUE - oldCurrentValue : -( _MIN_VALUE - oldCurrentValue );
1:139ca85: 
1:139ca85:         // if overflow occurred, the range is very large
1:139ca85:         if ( spaceLeft < 0L ) { spaceLeft = Long.MAX_VALUE; }
1:139ca85: 
1:139ca85:         long divisor = _STEP_INCREASES ? _INCREMENT : -_INCREMENT;
1:139ca85: 
1:139ca85:         return spaceLeft / divisor;
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // SETUP/TEARDOWN MINIONS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * This method returns the number of values to pre-allocate when we
1:139ca85:      * grab a new chunk of values. This is a bit of defensive coding to cover
1:139ca85:      * the case when the sequence's parameters are absurdly large.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     private int computePreAllocationCount()
1:139ca85:     {
1:311ee54:         int happyResult = _PREALLOCATOR.nextRangeSize(  _SCHEMA_NAME, _SEQUENCE_NAME );
1:139ca85:         int unhappyResult = PREALLOCATION_THRESHHOLD;
1:139ca85: 
1:311ee54:         if ( happyResult < unhappyResult ) { return unhappyResult; }
1:311ee54: 
1:139ca85:         double min = _MIN_VALUE;
1:139ca85:         double max = _MAX_VALUE;
1:139ca85:         double range = max - min;
1:139ca85:         double step = _INCREMENT;
1:139ca85:         if ( step < 0.0 ) { step = -step; }
1:139ca85: 
1:139ca85:         double chunkSize = step * happyResult;
1:139ca85: 
1:139ca85:         if ( chunkSize > Long.MAX_VALUE ) { return unhappyResult; }
1:139ca85:         if ( chunkSize > range ) { return unhappyResult; }
1:139ca85: 
1:139ca85:         return happyResult;
1:139ca85:     }
1:139ca85: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1: 	    if(_INCREMENT>0)
1: 	        nextValue = _MIN_VALUE;
1: 	    
1: 	    else 
1: 	        nextValue = _MAX_VALUE;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:         if ( restart ) { startValue = _RESTART_VALUE; }
1:         else { startValue = _currentValue; }
/////////////////////////////////////////////////////////////////////////
1:         if ( !_isExhausted ) { currentValue = _currentValue; }
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Clone this sequence generator. This method supports the special bulk-insert optimization in
1:      * InsertResultSet.
1:      * </p>
1:      *
1:      * @param restart   True if the clone should be reset to start at the beginning instead of at the current value.
1:      */
1:     public synchronized SequenceGenerator clone( boolean restart )
1:     {
1:         Long    startValue;
1: 
0:         if ( restart ) { startValue = new Long( _RESTART_VALUE ); }
1:         else if ( _isExhausted ) { startValue = null; }
0:         else { startValue = new Long( _currentValue ); }
1: 
1:         return new SequenceGenerator
1:             (
1:              startValue,
1:              _CAN_CYCLE,
1:              _INCREMENT,
1:              _MAX_VALUE,
1:              _MIN_VALUE,
1:              _RESTART_VALUE,
1:              _SCHEMA_NAME,
1:              _SEQUENCE_NAME,
1:              _PREALLOCATOR
1:              );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Clone this sequence generator. This method supports the special bulk-insert optimization in
1:      * InsertResultSet.
1:      * </p>
1:      *
1:      * @param newStartValue New value to start with.
1:      */
1:     public synchronized SequenceGenerator clone( Long newStartValue )
1:     {
1:         return new SequenceGenerator
1:             (
1:              newStartValue,
1:              _CAN_CYCLE,
1:              _INCREMENT,
1:              _MAX_VALUE,
1:              _MIN_VALUE,
1:              _RESTART_VALUE,
1:              _SCHEMA_NAME,
1:              _SEQUENCE_NAME,
1:              _PREALLOCATOR
1:              );
1:     }
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:  * catalog with the value returned by peekAtCurrentValue(). The peekAtCurrentValue() method
1:  * is also called by the syscs_peek_at_sequence() function which users should call rather
1:  * than try to scan the underlying catalog themselves.
commit:311ee54
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.SequencePreallocator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Name of the schema that the sequence lives in.
1:     private final String _SCHEMA_NAME;
1: 
1:     // Name of the sequence.
1:     // Logic to determine how many values to pre-allocate
1:     private final   SequencePreallocator    _PREALLOCATOR;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          String schemaName,
1:          String sequenceName,
1:          SequencePreallocator   sequencePreallocator
/////////////////////////////////////////////////////////////////////////
1:         _SCHEMA_NAME = schemaName;
1:         _PREALLOCATOR = sequencePreallocator;
/////////////////////////////////////////////////////////////////////////
1:      * Get the name of the schema of this sequence generator. Technically, this doesn't need to be
1:      * synchronized. But it is simpler to just maintain a rule that all public methods
1:      * should be synchronized.
1:      * </p>
1:      */
1:     public synchronized String getSchemaName() { return _SCHEMA_NAME; }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:                 ( SQLState.LANG_SEQUENCE_GENERATOR_EXHAUSTED, _SCHEMA_NAME, _SEQUENCE_NAME );
/////////////////////////////////////////////////////////////////////////
1:         int preferredValuesPerAllocation = computePreAllocationCount();
1:         
/////////////////////////////////////////////////////////////////////////
1:         if ( remainingLegalValues >= preferredValuesPerAllocation )
1:             newValueOnDisk = oldCurrentValue + ( preferredValuesPerAllocation * _INCREMENT );
1:             valuesToAllocate = preferredValuesPerAllocation;
/////////////////////////////////////////////////////////////////////////
1:                 long spillOverValues = preferredValuesPerAllocation - remainingLegalValues;
1:                 valuesToAllocate = preferredValuesPerAllocation;
/////////////////////////////////////////////////////////////////////////
1:         int happyResult = _PREALLOCATOR.nextRangeSize(  _SCHEMA_NAME, _SEQUENCE_NAME );
1:         if ( happyResult < unhappyResult ) { return unhappyResult; }
1: 
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.catalog.SequenceGenerator
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derby.impl.sql.catalog;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.cache.Cacheable;
0: import org.apache.derby.iapi.services.cache.CacheManager;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: /**
1:  * <p>
1:  * This is a generic machine for pre-allocating ranges of sequence numbers in order
1:  * to improve concurrency. The public methods are synchronized and should be brief.
1:  * The caller of the methods in this class is responsible for updating values on disk
1:  * when the generator is exhausted or when it needs to allocate a new range of values.
1:  * </p>
1:  *
1:  * <p>
1:  * The most used method in this class is getCurrentValueAndAdvance(). This method
1:  * returns the next number in the range managed by the sequence generator. This
1:  * method will raise an exception if the sequence generator is exhausted. Otherwise
1:  * getCurrentValueAndAdvance() hands back a tuple of return values:
1:  * </p>
1:  *
1:  * <blockquote>
1:  * ( <i>status, currentValue, lastAllocatedValue, numberOfValuesAllocated</i> )
1:  * </blockquote>
1:  *
1:  * <p>
1:  * The <i>status</i> field takes the following values:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li><b>RET_I_AM_CONFUSED</b> - This value should never be returned. If this value comes back,
1:  * then the sequence generator is confused.</li>
1:  * <li><b>RET_OK</b> - This means that the generator has successfully obtained a
1:  * next value. That value is <i>currentValue</i>.</li>
1:  * <li><b>RET_MARK_EXHAUSTED</b> - This means that the generator has reached the end of its
1:  * legal range and is handing back its very last value. The caller must mark the catalogs
1:  * to indicate that the range is exhausted. The very last value being handed back
1:  * is <i>currentValue</i>.</li>
1:  * <li><b>RET_ALLOCATE_NEW_VALUES</b> - This means that the generator has come to the end
1:  * of its pre-allocated values. The caller needs to update the catalog to grab a new range of
1:  * legal values and then call allocateNewRange() to tell the generator that the range was
1:  * successfully allocated. The remaining values in the return tuple have these meanings:
1:  *  <ul>
1:  *  <li><i>currentValue</i> - This is what is expected to be the current value in the catalog before
1:  *   allocating a new range. If, in fact, this is not the value in the catalog, then we are racing with
1:  *   another session to drain values from the generator and update the disk. Do not update
1:  *   the catalog if the value there is not <i>currentValue</i>. Instead, assume that another session
1:  *   got in ahead of us and grabbed a new range of values. Simply call getCurrentValueAndAdvance()
1:  *   again.</li>
1:  *  <li><i>lastAllocatedValue</i> - This is the next value to write to the catalog.</li>
1:  *  <li><i>numberOfValuesAllocated</i> - This is the number of values which were allocated
1:  *   if we successfully updated the catalog. If we successfully updated the catalog, then we
1:  *   should call allocateNewRange(), handing it this value so that it can reset its range. As a
1:  *   sanity check, we also hand allocateNewRange() the <i>currentValue</i> that we were
1:  *   given. The allocateNewRange() method will assume we're racing another session and will
1:  *   ignore us if its sense of <i>currentValue</i> does not agree with ours.</li>
1:  *  </ul>
1:  * </li>
1:  * </ul>
1:  *
1:  *
1:  * <p>
1:  * It may happen that getCurrentValueAndAdvance() tells its caller to allocate a new
1:  * range of sequence numbers in the system catalog. If the caller successfully allocates
1:  * a new range, the caller should call allocateNewRange() to tell the generator to update
1:  * its internal memory of that range.
1:  * </p>
1:  *
1:  *
1:  * <p>
1:  * The peekAtCurrentValue() method is provided so that unused, pre-allocated values can
1:  * be flushed when the sequence generator is being discarded. The caller updates the
0:  * catalog with the value returned by peekAtCurrentValue().
1:  * </p>
1:  *
1:  */
1: public class SequenceGenerator
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Default number of values to pre-allocate. In the future, we may want to provide
0:      * something more sophisticated. For instance, we might want to make Derby tune
0:      * this number per sequence generator or give the user the power to override Derby's
0:      * decision.
1:      */
0:     public static final int DEFAULT_PREALLOCATION_COUNT = 5;
1: 
1:     /** If pre-allocation drops below this level, then we need to grab another chunk of numbers */
1:     private static final int PREALLOCATION_THRESHHOLD = 1;
1: 
1:     //
1:     // Return values from dispatchCommand().
1:     //
1:     public static final int RET_I_AM_CONFUSED = 0; // should never see this
1:     public static final int RET_OK = RET_I_AM_CONFUSED + 1;
1:     public static final int RET_MARK_EXHAUSTED = RET_OK + 1;
1:     public static final int RET_ALLOCATE_NEW_VALUES = RET_MARK_EXHAUSTED + 1;
1: 
1:     //
1:     // Offsets into array of longs returned by getCurrentValueAndAdvance()
1:     //
1:     public static final int CVAA_STATUS = 0;
1:     public static final int CVAA_CURRENT_VALUE = CVAA_STATUS + 1;
1:     public static final int CVAA_LAST_ALLOCATED_VALUE = CVAA_CURRENT_VALUE + 1;
1:     public static final int CVAA_NUMBER_OF_VALUES_ALLOCATED = CVAA_LAST_ALLOCATED_VALUE + 1;
1:     public static final int CVAA_LENGTH = CVAA_NUMBER_OF_VALUES_ALLOCATED + 1;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANT STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     //
1:     // The following state is initialized when this SequenceGenerator is created.
1:     //
1: 
1:     // True if the generator can wrap-around, that is, if the generator was declared to CYCLE.
1:     private final boolean _CAN_CYCLE;
1: 
1:     // True if the increment value is positive.
1:     private final boolean _STEP_INCREASES;
1: 
1:     // This is the step-size for the generator. It is non-zero. It is positive for
1:     // generators which increment and it is negative for generators which decrement.
1:     private final long _INCREMENT;
1: 
1:     // This is the highest (most positive) value which the generator is willing to hand out.
1:     private final long _MAX_VALUE;
1: 
1:     // This is lowest (most negative) value which the generator is willing to hand out.
1:     private final long _MIN_VALUE;
1: 
1:     // This is where we restart the sequence if we wrap around.
1:     private final long _RESTART_VALUE;
1: 
0:     // Name of the sequence (for error messages).
1:     private final String _SEQUENCE_NAME;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // VARIABLES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     // True if the generator can not produce any more values.
1:     private boolean _isExhausted;
1: 
1:     // This is the next value which the generator will hand out.
1:     private long _currentValue;
1: 
0:     // This is the number of values to pre-allocate per chunk. Right now this
0:     // is a constant which we figure out when we initialize the generator.
0:     // However, this number could change over time if, for instance, Derby
0:     // tunes it on the fly.
0:     private long _valuesPerAllocation;
1:     
1:     // This is the remaining number of values which were pre-allocated on disk
1:     // by bumping the contents of SYSSEQUENCES.CURRENTVALUE.
1:     private long _remainingPreallocatedValues;
1: 
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Normal constructor */
1:     public SequenceGenerator
1:         (
1:          Long currentValue,
1:          boolean canCycle,
1:          long increment,
1:          long maxValue,
1:          long minValue,
1:          long restartValue,
0:          String sequenceName
1:          )
1:     {
1:         if ( currentValue == null )
1:         {
1:             _isExhausted = true;
1:             _currentValue = 0;
1:         }
1:         else
1:         {
1:             _isExhausted = false;
1:             _currentValue = currentValue.longValue();
1:         }
1: 
1:         _CAN_CYCLE = canCycle;
1:         _INCREMENT = increment;
1:         _MAX_VALUE = maxValue;
1:         _MIN_VALUE = minValue;
1:         _RESTART_VALUE = restartValue;
1:         _STEP_INCREASES = ( _INCREMENT > 0 );
1:         _SEQUENCE_NAME = sequenceName;
1: 
1:         //
1:         // Next call to getCurrentValueAndAdvance() will cause  us to ask our caller to allocate a new range of values.
1:         //
1:         _remainingPreallocatedValues = 1L;
1: 
0:         _valuesPerAllocation = computePreAllocationCount();
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // PUBLIC BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get the name of this sequence generator. Technically, this doesn't need to be
1:      * synchronized. But it is simpler to just maintain a rule that all public methods
1:      * should be synchronized.
1:      * </p>
1:      */
1:     public synchronized String getName() { return _SEQUENCE_NAME; }
1:     
1:     /**
1:      * <p>
1:      * Allocate a new range. Is a NOP if the current value is not what we expected. See the
1:      * class header comment for more information on how this method is used.
1:      * </p>
1:      */
1:     public synchronized void allocateNewRange( long expectedCurrentValue, long numberOfAllocatedValues )
1:     {
1:         if ( _currentValue == expectedCurrentValue )
1:         {
1:             _remainingPreallocatedValues = numberOfAllocatedValues;
1:         }
1:     }
1:      
1:     /**
1:      * <p>
1:      * Peek at the current value of the sequence generator without advancing the
1:      * generator. Returns null if the generator is exhausted.
1:      * </p>
1:      */
1:     public synchronized Long peekAtCurrentValue()
1:     {
1:         Long currentValue = null;
1: 
0:         if ( !_isExhausted ) { currentValue = new Long( _currentValue ); }
1:         
1:         return currentValue;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the next sequence number managed by this generator and advance the number. Could raise an
1:      * exception if the legal range is exhausted and wrap-around is not allowed--that is,
1:      * if NO CYCLE was specified when the sequence was defined. See the class header comment
1:      * for a description of how this method operates.
1:      * </p>
1:      *
1:      * @return Returns an array of longs indexed by the CVAA_* constants.
1:      */
1:     public synchronized long[] getCurrentValueAndAdvance()
1:         throws StandardException
1:     {
1:         if ( _isExhausted )
1:         {
1:             throw StandardException.newException
0:                 ( SQLState.LANG_SEQUENCE_GENERATOR_EXHAUSTED, _SEQUENCE_NAME );
1:         }
1: 
1:         long retval[] = new long[ CVAA_LENGTH ];
1:         retval[ CVAA_STATUS ] = RET_I_AM_CONFUSED;
1:         retval[ CVAA_CURRENT_VALUE ] = _currentValue;
1: 
1:         advanceValue( retval );
1:         
1:         return retval;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // PRIVATE BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * <p>
1:      * Advance the sequence generator. Pre-allocate a range of new values if
1:      * necessary.
1:      * </p>
1:      *
1:      * @param retval Array of return values to fill in: see CVAA_* constants
1:      */
1:     private void advanceValue( long[] retval ) throws StandardException
1:     {
1:         long nextValue = _currentValue + _INCREMENT;
1: 
1:         if ( overflowed( _currentValue, nextValue ) )
1:         {
1:             // Take this generator offline if we've wrapped around but cycling really isn't allowed.
1:             if ( !_CAN_CYCLE )
1:             {
1:                 markExhausted( retval );
1:                 return;
1:             }
1: 
1:             // Otherwise, cycling is allowed.
0:             nextValue = _RESTART_VALUE;
1:         }
1: 
1:         _remainingPreallocatedValues--;
1:         if ( _remainingPreallocatedValues < PREALLOCATION_THRESHHOLD )
1:         {
1:             computeNewAllocation( _currentValue, retval );
1:             return;
1:         }
1:         else
1:         {
1:             _currentValue = nextValue;
1:             retval[ CVAA_STATUS ] = RET_OK;
1:             return;
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Mark the generator as exhausted.
1:      * </p>
1:      */
1:     private void markExhausted( long[] retval )
1:     {
1:         _isExhausted = true;
1:         retval[ CVAA_STATUS ] = RET_MARK_EXHAUSTED;
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if an overflow/underflow occurred. This happens if
1:      * the originalValue and incrementedValue have opposite sign. Overflow
1:      * also occurs if the incrementedValue falls outside the range of the
1:      * sequence.
1:      * </p>
1:      */
1:     private boolean overflowed( long originalValue, long incrementedValue )
1:     {
1:         boolean overflowed = ( _STEP_INCREASES == ( incrementedValue < originalValue ) );
1:         
1:         if ( !overflowed )
1:         {
1:             if ( _STEP_INCREASES ) { overflowed = ( incrementedValue > _MAX_VALUE ); }
1:             else { overflowed = ( incrementedValue < _MIN_VALUE ); }
1:         }
1: 
1:         return overflowed;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Compute the number of values to allocate. The range may wrap around.
1:      * </p>
1:      *
1:      * @param oldCurrentValue INPUT Used to compute how many values need to be allocated
1:      * @param retval OUTPUT Array of values to fill in (see CVAA_* constants)
1:      *
1:      * @throws StandardException if any error occurs.
1:      */
1:     private void computeNewAllocation( long oldCurrentValue, long[] retval ) throws StandardException
1:     {
1:         //
1:         // The values are growing toward one of the endpoints of the legal range,
1:         // either the largest legal value or the smallest legal value. First find out
1:         // how many values are left between the current value and the endpoint
1:         // we are growing toward.
1:         //
1:         long remainingLegalValues = computeRemainingValues( oldCurrentValue );
1: 
1:         long newValueOnDisk;
1:         long valuesToAllocate;
1: 
0:         if ( remainingLegalValues >= _valuesPerAllocation )
1:         {
0:             newValueOnDisk = oldCurrentValue + ( _valuesPerAllocation * _INCREMENT );
0:             valuesToAllocate = _valuesPerAllocation;
1:         }
1:         else
1:         {
1:             // We wrapped around.
1: 
1:             if ( _CAN_CYCLE )
1:             {
0:                 long spillOverValues = _valuesPerAllocation - remainingLegalValues;
1: 
1:                 // account for the fact that the restart value itself is a legal value
1:                 spillOverValues--;
1: 
1:                 newValueOnDisk = _RESTART_VALUE + ( spillOverValues * _INCREMENT );
0:                 valuesToAllocate = _valuesPerAllocation;
1:             }
1:             else
1:             {
1:                 // wrap around not allowed
1:                 
1:                 if ( remainingLegalValues <= 0 )
1:                 {
1:                     markExhausted( retval );
1:                     return;
1:                 }
1:                 else
1:                 {
1:                     valuesToAllocate = remainingLegalValues;
1:                     newValueOnDisk = oldCurrentValue + ( valuesToAllocate * _INCREMENT );
1:                 }
1:             }
1:         }
1: 
1:         //account for the fact that the current value is already allocated
1:         retval[ CVAA_NUMBER_OF_VALUES_ALLOCATED ] = valuesToAllocate + 1;
1:         retval[ CVAA_LAST_ALLOCATED_VALUE ] = newValueOnDisk ;
1:         retval[ CVAA_STATUS ] = RET_ALLOCATE_NEW_VALUES;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the number of values remaining until we bump against an endpoint of the legal range of values.
1:      * This is a positive number and so may understate the number of remaining values if the datatype is BIGINT.
1:      * </p>
1:      *
1:      */
1:     private long computeRemainingValues( long oldCurrentValue )
1:     {
1:         long spaceLeft = _STEP_INCREASES ? _MAX_VALUE - oldCurrentValue : -( _MIN_VALUE - oldCurrentValue );
1: 
1:         // if overflow occurred, the range is very large
1:         if ( spaceLeft < 0L ) { spaceLeft = Long.MAX_VALUE; }
1: 
1:         long divisor = _STEP_INCREASES ? _INCREMENT : -_INCREMENT;
1: 
1:         return spaceLeft / divisor;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // SETUP/TEARDOWN MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * This method returns the number of values to pre-allocate when we
1:      * grab a new chunk of values. This is a bit of defensive coding to cover
1:      * the case when the sequence's parameters are absurdly large.
1:      * </p>
1:      */
1:     private int computePreAllocationCount()
1:     {
0:         int happyResult = DEFAULT_PREALLOCATION_COUNT;
1:         int unhappyResult = PREALLOCATION_THRESHHOLD;
1: 
1:         double min = _MIN_VALUE;
1:         double max = _MAX_VALUE;
1:         double range = max - min;
1:         double step = _INCREMENT;
1:         if ( step < 0.0 ) { step = -step; }
1: 
1:         double chunkSize = step * happyResult;
1: 
1:         if ( chunkSize > Long.MAX_VALUE ) { return unhappyResult; }
1:         if ( chunkSize > range ) { return unhappyResult; }
1: 
1:         return happyResult;
1:     }
1: 
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // UTILITY MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0: 	private static LanguageConnectionContext getLCC()
1:     {
0: 		return (LanguageConnectionContext) 
0: 					ContextService.getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
1: 	}
1: 
0:     /** Report an unimplemented feature */
0:     private StandardException unimplementedFeature()
1:     {
0:         return StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:     }
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:afe6225
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================