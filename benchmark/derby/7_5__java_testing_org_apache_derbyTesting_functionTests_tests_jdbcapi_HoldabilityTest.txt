1:c049abf: /*
2:c049abf:  *
1:c049abf:  * Derby - Class HoldabilityTest
1:c049abf:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:c049abf:  *
1:c049abf:  *    http://www.apache.org/licenses/LICENSE-2.0
1:c049abf:  *
1:c049abf:  * Unless required by applicable law or agreed to in writing,
1:c049abf:  * software distributed under the License is distributed on an
1:c049abf:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:c049abf:  * either express or implied. See the License for the specific
1:c049abf:  * language governing permissions and limitations under the License.
2:c049abf:  */
1:c049abf: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:c049abf: import junit.framework.*;
1:c049abf: import java.sql.*;
4:c049abf: 
1:3bd1dd8: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:985662b: import org.apache.derbyTesting.junit.TestConfiguration;
1:ff65830: 
2:c049abf: /**
1:c049abf:  * Tests holdable resultsets.
1:c049abf:  */
1:c049abf: public class HoldabilityTest extends SURBaseTest {
1:c049abf:     
1:c049abf:     /** Creates a new instance of HoldabilityTest */
1:c049abf:     public HoldabilityTest(String name) {
1:c049abf:         super(name, 1000); // We will use 1000 records
5:c049abf:     }
1:d038483:     
1:d038483:     public static Test suite() {
1:d038483:                
1:985662b:         return TestConfiguration.defaultSuite(HoldabilityTest.class);
1:d038483:     }
1:d038483: 
1:c049abf:     /**
1:c049abf:      * Sets up the connection, then create the data model
1:c049abf:      */
1:5b9d0fb:     protected void setUp() 
1:c049abf:         throws Exception 
1:c049abf:     {      
1:ff65830:        // For the holdability tests, we recreate the model
1:c049abf:         // for each testcase (since we do commits)
1:d038483:         
1:c049abf:         // We also use more records to ensure that the disk
1:c049abf:         // is being used.
1:c049abf:         SURDataModelSetup.createDataModel
1:03a99e2:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getConnection(),
1:c049abf:              recordCount);
1:ff65830:         commit();
1:c049abf:     }
1:d038483:     
1:5b9d0fb:     protected void tearDown() throws Exception
1:c049abf:     {
1:5b9d0fb:     	// Commit any changes, they will be dropped
1:5b9d0fb:     	// anyway by the next setUp to run or the
1:5b9d0fb:     	// outer database cleaners. It's faster to
1:5b9d0fb:     	// commit than rollback many changes.
1:5b9d0fb:     	commit();
1:5b9d0fb:     	super.tearDown();
1:c049abf:     }
1:c049abf:     
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it has not done any scanning
1:c049abf:      */
1:c049abf:     public void testHeldForwardOnlyResultSetScanInit() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement();
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         
1:ff65830:         commit(); // scan initialized
1:c049abf:         
1:c049abf:         scrollForward(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:     
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it is in progress of scanning
1:c049abf:      */
1:c049abf:     public void testHeldForwardOnlyResultSetScanInProgress() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement();
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf: 
1:c049abf:         for (int i=0; i<this.recordCount/2; i++) {
1:c049abf:             rs.next();
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:ff65830:         commit(); // Scan is in progress
1:c049abf:         
1:c049abf:         while (rs.next()) {
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it has not done any scanning, and be updatable
1:c049abf:      */
1:c049abf:     public void testHeldForwardOnlyUpdatableResultSetScanInit() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:ff65830:         commit(); // scan initialized
1:c049abf:         rs.next();    // naviagate to a new tuple
1:c049abf:         updateTuple(rs); // Updatable
1:c049abf:         scrollForward(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:     
1:c049abf:     
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it is in progress of scanning, and that after a compress the
1:c049abf:      * resultset is still updatable.
1:c049abf:      */
1:c049abf:     public void testCompressOnHeldForwardOnlyUpdatableResultSetScanInProgress()
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf: 
1:c049abf:         for (int i=0; i<this.recordCount/2; i++) {
1:c049abf:             rs.next();
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:c049abf:         updateTuple(rs);
1:ff65830:         commit(); // Scan is in progress
1:c049abf:         
1:c049abf:         // Verifies resultset can do updates after compress
1:c049abf:         verifyResultSetUpdatableAfterCompress(rs);
1:ff65830:         s.close();
1:c049abf:         
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it has not done any scanning, and that after a compress it is
1:c049abf:      * still updatable.
1:c049abf:      */
1:c049abf:     public void testCompressOnHeldForwardOnlyUpdatableResultSetScanInit() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:ff65830:         commit(); // scan initialized
1:c049abf:         
1:c049abf:         // Verifies resultset can do updates after compress
1:c049abf:         verifyResultSetUpdatableAfterCompress(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:         
1:c049abf:     /**
1:c049abf:      * Test that a forward only resultset can be held over commit while
1:c049abf:      * it is in progress of scanning
1:c049abf:      */
1:c049abf:     public void testHeldForwardOnlyUpdatableResultSetScanInProgress() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf: 
1:c049abf:         for (int i=0; i<this.recordCount/2; i++) {
1:c049abf:             rs.next();
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:c049abf:         updateTuple(rs);
1:ff65830:         commit(); // Scan is in progress
1:c049abf:         rs.next();
1:c049abf:         updateTuple(rs); // Still updatable
1:c049abf:         while (rs.next()) {
1:c049abf:             verifyTuple(rs); // complete the scan
1:c049abf:         }
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:     
1:c049abf:     /**
1:c049abf:      * Test that a scrollable resultset can be held over commit while
1:c049abf:      * it has not done any scanning
1:c049abf:      */
1:c049abf:     public void testHeldScrollableResultSetScanInit() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_READ_ONLY);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         
1:ff65830:         commit(); // scan initialized
1:c049abf:         
1:c049abf:         scrollForward(rs);
1:c049abf:         scrollBackward(rs);
1:ff65830:         
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:         
1:c049abf:     /**
1:c049abf:      * Test that a scrollable resultset can be held over commit while
1:c049abf:      * it is in progress of scanning
1:c049abf:      */
1:c049abf:     public void testHeldScrollableResultSetScanInProgress() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_READ_ONLY);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf: 
1:c049abf:         for (int i=0; i<this.recordCount/2; i++) {
1:c049abf:             rs.next();
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:ff65830:         commit(); // Scan is in progress
1:c049abf:         
1:c049abf:         while (rs.next()) {
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:c049abf:         scrollBackward(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that a scrollable resultset can be held over commit
1:c049abf:      * after the resultset has been populated
1:c049abf:      */
1:c049abf:     public void testHeldScrollableResultSetScanDone() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_READ_ONLY);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         
1:c049abf:         scrollForward(rs); // Scan is done
1:c049abf:         
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         scrollBackward(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that a scrollable updatable resultset can be held over commit 
1:c049abf:      * while it has not done any scanning
1:c049abf:      */
1:c049abf:     public void testHeldScrollableUpdatableResultSetScanInit() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c247315:         }
1:ff65830:         commit(); // scan initialized
1:c049abf:         
1:c049abf:         scrollForward(rs);
1:c049abf:         scrollBackwardAndUpdate(rs);
1:ff65830:         
1:ff65830:         s.close();
1:c049abf:     }    
1:ff65830:     
1:c049abf:     /**
1:c049abf:      * Test that a scrollable updatable resultset can be held over commit while
1:c049abf:      * it is in progress of scanning
1:c049abf:      */
1:c049abf:     public void testHeldScrollableUpdatableResultSetScanInProgress() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c049abf:         }        
1:c049abf:         for (int i=0; i<this.recordCount/2; i++) {
1:c049abf:             rs.next();
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:ff65830:         commit(); // Scan is in progress
1:ff65830:         
1:c049abf:         while (rs.next()) {
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:c049abf:         scrollBackwardAndUpdate(rs);
1:c049abf:         
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that a scrollable updatable resultset can be held over commit
1:c049abf:      * after the resultset has been populated
1:c049abf:      */
1:c049abf:     public void testHeldScrollableUpdatableResultSetScanDone() 
1:c049abf:         throws SQLException
1:c049abf:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c049abf:         }
1:c049abf:       
1:c049abf:         scrollForward(rs); // Scan is done
1:c049abf:         
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         scrollBackwardAndUpdate(rs);
1:c049abf:         
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:f342d5b:      * Test that updateRow() after a commit requires a renavigation 
1:f342d5b:      * on a held forward only ResulTset.
1:f342d5b:      */
1:f342d5b:     public void testUpdateRowAfterCommitOnHeldForwardOnlyResultSet() 
1:f342d5b:         throws SQLException
1:f342d5b:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:f342d5b:                                           ResultSet.CONCUR_UPDATABLE);
1:f342d5b:         ResultSet rs = s.executeQuery(selectStatement);
1:f342d5b:         
1:f342d5b:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:f342d5b:         }
1:f342d5b:         rs.next();
1:ff65830:         commit();
1:f342d5b:         try {
1:f342d5b:             rs.updateInt(2, -100);
1:f342d5b:             rs.updateRow();
1:5b9d0fb:             fail("Expected updateRow() to throw exception");
1:f342d5b:         } catch (SQLException e) {
1:f342d5b:             assertEquals("Unexpected SQLState",
1:f342d5b:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW, e.getSQLState());
1:f342d5b:         }
1:ff65830:         s.close();
1:f342d5b:     }
1:f342d5b: 
1:f342d5b:     /**
1:f342d5b:      * Test that updateRow() after a commit requires a renavigation 
1:f342d5b:      * on a held scrollinsensitve ResulTset.
1:f342d5b:      */
1:f342d5b:     public void testUpdateRowAfterCommitOnHeldScrollInsensitiveResultSet() 
1:f342d5b:         throws SQLException
1:f342d5b:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:f342d5b:                                           ResultSet.CONCUR_UPDATABLE);
1:f342d5b:         ResultSet rs = s.executeQuery(selectStatement);
1:f342d5b:         
1:f342d5b:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:f342d5b:         }
1:f342d5b:         rs.next();
1:ff65830:         commit();
1:f342d5b:         try {
1:f342d5b:             rs.updateInt(2, -100);
1:f342d5b:             rs.updateRow();
1:5b9d0fb:             fail("Expected updateRow() to throw exception");
1:f342d5b:         } catch (SQLException e) {
1:f342d5b:             assertEquals("Unexpected SQLState",
1:f342d5b:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW, e.getSQLState());
1:f342d5b:         }
1:ff65830:         s.close();
1:f342d5b:     }
1:f342d5b: 
1:f342d5b:     /**
1:c049abf:      * Test that running a compress on a holdable scrollable updatable 
1:c049abf:      * resultset will not invalidate the ResultSet from doing updates,
1:c049abf:      * if the scan is initialized
1:c049abf:      */
1:c049abf:     public void testCompressOnHeldScrollableUpdatableResultSetScanInit()
1:c049abf:         throws SQLException
1:c049abf:     {
1:c049abf:         // First: Read all records in the table into the ResultSet:
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c049abf:         }
1:ff65830:         commit(); // commit
1:ff65830:         
1:c049abf:         // Verifies resultset can do updates after compress
1:c049abf:         verifyResultSetUpdatableAfterCompress(rs);
1:c049abf:         
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Test that running a compress on a holdable scrollable updatable 
1:c049abf:      * resultset will invalidate the Resultset from doing updates after 
1:c049abf:      * a renavigate, if the scan is in progress.
1:c049abf:      */
1:c049abf:     public void testCompressOnHeldScrollableUpdatableResultSetScanInProgress()
1:c049abf:         throws SQLException
1:c049abf:     {
1:c049abf:         // First: Read all records in the table into the ResultSet:
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c049abf:         }
1:c049abf:         rs.next(); // Scan is in progress.
1:c049abf:         
1:ff65830:         commit(); // commit, releases the lock on the records
1:c049abf:         
1:c049abf:         verifyCompressInvalidation(rs);
1:ff65830:         
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf:     
1:c049abf:     /**
1:c049abf:      * Test that running a compress on a holdable scrollable updatable 
1:c049abf:      * resultset will invalidate the Resultset from doing updates after 
1:c049abf:      * a renavigate.
1:c049abf:      */
1:c049abf:     public void testCompressOnHeldScrollableUpdatableResultSetScanDone()
1:c049abf:         throws SQLException
1:c049abf:     {
1:c049abf:         // First: Read all records in the table into the ResultSet:
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:c049abf:                                           ResultSet.CONCUR_UPDATABLE);
1:c049abf:         ResultSet rs = s.executeQuery(selectStatement);
1:c049abf:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
1:5b9d0fb:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:c049abf:         }
1:c049abf:         
1:c049abf:         scrollForward(rs); // scan is done
1:c049abf:         
1:ff65830:         commit(); // commit, releases the lock on the records
1:c049abf:         
1:c049abf:         verifyCompressInvalidation(rs);
1:ff65830:         s.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Verifies that even after a compress, the ResultSet of this type and
1:c049abf:      * state is updatable.
1:c049abf:      */
1:c049abf:     private void verifyResultSetUpdatableAfterCompress(ResultSet rs) 
1:c049abf:         throws SQLException
1:c049abf:     {
1:c049abf:                 // Delete all records except the first:
1:ff65830:         Statement delStatement = createStatement();
1:c049abf:         int deleted = delStatement.executeUpdate("delete from T1 where id>0");
1:4316596:         int expectedDeleted = recordCount-1;
1:4316596:         delStatement.close();
1:c049abf:         
1:c049abf:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:c049abf:                      deleted);
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         // Execute online compress
1:c049abf:         onlineCompress(true, true, true);
1:c049abf:         
1:c049abf:         // Now reinsert the tuples:
1:ff65830:         PreparedStatement ps = 
1:4c9b831:             prepareStatement("insert into t1 values (?,?,?,?,?)");
1:c049abf:         
1:c049abf:         for (int i=0; i<recordCount*2; i++) {
1:c049abf:             int recordId = i + recordCount + 1000;
1:c049abf:             ps.setInt(1, recordId);
1:c049abf:             ps.setInt(2, recordId);
1:c049abf:             ps.setInt(3, recordId *2 + 17);
1:c049abf:             ps.setString(4, "m" + recordId);
1:4c9b831:             ps.setString(5, "c"+recordId);
1:c049abf:             ps.addBatch();
1:c049abf:         }
1:c049abf:         ps.executeBatch();
1:5b9d0fb:         ps.close();
1:ff65830:         commit();
1:c049abf: 
1:c049abf:         rs.next();
1:c049abf:         updateTuple(rs);
1:c049abf:         
1:c049abf:         SQLWarning warn = rs.getWarnings();
1:c049abf:         assertNull("Expected no warning when updating this row", warn);
1:c049abf:         
1:c049abf:         // This part if only for scrollable resultsets
1:c049abf:         if (rs.getType()!=ResultSet.TYPE_FORWARD_ONLY) {
1:c049abf:             
1:c049abf:             // Update last tuple
1:c049abf:             rs.last();         
1:c049abf:             updateTuple(rs);
1:c049abf:             
1:c049abf:             warn = rs.getWarnings();
1:c049abf:             assertNull("Expected no warning when updating this row", warn);
1:c049abf:             
1:c049abf:             // Update first tuple
1:c049abf:             rs.first();
1:c049abf:             updateTuple(rs);
1:c049abf:             warn = rs.getWarnings();
1:c049abf:             assertNull("Expected no warning when updating this row", warn);
1:c049abf:         }
1:c049abf:         
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         // Verify data
1:ff65830:         rs = createStatement().executeQuery(selectStatement);
1:c049abf:         while (rs.next()) {            
1:c049abf:             verifyTuple(rs);
1:c049abf:         }
1:5b9d0fb:         rs.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Verifies that the ResultSet is invalidated from doing updates after
1:c049abf:      * a compress.
1:c049abf:      * @param rs ResultSet which we test is being invalidated
1:c049abf:      */
1:c049abf:     private void verifyCompressInvalidation(ResultSet rs) 
1:c049abf:         throws SQLException 
1:c049abf:     {
1:c049abf:         
1:c049abf:         // Delete all records except the first:
1:ff65830:         Statement delStatement = createStatement();
1:c049abf:         int deleted = delStatement.executeUpdate("delete from T1 where id>0");
2:c049abf:         int expectedDeleted = recordCount-1;    
1:ff65830:         delStatement.close();
1:c049abf:         
1:c049abf:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:c049abf:                      deleted);
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         // Execute online compress
1:c049abf:         onlineCompress(true, true, true);
1:c049abf:         
1:c049abf:         // Now reinsert the tuples:
1:ff65830:         PreparedStatement ps = 
1:4c9b831:             prepareStatement("insert into t1 values (?,?,?,?,?)");
1:c049abf:         
1:c049abf:         for (int i=0; i<recordCount*2; i++) {
1:c049abf:             int recordId = i + recordCount + 1000;
1:c049abf:             ps.setInt(1, recordId);
1:c049abf:             ps.setInt(2, recordId);
1:c049abf:             ps.setInt(3, recordId *2 + 17);
1:c049abf:             ps.setString(4, "m" + recordId);
1:4c9b831:             ps.setString(5, "c" + recordId);
1:c049abf:             ps.addBatch();
1:c049abf:         }
1:c049abf:         ps.executeBatch();
1:ff65830:         ps.close();
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         // Update last tuple
1:c049abf:         rs.last();         
1:c049abf:         rs.updateInt(2, -100);
1:c049abf:         rs.updateRow();
1:c049abf:         SQLWarning warn = rs.getWarnings();
1:c247315:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:c049abf:         rs.clearWarnings();
1:c049abf:         
1:c049abf:         // Update first tuple
1:c049abf:         rs.first(); 
1:c049abf:         rs.updateInt(2, -100);
1:c049abf:         updateTuple(rs); 
1:c049abf:         warn = rs.getWarnings();
1:c247315:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:ff65830:         commit();
1:c049abf:         
1:c049abf:         // Verify data
1:ff65830:         rs = createStatement().executeQuery(selectStatement);
1:c049abf:         while (rs.next()) {            
1:c049abf:             // This will fail if we managed to update reinserted tuple
1:c049abf:             verifyTuple(rs); 
1:c049abf:         }
1:5b9d0fb:         rs.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     /**
1:c049abf:      * Executes online compress
1:c049abf:      * @param purge set to true to purge rows
1:c049abf:      * @param defragment set to true to defragment rows
1:c049abf:      * @param truncate set to true to truncate pages
1:c049abf:      */
1:c049abf:     private void onlineCompress(boolean purge, 
1:c049abf:                                 boolean defragment, 
1:c049abf:                                 boolean truncate)
1:c049abf:         throws SQLException
1:c049abf:     {
1:c049abf:                // Use a new connection to compress the table        
1:03a99e2:         final Connection con2 = openDefaultConnection();
1:c049abf:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:c049abf:         
1:c049abf:         final PreparedStatement ps2 = con2.prepareStatement
1:c049abf:             ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:c049abf:         ps2.setString(1, "APP"); // schema
1:c049abf:         ps2.setString(2, "T1");  // table name
1:c049abf:         ps2.setBoolean(3, purge);
1:c049abf:         ps2.setBoolean(4, defragment);
1:c049abf:         ps2.setBoolean(5, truncate);
1:c049abf:         
1:4316596:         ps2.executeUpdate();
1:4316596:         ps2.close();
1:4316596:         con2.commit();
1:4316596:         con2.close();
1:c049abf:     }
1:c049abf: 
1:c049abf:     private final static String selectStatement = "select * from t1";
1:c049abf: }
============================================================================
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4c9b831
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("insert into t1 values (?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:             ps.setString(5, "c"+recordId);
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("insert into t1 values (?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:             ps.setString(5, "c" + recordId);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client())
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4316596
/////////////////////////////////////////////////////////////////////////
1:         int expectedDeleted = recordCount-1;
1:         delStatement.close();
/////////////////////////////////////////////////////////////////////////
1:         ps2.executeUpdate();
1:         ps2.close();
1:         con2.commit();
1:         con2.close();
commit:5b9d0fb
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() 
/////////////////////////////////////////////////////////////////////////
1:     protected void tearDown() throws Exception
1:     	// Commit any changes, they will be dropped
1:     	// anyway by the next setUp to run or the
1:     	// outer database cleaners. It's faster to
1:     	// commit than rollback many changes.
1:     	commit();
1:     	super.tearDown();
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:             fail("Expected updateRow() to throw exception");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
1:             fail("Expected updateRow() to throw exception");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:             fail("ResultSet concurrency downgraded to CONCUR_READ_ONLY");
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
/////////////////////////////////////////////////////////////////////////
commit:985662b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:             return new TestSuite();
1:         return TestConfiguration.defaultSuite(HoldabilityTest.class);
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getConnection(),
/////////////////////////////////////////////////////////////////////////
1:         final Connection con2 = openDefaultConnection();
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
commit:ff65830
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.CleanDatabaseTestSetup;
1: 
/////////////////////////////////////////////////////////////////////////
0:         return new CleanDatabaseTestSetup(suite);
/////////////////////////////////////////////////////////////////////////
1:        // For the holdability tests, we recreate the model
0:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getXConnection(),
1:         commit();
/////////////////////////////////////////////////////////////////////////
0:             rollback();
0:             Statement dropStatement = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         commit(); // scan initialized
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         commit(); // Scan is in progress
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:         commit(); // scan initialized
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // Scan is in progress
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:         commit(); // scan initialized
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // Scan is in progress
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         commit(); // scan initialized
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // Scan is in progress
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         commit();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // scan initialized
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // Scan is in progress
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // commit
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // commit, releases the lock on the records
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit(); // commit, releases the lock on the records
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement delStatement = createStatement();
1:         commit();
1:         PreparedStatement ps = 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         rs = createStatement().executeQuery(selectStatement);
/////////////////////////////////////////////////////////////////////////
1:         Statement delStatement = createStatement();
1:         delStatement.close();
1:         commit();
1:         PreparedStatement ps = 
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         rs = createStatement().executeQuery(selectStatement);
/////////////////////////////////////////////////////////////////////////
0:             ps2.close();
commit:a6464f2
/////////////////////////////////////////////////////////////////////////
0:      * @throws Exception 
0:     public void tearDown() throws Exception 
0:             dropStatement.close();
0:         super.tearDown();
commit:d038483
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:                
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
0:             return suite;
1:         
0:         suite.addTestSuite(HoldabilityTest.class);
1:         
0:         return suite;
1: 
1:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:c247315
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
1:         }        
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
0:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
0:                        false);
/////////////////////////////////////////////////////////////////////////
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
/////////////////////////////////////////////////////////////////////////
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
commit:f342d5b
/////////////////////////////////////////////////////////////////////////
1:      * Test that updateRow() after a commit requires a renavigation 
1:      * on a held forward only ResulTset.
1:      */
1:     public void testUpdateRowAfterCommitOnHeldForwardOnlyResultSet() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:         rs.next();
0:         con.commit();
1:         try {
1:             rs.updateInt(2, -100);
1:             rs.updateRow();
0:             assertTrue("Expected updateRow() to throw exception", false);
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQLState",
1:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW, e.getSQLState());
1:         }
1:     }
1: 
1:     /**
1:      * Test that updateRow() after a commit requires a renavigation 
1:      * on a held scrollinsensitve ResulTset.
1:      */
1:     public void testUpdateRowAfterCommitOnHeldScrollInsensitiveResultSet() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:         rs.next();
0:         con.commit();
1:         try {
1:             rs.updateInt(2, -100);
1:             rs.updateRow();
0:             assertTrue("Expected updateRow() to throw exception", false);
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQLState",
1:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW, e.getSQLState());
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("Unexpected SQL State on warning", 
0:                      CURSOR_OPERATION_CONFLICT, 
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("Unexpected SQL State on warning", 
0:                      CURSOR_OPERATION_CONFLICT, 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c049abf
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class HoldabilityTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: import junit.framework.*;
1: import java.sql.*;
1: 
1: /**
1:  * Tests holdable resultsets.
1:  */
1: public class HoldabilityTest extends SURBaseTest {
1:     
1:     /** Creates a new instance of HoldabilityTest */
1:     public HoldabilityTest(String name) {
1:         super(name, 1000); // We will use 1000 records
1:     }
1: 
1:     /**
1:      * Sets up the connection, then create the data model
1:      */
0:     public void setUp() 
1:         throws Exception 
1:     {      
0:         try {
0:             super.setUp();
0:         } catch (SQLException e) {
0:             if (con!=null) tearDown();
0:             throw e;
1:         }
0:         // For the holdability tests, we recreate the model
1:         // for each testcase (since we do commits)
1:         
1:         // We also use more records to ensure that the disk
1:         // is being used.
1:         SURDataModelSetup.createDataModel
0:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, con,
1:              recordCount);
0:         con.commit();
1:     }
1:     
1:     /**
0:      * Drop the data model, and close the connection
1:      */
0:     public void tearDown() 
1:     {
0:         try {            
0:             con.rollback();
0:             Statement dropStatement = con.createStatement();
0:             dropStatement.execute("drop table t1");
0:             con.commit();
0:             con.close();
0:         } catch (SQLException e) {
0:             printStackTrace(e); // Want to propagate the real exception.
1:         }
1:     }
1:     
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it has not done any scanning
1:      */
1:     public void testHeldForwardOnlyResultSetScanInit() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
0:         con.commit(); // scan initialized
1:         
1:         scrollForward(rs);
1:     }
1:     
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it is in progress of scanning
1:      */
1:     public void testHeldForwardOnlyResultSetScanInProgress() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery(selectStatement);
1: 
1:         for (int i=0; i<this.recordCount/2; i++) {
1:             rs.next();
1:             verifyTuple(rs);
1:         }
0:         con.commit(); // Scan is in progress
1:         
1:         while (rs.next()) {
1:             verifyTuple(rs);
1:         }
1:     }
1: 
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it has not done any scanning, and be updatable
1:      */
1:     public void testHeldForwardOnlyUpdatableResultSetScanInit() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
0:         con.commit(); // scan initialized
1:         rs.next();    // naviagate to a new tuple
1:         updateTuple(rs); // Updatable
1:         scrollForward(rs);
1:     }
1:     
1:     
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it is in progress of scanning, and that after a compress the
1:      * resultset is still updatable.
1:      */
1:     public void testCompressOnHeldForwardOnlyUpdatableResultSetScanInProgress()
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1: 
1:         for (int i=0; i<this.recordCount/2; i++) {
1:             rs.next();
1:             verifyTuple(rs);
1:         }
1:         updateTuple(rs);
0:         con.commit(); // Scan is in progress
1:         
1:         // Verifies resultset can do updates after compress
1:         verifyResultSetUpdatableAfterCompress(rs);
1:         
1:     }
1: 
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it has not done any scanning, and that after a compress it is
1:      * still updatable.
1:      */
1:     public void testCompressOnHeldForwardOnlyUpdatableResultSetScanInit() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
0:         con.commit(); // scan initialized
1:         
1:         // Verifies resultset can do updates after compress
1:         verifyResultSetUpdatableAfterCompress(rs);
1:     }
1:         
1:     /**
1:      * Test that a forward only resultset can be held over commit while
1:      * it is in progress of scanning
1:      */
1:     public void testHeldForwardOnlyUpdatableResultSetScanInProgress() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1: 
1:         for (int i=0; i<this.recordCount/2; i++) {
1:             rs.next();
1:             verifyTuple(rs);
1:         }
1:         updateTuple(rs);
0:         con.commit(); // Scan is in progress
1:         rs.next();
1:         updateTuple(rs); // Still updatable
1:         while (rs.next()) {
1:             verifyTuple(rs); // complete the scan
1:         }
1:     }
1:     
1:     /**
1:      * Test that a scrollable resultset can be held over commit while
1:      * it has not done any scanning
1:      */
1:     public void testHeldScrollableResultSetScanInit() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
0:         con.commit(); // scan initialized
1:         
1:         scrollForward(rs);
1:         scrollBackward(rs);
1:     }
1:         
1:     /**
1:      * Test that a scrollable resultset can be held over commit while
1:      * it is in progress of scanning
1:      */
1:     public void testHeldScrollableResultSetScanInProgress() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = s.executeQuery(selectStatement);
1: 
1:         for (int i=0; i<this.recordCount/2; i++) {
1:             rs.next();
1:             verifyTuple(rs);
1:         }
0:         con.commit(); // Scan is in progress
1:         
1:         while (rs.next()) {
1:             verifyTuple(rs);
1:         }
1:         scrollBackward(rs);
1:     }
1: 
1:     /**
1:      * Test that a scrollable resultset can be held over commit
1:      * after the resultset has been populated
1:      */
1:     public void testHeldScrollableResultSetScanDone() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
1:         scrollForward(rs); // Scan is done
1:         
0:         con.commit();
1:         
1:         scrollBackward(rs);
1:     }
1: 
1:     /**
1:      * Test that a scrollable updatable resultset can be held over commit 
1:      * while it has not done any scanning
1:      */
1:     public void testHeldScrollableUpdatableResultSetScanInit() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
0:         con.commit(); // scan initialized
1:         
1:         scrollForward(rs);
1:         scrollBackwardAndUpdate(rs);
1:     }    
1:     
1:     /**
1:      * Test that a scrollable updatable resultset can be held over commit while
1:      * it is in progress of scanning
1:      */
1:     public void testHeldScrollableUpdatableResultSetScanInProgress() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:         for (int i=0; i<this.recordCount/2; i++) {
1:             rs.next();
1:             verifyTuple(rs);
1:         }
0:         con.commit(); // Scan is in progress
1:         
1:         while (rs.next()) {
1:             verifyTuple(rs);
1:         }
1:         scrollBackwardAndUpdate(rs);
1:     }
1: 
1:     /**
1:      * Test that a scrollable updatable resultset can be held over commit
1:      * after the resultset has been populated
1:      */
1:     public void testHeldScrollableUpdatableResultSetScanDone() 
1:         throws SQLException
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:       
1:         scrollForward(rs); // Scan is done
1:         
0:         con.commit();
1:         
1:         scrollBackwardAndUpdate(rs);
1:     }
1: 
1:     /**
1:      * Test that running a compress on a holdable scrollable updatable 
1:      * resultset will not invalidate the ResultSet from doing updates,
1:      * if the scan is initialized
1:      */
1:     public void testCompressOnHeldScrollableUpdatableResultSetScanInit()
1:         throws SQLException
1:     {
1:         // First: Read all records in the table into the ResultSet:
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
0:         con.commit(); // commit
1:         
1:         // Verifies resultset can do updates after compress
1:         verifyResultSetUpdatableAfterCompress(rs);
1:     }
1: 
1:     /**
1:      * Test that running a compress on a holdable scrollable updatable 
1:      * resultset will invalidate the Resultset from doing updates after 
1:      * a renavigate, if the scan is in progress.
1:      */
1:     public void testCompressOnHeldScrollableUpdatableResultSetScanInProgress()
1:         throws SQLException
1:     {
1:         // First: Read all records in the table into the ResultSet:
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:         rs.next(); // Scan is in progress.
1:         
0:         con.commit(); // commit, releases the lock on the records
1:         
1:         verifyCompressInvalidation(rs);
1:     }
1:     
1:     /**
1:      * Test that running a compress on a holdable scrollable updatable 
1:      * resultset will invalidate the Resultset from doing updates after 
1:      * a renavigate.
1:      */
1:     public void testCompressOnHeldScrollableUpdatableResultSetScanDone()
1:         throws SQLException
1:     {
1:         // First: Read all records in the table into the ResultSet:
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(selectStatement);
1:         if (rs.getConcurrency()==ResultSet.CONCUR_READ_ONLY) {
0:             println("Test disabled");
0:             return;
1:         }
1:         
1:         scrollForward(rs); // scan is done
1:         
0:         con.commit(); // commit, releases the lock on the records
1:         
1:         verifyCompressInvalidation(rs);
1:     }
1: 
1:     /**
1:      * Verifies that even after a compress, the ResultSet of this type and
1:      * state is updatable.
1:      */
1:     private void verifyResultSetUpdatableAfterCompress(ResultSet rs) 
1:         throws SQLException
1:     {
1:                 // Delete all records except the first:
0:         Statement delStatement = con.createStatement();
1:         int deleted = delStatement.executeUpdate("delete from T1 where id>0");
1:         int expectedDeleted = recordCount-1;    
1:         
1:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:                      deleted);
0:         con.commit();
1:         
1:         // Execute online compress
1:         onlineCompress(true, true, true);
1:         
1:         // Now reinsert the tuples:
0:         PreparedStatement ps = con.
0:             prepareStatement("insert into t1 values (?,?,?,?)");
1:         
1:         for (int i=0; i<recordCount*2; i++) {
1:             int recordId = i + recordCount + 1000;
1:             ps.setInt(1, recordId);
1:             ps.setInt(2, recordId);
1:             ps.setInt(3, recordId *2 + 17);
1:             ps.setString(4, "m" + recordId);
1:             ps.addBatch();
1:         }
1:         ps.executeBatch();
0:         con.commit();
1: 
1:         rs.next();
1:         updateTuple(rs);
1:         
1:         SQLWarning warn = rs.getWarnings();
1:         assertNull("Expected no warning when updating this row", warn);
1:         
1:         // This part if only for scrollable resultsets
1:         if (rs.getType()!=ResultSet.TYPE_FORWARD_ONLY) {
1:             
1:             // Update last tuple
1:             rs.last();         
1:             updateTuple(rs);
1:             
1:             warn = rs.getWarnings();
1:             assertNull("Expected no warning when updating this row", warn);
1:             
1:             // Update first tuple
1:             rs.first();
1:             updateTuple(rs);
1:             warn = rs.getWarnings();
1:             assertNull("Expected no warning when updating this row", warn);
1:         }
1:         
0:         con.commit();
1:         
1:         // Verify data
0:         rs = con.createStatement().executeQuery(selectStatement);
1:         while (rs.next()) {            
1:             verifyTuple(rs);
1:         }
1:     }
1: 
1:     /**
1:      * Verifies that the ResultSet is invalidated from doing updates after
1:      * a compress.
1:      * @param rs ResultSet which we test is being invalidated
1:      */
1:     private void verifyCompressInvalidation(ResultSet rs) 
1:         throws SQLException 
1:     {
1:         
1:         // Delete all records except the first:
0:         Statement delStatement = con.createStatement();
1:         int deleted = delStatement.executeUpdate("delete from T1 where id>0");
1:         int expectedDeleted = recordCount-1;    
1:         
1:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:                      deleted);
0:         con.commit();
1:         
1:         // Execute online compress
1:         onlineCompress(true, true, true);
1:         
1:         // Now reinsert the tuples:
0:         PreparedStatement ps = con.
0:             prepareStatement("insert into t1 values (?,?,?,?)");
1:         
1:         for (int i=0; i<recordCount*2; i++) {
1:             int recordId = i + recordCount + 1000;
1:             ps.setInt(1, recordId);
1:             ps.setInt(2, recordId);
1:             ps.setInt(3, recordId *2 + 17);
1:             ps.setString(4, "m" + recordId);
1:             ps.addBatch();
1:         }
1:         ps.executeBatch();
0:         con.commit();
1:         
1:         // Update last tuple
1:         rs.last();         
1:         rs.updateInt(2, -100);
1:         rs.updateRow();
1:         SQLWarning warn = rs.getWarnings();
0:         assertNotNull("Expected warning when updating deleted tuple", warn);
0:         assertEquals("Unexpected SQL State on warning", "01001", 
0:                      warn.getSQLState());        
1:         rs.clearWarnings();
1:         
1:         // Update first tuple
1:         rs.first(); 
1:         rs.updateInt(2, -100);
1:         updateTuple(rs); 
1:         warn = rs.getWarnings();
0:         assertNotNull("Expected warning when updating deleted tuple", warn);
0:         assertEquals("Unexpected SQL State on warning", "01001", 
0:                      warn.getSQLState());
0:         con.commit();
1:         
1:         // Verify data
0:         rs = con.createStatement().executeQuery(selectStatement);
1:         while (rs.next()) {            
1:             // This will fail if we managed to update reinserted tuple
1:             verifyTuple(rs); 
1:         }
1:     }
1: 
1:     /**
1:      * Executes online compress
1:      * @param purge set to true to purge rows
1:      * @param defragment set to true to defragment rows
1:      * @param truncate set to true to truncate pages
1:      */
1:     private void onlineCompress(boolean purge, 
1:                                 boolean defragment, 
1:                                 boolean truncate)
1:         throws SQLException
1:     {
1:                // Use a new connection to compress the table        
0:         final Connection con2 = getNewConnection();
0:         final String connId = con2.toString();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         
1:         final PreparedStatement ps2 = con2.prepareStatement
1:             ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:         ps2.setString(1, "APP"); // schema
1:         ps2.setString(2, "T1");  // table name
1:         ps2.setBoolean(3, purge);
1:         ps2.setBoolean(4, defragment);
1:         ps2.setBoolean(5, truncate);
1:         
0:         try { 
0:             ps2.executeUpdate();
0:             con2.commit();
0:         } finally {
0:             con2.close();
1:         }
1:     }
1: 
1:     private final static String selectStatement = "select * from t1";
1: }
============================================================================