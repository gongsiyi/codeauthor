1:c58f84b: /*
10:c58f84b: 
1:e906df8:    Derby - Class org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests
1:d773139: 
1:c58f84b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c58f84b:    contributor license agreements.  See the NOTICE file distributed with
1:c58f84b:    this work for additional information regarding copyright ownership.
1:c58f84b:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c58f84b:    (the "License"); you may not use this file except in compliance with
1:c58f84b:    the License.  You may obtain a copy of the License at
1:d773139: 
1:c58f84b:       http://www.apache.org/licenses/LICENSE-2.0
1:d773139: 
1:c58f84b:    Unless required by applicable law or agreed to in writing, software
1:c58f84b:    distributed under the License is distributed on an "AS IS" BASIS,
1:c58f84b:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c58f84b:    See the License for the specific language governing permissions and
1:c58f84b:    limitations under the License.
1:d773139: 
1:c58f84b:  */
1:c58f84b: package org.apache.derbyTesting.functionTests.util;
1:d773139: 
1:c58f84b: import java.io.File;
1:c58f84b: import java.io.FileInputStream;
1:c58f84b: import java.io.FileNotFoundException;
1:c33b0cf: import java.io.FileOutputStream;
1:a03ad56: import java.io.FileReader;
1:e4e2bfd: import java.io.FileWriter;
1:d773139: import java.io.IOException;
1:d773139: import java.io.InputStream;
1:d773139: import java.io.OutputStream;
1:4394bdd: import java.net.URI;
1:c58f84b: import java.security.AccessController;
1:e906df8: import java.security.PrivilegedAction;
1:c58f84b: import java.security.PrivilegedActionException;
1:c58f84b: import java.security.PrivilegedExceptionAction;
1:c7b3589: import java.util.ArrayList;
1:c7b3589: import java.util.List;
1:d773139: 
1:d773139: /**
1:e906df8:  * A set of operations on {@link java.io.File} that wraps the
1:c58f84b:  * operations in privileged block of code. This class is intended to provide
1:c58f84b:  * these methods for testcases to reduce the hassle of having to wrap file
1:c58f84b:  * operations in privileged code blocks.
2:c58f84b:  * <p>
1:c58f84b:  * Derby needs to use privileged blocks in some places to avoid
1:c58f84b:  * {@link SecurityException}s being thrown, as the required privileges are
1:c58f84b:  * often granted to Derby itself, but not the higher level application code.
1:c58f84b:  */
1:c58f84b: public class PrivilegedFileOpsForTests {
1:e906df8: 
1:ea9b68b: 	/**
1:c58f84b:      * Get the file length.
1:d773139:      *
1:e906df8:      * @return Byte length of the file.
1:c58f84b:      * @throws SecurityException if the required permissions to read the file,
1:c58f84b:      *      or the path it is in, are missing
1:c58f84b:      * @see File#length
1:c58f84b:      */
1:c58f84b:     public static long length(final File file)
1:c58f84b:             throws SecurityException {
1:c58f84b:         if (file == null) {
1:c58f84b:             throw new IllegalArgumentException("file cannot be <null>");
7:c58f84b:         }
1:2510115:         return AccessController.doPrivileged(
1:2510115:                     new PrivilegedAction<Long>() {
1:2510115:                         public Long run() {
1:2510115:                             return file.length();
1:e906df8:                         }
1:2510115:                     });
1:e906df8:     }
1:e906df8: 
1:8aa8deb:     /**
1:d773139:      * Get the absolute path
1:0dfad31:      *
1:d773139:      * @param file File for absolute path
1:d773139:      * @return Absolute path of the file.
1:d773139:      * @throws SecurityException if the required permissions to access the file,
1:d773139:      *      
1:d773139:      * @see File#getAbsolutePath
1:0dfad31:      */
1:d773139:     public static String getAbsolutePath(final File file)
1:d773139:             throws SecurityException {
1:d773139:         if (file == null) {
1:d773139:             throw new IllegalArgumentException("file cannot be <null>");
1:e4e2bfd:         }
1:2510115:         return AccessController.doPrivileged(
1:2510115:                 new PrivilegedAction<String>() {
1:2510115:                     public String run() throws SecurityException {
1:d773139:                         return file.getAbsolutePath();
1:d773139:                     }});
1:d773139:     }
1:2d7d37f: 
1:2d7d37f:     /**
1:4394bdd:      * Get the URI for a file.
1:4394bdd:      *
1:4394bdd:      * @param file File to be queried
1:4394bdd:      * @return Its URI
1:4394bdd:      * @throws SecurityException if the test lacks the required permissions to access the file,
1:4394bdd:      *      
1:4394bdd:      * @see File#getAbsolutePath
1:4394bdd:      */
1:4394bdd:     public static URI toURI(final File file)
1:4394bdd:             throws SecurityException {
1:4394bdd:         if (file == null) {
1:4394bdd:             throw new IllegalArgumentException("file cannot be <null>");
1:4394bdd:         }
1:2510115:         return AccessController.doPrivileged(
1:4394bdd:                 new PrivilegedAction<URI>() {
1:4394bdd:                     public URI run() throws SecurityException {
1:4394bdd:                         return file.toURI();
1:4394bdd:                     }});
1:4394bdd:     }
1:4394bdd: 
1:4394bdd:     /**
1:2d7d37f:      * Create a temporary file.
1:2d7d37f:      *
1:2d7d37f:      * @param prefix file name prefix, at least three characters
1:2d7d37f:      * @param suffix file name suffix, defaults to ".tmp" if {@code null}
1:2d7d37f:      * @param directory where to create the file, or {@code null} for the
1:2d7d37f:      *   default temporary file directory
1:2d7d37f:      * @return the file that was created
1:2d7d37f:      * @throws IOException if the file cannot be created
1:2d7d37f:      * @see File#createTempFile(String, String, File)
1:2d7d37f:      */
1:2d7d37f:     public static File createTempFile(final String prefix,
1:2d7d37f:                                       final String suffix,
1:2d7d37f:                                       final File directory)
1:2d7d37f:             throws IOException
1:2d7d37f:     {
1:2d7d37f:         try {
1:2d7d37f:             return AccessController.doPrivileged(
1:2d7d37f:                 new PrivilegedExceptionAction<File>() {
1:2d7d37f:                     @Override
1:2d7d37f:                     public File run() throws IOException {
1:2d7d37f:                         return File.createTempFile(prefix, suffix, directory);
1:2d7d37f:                     }
1:2d7d37f:                 });
1:2d7d37f:         } catch (PrivilegedActionException pae) {
1:2d7d37f:             throw (IOException) pae.getCause();
1:2d7d37f:         }
1:2d7d37f:     }
1:a03ad56: 
1:e906df8:     /**
1:e906df8:      * Returns a input stream for the specified file.
1:e906df8:      *
1:e906df8:      * @param file the file to open a stream for
1:e906df8:      * @return A input stream reading from the specified file.
1:e906df8:      * @throws SecurityException if the required permissions to read the file,
1:e906df8:      *      or the path it is in, are missing
1:e906df8:      * @throws FileNotFoundException if the specified file does not exist
1:e906df8:      */
1:c58f84b:     public static FileInputStream getFileInputStream(final File file) 
1:0dfad31:             throws FileNotFoundException {
1:c58f84b:     	if (file == null) {
1:0dfad31:             throw new IllegalArgumentException("file cannot be <null>");
1:0dfad31:         }
1:0dfad31:         try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<FileInputStream>() {
1:2510115:                 public FileInputStream run() throws FileNotFoundException {
1:2510115:                     return new FileInputStream(file);
1:2510115:                 }
1:2510115:             });
1:0dfad31:         } catch (PrivilegedActionException pae) {
1:e906df8:             throw (FileNotFoundException)pae.getException();
1:0dfad31:         }
1:d773139:     }
1:e4e2bfd: 
1:a03ad56:     /**
1:ea9b68b:      * Check if the file exists.
1:ea9b68b:      *
1:e906df8:      * @return {@code true} if file exists, {@code false} otherwise
1:ea9b68b:      * @throws SecurityException if the required permissions to read the file,
1:ea9b68b:      *      or the path it is in, are missing
1:ea9b68b:      * @see File#exists
1:d773139:      */
1:ea9b68b:     public static boolean exists(final File file)
1:ea9b68b:             throws SecurityException {
1:ea9b68b:         if (file == null) {
1:ea9b68b:             throw new IllegalArgumentException("file cannot be <null>");
1:d773139:         }
1:2510115:         return AccessController.doPrivileged(
1:2510115:                     new PrivilegedAction<Boolean>() {
1:2510115:                         public Boolean run() {
1:2510115:                             return file.exists();
1:d773139:                         }
1:2510115:                     });
1:ea9b68b:     }
1:e4e2bfd: 
1:e4e2bfd:     /**
1:e4e2bfd:      * Delete a file
1:e4e2bfd:      *
1:e4e2bfd:      * @return {@code true} if file was deleted, {@code false} otherwise
1:e4e2bfd:      * @throws SecurityException if the required permissions to read the file,
1:e4e2bfd:      *      or the path it is in, are missing
1:e4e2bfd:      * @see File#delete
1:e4e2bfd:      */
1:e4e2bfd:     public static boolean delete(final File file)
1:e4e2bfd:             throws SecurityException {
1:e4e2bfd:         if (file == null) {
1:e4e2bfd:             throw new IllegalArgumentException("file cannot be <null>");
1:e4e2bfd:         }
1:2510115:         return AccessController.doPrivileged(
1:2510115:                     new PrivilegedAction<Boolean>() {
1:2510115:                         public Boolean run() {
1:2510115:                             return file.delete();
1:e4e2bfd:                         }
1:2510115:                     });
1:e4e2bfd:     }
1:e4e2bfd: 
1:e4e2bfd:     /**
1:d32b042:      * Create a directory.
1:d32b042:      * @param dir the directory to create
1:d32b042:      * @return {@code true} if and only if the directory was created
1:d32b042:      */
1:d32b042:     public static boolean mkdir(final File dir) {
1:d32b042:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:d32b042:             public Boolean run() {
1:d32b042:                 return dir.mkdir();
1:d32b042:             }
1:d32b042:         });
1:d32b042:     }
1:d32b042: 
1:d32b042:     /**
1:d32b042:      * Set the read permission for a file.
1:d32b042:      * @param file      the file to set the read permission for
1:d32b042:      * @param readable  {@code true} to allow read, {@code false} to deny it
1:d32b042:      * @param ownerOnly {@code true} if it should be set for the owner only,
1:d32b042:      *                  {@code false} if it should be set for everyone
1:d32b042:      * @return {@code true} if the operation succeeded, {@code false} otherwise
1:d32b042:      */
1:d32b042:     public static boolean setReadable(final File file,
1:d32b042:                                       final boolean readable,
1:d32b042:                                       final boolean ownerOnly) {
1:d32b042:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:d32b042:             public Boolean run() {
1:d32b042:                 return file.setReadable(readable, ownerOnly);
1:d32b042:             }
1:d32b042:         });
1:d32b042:     }
1:d32b042: 
1:d32b042:     /**
1:2d7d37f:      * Make a file or directory read-only.
1:2d7d37f:      * @param file the file to make read-only
1:2d7d37f:      * @return {@code true} if successful, {@code false} otherwise
1:2d7d37f:      */
1:2d7d37f:     public static boolean setReadOnly(final File file) {
1:2d7d37f:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:2d7d37f:             @Override
1:2d7d37f:             public Boolean run() {
1:2d7d37f:                 return file.setReadOnly();
1:2d7d37f:             }
1:2d7d37f:         });
1:2d7d37f:     }
1:2d7d37f: 
1:2d7d37f:     /**
1:a03ad56:      * Obtains a reader for the specified file.
1:a03ad56:      *
1:a03ad56:      * @param file the file to obtain a reader for
1:a03ad56:      * @return An unbuffered reader for the specified file.
1:a03ad56:      * @throws FileNotFoundException if the specified file does not exist
1:e906df8:      * @throws SecurityException if the required permissions to read the file,
1:e906df8:      *      or the path it is in, are missing
1:a03ad56:      */
1:a03ad56:     public static FileReader getFileReader(final File file)
1:e906df8:             throws FileNotFoundException {
1:a03ad56:         if (file == null) {
1:a03ad56:             throw new IllegalArgumentException("file cannot be <null>");
1:a03ad56:         }
1:a03ad56:         try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<FileReader>() {
1:2510115:                         public FileReader run()
1:a03ad56:                                 throws FileNotFoundException {
1:a03ad56:                             return new FileReader(file);
1:a03ad56:                         }
1:a03ad56:                     });
1:a03ad56:         } catch (PrivilegedActionException pae) {
1:0dfad31:             throw (FileNotFoundException)pae.getCause();
1:0dfad31:         }
1:0dfad31:     }
1:0dfad31: 
1:0dfad31:     /**
1:e4e2bfd:      * Obtains a writer for the specified file.
1:e4e2bfd:      *
1:e4e2bfd:      * @param file the file to obtain a writer for
1:e4e2bfd:      * @return An writer for the specified file.
1:e4e2bfd:      * @throws IOException if the file cannot be opened
1:e4e2bfd:      * @throws SecurityException if the required permissions to write to the file,
1:e4e2bfd:      *      or the path it is in, are missing
1:e4e2bfd:      */
1:e4e2bfd:     public static FileWriter getFileWriter(final File file)
1:e4e2bfd:             throws IOException {
1:e4e2bfd:         if (file == null) {
1:e4e2bfd:             throw new IllegalArgumentException("file cannot be <null>");
1:a03ad56:         }
1:e4e2bfd:         try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<FileWriter>() {
1:2510115:                         public FileWriter run()
1:e4e2bfd:                                 throws IOException {
1:e4e2bfd:                             return new FileWriter(file);
1:a03ad56:                         }
1:e4e2bfd:                     });
1:e4e2bfd:         } catch (PrivilegedActionException pae) {
1:e4e2bfd:             throw (IOException)pae.getCause();
1:e4e2bfd:         }
1:e4e2bfd:     }
1:c7b3589: 
1:c7b3589:     /**
1:8aa8deb:      * In a priv block, get an array with all the files in a directory.
1:8aa8deb:      * @param dir the directory to scan
1:8aa8deb:      * @return an array of all the files in the directory
1:8aa8deb:      * @see java.io.File#listFiles()
1:8aa8deb:      */
1:8aa8deb:     public static File[] listFiles(File dir) {
1:8aa8deb:         return AccessController.doPrivileged(
1:8aa8deb:                 (PrivilegedAction<File[]>) () -> dir.listFiles());
1:8aa8deb:     }
1:c7b3589:     
1:d773139:     /**
1:d773139:      * In a priv block, do a recursive copy from source to target.  
1:d773139:      * If target exists it will be overwritten. Parent directory for 
1:d773139:      * target will be created if it does not exist. 
1:d773139:      * If source does not exist this will be a noop.
1:d773139:      * 
1:d773139:      * @param source  Source file or directory to copy
1:840ed3f:      * @param target  Target file or directory to copy to
1:e4e2bfd:      * @throws IOException
1:d773139:      * @throws SecurityException
1:d773139:      */    
1:d773139:     public static void copy(final File source, final File target) throws IOException {
1:d773139:         try {
1:2510115:             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
1:2510115:                 public Void run() throws IOException {
1:d773139:                     recursiveCopy(source,target);
1:d773139:                     return null;
1:e4e2bfd:                 }
1:d773139:                 });
1:d773139:         } catch (PrivilegedActionException pae) {
1:d773139:             throw (IOException) pae.getException();
1:e4e2bfd:         
1:e4e2bfd:         }
1:d773139:         
1:d773139:     }
1:d773139:     /**
1:d773139:      * Do a recursive copy from source to target.  If target exists it will 
1:d773139:      * be overwritten. Parent directory for target will be created if it does
1:d773139:      * not exist. If source does not exist this will be a noop.
1:d773139:      * 
1:d773139:      * @param source  Source file or directory to copy
2:d773139:      * @param target  Target file or directory to copy
3:d773139:      * @throws IOException
2:d773139:      * @throws FileNotFoundException
1:d773139:      */
1:c7b3589:     private static void  recursiveCopy(File source, File target)
1:c7b3589:             throws IOException {
1:d773139:     
1:c7b3589:         // Share the copy buffer between all copy operations.
1:c7b3589:         byte[] buf = new byte[32*1024];
1:d773139:         if (source.isFile()) {
1:c7b3589:             copySingleFile(source, target, buf);
1:d773139:             return;
1:d773139:         }
1:d773139:             
1:d773139:         String[] list = source.list();
1:d773139: 
1:d773139:         // Some JVMs return null for File.list() when the
1:d773139:         // directory is empty.
1:d773139:         if (list != null) {
1:d773139:             for (int i = 0; i < list.length; i++) {
1:d773139:                 File entry = new File(source, list[i]);
1:d773139:                 File targetEntry = new File(target, list[i]);
1:d773139:                 if (entry.isDirectory()) {
1:d773139:                     copy(entry,targetEntry);
1:d773139:                 } else {
1:c7b3589:                     copySingleFile(entry, targetEntry, buf);
1:d773139:                 }
1:d773139:             }
1:d773139:         }
1:d773139:     }
1:d773139: 
1:d773139:     /**
1:d773139:      * Copy a single file from source to target.  If target exists it will be 
1:d773139:      * overwritten.  If source does not exist, this will be a noop.
1:d773139:      * 
1:d773139:      * @param source  Source file to copy
1:d773139:      * @param target  Destination file for copy
1:c7b3589:      * @param buf buffer used for copy (may be {@code null})
1:c7b3589:      * @throws IOException if accessing the specified files fail
1:c7b3589:      * @throws FileNotFoundException if a specified file doesn't exist
1:d773139:      */
1:c7b3589:     private static void copySingleFile (File source, File target, byte[] buf)
1:c7b3589:             throws IOException {
1:d773139: 
1:c7b3589:         // Create a default buffer if necessary.
1:c7b3589:         if (buf == null) {
1:c7b3589:             buf = new byte[32 * 1024];
1:c7b3589:         }
1:d773139:         File targetParent = target.getParentFile();
1:d773139:         if (targetParent != null && ! targetParent.exists())
1:d773139:             target.getParentFile().mkdirs();
1:d773139:         
1:d773139:                 
1:d773139:         InputStream in = new FileInputStream(source);
1:d773139:         OutputStream out = new FileOutputStream(target);
1:c7b3589: 
1:c7b3589:         try {
1:c7b3589:             for (;;) {
1:c7b3589:                 int read = in.read(buf);
1:c7b3589:                 if (read == -1)
1:c7b3589:                     break;
1:c7b3589:                 out.write(buf, 0, read);
1:c7b3589:             }
1:c7b3589:         } finally {
1:c7b3589:             in.close();
1:c7b3589:             out.close();
1:d773139:         }
1:d773139:     }
1:d773139:     
1:d773139: 
1:c58f84b:     /**
1:c33b0cf:      * Returns a file output stream for the specified file.
1:fe7db0f:      * <p>
1:fe7db0f:      * If the file already exists and is writable, it will be overwritten.
1:c58f84b:      *
1:c33b0cf:      * @param file the file to create a stream for
1:c33b0cf:      * @return An output stream.
1:c33b0cf:      * @throws FileNotFoundException if the specified file does not exist
1:c33b0cf:      * @throws SecurityException if the required permissions to write the file,
1:c33b0cf:      *      or the path it is in, are missing
1:ea9b68b:      */
1:c33b0cf:     public static FileOutputStream getFileOutputStream(final File file)
1:a03ad56:             throws FileNotFoundException {
1:fe7db0f:         return getFileOutputStream(file, false);
1:fe7db0f:     }
1:fe7db0f: 
1:fe7db0f:     /**
1:fe7db0f:      * Returns a file output stream for the specified file.
1:fe7db0f:      *
1:fe7db0f:      * @param file the file to create a stream for
1:fe7db0f:      * @param append whether to append or overwrite an existing file
1:fe7db0f:      * @return An output stream.
1:fe7db0f:      * @throws FileNotFoundException if the specified file does not exist
1:fe7db0f:      * @throws SecurityException if the required permissions to write the file,
1:fe7db0f:      *      or the path it is in, are missing
1:fe7db0f:      */
1:fe7db0f:     public static FileOutputStream getFileOutputStream(final File file,
1:fe7db0f:                                                        final boolean append)
1:fe7db0f:             throws FileNotFoundException {
1:c33b0cf:         if (file == null) {
1:c58f84b:             throw new IllegalArgumentException("file cannot be <null>");
1:ea9b68b:         }
1:ea9b68b:         try {
1:4394bdd:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<FileOutputStream>() {
1:2510115:                         public FileOutputStream run()
2:c33b0cf:                                 throws FileNotFoundException {
1:fe7db0f:                             return new FileOutputStream(file, append);
1:ea9b68b:                         }
1:c33b0cf:                     });
1:ea9b68b:         } catch (PrivilegedActionException pae) {
1:a03ad56:             throw (FileNotFoundException)pae.getCause();
1:ea9b68b:         }
1:c58f84b:     }
1:d773139: 
1:c58f84b:     /**
1:c7b3589:      * Tries to delete all the files, including the specified directory, in the
1:c7b3589:      * directory tree with the specified root.
1:c7b3589:      * <p>
1:c7b3589:      * If deleting one of the files fail, it will be recorded and the method
1:c7b3589:      * will move on to the remaining files and try to delete them.
1:c7b3589:      *
1:c7b3589:      * @param dir the directory to delete (including subdirectories)
1:c7b3589:      * @return A list of files which couldn't be deleted (may be empty).
1:a0f4b68:      * @see org.apache.derbyTesting.junit.BaseTestCase#assertDirectoryDeleted
1:c7b3589:      */
1:c7b3589:     public static File[] persistentRecursiveDelete(final File dir)
1:c7b3589:             throws FileNotFoundException {
1:c7b3589:         // Fail if the directory doesn't exist.
1:c7b3589:         if (!exists(dir)) {
1:c7b3589:             throw new FileNotFoundException(getAbsolutePath(dir));
1:c7b3589:         }
1:2510115:         final ArrayList<File> notDeleted = new ArrayList<File>();
1:2510115:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:2510115:             public Void run() {
1:2510115:                 deleteRecursively(dir, notDeleted);
1:2510115:                 return null;
1:c7b3589:             }
1:c7b3589:         });
1:c7b3589: 
1:2510115:         return notDeleted.toArray(new File[notDeleted.size()]);
1:c7b3589:     }
1:c7b3589: 
1:c7b3589:     /**
1:c7b3589:      * Deletes the specified directory and all its files and subdirectories.
1:c7b3589:      * <p>
1:c7b3589:      * An attempt is made to delete all files, even if one of the delete
1:c7b3589:      * operations fail.
1:c7b3589:      *
1:c7b3589:      * @param dir the root directory to start deleting from
1:c7b3589:      * @param failedDeletes a list of failed deletes (if any)
1:c7b3589:      * @return {@code true} is all delete operations succeeded, {@code false}
1:c7b3589:      *      otherwise.
1:c7b3589:      */
1:2510115:     private static boolean deleteRecursively(File dir, List<File> failedDeletes) {
1:c7b3589:         boolean allDeleted = true;
1:c7b3589:         if (dir.isDirectory()) {
1:c7b3589:             File[] files = dir.listFiles();
1:c7b3589:             if (files != null) {
1:c7b3589:                 for (int i=0; i < files.length; i++) {
1:c7b3589:                     File f = files[i];
1:c7b3589:                     if (f.isDirectory()) {
1:c7b3589:                         allDeleted &= deleteRecursively(f, failedDeletes);
1:c7b3589:                     } else {
1:c7b3589:                         allDeleted &= internalDelete(f, failedDeletes);
1:c7b3589:                     }
1:c7b3589:                 }
1:c7b3589:             }
1:c7b3589:         }
1:c7b3589:         allDeleted &= internalDelete(dir, failedDeletes);
1:c7b3589:         return allDeleted;
1:c7b3589:     }
1:c7b3589: 
1:c7b3589:     /**
1:c7b3589:      * Attempts to delete the specified file, will add it to the passed in list
1:c7b3589:      * if the delete fails.
1:c7b3589:      *
1:c7b3589:      * @param f file to delete
1:c7b3589:      * @param failedDeletes list keeping track of failed deletes
1:c7b3589:      * @return {@code true} if the delete succeeded, {@code false} otherwise.
1:c7b3589:      */
1:2510115:     private static boolean internalDelete(File f, List<File> failedDeletes) {
1:c7b3589:         boolean deleted = f.delete();
1:c7b3589:         if (!deleted) {
1:c7b3589:             failedDeletes.add(f);
1:c7b3589:         }
1:c7b3589:         return deleted;
1:c7b3589:     }
1:c7b3589: 
1:c7b3589:     /**
1:c7b3589:      * Obtains information about the specified file.
1:c7b3589:      *
1:0dfad31:      * @param f the file
1:c7b3589:      * @return A string with file information (human-readable).
1:c7b3589:      */
1:c7b3589:     public static String getFileInfo(final File f) {
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:2510115:             public String run() {
1:c7b3589:                 if (!f.exists()) {
1:c7b3589:                     return "(non-existant)";
1:c7b3589:                 }
1:2510115:                 StringBuilder sb = new StringBuilder();
1:c7b3589:                 sb.append("(isDir=").append(f.isDirectory()).
1:c7b3589:                         append(", canRead=").append(f.canRead()).
1:c7b3589:                         append(", canWrite=").append(f.canWrite()).
1:c7b3589:                         append(", size=").append(f.length()).append(')');
1:c7b3589:                 return sb.toString();
1:c7b3589:             }
1:c7b3589:         });
1:c7b3589:     }
1:c7b3589:     
1:d773139: 
1:c58f84b:  }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8aa8deb
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * In a priv block, get an array with all the files in a directory.
1:      * @param dir the directory to scan
1:      * @return an array of all the files in the directory
1:      * @see java.io.File#listFiles()
1:      */
1:     public static File[] listFiles(File dir) {
1:         return AccessController.doPrivileged(
1:                 (PrivilegedAction<File[]>) () -> dir.listFiles());
1:     }
commit:2d7d37f
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a temporary file.
1:      *
1:      * @param prefix file name prefix, at least three characters
1:      * @param suffix file name suffix, defaults to ".tmp" if {@code null}
1:      * @param directory where to create the file, or {@code null} for the
1:      *   default temporary file directory
1:      * @return the file that was created
1:      * @throws IOException if the file cannot be created
1:      * @see File#createTempFile(String, String, File)
1:      */
1:     public static File createTempFile(final String prefix,
1:                                       final String suffix,
1:                                       final File directory)
1:             throws IOException
1:     {
1:         try {
1:             return AccessController.doPrivileged(
1:                 new PrivilegedExceptionAction<File>() {
1:                     @Override
1:                     public File run() throws IOException {
1:                         return File.createTempFile(prefix, suffix, directory);
1:                     }
1:                 });
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * Make a file or directory read-only.
1:      * @param file the file to make read-only
1:      * @return {@code true} if successful, {@code false} otherwise
1:      */
1:     public static boolean setReadOnly(final File file) {
1:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:             @Override
1:             public Boolean run() {
1:                 return file.setReadOnly();
1:             }
1:         });
1:     }
1: 
1:     /**
commit:d32b042
/////////////////////////////////////////////////////////////////////////
1:      * Create a directory.
1:      * @param dir the directory to create
1:      * @return {@code true} if and only if the directory was created
1:      */
1:     public static boolean mkdir(final File dir) {
1:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:             public Boolean run() {
1:                 return dir.mkdir();
1:             }
1:         });
1:     }
1: 
1:     /**
1:      * Set the read permission for a file.
1:      * @param file      the file to set the read permission for
1:      * @param readable  {@code true} to allow read, {@code false} to deny it
1:      * @param ownerOnly {@code true} if it should be set for the owner only,
1:      *                  {@code false} if it should be set for everyone
1:      * @return {@code true} if the operation succeeded, {@code false} otherwise
1:      */
1:     public static boolean setReadable(final File file,
1:                                       final boolean readable,
1:                                       final boolean ownerOnly) {
1:         return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
1:             public Boolean run() {
1:                 return file.setReadable(readable, ownerOnly);
1:             }
1:         });
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:                     new PrivilegedAction<Long>() {
1:                         public Long run() {
1:                             return file.length();
1:                     });
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:                 new PrivilegedAction<String>() {
1:                     public String run() throws SecurityException {
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileInputStream>() {
1:                 public FileInputStream run() throws FileNotFoundException {
1:                     return new FileInputStream(file);
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:                     new PrivilegedAction<Boolean>() {
1:                         public Boolean run() {
1:                             return file.exists();
1:                     });
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:                     new PrivilegedAction<Boolean>() {
1:                         public Boolean run() {
1:                             return file.delete();
1:                     });
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileReader>() {
1:                         public FileReader run()
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileWriter>() {
1:                         public FileWriter run()
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileOutputStream>() {
1:                         public FileOutputStream run()
/////////////////////////////////////////////////////////////////////////
1:         final ArrayList<File> notDeleted = new ArrayList<File>();
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
1:                 deleteRecursively(dir, notDeleted);
1:                 return null;
1:         return notDeleted.toArray(new File[notDeleted.size()]);
/////////////////////////////////////////////////////////////////////////
1:     private static boolean deleteRecursively(File dir, List<File> failedDeletes) {
/////////////////////////////////////////////////////////////////////////
1:     private static boolean internalDelete(File f, List<File> failedDeletes) {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:             public String run() {
1:                 StringBuilder sb = new StringBuilder();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4394bdd
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
/////////////////////////////////////////////////////////////////////////
1:      * Get the URI for a file.
1:      *
1:      * @param file File to be queried
1:      * @return Its URI
1:      * @throws SecurityException if the test lacks the required permissions to access the file,
1:      *      
1:      * @see File#getAbsolutePath
1:      */
1:     public static URI toURI(final File file)
1:             throws SecurityException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
1:         return AccessController.doPrivileged(
1:                 new PrivilegedAction<URI>() {
1:                     public URI run() throws SecurityException {
1:                         return file.toURI();
1:                     }});
1:     }
1: 
1:     /**
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ce0c0ae
/////////////////////////////////////////////////////////////////////////
commit:0dfad31
/////////////////////////////////////////////////////////////////////////
0:      * Checks if the specified file is empty.
1:      *
1:      * @param f the file
0:      * @return true if the file is empty
1:      */
0:     public static boolean isFileEmpty(final File f) 
1:             throws FileNotFoundException {
0:         if (f == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
1:         try {
0:             return((Boolean)AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     FileInputStream fis = new FileInputStream(f);
0:                     int result = fis.read();
0:                     fis.close();
0:                     if(result == -1)
0:                         return Boolean.valueOf(true);
0:                     else
0:                         return Boolean.valueOf(false);
1:                 }
0:             })).booleanValue();
1:         } catch (PrivilegedActionException pae) {
1:             throw (FileNotFoundException)pae.getCause();
1:         }
1:     }
1: 
1:     /**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a0f4b68
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.derbyTesting.junit.BaseTestCase#assertDirectoryDeleted
commit:840ed3f
/////////////////////////////////////////////////////////////////////////
1:      * @param target  Target file or directory to copy to
commit:c7b3589
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:                             return Boolean.valueOf(file.exists());
/////////////////////////////////////////////////////////////////////////
1:     private static void  recursiveCopy(File source, File target)
1:             throws IOException {
1:         // Share the copy buffer between all copy operations.
1:         byte[] buf = new byte[32*1024];
1:             copySingleFile(source, target, buf);
/////////////////////////////////////////////////////////////////////////
1:                     copySingleFile(entry, targetEntry, buf);
/////////////////////////////////////////////////////////////////////////
1:      * @param buf buffer used for copy (may be {@code null})
1:      * @throws IOException if accessing the specified files fail
1:      * @throws FileNotFoundException if a specified file doesn't exist
1:     private static void copySingleFile (File source, File target, byte[] buf)
1:             throws IOException {
1:         // Create a default buffer if necessary.
1:         if (buf == null) {
1:             buf = new byte[32 * 1024];
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         try {
1:             for (;;) {
1:                 int read = in.read(buf);
1:                 if (read == -1)
1:                     break;
1:                 out.write(buf, 0, read);
1:             }
1:         } finally {
1:             in.close();
1:             out.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tries to delete all the files, including the specified directory, in the
1:      * directory tree with the specified root.
1:      * <p>
1:      * If deleting one of the files fail, it will be recorded and the method
1:      * will move on to the remaining files and try to delete them.
1:      *
1:      * @param dir the directory to delete (including subdirectories)
1:      * @return A list of files which couldn't be deleted (may be empty).
0:      * @see org.apache.derbyTesting.junit.BaseJDBCTestCase#assertDirectoryDeleted
1:      */
1:     public static File[] persistentRecursiveDelete(final File dir)
1:             throws FileNotFoundException {
1:         // Fail if the directory doesn't exist.
1:         if (!exists(dir)) {
1:             throw new FileNotFoundException(getAbsolutePath(dir));
1:         }
0:         final ArrayList notDeleted = new ArrayList();
0:         AccessController.doPrivileged(new PrivilegedAction() {
1: 
0:             public Object run() {
0:                 return Boolean.valueOf(deleteRecursively(dir, notDeleted));
1:             }
1:         });
1: 
0:         File[] failedDeletes = new File[notDeleted.size()];
0:         notDeleted.toArray(failedDeletes);
0:         return failedDeletes;
1:     }
1: 
1:     /**
1:      * Deletes the specified directory and all its files and subdirectories.
1:      * <p>
1:      * An attempt is made to delete all files, even if one of the delete
1:      * operations fail.
1:      *
1:      * @param dir the root directory to start deleting from
1:      * @param failedDeletes a list of failed deletes (if any)
1:      * @return {@code true} is all delete operations succeeded, {@code false}
1:      *      otherwise.
1:      */
0:     private static boolean deleteRecursively(File dir, List failedDeletes) {
1:         boolean allDeleted = true;
1:         if (dir.isDirectory()) {
1:             File[] files = dir.listFiles();
1:             if (files != null) {
1:                 for (int i=0; i < files.length; i++) {
1:                     File f = files[i];
1:                     if (f.isDirectory()) {
1:                         allDeleted &= deleteRecursively(f, failedDeletes);
1:                     } else {
1:                         allDeleted &= internalDelete(f, failedDeletes);
1:                     }
1:                 }
1:             }
1:         }
1:         allDeleted &= internalDelete(dir, failedDeletes);
1:         return allDeleted;
1:     }
1: 
1:     /**
1:      * Attempts to delete the specified file, will add it to the passed in list
1:      * if the delete fails.
1:      *
1:      * @param f file to delete
1:      * @param failedDeletes list keeping track of failed deletes
1:      * @return {@code true} if the delete succeeded, {@code false} otherwise.
1:      */
0:     private static boolean internalDelete(File f, List failedDeletes) {
1:         boolean deleted = f.delete();
1:         if (!deleted) {
1:             failedDeletes.add(f);
1:         }
1:         return deleted;
1:     }
1: 
1:     /**
1:      * Obtains information about the specified file.
1:      *
0:      * @param f the file
1:      * @return A string with file information (human-readable).
1:      */
1:     public static String getFileInfo(final File f) {
0:         return (String)AccessController.doPrivileged(new PrivilegedAction() {
1: 
0:             public Object run() {
1:                 if (!f.exists()) {
1:                     return "(non-existant)";
1:                 }
0:                 StringBuffer sb = new StringBuffer();
1:                 sb.append("(isDir=").append(f.isDirectory()).
1:                         append(", canRead=").append(f.canRead()).
1:                         append(", canWrite=").append(f.canWrite()).
1:                         append(", size=").append(f.length()).append(')');
1:                 return sb.toString();
1:             }
1:         });
1:     }
commit:fe7db0f
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * If the file already exists and is writable, it will be overwritten.
/////////////////////////////////////////////////////////////////////////
1:         return getFileOutputStream(file, false);
1:     }
1: 
1:     /**
1:      * Returns a file output stream for the specified file.
1:      *
1:      * @param file the file to create a stream for
1:      * @param append whether to append or overwrite an existing file
1:      * @return An output stream.
1:      * @throws FileNotFoundException if the specified file does not exist
1:      * @throws SecurityException if the required permissions to write the file,
1:      *      or the path it is in, are missing
1:      */
1:     public static FileOutputStream getFileOutputStream(final File file,
1:                                                        final boolean append)
1:             throws FileNotFoundException {
/////////////////////////////////////////////////////////////////////////
1:                             return new FileOutputStream(file, append);
commit:e906df8
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1:  * A set of operations on {@link java.io.File} that wraps the
/////////////////////////////////////////////////////////////////////////
1: 
1:      * @return Byte length of the file.
/////////////////////////////////////////////////////////////////////////
0:         return ((Long)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
0:                             return new Long(file.length());
1:                         }
0:                     })).longValue();
1: 
1:     /**
1:      * Returns a input stream for the specified file.
1:      *
1:      * @param file the file to open a stream for
1:      * @return A input stream reading from the specified file.
1:      * @throws SecurityException if the required permissions to read the file,
1:      *      or the path it is in, are missing
1:      * @throws FileNotFoundException if the specified file does not exist
1:      */
1:             throws FileNotFoundException {
0:                             public Object run() throws FileNotFoundException {
1:             throw (FileNotFoundException)pae.getException();
1:      * @return {@code true} if file exists, {@code false} otherwise
/////////////////////////////////////////////////////////////////////////
0:         return ((Boolean)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
0:                             return new Boolean(file.exists());
1:                         }
0:                     })).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:      * @throws SecurityException if the required permissions to read the file,
1:      *      or the path it is in, are missing
commit:a03ad56
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileReader;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Obtains a reader for the specified file.
1:      *
1:      * @param file the file to obtain a reader for
1:      * @return An unbuffered reader for the specified file.
1:      * @throws FileNotFoundException if the specified file does not exist
0:      * @throws SecurityException if the required privileges to read the file
0:      *      are missing
1:      */
1:     public static FileReader getFileReader(final File file)
1:             throws FileNotFoundException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
1:         try {
0:             return (FileReader)AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                         public Object run()
1:                                 throws FileNotFoundException {
1:                             return new FileReader(file);
1:                         }
1:                     });
1:         } catch (PrivilegedActionException pae) {
1:             throw (FileNotFoundException)pae.getCause();
1:         }
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e4e2bfd
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileWriter;
/////////////////////////////////////////////////////////////////////////
1:      * Delete a file
1:      *
1:      * @return {@code true} if file was deleted, {@code false} otherwise
1:      * @throws SecurityException if the required permissions to read the file,
1:      *      or the path it is in, are missing
1:      * @see File#delete
1:      */
1:     public static boolean delete(final File file)
1:             throws SecurityException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
0:         return ((Boolean)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
0:                             return Boolean.valueOf(file.delete());
1:                         }
0:                     })).booleanValue();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Obtains a writer for the specified file.
1:      *
1:      * @param file the file to obtain a writer for
1:      * @return An writer for the specified file.
1:      * @throws IOException 
1:      * @throws IOException if the file cannot be opened
1:      * @throws SecurityException if the required permissions to write to the file,
1:      *      or the path it is in, are missing
1:      */
1:     public static FileWriter getFileWriter(final File file)
1:             throws IOException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
1:         try {
0:             return (FileWriter)AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                         public Object run()
1:                                 throws IOException {
1:                             return new FileWriter(file);
1:                         }
1:                     });
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException)pae.getCause();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:  }
commit:d773139
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
0: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:      * Get the absolute path
1:      *
1:      * @param file File for absolute path
1:      * @return Absolute path of the file.
1:      * @throws SecurityException if the required permissions to access the file,
1:      *      
1:      * @see File#getAbsolutePath
1:      */
1:     public static String getAbsolutePath(final File file)
1:             throws SecurityException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
0:         return (String)AccessController.doPrivileged(
0:                 new PrivilegedAction() {
0:                     public Object run() throws SecurityException {
1:                         return file.getAbsolutePath();
1:                     }});
1:     }
1:       
1:     
1:     
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * In a priv block, do a recursive copy from source to target.  
1:      * If target exists it will be overwritten. Parent directory for 
1:      * target will be created if it does not exist. 
1:      * If source does not exist this will be a noop.
1:      * 
1:      * @param source  Source file or directory to copy
1:      * @param target  Target file or directory to copy
1:      * @throws IOException
1:      * @throws SecurityException
1:      */    
1:     public static void copy(final File source, final File target) throws IOException {
1:         try {
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
1:                     recursiveCopy(source,target);
1:                     return null;
1:                 }
1:                 });
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getException();
1:         
1:         }
1:         
1:     }
1:     /**
1:      * Do a recursive copy from source to target.  If target exists it will 
1:      * be overwritten. Parent directory for target will be created if it does
1:      * not exist. If source does not exist this will be a noop.
1:      * 
1:      * @param source  Source file or directory to copy
1:      * @param target  Target file or directory to copy
1:      * @throws IOException
1:      * @throws FileNotFoundException
1:      */
0:     private static void  recursiveCopy(File source, File target) throws IOException, FileNotFoundException{
1:     
1:         if (source.isFile()) {
0:             copySingleFile(source,target);
1:             return;
1:         }
1:             
1:         String[] list = source.list();
1: 
1:         // Some JVMs return null for File.list() when the
1:         // directory is empty.
1:         if (list != null) {
1:             for (int i = 0; i < list.length; i++) {
1:                 File entry = new File(source, list[i]);
1:                 File targetEntry = new File(target, list[i]);
1:                 if (entry.isDirectory()) {
1:                     copy(entry,targetEntry);
1:                 } else {
0:                     copySingleFile(entry, targetEntry);
1:                 }
1:             }
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Copy a single file from source to target.  If target exists it will be 
1:      * overwritten.  If source does not exist, this will be a noop.
1:      * 
1:      * @param source  Source file to copy
1:      * @param target  Destination file for copy
1:      * @throws IOException
1:      * @throws FileNotFoundException
1:      */
0:     private static void copySingleFile (File source, File target) throws IOException, FileNotFoundException {
1: 
1:         File targetParent = target.getParentFile();
1:         if (targetParent != null && ! targetParent.exists())
1:             target.getParentFile().mkdirs();
1:         
1:                 
1:         InputStream in = new FileInputStream(source);
1:         OutputStream out = new FileOutputStream(target);
0:         byte[] buf = new byte[32 * 1024];
1:         
0:         for (;;) {
0:             int read = in.read(buf);
0:             if (read == -1)
0:                 break;
0:             out.write(buf, 0, read);
1:         }
0:         in.close();
0:         out.close();
1:     }
1:     
1: 
commit:ea9b68b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if the file exists.
1:      *
0:      * @return <code>true</code> if file exists, <code>false</code> otherwise
1:      * @throws SecurityException if the required permissions to read the file,
1:      *      or the path it is in, are missing
1:      * @see File#exists
1:      */
1:     public static boolean exists(final File file)
1:             throws SecurityException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
1:         try {
0:             return ((Boolean)AccessController.doPrivileged(
0:                         new PrivilegedExceptionAction() {
0:                             public Object run() throws SecurityException {
0:                                 return new Boolean(file.exists());
1:                             }
0:                         })).booleanValue();
1:         } catch (PrivilegedActionException pae) {
0:             throw (SecurityException)pae.getException();
1:         }
1:     }
commit:c58f84b
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsorTests
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: 
1: /**
0:  * A set of operations on {$@link java.io.File} that wraps the
1:  * operations in privileged block of code. This class is intended to provide
1:  * these methods for testcases to reduce the hassle of having to wrap file
1:  * operations in privileged code blocks.
1:  * <p>
1:  * Derby needs to use privileged blocks in some places to avoid
1:  * {@link SecurityException}s being thrown, as the required privileges are
1:  * often granted to Derby itself, but not the higher level application code.
1:  * <p>
1:  */
1: public class PrivilegedFileOpsForTests {
1: 	
1: 	/**
1:      * Get the file length.
1:      *
0:      * @return byte length of the file.
1:      * @throws SecurityException if the required permissions to read the file,
1:      *      or the path it is in, are missing
1:      * @see File#length
1:      */
1:     public static long length(final File file)
1:             throws SecurityException {
1:         if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
0:         try {
0:             return ((Long)AccessController.doPrivileged(
0:                         new PrivilegedExceptionAction() {
0:                             public Object run() throws SecurityException {
0:                                 return new Long(file.length());
1:                             }
0:                         })).longValue();
0:         } catch (PrivilegedActionException pae) {
0:             throw (SecurityException)pae.getException();
1:         }
1:     }
1:     
1:     public static FileInputStream getFileInputStream(final File file) 
0:     	throws SecurityException, FileNotFoundException {
1:     	if (file == null) {
1:             throw new IllegalArgumentException("file cannot be <null>");
1:         }
0:         try {
0:             return ((FileInputStream)AccessController.doPrivileged(
0:                         new PrivilegedExceptionAction() {
0:                             public Object run() throws SecurityException, FileNotFoundException {
0:                                 return new FileInputStream(file);
1:                             }
0:                         }));
0:         } catch (PrivilegedActionException pae) {
0:             throw (SecurityException)pae.getException();
1:         }
1:     }
1: 
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:c33b0cf
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileOutputStream;
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Returns a file output stream for the specified file.
0:      *
1:      * @param file the file to create a stream for
1:      * @return An output stream.
1:      * @throws FileNotFoundException if the specified file does not exist
1:      * @throws SecurityException if the required permissions to write the file,
1:      *      or the path it is in, are missing
0:      */
1:     public static FileOutputStream getFileOutputStream(final File file)
1:             throws FileNotFoundException {
1:         if (file == null) {
0:             throw new IllegalArgumentException("file cannot be <null>");
0:         }
0:         try {
0:             return (FileOutputStream)AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                         public Object run()
1:                                 throws FileNotFoundException {
0:                             return new FileOutputStream(file);
0:                         }
1:                     });
0:         } catch (PrivilegedActionException pae) {
0:             throw (FileNotFoundException)pae.getCause();
0:         }
0:     }
============================================================================