1:eac0369: /*
13:eac0369: 
1:345de35:  Derby - Class org.apache.derby.impl.sql.compile.ConcatenationOperatorNode
1:345de35: 
1:7c5fbc4:  Licensed to the Apache Software Foundation (ASF) under one or more
1:7c5fbc4:  contributor license agreements.  See the NOTICE file distributed with
1:7c5fbc4:  this work for additional information regarding copyright ownership.
1:7c5fbc4:  The ASF licenses this file to you under the Apache License, Version 2.0
1:7c5fbc4:  (the "License"); you may not use this file except in compliance with
1:7c5fbc4:  the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:  http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:  Unless required by applicable law or agreed to in writing, software
1:345de35:  distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:  See the License for the specific language governing permissions and
1:345de35:  limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:7c5fbc4: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.sql.Types;
1:3bb140c: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.StringDataValue;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This node represents a concatenation comparison operator
1:eac0369:  * 
1:7c5fbc4:  * varying.
1:eac0369:  */
1:eac0369: 
1:3bb140c: class ConcatenationOperatorNode extends BinaryOperatorNode {
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ConcatenationOperatorNode
1:eac0369: 	 * 
1:7c5fbc4: 	 * @param leftOperand
1:7c5fbc4: 	 *            The left operand of the concatenation
1:7c5fbc4: 	 * @param rightOperand
1:7c5fbc4: 	 *            The right operand of the concatenation
1:3bb140c:      * @param cm  The context manager
1:eac0369: 	 */
1:3bb140c:     ConcatenationOperatorNode(
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             ContextManager cm) {
1:3bb140c:         super(leftOperand,
1:3bb140c:               rightOperand,
1:3bb140c:               "||",
1:3bb140c:               "concatenate",
1:3bb140c:               ClassName.ConcatableDataValue,
1:3bb140c:               ClassName.ConcatableDataValue,
1:3bb140c:               cm);
1:eac0369: 	}
1:eac0369: 
1:1998441:     /**
1:1998441:      * Check if this node always evaluates to the same value. If so, return
1:1998441:      * a constant node representing the known result.
1:1998441:      *
1:1998441:      * @return a constant node representing the result of this concatenation
1:1998441:      * operation, or {@code this} if the result is not known up front
1:1998441:      */
1:3bb140c:     @Override
1:1998441:     ValueNode evaluateConstantExpressions() throws StandardException {
1:1998441:         if (leftOperand instanceof CharConstantNode &&
1:1998441:                 rightOperand instanceof CharConstantNode) {
1:1998441:             CharConstantNode leftOp = (CharConstantNode) leftOperand;
1:1998441:             CharConstantNode rightOp = (CharConstantNode) rightOperand;
1:1998441:             StringDataValue leftValue = (StringDataValue) leftOp.getValue();
1:1998441:             StringDataValue rightValue = (StringDataValue) rightOp.getValue();
1:1998441: 
1:1998441:             StringDataValue resultValue =
1:1998441:                     (StringDataValue) getTypeServices().getNull();
1:1998441:             resultValue.concatenate(leftValue, rightValue, resultValue);
1:1998441: 
1:3bb140c:             return new CharConstantNode(
1:3bb140c:                 resultValue.getString(), getContextManager());
1:1998441:         }
1:1998441: 
1:1998441:         return this;
1:1998441:     }
1:1998441: 
1:eac0369: 	/**
1:7c5fbc4: 	 * overrides BindOperatorNode.bindExpression because concatenation has
1:7c5fbc4: 	 * special requirements for parameter binding.
1:eac0369: 	 * 
1:7c5fbc4: 	 * @exception StandardException
1:7c5fbc4: 	 *                thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:71c8e86:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:7c5fbc4: 			throws StandardException {
1:eac0369: 		// deal with binding operands
1:eac0369: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList,
1:09c2697:                 aggregates);
1:eac0369: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList,
1:09c2697:                 aggregates);
1:eac0369: 
1:eac0369: 		// deal with operand parameters
1:eac0369: 		/*
1:7c5fbc4: 		 * Is there a ? parameter on the left? If so, it's type is the type of
1:7c5fbc4: 		 * the other parameter, with maximum length for that type.
1:eac0369: 		 */
1:eac0369: 
1:7c5fbc4: 		if (leftOperand.requiresTypeFromContext()) {
1:7c5fbc4: 			if (rightOperand.requiresTypeFromContext()) {
1:7c5fbc4: 				throw StandardException.newException(
1:7c5fbc4: 						SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, operator);
1:eac0369: 			}
1:eac0369: 
1:7c5fbc4: 			TypeId leftType;
1:eac0369: 
1:eac0369: 			/*
1:7c5fbc4: 			 * * A ? on the left gets its type from the right. There are eight *
1:7c5fbc4: 			 * legal types for the concatenation operator: CHAR, VARCHAR, * LONG
1:7c5fbc4: 			 * VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB. * If
1:7c5fbc4: 			 * the right type is BLOB, set the parameter type to BLOB with max
1:7c5fbc4: 			 * length. * If the right type is one of the other bit types, set
1:7c5fbc4: 			 * the parameter type to * BIT VARYING with maximum length. * * If
1:7c5fbc4: 			 * the right type is CLOB, set parameter type to CLOB with max
1:7c5fbc4: 			 * length. * If the right type is anything else, set it to VARCHAR
1:7c5fbc4: 			 * with * maximum length. We count on the resolveConcatOperation
1:7c5fbc4: 			 * method to * catch an illegal type. * * NOTE: When I added the
1:7c5fbc4: 			 * long types, I could have changed the * resulting parameter types
1:7c5fbc4: 			 * to LONG VARCHAR and LONG BIT VARYING, * but they were already
1:7c5fbc4: 			 * VARCHAR and BIT VARYING, and it wasn't * clear to me what effect
1:7c5fbc4: 			 * it would have to change it. - Jeff
1:eac0369: 			 */
1:7c5fbc4: 			if (rightOperand.getTypeId().isBitTypeId()) {
1:8809d55: 				if (rightOperand.getTypeId().isBlobTypeId())
1:8809d55: 					leftType = TypeId.getBuiltInTypeId(Types.BLOB);
1:7c5fbc4: 				else
1:eac0369: 					leftType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1:7c5fbc4: 			} else {
1:8809d55: 				if (rightOperand.getTypeId().isClobTypeId())
1:8809d55: 					leftType = TypeId.getBuiltInTypeId(Types.CLOB);
1:eac0369: 				else
1:eac0369: 					leftType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1:eac0369: 			}
1:eac0369: 
1:244952e: 			leftOperand.setType(new DataTypeDescriptor(leftType, true));
1:7c5fbc4: 			if (rightOperand.getTypeId().isStringTypeId()) {
1:168a4f8: 				//collation of ? operand should be picked from the context
1:b25481f:                 leftOperand.setCollationInfo(rightOperand.getTypeServices());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * Is there a ? parameter on the right?
1:eac0369: 		 */
1:7c5fbc4: 		if (rightOperand.requiresTypeFromContext()) {
1:7c5fbc4: 			TypeId rightType;
1:eac0369: 
1:eac0369: 			/*
1:7c5fbc4: 			 * * A ? on the right gets its type from the left. There are eight *
1:7c5fbc4: 			 * legal types for the concatenation operator: CHAR, VARCHAR, * LONG
1:7c5fbc4: 			 * VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB. * If
1:7c5fbc4: 			 * the left type is BLOB, set the parameter type to BLOB with max
1:7c5fbc4: 			 * length. * If the left type is one of the other bit types, set the
1:7c5fbc4: 			 * parameter type to * BIT VARYING with maximum length. * * If the
1:7c5fbc4: 			 * left type is CLOB, set parameter type to CLOB with max length. *
1:7c5fbc4: 			 * If the left type is anything else, set it to VARCHAR with *
1:7c5fbc4: 			 * maximum length. We count on the resolveConcatOperation method to *
1:7c5fbc4: 			 * catch an illegal type. * * NOTE: When I added the long types, I
1:7c5fbc4: 			 * could have changed the * resulting parameter types to LONG
1:7c5fbc4: 			 * VARCHAR and LONG BIT VARYING, * but they were already VARCHAR and
1:7c5fbc4: 			 * BIT VARYING, and it wasn't * clear to me what effect it would
1:7c5fbc4: 			 * have to change it. - Jeff
1:eac0369: 			 */
1:7c5fbc4: 			if (leftOperand.getTypeId().isBitTypeId()) {
1:8809d55: 				if (leftOperand.getTypeId().isBlobTypeId())
1:8809d55: 					rightType = TypeId.getBuiltInTypeId(Types.BLOB);
1:7c5fbc4: 				else
1:eac0369: 					rightType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1:7c5fbc4: 			} else {
1:8809d55: 				if (leftOperand.getTypeId().isClobTypeId())
1:8809d55: 					rightType = TypeId.getBuiltInTypeId(Types.CLOB);
1:eac0369: 				else
1:eac0369: 					rightType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1:eac0369: 			}
1:7c5fbc4: 			rightOperand.setType(new DataTypeDescriptor(rightType, true));
1:7c5fbc4: 			if (leftOperand.getTypeId().isStringTypeId()) {
1:168a4f8: 				//collation of ? operand should be picked from the context
1:b25481f:                 rightOperand.setCollationInfo(leftOperand.getTypeServices());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
2:7c5fbc4: 		/*
1:7c5fbc4: 		 * If the left operand is not a built-in type, then generate a bound
1:7c5fbc4: 		 * conversion tree to a built-in type.
1:eac0369: 		 */
1:7c5fbc4: 		if (leftOperand.getTypeId().userType()) {
1:eac0369: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1:eac0369: 		}
1:eac0369: 
1:7c5fbc4: 		/*
1:7c5fbc4: 		 * If the right operand is not a built-in type, then generate a bound
1:7c5fbc4: 		 * conversion tree to a built-in type.
1:eac0369: 		 */
1:7c5fbc4: 		if (rightOperand.getTypeId().userType()) {
1:eac0369: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * If either the left or right operands are non-string, non-bit types,
1:eac0369: 		 * then we generate an implicit cast to VARCHAR.
1:eac0369: 		 */
1:eac0369: 		TypeCompiler tc = leftOperand.getTypeCompiler();
1:7c5fbc4: 		if (!(leftOperand.getTypeId().isStringTypeId() || leftOperand
1:7c5fbc4: 				.getTypeId().isBitTypeId())) {
1:d9b6192: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1:d9b6192: 					Types.VARCHAR, true, tc
1:d9b6192: 					.getCastToCharWidth(leftOperand							.getTypeServices()));	
1:9ed7c4d: 
1:3bb140c:             leftOperand = new CastNode(leftOperand, dtd, getContextManager());
1:eac0369: 
1:9ed7c4d: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
1:9ed7c4d: 			// explicit casts per SQL Spec 6.12 (10)			
1:9ed7c4d: 			leftOperand.setCollationUsingCompilationSchema();
1:9ed7c4d: 						
1:eac0369: 			((CastNode) leftOperand).bindCastNodeOnly();
1:eac0369: 		}
1:eac0369: 		tc = rightOperand.getTypeCompiler();
1:7c5fbc4: 		if (!(rightOperand.getTypeId().isStringTypeId() || rightOperand
1:7c5fbc4: 				.getTypeId().isBitTypeId())) {
1:d9b6192: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1:d9b6192: 					Types.VARCHAR, true, tc
1:d9b6192: 							.getCastToCharWidth(rightOperand
1:d9b6192: 									.getTypeServices()));
1:9ed7c4d: 
1:3bb140c:             rightOperand = new CastNode(rightOperand, dtd, getContextManager());
1:eac0369: 			
1:9ed7c4d: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
1:9ed7c4d: 			// explicit casts per SQL Spec 6.12 (10)					
1:9ed7c4d: 			rightOperand.setCollationUsingCompilationSchema();
1:9ed7c4d: 			
1:eac0369: 			((CastNode) rightOperand).bindCastNodeOnly();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Set the result type of this operator based on the operands. * By
1:7c5fbc4: 		 * convention, the left operand gets to decide the result type * of a
1:7c5fbc4: 		 * binary operator.
1:eac0369: 		 */
1:eac0369: 		tc = leftOperand.getTypeCompiler();
1:7c5fbc4: 		setType(resolveConcatOperation(leftOperand.getTypeServices(),
1:eac0369: 				rightOperand.getTypeServices()));
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Make sure the maximum width set for the result doesn't exceed the
1:7c5fbc4: 		 * result type's maximum width
1:eac0369: 		 */
1:7c5fbc4: 		if (SanityManager.DEBUG) {
1:7c5fbc4: 			if (getTypeServices().getMaximumWidth() > getTypeId()
1:7c5fbc4: 					.getMaximumMaximumWidth()) {
1:7c5fbc4: 				SanityManager
1:7c5fbc4: 						.THROWASSERT("The maximum length "
1:7c5fbc4: 								+ getTypeServices().getMaximumWidth()
1:7c5fbc4: 								+ " for the result type "
1:7c5fbc4: 								+ getTypeId().getSQLTypeName()
1:7c5fbc4: 								+ " can't be greater than it's maximum width of result's typeid"
1:7c5fbc4: 								+ getTypeId().getMaximumMaximumWidth());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Now that we know the target interface type, set it. This assumes *
1:7c5fbc4: 		 * that both operands have the same interface type, which is a safe *
1:7c5fbc4: 		 * assumption for the concatenation operator.
1:eac0369: 		 */
1:eac0369: 		this.setLeftRightInterfaceType(tc.interfaceName());
1:eac0369: 
1:1998441:         // Finally, fold constants so that for example LIKE optimization is
1:1998441:         // able to take advantage of concatenated literals like 'ab' || '%'.
1:1998441:         return this.evaluateConstantExpressions();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Resolve a concatenation operator
1:eac0369: 	 * 
1:7c5fbc4: 	 * @param leftType
1:7c5fbc4: 	 *            The DataTypeDescriptor of the left operand
1:7c5fbc4: 	 * @param rightType
1:7c5fbc4: 	 *            The DataTypeDescriptor of the right operand
1:eac0369: 	 * 
1:7c5fbc4: 	 * @return A DataTypeDescriptor telling the result type of the concatenate
1:7c5fbc4: 	 *         operation
1:eac0369: 	 * 
1:7c5fbc4: 	 * @exception StandardException
1:7c5fbc4: 	 *                BinaryOperatorNotSupported Thrown when a BinaryOperator is
1:7c5fbc4: 	 *                not supported on the operand types.
1:eac0369: 	 */
1:eac0369: 	private DataTypeDescriptor resolveConcatOperation(
1:7c5fbc4: 			DataTypeDescriptor leftType, DataTypeDescriptor rightType)
1:7c5fbc4: 			throws StandardException {
1:7c5fbc4: 		TypeId leftTypeId;
1:7c5fbc4: 		TypeId rightTypeId;
1:7c5fbc4: 		String higherType;
1:7c5fbc4: 		int resultLength;
1:7c5fbc4: 		boolean nullable;
1:eac0369: 
1:eac0369: 		leftTypeId = leftType.getTypeId();
1:eac0369: 		rightTypeId = rightType.getTypeId();
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Check the right type to be sure it's a concatable. By convention, *
1:7c5fbc4: 		 * we call this method off the TypeId of the left operand, so if * we
1:7c5fbc4: 		 * get here, we know the left operand is a concatable.
1:eac0369: 		 */
1:eac0369: 		/*
1:7c5fbc4: 		 * * Make sure we haven't been given a char and a * bit to concatenate.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		if (!leftTypeId.isConcatableTypeId()
1:eac0369: 				|| !rightTypeId.isConcatableTypeId()
1:eac0369: 				|| (rightTypeId.isBitTypeId() && leftTypeId.isStringTypeId())
1:eac0369: 				|| (leftTypeId.isBitTypeId() && rightTypeId.isStringTypeId()))
1:7c5fbc4: 			throw StandardException.newException(
1:7c5fbc4: 					SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "||", "FUNCTION");
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * The types aren't the same. The result of the operation is the *
1:7c5fbc4: 		 * type of higher precedence.
1:eac0369: 		 */
1:eac0369: 
1:7c5fbc4: 		higherType = (leftTypeId.typePrecedence() >= rightTypeId
1:7c5fbc4: 				.typePrecedence()) ? leftType.getTypeName() : rightType
1:7c5fbc4: 				.getTypeName();
1:eac0369: 
1:eac0369: 		/* Get the length of the result */
1:7c5fbc4: 		resultLength = leftType.getMaximumWidth() + rightType.getMaximumWidth();
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Use following chart to handle overflow * operands CHAR(A) CHAR(B)
1:7c5fbc4: 		 * and A+B <255 then result is CHAR(A+B) * operands CHAR FOR BIT DATA(A)
1:7c5fbc4: 		 * CHAR FOR BIT DATA(B) and A+B <255 then result is CHAR FOR BIT
1:7c5fbc4: 		 * DATA(A+B) * * operands CHAR(A) CHAR(B) and A+B>254 then result is
1:7c5fbc4: 		 * VARCHAR(A+B) * operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and
1:7c5fbc4: 		 * A+B>254 then result is VARCHAR FOR BIT DATA(A+B) * * operands CHAR(A)
1:7c5fbc4: 		 * VARCHAR(B) and A+B <4001 then result is VARCHAR(A+B) * operands CHAR
1:7c5fbc4: 		 * FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B <4001 then result is
1:7c5fbc4: 		 * VARCHAR FOR BIT DATA(A+B) * * operands CHAR(A) VARCHAR(B) and
1:7c5fbc4: 		 * A+B>4000 then result is LONG VARCHAR * operands CHAR FOR BIT DATA(A)
1:7c5fbc4: 		 * VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR
1:7c5fbc4: 		 * BIT DATA * * operands CHAR(A) LONG VARCHAR then result is LONG
1:7c5fbc4: 		 * VARCHAR * operands CHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA
1:7c5fbc4: 		 * then result is LONG VARCHAR FOR BIT DATA * * operands VARCHAR(A)
1:7c5fbc4: 		 * VARCHAR(B) and A+B <4001 then result is VARCHAR(A+B) * operands
1:7c5fbc4: 		 * VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B <4001 then
1:7c5fbc4: 		 * result is VARCHAR FOR BIT DATA(A+B) * * operands VARCHAR(A)
1:7c5fbc4: 		 * VARCHAR(B) and A+B>4000 then result is LONG VARCHAR * operands
1:7c5fbc4: 		 * VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then
1:7c5fbc4: 		 * result is LONG VARCHAR FOR BIT DATA * * operands VARCHAR(A) LONG
1:7c5fbc4: 		 * VARCHAR then result is LONG VARCHAR * operands VARCHAR FOR BIT
1:7c5fbc4: 		 * DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT
1:7c5fbc4: 		 * DATA * * operands LONG VARCHAR, LONG VARCHAR then result is LONG
1:7c5fbc4: 		 * VARCHAR * operands LONG VARCHAR FOR BIT DATA, LONG VARCHAR FOR BIT
1:7c5fbc4: 		 * DATA then result is LONG VARCHAR FOR BIT DATA * * operands CLOB(A),
1:7c5fbc4: 		 * CHAR(B) then result is CLOB(MIN(A+B,2G)) * operands CLOB(A),
1:7c5fbc4: 		 * VARCHAR(B) then result is CLOB(MIN(A+B,2G)) * operands CLOB(A), LONG
1:7c5fbc4: 		 * VARCHAR then result is CLOB(MIN(A+32K,2G)) * operands CLOB(A),
1:7c5fbc4: 		 * CLOB(B) then result is CLOB(MIN(A+B,2G)) * * operands BLOB(A), CHAR
1:7c5fbc4: 		 * FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G)) * operands BLOB(A),
1:7c5fbc4: 		 * VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G)) * operands
1:7c5fbc4: 		 * BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G)) *
1:7c5fbc4: 		 * operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G)) * *
1:7c5fbc4: 		 * operands CHAR(A)/VARCHAR(A)/LONGVARCHAR, LONGVARCHAR and
1:7c5fbc4: 		 * "concatenated string length">32700 does not cause automatic
1:7c5fbc4: 		 * escalation * to LOB for compatibility with previous releases. Any
1:7c5fbc4: 		 * such cases would result in an error at runtime *
1:eac0369: 		 */
1:7c5fbc4: 		//in the following code, I can assume that left and right operands both
1:7c5fbc4: 		// will be either char kind
1:7c5fbc4: 		//of datatypes or they will be both binary kind of datatypes. That's
1:7c5fbc4: 		// because operand datatypes
1:eac0369: 		//mismatch has already been handled earlier
1:7c5fbc4: 		if (leftTypeId.getJDBCTypeId() == Types.CHAR
1:7c5fbc4: 				|| leftTypeId.getJDBCTypeId() == Types.BINARY) {
1:7c5fbc4: 			switch (rightTypeId.getJDBCTypeId()) {
1:eac0369: 			case Types.CHAR:
1:eac0369: 			case Types.BINARY:
1:7c5fbc4: 				if (resultLength > Limits.DB2_CHAR_MAXWIDTH) {
1:eac0369: 					if (rightTypeId.getJDBCTypeId() == Types.CHAR)
1:7c5fbc4: 						//operands CHAR(A) CHAR(B) and A+B>254 then result is
1:7c5fbc4: 						// VARCHAR(A+B)
1:eac0369: 						higherType = TypeId.VARCHAR_NAME;
1:eac0369: 					else
1:7c5fbc4: 						//operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B)
1:7c5fbc4: 						// and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
1:eac0369: 						higherType = TypeId.VARBIT_NAME;
1:eac0369: 				}
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case Types.VARCHAR:
1:eac0369: 			case Types.VARBINARY:
1:7c5fbc4: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH) {
1:eac0369: 					if (rightTypeId.getJDBCTypeId() == Types.VARCHAR)
1:7c5fbc4: 						//operands CHAR(A) VARCHAR(B) and A+B>4000 then result
1:7c5fbc4: 						// is LONG VARCHAR
1:eac0369: 						higherType = TypeId.LONGVARCHAR_NAME;
1:eac0369: 					else
1:7c5fbc4: 						//operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B)
1:7c5fbc4: 						// and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
1:eac0369: 						higherType = TypeId.LONGVARBIT_NAME;
1:eac0369: 				}
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case Types.CLOB:
1:eac0369: 			case Types.BLOB:
1:eac0369: 				//operands CHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1:7c5fbc4: 				//operands CHAR FOR BIT DATA(A), BLOB(B) then result is
1:7c5fbc4: 				// BLOB(MIN(A+B,2G))
1:eac0369: 				resultLength = clobBlobHandling(rightType, leftType);
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARCHAR) {
1:7c5fbc4: 			switch (rightTypeId.getJDBCTypeId()) {
1:7c5fbc4: 			case Types.CHAR: //operands CHAR(A) VARCHAR(B) and A+B>4000 then
1:7c5fbc4: 							 // result is LONG VARCHAR
1:7c5fbc4: 			case Types.VARCHAR: //operands VARCHAR(A) VARCHAR(B) and A+B>4000
1:7c5fbc4: 								// then result is LONG VARCHAR
1:7c5fbc4: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
1:eac0369: 					higherType = TypeId.LONGVARCHAR_NAME;
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case Types.CLOB:
1:eac0369: 				//operands VARCHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1:eac0369: 				resultLength = clobBlobHandling(rightType, leftType);
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARBINARY) {
1:7c5fbc4: 			switch (rightTypeId.getJDBCTypeId()) {
1:7c5fbc4: 			case Types.BINARY: //operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT
1:7c5fbc4: 							   // DATA(B) and A+B>4000 then result is LONG
1:7c5fbc4: 							   // VARCHAR FOR BIT DATA
1:7c5fbc4: 			case Types.VARBINARY://operands VARCHAR FOR BIT DATA(A) VARCHAR FOR
1:7c5fbc4: 								 // BIT DATA(B) and A+B>4000 then result is LONG
1:7c5fbc4: 								 // VARCHAR FOR BIT DATA
1:7c5fbc4: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
1:eac0369: 					higherType = TypeId.LONGVARBIT_NAME;
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case Types.BLOB:
1:7c5fbc4: 				//operands VARCHAR FOR BIT DATA(A), BLOB(B) then result is
1:7c5fbc4: 				// BLOB(MIN(A+B,2G))
1:eac0369: 				resultLength = clobBlobHandling(rightType, leftType);
1:eac0369: 				break;
1:eac0369: 			}
1:7c5fbc4: 		} else if (leftTypeId.getJDBCTypeId() == Types.CLOB
1:7c5fbc4: 				|| leftTypeId.getJDBCTypeId() == Types.BLOB) {
1:eac0369: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
1:eac0369: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
1:eac0369: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
1:eac0369: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1:7c5fbc4: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is
1:7c5fbc4: 			// BLOB(MIN(A+B,2G))
1:7c5fbc4: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is
1:7c5fbc4: 			// BLOB(MIN(A+B,2G))
1:7c5fbc4: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is
1:7c5fbc4: 			// BLOB(MIN(A+32K,2G))
1:eac0369: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
1:eac0369: 			resultLength = clobBlobHandling(leftType, rightType);
1:7c5fbc4: 		} else if (rightTypeId.getJDBCTypeId() == Types.CLOB
1:7c5fbc4: 				|| rightTypeId.getJDBCTypeId() == Types.BLOB) {
1:eac0369: 			//operands LONG VARCHAR, CLOB(A) then result is CLOB(MIN(A+32K,2G))
1:7c5fbc4: 			//operands LONG VARCHAR FOR BIT DATA, BLOB(A) then result is
1:7c5fbc4: 			// BLOB(MIN(A+32K,2G))
1:eac0369: 			resultLength = clobBlobHandling(rightType, leftType);
1:eac0369: 		}
1:eac0369: 
1:7c5fbc4: 		//bug - 5837. long varchar and long binary can't hold more data than
1:7c5fbc4: 		// their specific limits. If this length is violated by resulting
1:eac0369: 		//concatenated string, an exception will be thrown at execute time.
1:eac0369: 		if (higherType.equals(TypeId.LONGVARCHAR_NAME))
1:eac0369: 			resultLength = TypeId.LONGVARCHAR_MAXWIDTH;
1:eac0369: 		else if (higherType.equals(TypeId.LONGVARBIT_NAME))
1:eac0369: 			resultLength = TypeId.LONGVARBIT_MAXWIDTH;
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Result Length can't be negative
1:eac0369: 		 */
1:7c5fbc4: 		if (SanityManager.DEBUG) {
1:7c5fbc4: 			if (resultLength < 0) {
1:7c5fbc4: 				SanityManager
1:7c5fbc4: 						.THROWASSERT("There should not be an overflow of maximum length for any result type at this point. Overflow for BLOB/CLOB has already been handled earlier");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* The result is nullable if either side is nullable */
1:eac0369: 		nullable = leftType.isNullable() || rightType.isNullable();
1:eac0369: 
1:eac0369: 		/*
1:7c5fbc4: 		 * * Create a new DataTypeDescriptor that has the correct * type and
1:7c5fbc4: 		 * nullability. * * It's OK to call the implementation of the
1:7c5fbc4: 		 * DataTypeDescriptorFactory * here, because we're in the same package.
1:eac0369: 		 */
1:7c5fbc4: 		DataTypeDescriptor returnDTD = new DataTypeDescriptor(TypeId
1:7c5fbc4: 				.getBuiltInTypeId(higherType), nullable, resultLength);
1:eac0369: 
1:7c5fbc4: 		//Check if collation derivations and collation types of 2 operands
1:12f2b05: 		//match?
1:244952e: 		//If they do, then the result of the concatenation will get the smae
1:244952e: 		//collation information. But if not, then the collation derivation of
1:244952e: 		//the result will be NONE.
1:7c5fbc4: 		if (leftType.getCollationDerivation() != rightType
1:7c5fbc4: 				.getCollationDerivation()
1:7c5fbc4: 				|| leftType.getCollationType() != rightType.getCollationType())
1:9ed7c4d:             
1:9ed7c4d:             returnDTD = returnDTD.getCollatedType(
1:9ed7c4d:                     returnDTD.getCollationDerivation(),
1:9ed7c4d:                     StringDataValue.COLLATION_DERIVATION_NONE);
1:244952e: 		else {
1:9ed7c4d:             returnDTD = returnDTD.getCollatedType(
1:9ed7c4d:                     leftType.getCollationType(),
1:9ed7c4d:                     leftType.getCollationDerivation());
1:eac0369: 		}
1:244952e: 		return returnDTD;
1:eac0369: 	}
1:eac0369: 
1:7c5fbc4: 	private static int clobBlobHandling(DataTypeDescriptor clobBlobType,
1:7c5fbc4: 			DataTypeDescriptor otherType) throws StandardException {
1:eac0369: 		int resultLength;
1:eac0369: 
1:7c5fbc4: 		if (otherType.getTypeId().getJDBCTypeId() == Types.LONGVARCHAR
1:7c5fbc4: 				|| otherType.getTypeId().getJDBCTypeId() == Types.LONGVARBINARY) {
1:eac0369: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
1:7c5fbc4: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is
1:7c5fbc4: 			// BLOB(MIN(A+32K,2G))
1:eac0369: 			resultLength = clobBlobType.getMaximumWidth() + 32768;
1:eac0369: 		} else {
1:eac0369: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
1:eac0369: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
1:eac0369: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1:7c5fbc4: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is
1:7c5fbc4: 			// BLOB(MIN(A+B,2G))
1:7c5fbc4: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is
1:7c5fbc4: 			// BLOB(MIN(A+B,2G))
1:eac0369: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
1:7c5fbc4: 			resultLength = clobBlobType.getMaximumWidth()
1:7c5fbc4: 					+ otherType.getMaximumWidth();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (resultLength < 1) //this mean A+B or A+32K is bigger than 2G
1:7c5fbc4: 			return (Integer.MAX_VALUE);
1:eac0369: 		else
1:7c5fbc4: 			return (resultLength);
1:eac0369: 
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import java.util.List;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.StringDataValue;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1: class ConcatenationOperatorNode extends BinaryOperatorNode {
1:      * Constructor for a ConcatenationOperatorNode
1:      * @param cm  The context manager
1:     ConcatenationOperatorNode(
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             ContextManager cm) {
1:         super(leftOperand,
1:               rightOperand,
1:               "||",
1:               "concatenate",
1:               ClassName.ConcatableDataValue,
1:               ClassName.ConcatableDataValue,
1:               cm);
0:         setNodeType(C_NodeTypes.CONCATENATION_OPERATOR_NODE);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             return new CharConstantNode(
1:                 resultValue.getString(), getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             leftOperand = new CastNode(leftOperand, dtd, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             rightOperand = new CastNode(rightOperand, dtd, getContextManager());
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
1:                 aggregates);
1:                 aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 			SubqueryList subqueryList, List aggregateVector)
commit:6d90df0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1998441
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if this node always evaluates to the same value. If so, return
1:      * a constant node representing the known result.
1:      *
1:      * @return a constant node representing the result of this concatenation
1:      * operation, or {@code this} if the result is not known up front
1:      */
1:     ValueNode evaluateConstantExpressions() throws StandardException {
1:         if (leftOperand instanceof CharConstantNode &&
1:                 rightOperand instanceof CharConstantNode) {
1:             CharConstantNode leftOp = (CharConstantNode) leftOperand;
1:             CharConstantNode rightOp = (CharConstantNode) rightOperand;
1:             StringDataValue leftValue = (StringDataValue) leftOp.getValue();
1:             StringDataValue rightValue = (StringDataValue) rightOp.getValue();
1: 
1:             StringDataValue resultValue =
1:                     (StringDataValue) getTypeServices().getNull();
1:             resultValue.concatenate(leftValue, rightValue, resultValue);
1: 
0:             return (ValueNode) getNodeFactory().getNode(
0:                     C_NodeTypes.CHAR_CONSTANT_NODE,
0:                     resultValue.getString(),
0:                     getContextManager());
1:         }
1: 
1:         return this;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Finally, fold constants so that for example LIKE optimization is
1:         // able to take advantage of concatenated literals like 'ab' || '%'.
1:         return this.evaluateConstantExpressions();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 
1: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
1: 			// explicit casts per SQL Spec 6.12 (10)			
1: 			leftOperand.setCollationUsingCompilationSchema();
1: 						
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
1: 			// explicit casts per SQL Spec 6.12 (10)					
1: 			rightOperand.setCollationUsingCompilationSchema();
1: 			
/////////////////////////////////////////////////////////////////////////
1:             
1:             returnDTD = returnDTD.getCollatedType(
1:                     returnDTD.getCollationDerivation(),
1:                     StringDataValue.COLLATION_DERIVATION_NONE);
1:             returnDTD = returnDTD.getCollatedType(
1:                     leftType.getCollationType(),
1:                     leftType.getCollationDerivation());
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:                 leftOperand.setCollationInfo(rightOperand.getTypeServices());
/////////////////////////////////////////////////////////////////////////
1:                 rightOperand.setCollationInfo(leftOperand.getTypeServices());
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0: 		if (leftOperand.getTypeId().userType())
/////////////////////////////////////////////////////////////////////////
0: 		if (rightOperand.getTypeId().userType())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ConcatenationOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
0: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.ConcatableDataValue;
0: import org.apache.derby.iapi.types.BitDataValue;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import java.sql.Types;
1: 
0: import java.util.Vector;
1: 
1: 
1: /**
1:  * This node represents a concatenation comparison operator
1:  *
0:  * @author Jerry Brenner -- modified by jamie for bit and bit
0:  *							varying.
1:  */
1: 
0: public class ConcatenationOperatorNode extends BinaryOperatorNode
0: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
0: 	 * Initializer for a ConcatenationOperatorNode
1: 	 *
0: 	 * @param leftOperand	The left operand of the concatenation
0: 	 * @param rightOperand	The right operand of the concatenation
1: 	 */
0: 	public void init(Object leftOperand, Object rightOperand)
0: 	{
0: 		super.init(leftOperand, rightOperand, "||", "concatenate",
0: 				ClassName.ConcatableDataValue, ClassName.ConcatableDataValue);
1: 	}
1: 
1: 	/**
0: 	 * overrides BindOperatorNode.bindExpression because concatenation has special
0: 	 * requirements for parameter binding.
1: 	 *
0: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
0: 			throws StandardException
0: 	{
1: 		// deal with binding operands
1: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList,
0: 			aggregateVector);
1: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList,
0: 			aggregateVector);
1: 
1: 		// deal with operand parameters
1: 		/*
0: 			Is there a ? parameter on the left?
0: 			If so, it's type is the type of the other parameter, with
0: 			maximum length for that type.
1: 		*/
1: 
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			if (rightOperand.isParameterNode())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
0: 																	operator);
1: 			}
1: 
0: 			TypeId 	leftType;
1: 
1: 			/*
0: 			** A ? on the left gets its type from the right.  There are six
0: 			** legal types for the concatenation operator: CHAR, VARCHAR,
0: 			** LONG VARCHAR, BIT, BIT VARYING, and LONG BIT VARYING.  If the
0: 			** right type is one of the bit types, set the parameter type to
0: 			** BIT VARYING with maximum length.
0: 			**
0: 			** If the right type is anything else, set it to VARCHAR with
0: 			** maximum length.  We count on the resolveConcatOperation method to
0: 			** catch an illegal type.
0: 			**
0: 			** NOTE: When I added the long types, I could have changed the
0: 			** resulting parameter types to LONG VARCHAR and LONG BIT VARYING,
0: 			** but they were already VARCHAR and BIT VARYING, and it wasn't
0: 			** clear to me what effect it would have to change it.
0: 			**
0: 			**				-	Jeff
1: 			*/
0: 			if (rightOperand.getTypeId().isBitTypeId())
0: 			{
1: 				leftType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1: 			}
1: 			else
0: 			{
1: 				leftType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1: 			}
1: 		
0: 		((ParameterNode) leftOperand).setDescriptor(new DataTypeDescriptor(leftType, true));
1: 		}
1: 
1: 		/*
0: 			Is there a ? parameter on the right?
1: 		*/
0: 		if (rightOperand.isParameterNode())
0: 		{
0: 			TypeId 	rightType;
1: 
1: 			/*
0: 			** A ? on the right gets its type from the left.  There are six
0: 			** legal types for the concatenation operator: CHAR, VARCHAR,
0: 			** LONG VARCHAR, BIT, BIT VARYING, and LONG BIT VARYING.  If the
0: 			** left type is one of the bit types, set the parameter type to
0: 			** BIT VARYING with maximum length.  If the left type is anything
0: 			** else, set it to VARCHAR with maximum length.  We count on the
0: 			** resolveConcatOperation method to catch an illegal type.
0: 			**
0: 			** NOTE: When I added the long types, I could have changed the
0: 			** resulting parameter types to LONG VARCHAR and LONG BIT VARYING,
0: 			** but they were already VARCHAR and BIT VARYING, and it wasn't
0: 			** clear to me what effect it would have to change it.
0: 			**
0: 			**				-	Jeff
1: 			*/
0: 			if (leftOperand.getTypeId().isBitTypeId())
0: 			{
1: 				rightType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1: 			}
1: 			else
0: 			{
1: 				rightType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1: 			}
1: 		
0: 		((ParameterNode) rightOperand).setDescriptor(
0: 							new DataTypeDescriptor(
0: 										rightType,
0: 										true));
1: 		}
1: 
0: 		/* If the left operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
1: 		 */
0: 		if (! leftOperand.getTypeId().systemBuiltIn())
0: 		{
1: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1: 		}
1: 
0: 		/* If the right operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
1: 		 */
0: 		if (! rightOperand.getTypeId().systemBuiltIn())
0: 		{
1: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1: 		}
1: 
0: 		/* If either the left or right operands are non-string, non-bit types,
1: 		 * then we generate an implicit cast to VARCHAR.
1: 		 */
1: 		TypeCompiler tc = leftOperand.getTypeCompiler();
0: 		if (! (leftOperand.getTypeId().isStringTypeId() || leftOperand.getTypeId().isBitTypeId()))
0: 		{
0: 			leftOperand =  (ValueNode)
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						leftOperand, 
0: 						DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true, 
0: 										    tc.getCastToCharWidth(
0: 												leftOperand.getTypeServices())),
0: 						getContextManager());
1: 			((CastNode) leftOperand).bindCastNodeOnly();
1: 		}
1: 		tc = rightOperand.getTypeCompiler();
0: 		if (! (rightOperand.getTypeId().isStringTypeId() || rightOperand.getTypeId().isBitTypeId()))
0: 		{
0: 			rightOperand =  (ValueNode)
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						rightOperand, 
0: 						DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
0: 										    tc.getCastToCharWidth(
0: 												rightOperand.getTypeServices())),
0: 						getContextManager());
1: 			((CastNode) rightOperand).bindCastNodeOnly();
1: 		}
1: 
1: 
1: 		/*
0: 		** Set the result type of this operator based on the operands.
0: 		** By convention, the left operand gets to decide the result type
0: 		** of a binary operator.
1: 		*/
1: 		tc = leftOperand.getTypeCompiler();
0: 		setType(resolveConcatOperation(
0: 						leftOperand.getTypeServices(),
1: 						rightOperand.getTypeServices()));
1: 
1: 		/*
0: 		** Make sure the maximum width set for the result doesn't exceed the result type's maximum width
1: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (getTypeServices().getMaximumWidth() > getTypeId().getMaximumMaximumWidth())
0: 			{
0: 				SanityManager.THROWASSERT("The maximum length " + getTypeServices().getMaximumWidth() +
0: 						" for the result type " + getTypeId().getSQLTypeName() +
0: 						" can't be greater than it's maximum width of result's typeid" + getTypeId().getMaximumMaximumWidth());
1: 			}
1: 		}
1: 
1: 		/*
0: 		** Now that we know the target interface type, set it.  This assumes
0: 		** that both operands have the same interface type, which is a safe
0: 		** assumption for the concatenation operator.
1: 		*/
1: 		this.setLeftRightInterfaceType(tc.interfaceName());
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Resolve a concatenation operator
1: 	 *
0: 	 * @param leftType	The DataTypeDescriptor of the left operand
0: 	 * @param rightType	The DataTypeDescriptor of the right operand
1: 	 *
0: 	 * @return	A DataTypeDescriptor telling the result type of the 
0: 	 *			concatenate operation
1: 	 *
0: 	 * @exception StandardException BinaryOperatorNotSupported
0: 	 *						Thrown when a BinaryOperator is not supported
0: 	 *						on the operand types.
1: 	 */
1: 	private DataTypeDescriptor resolveConcatOperation(
0: 								DataTypeDescriptor leftType,
0: 								DataTypeDescriptor rightType
0: 							) throws StandardException
0: 	{
0: 		TypeId	leftTypeId;
0: 		TypeId	rightTypeId;
0: 		String	higherType;
0: 		int					resultLength;
0: 		boolean				nullable;
1: 
1: 		leftTypeId = leftType.getTypeId();
1: 		rightTypeId = rightType.getTypeId();
1: 
1: 		/*
0: 		** Check the right type to be sure it's a concatable.  By convention,
0: 		** we call this method off the TypeId of the left operand, so if
0: 		** we get here, we know the left operand is a concatable.
1: 		*/
1: 		/*
0: 		** Make sure we haven't been given a char and a
0: 		** bit to concatenate.
1: 		*/
1: 
1: 		if (!leftTypeId.isConcatableTypeId()
1: 			|| !rightTypeId.isConcatableTypeId()
1: 			|| (rightTypeId.isBitTypeId() && leftTypeId.isStringTypeId())
1: 			|| (leftTypeId.isBitTypeId() && rightTypeId.isStringTypeId()))
0: 				throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "||", "FUNCTION");
1: 
1: 		/*
0: 		** The types aren't the same.  The result of the operation is the
0: 		** type of higher precedence.
1: 		*/
1:     
0: 		higherType = (leftTypeId.typePrecedence() >=
0: 									rightTypeId.typePrecedence()) ?
0: 				leftType.getTypeName() : rightType.getTypeName();
1: 
1: 		/* Get the length of the result */
0: 		resultLength = leftType.getMaximumWidth() +
0: 					   rightType.getMaximumWidth();
1: 
1: 		/*
0: 		** Use following chart to handle overflow
0: 		** operands CHAR(A) CHAR(B) and A+B<255 then result is CHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B<255 then result is CHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) CHAR(B) and A+B>254 then result is VARCHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) VARCHAR(B) and A+B<4001 then result is VARCHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B<4001 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 		** operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands CHAR(A) LONG VARCHAR then result is LONG VARCHAR
0: 		** operands CHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands VARCHAR(A) VARCHAR(B) and A+B<4001 then result is VARCHAR(A+B)
0: 		** operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B<4001 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands VARCHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 		** operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands VARCHAR(A) LONG VARCHAR then result is LONG VARCHAR
0: 		** operands VARCHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands LONG VARCHAR, LONG VARCHAR then result is LONG VARCHAR
0: 		** operands LONG VARCHAR FOR BIT DATA, LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
0: 		** operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
0: 		** operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
0: 		** operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 		**
0: 		** operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 		** operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 		** operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
0: 		** operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 		**
0: 		** operands CHAR(A)/VARCHAR(A)/LONGVARCHAR, LONGVARCHAR and "concatenated string length">32700 does not cause automatic escalation
0: 		** to LOB for compatibility with previous releases. Any such cases would result in an error at runtime
0: 		**
1: 		*/
0: 		//in the following code, I can assume that left and right operands both will be either char kind
0: 		//of datatypes or they will be both binary kind of datatypes. That's because operand datatypes
1: 		//mismatch has already been handled earlier
0: 		if (leftTypeId.getJDBCTypeId() == Types.CHAR || leftTypeId.getJDBCTypeId() == Types.BINARY)
0: 		{
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
1: 				case Types.CHAR:
1: 				case Types.BINARY:
0: 					if (resultLength > DB2Limit.DB2_CHAR_MAXWIDTH) {
1: 						if (rightTypeId.getJDBCTypeId() == Types.CHAR)
0: 								//operands CHAR(A) CHAR(B) and A+B>254 then result is VARCHAR(A+B)
1: 								higherType = TypeId.VARCHAR_NAME;
1: 						else
0: 								//operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
1: 								higherType = TypeId.VARBIT_NAME;
1: 					}
1: 					break;
1: 
1: 				case Types.VARCHAR:
1: 				case Types.VARBINARY:
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH) {
1: 						if (rightTypeId.getJDBCTypeId() == Types.VARCHAR)
0: 								//operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
1: 								higherType = TypeId.LONGVARCHAR_NAME;
1: 						else
0: 								//operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
1: 								higherType = TypeId.LONGVARBIT_NAME;
1: 					}
1: 					break;
1: 
1: 				case Types.CLOB:
1: 				case Types.BLOB:
1: 					//operands CHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 					//operands CHAR FOR BIT DATA(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
1: 					resultLength = clobBlobHandling(rightType, leftType);
1: 					break;
1: 			}
1: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARCHAR) {
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
0: 				case Types.CHAR: //operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 				case Types.VARCHAR: //operands VARCHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH)
1: 						higherType = TypeId.LONGVARCHAR_NAME;
1: 					break;
1: 
1: 				case Types.CLOB:
1: 					//operands VARCHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1: 					resultLength = clobBlobHandling(rightType, leftType);
1: 					break;
1: 			}
1: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARBINARY) {
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
0: 				case Types.BINARY: //operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 				case Types.VARBINARY://operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH)
1: 						higherType = TypeId.LONGVARBIT_NAME;
1: 					break;
1: 
1: 				case Types.BLOB:
0: 					//operands VARCHAR FOR BIT DATA(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
1: 					resultLength = clobBlobHandling(rightType, leftType);
1: 					break;
1: 			}
0: 		} else if (leftTypeId.getJDBCTypeId() == Types.CLOB || leftTypeId.getJDBCTypeId() == Types.BLOB) {
1: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
1: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
1: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
1: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
1: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
1: 			resultLength = clobBlobHandling(leftType, rightType);
0: 		} else if (rightTypeId.getJDBCTypeId() == Types.CLOB || rightTypeId.getJDBCTypeId() == Types.BLOB) {
1: 			//operands LONG VARCHAR, CLOB(A) then result is CLOB(MIN(A+32K,2G))
0: 			//operands LONG VARCHAR FOR BIT DATA, BLOB(A) then result is BLOB(MIN(A+32K,2G))
1: 			resultLength = clobBlobHandling(rightType, leftType);
1: 		}
1: 
0: 		//bug - 5837. long varchar and long binary can't hold more data than their specific limits. If this length is violated by resulting
1: 		//concatenated string, an exception will be thrown at execute time.
1: 		if (higherType.equals(TypeId.LONGVARCHAR_NAME))
1: 			resultLength = TypeId.LONGVARCHAR_MAXWIDTH;
1: 		else if (higherType.equals(TypeId.LONGVARBIT_NAME))
1: 			resultLength = TypeId.LONGVARBIT_MAXWIDTH;
1: 
1: 
1: 		/*
0: 		** Result Length can't be negative
1: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (resultLength < 0)
0: 			{
0: 				SanityManager.THROWASSERT("There should not be an overflow of maximum length for any result type at this point. Overflow for BLOB/CLOB has already been handled earlier");
1: 			}
1: 		}
1: 
1: 		/* The result is nullable if either side is nullable */
1: 		nullable = leftType.isNullable() || rightType.isNullable();
1: 
1: 		/*
0: 		** Create a new DataTypeDescriptor that has the correct
0: 		** type and nullability.
0: 		**
0: 		** It's OK to call the implementation of the DataTypeDescriptorFactory
0: 		** here, because we're in the same package.
1: 		*/
0: 		return new DataTypeDescriptor(
0: 					TypeId.getBuiltInTypeId(higherType),
0: 					nullable,
0: 					resultLength
0: 				);
1: 	}
1: 
1: 	/*
0: 	 *for conatenation operator, we generate code as follows
0: 	 *field = method(p1, p2, field);
0: 	 *what we are ensuring here is if field is null then initialize it to NULL SQLxxx type.
0: 	 *Because of the following, at execution time, SQLxxx concatenate method do not have to
0: 	 *worry about field coming in as null
1: 	*/
0: 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
0: 	{
0: 		mb.conditionalIfNull();//get the field on the stack and if it is null
0: 			acb.generateNull(mb, getTypeCompiler());// yes, it is, hence create a NULL SQLxxx type object and put that on stack
0: 		mb.startElseCode(); //no, it is not null
0: 			mb.getField(resultField); //so put it back on the stack
0: 		mb.completeConditional(); //complete if else block
1: 	}
1: 
0: 	private static int clobBlobHandling(
0: 								DataTypeDescriptor clobBlobType,
0: 								DataTypeDescriptor otherType
0: 							) throws StandardException
0: 	{
1: 		int resultLength;
1: 
0: 		if (otherType.getTypeId().getJDBCTypeId() == Types.LONGVARCHAR ||
0: 			otherType.getTypeId().getJDBCTypeId() == Types.LONGVARBINARY) {
1: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
0: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
1: 			resultLength = clobBlobType.getMaximumWidth() + 32768;
1: 		} else {
1: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
1: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
1: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
1: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 			resultLength = clobBlobType.getMaximumWidth() + otherType.getMaximumWidth();
1: 		}
1: 
1: 		if (resultLength < 1) //this mean A+B or A+32K is bigger than 2G
0: 			return(Integer.MAX_VALUE); 
1: 		else
0: 			return(resultLength);
1: 
1: 	}
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:d9b6192
/////////////////////////////////////////////////////////////////////////
1: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1: 					Types.VARCHAR, true, tc
1: 					.getCastToCharWidth(leftOperand							.getTypeServices()));	
0: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
0: 			// explicit casts per SQL Spec 6.12 (10)									
0: 			dtd.setCollationType(getSchemaDescriptor(null).getCollationType());
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 
0: 					dtd,
1: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1: 					Types.VARCHAR, true, tc
1: 							.getCastToCharWidth(rightOperand
1: 									.getTypeServices()));
0: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
0: 			// explicit casts per SQL Spec 6.12 (10)					
0: 			dtd.setCollationType(getSchemaDescriptor(null).getCollationType());
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 
0: 					dtd,
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:12f2b05
/////////////////////////////////////////////////////////////////////////
1: 		//match?
commit:168a4f8
/////////////////////////////////////////////////////////////////////////
1: 				//collation of ? operand should be picked from the context
0: 				leftOperand.getTypeServices().setCollationDerivation(
0: 						rightOperand.getTypeServices().getCollationDerivation());
0: 				leftOperand.getTypeServices().setCollationType(
0: 						rightOperand.getTypeServices().getCollationType());
/////////////////////////////////////////////////////////////////////////
1: 				//collation of ? operand should be picked from the context
0: 				rightOperand.getTypeServices().setCollationDerivation(
0: 						leftOperand.getTypeServices().getCollationDerivation());
0: 				rightOperand.getTypeServices().setCollationType(
0: 						leftOperand.getTypeServices().getCollationType());
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the compilation schema
0: 				leftOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the compilation schema
0: 				rightOperand.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0:  Derby - Class org.apache.derby.impl.sql.compile.ConcatenationOperatorNode
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to you under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
0:  http://www.apache.org/licenses/LICENSE-2.0
0:  Unless required by applicable law or agreed to in writing, software
0:  distributed under the License is distributed on an "AS IS" BASIS,
0:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  See the License for the specific language governing permissions and
0:  limitations under the License.
1: package org.apache.derby.impl.sql.compile;
/////////////////////////////////////////////////////////////////////////
0:  * 
1:  * varying.
0: public class ConcatenationOperatorNode extends BinaryOperatorNode {
0: 	 * 
1: 	 * @param leftOperand
1: 	 *            The left operand of the concatenation
1: 	 * @param rightOperand
1: 	 *            The right operand of the concatenation
0: 	public void init(Object leftOperand, Object rightOperand) {
1: 	 * overrides BindOperatorNode.bindExpression because concatenation has
1: 	 * special requirements for parameter binding.
0: 	 * 
1: 	 * @exception StandardException
1: 	 *                thrown on failure
0: 	public ValueNode bindExpression(FromList fromList,
0: 			SubqueryList subqueryList, Vector aggregateVector)
1: 			throws StandardException {
0: 				aggregateVector);
0: 				aggregateVector);
1: 		 * Is there a ? parameter on the left? If so, it's type is the type of
1: 		 * the other parameter, with maximum length for that type.
0: 		 */
1: 		if (leftOperand.requiresTypeFromContext()) {
1: 			if (rightOperand.requiresTypeFromContext()) {
1: 				throw StandardException.newException(
1: 						SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, operator);
1: 			TypeId leftType;
1: 			 * * A ? on the left gets its type from the right. There are eight *
1: 			 * legal types for the concatenation operator: CHAR, VARCHAR, * LONG
1: 			 * VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB. * If
1: 			 * the right type is BLOB, set the parameter type to BLOB with max
1: 			 * length. * If the right type is one of the other bit types, set
1: 			 * the parameter type to * BIT VARYING with maximum length. * * If
1: 			 * the right type is CLOB, set parameter type to CLOB with max
1: 			 * length. * If the right type is anything else, set it to VARCHAR
1: 			 * with * maximum length. We count on the resolveConcatOperation
1: 			 * method to * catch an illegal type. * * NOTE: When I added the
1: 			 * long types, I could have changed the * resulting parameter types
1: 			 * to LONG VARCHAR and LONG BIT VARYING, * but they were already
1: 			 * VARCHAR and BIT VARYING, and it wasn't * clear to me what effect
1: 			 * it would have to change it. - Jeff
0: 			 */
1: 			if (rightOperand.getTypeId().isBitTypeId()) {
1: 			} else {
0: 
1: 			if (rightOperand.getTypeId().isStringTypeId()) {
0: 				//collation of ? operand should be same as the current schema
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 						getLanguageConnectionContext().getDefaultSchema()
0: 								.getCollationType());
1: 		 * Is there a ? parameter on the right?
0: 		 */
1: 		if (rightOperand.requiresTypeFromContext()) {
1: 			TypeId rightType;
1: 			 * * A ? on the right gets its type from the left. There are eight *
1: 			 * legal types for the concatenation operator: CHAR, VARCHAR, * LONG
1: 			 * VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB. * If
1: 			 * the left type is BLOB, set the parameter type to BLOB with max
1: 			 * length. * If the left type is one of the other bit types, set the
1: 			 * parameter type to * BIT VARYING with maximum length. * * If the
1: 			 * left type is CLOB, set parameter type to CLOB with max length. *
1: 			 * If the left type is anything else, set it to VARCHAR with *
1: 			 * maximum length. We count on the resolveConcatOperation method to *
1: 			 * catch an illegal type. * * NOTE: When I added the long types, I
1: 			 * could have changed the * resulting parameter types to LONG
1: 			 * VARCHAR and LONG BIT VARYING, * but they were already VARCHAR and
1: 			 * BIT VARYING, and it wasn't * clear to me what effect it would
1: 			 * have to change it. - Jeff
0: 			 */
1: 			if (leftOperand.getTypeId().isBitTypeId()) {
1: 			} else {
1: 			rightOperand.setType(new DataTypeDescriptor(rightType, true));
1: 			if (leftOperand.getTypeId().isStringTypeId()) {
0: 				//collation of ? operand should be same as the current schema
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 						getLanguageConnectionContext().getDefaultSchema()
0: 								.getCollationType());
1: 		/*
1: 		 * If the left operand is not a built-in type, then generate a bound
1: 		 * conversion tree to a built-in type.
1: 		if (leftOperand.getTypeId().userType()) {
1: 		/*
1: 		 * If the right operand is not a built-in type, then generate a bound
1: 		 * conversion tree to a built-in type.
1: 		if (rightOperand.getTypeId().userType()) {
1: 		/*
1: 		 * If either the left or right operands are non-string, non-bit types,
1: 		if (!(leftOperand.getTypeId().isStringTypeId() || leftOperand
1: 				.getTypeId().isBitTypeId())) {
0: 			leftOperand = (ValueNode) getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					leftOperand,
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0: 							Types.VARCHAR, true, tc
0: 									.getCastToCharWidth(leftOperand
0: 											.getTypeServices())),
0: 					getContextManager());
1: 		if (!(rightOperand.getTypeId().isStringTypeId() || rightOperand
1: 				.getTypeId().isBitTypeId())) {
0: 			rightOperand = (ValueNode) getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					rightOperand,
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0: 							Types.VARCHAR, true, tc
0: 									.getCastToCharWidth(rightOperand
0: 											.getTypeServices())),
0: 					getContextManager());
1: 		 * * Set the result type of this operator based on the operands. * By
1: 		 * convention, the left operand gets to decide the result type * of a
1: 		 * binary operator.
0: 		 */
1: 		setType(resolveConcatOperation(leftOperand.getTypeServices(),
0: 				rightOperand.getTypeServices()));
1: 		 * * Make sure the maximum width set for the result doesn't exceed the
1: 		 * result type's maximum width
0: 		 */
1: 		if (SanityManager.DEBUG) {
1: 			if (getTypeServices().getMaximumWidth() > getTypeId()
1: 					.getMaximumMaximumWidth()) {
1: 				SanityManager
1: 						.THROWASSERT("The maximum length "
1: 								+ getTypeServices().getMaximumWidth()
1: 								+ " for the result type "
1: 								+ getTypeId().getSQLTypeName()
1: 								+ " can't be greater than it's maximum width of result's typeid"
1: 								+ getTypeId().getMaximumMaximumWidth());
1: 		 * * Now that we know the target interface type, set it. This assumes *
1: 		 * that both operands have the same interface type, which is a safe *
1: 		 * assumption for the concatenation operator.
0: 		 */
/////////////////////////////////////////////////////////////////////////
0: 	 * 
1: 	 * @param leftType
1: 	 *            The DataTypeDescriptor of the left operand
1: 	 * @param rightType
1: 	 *            The DataTypeDescriptor of the right operand
0: 	 * 
1: 	 * @return A DataTypeDescriptor telling the result type of the concatenate
1: 	 *         operation
0: 	 * 
1: 	 * @exception StandardException
1: 	 *                BinaryOperatorNotSupported Thrown when a BinaryOperator is
1: 	 *                not supported on the operand types.
1: 			DataTypeDescriptor leftType, DataTypeDescriptor rightType)
1: 			throws StandardException {
1: 		TypeId leftTypeId;
1: 		TypeId rightTypeId;
1: 		String higherType;
1: 		int resultLength;
1: 		boolean nullable;
1: 		 * * Check the right type to be sure it's a concatable. By convention, *
1: 		 * we call this method off the TypeId of the left operand, so if * we
1: 		 * get here, we know the left operand is a concatable.
0: 		 */
1: 		 * * Make sure we haven't been given a char and a * bit to concatenate.
0: 		 */
0: 				|| !rightTypeId.isConcatableTypeId()
0: 				|| (rightTypeId.isBitTypeId() && leftTypeId.isStringTypeId())
0: 				|| (leftTypeId.isBitTypeId() && rightTypeId.isStringTypeId()))
1: 			throw StandardException.newException(
1: 					SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "||", "FUNCTION");
1: 		 * * The types aren't the same. The result of the operation is the *
1: 		 * type of higher precedence.
0: 		 */
0: 
1: 		higherType = (leftTypeId.typePrecedence() >= rightTypeId
1: 				.typePrecedence()) ? leftType.getTypeName() : rightType
1: 				.getTypeName();
1: 		resultLength = leftType.getMaximumWidth() + rightType.getMaximumWidth();
1: 		 * * Use following chart to handle overflow * operands CHAR(A) CHAR(B)
1: 		 * and A+B <255 then result is CHAR(A+B) * operands CHAR FOR BIT DATA(A)
1: 		 * CHAR FOR BIT DATA(B) and A+B <255 then result is CHAR FOR BIT
1: 		 * DATA(A+B) * * operands CHAR(A) CHAR(B) and A+B>254 then result is
1: 		 * VARCHAR(A+B) * operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and
1: 		 * A+B>254 then result is VARCHAR FOR BIT DATA(A+B) * * operands CHAR(A)
1: 		 * VARCHAR(B) and A+B <4001 then result is VARCHAR(A+B) * operands CHAR
1: 		 * FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B <4001 then result is
1: 		 * VARCHAR FOR BIT DATA(A+B) * * operands CHAR(A) VARCHAR(B) and
1: 		 * A+B>4000 then result is LONG VARCHAR * operands CHAR FOR BIT DATA(A)
1: 		 * VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR
1: 		 * BIT DATA * * operands CHAR(A) LONG VARCHAR then result is LONG
1: 		 * VARCHAR * operands CHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA
1: 		 * then result is LONG VARCHAR FOR BIT DATA * * operands VARCHAR(A)
1: 		 * VARCHAR(B) and A+B <4001 then result is VARCHAR(A+B) * operands
1: 		 * VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B <4001 then
1: 		 * result is VARCHAR FOR BIT DATA(A+B) * * operands VARCHAR(A)
1: 		 * VARCHAR(B) and A+B>4000 then result is LONG VARCHAR * operands
1: 		 * VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then
1: 		 * result is LONG VARCHAR FOR BIT DATA * * operands VARCHAR(A) LONG
1: 		 * VARCHAR then result is LONG VARCHAR * operands VARCHAR FOR BIT
1: 		 * DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT
1: 		 * DATA * * operands LONG VARCHAR, LONG VARCHAR then result is LONG
1: 		 * VARCHAR * operands LONG VARCHAR FOR BIT DATA, LONG VARCHAR FOR BIT
1: 		 * DATA then result is LONG VARCHAR FOR BIT DATA * * operands CLOB(A),
1: 		 * CHAR(B) then result is CLOB(MIN(A+B,2G)) * operands CLOB(A),
1: 		 * VARCHAR(B) then result is CLOB(MIN(A+B,2G)) * operands CLOB(A), LONG
1: 		 * VARCHAR then result is CLOB(MIN(A+32K,2G)) * operands CLOB(A),
1: 		 * CLOB(B) then result is CLOB(MIN(A+B,2G)) * * operands BLOB(A), CHAR
1: 		 * FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G)) * operands BLOB(A),
1: 		 * VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G)) * operands
1: 		 * BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G)) *
1: 		 * operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G)) * *
1: 		 * operands CHAR(A)/VARCHAR(A)/LONGVARCHAR, LONGVARCHAR and
1: 		 * "concatenated string length">32700 does not cause automatic
1: 		 * escalation * to LOB for compatibility with previous releases. Any
1: 		 * such cases would result in an error at runtime *
0: 		 */
1: 		//in the following code, I can assume that left and right operands both
1: 		// will be either char kind
1: 		//of datatypes or they will be both binary kind of datatypes. That's
1: 		// because operand datatypes
1: 		if (leftTypeId.getJDBCTypeId() == Types.CHAR
1: 				|| leftTypeId.getJDBCTypeId() == Types.BINARY) {
1: 			switch (rightTypeId.getJDBCTypeId()) {
0: 			case Types.CHAR:
0: 			case Types.BINARY:
1: 				if (resultLength > Limits.DB2_CHAR_MAXWIDTH) {
0: 					if (rightTypeId.getJDBCTypeId() == Types.CHAR)
1: 						//operands CHAR(A) CHAR(B) and A+B>254 then result is
1: 						// VARCHAR(A+B)
0: 						higherType = TypeId.VARCHAR_NAME;
1: 					else
1: 						//operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B)
1: 						// and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
0: 						higherType = TypeId.VARBIT_NAME;
0: 				}
0: 				break;
0: 			case Types.VARCHAR:
0: 			case Types.VARBINARY:
1: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH) {
0: 					if (rightTypeId.getJDBCTypeId() == Types.VARCHAR)
1: 						//operands CHAR(A) VARCHAR(B) and A+B>4000 then result
1: 						// is LONG VARCHAR
0: 						higherType = TypeId.LONGVARCHAR_NAME;
1: 					else
1: 						//operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B)
1: 						// and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 						higherType = TypeId.LONGVARBIT_NAME;
0: 				}
0: 				break;
0: 			case Types.CLOB:
0: 			case Types.BLOB:
0: 				//operands CHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
1: 				//operands CHAR FOR BIT DATA(A), BLOB(B) then result is
1: 				// BLOB(MIN(A+B,2G))
0: 				resultLength = clobBlobHandling(rightType, leftType);
0: 				break;
1: 			switch (rightTypeId.getJDBCTypeId()) {
1: 			case Types.CHAR: //operands CHAR(A) VARCHAR(B) and A+B>4000 then
1: 							 // result is LONG VARCHAR
1: 			case Types.VARCHAR: //operands VARCHAR(A) VARCHAR(B) and A+B>4000
1: 								// then result is LONG VARCHAR
1: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
0: 					higherType = TypeId.LONGVARCHAR_NAME;
0: 				break;
0: 			case Types.CLOB:
0: 				//operands VARCHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 				resultLength = clobBlobHandling(rightType, leftType);
0: 				break;
1: 			switch (rightTypeId.getJDBCTypeId()) {
1: 			case Types.BINARY: //operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT
1: 							   // DATA(B) and A+B>4000 then result is LONG
1: 							   // VARCHAR FOR BIT DATA
1: 			case Types.VARBINARY://operands VARCHAR FOR BIT DATA(A) VARCHAR FOR
1: 								 // BIT DATA(B) and A+B>4000 then result is LONG
1: 								 // VARCHAR FOR BIT DATA
1: 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
0: 					higherType = TypeId.LONGVARBIT_NAME;
0: 				break;
0: 			case Types.BLOB:
1: 				//operands VARCHAR FOR BIT DATA(A), BLOB(B) then result is
1: 				// BLOB(MIN(A+B,2G))
0: 				resultLength = clobBlobHandling(rightType, leftType);
0: 				break;
1: 		} else if (leftTypeId.getJDBCTypeId() == Types.CLOB
1: 				|| leftTypeId.getJDBCTypeId() == Types.BLOB) {
1: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is
1: 			// BLOB(MIN(A+B,2G))
1: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is
1: 			// BLOB(MIN(A+B,2G))
1: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is
1: 			// BLOB(MIN(A+32K,2G))
1: 		} else if (rightTypeId.getJDBCTypeId() == Types.CLOB
1: 				|| rightTypeId.getJDBCTypeId() == Types.BLOB) {
1: 			//operands LONG VARCHAR FOR BIT DATA, BLOB(A) then result is
1: 			// BLOB(MIN(A+32K,2G))
1: 		//bug - 5837. long varchar and long binary can't hold more data than
1: 		// their specific limits. If this length is violated by resulting
1: 		 * * Result Length can't be negative
0: 		 */
1: 		if (SanityManager.DEBUG) {
1: 			if (resultLength < 0) {
1: 				SanityManager
1: 						.THROWASSERT("There should not be an overflow of maximum length for any result type at this point. Overflow for BLOB/CLOB has already been handled earlier");
/////////////////////////////////////////////////////////////////////////
1: 		 * * Create a new DataTypeDescriptor that has the correct * type and
1: 		 * nullability. * * It's OK to call the implementation of the
1: 		 * DataTypeDescriptorFactory * here, because we're in the same package.
0: 		 */
1: 		DataTypeDescriptor returnDTD = new DataTypeDescriptor(TypeId
1: 				.getBuiltInTypeId(higherType), nullable, resultLength);
1: 		//Check if collation derivations and collation types of 2 operands
0: 		// match?
1: 		if (leftType.getCollationDerivation() != rightType
1: 				.getCollationDerivation()
1: 				|| leftType.getCollationType() != rightType.getCollationType())
0: 			returnDTD
0: 					.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_NONE);
/////////////////////////////////////////////////////////////////////////
0: 	 * for conatenation operator, we generate code as follows field = method(p1,
0: 	 * p2, field); what we are ensuring here is if field is null then initialize
0: 	 * it to NULL SQLxxx type. Because of the following, at execution time,
0: 	 * SQLxxx concatenate method do not have to worry about field coming in as
0: 	 * null
0: 	 */
0: 	protected void initializeResultField(ExpressionClassBuilder acb,
0: 			MethodBuilder mb, LocalField resultField) throws StandardException {
0: 		acb.generateNull(mb, getTypeCompiler(), getTypeServices()
0: 				.getCollationType());// yes, it is, hence create a NULL SQLxxx
0: 									 // type object and put that on stack
0: 		mb.getField(resultField); //so put it back on the stack
1: 	private static int clobBlobHandling(DataTypeDescriptor clobBlobType,
1: 			DataTypeDescriptor otherType) throws StandardException {
1: 		if (otherType.getTypeId().getJDBCTypeId() == Types.LONGVARCHAR
1: 				|| otherType.getTypeId().getJDBCTypeId() == Types.LONGVARBINARY) {
1: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is
1: 			// BLOB(MIN(A+32K,2G))
1: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is
1: 			// BLOB(MIN(A+B,2G))
1: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is
1: 			// BLOB(MIN(A+B,2G))
1: 			resultLength = clobBlobType.getMaximumWidth()
1: 					+ otherType.getMaximumWidth();
1: 			return (Integer.MAX_VALUE);
1: 			return (resultLength);
commit:244952e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 			
1: 			leftOperand.setType(new DataTypeDescriptor(leftType, true));
0: 			if (rightOperand.getTypeId().isStringTypeId())
0: 			{//collation of ? operand should be same as the other operand
0: 				leftOperand.getTypeServices().setCollationDerivation(
0: 					rightOperand.getTypeServices().getCollationDerivation());
0: 				leftOperand.getTypeServices().setCollationType(
0: 					rightOperand.getTypeServices().getCollationType());
0: 			}
/////////////////////////////////////////////////////////////////////////
0: 			rightOperand.setType(
0: 			if (leftOperand.getTypeId().isStringTypeId())
0: 			{//collation of ? operand should be same as the other operand
0: 				rightOperand.getTypeServices().setCollationDerivation(
0: 						leftOperand.getTypeServices().getCollationDerivation());
0: 				rightOperand.getTypeServices().setCollationType(
0: 						leftOperand.getTypeServices().getCollationType());
0: 			}
/////////////////////////////////////////////////////////////////////////
0: 		DataTypeDescriptor returnDTD = new DataTypeDescriptor(
0: 
0: 		//Check if collation derivations and collation types of 2 operands match?
1: 		//If they do, then the result of the concatenation will get the smae
1: 		//collation information. But if not, then the collation derivation of
1: 		//the result will be NONE.
0: 		if (leftType.getCollationDerivation() != rightType.getCollationDerivation()
0: 			|| leftType.getCollationType() != rightType.getCollationType())
0: 			returnDTD.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_NONE);
1: 		else {
0: 			returnDTD.setCollationDerivation(leftType.getCollationDerivation());
0: 			returnDTD.setCollationType(leftType.getCollationType());
0: 		}
1: 		return returnDTD;
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
0: 			acb.generateNull(mb, getTypeCompiler(),
0: 					getTypeServices().getCollationType());// yes, it is, hence create a NULL SQLxxx type object and put that on stack
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
0:    Licensed to the Apache Software Foundation (ASF) under one or more
0:    contributor license agreements.  See the NOTICE file distributed with
0:    this work for additional information regarding copyright ownership.
0:    The ASF licenses this file to you under the Apache License, Version 2.0
0:    (the "License"); you may not use this file except in compliance with
0:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 		if (leftOperand.requiresTypeFromContext())
0: 			if (rightOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 		leftOperand.setType(new DataTypeDescriptor(leftType, true));
0: 		if (rightOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 		rightOperand.setType(
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 					if (resultLength > Limits.DB2_CHAR_MAXWIDTH) {
/////////////////////////////////////////////////////////////////////////
0: 					if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH) {
/////////////////////////////////////////////////////////////////////////
0: 					if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
/////////////////////////////////////////////////////////////////////////
0: 					if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH)
commit:8809d55
/////////////////////////////////////////////////////////////////////////
0: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS,
0: 			** A ? on the left gets its type from the right.  There are eight
0: 			** LONG VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB.
0: 			** If the right type is BLOB, set the parameter type to BLOB with max length.
0: 			** If the right type is one of the other bit types, set the parameter type to
0: 			** If the right type is CLOB, set parameter type to CLOB with max length.
/////////////////////////////////////////////////////////////////////////
0: 			** clear to me what effect it would have to change it. -	Jeff
1: 				if (rightOperand.getTypeId().isBlobTypeId())
1: 					leftType = TypeId.getBuiltInTypeId(Types.BLOB);
0: 				else
0: 					leftType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1: 				if (rightOperand.getTypeId().isClobTypeId())
1: 					leftType = TypeId.getBuiltInTypeId(Types.CLOB);
0: 				else
0: 					leftType = TypeId.getBuiltInTypeId(Types.VARCHAR);
0: 
/////////////////////////////////////////////////////////////////////////
0: 			** A ? on the right gets its type from the left.  There are eight
0: 			** LONG VARCHAR, CLOB, BIT, BIT VARYING, LONG BIT VARYING, and BLOB.
0: 			** If the left type is BLOB, set the parameter type to BLOB with max length.
0: 			** If the left type is one of the other bit types, set the parameter type to
0: 			** BIT VARYING with maximum length.
0: 			**
0: 			** If the left type is CLOB, set parameter type to CLOB with max length.
0: 			** If the left type is anything else, set it to VARCHAR with
0: 			** maximum length.  We count on the resolveConcatOperation method to
0: 			** catch an illegal type.
0: 			** clear to me what effect it would have to change it. -	Jeff
1: 				if (leftOperand.getTypeId().isBlobTypeId())
1: 					rightType = TypeId.getBuiltInTypeId(Types.BLOB);
0: 				else
0: 					rightType = TypeId.getBuiltInTypeId(Types.VARBINARY);
1: 				if (leftOperand.getTypeId().isClobTypeId())
1: 					rightType = TypeId.getBuiltInTypeId(Types.CLOB);
0: 				else
0: 					rightType = TypeId.getBuiltInTypeId(Types.VARCHAR);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.ConcatableDataValue;
0: import org.apache.derby.iapi.types.BitDataValue;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import java.sql.Types;
0: 
0: import java.util.Vector;
0: 
0: 
0: /**
0:  * This node represents a concatenation comparison operator
0:  *
0:  * @author Jerry Brenner -- modified by jamie for bit and bit
0:  *							varying.
0:  */
0: 
0: public class ConcatenationOperatorNode extends BinaryOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * Initializer for a ConcatenationOperatorNode
0: 	 *
0: 	 * @param leftOperand	The left operand of the concatenation
0: 	 * @param rightOperand	The right operand of the concatenation
0: 	 */
0: 	public void init(Object leftOperand, Object rightOperand)
0: 	{
0: 		super.init(leftOperand, rightOperand, "||", "concatenate",
0: 				ClassName.ConcatableDataValue, ClassName.ConcatableDataValue);
0: 	}
0: 
0: 	/**
0: 	 * overrides BindOperatorNode.bindExpression because concatenation has special
0: 	 * requirements for parameter binding.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
0: 			throws StandardException
0: 	{
0: 		// deal with binding operands
0: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList,
0: 			aggregateVector);
0: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList,
0: 			aggregateVector);
0: 
0: 		// deal with operand parameters
0: 		/*
0: 			Is there a ? parameter on the left?
0: 			If so, it's type is the type of the other parameter, with
0: 			maximum length for that type.
0: 		*/
0: 
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			if (rightOperand.isParameterNode())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
0: 																	operator);
0: 			}
0: 
0: 			TypeId 	leftType;
0: 
0: 			/*
0: 			** A ? on the left gets its type from the right.  There are six
0: 			** legal types for the concatenation operator: CHAR, VARCHAR,
0: 			** LONG VARCHAR, BIT, BIT VARYING, and LONG BIT VARYING.  If the
0: 			** right type is one of the bit types, set the parameter type to
0: 			** BIT VARYING with maximum length.
0: 			**
0: 			** If the right type is anything else, set it to VARCHAR with
0: 			** maximum length.  We count on the resolveConcatOperation method to
0: 			** catch an illegal type.
0: 			**
0: 			** NOTE: When I added the long types, I could have changed the
0: 			** resulting parameter types to LONG VARCHAR and LONG BIT VARYING,
0: 			** but they were already VARCHAR and BIT VARYING, and it wasn't
0: 			** clear to me what effect it would have to change it.
0: 			**
0: 			**				-	Jeff
0: 			*/
0: 			if (rightOperand.getTypeId().isBitTypeId())
0: 			{
0: 				leftType = TypeId.getBuiltInTypeId(Types.VARBINARY);
0: 			}
0: 			else
0: 			{
0: 				leftType = TypeId.getBuiltInTypeId(Types.VARCHAR);
0: 			}
0: 		
0: 		((ParameterNode) leftOperand).setDescriptor(new DataTypeDescriptor(leftType, true));
0: 		}
0: 
0: 		/*
0: 			Is there a ? parameter on the right?
0: 		*/
0: 		if (rightOperand.isParameterNode())
0: 		{
0: 			TypeId 	rightType;
0: 
0: 			/*
0: 			** A ? on the right gets its type from the left.  There are six
0: 			** legal types for the concatenation operator: CHAR, VARCHAR,
0: 			** LONG VARCHAR, BIT, BIT VARYING, and LONG BIT VARYING.  If the
0: 			** left type is one of the bit types, set the parameter type to
0: 			** BIT VARYING with maximum length.  If the left type is anything
0: 			** else, set it to VARCHAR with maximum length.  We count on the
0: 			** resolveConcatOperation method to catch an illegal type.
0: 			**
0: 			** NOTE: When I added the long types, I could have changed the
0: 			** resulting parameter types to LONG VARCHAR and LONG BIT VARYING,
0: 			** but they were already VARCHAR and BIT VARYING, and it wasn't
0: 			** clear to me what effect it would have to change it.
0: 			**
0: 			**				-	Jeff
0: 			*/
0: 			if (leftOperand.getTypeId().isBitTypeId())
0: 			{
0: 				rightType = TypeId.getBuiltInTypeId(Types.VARBINARY);
0: 			}
0: 			else
0: 			{
0: 				rightType = TypeId.getBuiltInTypeId(Types.VARCHAR);
0: 			}
0: 		
0: 		((ParameterNode) rightOperand).setDescriptor(
0: 							new DataTypeDescriptor(
0: 										rightType,
0: 										true));
0: 		}
0: 
0: 		/* If the left operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (! leftOperand.getTypeId().systemBuiltIn())
0: 		{
0: 			leftOperand = leftOperand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		/* If the right operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (! rightOperand.getTypeId().systemBuiltIn())
0: 		{
0: 			rightOperand = rightOperand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		/* If either the left or right operands are non-string, non-bit types,
0: 		 * then we generate an implicit cast to VARCHAR.
0: 		 */
0: 		TypeCompiler tc = leftOperand.getTypeCompiler();
0: 		if (! (leftOperand.getTypeId().isStringTypeId() || leftOperand.getTypeId().isBitTypeId()))
0: 		{
0: 			leftOperand =  (ValueNode)
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						leftOperand, 
0: 						DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true, 
0: 										    tc.getCastToCharWidth(
0: 												leftOperand.getTypeServices())),
0: 						getContextManager());
0: 			((CastNode) leftOperand).bindCastNodeOnly();
0: 		}
0: 		tc = rightOperand.getTypeCompiler();
0: 		if (! (rightOperand.getTypeId().isStringTypeId() || rightOperand.getTypeId().isBitTypeId()))
0: 		{
0: 			rightOperand =  (ValueNode)
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						rightOperand, 
0: 						DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
0: 										    tc.getCastToCharWidth(
0: 												rightOperand.getTypeServices())),
0: 						getContextManager());
0: 			((CastNode) rightOperand).bindCastNodeOnly();
0: 		}
0: 
0: 
0: 		/*
0: 		** Set the result type of this operator based on the operands.
0: 		** By convention, the left operand gets to decide the result type
0: 		** of a binary operator.
0: 		*/
0: 		tc = leftOperand.getTypeCompiler();
0: 		setType(resolveConcatOperation(
0: 						leftOperand.getTypeServices(),
0: 						rightOperand.getTypeServices()));
0: 
0: 		/*
0: 		** Make sure the maximum width set for the result doesn't exceed the result type's maximum width
0: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (getTypeServices().getMaximumWidth() > getTypeId().getMaximumMaximumWidth())
0: 			{
0: 				SanityManager.THROWASSERT("The maximum length " + getTypeServices().getMaximumWidth() +
0: 						" for the result type " + getTypeId().getSQLTypeName() +
0: 						" can't be greater than it's maximum width of result's typeid" + getTypeId().getMaximumMaximumWidth());
0: 			}
0: 		}
0: 
0: 		/*
0: 		** Now that we know the target interface type, set it.  This assumes
0: 		** that both operands have the same interface type, which is a safe
0: 		** assumption for the concatenation operator.
0: 		*/
0: 		this.setLeftRightInterfaceType(tc.interfaceName());
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Resolve a concatenation operator
0: 	 *
0: 	 * @param leftType	The DataTypeDescriptor of the left operand
0: 	 * @param rightType	The DataTypeDescriptor of the right operand
0: 	 *
0: 	 * @return	A DataTypeDescriptor telling the result type of the 
0: 	 *			concatenate operation
0: 	 *
0: 	 * @exception StandardException BinaryOperatorNotSupported
0: 	 *						Thrown when a BinaryOperator is not supported
0: 	 *						on the operand types.
0: 	 */
0: 	private DataTypeDescriptor resolveConcatOperation(
0: 								DataTypeDescriptor leftType,
0: 								DataTypeDescriptor rightType
0: 							) throws StandardException
0: 	{
0: 		TypeId	leftTypeId;
0: 		TypeId	rightTypeId;
0: 		String	higherType;
0: 		int					resultLength;
0: 		boolean				nullable;
0: 
0: 		leftTypeId = leftType.getTypeId();
0: 		rightTypeId = rightType.getTypeId();
0: 
0: 		/*
0: 		** Check the right type to be sure it's a concatable.  By convention,
0: 		** we call this method off the TypeId of the left operand, so if
0: 		** we get here, we know the left operand is a concatable.
0: 		*/
0: 		/*
0: 		** Make sure we haven't been given a char and a
0: 		** bit to concatenate.
0: 		*/
0: 
0: 		if (!leftTypeId.isConcatableTypeId()
0: 			|| !rightTypeId.isConcatableTypeId()
0: 			|| (rightTypeId.isBitTypeId() && leftTypeId.isStringTypeId())
0: 			|| (leftTypeId.isBitTypeId() && rightTypeId.isStringTypeId()))
0: 				throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "||", "FUNCTION");
0: 
0: 		/*
0: 		** The types aren't the same.  The result of the operation is the
0: 		** type of higher precedence.
0: 		*/
0:     
0: 		higherType = (leftTypeId.typePrecedence() >=
0: 									rightTypeId.typePrecedence()) ?
0: 				leftType.getTypeName() : rightType.getTypeName();
0: 
0: 		/* Get the length of the result */
0: 		resultLength = leftType.getMaximumWidth() +
0: 					   rightType.getMaximumWidth();
0: 
0: 		/*
0: 		** Use following chart to handle overflow
0: 		** operands CHAR(A) CHAR(B) and A+B<255 then result is CHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B<255 then result is CHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) CHAR(B) and A+B>254 then result is VARCHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) VARCHAR(B) and A+B<4001 then result is VARCHAR(A+B)
0: 		** operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B<4001 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 		** operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands CHAR(A) LONG VARCHAR then result is LONG VARCHAR
0: 		** operands CHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands VARCHAR(A) VARCHAR(B) and A+B<4001 then result is VARCHAR(A+B)
0: 		** operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B<4001 then result is VARCHAR FOR BIT DATA(A+B)
0: 		**
0: 		** operands VARCHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 		** operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands VARCHAR(A) LONG VARCHAR then result is LONG VARCHAR
0: 		** operands VARCHAR FOR BIT DATA(A) LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands LONG VARCHAR, LONG VARCHAR then result is LONG VARCHAR
0: 		** operands LONG VARCHAR FOR BIT DATA, LONG VARCHAR FOR BIT DATA then result is LONG VARCHAR FOR BIT DATA
0: 		**
0: 		** operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
0: 		** operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
0: 		** operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
0: 		** operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 		**
0: 		** operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 		** operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 		** operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
0: 		** operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 		**
0: 		** operands CHAR(A)/VARCHAR(A)/LONGVARCHAR, LONGVARCHAR and "concatenated string length">32700 does not cause automatic escalation
0: 		** to LOB for compatibility with previous releases. Any such cases would result in an error at runtime
0: 		**
0: 		*/
0: 		//in the following code, I can assume that left and right operands both will be either char kind
0: 		//of datatypes or they will be both binary kind of datatypes. That's because operand datatypes
0: 		//mismatch has already been handled earlier
0: 		if (leftTypeId.getJDBCTypeId() == Types.CHAR || leftTypeId.getJDBCTypeId() == Types.BINARY)
0: 		{
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
0: 				case Types.CHAR:
0: 				case Types.BINARY:
0: 					if (resultLength > DB2Limit.DB2_CHAR_MAXWIDTH) {
0: 						if (rightTypeId.getJDBCTypeId() == Types.CHAR)
0: 								//operands CHAR(A) CHAR(B) and A+B>254 then result is VARCHAR(A+B)
0: 								higherType = TypeId.VARCHAR_NAME;
0: 						else
0: 								//operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B) and A+B>254 then result is VARCHAR FOR BIT DATA(A+B)
0: 								higherType = TypeId.VARBIT_NAME;
0: 					}
0: 					break;
0: 
0: 				case Types.VARCHAR:
0: 				case Types.VARBINARY:
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH) {
0: 						if (rightTypeId.getJDBCTypeId() == Types.VARCHAR)
0: 								//operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 								higherType = TypeId.LONGVARCHAR_NAME;
0: 						else
0: 								//operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 								higherType = TypeId.LONGVARBIT_NAME;
0: 					}
0: 					break;
0: 
0: 				case Types.CLOB:
0: 				case Types.BLOB:
0: 					//operands CHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 					//operands CHAR FOR BIT DATA(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 					resultLength = clobBlobHandling(rightType, leftType);
0: 					break;
0: 			}
0: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARCHAR) {
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
0: 				case Types.CHAR: //operands CHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 				case Types.VARCHAR: //operands VARCHAR(A) VARCHAR(B) and A+B>4000 then result is LONG VARCHAR
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH)
0: 						higherType = TypeId.LONGVARCHAR_NAME;
0: 					break;
0: 
0: 				case Types.CLOB:
0: 					//operands VARCHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 					resultLength = clobBlobHandling(rightType, leftType);
0: 					break;
0: 			}
0: 		} else if (leftTypeId.getJDBCTypeId() == Types.VARBINARY) {
0: 			switch (rightTypeId.getJDBCTypeId())
0: 			{
0: 				case Types.BINARY: //operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 				case Types.VARBINARY://operands VARCHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B) and A+B>4000 then result is LONG VARCHAR FOR BIT DATA
0: 					if (resultLength > DB2Limit.DB2_CONCAT_VARCHAR_LENGTH)
0: 						higherType = TypeId.LONGVARBIT_NAME;
0: 					break;
0: 
0: 				case Types.BLOB:
0: 					//operands VARCHAR FOR BIT DATA(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 					resultLength = clobBlobHandling(rightType, leftType);
0: 					break;
0: 			}
0: 		} else if (leftTypeId.getJDBCTypeId() == Types.CLOB || leftTypeId.getJDBCTypeId() == Types.BLOB) {
0: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
0: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
0: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 			resultLength = clobBlobHandling(leftType, rightType);
0: 		} else if (rightTypeId.getJDBCTypeId() == Types.CLOB || rightTypeId.getJDBCTypeId() == Types.BLOB) {
0: 			//operands LONG VARCHAR, CLOB(A) then result is CLOB(MIN(A+32K,2G))
0: 			//operands LONG VARCHAR FOR BIT DATA, BLOB(A) then result is BLOB(MIN(A+32K,2G))
0: 			resultLength = clobBlobHandling(rightType, leftType);
0: 		}
0: 
0: 		//bug - 5837. long varchar and long binary can't hold more data than their specific limits. If this length is violated by resulting
0: 		//concatenated string, an exception will be thrown at execute time.
0: 		if (higherType.equals(TypeId.LONGVARCHAR_NAME))
0: 			resultLength = TypeId.LONGVARCHAR_MAXWIDTH;
0: 		else if (higherType.equals(TypeId.LONGVARBIT_NAME))
0: 			resultLength = TypeId.LONGVARBIT_MAXWIDTH;
0: 
0: 
0: 		/*
0: 		** Result Length can't be negative
0: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (resultLength < 0)
0: 			{
0: 				SanityManager.THROWASSERT("There should not be an overflow of maximum length for any result type at this point. Overflow for BLOB/CLOB has already been handled earlier");
0: 			}
0: 		}
0: 
0: 		/* The result is nullable if either side is nullable */
0: 		nullable = leftType.isNullable() || rightType.isNullable();
0: 
0: 		/*
0: 		** Create a new DataTypeDescriptor that has the correct
0: 		** type and nullability.
0: 		**
0: 		** It's OK to call the implementation of the DataTypeDescriptorFactory
0: 		** here, because we're in the same package.
0: 		*/
0: 		return new DataTypeDescriptor(
0: 					TypeId.getBuiltInTypeId(higherType),
0: 					nullable,
0: 					resultLength
0: 				);
0: 	}
0: 
0: 	/*
0: 	 *for conatenation operator, we generate code as follows
0: 	 *field = method(p1, p2, field);
0: 	 *what we are ensuring here is if field is null then initialize it to NULL SQLxxx type.
0: 	 *Because of the following, at execution time, SQLxxx concatenate method do not have to
0: 	 *worry about field coming in as null
0: 	*/
0: 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
0: 	{
0: 		mb.conditionalIfNull();//get the field on the stack and if it is null
0: 			acb.generateNull(mb, getTypeCompiler());// yes, it is, hence create a NULL SQLxxx type object and put that on stack
0: 		mb.startElseCode(); //no, it is not null
0: 			mb.getField(resultField); //so put it back on the stack
0: 		mb.completeConditional(); //complete if else block
0: 	}
0: 
0: 	private static int clobBlobHandling(
0: 								DataTypeDescriptor clobBlobType,
0: 								DataTypeDescriptor otherType
0: 							) throws StandardException
0: 	{
0: 		int resultLength;
0: 
0: 		if (otherType.getTypeId().getJDBCTypeId() == Types.LONGVARCHAR ||
0: 			otherType.getTypeId().getJDBCTypeId() == Types.LONGVARBINARY) {
0: 			//operands CLOB(A), LONG VARCHAR then result is CLOB(MIN(A+32K,2G))
0: 			//operands BLOB(A), LONG VARCHAR FOR BIT DATA then result is BLOB(MIN(A+32K,2G))
0: 			resultLength = clobBlobType.getMaximumWidth() + 32768;
0: 		} else {
0: 			//operands CLOB(A), CHAR(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands CLOB(A), VARCHAR(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands CLOB(A), CLOB(B) then result is CLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), CHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), VARCHAR FOR BIT DATA(B) then result is BLOB(MIN(A+B,2G))
0: 			//operands BLOB(A), BLOB(B) then result is BLOB(MIN(A+B,2G))
0: 			resultLength = clobBlobType.getMaximumWidth() + otherType.getMaximumWidth();
0: 		}
0: 
0: 		if (resultLength < 1) //this mean A+B or A+32K is bigger than 2G
0: 			return(Integer.MAX_VALUE); 
0: 		else
0: 			return(resultLength);
0: 
0: 	}
0: }
============================================================================