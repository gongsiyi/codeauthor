3:eac0369: /*
27:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.InListOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
9:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.lang.reflect.Modifier;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:0b0252d: import org.apache.derby.iapi.services.loader.ClassFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * An InListOperatorNode represents an IN list.
4:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class InListOperatorNode extends BinaryListOperatorNode
4:eac0369: {
1:eac0369: 	private boolean isOrdered;
1:20bd3c0: 	private boolean sortDescending;
1:eac0369: 
1:3bb140c:     /**
1:3bb140c:      * @param leftOperand The left operand of the node
1:3bb140c:      * @param rightOperandList The right operand list of the node
1:3bb140c:      * @param cm Context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     InListOperatorNode(
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNodeList rightOperandList,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(leftOperand, rightOperandList, "IN", "in", cm);
1:3bb140c:     }
1:cbdc90c: 
1:3bb140c:     /**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "isOrdered: " + isOrdered + "\n" +
1:eac0369: 				super.toString();
5:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:4d09732: 	/**
1:7777c5d: 	 * Create a shallow copy of this InListOperatorNode whose operands are
1:7777c5d: 	 * the same as this node's operands.  Copy over all other necessary
1:7777c5d: 	 * state, as well.
1:7777c5d: 	 */
1:7777c5d: 	protected InListOperatorNode shallowCopy() throws StandardException
1:7777c5d: 	{
1:3bb140c:         InListOperatorNode ilon = new InListOperatorNode(
1:7777c5d: 				leftOperand,
1:7777c5d: 				rightOperandList,
1:7777c5d: 				getContextManager());
1:7777c5d: 
1:7777c5d: 		ilon.copyFields(this);
1:7777c5d: 		if (isOrdered)
1:7777c5d: 			ilon.markAsOrdered();
1:7777c5d: 
1:20bd3c0: 		if (sortDescending)
1:20bd3c0: 			ilon.markSortDescending();
1:20bd3c0: 
1:7777c5d: 		return ilon;
1:7777c5d: 	}
1:7777c5d: 
1:7777c5d: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		super.preprocess(numTables,
1:eac0369: 						 outerFromList, outerSubqueryList,
1:eac0369: 						 outerPredicateList);
1:eac0369: 
1:eac0369: 		/* Check for the degenerate case of a single element in the IN list.
1:eac0369: 		 * If found, then convert to "=".
1:eac0369: 		 */
1:eac0369: 		if (rightOperandList.size() == 1)
1:eac0369: 		{
2:eac0369: 			BinaryComparisonOperatorNode equal = 
1:3bb140c:                 new BinaryRelationalOperatorNode(
1:2706d1f:                     BinaryRelationalOperatorNode.K_EQUALS,
1:2706d1f:                     leftOperand,
1:2706d1f:                     rightOperandList.elementAt(0),
1:2706d1f:                     false,
1:2706d1f:                     getContextManager());
2:eac0369: 			/* Set type info for the operator node */
2:eac0369: 			equal.bindComparisonOperator();
2:eac0369: 			return equal;
1:7777c5d: 		}
1:4d09732: 
1:4d09732:         // DERBY-6017: All comparisons have to be performed using the dominant
1:4d09732:         // type of *all* the values in the left operand and the right operand.
1:4d09732:         // If either the left operand is of the dominant type, or all of the
1:4d09732:         // values in the right operand are of the dominant type, we know that
1:4d09732:         // each comparison will be performed using the dominant type.
1:4d09732:         // Otherwise, cast the left operand to the dominant type to ensure
1:4d09732:         // that each comparison operation will use the dominant type.
1:4d09732:         DataTypeDescriptor targetType = getDominantType();
1:4d09732:         int targetTypePrecedence = targetType.getTypeId().typePrecedence();
1:4d09732:         if ((leftOperand.getTypeServices().getTypeId().typePrecedence() !=
1:4d09732:                     targetTypePrecedence) &&
1:4d09732:                 !rightOperandList.allSamePrecendence(targetTypePrecedence)) {
1:3bb140c:             CastNode cn =
1:3bb140c:                     new CastNode(leftOperand, targetType, getContextManager());
1:4d09732:             cn.bindCastNodeOnly();
1:4d09732:             leftOperand = cn;
1:4d09732:         }
1:4d09732: 
1:4d09732:         if ((leftOperand instanceof ColumnReference) &&
1:7777c5d: 				 rightOperandList.containsOnlyConstantAndParamNodes())
1:eac0369: 		{
1:7777c5d: 			/* At this point we have an IN-list made up of constant and/or
1:7777c5d: 			 * parameter values.  Ex.:
1:7777c5d: 			 *
1:7777c5d: 			 *  select id, name from emp where id in (34, 28, ?)
1:7777c5d: 			 *
1:7777c5d: 			 * Since the optimizer does not recognize InListOperatorNodes
1:7777c5d: 			 * as potential start/stop keys for indexes, it (the optimizer)
1:7777c5d: 			 * may estimate that the cost of using any of the indexes would
1:7777c5d: 			 * be too high.  So we could--and probably would--end up doing
1:7777c5d: 			 * a table scan on the underlying base table. But if the number
1:7777c5d: 			 * of rows in the base table is significantly greater than the
1:7777c5d: 			 * number of values in the IN-list, scanning the base table can
1:7777c5d: 			 * be overkill and can lead to poor performance.  And further,
1:7777c5d: 			 * choosing to use an index but then scanning the entire index
1:7777c5d: 			 * can be slow, too. DERBY-47.
1:7777c5d: 			 *
1:7777c5d: 			 * What we do, then, is create an "IN-list probe predicate",
1:7777c5d: 			 * which is an internally generated equality predicate with a
1:7777c5d: 			 * parameter value on the right.  So for the query shown above
1:7777c5d: 			 * the probe predicate would be "id = ?".  We then replace
1:7777c5d: 			 * this InListOperatorNode with the probe predicate during
1:7777c5d: 			 * optimization.  The optimizer in turn recognizes the probe
1:7777c5d: 			 * predicate, which is disguised to look like a typical binary
1:7777c5d: 			 * equality, as a potential start/stop key for any indexes.
1:7777c5d: 			 * This start/stop key potential then factors into the estimated
1:7777c5d: 			 * cost of probing the indexes, which leads to a more reasonable
1:7777c5d: 			 * estimate and thus makes it more likely that the optimizer
1:7777c5d: 			 * will choose to use an index vs a table scan.  That done, we
1:7777c5d: 			 * then use the probe predicate to perform multiple execution-
1:7777c5d: 			 * time "probes" on the index--instead of doing a range index
1:7777c5d: 			 * scan--which eliminates unnecessary scanning. For more see
1:7777c5d: 			 * execute/MultiProbeTableScanResultSet.java.
1:7777c5d: 			 *
1:7777c5d: 			 * With this approach we know that regardless of how large the
1:7777c5d: 			 * base table is, we'll only have to probe the index a max of
1:7777c5d: 			 * N times, where "N" is the size of the IN-list. If N is
1:7777c5d: 			 * significantly less than the number of rows in the table, or
1:7777c5d: 			 * is significantly less than the number of rows between the
1:7777c5d: 			 * min value and the max value in the IN-list, this selective
1:7777c5d: 			 * probing can save us a lot of time.
1:7777c5d: 			 *
1:7777c5d: 			 * Note: We will do fewer than N probes if there are duplicates
1:7777c5d: 			 * in the list.
1:7777c5d: 			 *
1:7777c5d: 			 * Note also that, depending on the relative size of the IN-list
1:7777c5d: 			 * verses the number of rows in the table, it may actually be
1:7777c5d: 			 * better to just do a table scan--especially if there are fewer
1:7777c5d: 			 * rows in the table than there are in the IN-list.  So even though
1:7777c5d: 			 * we create a "probe predicate" and pass it to the optimizer, it
1:7777c5d: 			 * (the optimizer) may still choose to do a table scan.  If that
1:7777c5d: 			 * happens then we'll "revert" the probe predicate back to its
1:7777c5d: 			 * original form (i.e. to this InListOperatorNode) during code
1:7777c5d: 			 * generation, and then we'll use it as a regular IN-list
1:7777c5d: 			 * restriction when it comes time to execute.
1:eac0369: 			 */
1:eac0369: 
1:7777c5d: 			boolean allConstants = rightOperandList.containsAllConstantNodes();
1:eac0369: 
1:7777c5d: 			/* If we have all constants then sort them now.  This allows us to
1:7777c5d: 			 * skip the sort at execution time (we have to sort them so that
1:7777c5d: 			 * we can eliminate duplicate IN-list values).  If we have one
1:7777c5d: 			 * or more parameter nodes then we do *not* sort the values here
1:7777c5d: 			 * because we do not (and cannot) know what values the parameter(s)
1:7777c5d: 			 * will have.  In that case we'll sort the values at execution
1:7777c5d: 			 * time. 
1:eac0369: 			 */
1:7777c5d: 			if (allConstants)
1:7777c5d: 			{
1:7777c5d: 				/* When sorting or choosing min/max in the list, if types
1:0b0252d: 				 * are not an exact match then we have to use the *dominant*
1:0b0252d: 				 * type across all values, where "all values" includes the
1:0b0252d: 				 * left operand.  Otherwise we can end up with incorrect
1:0b0252d: 				 * results.
1:0b0252d: 				 *
1:0b0252d: 				 * Note that it is *not* enough to just use the left operand's
1:0b0252d: 				 * type as the judge because we have no guarantee that the
1:0b0252d: 				 * left operand has the dominant type.  If, for example, the
1:0b0252d: 				 * left operand has type INTEGER and all (or any) values in
1:0b0252d: 				 * the IN list have type DECIMAL, use of the left op's type
1:0b0252d: 				 * would lead to comparisons with truncated values and could
1:0b0252d: 				 * therefore lead to an incorrect sort order. DERBY-2256.
1:0b0252d: 				 */
1:0b0252d:  
1:4d09732: 				/* Now sort the list in ascending order using the dominant
1:0b0252d: 				 * type found above.
1:7777c5d: 				 */
1:45535b5: 				DataValueDescriptor judgeODV = targetType.getNull();
1:7777c5d: 
1:7777c5d: 				rightOperandList.sortInAscendingOrder(judgeODV);
1:7777c5d: 				isOrdered = true;
1:7777c5d: 
1:e1f49ca:                 ValueNode minValue = rightOperandList.elementAt(0);
1:e1f49ca:                 ValueNode maxValue = rightOperandList.elementAt(
1:7777c5d: 						rightOperandList.size() - 1);
1:7777c5d: 
1:7777c5d: 				/* Handle the degenerate case where the min and the max
1:0b0252d: 				 * are the same value.  Note (again) that we need to do
1:0b0252d: 				 * this comparison using the dominant type found above.
1:7777c5d: 				 */
1:7777c5d: 				DataValueDescriptor minODV =
1:7777c5d: 					((ConstantNode) minValue).getValue();
1:7777c5d: 				DataValueDescriptor maxODV =
1:7777c5d: 					 ((ConstantNode) maxValue).getValue();
1:7777c5d: 
1:0b0252d: 				if (judgeODV.equals(minODV, maxODV).equals(true))
1:7777c5d: 				{
1:7777c5d: 					BinaryComparisonOperatorNode equal = 
1:3bb140c:                         new BinaryRelationalOperatorNode(
1:2706d1f:                             BinaryRelationalOperatorNode.K_EQUALS,
1:4d09732: 							leftOperand, 
1:2e57170: 							minValue,
1:3bb140c:                             false,
1:4d09732: 							getContextManager());
1:7777c5d: 					/* Set type info for the operator node */
1:7777c5d: 					equal.bindComparisonOperator();
1:7777c5d: 					return equal;
1:2e57170: 				}
1:7777c5d: 			}
1:2e57170: 
1:7777c5d: 			/* Create a parameter node to serve as the right operand of
1:7777c5d: 			 * the probe predicate.  We intentionally use a parameter node
1:7777c5d: 			 * instead of a constant node because the IN-list has more than
1:7777c5d: 			 * one value (some of which may be unknown at compile time, i.e.
1:7777c5d: 			 * if they are parameters), so we don't want an estimate based
1:7777c5d: 			 * on any single literal.  Instead we want a generic estimate
1:7777c5d: 			 * of the cost to retrieve the rows matching some _unspecified_
1:7777c5d: 			 * value (namely, one of the values in the IN-list, but we
1:7777c5d: 			 * don't know which one).  That's exactly what a parameter
1:7777c5d: 			 * node gives us.
1:7777c5d: 			 *
1:7777c5d: 			 * Note: If the IN-list only had a single value then we would
1:7777c5d: 			 * have taken the "if (rightOperandList.size() == 1)" branch
1:7777c5d: 			 * above and thus would not be here.
1:7777c5d: 			 *
1:7777c5d: 			 * We create the parameter node based on the first value in
1:7777c5d: 			 * the list.  This is arbitrary and should not matter in the
1:7777c5d: 			 * big picture.
1:eac0369: 			 */
1:e1f49ca:             ValueNode srcVal = rightOperandList.elementAt(0);
1:3bb140c:             ParameterNode pNode = new ParameterNode(
1:3bb140c:                     0,
1:7777c5d: 					null, // default value
1:2e57170: 					getContextManager());
1:eac0369: 
1:7777c5d: 			DataTypeDescriptor pType = srcVal.getTypeServices();
1:7777c5d: 			pNode.setType(pType);
1:eac0369: 
1:7777c5d: 			/* If we choose to use the new predicate for execution-time
1:7777c5d: 			 * probing then the right operand will function as a start-key
1:7777c5d: 			 * "place-holder" into which we'll store the different IN-list
1:7777c5d: 			 * values as we iterate through them.  This means we have to
1:7777c5d: 			 * generate a valid value for the parameter node--i.e. for the
1:7777c5d: 			 * right side of the probe predicate--in order to have a valid
1:7777c5d: 			 * execution-time placeholder.  To do that we pass the source
1:7777c5d: 			 * value from which we found the type down to the new, "fake"
1:7777c5d: 			 * parameter node.  Then, when it comes time to generate the
1:7777c5d: 			 * parameter node, we'll just generate the source value as our
1:7777c5d: 			 * place-holder.  See ParameterNode.generateExpression().
1:7777c5d: 			 *
1:7777c5d: 			 * Note: the actual value of the "place-holder" does not matter
1:7777c5d: 			 * because it will be clobbered by the various IN-list values
1:7777c5d: 			 * (which includes "srcVal" itself) as we iterate through them
1:7777c5d: 			 * during execution.
1:eac0369: 			 */
1:7777c5d: 			pNode.setValueToGenerate(srcVal);
1:eac0369: 
1:7777c5d: 			/* Finally, create the "column = ?" equality that serves as the
1:7777c5d: 			 * basis for the probe predicate.  We store a reference to "this"
1:7777c5d: 			 * node inside the probe predicate so that, if we later decide
1:7777c5d: 			 * *not* to use the probe predicate for execution time index
1:7777c5d: 			 * probing, we can revert it back to its original form (i.e.
1:7777c5d: 			 * to "this").
1:7777c5d: 			 */
1:7777c5d: 			BinaryComparisonOperatorNode equal = 
1:3bb140c:                 new BinaryRelationalOperatorNode(
1:2706d1f:                     BinaryRelationalOperatorNode.K_EQUALS,
2:7777c5d: 					leftOperand, 
1:7777c5d: 					pNode,
1:7777c5d: 					this,
1:3bb140c:                     false,
3:7777c5d: 					getContextManager());
1:7777c5d: 
1:7777c5d: 			/* Set type info for the operator node */
1:7777c5d: 			equal.bindComparisonOperator();
1:7777c5d: 			return equal;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:cbdc90c:     /**
1:4d09732:      * Get the dominant type of all the operands in this IN list.
1:4d09732:      * @return the type descriptor for the dominant type
1:4d09732:      * @see DataTypeDescriptor#getDominantType(DataTypeDescriptor, ClassFactory)
1:4d09732:      */
1:4d09732:     private DataTypeDescriptor getDominantType() {
1:4d09732:         DataTypeDescriptor targetType = leftOperand.getTypeServices();
1:4d09732:         TypeId judgeTypeId = targetType.getTypeId();
1:4d09732: 
1:4d09732:         if (!rightOperandList.allSamePrecendence(
1:4d09732:                 judgeTypeId.typePrecedence())) {
1:4d09732:             // Iterate through the entire list of values to find out
1:4d09732:             // what the dominant type is.
1:4d09732:             ClassFactory cf = getClassFactory();
1:e1f49ca: 
1:e1f49ca:             for (ValueNode vn : rightOperandList) {
1:4d09732:                 targetType = targetType.getDominantType(
1:4d09732:                         vn.getTypeServices(), cf);
1:4d09732:             }
1:4d09732:         }
1:4d09732: 
1:4d09732:         return targetType;
1:4d09732:     }
1:4d09732: 
1:eac0369: 	/**
1:eac0369: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1:eac0369: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1:eac0369: 	 * ComparisonOperators and boolean expressions.  We invert 
1:eac0369: 	 * ComparisonOperators and replace boolean expressions with 
1:eac0369: 	 * boolean expression = false.
1:eac0369: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1:eac0369: 	 * still could be NotNodes left in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:0b0252d: 	 */
1:3bb140c:     @Override
1:eac0369: 	ValueNode eliminateNots(boolean underNotNode) 
1:eac0369: 					throws StandardException
1:0b0252d: 	{
1:eac0369: 		BinaryComparisonOperatorNode leftBCO;
1:eac0369: 		BinaryComparisonOperatorNode rightBCO;
1:eac0369: 		int							 listSize = rightOperandList.size();
1:eac0369: 		ValueNode					 leftSide;
1:0b0252d: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(listSize > 0,
1:eac0369: 			"rightOperandList.size() is expected to be > 0");
1:eac0369: 
1:eac0369: 		if (! underNotNode)
1:eac0369: 		{
1:eac0369: 			return this;
1:0b0252d: 		}
1:eac0369: 
1:eac0369: 		/* we want to convert the IN List into = OR = ... as
1:eac0369: 		 * described below.  
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* Convert:
1:eac0369: 		 *		leftO IN rightOList.elementAt(0) , rightOList.elementAt(1) ...
1:eac0369: 		 * to:
1:eac0369: 		 *		leftO <> rightOList.elementAt(0) AND leftO <> rightOList.elementAt(1) ...
1:eac0369: 		 * NOTE - We do the conversion here since the single table clauses
1:eac0369: 		 * can be pushed down and the optimizer may eventually have a filter factor
1:eac0369: 		 * for <>.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* leftO <> rightOList.at(0) */
1:eac0369: 		/* If leftOperand is a ColumnReference, it may be remapped during optimization, and that
1:eac0369: 		 * requires each <> node to have a separate object.
1:eac0369: 		 */
1:eac0369: 		ValueNode leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
1:3bb140c:         leftBCO = new BinaryRelationalOperatorNode(
1:2706d1f:                 BinaryRelationalOperatorNode.K_NOT_EQUALS,
1:2706d1f:                 leftClone,
1:2706d1f:                 rightOperandList.elementAt(0),
1:2706d1f:                 false,
1:2706d1f:                 getContextManager());
1:eac0369: 		/* Set type info for the operator node */
1:eac0369: 		leftBCO.bindComparisonOperator();
1:eac0369: 
1:eac0369: 		leftSide = leftBCO;
1:eac0369: 
1:eac0369: 		for (int elemsDone = 1; elemsDone < listSize; elemsDone++)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			/* leftO <> rightOList.elementAt(elemsDone) */
1:eac0369: 			leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
1:3bb140c:             rightBCO = new BinaryRelationalOperatorNode(
1:2706d1f:                     BinaryRelationalOperatorNode.K_NOT_EQUALS,
1:2706d1f:                     leftClone,
1:2706d1f:                     rightOperandList.elementAt(elemsDone),
1:2706d1f:                     false,
1:2706d1f:                     getContextManager());
1:eac0369: 			/* Set type info for the operator node */
1:eac0369: 			rightBCO.bindComparisonOperator();
1:eac0369: 
2:eac0369: 			/* Create the AND */
1:3bb140c:             AndNode newAnd =
1:3bb140c:                     new AndNode(leftSide, rightBCO, getContextManager());
2:eac0369: 			newAnd.postBindFixup();
1:eac0369: 
1:eac0369: 			leftSide = newAnd;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return leftSide;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * See if this IN list operator is referencing the same table.
1:eac0369: 	 *
1:eac0369: 	 * @param cr	The column reference.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if in list references the same table as in cr.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     boolean selfReference(ColumnReference cr)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:e1f49ca:         for (ValueNode vn : rightOperandList)
1:eac0369: 		{
1:e1f49ca:             if (vn.getTablesReferenced().get(cr.getTableNumber())) {
1:eac0369: 				return true;
1:e1f49ca:             }
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The selectivity for an "IN" predicate is generally very small.
1:eac0369: 	 * This is an estimate applicable when in list are not all constants.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public double selectivity(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		return 0.3d;
1:eac0369: 	}
1:eac0369:  
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this IN list operator.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb The MethodBuilder the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:3bb140c:      */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		int			listSize = rightOperandList.size();
1:eac0369: 		String		resultTypeName;
1:eac0369: 		String		receiverType = ClassName.DataValueDescriptor;
1:eac0369: 	
1:eac0369: 		String		leftInterfaceType = ClassName.DataValueDescriptor;
1:eac0369: 		String		rightInterfaceType = ClassName.DataValueDescriptor + "[]";
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(listSize > 0,
1:eac0369: 				"listSize is expected to be > 0");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** There are 2 parts to the code generation for an IN list -
1:eac0369: 		** the code in the constructor and the code for the expression evaluation.
1:eac0369: 		** The code that gets generated for the constructor is:
1:eac0369: 		**		DataValueDescriptor[] field = new DataValueDescriptor[size];
1:eac0369: 		**	For each element in the IN list that is a constant, we also generate:
1:eac0369: 		**		field[i] = rightOperandList[i];
2:eac0369: 		**	
1:eac0369: 		** If the IN list is composed entirely of constants, then we generate the
1:eac0369: 		** the following:
1:eac0369: 		**		leftOperand.in(rightOperandList, leftOperand, isNullable(), ordered, result);
1:eac0369: 		**
1:eac0369: 		** Otherwise, we create a new method.  This method contains the 
1:eac0369: 		** assignment of the non-constant elements into the array and the call to the in()
1:eac0369: 		** method, which is in the new method's return statement.  We then return a call
1:eac0369: 		** to the new method.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		/* Figure out the result type name */
1:eac0369: 		resultTypeName = getTypeCompiler().interfaceName();
1:eac0369: 
1:eac0369: 		// Generate the code to build the array
1:cbdc90c: 		LocalField arrayField = generateListAsArray(acb, mb);
1:eac0369: 
1:cbdc90c: 		/*
1:cbdc90c: 		** Call the method for this operator.
1:cbdc90c: 		*/
1:cbdc90c: 		/*
1:cbdc90c: 		** Generate (field = <left expression>).  This assignment is
1:cbdc90c: 		** used as the receiver of the method call for this operator,
1:cbdc90c: 		** and the field is used as the left operand:
1:cbdc90c: 		**
1:cbdc90c: 		**	(field = <left expression>).method(field, <right expression>...)
1:cbdc90c: 		*/
1:cbdc90c: 
1:cbdc90c: 		//LocalField receiverField =
1:cbdc90c: 		//	acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
1:cbdc90c: 
1:cbdc90c: 		leftOperand.generateExpression(acb, mb);
1:cbdc90c: 		mb.dup();
1:cbdc90c: 		//mb.putField(receiverField); // instance for method call
1:cbdc90c: 		/*mb.getField(receiverField);*/ mb.upCast(leftInterfaceType); // first arg
1:cbdc90c: 		mb.getField(arrayField); // second arg
1:cbdc90c: 		mb.push(isOrdered); // third arg
1:cbdc90c: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
1:cbdc90c: 	}
1:cbdc90c: 
1:cbdc90c: 	/**
1:cbdc90c: 	 * Generate the code to create an array of DataValueDescriptors that
1:cbdc90c: 	 * will hold the IN-list values at execution time.  The array gets
1:cbdc90c: 	 * created in the constructor.  All constant elements in the array
1:cbdc90c: 	 * are initialized in the constructor.  All non-constant elements,
1:cbdc90c: 	 * if any, are initialized each time the IN list is evaluated.
1:cbdc90c: 	 *
1:cbdc90c: 	 * @param acb The ExpressionClassBuilder for the class we're generating
1:cbdc90c: 	 * @param mb The MethodBuilder the expression will go into
1:cbdc90c: 	 */
1:cbdc90c: 	protected LocalField generateListAsArray(ExpressionClassBuilder acb,
1:cbdc90c: 		MethodBuilder mb) throws StandardException
1:cbdc90c: 	{
1:cbdc90c: 		int listSize = rightOperandList.size();
1:cbdc90c: 		LocalField arrayField = acb.newFieldDeclaration(
1:cbdc90c: 			Modifier.PRIVATE, ClassName.DataValueDescriptor + "[]");
1:cbdc90c: 
1:eac0369: 		/* Assign the initializer to the DataValueDescriptor[] field */
1:eac0369: 		MethodBuilder cb = acb.getConstructor();
1:eac0369: 		cb.pushNewArray(ClassName.DataValueDescriptor, listSize);
1:afa871e: 		cb.setField(arrayField);
1:eac0369: 
1:eac0369: 		/* Set the array elements that are constant */
1:eac0369: 		int numConstants = 0;
1:eac0369: 		MethodBuilder nonConstantMethod = null;
1:eac0369: 		MethodBuilder currentConstMethod = cb;
1:eac0369: 		for (int index = 0; index < listSize; index++)
1:eac0369: 		{
1:eac0369: 			MethodBuilder setArrayMethod;
1:eac0369: 	
1:eac0369: 			if (rightOperandList.elementAt(index) instanceof ConstantNode)
1:eac0369: 			{
1:eac0369: 				numConstants++;
1:eac0369: 		
1:eac0369: 				/*if too many statements are added  to a  method, 
1:eac0369: 				*size of method can hit  65k limit, which will
1:eac0369: 				*lead to the class format errors at load time.
1:eac0369: 				*To avoid this problem, when number of statements added 
1:eac0369: 				*to a method is > 2048, remaing statements are added to  a new function
1:eac0369: 				*and called from the function which created the function.
1:eac0369: 				*See Beetle 5135 or 4293 for further details on this type of problem.
1:eac0369: 				*/
1:eac0369: 				if(currentConstMethod.statementNumHitLimit(1))
1:eac0369: 				{
1:eac0369: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
1:eac0369: 					currentConstMethod.pushThis();
1:eac0369: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
1:eac0369: 												  (String) null, 
1:eac0369: 												  genConstantMethod.getName(),
1:eac0369: 												  "void", 0);
1:eac0369: 					//if it is a generate function, close the metod.
1:eac0369: 					if(currentConstMethod != cb){
1:eac0369: 						currentConstMethod.methodReturn();
1:eac0369: 						currentConstMethod.complete();
1:eac0369: 					}
1:eac0369: 					currentConstMethod = genConstantMethod;
1:eac0369: 				}
1:eac0369: 				setArrayMethod = currentConstMethod;
1:eac0369: 			} else {
1:eac0369: 				if (nonConstantMethod == null)
1:eac0369: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
1:eac0369: 				setArrayMethod = nonConstantMethod;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			setArrayMethod.getField(arrayField); // first arg
1:e1f49ca:             rightOperandList.elementAt(index).generateExpression(acb, setArrayMethod);
1:cbdc90c: 			setArrayMethod.upCast(ClassName.DataValueDescriptor); // second arg
1:eac0369: 			setArrayMethod.setArrayElement(index);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//if a generated function was created to reduce the size of the methods close the functions.
1:eac0369: 		if(currentConstMethod != cb){
1:eac0369: 			currentConstMethod.methodReturn();
1:eac0369: 			currentConstMethod.complete();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (nonConstantMethod != null) {
1:eac0369: 			nonConstantMethod.methodReturn();
1:eac0369: 			nonConstantMethod.complete();
1:eac0369: 			mb.pushThis();
1:eac0369: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
1:eac0369: 		}
1:eac0369: 
1:cbdc90c: 		return arrayField;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate start/stop key for this IN list operator.  Bug 3858.
1:eac0369: 	 *
1:eac0369: 	 * @param isAsc		is the index ascending on the column in question
1:eac0369: 	 * @param isStartKey	are we generating start key or not
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb The MethodBuilder the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     void generateStartStopKey(boolean isAsc, boolean isStartKey,
1:eac0369: 									 ExpressionClassBuilder acb,
2:eac0369: 									 MethodBuilder mb)
1:eac0369: 											   throws StandardException
1:eac0369: 	{
1:eac0369: 		/* left side of the "in" operator is our "judge" when we try to get
1:eac0369: 		 * the min/max value of the operands on the right side.  Judge's type
1:eac0369: 		 * is important for us, and is input parameter to min/maxValue.
1:0d23c0d: 		 * We found in DERBY-6025(Wrong results with IN lists and indexes in 
1:0d23c0d: 		 * territory based collation) that we need to make sure that we also
1:0d23c0d: 		 * left operand's collation information with Judge object. The reason
1:0d23c0d: 		 * we are sending precision/scale etc along with type id and collation
1:0d23c0d: 		 * information is that DataTypeDescriptor constructor requires all
1:0d23c0d: 		 * those properties too along with the collation information.
1:eac0369: 		 */
1:eac0369: 		int leftTypeFormatId = leftOperand.getTypeId().getTypeFormatId();
1:0d23c0d: 		int leftPrecision = leftOperand.getTypeServices().getPrecision();
1:0d23c0d: 		int leftScale = leftOperand.getTypeServices().getScale();
1:0d23c0d: 		boolean leftIsNullable = leftOperand.getTypeServices().isNullable();
1:0d23c0d: 		int leftMaximumWidth = leftOperand.getTypeServices().getMaximumWidth();
1:0d23c0d: 		int leftCollationType = leftOperand.getTypeServices().getCollationType();
1:0d23c0d: 		int leftCollationDerivation = leftOperand.getTypeServices().getCollationDerivation();
1:eac0369: 		int leftJDBCTypeId = leftOperand.getTypeId().isUserDefinedTypeId() ?
1:eac0369: 								leftOperand.getTypeId().getJDBCTypeId() : -1;
1:eac0369: 
1:eac0369: 		int listSize = rightOperandList.size();
1:eac0369: 		int numLoops, numValInLastLoop, currentOpnd = 0;
1:eac0369: 
1:eac0369: 		/* We first calculate how many times (loops) we generate a call to
1:eac0369: 		 * min/maxValue function accumulatively, since each time it at most
1:eac0369: 		 * takes 4 input values.  An example of the calls generated will be:
1:eac0369: 		 * minVal(minVal(...minVal(minVal(v1,v2,v3,v4,judge), v5,v6,v7,judge),
1:eac0369: 		 *        ...), vn-1, vn, NULL, judge)
1:eac0369: 		 * Unused value parameters in the last call are filled with NULLs.
1:eac0369: 		 */
1:eac0369: 		if (listSize < 5)
1:eac0369: 		{
1:eac0369: 			numLoops = 1;
1:eac0369: 			numValInLastLoop = (listSize - 1) % 4 + 1;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			numLoops = (listSize - 5) / 3 + 2;
1:eac0369: 			numValInLastLoop = (listSize - 5) % 3 + 1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numLoops; i++)
1:eac0369: 		{
1:eac0369: 			/* generate value parameters of min/maxValue
1:eac0369: 			 */
1:eac0369: 			int numVals = (i == numLoops - 1) ? numValInLastLoop :
1:eac0369: 							  ((i == 0) ? 4 : 3);
1:eac0369: 			for (int j = 0; j < numVals; j++)
1:eac0369: 			{
1:e1f49ca:                 ValueNode vn = rightOperandList.elementAt(currentOpnd++);
1:eac0369: 				vn.generateExpression(acb, mb);
1:eac0369: 				mb.upCast(ClassName.DataValueDescriptor);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* since we have fixed number of input values (4), unused ones
1:eac0369: 			 * in the last loop are filled with NULLs
1:eac0369: 			 */
1:eac0369: 			int numNulls = (i < numLoops - 1) ? 0 :
1:eac0369: 							((i == 0) ? 4 - numValInLastLoop : 3 - numValInLastLoop);
1:eac0369: 			for (int j = 0; j < numNulls; j++)
1:eac0369: 				mb.pushNull(ClassName.DataValueDescriptor);
1:eac0369: 
1:eac0369: 			/* have to put judge's types in the end
1:eac0369: 			 */
1:eac0369: 			mb.push(leftTypeFormatId);
1:eac0369: 			mb.push(leftJDBCTypeId);
1:0d23c0d: 			mb.push(leftPrecision);
1:0d23c0d: 			mb.push(leftScale);
1:0d23c0d: 			mb.push(leftIsNullable);
1:0d23c0d: 			mb.push(leftMaximumWidth);
1:0d23c0d: 			mb.push(leftCollationType);
1:0d23c0d: 			mb.push(leftCollationDerivation);
1:eac0369: 
1:eac0369: 			/* decide to get min or max value
1:eac0369: 			 */
1:3bb140c:             String methodNam;
1:eac0369: 			if ((isAsc && isStartKey) || (! isAsc && ! isStartKey))
1:3bb140c:                 methodNam = "minValue";
1:eac0369: 			else
1:3bb140c:                 methodNam = "maxValue";
1:eac0369: 		
1:3bb140c:             mb.callMethod(
1:3bb140c:                 VMOpcode.INVOKESTATIC,
1:3bb140c:                 ClassName.BaseExpressionActivation,
1:3bb140c:                 methodNam,
1:3bb140c:                 ClassName.DataValueDescriptor,
1:0d23c0d:                 12);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7777c5d: 	 * Indicate that the IN-list values for this node are ordered (i.e. they
1:7777c5d: 	 * are all constants and they have been sorted).
1:7777c5d: 	 */
1:7777c5d: 	protected void markAsOrdered()
1:7777c5d: 	{
1:7777c5d: 		isOrdered = true;
1:7777c5d: 	}
1:7777c5d: 
1:7777c5d: 	/**
1:20bd3c0: 	 * Indicate that the IN-list values for this node must be sorted
1:20bd3c0: 	 * in DESCENDING order.  This only applies to in-list "multi-probing",
1:20bd3c0: 	 * where the rows are processed in the order of the IN list elements
1:20bd3c0: 	 * themselves.  In that case, any requirement to sort the rows in
1:20bd3c0: 	 * descending order means that the values in the IN list have to
1:20bd3c0: 	 * be sorted in descending order, as well.
1:20bd3c0: 	 */
1:20bd3c0: 	protected void markSortDescending()
1:20bd3c0: 	{
1:20bd3c0: 		sortDescending = true;
1:20bd3c0: 	}
1:20bd3c0: 
1:20bd3c0: 	/**
1:cbdc90c: 	 * Return whether or not the IN-list values for this node are ordered.
1:cbdc90c: 	 * This is used for determining whether or not we need to do an execution-
1:cbdc90c: 	 * time sort.
1:cbdc90c: 	 */
1:cbdc90c: 	protected boolean isOrdered()
1:cbdc90c: 	{
1:cbdc90c: 		return isOrdered;
1:cbdc90c: 	} 
1:20bd3c0: 
1:20bd3c0: 	/**
1:20bd3c0: 	 * Return whether or not the IN-list values for this node must be
1:20bd3c0: 	 * sorted in DESCENDING order.
1:20bd3c0: 	 */
1:20bd3c0: 	protected boolean sortDescending()
1:20bd3c0: 	{
1:20bd3c0: 		return sortDescending;
1:20bd3c0: 	} 
1:eac0369: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0d23c0d
/////////////////////////////////////////////////////////////////////////
1: 		 * We found in DERBY-6025(Wrong results with IN lists and indexes in 
1: 		 * territory based collation) that we need to make sure that we also
1: 		 * left operand's collation information with Judge object. The reason
1: 		 * we are sending precision/scale etc along with type id and collation
1: 		 * information is that DataTypeDescriptor constructor requires all
1: 		 * those properties too along with the collation information.
1: 		int leftPrecision = leftOperand.getTypeServices().getPrecision();
1: 		int leftScale = leftOperand.getTypeServices().getScale();
1: 		boolean leftIsNullable = leftOperand.getTypeServices().isNullable();
1: 		int leftMaximumWidth = leftOperand.getTypeServices().getMaximumWidth();
1: 		int leftCollationType = leftOperand.getTypeServices().getCollationType();
1: 		int leftCollationDerivation = leftOperand.getTypeServices().getCollationDerivation();
/////////////////////////////////////////////////////////////////////////
1: 			mb.push(leftPrecision);
1: 			mb.push(leftScale);
1: 			mb.push(leftIsNullable);
1: 			mb.push(leftMaximumWidth);
1: 			mb.push(leftCollationType);
1: 			mb.push(leftCollationDerivation);
/////////////////////////////////////////////////////////////////////////
1:                 12);
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0: 						Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0: 							Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0: 					Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0: 						Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0: 							Boolean.FALSE,
commit:63385d4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			pType.setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			pType.setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     BinaryRelationalOperatorNode.K_EQUALS,
1:                     leftOperand,
1:                     rightOperandList.elementAt(0),
1:                     false,
1:                     getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                             BinaryRelationalOperatorNode.K_EQUALS,
/////////////////////////////////////////////////////////////////////////
1:                     BinaryRelationalOperatorNode.K_EQUALS,
/////////////////////////////////////////////////////////////////////////
1:                 BinaryRelationalOperatorNode.K_NOT_EQUALS,
1:                 leftClone,
1:                 rightOperandList.elementAt(0),
1:                 false,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                     BinaryRelationalOperatorNode.K_NOT_EQUALS,
1:                     leftClone,
1:                     rightOperandList.elementAt(elemsDone),
1:                     false,
1:                     getContextManager());
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:                         rightOperandList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
1:                 ValueNode minValue = rightOperandList.elementAt(0);
1:                 ValueNode maxValue = rightOperandList.elementAt(
/////////////////////////////////////////////////////////////////////////
1:             ValueNode srcVal = rightOperandList.elementAt(0);
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (ValueNode vn : rightOperandList) {
/////////////////////////////////////////////////////////////////////////
0:                         rightOperandList.elementAt(0),
/////////////////////////////////////////////////////////////////////////
0:                             rightOperandList.elementAt(elemsDone),
/////////////////////////////////////////////////////////////////////////
1:         for (ValueNode vn : rightOperandList)
1:             if (vn.getTablesReferenced().get(cr.getTableNumber())) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             rightOperandList.elementAt(index).generateExpression(acb, setArrayMethod);
/////////////////////////////////////////////////////////////////////////
1:                 ValueNode vn = rightOperandList.elementAt(currentOpnd++);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param leftOperand The left operand of the node
1:      * @param rightOperandList The right operand list of the node
1:      * @param cm Context manager
1:      * @throws StandardException
1:      */
1:     InListOperatorNode(
1:             ValueNode leftOperand,
1:             ValueNodeList rightOperandList,
1:             ContextManager cm) throws StandardException {
1:         super(leftOperand, rightOperandList, "IN", "in", cm);
0:         setNodeType(C_NodeTypes.IN_LIST_OPERATOR_NODE);
1:     }
1:     /**
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         InListOperatorNode ilon = new InListOperatorNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:                 new BinaryRelationalOperatorNode(
1:                         false,
/////////////////////////////////////////////////////////////////////////
1:             CastNode cn =
1:                     new CastNode(leftOperand, targetType, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                         new BinaryRelationalOperatorNode(
1:                             false,
/////////////////////////////////////////////////////////////////////////
1:             ParameterNode pNode = new ParameterNode(
1:                     0,
/////////////////////////////////////////////////////////////////////////
1:                 new BinaryRelationalOperatorNode(
0:                     false,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         leftBCO = new BinaryRelationalOperatorNode(
0:                         (ValueNode)rightOperandList.elementAt(0),
0:                         false,
/////////////////////////////////////////////////////////////////////////
1:             rightBCO = new BinaryRelationalOperatorNode(
0:                             false,
1:             AndNode newAnd =
1:                     new AndNode(leftSide, rightBCO, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     boolean selfReference(ColumnReference cr)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      */
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             String methodNam;
1:                 methodNam = "minValue";
1:                 methodNam = "maxValue";
1:             mb.callMethod(
1:                 VMOpcode.INVOKESTATIC,
1:                 ClassName.BaseExpressionActivation,
1:                 methodNam,
1:                 ClassName.DataValueDescriptor,
0:                 6);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     void generateStartStopKey(boolean isAsc, boolean isStartKey,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:4d09732
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-6017: All comparisons have to be performed using the dominant
1:         // type of *all* the values in the left operand and the right operand.
1:         // If either the left operand is of the dominant type, or all of the
1:         // values in the right operand are of the dominant type, we know that
1:         // each comparison will be performed using the dominant type.
1:         // Otherwise, cast the left operand to the dominant type to ensure
1:         // that each comparison operation will use the dominant type.
1:         DataTypeDescriptor targetType = getDominantType();
1:         int targetTypePrecedence = targetType.getTypeId().typePrecedence();
1:         if ((leftOperand.getTypeServices().getTypeId().typePrecedence() !=
1:                     targetTypePrecedence) &&
1:                 !rightOperandList.allSamePrecendence(targetTypePrecedence)) {
0:             CastNode cn = (CastNode) getNodeFactory().getNode(
0:                     C_NodeTypes.CAST_NODE,
1:                     leftOperand,
0:                     targetType,
1:                     getContextManager());
1:             cn.bindCastNodeOnly();
1:             leftOperand = cn;
1:         }
1: 
1:         if ((leftOperand instanceof ColumnReference) &&
/////////////////////////////////////////////////////////////////////////
1: 				/* Now sort the list in ascending order using the dominant
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the dominant type of all the operands in this IN list.
1:      * @return the type descriptor for the dominant type
1:      * @see DataTypeDescriptor#getDominantType(DataTypeDescriptor, ClassFactory)
1:      */
1:     private DataTypeDescriptor getDominantType() {
1:         DataTypeDescriptor targetType = leftOperand.getTypeServices();
1:         TypeId judgeTypeId = targetType.getTypeId();
1: 
1:         if (!rightOperandList.allSamePrecendence(
1:                 judgeTypeId.typePrecedence())) {
1:             // Iterate through the entire list of values to find out
1:             // what the dominant type is.
1:             ClassFactory cf = getClassFactory();
0:             int sz = rightOperandList.size();
0:             for (int i = 0; i < sz; i++) {
0:                 ValueNode vn = (ValueNode) rightOperandList.elementAt(i);
1:                 targetType = targetType.getDominantType(
1:                         vn.getTypeServices(), cf);
1:             }
1:         }
1: 
1:         return targetType;
1:     }
1: 
commit:2e57170
/////////////////////////////////////////////////////////////////////////
0:                     int judgePrecedence = judgeODV.typePrecedence();
0:                     int leftPrecedence = leftOperand.getTypeServices()
0:                             .getTypeId().typePrecedence();
0:                     if (leftPrecedence != judgePrecedence &&
0:                             minODV.typePrecedence() != judgePrecedence) {
0:                         // DERBY-6017: If neither the minimum value nor the
0:                         // left operand is of the dominant type, cast the
0:                         // minimum value to the dominant type. Otherwise, the
0:                         // equals operation will be performed using a different
0:                         // type, which may not have the same ordering as the
0:                         // type used to sort the list, and it could produce
0:                         // unexpected results.
0:                         CastNode cn = (CastNode) getNodeFactory().getNode(
0:                                 C_NodeTypes.CAST_NODE,
1:                                 minValue,
0:                                 targetType,
1:                                 getContextManager());
0:                         cn.bindCastNodeOnly();
0:                         minValue = cn;
1:                     }
1: 
author:Army
-------------------------------------------------------------------------------
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 	private boolean sortDescending;
/////////////////////////////////////////////////////////////////////////
1: 		if (sortDescending)
1: 			ilon.markSortDescending();
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Indicate that the IN-list values for this node must be sorted
1: 	 * in DESCENDING order.  This only applies to in-list "multi-probing",
1: 	 * where the rows are processed in the order of the IN list elements
1: 	 * themselves.  In that case, any requirement to sort the rows in
1: 	 * descending order means that the values in the IN list have to
1: 	 * be sorted in descending order, as well.
1: 	 */
1: 	protected void markSortDescending()
1: 	{
1: 		sortDescending = true;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return whether or not the IN-list values for this node must be
1: 	 * sorted in DESCENDING order.
1: 	 */
1: 	protected boolean sortDescending()
1: 	{
1: 		return sortDescending;
1: 	} 
commit:0b0252d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.loader.ClassFactory;
/////////////////////////////////////////////////////////////////////////
1: 				 * are not an exact match then we have to use the *dominant*
1: 				 * type across all values, where "all values" includes the
1: 				 * left operand.  Otherwise we can end up with incorrect
1: 				 * results.
1: 				 *
1: 				 * Note that it is *not* enough to just use the left operand's
1: 				 * type as the judge because we have no guarantee that the
1: 				 * left operand has the dominant type.  If, for example, the
1: 				 * left operand has type INTEGER and all (or any) values in
1: 				 * the IN list have type DECIMAL, use of the left op's type
1: 				 * would lead to comparisons with truncated values and could
1: 				 * therefore lead to an incorrect sort order. DERBY-2256.
0: 				DataTypeDescriptor targetType = leftOperand.getTypeServices();
0: 				TypeId judgeTypeId = targetType.getTypeId();
1: 
0: 					/* Iterate through the entire list of values to find out
0: 					 * what the dominant type is.
1: 					 */
0: 					ClassFactory cf = getClassFactory();
0: 					int sz = rightOperandList.size();
0: 					for (int i = 0; i < sz; i++)
1: 					{
0: 						ValueNode vn = (ValueNode)rightOperandList.elementAt(i);
0: 						targetType =
0: 							targetType.getDominantType(
0: 								vn.getTypeServices(), cf);
1: 					}
0: 				/* Now wort the list in ascending order using the dominant
1: 				 * type found above.
1: 				 */
0: 				DataValueDescriptor judgeODV =
0: 					(DataValueDescriptor)targetType.getTypeId().getNull();
1: 
/////////////////////////////////////////////////////////////////////////
1: 				 * are the same value.  Note (again) that we need to do
1: 				 * this comparison using the dominant type found above.
1: 				if (judgeODV.equals(minODV, maxODV).equals(true))
commit:7777c5d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	 * Create a shallow copy of this InListOperatorNode whose operands are
1: 	 * the same as this node's operands.  Copy over all other necessary
1: 	 * state, as well.
1: 	 */
1: 	protected InListOperatorNode shallowCopy() throws StandardException
1: 	{
0: 		InListOperatorNode ilon =
0: 			 (InListOperatorNode)getNodeFactory().getNode(
0: 				C_NodeTypes.IN_LIST_OPERATOR_NODE,
1: 				leftOperand,
1: 				rightOperandList,
1: 				getContextManager());
1: 
1: 		ilon.copyFields(this);
1: 		if (isOrdered)
1: 			ilon.markAsOrdered();
1: 
1: 		return ilon;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 				 rightOperandList.containsOnlyConstantAndParamNodes())
1: 			/* At this point we have an IN-list made up of constant and/or
1: 			 * parameter values.  Ex.:
1: 			 *
1: 			 *  select id, name from emp where id in (34, 28, ?)
1: 			 *
1: 			 * Since the optimizer does not recognize InListOperatorNodes
1: 			 * as potential start/stop keys for indexes, it (the optimizer)
1: 			 * may estimate that the cost of using any of the indexes would
1: 			 * be too high.  So we could--and probably would--end up doing
1: 			 * a table scan on the underlying base table. But if the number
1: 			 * of rows in the base table is significantly greater than the
1: 			 * number of values in the IN-list, scanning the base table can
1: 			 * be overkill and can lead to poor performance.  And further,
1: 			 * choosing to use an index but then scanning the entire index
1: 			 * can be slow, too. DERBY-47.
1: 			 *
1: 			 * What we do, then, is create an "IN-list probe predicate",
1: 			 * which is an internally generated equality predicate with a
1: 			 * parameter value on the right.  So for the query shown above
1: 			 * the probe predicate would be "id = ?".  We then replace
1: 			 * this InListOperatorNode with the probe predicate during
1: 			 * optimization.  The optimizer in turn recognizes the probe
1: 			 * predicate, which is disguised to look like a typical binary
1: 			 * equality, as a potential start/stop key for any indexes.
1: 			 * This start/stop key potential then factors into the estimated
1: 			 * cost of probing the indexes, which leads to a more reasonable
1: 			 * estimate and thus makes it more likely that the optimizer
1: 			 * will choose to use an index vs a table scan.  That done, we
1: 			 * then use the probe predicate to perform multiple execution-
1: 			 * time "probes" on the index--instead of doing a range index
1: 			 * scan--which eliminates unnecessary scanning. For more see
1: 			 * execute/MultiProbeTableScanResultSet.java.
1: 			 *
1: 			 * With this approach we know that regardless of how large the
1: 			 * base table is, we'll only have to probe the index a max of
1: 			 * N times, where "N" is the size of the IN-list. If N is
1: 			 * significantly less than the number of rows in the table, or
1: 			 * is significantly less than the number of rows between the
1: 			 * min value and the max value in the IN-list, this selective
1: 			 * probing can save us a lot of time.
1: 			 *
1: 			 * Note: We will do fewer than N probes if there are duplicates
1: 			 * in the list.
1: 			 *
1: 			 * Note also that, depending on the relative size of the IN-list
1: 			 * verses the number of rows in the table, it may actually be
1: 			 * better to just do a table scan--especially if there are fewer
1: 			 * rows in the table than there are in the IN-list.  So even though
1: 			 * we create a "probe predicate" and pass it to the optimizer, it
1: 			 * (the optimizer) may still choose to do a table scan.  If that
1: 			 * happens then we'll "revert" the probe predicate back to its
1: 			 * original form (i.e. to this InListOperatorNode) during code
1: 			 * generation, and then we'll use it as a regular IN-list
1: 			 * restriction when it comes time to execute.
1: 			boolean allConstants = rightOperandList.containsAllConstantNodes();
1: 			/* If we have all constants then sort them now.  This allows us to
1: 			 * skip the sort at execution time (we have to sort them so that
1: 			 * we can eliminate duplicate IN-list values).  If we have one
1: 			 * or more parameter nodes then we do *not* sort the values here
1: 			 * because we do not (and cannot) know what values the parameter(s)
1: 			 * will have.  In that case we'll sort the values at execution
1: 			 * time. 
1: 			if (allConstants)
1: 				/* When sorting or choosing min/max in the list, if types
0: 				 * are not an exact match, we use the left operand's type
0: 				 * as the "judge", assuming that they are compatible, as
0: 				 * also the case with DB2.
1: 				 */
0: 				TypeId judgeTypeId = leftOperand.getTypeServices().getTypeId();
0: 				DataValueDescriptor judgeODV = null;  //no judge, no argument
0: 				if (!rightOperandList.allSamePrecendence(
0: 					judgeTypeId.typePrecedence()))
1: 				{
0: 					judgeODV = (DataValueDescriptor) judgeTypeId.getNull();
1: 				}
1:  
0: 				// Sort the list in ascending order
1: 				rightOperandList.sortInAscendingOrder(judgeODV);
1: 				isOrdered = true;
1: 
0: 				ValueNode minValue = (ValueNode)rightOperandList.elementAt(0);
0: 				ValueNode maxValue =
0: 					(ValueNode)rightOperandList.elementAt(
1: 						rightOperandList.size() - 1);
1: 
1: 				/* Handle the degenerate case where the min and the max
0: 				 * are the same value.
1: 				 */
1: 				DataValueDescriptor minODV =
1: 					((ConstantNode) minValue).getValue();
1: 				DataValueDescriptor maxODV =
1: 					 ((ConstantNode) maxValue).getValue();
1: 
0: 				if (((judgeODV == null) && (minODV.compare(maxODV) == 0)) ||
0: 					((judgeODV != null)
0: 						&& judgeODV.equals(minODV, maxODV).equals(true)))
1: 				{
1: 					BinaryComparisonOperatorNode equal = 
0: 						(BinaryComparisonOperatorNode)getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
1: 							leftOperand, 
0: 							minValue,
1: 							getContextManager());
1: 					/* Set type info for the operator node */
1: 					equal.bindComparisonOperator();
1: 					return equal;
1: 				}
1: 			/* Create a parameter node to serve as the right operand of
1: 			 * the probe predicate.  We intentionally use a parameter node
1: 			 * instead of a constant node because the IN-list has more than
1: 			 * one value (some of which may be unknown at compile time, i.e.
1: 			 * if they are parameters), so we don't want an estimate based
1: 			 * on any single literal.  Instead we want a generic estimate
1: 			 * of the cost to retrieve the rows matching some _unspecified_
1: 			 * value (namely, one of the values in the IN-list, but we
1: 			 * don't know which one).  That's exactly what a parameter
1: 			 * node gives us.
1: 			 *
1: 			 * Note: If the IN-list only had a single value then we would
1: 			 * have taken the "if (rightOperandList.size() == 1)" branch
1: 			 * above and thus would not be here.
1: 			 *
1: 			 * We create the parameter node based on the first value in
1: 			 * the list.  This is arbitrary and should not matter in the
1: 			 * big picture.
0: 			ValueNode srcVal = (ValueNode) rightOperandList.elementAt(0);
0: 			ParameterNode pNode =
0: 				(ParameterNode) getNodeFactory().getNode(
0: 					C_NodeTypes.PARAMETER_NODE,
0: 					new Integer(0),
1: 					null, // default value
1: 					getContextManager());
1: 			DataTypeDescriptor pType = srcVal.getTypeServices();
0: 			pNode.setDescriptors(new DataTypeDescriptor [] { pType });
1: 			pNode.setType(pType);
1: 			/* If we choose to use the new predicate for execution-time
1: 			 * probing then the right operand will function as a start-key
1: 			 * "place-holder" into which we'll store the different IN-list
1: 			 * values as we iterate through them.  This means we have to
1: 			 * generate a valid value for the parameter node--i.e. for the
1: 			 * right side of the probe predicate--in order to have a valid
1: 			 * execution-time placeholder.  To do that we pass the source
1: 			 * value from which we found the type down to the new, "fake"
1: 			 * parameter node.  Then, when it comes time to generate the
1: 			 * parameter node, we'll just generate the source value as our
1: 			 * place-holder.  See ParameterNode.generateExpression().
1: 			 *
1: 			 * Note: the actual value of the "place-holder" does not matter
1: 			 * because it will be clobbered by the various IN-list values
1: 			 * (which includes "srcVal" itself) as we iterate through them
1: 			 * during execution.
1: 			pNode.setValueToGenerate(srcVal);
1: 			/* Finally, create the "column = ?" equality that serves as the
1: 			 * basis for the probe predicate.  We store a reference to "this"
1: 			 * node inside the probe predicate so that, if we later decide
1: 			 * *not* to use the probe predicate for execution time index
1: 			 * probing, we can revert it back to its original form (i.e.
1: 			 * to "this").
1: 			 */
1: 			BinaryComparisonOperatorNode equal = 
0: 				(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 					C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
1: 					leftOperand, 
1: 					pNode,
1: 					this,
1: 					getContextManager());
1: 
1: 			/* Set type info for the operator node */
1: 			equal.bindComparisonOperator();
1: 			return equal;
/////////////////////////////////////////////////////////////////////////
1: 	 * Indicate that the IN-list values for this node are ordered (i.e. they
1: 	 * are all constants and they have been sorted).
1: 	 */
1: 	protected void markAsOrdered()
1: 	{
1: 		isOrdered = true;
1: 	}
1: 
1: 	/**
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: 		LocalField arrayField = generateListAsArray(acb, mb);
1: 		/*
1: 		** Call the method for this operator.
1: 		*/
1: 		/*
1: 		** Generate (field = <left expression>).  This assignment is
1: 		** used as the receiver of the method call for this operator,
1: 		** and the field is used as the left operand:
1: 		**
1: 		**	(field = <left expression>).method(field, <right expression>...)
1: 		*/
1: 
1: 		//LocalField receiverField =
1: 		//	acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
1: 
1: 		leftOperand.generateExpression(acb, mb);
1: 		mb.dup();
1: 		//mb.putField(receiverField); // instance for method call
1: 		/*mb.getField(receiverField);*/ mb.upCast(leftInterfaceType); // first arg
1: 		mb.getField(arrayField); // second arg
1: 		mb.push(isOrdered); // third arg
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
1: 	}
1: 
1: 	/**
1: 	 * Generate the code to create an array of DataValueDescriptors that
1: 	 * will hold the IN-list values at execution time.  The array gets
1: 	 * created in the constructor.  All constant elements in the array
1: 	 * are initialized in the constructor.  All non-constant elements,
1: 	 * if any, are initialized each time the IN list is evaluated.
1: 	 *
1: 	 * @param acb The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb The MethodBuilder the expression will go into
1: 	 */
1: 	protected LocalField generateListAsArray(ExpressionClassBuilder acb,
1: 		MethodBuilder mb) throws StandardException
1: 	{
1: 		int listSize = rightOperandList.size();
1: 		LocalField arrayField = acb.newFieldDeclaration(
1: 			Modifier.PRIVATE, ClassName.DataValueDescriptor + "[]");
1: 
/////////////////////////////////////////////////////////////////////////
1: 			setArrayMethod.upCast(ClassName.DataValueDescriptor); // second arg
/////////////////////////////////////////////////////////////////////////
1: 		return arrayField;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return whether or not the IN-list values for this node are ordered.
1: 	 * This is used for determining whether or not we need to do an execution-
1: 	 * time sort.
1: 	 */
1: 	protected boolean isOrdered()
1: 	{
1: 		return isOrdered;
1: 	} 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
commit:45535b5
/////////////////////////////////////////////////////////////////////////
1: 				DataValueDescriptor judgeODV = targetType.getNull();
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		cb.setField(arrayField);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.InListOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.lang.reflect.Modifier;
1: 
1: /**
1:  * An InListOperatorNode represents an IN list.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
1: public final class InListOperatorNode extends BinaryListOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private boolean isOrdered;
1: 
1: 	/**
0: 	 * Initializer for a InListOperatorNode
1: 	 *
0: 	 * @param leftOperand		The left operand of the node
0: 	 * @param rightOperandList	The right operand list of the node
1: 	 */
1: 
0: 	public void init(Object leftOperand, Object rightOperandList)
1: 	{
0: 		init(leftOperand, rightOperandList, "IN", "in");
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "isOrdered: " + isOrdered + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		super.preprocess(numTables,
1: 						 outerFromList, outerSubqueryList,
1: 						 outerPredicateList);
1: 
1: 		/* Check for the degenerate case of a single element in the IN list.
1: 		 * If found, then convert to "=".
1: 		 */
1: 		if (rightOperandList.size() == 1)
1: 		{
1: 			BinaryComparisonOperatorNode equal = 
0: 				(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 						leftOperand, 
0: 						(ValueNode) rightOperandList.elementAt(0),
0: 						getContextManager());
1: 			/* Set type info for the operator node */
1: 			equal.bindComparisonOperator();
1: 			return equal;
1: 		}
0: 		else if ((leftOperand instanceof ColumnReference) &&
0: 				 rightOperandList.containsAllConstantNodes())
1: 		{
0: 			/* When sorting or choosing min/max in the list, if types are not an exact
0: 			 * match, we use the left operand's type as the "judge", assuming that they
0: 			 * are compatible, as also the case with DB2.
1: 			 */
0: 			TypeId judgeTypeId = leftOperand.getTypeServices().getTypeId();
0: 			DataValueDescriptor judgeODV = null;  //no judge, no argument
0: 			if (! rightOperandList.allSamePrecendence(judgeTypeId.typePrecedence()))
0: 				judgeODV = (DataValueDescriptor) judgeTypeId.getNull();
1: 
0: 			//Sort the list in ascending order
0: 			rightOperandList.sortInAscendingOrder(judgeODV);
0: 			isOrdered = true;
1: 
0: 			/* If the leftOperand is a ColumnReference
0: 			 * and the IN list is all constants, then we generate
0: 			 * an additional BETWEEN clause of the form:
0: 			 *	CRClone BETWEEN minValue and maxValue
1: 			 */
0: 			ValueNode leftClone = leftOperand.getClone();
0: 			ValueNode minValue = (ValueNode) rightOperandList.elementAt(0);  //already sorted
0: 			ValueNode maxValue = (ValueNode) rightOperandList.elementAt(rightOperandList.size() - 1);
1: 
0: 			/* Handle the degenerate case where 
0: 			 * the min and the max are the same value.
1: 			 */
0: 			DataValueDescriptor minODV =
0: 				 ((ConstantNode) minValue).getValue();
0: 			DataValueDescriptor maxODV =
0: 				 ((ConstantNode) maxValue).getValue();
0: 			if ((judgeODV == null && minODV.compare(maxODV) == 0) ||
0: 				(judgeODV != null && judgeODV.equals(minODV, maxODV).equals(true)))
1: 			{
1: 				BinaryComparisonOperatorNode equal = 
0: 					(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 						leftOperand, 
0: 						minValue,
0: 						getContextManager());
1: 				/* Set type info for the operator node */
1: 				equal.bindComparisonOperator();
1: 				return equal;
1: 			}
1: 
0: 			// Build the Between
0: 			ValueNodeList vnl = (ValueNodeList) getNodeFactory().getNode(
0: 													C_NodeTypes.VALUE_NODE_LIST,
0: 													getContextManager());
0: 			vnl.addValueNode(minValue);
0: 			vnl.addValueNode(maxValue);
1: 
0: 			BetweenOperatorNode bon = 
0: 				(BetweenOperatorNode) getNodeFactory().getNode(
0: 									C_NodeTypes.BETWEEN_OPERATOR_NODE,
0: 									leftClone,
0: 									vnl,
0: 									getContextManager());
1: 
0: 			/* The transformed tree has to be normalized:
0: 			 *				AND
0: 			 *			   /   \
0: 			 *		IN LIST    AND
0: 			 *				   /   \
0: 			 *				  >=	AND
0: 			 *						/   \
0: 			 *					   <=	TRUE
1: 			 */
1: 
1: 			/* Create the AND */
0: 			AndNode newAnd;
1: 
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 									C_NodeTypes.AND_NODE,
0: 									this,
0: 									bon.preprocess(numTables,
0: 												   outerFromList,
0: 												   outerSubqueryList,
0: 												   outerPredicateList),
0: 									getContextManager());
1: 			newAnd.postBindFixup();
1: 
0: 			/* Mark this node as transformed so that we don't get
0: 			 * calculated into the selectivity mulitple times.
1: 			 */
0: 			setTransformed();
1: 
0: 			// Return new AndNode
0: 			return newAnd;
1: 		}
1: 		else
1: 		{
1: 			return this;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1: 	 * ComparisonOperators and boolean expressions.  We invert 
1: 	 * ComparisonOperators and replace boolean expressions with 
1: 	 * boolean expression = false.
1: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1: 	 * still could be NotNodes left in the tree.
1: 	 *
1: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	ValueNode eliminateNots(boolean underNotNode) 
1: 					throws StandardException
1: 	{
0: 		AndNode						 newAnd = null;
1: 		BinaryComparisonOperatorNode leftBCO;
1: 		BinaryComparisonOperatorNode rightBCO;
1: 		int							 listSize = rightOperandList.size();
1: 		ValueNode					 leftSide;
1: 
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(listSize > 0,
1: 			"rightOperandList.size() is expected to be > 0");
1: 
1: 		if (! underNotNode)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/* we want to convert the IN List into = OR = ... as
1: 		 * described below.  
1: 		 */
1: 
1: 		/* Convert:
1: 		 *		leftO IN rightOList.elementAt(0) , rightOList.elementAt(1) ...
1: 		 * to:
1: 		 *		leftO <> rightOList.elementAt(0) AND leftO <> rightOList.elementAt(1) ...
1: 		 * NOTE - We do the conversion here since the single table clauses
1: 		 * can be pushed down and the optimizer may eventually have a filter factor
1: 		 * for <>.
1: 		 */
1: 
1: 		/* leftO <> rightOList.at(0) */
1: 		/* If leftOperand is a ColumnReference, it may be remapped during optimization, and that
1: 		 * requires each <> node to have a separate object.
1: 		 */
1: 		ValueNode leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
0: 		leftBCO = (BinaryComparisonOperatorNode) 
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
0: 						leftClone,
0: 						(ValueNode) rightOperandList.elementAt(0),
0: 						getContextManager());
1: 		/* Set type info for the operator node */
1: 		leftBCO.bindComparisonOperator();
1: 
1: 		leftSide = leftBCO;
1: 
1: 		for (int elemsDone = 1; elemsDone < listSize; elemsDone++)
1: 		{
1: 
1: 			/* leftO <> rightOList.elementAt(elemsDone) */
1: 			leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
0: 			rightBCO = (BinaryComparisonOperatorNode) 
0: 						getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
0: 							leftClone,
0: 							(ValueNode) rightOperandList.elementAt(elemsDone),
0: 							getContextManager());
1: 			/* Set type info for the operator node */
1: 			rightBCO.bindComparisonOperator();
1: 
1: 			/* Create the AND */
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 												C_NodeTypes.AND_NODE,
0: 												leftSide,
0: 												rightBCO,
0: 												getContextManager());
1: 			newAnd.postBindFixup();
1: 
1: 			leftSide = newAnd;
1: 		}
1: 
1: 		return leftSide;
1: 	}
1: 
1: 	/**
1: 	 * See if this IN list operator is referencing the same table.
1: 	 *
1: 	 * @param cr	The column reference.
1: 	 *
1: 	 * @return	true if in list references the same table as in cr.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean selfReference(ColumnReference cr)
1: 		throws StandardException
1: 	{
0: 		int size = rightOperandList.size();
0: 		for (int i = 0; i < size; i++)
1: 		{
0: 			ValueNode vn = (ValueNode) rightOperandList.elementAt(i);
0: 			if (vn.getTablesReferenced().get(cr.getTableNumber()))
1: 				return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * The selectivity for an "IN" predicate is generally very small.
1: 	 * This is an estimate applicable when in list are not all constants.
1: 	 */
1: 	public double selectivity(Optimizable optTable)
1: 	{
1: 		return 0.3d;
1: 	}
1:  
1: 	/**
1: 	 * Do code generation for this IN list operator.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb The MethodBuilder the expression will go into
1: 	 *
0: 	 * @return	An Expression to evaluate this operator
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		int			listSize = rightOperandList.size();
1: 		String		resultTypeName;
1: 		String		receiverType = ClassName.DataValueDescriptor;
1: 	
1: 		String		leftInterfaceType = ClassName.DataValueDescriptor;
1: 		String		rightInterfaceType = ClassName.DataValueDescriptor + "[]";
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(listSize > 0,
1: 				"listSize is expected to be > 0");
1: 		}
1: 
1: 		/*
1: 		** There are 2 parts to the code generation for an IN list -
1: 		** the code in the constructor and the code for the expression evaluation.
1: 		** The code that gets generated for the constructor is:
1: 		**		DataValueDescriptor[] field = new DataValueDescriptor[size];
1: 		**	For each element in the IN list that is a constant, we also generate:
1: 		**		field[i] = rightOperandList[i];
1: 		**	
1: 		** If the IN list is composed entirely of constants, then we generate the
1: 		** the following:
1: 		**		leftOperand.in(rightOperandList, leftOperand, isNullable(), ordered, result);
1: 		**
1: 		** Otherwise, we create a new method.  This method contains the 
1: 		** assignment of the non-constant elements into the array and the call to the in()
1: 		** method, which is in the new method's return statement.  We then return a call
1: 		** to the new method.
1: 		*/
1: 
0: 		receiver = leftOperand;
1: 
1: 		/* Figure out the result type name */
1: 		resultTypeName = getTypeCompiler().interfaceName();
1: 
1: 		// Generate the code to build the array
0: 		LocalField arrayField =
0: 			acb.newFieldDeclaration(Modifier.PRIVATE, rightInterfaceType);
1: 
0: 		/* The array gets created in the constructor.
0: 		 * All constant elements in the array are initialized
0: 		 * in the constructor.  All non-constant elements, if any,
0: 		 * are initialized each time the IN list is evaluated.
1: 		 */
1: 		/* Assign the initializer to the DataValueDescriptor[] field */
1: 		MethodBuilder cb = acb.getConstructor();
1: 		cb.pushNewArray(ClassName.DataValueDescriptor, listSize);
0: 		cb.putField(arrayField);
0: 		cb.endStatement();
1: 
1: 		/* Set the array elements that are constant */
1: 		int numConstants = 0;
1: 		MethodBuilder nonConstantMethod = null;
1: 		MethodBuilder currentConstMethod = cb;
1: 		for (int index = 0; index < listSize; index++)
1: 		{
1: 			MethodBuilder setArrayMethod;
1: 	
1: 			if (rightOperandList.elementAt(index) instanceof ConstantNode)
1: 			{
1: 				numConstants++;
1: 		
1: 				/*if too many statements are added  to a  method, 
1: 				*size of method can hit  65k limit, which will
1: 				*lead to the class format errors at load time.
1: 				*To avoid this problem, when number of statements added 
1: 				*to a method is > 2048, remaing statements are added to  a new function
1: 				*and called from the function which created the function.
1: 				*See Beetle 5135 or 4293 for further details on this type of problem.
1: 				*/
1: 				if(currentConstMethod.statementNumHitLimit(1))
1: 				{
1: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
1: 					currentConstMethod.pushThis();
1: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
1: 												  (String) null, 
1: 												  genConstantMethod.getName(),
1: 												  "void", 0);
1: 					//if it is a generate function, close the metod.
1: 					if(currentConstMethod != cb){
1: 						currentConstMethod.methodReturn();
1: 						currentConstMethod.complete();
1: 					}
1: 					currentConstMethod = genConstantMethod;
1: 				}
1: 				setArrayMethod = currentConstMethod;
1: 			} else {
1: 				if (nonConstantMethod == null)
1: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
1: 				setArrayMethod = nonConstantMethod;
1: 
1: 			}
1: 
1: 			setArrayMethod.getField(arrayField); // first arg
0: 			((ValueNode) rightOperandList.elementAt(index)).generateExpression(acb, setArrayMethod);
0: 			setArrayMethod.upCast(receiverType); // second arg
1: 			setArrayMethod.setArrayElement(index);
1: 		}
1: 
1: 		//if a generated function was created to reduce the size of the methods close the functions.
1: 		if(currentConstMethod != cb){
1: 			currentConstMethod.methodReturn();
1: 			currentConstMethod.complete();
1: 		}
1: 
1: 		if (nonConstantMethod != null) {
1: 			nonConstantMethod.methodReturn();
1: 			nonConstantMethod.complete();
1: 			mb.pushThis();
1: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
1: 		}
1: 
1: 		/*
0: 		** Call the method for this operator.
1: 		*/
1: 		/*
0: 		** Generate (field = <left expression>).  This assignment is
0: 		** used as the receiver of the method call for this operator,
0: 		** and the field is used as the left operand:
1: 		**
0: 		**	(field = <left expression>).method(field, <right expression>...)
1: 		*/
1: 
0: 		//LocalField receiverField =
0: 		//	acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
1: 
0: 		leftOperand.generateExpression(acb, mb);
0: 		mb.dup();
0: 		//mb.putField(receiverField); // instance for method call
0: 		/*mb.getField(receiverField);*/ mb.upCast(leftInterfaceType); // first arg
0: 		mb.getField(arrayField); // second arg
0: 		mb.push(isOrdered); // third arg
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
1: 
1: 
1: 	}
1: 
1: 
1: 	/**
1: 	 * Generate start/stop key for this IN list operator.  Bug 3858.
1: 	 *
1: 	 * @param isAsc		is the index ascending on the column in question
1: 	 * @param isStartKey	are we generating start key or not
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb The MethodBuilder the expression will go into
1: 	 *
0: 	 * @return	nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateStartStopKey(boolean isAsc, boolean isStartKey,
1: 									 ExpressionClassBuilder acb,
1: 									 MethodBuilder mb)
1: 											   throws StandardException
1: 	{
1: 		/* left side of the "in" operator is our "judge" when we try to get
1: 		 * the min/max value of the operands on the right side.  Judge's type
1: 		 * is important for us, and is input parameter to min/maxValue.
1: 		 */
1: 		int leftTypeFormatId = leftOperand.getTypeId().getTypeFormatId();
1: 		int leftJDBCTypeId = leftOperand.getTypeId().isUserDefinedTypeId() ?
1: 								leftOperand.getTypeId().getJDBCTypeId() : -1;
1: 
1: 		int listSize = rightOperandList.size();
1: 		int numLoops, numValInLastLoop, currentOpnd = 0;
1: 
1: 		/* We first calculate how many times (loops) we generate a call to
1: 		 * min/maxValue function accumulatively, since each time it at most
1: 		 * takes 4 input values.  An example of the calls generated will be:
1: 		 * minVal(minVal(...minVal(minVal(v1,v2,v3,v4,judge), v5,v6,v7,judge),
1: 		 *        ...), vn-1, vn, NULL, judge)
1: 		 * Unused value parameters in the last call are filled with NULLs.
1: 		 */
1: 		if (listSize < 5)
1: 		{
1: 			numLoops = 1;
1: 			numValInLastLoop = (listSize - 1) % 4 + 1;
1: 		}
1: 		else
1: 		{
1: 			numLoops = (listSize - 5) / 3 + 2;
1: 			numValInLastLoop = (listSize - 5) % 3 + 1;
1: 		}
1: 
1: 		for (int i = 0; i < numLoops; i++)
1: 		{
1: 			/* generate value parameters of min/maxValue
1: 			 */
1: 			int numVals = (i == numLoops - 1) ? numValInLastLoop :
1: 							  ((i == 0) ? 4 : 3);
1: 			for (int j = 0; j < numVals; j++)
1: 			{
0: 				ValueNode vn = (ValueNode) rightOperandList.elementAt(currentOpnd++);
1: 				vn.generateExpression(acb, mb);
1: 				mb.upCast(ClassName.DataValueDescriptor);
1: 			}
1: 
1: 			/* since we have fixed number of input values (4), unused ones
1: 			 * in the last loop are filled with NULLs
1: 			 */
1: 			int numNulls = (i < numLoops - 1) ? 0 :
1: 							((i == 0) ? 4 - numValInLastLoop : 3 - numValInLastLoop);
1: 			for (int j = 0; j < numNulls; j++)
1: 				mb.pushNull(ClassName.DataValueDescriptor);
1: 
1: 			/* have to put judge's types in the end
1: 			 */
1: 			mb.push(leftTypeFormatId);
1: 			mb.push(leftJDBCTypeId);
1: 
1: 			/* decide to get min or max value
1: 			 */
0: 			String methodName;
1: 			if ((isAsc && isStartKey) || (! isAsc && ! isStartKey))
0: 				methodName = "minValue";
1: 			else
0: 				methodName = "maxValue";
1: 		
0: 			mb.callMethod(VMOpcode.INVOKESTATIC, ClassName.BaseExpressionActivation, methodName, ClassName.DataValueDescriptor, 6);
1: 
1: 		}
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: /**
0:  * An InListOperatorNode represents an IN list.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public final class InListOperatorNode extends BinaryListOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private boolean isOrdered;
0: 
0: 	/**
0: 	 * Initializer for a InListOperatorNode
0: 	 *
0: 	 * @param leftOperand		The left operand of the node
0: 	 * @param rightOperandList	The right operand list of the node
0: 	 */
0: 
0: 	public void init(Object leftOperand, Object rightOperandList)
0: 	{
0: 		init(leftOperand, rightOperandList, "IN", "in");
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "isOrdered: " + isOrdered + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		super.preprocess(numTables,
0: 						 outerFromList, outerSubqueryList,
0: 						 outerPredicateList);
0: 
0: 		/* Check for the degenerate case of a single element in the IN list.
0: 		 * If found, then convert to "=".
0: 		 */
0: 		if (rightOperandList.size() == 1)
0: 		{
0: 			BinaryComparisonOperatorNode equal = 
0: 				(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 						leftOperand, 
0: 						(ValueNode) rightOperandList.elementAt(0),
0: 						getContextManager());
0: 			/* Set type info for the operator node */
0: 			equal.bindComparisonOperator();
0: 			return equal;
0: 		}
0: 		else if ((leftOperand instanceof ColumnReference) &&
0: 				 rightOperandList.containsAllConstantNodes())
0: 		{
0: 			/* When sorting or choosing min/max in the list, if types are not an exact
0: 			 * match, we use the left operand's type as the "judge", assuming that they
0: 			 * are compatible, as also the case with DB2.
0: 			 */
0: 			TypeId judgeTypeId = leftOperand.getTypeServices().getTypeId();
0: 			DataValueDescriptor judgeODV = null;  //no judge, no argument
0: 			if (! rightOperandList.allSamePrecendence(judgeTypeId.typePrecedence()))
0: 				judgeODV = (DataValueDescriptor) judgeTypeId.getNull();
0: 
0: 			//Sort the list in ascending order
0: 			rightOperandList.sortInAscendingOrder(judgeODV);
0: 			isOrdered = true;
0: 
0: 			/* If the leftOperand is a ColumnReference
0: 			 * and the IN list is all constants, then we generate
0: 			 * an additional BETWEEN clause of the form:
0: 			 *	CRClone BETWEEN minValue and maxValue
0: 			 */
0: 			ValueNode leftClone = leftOperand.getClone();
0: 			ValueNode minValue = (ValueNode) rightOperandList.elementAt(0);  //already sorted
0: 			ValueNode maxValue = (ValueNode) rightOperandList.elementAt(rightOperandList.size() - 1);
0: 
0: 			/* Handle the degenerate case where 
0: 			 * the min and the max are the same value.
0: 			 */
0: 			DataValueDescriptor minODV =
0: 				 ((ConstantNode) minValue).getValue();
0: 			DataValueDescriptor maxODV =
0: 				 ((ConstantNode) maxValue).getValue();
0: 			if ((judgeODV == null && minODV.compare(maxODV) == 0) ||
0: 				(judgeODV != null && judgeODV.equals(minODV, maxODV).equals(true)))
0: 			{
0: 				BinaryComparisonOperatorNode equal = 
0: 					(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 						leftOperand, 
0: 						minValue,
0: 						getContextManager());
0: 				/* Set type info for the operator node */
0: 				equal.bindComparisonOperator();
0: 				return equal;
0: 			}
0: 
0: 			// Build the Between
0: 			ValueNodeList vnl = (ValueNodeList) getNodeFactory().getNode(
0: 													C_NodeTypes.VALUE_NODE_LIST,
0: 													getContextManager());
0: 			vnl.addValueNode(minValue);
0: 			vnl.addValueNode(maxValue);
0: 
0: 			BetweenOperatorNode bon = 
0: 				(BetweenOperatorNode) getNodeFactory().getNode(
0: 									C_NodeTypes.BETWEEN_OPERATOR_NODE,
0: 									leftClone,
0: 									vnl,
0: 									getContextManager());
0: 
0: 			/* The transformed tree has to be normalized:
0: 			 *				AND
0: 			 *			   /   \
0: 			 *		IN LIST    AND
0: 			 *				   /   \
0: 			 *				  >=	AND
0: 			 *						/   \
0: 			 *					   <=	TRUE
0: 			 */
0: 
0: 			/* Create the AND */
0: 			AndNode newAnd;
0: 
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 									C_NodeTypes.AND_NODE,
0: 									this,
0: 									bon.preprocess(numTables,
0: 												   outerFromList,
0: 												   outerSubqueryList,
0: 												   outerPredicateList),
0: 									getContextManager());
0: 			newAnd.postBindFixup();
0: 
0: 			/* Mark this node as transformed so that we don't get
0: 			 * calculated into the selectivity mulitple times.
0: 			 */
0: 			setTransformed();
0: 
0: 			// Return new AndNode
0: 			return newAnd;
0: 		}
0: 		else
0: 		{
0: 			return this;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
0: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
0: 	 * ComparisonOperators and boolean expressions.  We invert 
0: 	 * ComparisonOperators and replace boolean expressions with 
0: 	 * boolean expression = false.
0: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
0: 	 * still could be NotNodes left in the tree.
0: 	 *
0: 	 * @param	underNotNode		Whether or not we are under a NotNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	ValueNode eliminateNots(boolean underNotNode) 
0: 					throws StandardException
0: 	{
0: 		AndNode						 newAnd = null;
0: 		BinaryComparisonOperatorNode leftBCO;
0: 		BinaryComparisonOperatorNode rightBCO;
0: 		int							 listSize = rightOperandList.size();
0: 		ValueNode					 leftSide;
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(listSize > 0,
0: 			"rightOperandList.size() is expected to be > 0");
0: 
0: 		if (! underNotNode)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* we want to convert the IN List into = OR = ... as
0: 		 * described below.  
0: 		 */
0: 
0: 		/* Convert:
0: 		 *		leftO IN rightOList.elementAt(0) , rightOList.elementAt(1) ...
0: 		 * to:
0: 		 *		leftO <> rightOList.elementAt(0) AND leftO <> rightOList.elementAt(1) ...
0: 		 * NOTE - We do the conversion here since the single table clauses
0: 		 * can be pushed down and the optimizer may eventually have a filter factor
0: 		 * for <>.
0: 		 */
0: 
0: 		/* leftO <> rightOList.at(0) */
0: 		/* If leftOperand is a ColumnReference, it may be remapped during optimization, and that
0: 		 * requires each <> node to have a separate object.
0: 		 */
0: 		ValueNode leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
0: 		leftBCO = (BinaryComparisonOperatorNode) 
0: 					getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
0: 						leftClone,
0: 						(ValueNode) rightOperandList.elementAt(0),
0: 						getContextManager());
0: 		/* Set type info for the operator node */
0: 		leftBCO.bindComparisonOperator();
0: 
0: 		leftSide = leftBCO;
0: 
0: 		for (int elemsDone = 1; elemsDone < listSize; elemsDone++)
0: 		{
0: 
0: 			/* leftO <> rightOList.elementAt(elemsDone) */
0: 			leftClone = (leftOperand instanceof ColumnReference) ? leftOperand.getClone() : leftOperand;
0: 			rightBCO = (BinaryComparisonOperatorNode) 
0: 						getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE,
0: 							leftClone,
0: 							(ValueNode) rightOperandList.elementAt(elemsDone),
0: 							getContextManager());
0: 			/* Set type info for the operator node */
0: 			rightBCO.bindComparisonOperator();
0: 
0: 			/* Create the AND */
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 												C_NodeTypes.AND_NODE,
0: 												leftSide,
0: 												rightBCO,
0: 												getContextManager());
0: 			newAnd.postBindFixup();
0: 
0: 			leftSide = newAnd;
0: 		}
0: 
0: 		return leftSide;
0: 	}
0: 
0: 	/**
0: 	 * See if this IN list operator is referencing the same table.
0: 	 *
0: 	 * @param cr	The column reference.
0: 	 *
0: 	 * @return	true if in list references the same table as in cr.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean selfReference(ColumnReference cr)
0: 		throws StandardException
0: 	{
0: 		int size = rightOperandList.size();
0: 		for (int i = 0; i < size; i++)
0: 		{
0: 			ValueNode vn = (ValueNode) rightOperandList.elementAt(i);
0: 			if (vn.getTablesReferenced().get(cr.getTableNumber()))
0: 				return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * The selectivity for an "IN" predicate is generally very small.
0: 	 * This is an estimate applicable when in list are not all constants.
0: 	 */
0: 	public double selectivity(Optimizable optTable)
0: 	{
0: 		return 0.3d;
0: 	}
0:  
0: 	/**
0: 	 * Do code generation for this IN list operator.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb The MethodBuilder the expression will go into
0: 	 *
0: 	 * @return	An Expression to evaluate this operator
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		int			listSize = rightOperandList.size();
0: 		String		resultTypeName;
0: 		String		receiverType = ClassName.DataValueDescriptor;
0: 	
0: 		String		leftInterfaceType = ClassName.DataValueDescriptor;
0: 		String		rightInterfaceType = ClassName.DataValueDescriptor + "[]";
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(listSize > 0,
0: 				"listSize is expected to be > 0");
0: 		}
0: 
0: 		/*
0: 		** There are 2 parts to the code generation for an IN list -
0: 		** the code in the constructor and the code for the expression evaluation.
0: 		** The code that gets generated for the constructor is:
0: 		**		DataValueDescriptor[] field = new DataValueDescriptor[size];
0: 		**	For each element in the IN list that is a constant, we also generate:
0: 		**		field[i] = rightOperandList[i];
0: 		**	
0: 		** If the IN list is composed entirely of constants, then we generate the
0: 		** the following:
0: 		**		leftOperand.in(rightOperandList, leftOperand, isNullable(), ordered, result);
0: 		**
0: 		** Otherwise, we create a new method.  This method contains the 
0: 		** assignment of the non-constant elements into the array and the call to the in()
0: 		** method, which is in the new method's return statement.  We then return a call
0: 		** to the new method.
0: 		*/
0: 
0: 		receiver = leftOperand;
0: 
0: 		/* Figure out the result type name */
0: 		resultTypeName = getTypeCompiler().interfaceName();
0: 
0: 		// Generate the code to build the array
0: 		LocalField arrayField =
0: 			acb.newFieldDeclaration(Modifier.PRIVATE, rightInterfaceType);
0: 
0: 		/* The array gets created in the constructor.
0: 		 * All constant elements in the array are initialized
0: 		 * in the constructor.  All non-constant elements, if any,
0: 		 * are initialized each time the IN list is evaluated.
0: 		 */
0: 		/* Assign the initializer to the DataValueDescriptor[] field */
0: 		MethodBuilder cb = acb.getConstructor();
0: 		cb.pushNewArray(ClassName.DataValueDescriptor, listSize);
0: 		cb.putField(arrayField);
0: 		cb.endStatement();
0: 
0: 		/* Set the array elements that are constant */
0: 		int numConstants = 0;
0: 		MethodBuilder nonConstantMethod = null;
0: 		MethodBuilder currentConstMethod = cb;
0: 		for (int index = 0; index < listSize; index++)
0: 		{
0: 			MethodBuilder setArrayMethod;
0: 	
0: 			if (rightOperandList.elementAt(index) instanceof ConstantNode)
0: 			{
0: 				numConstants++;
0: 		
0: 				/*if too many statements are added  to a  method, 
0: 				*size of method can hit  65k limit, which will
0: 				*lead to the class format errors at load time.
0: 				*To avoid this problem, when number of statements added 
0: 				*to a method is > 2048, remaing statements are added to  a new function
0: 				*and called from the function which created the function.
0: 				*See Beetle 5135 or 4293 for further details on this type of problem.
0: 				*/
0: 				if(currentConstMethod.statementNumHitLimit(1))
0: 				{
0: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
0: 					currentConstMethod.pushThis();
0: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
0: 												  (String) null, 
0: 												  genConstantMethod.getName(),
0: 												  "void", 0);
0: 					//if it is a generate function, close the metod.
0: 					if(currentConstMethod != cb){
0: 						currentConstMethod.methodReturn();
0: 						currentConstMethod.complete();
0: 					}
0: 					currentConstMethod = genConstantMethod;
0: 				}
0: 				setArrayMethod = currentConstMethod;
0: 			} else {
0: 				if (nonConstantMethod == null)
0: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
0: 				setArrayMethod = nonConstantMethod;
0: 
0: 			}
0: 
0: 			setArrayMethod.getField(arrayField); // first arg
0: 			((ValueNode) rightOperandList.elementAt(index)).generateExpression(acb, setArrayMethod);
0: 			setArrayMethod.upCast(receiverType); // second arg
0: 			setArrayMethod.setArrayElement(index);
0: 		}
0: 
0: 		//if a generated function was created to reduce the size of the methods close the functions.
0: 		if(currentConstMethod != cb){
0: 			currentConstMethod.methodReturn();
0: 			currentConstMethod.complete();
0: 		}
0: 
0: 		if (nonConstantMethod != null) {
0: 			nonConstantMethod.methodReturn();
0: 			nonConstantMethod.complete();
0: 			mb.pushThis();
0: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
0: 		}
0: 
0: 		/*
0: 		** Call the method for this operator.
0: 		*/
0: 		/*
0: 		** Generate (field = <left expression>).  This assignment is
0: 		** used as the receiver of the method call for this operator,
0: 		** and the field is used as the left operand:
0: 		**
0: 		**	(field = <left expression>).method(field, <right expression>...)
0: 		*/
0: 
0: 		//LocalField receiverField =
0: 		//	acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
0: 
0: 		leftOperand.generateExpression(acb, mb);
0: 		mb.dup();
0: 		//mb.putField(receiverField); // instance for method call
0: 		/*mb.getField(receiverField);*/ mb.upCast(leftInterfaceType); // first arg
0: 		mb.getField(arrayField); // second arg
0: 		mb.push(isOrdered); // third arg
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
0: 
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * Generate start/stop key for this IN list operator.  Bug 3858.
0: 	 *
0: 	 * @param isAsc		is the index ascending on the column in question
0: 	 * @param isStartKey	are we generating start key or not
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb The MethodBuilder the expression will go into
0: 	 *
0: 	 * @return	nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateStartStopKey(boolean isAsc, boolean isStartKey,
0: 									 ExpressionClassBuilder acb,
0: 									 MethodBuilder mb)
0: 											   throws StandardException
0: 	{
0: 		/* left side of the "in" operator is our "judge" when we try to get
0: 		 * the min/max value of the operands on the right side.  Judge's type
0: 		 * is important for us, and is input parameter to min/maxValue.
0: 		 */
0: 		int leftTypeFormatId = leftOperand.getTypeId().getTypeFormatId();
0: 		int leftJDBCTypeId = leftOperand.getTypeId().isUserDefinedTypeId() ?
0: 								leftOperand.getTypeId().getJDBCTypeId() : -1;
0: 
0: 		int listSize = rightOperandList.size();
0: 		int numLoops, numValInLastLoop, currentOpnd = 0;
0: 
0: 		/* We first calculate how many times (loops) we generate a call to
0: 		 * min/maxValue function accumulatively, since each time it at most
0: 		 * takes 4 input values.  An example of the calls generated will be:
0: 		 * minVal(minVal(...minVal(minVal(v1,v2,v3,v4,judge), v5,v6,v7,judge),
0: 		 *        ...), vn-1, vn, NULL, judge)
0: 		 * Unused value parameters in the last call are filled with NULLs.
0: 		 */
0: 		if (listSize < 5)
0: 		{
0: 			numLoops = 1;
0: 			numValInLastLoop = (listSize - 1) % 4 + 1;
0: 		}
0: 		else
0: 		{
0: 			numLoops = (listSize - 5) / 3 + 2;
0: 			numValInLastLoop = (listSize - 5) % 3 + 1;
0: 		}
0: 
0: 		for (int i = 0; i < numLoops; i++)
0: 		{
0: 			/* generate value parameters of min/maxValue
0: 			 */
0: 			int numVals = (i == numLoops - 1) ? numValInLastLoop :
0: 							  ((i == 0) ? 4 : 3);
0: 			for (int j = 0; j < numVals; j++)
0: 			{
0: 				ValueNode vn = (ValueNode) rightOperandList.elementAt(currentOpnd++);
0: 				vn.generateExpression(acb, mb);
0: 				mb.upCast(ClassName.DataValueDescriptor);
0: 			}
0: 
0: 			/* since we have fixed number of input values (4), unused ones
0: 			 * in the last loop are filled with NULLs
0: 			 */
0: 			int numNulls = (i < numLoops - 1) ? 0 :
0: 							((i == 0) ? 4 - numValInLastLoop : 3 - numValInLastLoop);
0: 			for (int j = 0; j < numNulls; j++)
0: 				mb.pushNull(ClassName.DataValueDescriptor);
0: 
0: 			/* have to put judge's types in the end
0: 			 */
0: 			mb.push(leftTypeFormatId);
0: 			mb.push(leftJDBCTypeId);
0: 
0: 			/* decide to get min or max value
0: 			 */
0: 			String methodName;
0: 			if ((isAsc && isStartKey) || (! isAsc && ! isStartKey))
0: 				methodName = "minValue";
0: 			else
0: 				methodName = "maxValue";
0: 		
0: 			mb.callMethod(VMOpcode.INVOKESTATIC, ClassName.BaseExpressionActivation, methodName, ClassName.DataValueDescriptor, 6);
0: 
0: 		}
0: 	}
0: }
============================================================================