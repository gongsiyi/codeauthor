1:69a192a: /*
1:69a192a: 
1:69a192a:   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OffsetFetchNextTest
1:f6d5ae4: 
1:69a192a:   Licensed to the Apache Software Foundation (ASF) under one or more
1:69a192a:   contributor license agreements.  See the NOTICE file distributed with
1:69a192a:   this work for additional information regarding copyright ownership.
1:69a192a:   The ASF licenses this file to You under the Apache License, Version 2.0
1:69a192a:   (the "License"); you may not use this file except in compliance with
1:69a192a:   the License.  You may obtain a copy of the License at
1:69a192a: 
1:69a192a:   http://www.apache.org/licenses/LICENSE-2.0
1:69a192a: 
1:69a192a:   Unless required by applicable law or agreed to in writing, software
1:69a192a:   distributed under the License is distributed on an "AS IS" BASIS,
1:69a192a:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:69a192a:   See the License for the specific language governing permissions and
1:69a192a:   limitations under the License.
1:69a192a: 
1:69a192a: */
1:69a192a: 
1:69a192a: package org.apache.derbyTesting.functionTests.tests.lang;
1:69a192a: 
1:b4cda60: import java.sql.ParameterMetaData;
1:b4cda60: import java.sql.PreparedStatement;
1:69a192a: import java.sql.ResultSet;
1:69a192a: import java.sql.ResultSetMetaData;
1:69a192a: import java.sql.SQLException;
1:69a192a: import java.sql.Statement;
1:69a192a: import java.sql.Types;
1:69a192a: import junit.framework.Test;
1:69a192a: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:69a192a: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:69a192a: import org.apache.derbyTesting.junit.JDBC;
1:69a192a: import org.apache.derbyTesting.junit.TestConfiguration;
1:69a192a: 
1:69a192a: /**
1:b4cda60:  * Test {@code <result offset clause>} and {@code <fetch first clause>}.
1:69a192a:  */
1:69a192a: public class OffsetFetchNextTest extends BaseJDBCTestCase {
1:69a192a: 
1:00c7a20:     private final static String LANG_FORMAT_EXCEPTION = "22018";
1:00c7a20:     private final static String LANG_INTEGER_LITERAL_EXPECTED = "42X20";
1:00c7a20:     private final static String LANG_INVALID_ROW_COUNT_FIRST = "2201W";
1:00c7a20:     private final static String LANG_INVALID_ROW_COUNT_OFFSET = "2201X";
1:00c7a20:     private final static String LANG_MISSING_PARMS = "07000";
1:00c7a20:     private final static String LANG_SYNTAX_ERROR = "42X01";
1:00c7a20: 	private final static String LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL = "2201Z";
1:00c7a20: 
1:aff0657:     private final static String PERCENT_TOKEN = "%";
1:69a192a:     
1:aff0657:     // flavors of SQL Standard syntax
1:aff0657:     private final static String FIRST_ROWS_ONLY = "fetch first % rows only";
1:aff0657:     private final static String FIRST_ROW_ONLY = "fetch first % row only";
1:aff0657:     private final static String NEXT_ROWS_ONLY = "fetch next % rows only";
1:69a192a: 
1:aff0657:     // variants
1:aff0657:     private final static int SQL_STANDARD_VARIANT = 0;
1:aff0657:     private final static int JDBC_VARIANT = SQL_STANDARD_VARIANT + 1;
1:aff0657:     private final static int VARIANT_COUNT = JDBC_VARIANT + 1;
1:69a192a: 
1:69a192a:     public OffsetFetchNextTest(String name) {
1:69a192a:         super(name);
1:69a192a:     }
1:69a192a: 
1:69a192a:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("OffsetFetchNextTest");
1:69a192a: 
1:69a192a:         suite.addTest(
1:69a192a:             baseSuite("OffsetFetchNextTest:embedded"));
1:69a192a:         suite.addTest(
1:69a192a:             TestConfiguration.clientServerDecorator(
1:69a192a:                 baseSuite("OffsetFetchNextTest:client")));
1:69a192a: 
1:69a192a:         return suite;
1:69a192a:     }
1:69a192a: 
1:69a192a:     public static Test baseSuite(String suiteName) {
1:69a192a:         return new CleanDatabaseTestSetup(
1:1ae02c9:             new BaseTestSuite(OffsetFetchNextTest.class,
1:69a192a:                           suiteName)) {
1:b4cda60:             @Override
1:69a192a:             protected void decorateSQL(Statement s)
1:69a192a:                     throws SQLException {
1:69a192a:                 createSchemaObjects(s);
1:69a192a:             }
1:69a192a:         };
1:69a192a:     }
1:69a192a: 
1:69a192a: 
1:00c7a20:     /**
1:69a192a:      * Creates tables used by the tests (never modified, we use rollback after
1:69a192a:      * changes).
1:00c7a20:      */
1:b4cda60:     private static void createSchemaObjects(Statement st) throws SQLException
1:69a192a:     {
1:69a192a:         // T1 (no indexes)
1:69a192a:         st.executeUpdate("create table t1 (a int, b bigint)");
1:69a192a:         st.executeUpdate("insert into t1 (a, b) " +
1:69a192a:                          "values (1,1), (1,2), (1,3), (1,4), (1,5)");
1:69a192a: 
1:69a192a:         // T2 (primary key)
1:69a192a:         st.executeUpdate("create table t2 (a int primary key, b bigint)");
1:69a192a:         st.executeUpdate("insert into t2 (a, b) " +
1:69a192a:                          "values (1,1), (2,1), (3,1), (4,1), (5,1)");
1:69a192a: 
1:69a192a:         // T3 (primary key + secondary key)
1:69a192a:         st.executeUpdate("create table t3 (a int primary key, " +
1:69a192a:                          "                 b bigint unique)");
1:69a192a:         st.executeUpdate("insert into t3 (a, b) " +
1:69a192a:                          "values (1,1), (2,2), (3,3), (4,4), (5,5)");
1:69a192a:     }
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Negative tests. Test various invalid OFFSET and FETCH NEXT clauses.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testErrors() throws SQLException
1:69a192a:     {
1:69a192a:         Statement st = createStatement();
1:69a192a: 
1:aff0657:         String  stub = "select * from t1 %";
1:aff0657: 
1:69a192a:         // Wrong range in row count argument
1:aff0657:         vetStatement( st, LANG_INVALID_ROW_COUNT_OFFSET, stub, FIRST_ROWS_ONLY, "-1", null, null );
1:69a192a: 
1:aff0657:         vetStatement( st, LANG_SYNTAX_ERROR, stub, FIRST_ROWS_ONLY, "-?", null, null );
1:69a192a: 
2:00c7a20:         assertStatementError(LANG_INVALID_ROW_COUNT_FIRST, st,
1:69a192a:                              "select * from t1 fetch first 0 rows only");
1:69a192a: 
1:aff0657:         vetStatement( st, LANG_INVALID_ROW_COUNT_FIRST, stub, FIRST_ROWS_ONLY, null, "-1", null );
1:69a192a: 
1:69a192a:         // Wrong type in row count argument
1:aff0657:         vetStatement( st, LANG_INTEGER_LITERAL_EXPECTED, stub, FIRST_ROWS_ONLY, null, "3.14", null );
1:69a192a: 
1:69a192a:         // Wrong order of clauses
1:f6d5ae4:         assertStatementError(LANG_SYNTAX_ERROR, st,
1:69a192a:                              "select * from t1 " +
1:69a192a:                              "fetch first 0 rows only offset 0 rows");
1:00c7a20:         assertStatementError(LANG_SYNTAX_ERROR, st,
1:aff0657:                              "select * from t1 { offset 0 limit 0 }");
1:69a192a:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Positive tests. Check that the new keyword OFFSET introduced is not
1:b4cda60:      * reserved so we don't risk breaking existing applications.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testNewKeywordNonReserved() throws SQLException
1:69a192a:     {
1:f6d5ae4:         setAutoCommit(false);
1:f6d5ae4:         prepareStatement("select a,b as offset from t1 offset 0 rows");
1:aff0657:         prepareStatement("select a,b as limit from t1 offset 0 rows");
1:69a192a: 
1:69a192a:         // Column and table correlation name usage
1:f6d5ae4:         prepareStatement("select a,b from t1 as offset");
1:aff0657:         prepareStatement("select a,b from t1 as limit");
1:69a192a: 
1:f6d5ae4:         prepareStatement("select a,b offset from t1 offset");
1:aff0657:         prepareStatement("select a,b limit from t1 limit");
1:69a192a: 
1:f6d5ae4:         prepareStatement("select a,b offset from t1 offset +2 rows");
1:69a192a: 
1:f6d5ae4:         prepareStatement("select a offset,b from t1 offset ? rows");
1:aff0657: 
1:f6d5ae4:         prepareStatement("select offset.a, offset.b offset from t1 as offset offset ? rows");
1:aff0657:         prepareStatement("select limit.a, limit.b offset from t1 as limit offset ? rows");
1:f6d5ae4: 
1:f6d5ae4:         // DERBY-4562
1:f6d5ae4:         Statement s = createStatement();
1:f6d5ae4:         s.executeUpdate("create table t4562(i int, offset int)");
1:f6d5ae4:         ResultSet rs = s.executeQuery(
1:f6d5ae4:             "select * from t4562 where i > 0 and offset + i < 0 offset 2 rows");
1:f6d5ae4:         rs.next();
1:f6d5ae4: 
1:f6d5ae4:         rs = s.executeQuery(
1:f6d5ae4:             "select * from t4562 where i > 0 and offset - i < 0 offset 2 rows");
1:f6d5ae4:         rs.next();
1:f6d5ae4: 
1:f6d5ae4:         rs = s.executeQuery(
1:f6d5ae4:             "select * from t4562 where i > 0 and offset * i < 0 offset 2 rows");
1:f6d5ae4:         rs.next();
1:f6d5ae4: 
1:f6d5ae4:         rs.close();
1:f6d5ae4: 
1:f6d5ae4:         rollback();
1:69a192a:     }
1:aff0657: 
1:aff0657: 
1:69a192a:     /**
1:69a192a:      * Positive tests.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testOffsetFetchFirstReadOnlyForwardOnlyRS() throws SQLException
1:69a192a:     {
1:69a192a:         Statement stm = createStatement();
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 0 rows (a no-op)
1:69a192a:          */
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a, b from t1%", FIRST_ROWS_ONLY, "0", null,
1:aff0657:              new String [][] { {"1","1"}, {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "0", null,
1:aff0657:              new String [][] { {"1","1"}, {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "0", null,
1:aff0657:              new String [][] { {"1","1"}, {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 1 rows
1:69a192a:          */
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "1", null,
1:aff0657:              new String [][] { {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "1", null,
1:aff0657:              new String [][] { {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "1", null,
1:aff0657:              new String [][] { {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 4 rows
1:69a192a:          */
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "4", null,
1:aff0657:              new String [][] { {"1","5"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "4", null,
1:aff0657:              new String [][] { {"5","1"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "4", null,
1:aff0657:              new String [][] {  {"5","5"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 1 rows fetch 1 row. Use "next"/"rows" syntax
1:69a192a:          */
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "1", "1",
1:aff0657:              new String [][] { {"1","2"}  }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "1", "1",
1:aff0657:              new String [][] { {"2","1"}  }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "1", "1",
1:aff0657:              new String [][] { {"2","2"}  }
1:aff0657:              );
1:aff0657: 
1:69a192a:         /*
1:69a192a:          * offset 1 rows fetch so many rows we drain rs row. Use "first"/"row"
1:69a192a:          * syntax
1:69a192a:          */
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t1%", FIRST_ROW_ONLY, "1", "10",
1:aff0657:              new String [][] { {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROW_ONLY, "1", "10",
1:aff0657:              new String [][] { {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROW_ONLY, "1", "10",
1:aff0657:              new String [][] { {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:aff0657:              );
1:aff0657: 
1:69a192a:         /*
1:69a192a:          * offset so many rows that we see empty rs
1:69a192a:          */
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t1%", FIRST_ROW_ONLY, "10", null,
1:aff0657:              new String [][] { }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t2%", FIRST_ROW_ONLY, "10", null,
1:aff0657:              new String [][] { }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select a,b from t3%", FIRST_ROW_ONLY, "10", null,
1:aff0657:              new String [][] { }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * fetch first/next row (no row count given)
1:69a192a:          */
26:69a192a:         queryAndCheck(
26:69a192a:             stm,
1:69a192a:             "select a,b from t1 fetch first row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t2 fetch next row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t3 fetch next row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * Combine with order by asc
1:69a192a:          */
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t1 order by b asc fetch first row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t2 order by a asc fetch next row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t3 order by a asc fetch next row only",
1:69a192a:             new String [][] {{"1","1"}});
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * Combine with order by desc.
1:69a192a:          */
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             // Note: use column b here since for t1 all column a values are the
1:69a192a:             // same and order can change after sorting, want unique row first
1:69a192a:             // in rs so we can test it.
1:69a192a:             "select a,b from t1 order by b desc fetch first row only",
1:69a192a:             new String [][] {{"1","5"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t2 order by a desc fetch next row only",
1:69a192a:             new String [][] {{"5","1"}});
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select a,b from t3 order by a desc fetch next row only",
1:69a192a:             new String [][] {{"5","5"}});
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * Combine with group by, order by.
1:69a192a:          */
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select max(a) from t1 group by b fetch first row only",
1:69a192a:             new String [][] {{"1"}});
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select max(a) from t2 group by b %", FIRST_ROW_ONLY, "0", null,
1:aff0657:              new String [][] { {"5"} }
1:aff0657:              );
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select max(a) from t3 group by b order by max(a) %", NEXT_ROWS_ONLY, null, "2",
1:aff0657:              new String [][] { {"1"},{"2"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * Combine with union
1:69a192a:          */
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select * from t1 union all select * from t1 %", FIRST_ROW_ONLY, null, "2",
1:aff0657:              new String [][] { {"1","1"}, {"1","2"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * Combine with join
1:69a192a:          */
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select t2.b, t3.b from t2,t3 where t2.a=t3.a %", FIRST_ROW_ONLY, null, "2",
1:aff0657:              new String [][] { {"1","1"}, {"1","2"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         stm.close();
1:108305b:     }
1:108305b: 
1:108305b: 
1:69a192a:     /**
1:69a192a:      * Positive tests.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testOffsetFetchFirstUpdatableForwardOnlyRS() throws SQLException
1:aff0657:     {
1:69a192a:         Statement stm = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:69a192a:                                         ResultSet.CONCUR_UPDATABLE);
1:aff0657:         ResultSet   rs;
1:aff0657:         String[]    variants;
1:108305b: 
1:88e5971:         setAutoCommit(false);
1:108305b: 
1:69a192a:         /*
1:69a192a:          * offset 0 rows (a no-op), update a row and verify result
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "0", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next();
1:69a192a:             rs.next(); // at row 2
1:69a192a:             rs.updateInt(1, -rs.getInt(1));
1:69a192a:             rs.updateRow();
1:69a192a:             rs.close();
1:108305b: 
1:108305b:             queryAndCheck(
1:108305b:                           stm,
1:69a192a:                           "select a,b from t1",
17:69a192a:                           new String [][] {
1:69a192a:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:108305b: 
1:69a192a:             rollback();
1:69a192a:         }
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 1 rows, update a row and verify result
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "1", null );
1:b4cda60:         for ( String variant : variants )
1:69a192a:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next(); // at row 1, but row 2 of underlying rs
1:69a192a: 
1:69a192a:             rs.updateInt(1, -rs.getInt(1));
1:69a192a:             rs.updateRow();
1:69a192a:             rs.close();
1:69a192a: 
1:108305b:             queryAndCheck(
1:108305b:                           stm,
1:69a192a:                           "select a,b from t1",
1:69a192a:                           new String [][] {
1:69a192a:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:69a192a: 
1:69a192a:             rollback();
1:69a192a:         }
1:69a192a:         
1:108305b:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Positive tests with scrollable read-only.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testOffsetFetchFirstReadOnlyScrollableRS() throws SQLException
1:69a192a:     {
1:69a192a:         Statement stm = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:69a192a:                                         ResultSet.CONCUR_READ_ONLY);
1:aff0657:         ResultSet   rs;
1:aff0657:         String[]    variants;
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 0 rows (a no-op), update a row and verify result
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "0", null );
1:b4cda60:         for ( String variant : variants )
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next();
1:69a192a:             rs.next(); // at row 2
1:69a192a:             assertTrue(rs.getInt(2) == 2);
1:69a192a:             rs.close();
1:aff0657:         }
1:69a192a:         
1:69a192a:         /*
1:69a192a:          * offset 1 rows, fetch 3 row, check that we have the right ones
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "1", "3" );
1:b4cda60:         for ( String variant : variants )
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next();
1:69a192a:             rs.next(); // at row 2, but row 3 of underlying rs
1:69a192a: 
1:69a192a:             assertTrue(rs.getInt(2) == 3);
1:69a192a: 
1:69a192a:             // Go backbards and update
1:69a192a:             rs.previous();
1:69a192a:             assertTrue(rs.getInt(2) == 2);
1:69a192a: 
1:69a192a:             // Try some navigation and border conditions
1:69a192a:             rs.previous();
1:69a192a:             assertTrue(rs.isBeforeFirst());
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             assertTrue(rs.isAfterLast());
1:69a192a:         }
1:69a192a:         
1:69a192a:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Positive tests with SUR (Scrollable updatable result set).
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testOffsetFetchFirstUpdatableScrollableRS() throws SQLException
1:69a192a:     {
1:69a192a:         Statement stm = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:69a192a:                                         ResultSet.CONCUR_UPDATABLE);
1:aff0657:         ResultSet   rs;
1:aff0657:         String[]    variants;
1:69a192a: 
1:88e5971:         setAutoCommit(false);
1:69a192a: 
1:69a192a:         /*
1:69a192a:          * offset 0 rows (a no-op), update a row and verify result
1:69a192a:          * also try the "for update" syntax so we see that it still works
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 % for update", FIRST_ROWS_ONLY, "0", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next();
1:69a192a:             rs.next(); // at row 2
1:69a192a:             rs.updateInt(1, -rs.getInt(1));
1:69a192a:             rs.updateRow();
1:69a192a:             rs.close();
1:69a192a: 
1:69a192a:             queryAndCheck(
1:69a192a:                           stm,
1:69a192a:                           "select a,b from t1",
1:69a192a:                           new String [][] {
1:69a192a:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:69a192a: 
1:69a192a:             rollback();
1:aff0657:         }
1:69a192a:         
1:69a192a:         /*
1:69a192a:          * offset 1 rows, fetch 3 row, update some rows and verify result
1:69a192a:          */
1:aff0657:         variants = makeVariants( "select * from t1 %", NEXT_ROWS_ONLY, "1", "3" );
1:b4cda60:         for ( String variant : variants )
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             rs.next();
1:69a192a:             rs.next(); // at row 2, but row 3 of underlying rs
1:69a192a: 
1:69a192a:             rs.updateInt(1, -rs.getInt(1));
1:69a192a:             rs.updateRow();
1:69a192a: 
1:69a192a:             // Go backbards and update
1:69a192a:             rs.previous();
1:69a192a:             rs.updateInt(1, -rs.getInt(1));
1:69a192a:             rs.updateRow();
1:69a192a: 
1:69a192a:             // Try some navigation and border conditions
1:69a192a:             rs.previous();
1:69a192a:             assertTrue(rs.isBeforeFirst());
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             rs.next();
1:69a192a:             assertTrue(rs.isAfterLast());
1:69a192a: 
1:69a192a:             // Insert a row
1:69a192a:             rs.moveToInsertRow();
1:69a192a:             rs.updateInt(1,42);
1:69a192a:             rs.updateInt(2,42);
1:69a192a:             rs.insertRow();
1:69a192a: 
1:69a192a:             // Delete a row
1:69a192a:             rs.previous();
1:69a192a:             rs.deleteRow();
1:69a192a: 
1:69a192a:             // .. and see that a hole is left in its place
1:69a192a:             rs.previous();
1:69a192a:             rs.next();
1:69a192a:             assertTrue(rs.rowDeleted());
1:69a192a: 
1:69a192a:             rs.close();
1:69a192a: 
1:69a192a:             queryAndCheck(
1:69a192a:                           stm,
1:69a192a:                           "select a,b from t1",
1:69a192a:                           new String [][] {
1:69a192a:                               {"1","1"}, {"-1","2"},{"-1","3"},{"1","5"},{"42","42"}});
1:69a192a:             rollback();
1:aff0657:         }
1:69a192a:         
1:69a192a:         // Test with projection
1:aff0657:         variants = makeVariants( "select * from t1 where a + 1 < b%", NEXT_ROWS_ONLY, "1", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             // should yield 2 rows
1:69a192a:             rs.absolute(2);
1:69a192a:             assertTrue(rs.getInt(2) == 5);
1:69a192a:             rs.updateInt(2, -5);
1:69a192a:             rs.updateRow();
1:69a192a:             rs.close();
1:69a192a: 
1:69a192a:             queryAndCheck(
1:69a192a:                           stm,
1:69a192a:                           "select a,b from t1",
1:69a192a:                           new String [][] {
1:69a192a:                               {"1","1"}, {"1","2"},{"1","3"},{"1","4"},{"1","-5"}});
1:69a192a:             rollback();
1:69a192a:         }
1:69a192a:         
1:69a192a:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a: 
1:b4cda60:     public void testValues() throws SQLException
1:aff0657:     {
1:108305b:         Statement stm = createStatement();
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "values 4%", FIRST_ROW_ONLY, null, "2",
1:aff0657:              new String [][] { {"4"} }
1:aff0657:              );
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "values 4%", FIRST_ROW_ONLY, "1", null,
1:aff0657:              new String [][] { }
1:aff0657:              );
1:69a192a: 
1:69a192a:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Positive tests, result set metadata
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testMetadata() throws SQLException
1:aff0657:     {
1:69a192a:         Statement stm = createStatement();
1:aff0657:         ResultSet   rs;
1:aff0657:         String[]    variants;
1:69a192a: 
1:aff0657:         variants = makeVariants( "select * from t1%", NEXT_ROWS_ONLY, "1", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             rs = stm.executeQuery( variant );
1:69a192a:             ResultSetMetaData rsmd= rs.getMetaData();
1:69a192a:             int cnt = rsmd.getColumnCount();
1:69a192a: 
1:69a192a:             String[] cols = new String[]{"A","B"};
1:69a192a:             int[] types = {Types.INTEGER, Types.BIGINT};
1:69a192a: 
1:69a192a:             for (int i=1; i <= cnt; i++) {
1:69a192a:                 String name = rsmd.getColumnName(i);
1:69a192a:                 int type = rsmd.getColumnType(i);
1:69a192a: 
1:69a192a:                 assertTrue(name.equals(cols[i-1]));
1:69a192a:                 assertTrue(type == types[i-1]);
1:69a192a:             }
1:69a192a: 
1:69a192a:             rs.close();
1:69a192a:         }
1:69a192a:         
1:69a192a:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Test that we see correct traces of the filtering in the statistics
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testRunTimeStatistics() throws SQLException
1:aff0657:     {
1:69a192a:         Statement stm = createStatement();
1:aff0657:         ResultSet   rs;
1:aff0657:         String[]    variants;
1:69a192a: 
1:aff0657:         variants = makeVariants( "select a,b from t1%", NEXT_ROWS_ONLY, "2", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:aff0657:             stm.executeUpdate( "call syscs_util.syscs_set_runtimestatistics(1)" );
1:69a192a: 
1:69a192a:             queryAndCheck(
1:69a192a:                           stm,
1:b4cda60:                           variant,
1:69a192a:                           new String [][] {
1:69a192a:                               {"1","3"}, {"1","4"},{"1","5"}});
1:69a192a: 
1:aff0657:             stm.executeUpdate( "call syscs_util.syscs_set_runtimestatistics(0)" );
1:69a192a: 
1:aff0657:             rs = stm.executeQuery( "values syscs_util.syscs_get_runtimestatistics()" );
1:69a192a:             rs.next();
1:69a192a:             String plan = rs.getString(1);
1:69a192a: 
1:69a192a:             // Verify that the plan shows the filtering (2 rows of 3 seen):
1:e0b3d81:             assertTrue(plan.indexOf("Row Count (1):\n" +
1:e0b3d81:                                     "Number of opens = 1\n" +
1:e0b3d81:                                     "Rows seen = 3\n" +
1:69a192a:                                     "Rows filtered = 2") != -1);
1:69a192a: 
1:69a192a:             rs.close();
1:69a192a:         }
1:69a192a:         
1:69a192a:         stm.close();
1:aff0657:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Test against a bigger table
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:69a192a:      */
1:b4cda60:     public void testBigTable() throws SQLException
1:aff0657:     {
1:69a192a:         Statement stm = createStatement();
1:69a192a: 
1:88e5971:         setAutoCommit(false);
1:69a192a: 
1:69a192a:         stm.executeUpdate("declare global temporary table session.t (i int) " +
1:69a192a:                           "on commit preserve rows not logged");
1:69a192a: 
1:69a192a:         PreparedStatement ps =
1:88e5971:             prepareStatement("insert into session.t values ?");
1:69a192a: 
1:69a192a:         for (int i=1; i <= 100000; i++) {
1:69a192a:             ps.setInt(1, i);
1:69a192a:             ps.executeUpdate();
1:69a192a: 
1:69a192a:             if (i % 10000 == 0) {
1:69a192a:                 commit();
1:69a192a:             }
1:69a192a:         }
1:69a192a: 
1:69a192a:         queryAndCheck(
1:69a192a:             stm,
1:69a192a:             "select count(*) from session.t",
1:69a192a:             new String [][] {
2:69a192a:                 {"100000"}});
1:69a192a: 
1:aff0657:         vetStatement
1:aff0657:             (
1:aff0657:              stm, null, "select i from session.t%", FIRST_ROWS_ONLY, "99999", null,
1:aff0657:              new String [][] { {"100000"} }
1:aff0657:              );
1:69a192a: 
1:69a192a:         stm.executeUpdate("drop table session.t");
1:69a192a:         stm.close();
2:06154a0:     }
1:aff0657: 
1:06154a0:     /**
1:06154a0:      * Test that the values of offset and fetch first are not forgotten if
1:06154a0:      * a {@code PreparedStatement} is executed multiple times (DERBY-4212).
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:06154a0:      */
1:b4cda60:     public void testRepeatedExecution() throws SQLException
2:aff0657:     {
1:aff0657:         PreparedStatement ps;
1:aff0657:         String[]    variants;
1:aff0657: 
1:aff0657:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "2", "2" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:00c7a20:             String[][] expected = {{"1", "3"}, {"1", "4"}};
1:aff0657:             for (int i = 0; i < 10; i++) {
5:aff0657:                 JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:aff0657:             }
1:aff0657:         }
1:aff0657:     }
1:aff0657: 
1:aff0657:     /**
1:00c7a20:      * Test dynamic arguments
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:aff0657:      */
1:b4cda60:     public void testDynamicArgs() throws SQLException
1:aff0657:     {
1:aff0657:         PreparedStatement ps;
1:aff0657:         String[]    variants;
1:aff0657:         String[][] expected = null;
1:aff0657: 
1:00c7a20:         // Check look-ahead also for ? in grammar since offset is not reserved
1:aff0657:         variants = makeVariants( "select * from t1%", NEXT_ROWS_ONLY, "?", null );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:aff0657:         }
1:00c7a20:         
24:aff0657:         
1:aff0657:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "?" );
1:aff0657:         for ( int j = 0; j < variants.length; j++ )
1:aff0657:         {
1:aff0657:             // SQL Standard and JDBC limit/offset parameter orders are different
1:aff0657:             int offsetParam = ( j == SQL_STANDARD_VARIANT ) ? 1 : 2;
1:aff0657:             int fetchParam = ( j == SQL_STANDARD_VARIANT ) ? 2 : 1;
1:aff0657:             
1:aff0657:             expected = new String[][] {{"1", "3"}, {"1", "4"}};
3:aff0657:             ps = prepareStatement( variants[ j ] );
1:aff0657: 
1:00c7a20:             // Check range errors
1:00c7a20: 
1:aff0657:             ps.setInt( offsetParam, 0 );
1:00c7a20:             assertPreparedStatementError(LANG_MISSING_PARMS, ps);
1:00c7a20: 
1:aff0657:             ps.setInt( offsetParam, -1 );
1:aff0657:             ps.setInt( fetchParam, 2 );
1:00c7a20:             assertPreparedStatementError(LANG_INVALID_ROW_COUNT_OFFSET, ps);
1:00c7a20: 
1:aff0657:             ps.setInt( offsetParam, 0 );
1:aff0657:             ps.setInt( fetchParam, ( j == SQL_STANDARD_VARIANT ) ? 0 : -1 );
1:00c7a20:             assertPreparedStatementError(LANG_INVALID_ROW_COUNT_FIRST, ps);
1:00c7a20: 
1:00c7a20:             // Check non-integer values
1:00c7a20:             try {
1:aff0657:                 ps.setString( offsetParam, "aaa");
1:00c7a20:             } catch (SQLException e) {
1:00c7a20:                 assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:00c7a20:             }
1:00c7a20: 
1:00c7a20:             try {
1:aff0657:                 ps.setString( fetchParam, "aaa");
1:00c7a20:             } catch (SQLException e) {
1:00c7a20:                 assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:00c7a20:             }
1:00c7a20: 
1:00c7a20: 
1:00c7a20:             // A normal case
1:00c7a20:             for (int i = 0; i < 2; i++) {
1:aff0657:                 ps.setInt( offsetParam,2 );
1:aff0657:                 ps.setInt( fetchParam,2 );
1:00c7a20:                 JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:00c7a20:             }
1:00c7a20: 
1:00c7a20:             // Now, note that since we now have different values for offset and
1:00c7a20:             // fetch first, we also exercise reusing the result set for this
1:00c7a20:             // prepared statement (i.e. the values are computed at execution time,
1:00c7a20:             // not at result set generation time). Try long value for change.
1:aff0657:             ps.setLong( offsetParam, 1L );
1:aff0657:             ps.setInt( fetchParam, 3 );
1:00c7a20:             expected = new String[][]{{"1", "2"}, {"1", "3"}, {"1", "4"}};
1:00c7a20:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:00c7a20: 
1:00c7a20: 
1:00c7a20:             //  Try a large number
1:aff0657:             ps.setLong( offsetParam, Integer.MAX_VALUE * 2L );
1:aff0657:             ps.setInt( fetchParam, 5 );
1:00c7a20:             JDBC.assertEmpty(ps.executeQuery());
1:aff0657:         }
1:00c7a20:         
1:00c7a20:         // Mix of prepared and not
1:aff0657:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "3" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
2:00c7a20:             ps.setLong(1, 1L);
1:00c7a20:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:aff0657:         }
1:00c7a20: 
1:aff0657:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "4", "?" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:00c7a20:             ps.setLong(1, 1L);
1:aff0657:             JDBC.assertFullResultSet(ps.executeQuery(), new String[][]{{"1", "5"}});
1:aff0657:         }
1:00c7a20: 
1:00c7a20:         // Mix of other dyn args and ours:
1:aff0657:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "?", "3" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:00c7a20:             ps.setInt(1, 1);
1:00c7a20:             ps.setLong(2, 1L);
1:00c7a20:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:aff0657:         }
1:00c7a20: 
1:aff0657:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "1", "?" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:00c7a20:             ps.setInt(1, 1);
1:00c7a20:             ps.setLong(2, 2L);
1:00c7a20:             expected = new String[][]{{"1", "2"}, {"1", "3"}};
1:00c7a20:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:aff0657:         }
1:00c7a20: 
1:00c7a20:         // NULLs not allowed (Note: parameter metadata says "isNullable" for
1:00c7a20:         // all ? args in Derby...)
1:aff0657:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "?" );
2:aff0657:         for ( int i = 0; i < variants.length; i++ )
1:aff0657:         {
6:aff0657:             ps = prepareStatement( variants[ i ] );
1:aff0657:             int offsetParam = ( i == SQL_STANDARD_VARIANT ) ? 1 : 2;
1:aff0657:             int fetchParam = ( i == SQL_STANDARD_VARIANT ) ? 2 : 1;
1:00c7a20:             
1:aff0657:             ps.setNull( offsetParam, Types.BIGINT );
1:aff0657:             ps.setInt( fetchParam, 2 );
1:00c7a20:             assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1:00c7a20: 
1:aff0657:             ps.setInt( offsetParam,1 );
1:aff0657:             ps.setNull( fetchParam, Types.BIGINT );
1:00c7a20:             assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1:00c7a20:             
1:00c7a20:             ps.close();
1:00c7a20:         }
1:aff0657:     }
1:00c7a20: 
1:00c7a20:     /**
1:00c7a20:      * Test dynamic arguments
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:00c7a20:      */
1:b4cda60:     public void testDynamicArgsMetaData() throws SQLException
1:aff0657:     {
1:00c7a20: 
1:fc6899b:     	//since there is no getParameterMetaData() call available in JSR169 
1:fc6899b:     	//implementations, do not run this test if we are running JSR169
1:fc6899b:     	if (JDBC.vmSupportsJSR169()) return;
1:aff0657: 
1:aff0657:         PreparedStatement ps;
1:aff0657:         String[]    variants;
1:aff0657: 
1:aff0657:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "?", "?" );
1:b4cda60:         for (String variant : variants)
1:aff0657:         {
1:b4cda60:             ps = prepareStatement( variant );
1:aff0657:             
1:00c7a20:             ParameterMetaData pmd = ps.getParameterMetaData();
1:00c7a20:             int[] expectedTypes = { Types.INTEGER, Types.BIGINT, Types.BIGINT };
1:00c7a20: 
1:00c7a20:             for (int i = 0; i < 3; i++) {
1:00c7a20:                 assertEquals("Unexpected parameter type",
1:00c7a20:                              expectedTypes[i], pmd.getParameterType(i+1));
1:00c7a20:                 assertEquals("Derby ? args are nullable",
1:00c7a20:                              // Why is that? Cf. logic in ParameterNode.setType
1:00c7a20:                              ParameterMetaData.parameterNullable,
1:00c7a20:                              pmd.isNullable(i+1));
1:00c7a20:             }
1:00c7a20:             ps.close();
1:00c7a20:         }
1:aff0657:     }
1:00c7a20: 
1:aff0657:     /**
1:955f104:      * Test some additional corner cases in JDBC limit/offset syntax.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:955f104:      */
1:b4cda60:     public void testJDBCLimitOffset() throws SQLException
1:955f104:     {
1:955f104:         // LIMIT 0 is allowed. It means: everything from the OFFSET forward
1:955f104:         PreparedStatement   ps = prepareStatement( "select a from t2 order by a { limit ? }" );
1:955f104:         ps.setInt( 1, 0 );
1:955f104:         JDBC.assertFullResultSet
1:955f104:             (
1:955f104:              ps.executeQuery(),
1:955f104:              new String[][] { { "1" }, { "2" }, { "3" }, { "4" }, { "5" } }
1:955f104:              );
1:955f104:         ps.close();
1:955f104: 
1:955f104:         ps = prepareStatement( "select a from t2 order by a { limit ? offset 3 }" );
1:955f104:         ps.setInt( 1, 0 );
1:955f104:         JDBC.assertFullResultSet
1:955f104:             (
1:955f104:              ps.executeQuery(),
1:955f104:              new String[][] { { "4" }, { "5" } }
1:955f104:              );
1:955f104:         ps.close();
1:955f104: 
1:955f104:         // mix JDBC and SQL Standard syntax
1:955f104:         ps = prepareStatement
1:955f104:             (
1:955f104:              "select t.a from\n" +
1:955f104:              "( select * from t2 order by a { limit 3 offset 1 } ) t,\n" +
1:955f104:              "( select * from t3 order by a offset 2 rows fetch next 10 rows only ) s\n" +
1:955f104:              "where t.a = s.a order by t.a"
1:955f104:              );
1:955f104:         JDBC.assertFullResultSet
1:955f104:             (
1:955f104:              ps.executeQuery(),
1:955f104:              new String[][] { { "3" }, { "4" } }
1:955f104:              );
1:955f104:         ps.close();
1:955f104:     }
1:955f104: 
1:955f104:     /**
1:aff0657:      * Run a statement with both SQL Standard and JDBC limit/offset syntax. Verify
1:aff0657:      * that we get the expected error or results. The statement has a % literal at the
1:aff0657:      * point where the offset/fetchFirst and limit/offset clauses are to be inserted.
1:aff0657:      */
1:aff0657:     private void    vetStatement
1:aff0657:         ( Statement stmt, String sqlState, String stub, String fetchFormat, String offset, String fetchFirst, String[][] expectedResults )
1:b4cda60:         throws SQLException
1:aff0657:     {
1:aff0657:         String[]    variants = makeVariants( stub, fetchFormat, offset, fetchFirst );
1:69a192a: 
1:b4cda60:         for (String text : variants)
1:aff0657:         {
1:aff0657:             if ( sqlState != null )
1:aff0657:             {
1:aff0657:                 assertStatementError( sqlState, stmt, text );
1:69a192a:             }
1:aff0657:             else
1:aff0657:             {
1:aff0657:                 queryAndCheck( stmt, text, expectedResults );
1:aff0657:             }
1:aff0657:         }
1:aff0657:     }
1:69a192a: 
1:69a192a:     /**
1:aff0657:      * Make the SQL Standard and JDBC limit/offset variants of a stub statement,
1:aff0657:      * plugging in the given offset and fetch count.
1:69a192a:      */
1:aff0657:     private String[]    makeVariants
1:aff0657:         ( String stub, String fetchFormat, String offset, String fetchFirst )
1:aff0657:     {
1:aff0657:         String[]    result = new String[ VARIANT_COUNT ];
1:69a192a: 
1:aff0657:         result[ SQL_STANDARD_VARIANT ] = makeSQLStandardText( stub, fetchFormat, offset, fetchFirst );
1:aff0657:         result[ JDBC_VARIANT ] = makeJDBCText( stub, offset, fetchFirst );
1:69a192a: 
1:aff0657:         return result;
1:aff0657:     }
1:aff0657:     
1:aff0657:     /**
1:aff0657:      * Substitute the SQL Standard syntax into a stub statement, given an offset and fetch count.
1:aff0657:      */
1:aff0657:     private String  makeSQLStandardText
1:aff0657:         ( String stub, String fetchFormat, String offset, String fetchFirst )
1:aff0657:     {
1:aff0657:         String  sqlStandardText = "";
1:aff0657: 
1:aff0657:         if ( offset != null )
1:aff0657:         {
1:aff0657:             sqlStandardText = " offset " + offset + " rows ";
1:aff0657:         }
1:aff0657:         if ( fetchFirst != null )
1:aff0657:         {
1:aff0657:             sqlStandardText = sqlStandardText + substitute( fetchFormat, PERCENT_TOKEN, fetchFirst );
1:aff0657:         }
1:aff0657: 
1:aff0657:         sqlStandardText = substitute( stub, PERCENT_TOKEN, sqlStandardText );
1:aff0657: 
1:aff0657:         println( sqlStandardText );
1:aff0657: 
1:aff0657:         return sqlStandardText;
1:aff0657:     }
1:aff0657:     /**
1:aff0657:      * Substitute JDBC limit/offset syntax into a stub statement, given an offset and fetch count.
1:aff0657:      */
1:aff0657:     private String  makeJDBCText
1:aff0657:         ( String stub, String offset, String fetchFirst )
1:aff0657:     {
1:aff0657:         String  jdbcText = "";
1:aff0657: 
1:aff0657:         if ( offset != null )
1:aff0657:         {
1:aff0657:             jdbcText = " offset " + offset;
1:aff0657:         }
1:aff0657:         if ( fetchFirst != null )
1:aff0657:         {
1:aff0657:             jdbcText = " limit " + fetchFirst + " " + jdbcText;
1:aff0657:         }
1:aff0657:         else
1:aff0657:         {
1:aff0657:             jdbcText = "limit 0 " + jdbcText;
1:aff0657:         }
1:aff0657: 
1:aff0657:         jdbcText = substitute( stub, PERCENT_TOKEN, " { " + jdbcText + " } " );
1:aff0657: 
1:aff0657:         println( jdbcText );
1:aff0657: 
1:aff0657:         return jdbcText;
1:aff0657:     }
1:aff0657: 
1:aff0657:     private String  substitute( String stub, String token, String replacement )
1:aff0657:     {
1:aff0657:         int substitutionIndex = stub.indexOf( token );
1:aff0657:         if ( substitutionIndex < 0 ) { fail( "Bad stub: " + stub + ". Can't find token: " + token ); }
1:aff0657: 
1:aff0657:         String  prefix = stub.substring( 0, substitutionIndex );
1:aff0657:         String  suffix = ( substitutionIndex == stub.length() - 1 ) ?
1:aff0657:             "" : stub.substring( substitutionIndex + 1, stub.length() );
1:aff0657: 
1:aff0657:         return prefix + replacement + suffix;
1:aff0657:     }
1:aff0657:     
1:69a192a:     private void queryAndCheck(
1:69a192a:         Statement stm,
1:69a192a:         String queryText,
1:69a192a:         String [][] expectedRows) throws SQLException {
1:69a192a: 
1:69a192a:         ResultSet rs = stm.executeQuery(queryText);
1:69a192a:         JDBC.assertFullResultSet(rs, expectedRows);
1:69a192a:     }
1:aff0657: 
1:69a192a: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("OffsetFetchNextTest");
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(OffsetFetchNextTest.class,
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1:  * Test {@code <result offset clause>} and {@code <fetch first clause>}.
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     private static void createSchemaObjects(Statement st) throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testErrors() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * reserved so we don't risk breaking existing applications.
1:      *
1:      * @throws java.sql.SQLException
1:     public void testNewKeywordNonReserved() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testOffsetFetchFirstReadOnlyForwardOnlyRS() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testOffsetFetchFirstUpdatableForwardOnlyRS() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:         for ( String variant : variants )
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testOffsetFetchFirstReadOnlyScrollableRS() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for ( String variant : variants )
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:         for ( String variant : variants )
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testOffsetFetchFirstUpdatableScrollableRS() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:         for ( String variant : variants )
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:     public void testValues() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testMetadata() throws SQLException
1:         for (String variant : variants)
1:             rs = stm.executeQuery( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testRunTimeStatistics() throws SQLException
1:         for (String variant : variants)
1:                           variant,
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testBigTable() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testRepeatedExecution() throws SQLException
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testDynamicArgs() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testDynamicArgsMetaData() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for (String variant : variants)
1:             ps = prepareStatement( variant );
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
1:     public void testJDBCLimitOffset() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         throws SQLException
1:         for (String text : variants)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f6d5ae4
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError(LANG_SYNTAX_ERROR, st,
0:                              "select * from t1 offset -? rows");
1: 
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
1:         prepareStatement("select a,b as offset from t1 offset 0 rows");
1:         prepareStatement("select a,b from t1 as offset");
1:         prepareStatement("select a,b offset from t1 offset");
1:         prepareStatement("select a,b offset from t1 offset +2 rows");
1:         prepareStatement("select a offset,b from t1 offset ? rows");
1:         prepareStatement("select offset.a, offset.b offset from t1 as offset offset ? rows");
1: 
1:         // DERBY-4562
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t4562(i int, offset int)");
1:         ResultSet rs = s.executeQuery(
1:             "select * from t4562 where i > 0 and offset + i < 0 offset 2 rows");
1:         rs.next();
1: 
1:         rs = s.executeQuery(
1:             "select * from t4562 where i > 0 and offset - i < 0 offset 2 rows");
1:         rs.next();
1: 
1:         rs = s.executeQuery(
1:             "select * from t4562 where i > 0 and offset * i < 0 offset 2 rows");
1:         rs.next();
1: 
1:         rs.close();
1: 
1:         rollback();
commit:108305b
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void testValues() throws SQLException {
1:         Statement stm = createStatement();
1: 
1:         queryAndCheck(
1:             stm,
0:             "values 4" +
0:             "    fetch first 2 row only",
0:             new String [][] {{"4"}});
1: 
1:         queryAndCheck(
1:             stm,
0:             "values 4" +
0:             "    offset 1 row",
0:             new String [][] {});
1: 
1: 
1:         stm.close();
1:     }
1: 
commit:00c7a20
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ParameterMetaData ;
/////////////////////////////////////////////////////////////////////////
1:     private final static String LANG_FORMAT_EXCEPTION = "22018";
1:     private final static String LANG_INTEGER_LITERAL_EXPECTED = "42X20";
1:     private final static String LANG_INVALID_ROW_COUNT_FIRST = "2201W";
1:     private final static String LANG_INVALID_ROW_COUNT_OFFSET = "2201X";
1:     private final static String LANG_MISSING_PARMS = "07000";
1:     private final static String LANG_SYNTAX_ERROR = "42X01";
1: 	private final static String LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL = "2201Z";
1: 
/////////////////////////////////////////////////////////////////////////
0:         assertStatementError(LANG_INVALID_ROW_COUNT_OFFSET, st,
1:         assertStatementError(LANG_INVALID_ROW_COUNT_FIRST, st,
1:         assertStatementError(LANG_INVALID_ROW_COUNT_FIRST, st,
0:         assertStatementError(LANG_INTEGER_LITERAL_EXPECTED, st,
1:         assertStatementError(LANG_SYNTAX_ERROR, st,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test dynamic arguments
1:      */
0:     public void testDynamicArgs() throws SQLException {
1:         // Check look-ahead also for ? in grammar since offset is not reserved
0:         PreparedStatement ps = prepareStatement(
0:             "select * from t1 offset ? rows");
1: 
1:         // Check range errors
0:         ps = prepareStatement(
0:             "select * from t1 order by b " +
0:             "offset ? rows fetch next ? rows only");
1: 
0:         ps.setInt(1, 0);
1:         assertPreparedStatementError(LANG_MISSING_PARMS, ps);
1: 
0:         ps.setInt(1, -1);
0:         ps.setInt(2, 2);
1:         assertPreparedStatementError(LANG_INVALID_ROW_COUNT_OFFSET, ps);
1: 
0:         ps.setInt(1, 0);
0:         ps.setInt(2, 0);
1:         assertPreparedStatementError(LANG_INVALID_ROW_COUNT_FIRST, ps);
1: 
1:         // Check non-integer values
1:         try {
0:             ps.setString(1, "aaa");
1:         } catch (SQLException e) {
1:             assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:         }
1: 
1:         try {
0:             ps.setString(2, "aaa");
1:         } catch (SQLException e) {
1:             assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:         }
1: 
1: 
1:         // A normal case
1:         String[][] expected = {{"1", "3"}, {"1", "4"}};
1:         for (int i = 0; i < 2; i++) {
0:             ps.setInt(1,2);
0:             ps.setInt(2,2);
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1: 
1:         // Now, note that since we now have different values for offset and
1:         // fetch first, we also exercise reusing the result set for this
1:         // prepared statement (i.e. the values are computed at execution time,
1:         // not at result set generation time). Try long value for change.
1:         ps.setLong(1, 1L);
0:         ps.setInt(2, 3);
1:         expected = new String[][]{{"1", "2"}, {"1", "3"}, {"1", "4"}};
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1: 
1: 
1:         //  Try a large number
0:         ps.setLong(1, Integer.MAX_VALUE * 2L);
0:         ps.setInt(2, 5);
1:         JDBC.assertEmpty(ps.executeQuery());
1: 
1:         // Mix of prepared and not
0:         ps = prepareStatement(
0:             "select * from t1 order by b " +
0:              "offset ? rows fetch next 3 rows only");
1:         ps.setLong(1, 1L);
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1: 
0:         ps = prepareStatement(
0:             "select * from t1 order by b " +
0:              "offset 4 rows fetch next ? rows only");
1:         ps.setLong(1, 1L);
0:         JDBC.assertFullResultSet(ps.executeQuery(),
0:                                  new String[][]{{"1", "5"}});
1: 
1:         // Mix of other dyn args and ours:
0:         ps = prepareStatement(
0:             "select * from t1 where a = ? order by b " +
0:              "offset ? rows fetch next 3 rows only");
1:         ps.setInt(1, 1);
1:         ps.setLong(2, 1L);
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1: 
0:         ps = prepareStatement(
0:             "select * from t1 where a = ? order by b " +
0:              "offset 1 rows fetch next ? rows only");
1:         ps.setInt(1, 1);
1:         ps.setLong(2, 2L);
1:         expected = new String[][]{{"1", "2"}, {"1", "3"}};
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1: 
1: 
1:         // NULLs not allowed (Note: parameter metadata says "isNullable" for
1:         // all ? args in Derby...)
0:         ps = prepareStatement(
0:             "select * from t1 order by b " +
0:              "offset ? rows fetch next ? rows only");
0:         ps.setNull(1, Types.BIGINT);
0:         ps.setInt(2, 2);
1:         assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1: 
0:         ps.setInt(1,1);
0:         ps.setNull(2, Types.BIGINT);
1:         assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Test dynamic arguments
1:      */
0:     public void testDynamicArgsMetaData() throws SQLException {
0:         PreparedStatement ps = prepareStatement(
0:             "select * from t1 where a = ? order by b " +
0:             "offset ? rows fetch next ? rows only");
1: 
1:         ParameterMetaData pmd = ps.getParameterMetaData();
1:         int[] expectedTypes = { Types.INTEGER, Types.BIGINT, Types.BIGINT };
1: 
1:         for (int i = 0; i < 3; i++) {
1:             assertEquals("Unexpected parameter type",
1:                          expectedTypes[i], pmd.getParameterType(i+1));
1:             assertEquals("Derby ? args are nullable",
1:                          // Why is that? Cf. logic in ParameterNode.setType
1:                          ParameterMetaData.parameterNullable,
1:                          pmd.isNullable(i+1));
1:         }
1:         ps.close();
1:     }
1: 
commit:640d05d
/////////////////////////////////////////////////////////////////////////
0:     public void testRepeatedExecution() throws SQLException {
commit:e0b3d81
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(plan.indexOf("Row Count (1):\n" +
1:                                 "Number of opens = 1\n" +
1:                                 "Rows seen = 3\n" +
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OffsetFetchNextTest
1: 
1:   Licensed to the Apache Software Foundation (ASF) under one or more
1:   contributor license agreements.  See the NOTICE file distributed with
1:   this work for additional information regarding copyright ownership.
1:   The ASF licenses this file to You under the Apache License, Version 2.0
1:   (the "License"); you may not use this file except in compliance with
1:   the License.  You may obtain a copy of the License at
1: 
1:   http://www.apache.org/licenses/LICENSE-2.0
1: 
1:   Unless required by applicable law or agreed to in writing, software
1:   distributed under the License is distributed on an "AS IS" BASIS,
1:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:   See the License for the specific language governing permissions and
1:   limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
0: import java.sql.PreparedStatement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
0:  * Test <result offset clause> and <fetch first clause>.
1:  */
1: public class OffsetFetchNextTest extends BaseJDBCTestCase {
1: 
1:     public OffsetFetchNextTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("OffsetFetchNextTest");
1: 
1:         suite.addTest(
1:             baseSuite("OffsetFetchNextTest:embedded"));
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
1:                 baseSuite("OffsetFetchNextTest:client")));
1: 
1:         return suite;
1:     }
1: 
1:     public static Test baseSuite(String suiteName) {
1:         return new CleanDatabaseTestSetup(
0:             new TestSuite(OffsetFetchNextTest.class,
1:                           suiteName)) {
1:             protected void decorateSQL(Statement s)
1:                     throws SQLException {
1:                 createSchemaObjects(s);
1:             }
1:         };
1:     }
1: 
1: 
1:     /**
1:      * Creates tables used by the tests (never modified, we use rollback after
1:      * changes).
1:      */
0:     private static void createSchemaObjects(Statement st)
0:             throws SQLException
1:     {
1:         // T1 (no indexes)
1:         st.executeUpdate("create table t1 (a int, b bigint)");
1:         st.executeUpdate("insert into t1 (a, b) " +
1:                          "values (1,1), (1,2), (1,3), (1,4), (1,5)");
1: 
1:         // T2 (primary key)
1:         st.executeUpdate("create table t2 (a int primary key, b bigint)");
1:         st.executeUpdate("insert into t2 (a, b) " +
1:                          "values (1,1), (2,1), (3,1), (4,1), (5,1)");
1: 
1:         // T3 (primary key + secondary key)
1:         st.executeUpdate("create table t3 (a int primary key, " +
1:                          "                 b bigint unique)");
1:         st.executeUpdate("insert into t3 (a, b) " +
1:                          "values (1,1), (2,2), (3,3), (4,4), (5,5)");
1:     }
1: 
1:     /**
1:      * Negative tests. Test various invalid OFFSET and FETCH NEXT clauses.
1:      */
0:     public void testErrors()
0:             throws Exception
1:     {
1:         Statement st = createStatement();
1: 
1:         // Wrong range in row count argument
1: 
0:         assertStatementError("2201X", st,
0:                              "select * from t1 offset -1 rows");
1: 
0:         assertStatementError("2201W", st,
1:                              "select * from t1 fetch first 0 rows only");
1: 
0:         assertStatementError("2201W", st,
0:                              "select * from t1 fetch first -1 rows only");
1: 
1:         // Wrong type in row count argument
0:         assertStatementError("42X20", st,
0:                              "select * from t1 fetch first 3.14 rows only");
1: 
1:         // Wrong order of clauses
0:         assertStatementError("42X01", st,
1:                              "select * from t1 " +
1:                              "fetch first 0 rows only offset 0 rows");
1:     }
1: 
1: 
1:     /**
1:      * Positive tests. Check that the new keyword OFFSET introduced is not
0:      * reserved so we don't risk breaking existing apps.
1:      */
0:     public void testNewKeywordNonReserved()
0:             throws Exception
1:     {
0:         getConnection().prepareStatement(
0:             "select a,b as OFFSET from t1 OFFSET 0 rows");
1: 
1:         // Column and table correlation name usage
0:         getConnection().prepareStatement(
0:             "select a,b from t1 AS OFFSET");
1: 
0:         getConnection().prepareStatement(
0:             "select a,b OFFSET from t1 OFFSET");
1:     }
1: 
1: 
1:     /**
1:      * Positive tests.
1:      */
0:     public void testOffsetFetchFirstReadOnlyForwardOnlyRS()
0:             throws Exception
1:     {
1:         Statement stm = createStatement();
1: 
1:         /*
1:          * offset 0 rows (a no-op)
1:          */
1: 
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 0 rows",
1:             new String [][] {
0:                 {"1","1"}, {"1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 0 rows",
1:             new String [][] {
0:                 {"1","1"}, {"2","1"},{"3","1"}, {"4","1"},{"5","1"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 0 rows",
1:             new String [][] {
0:                 {"1","1"}, {"2","2"},{"3","3"}, {"4","4"},{"5","5"}});
1: 
1:         /*
1:          * offset 1 rows
1:          */
1: 
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 1 rows",
1:             new String [][] {
0:                 {"1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 1 rows",
1:             new String [][] {
0:                 {"2","1"},{"3","1"}, {"4","1"},{"5","1"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 1 rows",
1:             new String [][] {
0:                 {"2","2"},{"3","3"}, {"4","4"},{"5","5"}});
1: 
1:         /*
1:          * offset 4 rows
1:          */
1: 
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 4 rows",
1:             new String [][] {
0:                 {"1","5"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 4 rows",
1:             new String [][] {
0:                 {"5","1"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 4 rows",
1:             new String [][] {
0:                 {"5","5"}});
1: 
1:         /*
1:          * offset 1 rows fetch 1 row. Use "next"/"rows" syntax
1:          */
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 1 row fetch next 1 rows only",
1:             new String [][] {
0:                 {"1","2"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 1 row fetch next 1 rows only",
1:             new String [][] {
0:                 {"2","1"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 1 row  fetch next 1 rows only",
1:             new String [][] {
0:                 {"2","2"}});
1: 
1:         /*
1:          * offset 1 rows fetch so many rows we drain rs row. Use "first"/"row"
1:          * syntax
1:          */
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 1 rows fetch first 10 row only",
1:             new String [][] {
0:                 {"1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 1 rows fetch first 10 row only",
1:             new String [][] {
0:                 {"2","1"},{"3","1"}, {"4","1"},{"5","1"}});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 1 rows  fetch first 10 row only",
1:             new String [][] {
0:                 {"2","2"},{"3","3"}, {"4","4"},{"5","5"}});
1: 
1:         /*
1:          * offset so many rows that we see empty rs
1:          */
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 10 rows",
0:             new String [][] {});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t2 offset 10 rows",
0:             new String [][] {});
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t3 offset 10 rows",
0:             new String [][] {});
1: 
1:         /*
1:          * fetch first/next row (no row count given)
1:          */
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1 fetch first row only",
1:             new String [][] {{"1","1"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t2 fetch next row only",
1:             new String [][] {{"1","1"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t3 fetch next row only",
1:             new String [][] {{"1","1"}});
1: 
1:         /*
1:          * Combine with order by asc
1:          */
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1 order by b asc fetch first row only",
1:             new String [][] {{"1","1"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t2 order by a asc fetch next row only",
1:             new String [][] {{"1","1"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t3 order by a asc fetch next row only",
1:             new String [][] {{"1","1"}});
1: 
1: 
1:         /*
1:          * Combine with order by desc.
1:          */
1:         queryAndCheck(
1:             stm,
1:             // Note: use column b here since for t1 all column a values are the
1:             // same and order can change after sorting, want unique row first
1:             // in rs so we can test it.
1:             "select a,b from t1 order by b desc fetch first row only",
1:             new String [][] {{"1","5"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t2 order by a desc fetch next row only",
1:             new String [][] {{"5","1"}});
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t3 order by a desc fetch next row only",
1:             new String [][] {{"5","5"}});
1: 
1:         /*
1:          * Combine with group by, order by.
1:          */
1:         queryAndCheck(
1:             stm,
1:             "select max(a) from t1 group by b fetch first row only",
1:             new String [][] {{"1"}});
1:         queryAndCheck(
1:             stm,
0:             "select max(a) from t2 group by b offset 0 rows",
0:             new String [][] {{"5"}});
1:         queryAndCheck(
1:             stm,
0:             "select max(a) from t3 group by b " +
0:             "    order by max(a) fetch next 2 rows only",
0:             new String [][] {{"1"},{"2"}});
1: 
1:         /*
1:          * Combine with union
1:          */
1: 
1:         queryAndCheck(
1:             stm,
0:             "select * from t1 union all select * from t1 " +
0:             "    fetch first 2 row only",
0:             new String [][] {{"1","1"}, {"1","2"}});
1: 
1:         /*
1:          * Combine with join
1:          */
1:         queryAndCheck(
1:             stm,
0:             "select t2.b, t3.b from t2,t3 where t2.a=t3.a " +
0:             "    fetch first 2 row only",
0:             new String [][] {{"1","1"}, {"1","2"}});
1: 
1:         stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Positive tests.
1:      */
0:     public void testOffsetFetchFirstUpdatableForwardOnlyRS()
0:             throws Exception
1:     {
1:         Statement stm = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                         ResultSet.CONCUR_UPDATABLE);
1: 
0:         getConnection().setAutoCommit(false);
1: 
1:         /*
1:          * offset 0 rows (a no-op), update a row and verify result
1:          */
0:         ResultSet rs = stm.executeQuery("select * from t1  offset 0 rows");
1:         rs.next();
1:         rs.next(); // at row 2
1:         rs.updateInt(1, -rs.getInt(1));
1:         rs.updateRow();
1:         rs.close();
1: 
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1",
1:             new String [][] {
1:                 {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1: 
1:         rollback();
1: 
1:         /*
1:          * offset 1 rows, update a row and verify result
1:          */
0:         rs = stm.executeQuery("select * from t1 offset 1 rows");
1:         rs.next(); // at row 1, but row 2 of underlying rs
1: 
1:         rs.updateInt(1, -rs.getInt(1));
1:         rs.updateRow();
1:         rs.close();
1: 
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1",
1:             new String [][] {
1:                 {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1: 
1:         rollback();
1:         stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Positive tests with scrollable read-only.
1:      */
0:     public void testOffsetFetchFirstReadOnlyScrollableRS()
0:             throws Exception
1:     {
1:         Statement stm = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                         ResultSet.CONCUR_READ_ONLY);
1: 
1:         /*
1:          * offset 0 rows (a no-op), update a row and verify result
1:          */
0:         ResultSet rs = stm.executeQuery("select * from t1  offset 0 rows");
1:         rs.next();
1:         rs.next(); // at row 2
1:         assertTrue(rs.getInt(2) == 2);
1:         rs.close();
1: 
1:         /*
1:          * offset 1 rows, fetch 3 row, check that we have the right ones
1:          */
0:         rs = stm.executeQuery(
0:             "select * from t1 " + "offset 1 rows fetch next 3 rows only");
1:         rs.next();
1:         rs.next(); // at row 2, but row 3 of underlying rs
1: 
1:         assertTrue(rs.getInt(2) == 3);
1: 
1:         // Go backbards and update
1:         rs.previous();
1:         assertTrue(rs.getInt(2) == 2);
1: 
1:         // Try some navigation and border conditions
1:         rs.previous();
1:         assertTrue(rs.isBeforeFirst());
1:         rs.next();
1:         rs.next();
1:         rs.next();
1:         rs.next();
1:         assertTrue(rs.isAfterLast());
1: 
1:         stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Positive tests with SUR (Scrollable updatable result set).
1:      */
0:     public void testOffsetFetchFirstUpdatableScrollableRS()
0:             throws Exception
1:     {
1:         Statement stm = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                         ResultSet.CONCUR_UPDATABLE);
1: 
0:         getConnection().setAutoCommit(false);
1: 
1:         /*
1:          * offset 0 rows (a no-op), update a row and verify result
1:          * also try the "for update" syntax so we see that it still works
1:          */
0:         ResultSet rs = stm.executeQuery(
0:             "select * from t1  offset 0 rows for update");
1:         rs.next();
1:         rs.next(); // at row 2
1:         rs.updateInt(1, -rs.getInt(1));
1:         rs.updateRow();
1:         rs.close();
1: 
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1",
1:             new String [][] {
1:                 {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
1: 
1:         rollback();
1: 
1:         /*
1:          * offset 1 rows, fetch 3 row, update some rows and verify result
1:          */
0:         rs = stm.executeQuery(
0:             "select * from t1 offset 1 rows fetch next 3 rows only");
1:         rs.next();
1:         rs.next(); // at row 2, but row 3 of underlying rs
1: 
1:         rs.updateInt(1, -rs.getInt(1));
1:         rs.updateRow();
1: 
1:         // Go backbards and update
1:         rs.previous();
1:         rs.updateInt(1, -rs.getInt(1));
1:         rs.updateRow();
1: 
1:         // Try some navigation and border conditions
1:         rs.previous();
1:         assertTrue(rs.isBeforeFirst());
1:         rs.next();
1:         rs.next();
1:         rs.next();
1:         rs.next();
1:         assertTrue(rs.isAfterLast());
1: 
1:         // Insert a row
1:         rs.moveToInsertRow();
1:         rs.updateInt(1,42);
1:         rs.updateInt(2,42);
1:         rs.insertRow();
1: 
1:         // Delete a row
1:         rs.previous();
1:         rs.deleteRow();
1: 
1:         // .. and see that a hole is left in its place
1:         rs.previous();
1:         rs.next();
1:         assertTrue(rs.rowDeleted());
1: 
1:         rs.close();
1: 
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1",
1:             new String [][] {
1:                 {"1","1"}, {"-1","2"},{"-1","3"},{"1","5"},{"42","42"}});
1:         rollback();
1: 
1:         // Test with projection
0:         rs = stm.executeQuery(
0:             "select * from t1 where a + 1 < b offset 1 rows");
1:         // should yield 2 rows
1:         rs.absolute(2);
1:         assertTrue(rs.getInt(2) == 5);
1:         rs.updateInt(2, -5);
1:         rs.updateRow();
1:         rs.close();
1: 
1:         queryAndCheck(
1:             stm,
1:             "select a,b from t1",
1:             new String [][] {
1:                 {"1","1"}, {"1","2"},{"1","3"},{"1","4"},{"1","-5"}});
1:         rollback();
1: 
1:         stm.close();
1:     }
1: 
1:     /**
1:      * Positive tests, result set metadata
1:      */
0:     public void testMetadata() throws SQLException {
1:         Statement stm = createStatement();
1: 
0:         ResultSet rs = stm.executeQuery("select * from t1 offset 1 rows");
1:         ResultSetMetaData rsmd= rs.getMetaData();
1:         int cnt = rsmd.getColumnCount();
1: 
1:         String[] cols = new String[]{"A","B"};
1:         int[] types = {Types.INTEGER, Types.BIGINT};
1: 
1:         for (int i=1; i <= cnt; i++) {
1:             String name = rsmd.getColumnName(i);
1:             int type = rsmd.getColumnType(i);
1: 
1:             assertTrue(name.equals(cols[i-1]));
1:             assertTrue(type == types[i-1]);
1:         }
1: 
1:         rs.close();
1:         stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Test that we see correct traces of the filtering in the statistics
1:      */
0:     public void testRunTimeStatistics() throws SQLException {
1:         Statement stm = createStatement();
1: 
0:         stm.executeUpdate("call syscs_util.syscs_set_runtimestatistics(1)");
1: 
1:         queryAndCheck(
1:             stm,
0:             "select a,b from t1 offset 2 rows",
1:             new String [][] {
1:                 {"1","3"}, {"1","4"},{"1","5"}});
1: 
0:         stm.executeUpdate("call syscs_util.syscs_set_runtimestatistics(0)");
1: 
0:         ResultSet rs = stm.executeQuery(
0:             "values syscs_util.syscs_get_runtimestatistics()");
1:         rs.next();
1:         String plan = rs.getString(1);
1: 
0:         String nl = System.getProperty("line.separator");
1: 
1:         // Verify that the plan shows the filtering (2 rows of 3 seen):
0:         assertTrue(plan.indexOf("Row Count (1):" + nl +
0:                                 "Number of opens = 1" + nl +
0:                                 "Rows seen = 3" + nl +
1:                                 "Rows filtered = 2") != -1);
1: 
1:         rs.close();
1:         stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Test against a bigger table
1:      */
0:     public void testBigTable() throws SQLException {
1:         Statement stm = createStatement();
1: 
0:         getConnection().setAutoCommit(false);
1: 
1:         stm.executeUpdate("declare global temporary table session.t (i int) " +
1:                           "on commit preserve rows not logged");
1: 
1:         PreparedStatement ps =
0:             getConnection().prepareStatement("insert into session.t values ?");
1: 
1:         for (int i=1; i <= 100000; i++) {
1:             ps.setInt(1, i);
1:             ps.executeUpdate();
1: 
1:             if (i % 10000 == 0) {
1:                 commit();
1:             }
1:         }
1: 
1:         queryAndCheck(
1:             stm,
1:             "select count(*) from session.t",
1:             new String [][] {
1:                 {"100000"}});
1: 
1:         queryAndCheck(
1:             stm,
0:             "select i from session.t offset 99999 rows",
1:             new String [][] {
1:                 {"100000"}});
1: 
1:         stm.executeUpdate("drop table session.t");
1:         stm.close();
1:     }
1: 
1: 
1:     private void queryAndCheck(
1:         Statement stm,
1:         String queryText,
1:         String [][] expectedRows) throws SQLException {
1: 
1:         ResultSet rs = stm.executeQuery(queryText);
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:955f104
/////////////////////////////////////////////////////////////////////////
1:      * Test some additional corner cases in JDBC limit/offset syntax.
1:      */
0:     public  void    testJDBCLimitOffset()   throws Exception
1:     {
1:         // LIMIT 0 is allowed. It means: everything from the OFFSET forward
1:         PreparedStatement   ps = prepareStatement( "select a from t2 order by a { limit ? }" );
1:         ps.setInt( 1, 0 );
1:         JDBC.assertFullResultSet
1:             (
1:              ps.executeQuery(),
1:              new String[][] { { "1" }, { "2" }, { "3" }, { "4" }, { "5" } }
1:              );
1:         ps.close();
1: 
1:         ps = prepareStatement( "select a from t2 order by a { limit ? offset 3 }" );
1:         ps.setInt( 1, 0 );
1:         JDBC.assertFullResultSet
1:             (
1:              ps.executeQuery(),
1:              new String[][] { { "4" }, { "5" } }
1:              );
1:         ps.close();
1: 
1:         // mix JDBC and SQL Standard syntax
1:         ps = prepareStatement
1:             (
1:              "select t.a from\n" +
1:              "( select * from t2 order by a { limit 3 offset 1 } ) t,\n" +
1:              "( select * from t3 order by a offset 2 rows fetch next 10 rows only ) s\n" +
1:              "where t.a = s.a order by t.a"
1:              );
1:         JDBC.assertFullResultSet
1:             (
1:              ps.executeQuery(),
1:              new String[][] { { "3" }, { "4" } }
1:              );
1:         ps.close();
1:     }
1: 
1:     /**
commit:aff0657
/////////////////////////////////////////////////////////////////////////
1:     private final static String PERCENT_TOKEN = "%";
1:     
1:     // flavors of SQL Standard syntax
1:     private final static String FIRST_ROWS_ONLY = "fetch first % rows only";
1:     private final static String FIRST_ROW_ONLY = "fetch first % row only";
1:     private final static String NEXT_ROWS_ONLY = "fetch next % rows only";
1: 
1:     // variants
1:     private final static int SQL_STANDARD_VARIANT = 0;
1:     private final static int JDBC_VARIANT = SQL_STANDARD_VARIANT + 1;
1:     private final static int VARIANT_COUNT = JDBC_VARIANT + 1;
1: 
/////////////////////////////////////////////////////////////////////////
1:         String  stub = "select * from t1 %";
1: 
1:         vetStatement( st, LANG_INVALID_ROW_COUNT_OFFSET, stub, FIRST_ROWS_ONLY, "-1", null, null );
1:         vetStatement( st, LANG_SYNTAX_ERROR, stub, FIRST_ROWS_ONLY, "-?", null, null );
1:         vetStatement( st, LANG_INVALID_ROW_COUNT_FIRST, stub, FIRST_ROWS_ONLY, null, "-1", null );
1:         vetStatement( st, LANG_INTEGER_LITERAL_EXPECTED, stub, FIRST_ROWS_ONLY, null, "3.14", null );
0:         assertStatementError(LANG_SYNTAX_ERROR, st,
1:                              "select * from t1 { offset 0 limit 0 }");
/////////////////////////////////////////////////////////////////////////
1:         prepareStatement("select a,b as limit from t1 offset 0 rows");
1:         prepareStatement("select a,b from t1 as limit");
1:         prepareStatement("select a,b limit from t1 limit");
1: 
1: 
1: 
1:         prepareStatement("select limit.a, limit.b offset from t1 as limit offset ? rows");
/////////////////////////////////////////////////////////////////////////
1:         vetStatement
1:             (
1:              stm, null, "select a, b from t1%", FIRST_ROWS_ONLY, "0", null,
1:              new String [][] { {"1","1"}, {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "0", null,
1:              new String [][] { {"1","1"}, {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "0", null,
1:              new String [][] { {"1","1"}, {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "1", null,
1:              new String [][] { {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "1", null,
1:              new String [][] { {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "1", null,
1:              new String [][] { {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "4", null,
1:              new String [][] { {"1","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "4", null,
1:              new String [][] { {"5","1"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "4", null,
1:              new String [][] {  {"5","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t1%", FIRST_ROWS_ONLY, "1", "1",
1:              new String [][] { {"1","2"}  }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROWS_ONLY, "1", "1",
1:              new String [][] { {"2","1"}  }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROWS_ONLY, "1", "1",
1:              new String [][] { {"2","2"}  }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t1%", FIRST_ROW_ONLY, "1", "10",
1:              new String [][] { {"1","2"},{"1","3"}, {"1","4"},{"1","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROW_ONLY, "1", "10",
1:              new String [][] { {"2","1"},{"3","1"}, {"4","1"},{"5","1"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROW_ONLY, "1", "10",
1:              new String [][] { {"2","2"},{"3","3"}, {"4","4"},{"5","5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t1%", FIRST_ROW_ONLY, "10", null,
1:              new String [][] { }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t2%", FIRST_ROW_ONLY, "10", null,
1:              new String [][] { }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select a,b from t3%", FIRST_ROW_ONLY, "10", null,
1:              new String [][] { }
1:              );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         vetStatement
1:             (
1:              stm, null, "select max(a) from t2 group by b %", FIRST_ROW_ONLY, "0", null,
1:              new String [][] { {"5"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select max(a) from t3 group by b order by max(a) %", NEXT_ROWS_ONLY, null, "2",
1:              new String [][] { {"1"},{"2"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select * from t1 union all select * from t1 %", FIRST_ROW_ONLY, null, "2",
1:              new String [][] { {"1","1"}, {"1","2"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "select t2.b, t3.b from t2,t3 where t2.a=t3.a %", FIRST_ROW_ONLY, null, "2",
1:              new String [][] { {"1","1"}, {"1","2"} }
1:              );
/////////////////////////////////////////////////////////////////////////
1:         ResultSet   rs;
1:         String[]    variants;
1:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "0", null );
1:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next();
0:             rs.next(); // at row 2
0:             rs.updateInt(1, -rs.getInt(1));
0:             rs.updateRow();
0:             rs.close();
0:             queryAndCheck(
0:                           stm,
0:                           "select a,b from t1",
0:                           new String [][] {
0:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
0:             rollback();
1:         }
1:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "1", null );
1:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next(); // at row 1, but row 2 of underlying rs
0:             rs.updateInt(1, -rs.getInt(1));
0:             rs.updateRow();
0:             rs.close();
0:             queryAndCheck(
0:                           stm,
0:                           "select a,b from t1",
0:                           new String [][] {
0:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
0:             rollback();
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         ResultSet   rs;
1:         String[]    variants;
1:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "0", null );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next();
0:             rs.next(); // at row 2
0:             assertTrue(rs.getInt(2) == 2);
0:             rs.close();
1:         }
1:         
1:         variants = makeVariants( "select * from t1 %", FIRST_ROWS_ONLY, "1", "3" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next();
0:             rs.next(); // at row 2, but row 3 of underlying rs
0:             assertTrue(rs.getInt(2) == 3);
0:             // Go backbards and update
0:             rs.previous();
0:             assertTrue(rs.getInt(2) == 2);
0:             // Try some navigation and border conditions
0:             rs.previous();
0:             assertTrue(rs.isBeforeFirst());
0:             rs.next();
0:             rs.next();
0:             rs.next();
0:             rs.next();
0:             assertTrue(rs.isAfterLast());
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         ResultSet   rs;
1:         String[]    variants;
/////////////////////////////////////////////////////////////////////////
1:         variants = makeVariants( "select * from t1 % for update", FIRST_ROWS_ONLY, "0", null );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next();
0:             rs.next(); // at row 2
0:             rs.updateInt(1, -rs.getInt(1));
0:             rs.updateRow();
0:             rs.close();
0:             queryAndCheck(
0:                           stm,
0:                           "select a,b from t1",
0:                           new String [][] {
0:                               {"1","1"}, {"-1","2"},{"1","3"}, {"1","4"},{"1","5"}});
0:             rollback();
1:         }
1:         
1:         variants = makeVariants( "select * from t1 %", NEXT_ROWS_ONLY, "1", "3" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             rs.next();
0:             rs.next(); // at row 2, but row 3 of underlying rs
0:             rs.updateInt(1, -rs.getInt(1));
0:             rs.updateRow();
0:             // Go backbards and update
0:             rs.previous();
0:             rs.updateInt(1, -rs.getInt(1));
0:             rs.updateRow();
0:             // Try some navigation and border conditions
0:             rs.previous();
0:             assertTrue(rs.isBeforeFirst());
0:             rs.next();
0:             rs.next();
0:             rs.next();
0:             rs.next();
0:             assertTrue(rs.isAfterLast());
0:             // Insert a row
0:             rs.moveToInsertRow();
0:             rs.updateInt(1,42);
0:             rs.updateInt(2,42);
0:             rs.insertRow();
0:             // Delete a row
0:             rs.previous();
0:             rs.deleteRow();
0:             // .. and see that a hole is left in its place
0:             rs.previous();
0:             rs.next();
0:             assertTrue(rs.rowDeleted());
0:             rs.close();
0:             queryAndCheck(
0:                           stm,
0:                           "select a,b from t1",
0:                           new String [][] {
0:                               {"1","1"}, {"-1","2"},{"-1","3"},{"1","5"},{"42","42"}});
0:             rollback();
1:         }
1:         
1:         variants = makeVariants( "select * from t1 where a + 1 < b%", NEXT_ROWS_ONLY, "1", null );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             rs = stm.executeQuery( variants[ i ] );
0:             // should yield 2 rows
0:             rs.absolute(2);
0:             assertTrue(rs.getInt(2) == 5);
0:             rs.updateInt(2, -5);
0:             rs.updateRow();
0:             rs.close();
0:             queryAndCheck(
0:                           stm,
0:                           "select a,b from t1",
0:                           new String [][] {
0:                               {"1","1"}, {"1","2"},{"1","3"},{"1","4"},{"1","-5"}});
0:             rollback();
1:         }
1:         
0:     public void testValues() throws Exception
1:     {
1:         vetStatement
1:             (
1:              stm, null, "values 4%", FIRST_ROW_ONLY, null, "2",
1:              new String [][] { {"4"} }
1:              );
1:         vetStatement
1:             (
1:              stm, null, "values 4%", FIRST_ROW_ONLY, "1", null,
1:              new String [][] { }
1:              );
/////////////////////////////////////////////////////////////////////////
0:     public void testMetadata() throws Exception
1:     {
1:         ResultSet   rs;
1:         String[]    variants;
1:         variants = makeVariants( "select * from t1%", NEXT_ROWS_ONLY, "1", null );
1:         for ( int j = 0; j < variants.length; j++ )
1:         {
0:             rs = stm.executeQuery( variants[ j ] );
0:             ResultSetMetaData rsmd= rs.getMetaData();
0:             int cnt = rsmd.getColumnCount();
0:             String[] cols = new String[]{"A","B"};
0:             int[] types = {Types.INTEGER, Types.BIGINT};
0:             for (int i=1; i <= cnt; i++) {
0:                 String name = rsmd.getColumnName(i);
0:                 int type = rsmd.getColumnType(i);
0:                 assertTrue(name.equals(cols[i-1]));
0:                 assertTrue(type == types[i-1]);
1:             }
1: 
0:             rs.close();
1:         
/////////////////////////////////////////////////////////////////////////
0:     public void testRunTimeStatistics() throws Exception
1:     {
1:         ResultSet   rs;
1:         String[]    variants;
1:         variants = makeVariants( "select a,b from t1%", NEXT_ROWS_ONLY, "2", null );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             stm.executeUpdate( "call syscs_util.syscs_set_runtimestatistics(1)" );
0:             queryAndCheck(
0:                           stm,
0:                           variants[ i ],
0:                           new String [][] {
0:                               {"1","3"}, {"1","4"},{"1","5"}});
1:             stm.executeUpdate( "call syscs_util.syscs_set_runtimestatistics(0)" );
1:             rs = stm.executeQuery( "values syscs_util.syscs_get_runtimestatistics()" );
0:             rs.next();
0:             String plan = rs.getString(1);
0:             // Verify that the plan shows the filtering (2 rows of 3 seen):
0:             assertTrue(plan.indexOf("Row Count (1):\n" +
0:                                     "Number of opens = 1\n" +
0:                                     "Rows seen = 3\n" +
0:                                     "Rows filtered = 2") != -1);
0:             rs.close();
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:     public void testBigTable() throws Exception
1:     {
/////////////////////////////////////////////////////////////////////////
1:         vetStatement
1:             (
1:              stm, null, "select i from session.t%", FIRST_ROWS_ONLY, "99999", null,
1:              new String [][] { {"100000"} }
1:              );
/////////////////////////////////////////////////////////////////////////
0:     public void testRepeatedExecution() throws Exception
1:     {
1:         PreparedStatement ps;
0:         ResultSet   rs;
1:         String[]    variants;
1: 
1:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "2", "2" );
0:         for ( int j = 0; j < variants.length; j++ )
1:         {
1:             ps = prepareStatement( variants[ j ] );
0:             String[][] expected = {{"1", "3"}, {"1", "4"}};
1:             for (int i = 0; i < 10; i++) {
1:                 JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:             }
0:     public void testDynamicArgs() throws Exception
1:     {
1:         PreparedStatement ps;
1:         String[]    variants;
1:         String[][] expected = null;
1: 
1:         variants = makeVariants( "select * from t1%", NEXT_ROWS_ONLY, "?", null );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
1:         
1:         
1:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "?" );
0:         for ( int j = 0; j < variants.length; j++ )
1:         {
1:             // SQL Standard and JDBC limit/offset parameter orders are different
1:             int offsetParam = ( j == SQL_STANDARD_VARIANT ) ? 1 : 2;
1:             int fetchParam = ( j == SQL_STANDARD_VARIANT ) ? 2 : 1;
1:             
1:             expected = new String[][] {{"1", "3"}, {"1", "4"}};
1:             ps = prepareStatement( variants[ j ] );
0:             // Check range errors
1: 
1:             ps.setInt( offsetParam, 0 );
0:             assertPreparedStatementError(LANG_MISSING_PARMS, ps);
1: 
1:             ps.setInt( offsetParam, -1 );
1:             ps.setInt( fetchParam, 2 );
0:             assertPreparedStatementError(LANG_INVALID_ROW_COUNT_OFFSET, ps);
1: 
1:             ps.setInt( offsetParam, 0 );
1:             ps.setInt( fetchParam, ( j == SQL_STANDARD_VARIANT ) ? 0 : -1 );
0:             assertPreparedStatementError(LANG_INVALID_ROW_COUNT_FIRST, ps);
1: 
0:             // Check non-integer values
0:             try {
1:                 ps.setString( offsetParam, "aaa");
0:             } catch (SQLException e) {
0:                 assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:             }
1: 
0:             try {
1:                 ps.setString( fetchParam, "aaa");
0:             } catch (SQLException e) {
0:                 assertSQLState(LANG_FORMAT_EXCEPTION, e);
1:             }
1: 
1: 
0:             // A normal case
0:             for (int i = 0; i < 2; i++) {
1:                 ps.setInt( offsetParam,2 );
1:                 ps.setInt( fetchParam,2 );
1:                 JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:             }
1: 
0:             // Now, note that since we now have different values for offset and
0:             // fetch first, we also exercise reusing the result set for this
0:             // prepared statement (i.e. the values are computed at execution time,
0:             // not at result set generation time). Try long value for change.
1:             ps.setLong( offsetParam, 1L );
1:             ps.setInt( fetchParam, 3 );
0:             expected = new String[][]{{"1", "2"}, {"1", "3"}, {"1", "4"}};
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1: 
1: 
0:             //  Try a large number
1:             ps.setLong( offsetParam, Integer.MAX_VALUE * 2L );
1:             ps.setInt( fetchParam, 5 );
0:             JDBC.assertEmpty(ps.executeQuery());
1:         
0:         // Mix of prepared and not
1:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "3" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
0:             ps.setLong(1, 1L);
1:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "4", "?" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
0:             ps.setLong(1, 1L);
1:             JDBC.assertFullResultSet(ps.executeQuery(), new String[][]{{"1", "5"}});
1:         }
1:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "?", "3" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
0:             ps.setInt(1, 1);
0:             ps.setLong(2, 1L);
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "1", "?" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
0:             ps.setInt(1, 1);
0:             ps.setLong(2, 2L);
0:             expected = new String[][]{{"1", "2"}, {"1", "3"}};
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1:         variants = makeVariants( "select * from t1 order by b%", NEXT_ROWS_ONLY, "?", "?" );
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
1:             ps = prepareStatement( variants[ i ] );
1:             int offsetParam = ( i == SQL_STANDARD_VARIANT ) ? 1 : 2;
1:             int fetchParam = ( i == SQL_STANDARD_VARIANT ) ? 2 : 1;
1:             
1:             ps.setNull( offsetParam, Types.BIGINT );
1:             ps.setInt( fetchParam, 2 );
0:             assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1:             ps.setInt( offsetParam,1 );
1:             ps.setNull( fetchParam, Types.BIGINT );
0:             assertPreparedStatementError(LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL, ps);
1:             
0:             ps.close();
1:         }
0:     public void testDynamicArgsMetaData() throws Exception
1:     {
1:         PreparedStatement ps;
1:         String[]    variants;
1:         variants = makeVariants( "select * from t1 where a = ? order by b%", NEXT_ROWS_ONLY, "?", "?" );
0:         for ( int j = 0; j < variants.length; j++ )
1:         {
1:             ps = prepareStatement( variants[ j ] );
1:             
0:             ParameterMetaData pmd = ps.getParameterMetaData();
0:             int[] expectedTypes = { Types.INTEGER, Types.BIGINT, Types.BIGINT };
0:             for (int i = 0; i < 3; i++) {
0:                 assertEquals("Unexpected parameter type",
0:                              expectedTypes[i], pmd.getParameterType(i+1));
0:                 assertEquals("Derby ? args are nullable",
0:                              // Why is that? Cf. logic in ParameterNode.setType
0:                              ParameterMetaData.parameterNullable,
0:                              pmd.isNullable(i+1));
1:             }
0:             ps.close();
1:     /**
1:      * Run a statement with both SQL Standard and JDBC limit/offset syntax. Verify
1:      * that we get the expected error or results. The statement has a % literal at the
1:      * point where the offset/fetchFirst and limit/offset clauses are to be inserted.
1:      */
1:     private void    vetStatement
1:         ( Statement stmt, String sqlState, String stub, String fetchFormat, String offset, String fetchFirst, String[][] expectedResults )
0:         throws Exception
1:     {
1:         String[]    variants = makeVariants( stub, fetchFormat, offset, fetchFirst );
1: 
0:         for ( int i = 0; i < variants.length; i++ )
1:         {
0:             String  text = variants[ i ];
1:             
1:             if ( sqlState != null )
1:             {
1:                 assertStatementError( sqlState, stmt, text );
1:             }
1:             else
1:             {
1:                 queryAndCheck( stmt, text, expectedResults );
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Make the SQL Standard and JDBC limit/offset variants of a stub statement,
1:      * plugging in the given offset and fetch count.
1:      */
1:     private String[]    makeVariants
1:         ( String stub, String fetchFormat, String offset, String fetchFirst )
0:         throws Exception
1:     {
1:         String[]    result = new String[ VARIANT_COUNT ];
1: 
1:         result[ SQL_STANDARD_VARIANT ] = makeSQLStandardText( stub, fetchFormat, offset, fetchFirst );
1:         result[ JDBC_VARIANT ] = makeJDBCText( stub, offset, fetchFirst );
1: 
1:         return result;
1:     }
1:     
1:     /**
1:      * Substitute the SQL Standard syntax into a stub statement, given an offset and fetch count.
1:      */
1:     private String  makeSQLStandardText
1:         ( String stub, String fetchFormat, String offset, String fetchFirst )
0:         throws Exception
1:     {
1:         String  sqlStandardText = "";
1: 
1:         if ( offset != null )
1:         {
1:             sqlStandardText = " offset " + offset + " rows ";
1:         }
1:         if ( fetchFirst != null )
1:         {
1:             sqlStandardText = sqlStandardText + substitute( fetchFormat, PERCENT_TOKEN, fetchFirst );
1:         }
1: 
1:         sqlStandardText = substitute( stub, PERCENT_TOKEN, sqlStandardText );
1: 
1:         println( sqlStandardText );
1: 
1:         return sqlStandardText;
1:     }
1:     /**
1:      * Substitute JDBC limit/offset syntax into a stub statement, given an offset and fetch count.
1:      */
1:     private String  makeJDBCText
1:         ( String stub, String offset, String fetchFirst )
0:         throws Exception
1:     {
1:         String  jdbcText = "";
1: 
1:         if ( offset != null )
1:         {
1:             jdbcText = " offset " + offset;
1:         }
1:         if ( fetchFirst != null )
1:         {
1:             jdbcText = " limit " + fetchFirst + " " + jdbcText;
1:         }
1:         else
1:         {
1:             jdbcText = "limit 0 " + jdbcText;
1:         }
1: 
1:         jdbcText = substitute( stub, PERCENT_TOKEN, " { " + jdbcText + " } " );
1: 
1:         println( jdbcText );
1: 
1:         return jdbcText;
1:     }
1: 
0:     private String  substitute( String stub, String token, int replacement )
0:         throws Exception
1:     {
0:         return substitute( stub, token, Integer.toString( replacement ) );
1:     }
1:     private String  substitute( String stub, String token, String replacement )
0:         throws Exception
1:     {
1:         int substitutionIndex = stub.indexOf( token );
1:         if ( substitutionIndex < 0 ) { fail( "Bad stub: " + stub + ". Can't find token: " + token ); }
1: 
1:         String  prefix = stub.substring( 0, substitutionIndex );
1:         String  suffix = ( substitutionIndex == stub.length() - 1 ) ?
1:             "" : stub.substring( substitutionIndex + 1, stub.length() );
1: 
1:         return prefix + replacement + suffix;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:fc6899b
/////////////////////////////////////////////////////////////////////////
0: 
1:     	//since there is no getParameterMetaData() call available in JSR169 
1:     	//implementations, do not run this test if we are running JSR169
1:     	if (JDBC.vmSupportsJSR169()) return;
0: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:06154a0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that the values of offset and fetch first are not forgotten if
1:      * a {@code PreparedStatement} is executed multiple times (DERBY-4212).
0:      * <b>NOTE:</b> Disabled until the bug is fixed. Remove x from the method
0:      * name to enable it.
1:      */
0:     public void xtestRepeatedExecution() throws SQLException {
0:         PreparedStatement ps = prepareStatement(
0:                 "select * from t1 order by b " +
0:                 "offset 2 rows fetch next 2 rows only");
0:         String[][] expected = {{"1", "3"}, {"1", "4"}};
0:         for (int i = 0; i < 10; i++) {
0:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1:     }
commit:88e5971
/////////////////////////////////////////////////////////////////////////
0:         prepareStatement("select a,b as OFFSET from t1 OFFSET 0 rows");
0:         prepareStatement("select a,b from t1 AS OFFSET");
0:         prepareStatement("select a,b OFFSET from t1 OFFSET");
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
1:             prepareStatement("insert into session.t values ?");
============================================================================