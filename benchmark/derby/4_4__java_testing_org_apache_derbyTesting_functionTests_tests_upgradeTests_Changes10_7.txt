1:a584888: /*
10:a584888: 
1:a584888: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_7
1:a584888: 
1:a584888: Licensed to the Apache Software Foundation (ASF) under one or more
1:a584888: contributor license agreements.  See the NOTICE file distributed with
1:a584888: this work for additional information regarding copyright ownership.
1:a584888: The ASF licenses this file to You under the Apache License, Version 2.0
1:a584888: (the "License"); you may not use this file except in compliance with
1:a584888: the License.  You may obtain a copy of the License at
1:a584888: 
1:a584888:    http://www.apache.org/licenses/LICENSE-2.0
1:a584888: 
1:a584888: Unless required by applicable law or agreed to in writing, software
1:a584888: distributed under the License is distributed on an "AS IS" BASIS,
1:a584888: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a584888: See the License for the specific language governing permissions and
1:a584888: limitations under the License.
1:a584888: 
1:a584888: */
1:a584888: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:a584888: 
1:1ae02c9: import java.sql.ResultSet;
1:a584888: import java.sql.SQLException;
1:69dbd13: import java.sql.SQLWarning;
1:a584888: import java.sql.Statement;
1:433d084: import java.util.HashSet;
1:433d084: import java.util.Set;
1:a584888: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a584888: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:a584888: 
1:a584888: 
1:a584888: /**
1:a584888:  * Upgrade test cases for 10.7.
1:a584888:  * If the old version is 10.7 or later then these tests
1:a584888:  * will not be run.
1:a584888:  * <BR>
1:a584888:     10.7 Upgrade issues
1:a584888: 
1:a584888:     <UL>
1:a584888:     <LI>BOOLEAN data type support expanded.</LI>
1:a584888:     </UL>
1:a584888: 
1:a584888:  */
1:a584888: public class Changes10_7 extends UpgradeChange
1:a584888: {
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888:     //
1:a584888:     // CONSTANTS
1:a584888:     //
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888: 
1:a584888:     private static final String SYNTAX_ERROR = "42X01";
1:a584888:     private static final String  UPGRADE_REQUIRED = "XCL47";
1:9f60172:     private static final String  GRANT_REVOKE_WITH_LEGACY_ACCESS = "42Z60";
1:a584888: 
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888:     //
1:a584888:     // STATE
1:a584888:     //
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888: 
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888:     //
1:a584888:     // CONSTRUCTOR
1:a584888:     //
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888: 
1:a584888:     public Changes10_7(String name)
1:a584888:     {
1:a584888:         super(name);
1:a584888:     }
1:69dbd13: 
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888:     //
1:a584888:     // JUnit BEHAVIOR
1:a584888:     //
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:69dbd13: 
1:69dbd13:     /**
1:a584888:      * Return the suite of tests to test the changes made in 10.7.
1:a584888:      * @param phase an integer that indicates the current phase in
1:a584888:      *              the upgrade test.
1:a584888:      * @return the test suite created.
1:a584888:      */
1:a584888:     public static Test suite(int phase) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.7");
1:a584888: 
1:a584888:         suite.addTestSuite(Changes10_7.class);
1:a584888:         return new SupportFilesSetup((Test) suite);
1:a584888:     }
1:a584888: 
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888:     //
1:a584888:     // TESTS
1:a584888:     //
1:a584888:     ///////////////////////////////////////////////////////////////////////////////////
1:a584888: 
1:a584888:     /**
1:a584888:      * Make sure that that database is at level 10.7 in order to enjoy
1:a584888:      * extended support for the BOOLEAN datatype.
1:a584888:      */
1:a584888:     public void testBoolean() throws SQLException
1:a584888:     {
1:a584888:         String booleanValuedFunction =
1:a584888:             "create function f_4655( a varchar( 100 ) ) returns boolean\n" +
1:a584888:             "language java parameter style java no sql deterministic\n" +
1:a584888:             "external name 'Z.getBooleanValue'\n";
1:a584888: 
1:a584888:         Statement s = createStatement();
1:a584888: 
1:a584888:         switch ( getPhase() )
1:a584888:         {
1:a584888:         case PH_CREATE: // create with old version
1:a584888:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:433d084:             assertFalse(getSupportedTypes().contains("BOOLEAN"));
1:a584888:             assertStatementError(  SYNTAX_ERROR, s, booleanValuedFunction );
1:a6f9586:             break;
1:69dbd13: 
1:a584888:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:433d084:             assertFalse(getSupportedTypes().contains("BOOLEAN"));
1:a584888:             assertStatementError( UPGRADE_REQUIRED, s, booleanValuedFunction );
2:a584888:             break;
1:69dbd13:             
1:a584888:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:433d084:             assertTrue(getSupportedTypes().contains("BOOLEAN"));
1:a584888:             s.execute( booleanValuedFunction );
1:a584888:             break;
1:a584888:         }
1:69dbd13:         
1:a584888:         s.close();
1:a584888:     }
1:69dbd13: 
1:9f60172:     /**
1:433d084:      * Get the names of all supported types, as reported by
1:433d084:      * {@code DatabaseMetaData.getTypeInfo()}.
1:433d084:      *
1:433d084:      * @return a set with the names of all supported types in the loaded
1:433d084:      * version of Derby
1:433d084:      */
1:e18f54b:     private Set<String> getSupportedTypes() throws SQLException {
1:e18f54b:         HashSet<String> types = new HashSet<String>();
1:433d084:         ResultSet rs = getConnection().getMetaData().getTypeInfo();
1:433d084:         while (rs.next()) {
1:433d084:             types.add(rs.getString("TYPE_NAME"));
1:433d084:         }
1:433d084:         rs.close();
1:433d084:         return types;
1:433d084:     }
1:433d084:     
1:433d084:     /**
1:528ac25:      * This test creates 2 kinds of triggers in old release for each of the
1:528ac25:      * three phase of upgrade. The triggers are of following 2 types
1:528ac25:      * 1)trigger action using columns available through the REFERENCING clause.
1:528ac25:      * 2)trigger action using columns without the REFERENCING clause.
1:528ac25:      * For both kinds of triggers, there is test case which drops the column 
1:528ac25:      * being used in the trigger action column. 
1:69dbd13:      * 
1:528ac25:      * In all three modes of upgrade, soft upgrade, post soft upgrade, and 
1:528ac25:      * hard upgrade, ALTER TABLE DROP COLUMN will detect the trigger 
1:528ac25:      * dependency.
1:69dbd13:      */
1:69dbd13:     public void testAlterTableDropColumnAndTriggerAction() throws Exception
1:69dbd13:     {
1:528ac25:     	// ALTER TABLE DROP COLUMN was introduced in 10.3 so no point running
1:528ac25:     	// this test with earlier releases
1:69dbd13:     	if (!oldAtLeast(10, 3)) return;
1:69dbd13:     	
1:69dbd13:         Statement s = createStatement();
1:69dbd13:         ResultSet rs;
1:69dbd13: 
1:69dbd13:         switch ( getPhase() )
1:69dbd13:         {
1:69dbd13:         case PH_CREATE: // create with old version
1:528ac25:         	// Create 4 tables for each of the upgrade phases
1:528ac25:         	//
1:528ac25:         	// There will be 2 tests in each upgrade phase. 
1:528ac25:         	// 1)One test will use the column being dropped as part of the
1:528ac25:         	//   trigger action column through the REFERENCING clause
1:528ac25:         	// 2)Second test will use the column being dropped as part of the
1:528ac25:         	//   trigger action sql without the REFERENCING clause
1:528ac25:         	//
1:528ac25:         	//For each of the two tests, one table will be used for 
1:69dbd13:         	//ALTER TABLE DROP COLUMN RESTRICT and the second table will
1:69dbd13:         	//be used for ALTER TABLE DROP COLUMN CASCADE
1:69dbd13: 
1:528ac25:         	//Following 4 tables and triggers will be used in soft upgrade mode
1:528ac25:         	// The trigger actions on following 2 table use a column through 
1:528ac25:         	// REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_RESTRICT", 
1:528ac25:         			"TAB1_SOFT_UPGRADE_RESTRICT_TR1", true);
1:528ac25:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB1_SOFT_UPGRADE_CASCADE_TR1", true);
1:528ac25:         	// The trigger actions on following 2 table use a column without
1:528ac25:         	// the REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_RESTRICT",
1:528ac25:         			"TAB2_SOFT_UPGRADE_RESTRICT_TR1", false);
1:528ac25:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB2_SOFT_UPGRADE_CASCADE_TR1", false);
1:69dbd13: 
1:528ac25:         	//Following 4 tables and triggers will be used in post-soft 
1:528ac25:         	// upgrade mode
1:528ac25:         	// The trigger actions on following 2 table use a column through 
1:528ac25:         	// REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB1_POSTSOFT_UPGRADE_RESTRICT", 
1:528ac25:         			"TAB1_POSTSOFT_UPGRADE_RESTRICT_TR1", true);
1:528ac25:         	createTableAndTrigger("TAB1_POSTSOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB1_POSTSOFT_UPGRADE_CASCADE_TR1", true);
1:528ac25:         	// The trigger actions on following 2 table use a column without
1:528ac25:         	// the REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB2_POSTSOFT_UPGRADE_RESTRICT",
1:528ac25:         			"TAB2_POSTSOFT_UPGRADE_RESTRICT_TR1", false);
1:528ac25:         	createTableAndTrigger("TAB2_POSTSOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB2_POSTSOFT_UPGRADE_CASCADE_TR1", false);
1:69dbd13: 
1:528ac25:         	//Following 4 tables and triggers will be used in hard 
1:528ac25:         	// upgrade mode
1:528ac25:         	// The trigger actions on following 2 table use a column through 
1:528ac25:         	// REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB1_HARD_UPGRADE_RESTRICT", 
1:528ac25:         			"TAB1_HARD_UPGRADE_RESTRICT_TR1", true);
1:528ac25:         	createTableAndTrigger("TAB1_HARD_UPGRADE_CASCADE",
1:528ac25:         			"TAB1_HARD_UPGRADE_CASCADE_TR1", true);
1:528ac25:         	// The trigger actions on following 2 table use a column without
1:528ac25:         	// the REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB2_HARD_UPGRADE_RESTRICT",
1:528ac25:         			"TAB2_HARD_UPGRADE_RESTRICT_TR1", false);
1:528ac25:         	createTableAndTrigger("TAB2_HARD_UPGRADE_CASCADE",
1:528ac25:         			"TAB2_HARD_UPGRADE_CASCADE_TR1", false);
1:69dbd13: 
1:69dbd13:             break;
1:69dbd13: 
1:69dbd13:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // through the REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB1_SOFT_UPGRADE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_SOFT_UPGRADE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs, 
1:528ac25:                		new String[][]{{"TAB1_SOFT_UPGRADE_RESTRICT_TR1"}});
1:528ac25:                            	
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // through the REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:             s.executeUpdate("alter table TAB1_SOFT_UPGRADE_CASCADE " +
1:528ac25:             		" drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_SOFT_UPGRADE_CASCADE_TR1'"));
1:69dbd13: 
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:         	// (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB2_SOFT_UPGRADE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_SOFT_UPGRADE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs, 
1:528ac25:                		new String[][]{{"TAB2_SOFT_UPGRADE_RESTRICT_TR1"}});
1:528ac25:                            	
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:             s.executeUpdate("alter table TAB2_SOFT_UPGRADE_CASCADE " +
1:528ac25:             		" drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_SOFT_UPGRADE_CASCADE_TR1'"));
1:528ac25: 
1:528ac25:             // Same behavior can be seen with tables and triggers created
1:528ac25:             // in soft upgrade mode using Derby 10.7 release,
1:528ac25:             // The trigger actions in this test case uses a column through 
1:528ac25:         	// REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT", 
1:528ac25:         			"TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs,
1:528ac25:             		new String[][]{{"TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1:528ac25:             
1:528ac25:             // Same behavior can be seen with tables and triggers created
1:528ac25:             // in soft upgrade mode using Derby 10.7 release,
1:528ac25:             // The trigger actions in this test case uses a column through 
1:528ac25:         	// REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:528ac25:             s.executeUpdate("alter table TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE " +
1:528ac25:             		" drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:             		" select triggername from sys.systriggers where " +
1:528ac25:             		"triggername='TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:528ac25: 
1:528ac25:             // Same behavior can be seen with tables and triggers created
1:528ac25:             // in soft upgrade mode using Derby 10.7 release,
1:528ac25:             // The trigger actions in this test case uses a column  
1:528ac25:         	// (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT", 
1:528ac25:         			"TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs,
1:528ac25:             		new String[][]{{"TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1:528ac25: 
1:528ac25:             // Same behavior can be seen with tables and triggers created
1:528ac25:             // in soft upgrade mode using Derby 10.7 release,
1:528ac25:             // The trigger actions in this test case uses a column  
1:528ac25:         	// (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE", 
1:528ac25:         			"TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:528ac25:             s.executeUpdate("alter table TAB2_soft_upgrade_NEW_TABLE_cascade " +
1:528ac25:             		" drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:             		" select triggername from sys.systriggers where " +
1:528ac25:             		"triggername='TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:69dbd13:             break;
1:69dbd13: 
1:69dbd13:         case PH_POST_SOFT_UPGRADE: 
1:69dbd13:         	// soft-downgrade: boot with old version after soft-upgrade
1:69dbd13: 
1:528ac25:         	//The tables created with 10.6 and prior versions will exhibit
1:528ac25:         	// incorrect behavior because changes for DERBY-4887/DERBY-4984 
1:528ac25:         	// have not been backported to 10.6 and earlier yet
1:528ac25:         	//
1:528ac25:         	//ALTER TABLE DROP COLUMN will not detect column being dropped
1:528ac25:         	// in trigger action of dependent triggers.
1:528ac25:         	incorrectBehaviorForDropColumn("TAB1_POSTSOFT_UPGRADE_RESTRICT",
1:528ac25:         			"TAB1_POSTSOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
1:528ac25:         	incorrectBehaviorForDropColumn("TAB1_POSTSOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB1_POSTSOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1:528ac25:         	incorrectBehaviorForDropColumn("TAB2_POSTSOFT_UPGRADE_RESTRICT",
1:528ac25:         			"TAB2_POSTSOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
1:528ac25:         	incorrectBehaviorForDropColumn("TAB2_POSTSOFT_UPGRADE_CASCADE",
1:528ac25:         			"TAB2_POSTSOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1:528ac25: 
1:69dbd13:         	//We are back to pre-10.7 version after the soft upgrade. 
1:69dbd13:         	//ALTER TABLE DROP COLUMN will continue to behave incorrectly
1:69dbd13:         	//and will not detect the trigger actions referencing the column
1:69dbd13:         	//being dropped through the REFERENCING clause
1:528ac25:         	createTableAndTrigger("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:528ac25:         	incorrectBehaviorForDropColumn("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:528ac25:         	createTableAndTrigger("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:528ac25:         	incorrectBehaviorForDropColumn("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1:528ac25: 
1:528ac25:         	//We are back to pre-10.7 version after the soft upgrade. 
1:528ac25:         	//ALTER TABLE DROP COLUMN will continue to behave incorrectly
1:528ac25:         	//and will not detect the trigger actions referencing the column
1:528ac25:         	//being dropped directly (ie without the REFERENCING clause)
1:528ac25:         	createTableAndTrigger("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:528ac25:         	incorrectBehaviorForDropColumn("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:69dbd13:         	
1:528ac25:         	createTableAndTrigger("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:528ac25:         	incorrectBehaviorForDropColumn("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1:528ac25:         	
1:528ac25:         	break;
1:69dbd13: 
1:69dbd13:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // through the REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:69dbd13:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB1_HARD_UPGRADE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_HARD_UPGRADE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs, 
1:528ac25:                     new String[][]{{"TAB1_HARD_UPGRADE_RESTRICT_TR1"}});
1:528ac25: 
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // through the REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:             s.executeUpdate("alter table TAB1_HARD_UPGRADE_CASCADE " +
1:528ac25:                     " drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_HARD_UPGRADE_CASCADE_TR1'"));
1:528ac25:         	
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:         	// (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN RESTRICT will fail.
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB2_HARD_UPGRADE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_HARD_UPGRADE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs, 
1:528ac25:                     new String[][]{{"TAB2_HARD_UPGRADE_RESTRICT_TR1"}});
1:528ac25: 
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:             s.executeUpdate("alter table TAB2_HARD_UPGRADE_CASCADE " +
1:528ac25:                     " drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_HARD_UPGRADE_CASCADE_TR1'"));
1:528ac25: 
1:528ac25:             //Create 2 new tables now that the database has been upgraded.
1:528ac25:         	//Notice that newly created tables will be able to detect
1:528ac25:         	//trigger action reference to column through REFERENCING clause.
1:528ac25:         	createTableAndTrigger("TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT " +
1:528ac25:             		" drop column c11 restrict");
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             rs = s.executeQuery(
1:528ac25:             " select triggername from sys.systriggers where " +
1:528ac25:             "triggername='TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:528ac25:             JDBC.assertFullResultSet(rs, 
1:528ac25:             		new String[][]{{"TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1:528ac25: 
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // through the REFERENCING clause. Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:         	createTableAndTrigger("TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:528ac25:             s.executeUpdate("alter table TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE " +
1:528ac25:             		" drop column c11 CASCADE");
1:528ac25:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:528ac25:             JDBC.assertEmpty(s.executeQuery(
1:528ac25:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:528ac25: 
1:528ac25:             //Create 2 new tables now that the database has been upgraded.
1:528ac25:         	// Notice that newly created tables will be able to detect
1:528ac25:         	// trigger action column (without the REFERENCING clause.)
1:528ac25:         	//Because of this, DROP COLUMN RESTRICT will fail.
1:528ac25:         	createTableAndTrigger("TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT",
1:528ac25:         			"TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:528ac25:             //Verify that trigger still exists in the system
1:528ac25:             assertStatementError("X0Y25", s,
1:528ac25:             		" alter table TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT " +
1:69dbd13:             		" drop column c11 restrict");
1:69dbd13:             rs = s.executeQuery(
1:69dbd13:             " select triggername from sys.systriggers where " +
1:528ac25:             "triggername='TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:69dbd13:             JDBC.assertFullResultSet(rs, 
1:528ac25:             		new String[][]{{"TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1:528ac25: 
1:528ac25:         	// The trigger has trigger action using the column being dropped
1:528ac25:             // (not through the REFERENCING clause). Because of this, 
1:528ac25:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:528ac25:         	createTableAndTrigger("TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE",
1:528ac25:         			"TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:528ac25:             s.executeUpdate("alter table TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE " +
1:69dbd13:             		" drop column c11 CASCADE");
1:69dbd13:             checkWarning(s, "01502");
1:528ac25:             //Verify that the trigger does not exist in the system anymore
1:69dbd13:             JDBC.assertEmpty(s.executeQuery(
1:69dbd13:                     " select triggername from sys.systriggers where " +
1:528ac25:                     "triggername='TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:69dbd13:             break;
1:69dbd13:         }
1:69dbd13:     }
1:69dbd13: 
1:528ac25:     //Create the table and trigger necessary for ALTER TABLE DROP COLUMN test
1:528ac25:     private void createTableAndTrigger(String tableName,
1:528ac25:     		String triggerName, boolean usesReferencingClause) 
1:528ac25:     throws SQLException {
1:528ac25:         Statement s = createStatement();
1:528ac25:         ResultSet rs;
1:528ac25:         
1:528ac25:         s.execute("CREATE TABLE " + tableName + " (c11 int, c12 int) ");
1:528ac25:         s.execute("INSERT INTO " + tableName + " VALUES (1,10)");
1:528ac25:         s.execute("CREATE TRIGGER " + triggerName + 
1:528ac25:         		" AFTER UPDATE OF c12 ON " + tableName +
1:528ac25:         		(usesReferencingClause ? " REFERENCING OLD AS oldt" : "" )+
1:528ac25:         		" FOR EACH ROW SELECT " +
1:528ac25:         		(usesReferencingClause ? "oldt.c11 " : "c11 " )+
1:528ac25:                 "FROM " + tableName);
1:528ac25:         s.executeUpdate("UPDATE " + tableName + " SET c12=c12+1");
1:528ac25:     }
1:528ac25:     
1:528ac25: 
1:69dbd13:     //ALTER TABLE DROP COLUMN in not detected the trigger column dependency for
1:69dbd13:     //columns being used through the REFERENCING clause for triggers created
1:69dbd13:     //prior to 10.7 release
1:69dbd13:     private void incorrectBehaviorForDropColumn(String tableName,
1:69dbd13:     		String triggerName, String restrictOrCascade) throws SQLException {
1:69dbd13:         Statement s = createStatement();
1:69dbd13:         ResultSet rs;
1:69dbd13:         
1:69dbd13:         //ALTER TABLE DROP COLUMN of a column used in the trigger action
1:69dbd13:         //through REFERENCING clause does not detect the trigger 
1:69dbd13:         //dependency in older releases.
1:69dbd13:         //RESTRICT won't give any error for dependent trigger and will
1:69dbd13:         //drop column c11 even though it is getting used in trigger action
1:69dbd13:         //and will leave the invalid trigger in the system. 
1:69dbd13:         //CASCADE won't give any warning for dependent trigger and will
1:69dbd13:         //drop column c11 even though it is getting used in trigger action
1:69dbd13:         //and will leave the invalid trigger in the system. 
1:69dbd13:         s.executeUpdate("ALTER TABLE " + tableName + " DROP COLUMN c11 " +
1:69dbd13:         		restrictOrCascade);
1:69dbd13:         rs =
1:69dbd13:             s.executeQuery(
1:69dbd13:             " select triggername from sys.systriggers where " +
1:69dbd13:             "triggername='" + triggerName + "'");
1:69dbd13:         JDBC.assertFullResultSet(rs, new String[][]{{triggerName}});
1:a6f9586:     }
1:a6f9586: 
1:69dbd13:     private void checkWarning(Statement st, String expectedWarning)
1:69dbd13:             throws Exception {
1:69dbd13:         SQLWarning sqlWarn = null;
1:a6f9586: 
1:69dbd13:         sqlWarn = st.getWarnings();
1:69dbd13:         if (sqlWarn == null) {
1:69dbd13:             sqlWarn = getConnection().getWarnings();
1:a6f9586:         }
1:69dbd13:         assertNotNull("Expected warning but found none", sqlWarn);
1:69dbd13:         assertSQLState(expectedWarning, sqlWarn);
1:a584888:     }
1:a584888: 
1:a584888:     /**
1:a6f9586:      * Make sure that DERBY-1482 changes do not break backward compatibility
1:a6f9586:      */
1:a6f9586:     public void testTriggers() throws SQLException
1:a6f9586:     {
1:a6f9586:         Statement s = createStatement();
1:a6f9586:         ResultSet rs;
1:a6f9586:         boolean modeDb2SqlOptional = oldAtLeast(10, 3);
1:a6f9586: 
1:a6f9586:         switch ( getPhase() )
1:a6f9586:         {
1:a6f9586:         case PH_CREATE: // create with old version
1:a6f9586:             s.execute("CREATE TABLE DERBY1482_table1(c11 int, c12 int)");
1:a6f9586:             s.execute("INSERT INTO DERBY1482_table1 VALUES (1,10)");
1:a6f9586:             s.execute("CREATE TABLE DERBY1482_table2(c21 int, c22 int)");
1:a6f9586:             s.execute("CREATE TABLE DERBY1482_table3(c31 int, c32 int)");
1:a6f9586:             s.execute("CREATE TABLE DERBY1482_table4(c41 int, c42 int)");
1:a6f9586:             s.execute("CREATE TABLE DERBY1482_table5(c51 int, c52 int)");
1:a6f9586:             //Create the first trigger in the older release where the
1:a6f9586:             //database has been created. Every update of DERBY1482_table1.c12
1:a6f9586:             //will cause an insert into DERBY1482_table2 through this trigger tr1.
1:a6f9586:             s.execute("CREATE TRIGGER tr1 AFTER UPDATE OF c12 " +
1:a6f9586:             		"ON DERBY1482_table1 REFERENCING OLD AS oldt " +
12:69dbd13:             		"FOR EACH ROW " +
1:a6f9586:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:a6f9586:                     "INSERT INTO DERBY1482_table2 VALUES(-1, oldt.c12)");
1:69dbd13:             
1:a6f9586:             //Now do an update which will fire trigger tr1
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that trigger tr1 has inserted one row in DERBY1482_table2
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:69dbd13:             break;
1:69dbd13: 
1:a6f9586:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:a6f9586:             //Now do an update while in the soft upgrade. This should
1:a6f9586:         	//fire trigger tr1
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that now we have 2 rows in DERBY1482_table2 because trigger tr1
1:a6f9586:             //has fired twice so far. Once in PH_CREATE phase and once
1:a6f9586:             //in PH_SOFT_UPGRADE phase
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:a6f9586:             //Create trigger tr2 in soft upgrade mode. DERBY-1482 changes
1:a6f9586:             //will not put anything about trigger action columns in 
1:a6f9586:             //SYSTRIGGERS to maintain backward compatibility. Only 10.7
1:a6f9586:             //and up recognize additional information about trigger action
1:a6f9586:             //columns in SYSTRIGGERS.
1:a6f9586:             s.execute("CREATE TRIGGER tr2 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:a6f9586:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:a6f9586:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:a6f9586:             		"INSERT INTO DERBY1482_table3 VALUES(-1, oldt.c12)");
1:a6f9586:             //Now do an update which will fire triggers tr1 and tr2
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:a6f9586:             //Verify that trigger tr2 has inserted one row in DERBY1482_table3
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:a6f9586:             break;
1:a6f9586: 
1:a6f9586:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:a6f9586:             //Now do an update when we are back with the older release
1:a6f9586:         	//after the soft upgrade. This should fire trigger tr1 and tr2
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that now we have 4 rows in DERBY1482_table2 and 2 rows in DERBY1482_table3
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"4"}});
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:a6f9586:             //Create trigger tr3 with the older release. Triggers created in
1:a6f9586:             //soft-upgrade mode and with older release should work fine.
1:a6f9586:             s.execute("CREATE TRIGGER tr3 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:a6f9586:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:a6f9586:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:a6f9586:             		"INSERT INTO DERBY1482_table4 VALUES(-1, oldt.c12)");
1:a6f9586:             //Now do an update which will fire triggers tr1, tr2 and tr3
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"5"}});
1:a6f9586:             //Verify that trigger tr2 has inserted one more row in DERBY1482_table3
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:a6f9586:             //Verify that trigger tr3 has inserted one row in DERBY1482_table4
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:a6f9586:             break;
1:a6f9586: 
1:a6f9586:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:a6f9586:         	//Do an update after we have hard upgraded to 10.7 and make sure
1:a6f9586:         	//that all the triggers (created with older release and created
1:a6f9586:         	//in soft-upgrade mode) work fine.
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that now we have 6 rows in DERBY1482_table2, 4 rows in DERBY1482_table3, 2 rows in DERBY1482_table4
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"6"}});
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"4"}});
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:a6f9586:             //Create trigger DERBY1482_table4 in the hard-upgraded db.
1:a6f9586:             s.execute("CREATE TRIGGER tr4 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:a6f9586:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:a6f9586:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:a6f9586:             		"INSERT INTO DERBY1482_table5 VALUES(-1, oldt.c12)");
1:a6f9586:             //All 4 triggers tr1, tr2, tr3 and tr4 should fire 
1:a6f9586:             //Now do an update which will fire all 4 triggers tr1,tr2,tr3,tr4
1:a6f9586:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:a6f9586:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"7"}});
1:a6f9586:             //Verify that trigger tr2 has inserted one more row in DERBY1482_table3
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"5"}});
1:a6f9586:             //Verify that trigger tr3 has inserted one more row in DERBY1482_table4
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:a6f9586:             //Verify that trigger tr4 has inserted one row in DERBY1482_table5
1:a6f9586:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table5");
1:a6f9586:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:a6f9586:             break;
1:69dbd13:         }
1:a6f9586:         s.close();
1:69dbd13:     }
1:a6f9586: 
1:a6f9586:     /**
1:9f60172:      * Make sure that that database is at level 10.7 in order to enjoy
1:9f60172:      * routines with specified EXTERNAL SECURITY INVOKER or DEFINER.
1:9f60172:      */
1:9f60172:     public void testExternalSecuritySpecification() throws SQLException
1:9f60172:     {
1:9f60172:         String functionWithDefinersRights =
1:9f60172:             "create function f_4551( a varchar( 100 ) ) returns int\n" +
1:9f60172:             "language java parameter style java reads sql data\n" +
1:9f60172:             "external security definer\n" +
1:9f60172:             "external name 'Z.getIntValue'\n";
1:9f60172: 
1:9f60172:         Statement s = createStatement();
1:9f60172: 
1:9f60172:         switch ( getPhase() )
1:9f60172:         {
1:9f60172:         case PH_CREATE: // create with old version
1:9f60172:         case PH_POST_SOFT_UPGRADE:
1:9f60172:             // soft-downgrade: boot with old version after soft-upgrade
1:9f60172:             assertStatementError(
1:9f60172:                 SYNTAX_ERROR, s, functionWithDefinersRights );
1:9f60172:             break;
1:9f60172: 
1:9f60172:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:9f60172:             assertStatementError(
1:9f60172:                 UPGRADE_REQUIRED, s, functionWithDefinersRights );
1:9f60172:             break;
1:9f60172: 
1:9f60172:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade.
1:9f60172:             // Syntax now accepted and dictionary level ok, but
1:9f60172:             // sqlAuthorization not enabled (a priori) - expected.
1:9f60172:             assertStatementError(GRANT_REVOKE_WITH_LEGACY_ACCESS,
1:9f60172:                                  s, functionWithDefinersRights );
1:9f60172:             break;
1:9f60172:         }
1:9f60172: 
1:9f60172:         s.close();
1:9f60172:     }
1:9f60172: 
1:69dbd13: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.7");
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:     private static final String  GRANT_REVOKE_WITH_LEGACY_ACCESS = "42Z60";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure that that database is at level 10.7 in order to enjoy
1:      * routines with specified EXTERNAL SECURITY INVOKER or DEFINER.
1:      */
1:     public void testExternalSecuritySpecification() throws SQLException
1:     {
1:         String functionWithDefinersRights =
1:             "create function f_4551( a varchar( 100 ) ) returns int\n" +
1:             "language java parameter style java reads sql data\n" +
1:             "external security definer\n" +
1:             "external name 'Z.getIntValue'\n";
1: 
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:         case PH_POST_SOFT_UPGRADE:
1:             // soft-downgrade: boot with old version after soft-upgrade
1:             assertStatementError(
1:                 SYNTAX_ERROR, s, functionWithDefinersRights );
1:             break;
1: 
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             assertStatementError(
1:                 UPGRADE_REQUIRED, s, functionWithDefinersRights );
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade.
1:             // Syntax now accepted and dictionary level ok, but
1:             // sqlAuthorization not enabled (a priori) - expected.
1:             assertStatementError(GRANT_REVOKE_WITH_LEGACY_ACCESS,
1:                                  s, functionWithDefinersRights );
1:             break;
1:         }
1: 
1:         s.close();
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:     private Set<String> getSupportedTypes() throws SQLException {
1:         HashSet<String> types = new HashSet<String>();
commit:433d084
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:             assertFalse(getSupportedTypes().contains("BOOLEAN"));
1:             assertFalse(getSupportedTypes().contains("BOOLEAN"));
1:             assertTrue(getSupportedTypes().contains("BOOLEAN"));
/////////////////////////////////////////////////////////////////////////
1:      * Get the names of all supported types, as reported by
1:      * {@code DatabaseMetaData.getTypeInfo()}.
1:      *
1:      * @return a set with the names of all supported types in the loaded
1:      * version of Derby
1:      */
0:     private Set getSupportedTypes() throws SQLException {
0:         HashSet types = new HashSet();
1:         ResultSet rs = getConnection().getMetaData().getTypeInfo();
1:         while (rs.next()) {
1:             types.add(rs.getString("TYPE_NAME"));
1:         }
1:         rs.close();
1:         return types;
1:     }
1: 
1:     /**
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:528ac25
/////////////////////////////////////////////////////////////////////////
1:      * This test creates 2 kinds of triggers in old release for each of the
1:      * three phase of upgrade. The triggers are of following 2 types
1:      * 1)trigger action using columns available through the REFERENCING clause.
1:      * 2)trigger action using columns without the REFERENCING clause.
1:      * For both kinds of triggers, there is test case which drops the column 
1:      * being used in the trigger action column. 
1:      * In all three modes of upgrade, soft upgrade, post soft upgrade, and 
1:      * hard upgrade, ALTER TABLE DROP COLUMN will detect the trigger 
1:      * dependency.
1:     	// ALTER TABLE DROP COLUMN was introduced in 10.3 so no point running
1:     	// this test with earlier releases
/////////////////////////////////////////////////////////////////////////
1:         	// Create 4 tables for each of the upgrade phases
1:         	//
1:         	// There will be 2 tests in each upgrade phase. 
1:         	// 1)One test will use the column being dropped as part of the
1:         	//   trigger action column through the REFERENCING clause
1:         	// 2)Second test will use the column being dropped as part of the
1:         	//   trigger action sql without the REFERENCING clause
1:         	//
1:         	//For each of the two tests, one table will be used for 
1:         	//Following 4 tables and triggers will be used in soft upgrade mode
1:         	// The trigger actions on following 2 table use a column through 
1:         	// REFERENCING clause
1:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_RESTRICT", 
1:         			"TAB1_SOFT_UPGRADE_RESTRICT_TR1", true);
1:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_CASCADE",
1:         			"TAB1_SOFT_UPGRADE_CASCADE_TR1", true);
1:         	// The trigger actions on following 2 table use a column without
1:         	// the REFERENCING clause
1:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_RESTRICT",
1:         			"TAB2_SOFT_UPGRADE_RESTRICT_TR1", false);
1:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_CASCADE",
1:         			"TAB2_SOFT_UPGRADE_CASCADE_TR1", false);
1:         	//Following 4 tables and triggers will be used in post-soft 
1:         	// upgrade mode
1:         	// The trigger actions on following 2 table use a column through 
1:         	// REFERENCING clause
1:         	createTableAndTrigger("TAB1_POSTSOFT_UPGRADE_RESTRICT", 
1:         			"TAB1_POSTSOFT_UPGRADE_RESTRICT_TR1", true);
1:         	createTableAndTrigger("TAB1_POSTSOFT_UPGRADE_CASCADE",
1:         			"TAB1_POSTSOFT_UPGRADE_CASCADE_TR1", true);
1:         	// The trigger actions on following 2 table use a column without
1:         	// the REFERENCING clause
1:         	createTableAndTrigger("TAB2_POSTSOFT_UPGRADE_RESTRICT",
1:         			"TAB2_POSTSOFT_UPGRADE_RESTRICT_TR1", false);
1:         	createTableAndTrigger("TAB2_POSTSOFT_UPGRADE_CASCADE",
1:         			"TAB2_POSTSOFT_UPGRADE_CASCADE_TR1", false);
1:         	//Following 4 tables and triggers will be used in hard 
1:         	// upgrade mode
1:         	// The trigger actions on following 2 table use a column through 
1:         	// REFERENCING clause
1:         	createTableAndTrigger("TAB1_HARD_UPGRADE_RESTRICT", 
1:         			"TAB1_HARD_UPGRADE_RESTRICT_TR1", true);
1:         	createTableAndTrigger("TAB1_HARD_UPGRADE_CASCADE",
1:         			"TAB1_HARD_UPGRADE_CASCADE_TR1", true);
1:         	// The trigger actions on following 2 table use a column without
1:         	// the REFERENCING clause
1:         	createTableAndTrigger("TAB2_HARD_UPGRADE_RESTRICT",
1:         			"TAB2_HARD_UPGRADE_RESTRICT_TR1", false);
1:         	createTableAndTrigger("TAB2_HARD_UPGRADE_CASCADE",
1:         			"TAB2_HARD_UPGRADE_CASCADE_TR1", false);
1:         	// The trigger has trigger action using the column being dropped
1:             // through the REFERENCING clause. Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB1_SOFT_UPGRADE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_SOFT_UPGRADE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
1:                		new String[][]{{"TAB1_SOFT_UPGRADE_RESTRICT_TR1"}});
1:                            	
1:         	// The trigger has trigger action using the column being dropped
1:             // through the REFERENCING clause. Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:             s.executeUpdate("alter table TAB1_SOFT_UPGRADE_CASCADE " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_SOFT_UPGRADE_CASCADE_TR1'"));
1:         	// The trigger has trigger action using the column being dropped
1:         	// (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB2_SOFT_UPGRADE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB2_SOFT_UPGRADE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
1:                		new String[][]{{"TAB2_SOFT_UPGRADE_RESTRICT_TR1"}});
1:                            	
1:         	// The trigger has trigger action using the column being dropped
1:             // (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:             s.executeUpdate("alter table TAB2_SOFT_UPGRADE_CASCADE " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB2_SOFT_UPGRADE_CASCADE_TR1'"));
1: 
1:             // Same behavior can be seen with tables and triggers created
1:             // in soft upgrade mode using Derby 10.7 release,
1:             // The trigger actions in this test case uses a column through 
1:         	// REFERENCING clause. Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT", 
1:         			"TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs,
1:             		new String[][]{{"TAB1_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1:             
1:             // Same behavior can be seen with tables and triggers created
1:             // in soft upgrade mode using Derby 10.7 release,
1:             // The trigger actions in this test case uses a column through 
1:         	// REFERENCING clause. Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:         	createTableAndTrigger("TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:             s.executeUpdate("alter table TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:             		" select triggername from sys.systriggers where " +
1:             		"triggername='TAB1_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1: 
1:             // Same behavior can be seen with tables and triggers created
1:             // in soft upgrade mode using Derby 10.7 release,
1:             // The trigger actions in this test case uses a column  
1:         	// (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT", 
1:         			"TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs,
1:             		new String[][]{{"TAB2_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1: 
1:             // Same behavior can be seen with tables and triggers created
1:             // in soft upgrade mode using Derby 10.7 release,
1:             // The trigger actions in this test case uses a column  
1:         	// (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:         	createTableAndTrigger("TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE", 
1:         			"TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:             s.executeUpdate("alter table TAB2_soft_upgrade_NEW_TABLE_cascade " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:             		" select triggername from sys.systriggers where " +
1:             		"triggername='TAB2_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:         	//The tables created with 10.6 and prior versions will exhibit
1:         	// incorrect behavior because changes for DERBY-4887/DERBY-4984 
1:         	// have not been backported to 10.6 and earlier yet
1:         	//
1:         	//ALTER TABLE DROP COLUMN will not detect column being dropped
1:         	// in trigger action of dependent triggers.
1:         	incorrectBehaviorForDropColumn("TAB1_POSTSOFT_UPGRADE_RESTRICT",
1:         			"TAB1_POSTSOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
1:         	incorrectBehaviorForDropColumn("TAB1_POSTSOFT_UPGRADE_CASCADE",
1:         			"TAB1_POSTSOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1:         	incorrectBehaviorForDropColumn("TAB2_POSTSOFT_UPGRADE_RESTRICT",
1:         			"TAB2_POSTSOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
1:         	incorrectBehaviorForDropColumn("TAB2_POSTSOFT_UPGRADE_CASCADE",
1:         			"TAB2_POSTSOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1: 
1:         	createTableAndTrigger("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:         	incorrectBehaviorForDropColumn("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:         	createTableAndTrigger("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:         	incorrectBehaviorForDropColumn("TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB1_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1: 
1:         	//We are back to pre-10.7 version after the soft upgrade. 
1:         	//ALTER TABLE DROP COLUMN will continue to behave incorrectly
1:         	//and will not detect the trigger actions referencing the column
1:         	//being dropped directly (ie without the REFERENCING clause)
1:         	createTableAndTrigger("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:         	incorrectBehaviorForDropColumn("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:         	createTableAndTrigger("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:         	incorrectBehaviorForDropColumn("TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB2_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1:         	
1:         	break;
1:         	// The trigger has trigger action using the column being dropped
1:             // through the REFERENCING clause. Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:             		" alter table TAB1_HARD_UPGRADE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_HARD_UPGRADE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
1:                     new String[][]{{"TAB1_HARD_UPGRADE_RESTRICT_TR1"}});
1: 
1:         	// The trigger has trigger action using the column being dropped
1:             // through the REFERENCING clause. Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:             s.executeUpdate("alter table TAB1_HARD_UPGRADE_CASCADE " +
1:                     " drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_HARD_UPGRADE_CASCADE_TR1'"));
1:         	
1:         	// The trigger has trigger action using the column being dropped
1:         	// (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN RESTRICT will fail.
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB2_HARD_UPGRADE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB2_HARD_UPGRADE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
1:                     new String[][]{{"TAB2_HARD_UPGRADE_RESTRICT_TR1"}});
1: 
1:         	// The trigger has trigger action using the column being dropped
1:             // (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:             s.executeUpdate("alter table TAB2_HARD_UPGRADE_CASCADE " +
1:                     " drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB2_HARD_UPGRADE_CASCADE_TR1'"));
1: 
1:             //Create 2 new tables now that the database has been upgraded.
1:         	//Notice that newly created tables will be able to detect
1:         	//trigger action reference to column through REFERENCING clause.
1:         	createTableAndTrigger("TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1", true);
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             //Verify that trigger still exists in the system
1:             rs = s.executeQuery(
1:             " select triggername from sys.systriggers where " +
1:             "triggername='TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
1:             		new String[][]{{"TAB1_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1: 
1:         	// The trigger has trigger action using the column being dropped
1:             // through the REFERENCING clause. Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:         	createTableAndTrigger("TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1", true);
1:             s.executeUpdate("alter table TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             //Verify that the trigger does not exist in the system anymore
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
1:                     "triggername='TAB1_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1: 
1:             //Create 2 new tables now that the database has been upgraded.
1:         	// Notice that newly created tables will be able to detect
1:         	// trigger action column (without the REFERENCING clause.)
1:         	//Because of this, DROP COLUMN RESTRICT will fail.
1:         	createTableAndTrigger("TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT",
1:         			"TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1", false);
1:             //Verify that trigger still exists in the system
1:             assertStatementError("X0Y25", s,
1:             		" alter table TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT " +
1:             "triggername='TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:             		new String[][]{{"TAB2_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
1: 
1:         	// The trigger has trigger action using the column being dropped
1:             // (not through the REFERENCING clause). Because of this, 
1:         	// DROP COLUMN CASCADE will drop the dependent trigger.
1:         	createTableAndTrigger("TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE",
1:         			"TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1", false);
1:             s.executeUpdate("alter table TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE " +
1:             //Verify that the trigger does not exist in the system anymore
1:                     "triggername='TAB2_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:     //Create the table and trigger necessary for ALTER TABLE DROP COLUMN test
1:     private void createTableAndTrigger(String tableName,
1:     		String triggerName, boolean usesReferencingClause) 
1:     throws SQLException {
1:         Statement s = createStatement();
1:         ResultSet rs;
1:         
1:         s.execute("CREATE TABLE " + tableName + " (c11 int, c12 int) ");
1:         s.execute("INSERT INTO " + tableName + " VALUES (1,10)");
1:         s.execute("CREATE TRIGGER " + triggerName + 
1:         		" AFTER UPDATE OF c12 ON " + tableName +
1:         		(usesReferencingClause ? " REFERENCING OLD AS oldt" : "" )+
1:         		" FOR EACH ROW SELECT " +
1:         		(usesReferencingClause ? "oldt.c11 " : "c11 " )+
1:                 "FROM " + tableName);
1:         s.executeUpdate("UPDATE " + tableName + " SET c12=c12+1");
1:     }
1:     
1: 
commit:69dbd13
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Make sure that DERBY-4998 changes do not break backward compatibility.
1:      * 
0:      * It creates triggers in old release with trigger action columns getting
0:      * used through the REFERENCING clause. Those triggers in soft upgrade
0:      * mode, post soft upgrade mode and hard upgrade mode do not get detected 
0:      * by ALTER TABLE DROP COLUMN because prior to 10.7, we did not keep 
0:      * information about trigger action columns getting used through the 
0:      * REFERENCING clause.
1:      */
1:     public void testAlterTableDropColumnAndTriggerAction() throws Exception
1:     {
1:     	if (!oldAtLeast(10, 3)) return;
1:     	
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
0:         	//Create 2 tables for each of the upgrade phases which are 
0:         	//a)soft upgrade b)post soft upgrade and c)hard upgrade
0:         	//For each of the upgrade phase, one table will be used for 
1:         	//ALTER TABLE DROP COLUMN RESTRICT and the second table will
1:         	//be used for ALTER TABLE DROP COLUMN CASCADE
1: 
0:         	//Following 2 tables and triggers are for soft upgrade mode check
0:         	s.execute("CREATE TABLE DERBY4998_SOFT_UPGRADE_RESTRICT(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_SOFT_UPGRADE_RESTRICT VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_SOFT_UPGRADE_RESTRICT_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_SOFT_UPGRADE_RESTRICT REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_SOFT_UPGRADE_RESTRICT");
0:             s.executeUpdate("UPDATE DERBY4998_SOFT_UPGRADE_RESTRICT SET c12=c12+1");
1: 
0:             s.execute("CREATE TABLE DERBY4998_soft_upgrade_cascade(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_soft_upgrade_cascade VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_soft_upgrade_cascade_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_soft_upgrade_cascade REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_soft_upgrade_cascade");
0:             s.executeUpdate("UPDATE DERBY4998_soft_upgrade_cascade SET c12=c12+1");
1: 
0:         	//Following 2 tables and triggers are for post-soft upgrade mode
0:             //check
0:             s.execute("CREATE TABLE DERBY4998_postsoft_upgrade_restrict(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_postsoft_upgrade_restrict VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_postsoft_upgrade_restrict_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_postsoft_upgrade_restrict REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_postsoft_upgrade_restrict");
0:             s.executeUpdate("UPDATE DERBY4998_postsoft_upgrade_restrict SET c12=c12+1");
1: 
0:             s.execute("CREATE TABLE DERBY4998_postsoft_upgrade_cascade(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_postsoft_upgrade_cascade VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_postsoft_upgrade_cascade_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_postsoft_upgrade_cascade REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_postsoft_upgrade_cascade");
0:             s.executeUpdate("UPDATE DERBY4998_postsoft_upgrade_cascade SET c12=c12+1");
1: 
0:         	//Following 2 tables and triggers are for hard upgrade mode check
0:             s.execute("CREATE TABLE DERBY4998_hard_upgrade_restrict(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_hard_upgrade_restrict VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_hard_upgrade_restrict_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_hard_upgrade_restrict REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_hard_upgrade_restrict");
0:             s.executeUpdate("UPDATE DERBY4998_hard_upgrade_restrict SET c12=c12+1");
1: 
0:             s.execute("CREATE TABLE DERBY4998_hard_upgrade_cascade(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_hard_upgrade_cascade VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_hard_upgrade_cascade_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_hard_upgrade_cascade REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_hard_upgrade_cascade");
0:             s.executeUpdate("UPDATE DERBY4998_hard_upgrade_cascade SET c12=c12+1");
1:             break;
1: 
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
0:         	//The tables created with 10.6 and prior versions will exhibit
0:         	//incorrect behavoir
0:         	incorrectBehaviorForDropColumn("DERBY4998_SOFT_UPGRADE_RESTRICT",
0:         			"DERBY4998_SOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
0:         	incorrectBehaviorForDropColumn("DERBY4998_SOFT_UPGRADE_CASCADE",
0:         			"DERBY4998_SOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1: 
0:         	//Even though we are in soft upgrade mode using Derby 10.7 release,
0:         	//newly created triggers will still not keep track of trigger
0:         	//action columns referenced through REFERENCING clause because
0:         	//that will break the backward compatibility when this db gets
0:         	//used with earlier Derby version again after soft upgrade.
0:         	//Show this with an example
0:             s.execute("CREATE TABLE DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT");
0:             s.executeUpdate("UPDATE DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT SET c12=c12+1");
0:         	incorrectBehaviorForDropColumn("DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
0:         			"DERBY4998_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:         	
0:             s.execute("CREATE TABLE DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE");
0:             s.executeUpdate("UPDATE DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE SET c12=c12+1");
0:         	incorrectBehaviorForDropColumn("DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE",
0:         			"DERBY4998_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1:             break;
1: 
1:         case PH_POST_SOFT_UPGRADE: 
1:         	// soft-downgrade: boot with old version after soft-upgrade
1: 
0:         	//The tables created with 10.6 and prior versions will continue to 
0:         	//exhibit incorrect behavoir
0:         	incorrectBehaviorForDropColumn("DERBY4998_POSTSOFT_UPGRADE_RESTRICT",
0:         			"DERBY4998_POSTSOFT_UPGRADE_RESTRICT_TR1", "RESTRICT");
0:         	incorrectBehaviorForDropColumn("DERBY4998_POSTSOFT_UPGRADE_CASCADE",
0:         			"DERBY4998_POSTSOFT_UPGRADE_CASCADE_TR1", "CASCADE");
1:         	
1:         	//We are back to pre-10.7 version after the soft upgrade. 
1:         	//ALTER TABLE DROP COLUMN will continue to behave incorrectly
1:         	//and will not detect the trigger actions referencing the column
1:         	//being dropped through the REFERENCING clause
0:             s.execute("CREATE TABLE DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT");
0:             s.executeUpdate("UPDATE DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT SET c12=c12+1");
0:         	incorrectBehaviorForDropColumn("DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT",
0:         			"DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_RESTRICT_TR1", "RESTRICT");
1:         	
0:             s.execute("CREATE TABLE DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE");
0:             s.executeUpdate("UPDATE DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE SET c12=c12+1");
0:         	incorrectBehaviorForDropColumn("DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE",
0:         			"DERBY4998_POST_SOFT_UPGRADE_NEW_TABLE_CASCADE_TR1", "RESTRICT");
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
0:         	//The tables created with 10.6 and prior versions will exhibit
0:         	//incorrect behavior. Even though the database is at 10.7 level,
0:         	//the triggers created with prior Derby releases did not keep
0:         	//track of trigger action columns referenced through REFERENCING
0:         	//clause.
0:         	incorrectBehaviorForDropColumn("DERBY4998_HARD_UPGRADE_RESTRICT",
0:         			"DERBY4998_HARD_UPGRADE_RESTRICT_TR1", "RESTRICT");
0:         	incorrectBehaviorForDropColumn("DERBY4998_HARD_UPGRADE_CASCADE",
0:         			"DERBY4998_HARD_UPGRADE_CASCADE_TR1", "CASCADE");
1:         	
0:         	//Create 2 new tables now that the database has been upgraded to 
0:         	//10.7 Notice that newly created tables will be able to detect
0:         	//trigger action reference to column through REFERENCING clause.
0:         	//This is because starting 10.7, for new triggers, we have
0:         	//started keeping track of trigger action columns referenced 
0:         	//through REFERENCING clause.
0:             s.execute("CREATE TABLE DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT_tr1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT");
0:             s.executeUpdate("UPDATE DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT SET c12=c12+1");
1:             assertStatementError("X0Y25", s,
0:             		" alter table DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT " +
1:             		" drop column c11 restrict");
1:             rs = s.executeQuery(
1:             " select triggername from sys.systriggers where " +
0:             "triggername='DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1'");
1:             JDBC.assertFullResultSet(rs, 
0:             		new String[][]{{"DERBY4998_HARD_UPGRADE_NEW_TABLE_RESTRICT_TR1"}});
0:             s.execute("CREATE TABLE DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE(c11 int, c12 int)");
0:             s.execute("INSERT INTO DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE VALUES (1,10)");
0:             //Create a trigger in the older release where the database has been
0:             //created. The trigger action uses a column in trigger action
0:             //through REFERENCING clause
0:             s.execute("CREATE TRIGGER DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1 " +
0:             		"AFTER UPDATE OF c12 " +
0:             		"ON DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE REFERENCING OLD AS oldt " +
1:             		"FOR EACH ROW " +
0:                     "SELECT oldt.c11 from DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE");
0:             s.executeUpdate("UPDATE DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE SET c12=c12+1");
0:             s.executeUpdate("alter table DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE " +
1:             		" drop column c11 CASCADE");
1:             checkWarning(s, "01502");
1:             JDBC.assertEmpty(s.executeQuery(
1:                     " select triggername from sys.systriggers where " +
0:                     "triggername='DERBY4998_HARD_UPGRADE_NEW_TABLE_CASCADE_TR1'"));
1:             break;
1:         }
1:     }
1: 
1:     //ALTER TABLE DROP COLUMN in not detected the trigger column dependency for
1:     //columns being used through the REFERENCING clause for triggers created
1:     //prior to 10.7 release
1:     private void incorrectBehaviorForDropColumn(String tableName,
1:     		String triggerName, String restrictOrCascade) throws SQLException {
1:         Statement s = createStatement();
1:         ResultSet rs;
1:         
1:         //ALTER TABLE DROP COLUMN of a column used in the trigger action
1:         //through REFERENCING clause does not detect the trigger 
1:         //dependency in older releases.
1:         //RESTRICT won't give any error for dependent trigger and will
1:         //drop column c11 even though it is getting used in trigger action
1:         //and will leave the invalid trigger in the system. 
1:         //CASCADE won't give any warning for dependent trigger and will
1:         //drop column c11 even though it is getting used in trigger action
1:         //and will leave the invalid trigger in the system. 
1:         s.executeUpdate("ALTER TABLE " + tableName + " DROP COLUMN c11 " +
1:         		restrictOrCascade);
1:         rs =
1:             s.executeQuery(
1:             " select triggername from sys.systriggers where " +
1:             "triggername='" + triggerName + "'");
1:         JDBC.assertFullResultSet(rs, new String[][]{{triggerName}});
1:     }
1: 
1:     private void checkWarning(Statement st, String expectedWarning)
1:             throws Exception {
1:         SQLWarning sqlWarn = null;
1: 
1:         sqlWarn = st.getWarnings();
1:         if (sqlWarn == null) {
1:             sqlWarn = getConnection().getWarnings();
1:         }
1:         assertNotNull("Expected warning but found none", sqlWarn);
1:         assertSQLState(expectedWarning, sqlWarn);
1:     }
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1:      * Make sure that DERBY-1482 changes do not break backward compatibility
1:      */
1:     public void testTriggers() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         ResultSet rs;
1:         boolean modeDb2SqlOptional = oldAtLeast(10, 3);
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:             s.execute("CREATE TABLE DERBY1482_table1(c11 int, c12 int)");
1:             s.execute("INSERT INTO DERBY1482_table1 VALUES (1,10)");
1:             s.execute("CREATE TABLE DERBY1482_table2(c21 int, c22 int)");
1:             s.execute("CREATE TABLE DERBY1482_table3(c31 int, c32 int)");
1:             s.execute("CREATE TABLE DERBY1482_table4(c41 int, c42 int)");
1:             s.execute("CREATE TABLE DERBY1482_table5(c51 int, c52 int)");
1:             //Create the first trigger in the older release where the
1:             //database has been created. Every update of DERBY1482_table1.c12
1:             //will cause an insert into DERBY1482_table2 through this trigger tr1.
1:             s.execute("CREATE TRIGGER tr1 AFTER UPDATE OF c12 " +
1:             		"ON DERBY1482_table1 REFERENCING OLD AS oldt " +
0:             		"FOR EACH ROW " +
1:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:                     "INSERT INTO DERBY1482_table2 VALUES(-1, oldt.c12)");
1:             
1:             //Now do an update which will fire trigger tr1
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that trigger tr1 has inserted one row in DERBY1482_table2
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:             break;
1: 
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             //Now do an update while in the soft upgrade. This should
1:         	//fire trigger tr1
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that now we have 2 rows in DERBY1482_table2 because trigger tr1
1:             //has fired twice so far. Once in PH_CREATE phase and once
1:             //in PH_SOFT_UPGRADE phase
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:             //Create trigger tr2 in soft upgrade mode. DERBY-1482 changes
1:             //will not put anything about trigger action columns in 
1:             //SYSTRIGGERS to maintain backward compatibility. Only 10.7
1:             //and up recognize additional information about trigger action
1:             //columns in SYSTRIGGERS.
1:             s.execute("CREATE TRIGGER tr2 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:             		"INSERT INTO DERBY1482_table3 VALUES(-1, oldt.c12)");
1:             //Now do an update which will fire triggers tr1 and tr2
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:             //Verify that trigger tr2 has inserted one row in DERBY1482_table3
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:             break;
1: 
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             //Now do an update when we are back with the older release
1:         	//after the soft upgrade. This should fire trigger tr1 and tr2
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that now we have 4 rows in DERBY1482_table2 and 2 rows in DERBY1482_table3
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"4"}});
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:             //Create trigger tr3 with the older release. Triggers created in
1:             //soft-upgrade mode and with older release should work fine.
1:             s.execute("CREATE TRIGGER tr3 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:             		"INSERT INTO DERBY1482_table4 VALUES(-1, oldt.c12)");
1:             //Now do an update which will fire triggers tr1, tr2 and tr3
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"5"}});
1:             //Verify that trigger tr2 has inserted one more row in DERBY1482_table3
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:             //Verify that trigger tr3 has inserted one row in DERBY1482_table4
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:         	//Do an update after we have hard upgraded to 10.7 and make sure
1:         	//that all the triggers (created with older release and created
1:         	//in soft-upgrade mode) work fine.
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that now we have 6 rows in DERBY1482_table2, 4 rows in DERBY1482_table3, 2 rows in DERBY1482_table4
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"6"}});
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"4"}});
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"2"}});
1:             //Create trigger DERBY1482_table4 in the hard-upgraded db.
1:             s.execute("CREATE TRIGGER tr4 AFTER UPDATE OF c12 ON DERBY1482_table1 " +
1:             		"REFERENCING OLD AS oldt FOR EACH ROW " +
1:                     (modeDb2SqlOptional?"":"MODE DB2SQL ") +
1:             		"INSERT INTO DERBY1482_table5 VALUES(-1, oldt.c12)");
1:             //All 4 triggers tr1, tr2, tr3 and tr4 should fire 
1:             //Now do an update which will fire all 4 triggers tr1,tr2,tr3,tr4
1:             s.executeUpdate("UPDATE DERBY1482_table1 SET c12=-1 WHERE c11=1");
1:             //Verify that trigger tr1 has inserted one more row in DERBY1482_table2
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table2");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"7"}});
1:             //Verify that trigger tr2 has inserted one more row in DERBY1482_table3
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table3");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"5"}});
1:             //Verify that trigger tr3 has inserted one more row in DERBY1482_table4
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table4");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:             //Verify that trigger tr4 has inserted one row in DERBY1482_table5
1:             rs = s.executeQuery("SELECT COUNT(*) FROM DERBY1482_table5");
1:             JDBC.assertFullResultSet(rs, new String[][]{{"1"}});
1:             break;
1:         }
1:         s.close();
1:     }
1: 
1:     /**
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a584888
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_7
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: 
0: import org.apache.derbyTesting.junit.JDBCDataSource;
0: import java.lang.reflect.Method;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.sql.Connection;
0: import java.sql.CallableStatement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
1: 
0: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: 
1: /**
1:  * Upgrade test cases for 10.7.
1:  * If the old version is 10.7 or later then these tests
1:  * will not be run.
1:  * <BR>
1:     10.7 Upgrade issues
1: 
1:     <UL>
1:     <LI>BOOLEAN data type support expanded.</LI>
1:     </UL>
1: 
1:  */
1: public class Changes10_7 extends UpgradeChange
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static final String SYNTAX_ERROR = "42X01";
1:     private static final String  UPGRADE_REQUIRED = "XCL47";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public Changes10_7(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the suite of tests to test the changes made in 10.7.
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
1:      */
1:     public static Test suite(int phase) {
0:         TestSuite suite = new TestSuite("Upgrade test for 10.7");
1: 
1:         suite.addTestSuite(Changes10_7.class);
1:         return new SupportFilesSetup((Test) suite);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Make sure that that database is at level 10.7 in order to enjoy
1:      * extended support for the BOOLEAN datatype.
1:      */
1:     public void testBoolean() throws SQLException
1:     {
1:         String booleanValuedFunction =
1:             "create function f_4655( a varchar( 100 ) ) returns boolean\n" +
1:             "language java parameter style java no sql deterministic\n" +
1:             "external name 'Z.getBooleanValue'\n";
1: 
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             assertStatementError(  SYNTAX_ERROR, s, booleanValuedFunction );
1:             break;
1: 
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             assertStatementError( UPGRADE_REQUIRED, s, booleanValuedFunction );
1:             break;
1:             
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             s.execute( booleanValuedFunction );
1:             break;
1:         }
1:         
1:         s.close();
1:     }
1: 
1: }
============================================================================