2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.FromTable
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: 
1:afe6225: import java.util.Enumeration;
1:afe6225: import java.util.HashMap;
1:38b5979: import java.util.List;
1:afe6225: import java.util.Properties;
1:afe6225: import org.apache.derby.iapi.error.StandardException;
1:afe6225: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:afe6225: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:afe6225: import org.apache.derby.iapi.sql.compile.AccessPath;
1:afe6225: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:afe6225: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:c83a399: import org.apache.derby.iapi.sql.dictionary.*;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:afe6225: import org.apache.derby.impl.sql.execute.HashScanResultSet;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * A FromTable represents a table in the FROM clause of a DML statement.
1:eac0369:  * It can be either a base table, a subquery or a project restrict.
2:eac0369:  *
1:eac0369:  * @see FromBaseTable
1:eac0369:  * @see FromSubquery
1:eac0369:  * @see ProjectRestrictNode
1:eac0369:  *
1:eac0369:  */
1:03eae1d: abstract class FromTable extends ResultSetNode implements Optimizable
1:eac0369: {
1:eac0369: 	Properties		tableProperties;
1:eac0369: 	String		correlationName;
1:eac0369: 	TableName	corrTableName;
1:eac0369: 	int			tableNumber;
1:eac0369: 	/* (Query block) level is 0-based. */
1:eac0369: 	/* RESOLVE - View resolution will have to update the level within
1:eac0369: 	 * the view tree.
1:eac0369: 	 */
1:eac0369: 	int			level;
1:eac0369: 	// hashKeyColumns are 0-based column #s within the row returned by the store for hash scans
1:eac0369: 	int[]			hashKeyColumns;
1:eac0369: 
1:eac0369: 	// overrides for hash join
1:eac0369: 	int				initialCapacity = HashScanResultSet.DEFAULT_INITIAL_CAPACITY;
1:eac0369: 	float			loadFactor = HashScanResultSet.DEFAULT_LOADFACTOR;
1:eac0369: 	int				maxCapacity = HashScanResultSet.DEFAULT_MAX_CAPACITY;
1:eac0369: 
1:eac0369: 	AccessPathImpl			currentAccessPath;
1:eac0369: 	AccessPathImpl			bestAccessPath;
1:eac0369: 	AccessPathImpl			bestSortAvoidancePath;
1:eac0369: 	AccessPathImpl			trulyTheBestAccessPath;
1:eac0369: 
1:eac0369: 	private int		joinStrategyNumber;
1:eac0369: 
1:eac0369: 	protected String userSpecifiedJoinStrategy;
1:eac0369: 
1:eac0369: 	protected CostEstimate bestCostEstimate;
1:eac0369: 
1:b223f72:     private double perRowUsage = -1;
1:eac0369:     
1:eac0369: 	private boolean considerSortAvoidancePath;
1:eac0369: 
1:df5ffc8: 	/**
1:dbed020: 	 Set of object-&gt;trulyTheBestAccessPath mappings used to keep track
1:df5ffc8: 	 of which of this Optimizable's "trulyTheBestAccessPath" was the best
1:acdff3c: 	 with respect to a specific outer query or ancestor node.  In the case
1:acdff3c: 	 of an outer query, the object key will be an instance of OptimizerImpl.
1:acdff3c: 	 In the case of an ancestor node, the object key will be that node itself.
1:acdff3c: 	 Each ancestor node or outer query could potentially have a different
1:acdff3c: 	 idea of what this Optimizable's "best access path" is, so we have to
1:acdff3c: 	 keep track of them all.
1:df5ffc8: 	*/
1:71c8e86: 	private HashMap<Object,AccessPathImpl> bestPlanMap;
1:acdff3c: 
1:acdff3c: 	/** Operations that can be performed on bestPlanMap. */
1:acdff3c: 	protected static final short REMOVE_PLAN = 0;
1:acdff3c: 	protected static final short ADD_PLAN = 1;
1:acdff3c: 	protected static final short LOAD_PLAN = 2;
1:eac0369: 
1:b6c6e95: 	/** the original unbound table name */
1:b6c6e95: 	protected TableName origTableName;
1:3e77b5a: 
1:3e77b5a:     /** for resolving column references in MERGE statements in tough cases*/
1:3e77b5a:     private int _mergeTableID = ColumnReference.MERGE_UNKNOWN;
1:eac0369: 	
1:eac0369: 	/**
1:3bb140c:      * Constructor for a table in a FROM list.
1:3bb140c:      *
1:3bb140c:      * @param correlationName   The correlation name
1:3bb140c:      * @param tableProperties   Properties list associated with the table
1:3bb140c:      * @param cm                The context manager
1:3bb140c:      */
1:3bb140c:     FromTable(String correlationName,
1:3bb140c:               Properties tableProperties,
1:3bb140c:               ContextManager cm)
1:3bb140c:     {
1:3bb140c:         super(cm);
1:3bb140c:         this.correlationName = correlationName;
1:3bb140c:         this.tableProperties = tableProperties;
1:3bb140c:         tableNumber = -1;
1:3bb140c:         bestPlanMap = null;
1:3bb140c:     }
1:eac0369: 
1:eac0369: 	/**
1:444aa52: 	 * Get this table's correlation name, if any.
1:eac0369: 	 */
1:444aa52: 	public	String	getCorrelationName() { return correlationName; }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public CostEstimate optimizeIt(
1:eac0369: 							Optimizer optimizer,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							CostEstimate outerCost,
1:eac0369: 							RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:e07631a: 		// It's possible that a call to optimize the left/right will cause
1:e07631a: 		// a new "truly the best" plan to be stored in the underlying base
1:e07631a: 		// tables.  If that happens and then we decide to skip that plan
1:e07631a: 		// (which we might do if the call to "considerCost()" below decides
1:e07631a: 		// the current path is infeasible or not the best) we need to be
1:e07631a: 		// able to revert back to the "truly the best" plans that we had
1:e07631a: 		// saved before we got here.  So with this next call we save the
1:e07631a: 		// current plans using "this" node as the key.  If needed, we'll
1:e07631a: 		// then make the call to revert the plans in OptimizerImpl's
1:e07631a: 		// getNextDecoratedPermutation() method.
1:acdff3c: 		updateBestPlanMap(ADD_PLAN, this);
1:eac0369: 
1:eac0369: 		CostEstimate singleScanCost = estimateCost(predList,
1:eac0369: 												(ConglomerateDescriptor) null,
1:eac0369: 												outerCost,
1:eac0369: 												optimizer,
1:eac0369: 												rowOrdering);
1:eac0369: 
1:eac0369: 		/* Make sure there is a cost estimate to set */
1:eac0369: 		getCostEstimate(optimizer);
1:eac0369: 
1:11f7ee3: 		setCostEstimateCost(singleScanCost);
1:eac0369: 
1:eac0369: 		/* Optimize any subqueries that need to get optimized and
1:eac0369: 		 * are not optimized any where else.  (Like those
1:eac0369: 		 * in a RowResultSetNode.)
1:eac0369: 		 */
1:11f7ee3: 		optimizeSubqueries(getDataDictionary(), getCostEstimate().rowCount());
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the cost of this result set in the context of the whole plan.
1:eac0369: 		*/
1:eac0369: 		getCurrentAccessPath().
1:eac0369: 			getJoinStrategy().
1:eac0369: 				estimateCost(
1:eac0369: 							this,
1:eac0369: 							predList,
1:eac0369: 							(ConglomerateDescriptor) null,
1:eac0369: 							outerCost,
1:eac0369: 							optimizer,
1:eac0369: 							getCostEstimate()
1:eac0369: 							);
1:eac0369: 
1:eac0369: 		optimizer.considerCost(this, predList, getCostEstimate(), outerCost);
1:eac0369: 
1:eac0369: 		return getCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see Optimizable#nextAccessPath
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean nextAccessPath(Optimizer optimizer,
1:eac0369: 									OptimizablePredicateList predList,
1:eac0369: 									RowOrdering rowOrdering)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		int	numStrat = optimizer.getNumberOfJoinStrategies();
1:eac0369: 		boolean found = false;
1:eac0369: 		AccessPath ap = getCurrentAccessPath();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Most Optimizables have no ordering, so tell the rowOrdering that
1:eac0369: 		** this Optimizable is unordered, if appropriate.
1:eac0369: 		*/
1:eac0369: 		if (userSpecifiedJoinStrategy != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** User specified a join strategy, so we should look at only one
1:eac0369: 			** strategy.  If there is a current strategy, we have already
1:eac0369: 			** looked at the strategy, so go back to null.
1:eac0369: 			*/
1:eac0369: 			if (ap.getJoinStrategy() != null)
1:eac0369: 			{
1:eac0369:   				ap.setJoinStrategy((JoinStrategy) null);
1:eac0369: 
1:eac0369: 				found = false;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				ap.setJoinStrategy(
1:eac0369: 								optimizer.getJoinStrategy(userSpecifiedJoinStrategy));
1:eac0369: 
1:eac0369: 				if (ap.getJoinStrategy() == null)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_STRATEGY, 
1:eac0369: 						userSpecifiedJoinStrategy, getBaseTableName());
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				found = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if (joinStrategyNumber < numStrat)
1:eac0369: 		{
1:eac0369: 			/* Step through the join strategies. */
1:eac0369: 			ap.setJoinStrategy(optimizer.getJoinStrategy(joinStrategyNumber));
1:eac0369: 
1:eac0369: 			joinStrategyNumber++;
1:eac0369: 
1:eac0369: 			found = true;
1:eac0369: 
1:9881ca4:             if ( optimizerTracingIsOn() ) { getOptimizerTracer().traceConsideringJoinStrategy( ap.getJoinStrategy(), tableNumber ); }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Tell the RowOrdering about columns that are equal to constant
1:eac0369: 		** expressions.
1:eac0369: 		*/
1:eac0369: 		tellRowOrderingAboutConstantColumns(rowOrdering, predList);
1:eac0369: 
1:eac0369: 		return found;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Most Optimizables cannot be ordered */
1:eac0369: 	protected boolean canBeOrdered()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getCurrentAccessPath */
1:eac0369: 	public AccessPath getCurrentAccessPath()
1:eac0369: 	{
1:eac0369: 		return currentAccessPath;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getBestAccessPath */
1:eac0369: 	public AccessPath getBestAccessPath()
1:eac0369: 	{
1:eac0369: 		return bestAccessPath;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getBestSortAvoidancePath */
1:eac0369: 	public AccessPath getBestSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		return bestSortAvoidancePath;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1:eac0369: 	public AccessPath getTrulyTheBestAccessPath()
1:eac0369: 	{
1:eac0369: 		return trulyTheBestAccessPath;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#rememberSortAvoidancePath */
1:eac0369: 	public void rememberSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		considerSortAvoidancePath = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#considerSortAvoidancePath */
1:eac0369: 	public boolean considerSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		return considerSortAvoidancePath;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#rememberJoinStrategyAsBest */
1:eac0369: 	public void rememberJoinStrategyAsBest(AccessPath ap)
1:eac0369: 	{
1:3bb140c:         Optimizer opt = ap.getOptimizer();
1:eac0369: 
1:eac0369: 		ap.setJoinStrategy(getCurrentAccessPath().getJoinStrategy());
1:eac0369: 
1:9881ca4:         if (optimizerTracingIsOn()) {
1:9881ca4:             getOptimizerTracer().traceRememberingJoinStrategy(
1:3bb140c:                 getCurrentAccessPath().getJoinStrategy(), tableNumber);
1:3bb140c:         }
1:eac0369: 
1:eac0369: 		if (ap == bestAccessPath)
1:eac0369: 		{
1:9881ca4:             if (optimizerTracingIsOn()) {
1:9881ca4:                 getOptimizerTracer().traceRememberingBestAccessPathSubstring(
1:3bb140c:                     ap, tableNumber);
1:3bb140c:             }
1:eac0369: 		}
1:eac0369: 		else if (ap == bestSortAvoidancePath)
1:eac0369: 		{
1:9881ca4:             if (optimizerTracingIsOn()) {
1:9881ca4:                 getOptimizerTracer().
1:3bb140c:                     traceRememberingBestSortAvoidanceAccessPathSubstring(
1:3bb140c:                         ap, tableNumber);
1:3bb140c:             }
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* We currently get here when optimizing an outer join.
1:eac0369: 			 * (Problem predates optimizer trace change.)
1:eac0369: 			 * RESOLVE - fix this at some point.
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"unknown access path type");
1:3bb140c: 			}
1:eac0369: 			 */
1:9881ca4:             if (optimizerTracingIsOn()) {
1:9881ca4:                 getOptimizerTracer().traceRememberingBestUnknownAccessPathSubstring(
1:3bb140c:                     ap, tableNumber);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTableDescriptor */
1:eac0369: 	public TableDescriptor getTableDescriptor()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getTableDescriptor() not expected to be called for "
1:eac0369: 				+ getClass().toString());
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:ec6fcf1: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#pullOptPredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void pullOptPredicates(
1:eac0369: 								OptimizablePredicateList optimizablePredicates)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* For most types of Optimizable, do nothing */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#modifyAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* For most types of Optimizable, do nothing */
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see Optimizable#isCoveringIndex
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getProperties */
1:eac0369: 	public Properties getProperties()
1:eac0369: 	{
1:eac0369: 		return tableProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#setProperties */
1:eac0369: 	public void setProperties(Properties tableProperties)
1:eac0369: 	{
1:eac0369: 		this.tableProperties = tableProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#verifyProperties 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void verifyProperties(DataDictionary dDictionary)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (tableProperties == null)
1:eac0369: 		{
1:0eb98f1: 			return;
1:eac0369: 		}
1:eac0369: 		/* Check here for:
1:eac0369: 		 *		invalid properties key
1:eac0369: 		 *		invalid joinStrategy
1:eac0369: 		 *		invalid value for hashInitialCapacity
1:eac0369: 		 *		invalid value for hashLoadFactor
1:eac0369: 		 *		invalid value for hashMaxCapacity
1:eac0369: 		 */
1:e1f49ca:         Enumeration<?> e = tableProperties.keys();
1:e1f49ca: 
1:df9af89: 		while (e.hasMoreElements())
1:eac0369: 		{
1:df9af89: 			String key = (String) e.nextElement();
1:eac0369: 			String value = (String) tableProperties.get(key);
1:eac0369: 
1:eac0369: 			if (key.equals("joinStrategy"))
1:eac0369: 			{
1:eac0369: 				userSpecifiedJoinStrategy = StringUtil.SQLToUpperCase(value);
1:eac0369: 			}
1:eac0369: 			else if (key.equals("hashInitialCapacity"))
1:eac0369: 			{
1:eac0369: 				initialCapacity = getIntProperty(value, key);
1:eac0369: 
1:eac0369: 				// verify that the specified value is valid
1:eac0369: 				if (initialCapacity <= 0)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_INITIAL_CAPACITY, 
1:eac0369: 							String.valueOf(initialCapacity));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else if (key.equals("hashLoadFactor"))
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eb7e251: 					loadFactor = Float.parseFloat(value);
1:eac0369: 				}
1:eac0369: 				catch (NumberFormatException nfe)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
1:eac0369: 							value, key);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// verify that the specified value is valid
1:eac0369: 				if (loadFactor <= 0.0 || loadFactor > 1.0)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_LOAD_FACTOR, 
1:eac0369: 							value);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else if (key.equals("hashMaxCapacity"))
1:eac0369: 			{
1:eac0369: 				maxCapacity = getIntProperty(value, key);
1:eac0369: 
1:eac0369: 				// verify that the specified value is valid
1:eac0369: 				if (maxCapacity <= 0)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_MAX_CAPACITY, 
1:eac0369: 							String.valueOf(maxCapacity));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// No other "legal" values at this time
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_TABLE_PROPERTY, key,
1:eac0369: 					"joinStrategy");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getName 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public String getName() throws StandardException
1:eac0369: 	{
1:eac0369: 		return getExposedName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getBaseTableName */
1:eac0369: 	public String getBaseTableName()
1:eac0369: 	{
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#convertAbsoluteToRelativeColumnPosition */
1:eac0369: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition)
1:eac0369: 	{
1:eac0369: 		return absolutePosition;
1:eac0369: 	}
1:eac0369: 
1:acdff3c: 	/** @see Optimizable#updateBestPlanMap */
1:acdff3c: 	public void updateBestPlanMap(short action,
1:e07631a: 		Object planKey) throws StandardException
1:eac0369: 	{
1:acdff3c: 		if (action == REMOVE_PLAN)
1:acdff3c: 		{
1:acdff3c: 			if (bestPlanMap != null)
1:acdff3c: 			{
1:acdff3c: 				bestPlanMap.remove(planKey);
1:3bb140c:                 if (bestPlanMap.isEmpty()) {
1:acdff3c: 					bestPlanMap = null;
1:3bb140c:                 }
1:acdff3c: 			}
1:acdff3c: 
1:acdff3c: 			return;
1:acdff3c: 		}
1:acdff3c: 
1:e07631a: 		AccessPath bestPath = getTrulyTheBestAccessPath();
1:62d4560: 		AccessPathImpl ap = null;
1:acdff3c: 		if (action == ADD_PLAN)
1:b6c6e95: 		{
1:e07631a: 			// If we get to this method before ever optimizing this node, then
1:e07631a: 			// there will be no best path--so there's nothing to do.
1:e07631a: 			if (bestPath == null)
1:eac0369: 				return;
1:eac0369: 
1:acdff3c: 			// If the bestPlanMap already exists, search for an
1:e07631a: 			// AccessPath for the received key and use that if we can.
1:acdff3c: 			if (bestPlanMap == null)
1:71c8e86: 				bestPlanMap = new HashMap<Object,AccessPathImpl>();
1:62d4560: 			else
1:71c8e86: 				ap = bestPlanMap.get(planKey);
1:eac0369: 
1:e07631a: 			// If we don't already have an AccessPath for the key,
1:e07631a: 			// create a new one.  If the key is an OptimizerImpl then
1:e07631a: 			// we might as well pass it in to the AccessPath constructor;
1:e07631a: 			// otherwise just pass null.
2:62d4560: 			if (ap == null)
5:b223f72: 			{
1:e07631a: 				if (planKey instanceof Optimizer)
1:e07631a: 					ap = new AccessPathImpl((Optimizer)planKey);
1:e07631a: 				else
1:e07631a: 					ap = new AccessPathImpl((Optimizer)null);
1:eac0369: 			}
1:eac0369: 
1:e07631a: 			ap.copy(bestPath);
1:acdff3c: 			bestPlanMap.put(planKey, ap);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:62d4560: 		// If we get here, we want to load the best plan from our map
1:62d4560: 		// into this Optimizable's trulyTheBestAccessPath field.
1:eac0369: 
1:62d4560: 		// If we don't have any plans saved, then there's nothing to load.
1:e07631a: 		// This can happen if the key is an OptimizerImpl that tried some
1:e07631a: 		// join order for which there was no valid plan.
1:acdff3c: 		if (bestPlanMap == null)
1:e07631a: 			return;
1:eac0369: 
1:71c8e86: 		ap = bestPlanMap.get(planKey);
1:eac0369: 
1:e07631a: 		// It might be the case that there is no plan stored for
1:e07631a: 		// the key, in which case there's nothing to load.
1:e07631a: 		if ((ap == null) || (ap.getCostEstimate() == null))
4:62d4560: 			return;
1:eac0369: 
1:62d4560: 		// We found a best plan in our map, so load it into this Optimizable's
1:62d4560: 		// trulyTheBestAccessPath field.
1:e07631a: 		bestPath.copy(ap);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#rememberAsBest */
1:62d4560: 	public void rememberAsBest(int planType, Optimizer optimizer)
1:62d4560: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		AccessPath bestPath = null;
1:eac0369: 
1:eac0369: 		switch (planType)
1:eac0369: 		{
1:eac0369: 		  case Optimizer.NORMAL_PLAN:
1:eac0369: 			bestPath = getBestAccessPath();
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		  case Optimizer.SORT_AVOIDANCE_PLAN:
1:eac0369: 			bestPath = getBestSortAvoidancePath();
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		  default:
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"Invalid plan type " + planType);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		getTrulyTheBestAccessPath().copy(bestPath);
1:eac0369: 
1:62d4560: 		// Since we just set trulyTheBestAccessPath for the current
1:62d4560: 		// join order of the received optimizer, take note of what
1:62d4560: 		// that path is, in case we need to "revert" back to this
1:acdff3c: 		// path later.  See Optimizable.updateBestPlanMap().
1:e07631a: 		// Note: Since this call descends all the way down to base
1:e07631a: 		// tables, it can be relatively expensive when we have deeply
1:e07631a: 		// nested subqueries.  So in an attempt to save some work, we
1:e07631a: 		// skip the call if this node is a ProjectRestrictNode whose
1:e07631a: 		// child is an Optimizable--in that case the ProjectRestrictNode
1:e07631a: 		// will in turn call "rememberAsBest" on its child and so
1:acdff3c: 		// the required call to updateBestPlanMap() will be
1:e07631a: 		// made at that time.  If we did it here, too, then we would
1:e07631a: 		// just end up duplicating the work.
1:e07631a: 		if (!(this instanceof ProjectRestrictNode))
1:acdff3c: 			updateBestPlanMap(ADD_PLAN, optimizer);
1:e07631a: 		else
1:b223f72: 		{
1:e07631a: 			ProjectRestrictNode prn = (ProjectRestrictNode)this;
1:e07631a: 			if (!(prn.getChildResult() instanceof Optimizable))
1:acdff3c: 				updateBestPlanMap(ADD_PLAN, optimizer);
2:b6c6e95: 		}
1:eac0369: 		 
1:eac0369: 		/* also store the name of the access path; i.e index name/constraint
1:eac0369: 		 * name if we're using an index to access the base table.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		if (isBaseTable())
1:eac0369: 		{
1:eac0369: 			DataDictionary dd = getDataDictionary();
1:eac0369: 			TableDescriptor td = getTableDescriptor();
1:eac0369: 			getTrulyTheBestAccessPath().initializeAccessPathName(dd, td);
1:eac0369: 		}
1:eac0369: 
1:11f7ee3: 		setCostEstimateCost(bestPath.getCostEstimate());
1:eac0369: 
1:9881ca4:         if ( optimizerTracingIsOn() )
1:9881ca4:         { getOptimizerTracer().traceRememberingBestAccessPath( bestPath, tableNumber, planType ); }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#startOptimizing */
1:eac0369: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
1:eac0369: 	{
1:eac0369: 		resetJoinStrategies(optimizer);
1:eac0369: 
1:eac0369: 		considerSortAvoidancePath = false;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If there are costs associated with the best and sort access
1:eac0369: 		** paths, set them to their maximum values, so that any legitimate
1:eac0369: 		** access path will look cheaper.
1:eac0369: 		*/
1:eac0369: 		CostEstimate ce = getBestAccessPath().getCostEstimate();
1:eac0369: 
1:eac0369: 		if (ce != null)
1:eac0369: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
1:eac0369: 
1:eac0369: 		ce = getBestSortAvoidancePath().getCostEstimate();
1:eac0369: 
1:eac0369: 		if (ce != null)
1:eac0369: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
1:eac0369: 
1:eac0369: 		if (! canBeOrdered())
1:eac0369: 			rowOrdering.addUnorderedOptimizable(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method is called when this table is placed in a potential
1:eac0369: 	 * join order, or when a new conglomerate is being considered.
1:eac0369: 	 * Set this join strategy number to 0 to indicate that
1:eac0369: 	 * no join strategy has been considered for this table yet.
1:eac0369: 	 */
1:eac0369: 	protected void resetJoinStrategies(Optimizer optimizer)
1:eac0369: 	{
1:eac0369: 		joinStrategyNumber = 0;
1:eac0369: 		getCurrentAccessPath().setJoinStrategy((JoinStrategy) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#estimateCost
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1:eac0369: 									ConglomerateDescriptor cd,
1:eac0369: 									CostEstimate outerCost,
1:eac0369: 									Optimizer optimizer,
1:eac0369: 									RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 			 "estimateCost() not expected to be called for " + 
1:eac0369: 			 getClass().toString());
1:eac0369: 		}	
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:ab10884: 	 * Get the final CostEstimate for this FromTable.
1:eac0369: 	 *
1:ab10884: 	 * @return	The final CostEstimate for this FromTable, which is
1:ab10884: 	 *  the costEstimate of trulyTheBestAccessPath if there is one.
1:ab10884: 	 *  If there's no trulyTheBestAccessPath for this node, then
1:ab10884: 	 *  we just return the value stored in costEstimate as a default.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:ab10884: 		throws StandardException
1:eac0369: 	{
1:ab10884: 		// If we already found it, just return it.
1:11f7ee3: 		if (getCandidateFinalCostEstimate() != null)
1:11f7ee3:         {
1:11f7ee3: 			return getCandidateFinalCostEstimate();
1:11f7ee3:         }
1:eac0369: 
1:ab10884: 		if (getTrulyTheBestAccessPath() == null)
1:11f7ee3:         {
1:11f7ee3: 			setCandidateFinalCostEstimate( getCostEstimate() );
1:11f7ee3:         }
1:ab10884: 		else
1:11f7ee3:         {
1:11f7ee3: 			setCandidateFinalCostEstimate( getTrulyTheBestAccessPath().getCostEstimate() );
1:11f7ee3:         }
1:eac0369: 
1:11f7ee3: 		return getCandidateFinalCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#isBaseTable */
1:eac0369: 	public boolean isBaseTable()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:ec6fcf1:      * Check if any columns containing large objects (BLOBs or CLOBs) are
1:ec6fcf1:      * referenced in this table.
1:ec6fcf1:      *
1:ec6fcf1:      * @return {@code true} if at least one large object column is referenced,
1:ec6fcf1:      * {@code false} otherwise
1:ec6fcf1:      */
1:ec6fcf1:     public boolean hasLargeObjectColumns() {
1:11f7ee3:         for (ResultColumn rc : getResultColumns()) {
1:ec6fcf1:             if (rc.isReferenced()) {
1:ec6fcf1:                 DataTypeDescriptor type = rc.getType();
1:ec6fcf1:                 if (type != null && type.getTypeId().isLOBTypeId()) {
1:ec6fcf1:                     return true;
1:ec6fcf1:                 }
1:ec6fcf1:             }
1:ec6fcf1:         }
1:ec6fcf1:         return false;
1:ec6fcf1:     }
1:ec6fcf1: 
1:eac0369: 	/** @see Optimizable#isMaterializable 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean isMaterializable()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Derived tables are materializable
1:eac0369: 		 * iff they are not correlated with an outer query block.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		HasCorrelatedCRsVisitor visitor = new HasCorrelatedCRsVisitor();
1:eac0369: 		accept(visitor);
1:eac0369: 		return !(visitor.hasCorrelatedCRs());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#supportsMultipleInstantiations */
1:eac0369: 	public boolean supportsMultipleInstantiations()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTableNumber */
1:eac0369: 	public int getTableNumber()
1:eac0369: 	{
1:eac0369: 		return tableNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#hasTableNumber */
1:eac0369: 	public boolean hasTableNumber()
1:eac0369: 	{
1:eac0369: 		return tableNumber >= 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#forUpdate */
1:eac0369: 	public boolean forUpdate()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#initialCapacity */
1:eac0369: 	public int initialCapacity()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
2:eac0369: 			SanityManager.THROWASSERT("Not expected to be called");
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#loadFactor */
1:eac0369: 	public float loadFactor()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("Not expected to be called");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return 0.0F;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#maxCapacity */
1:b223f72: 	public int maxCapacity( JoinStrategy joinStrategy, int maxMemoryPerTable) throws StandardException
1:eac0369: 	{
1:b223f72:         return joinStrategy.maxCapacity( maxCapacity, maxMemoryPerTable, getPerRowUsage());
1:eac0369: 	}
1:eac0369: 
1:b223f72:     private double getPerRowUsage() throws StandardException
1:eac0369:     {
1:b223f72:         if( perRowUsage < 0)
1:eac0369:         {
1:b223f72:             // Do not use getRefCols() because the cached refCols may no longer be valid.
1:11f7ee3:             FormatableBitSet refCols = getResultColumns().getReferencedFormatableBitSet(cursorTargetTable(), true, false);
1:b223f72:             perRowUsage = 0.0;
1:eac0369: 
1:eac0369:             /* Add up the memory usage for each referenced column */
1:eac0369:             for (int i = 0; i < refCols.size(); i++)
1:eac0369:             {
1:eac0369:                 if (refCols.isSet(i))
1:eac0369:                 {
1:11f7ee3:                     ResultColumn rc = getResultColumns().elementAt(i);
1:ba1b7ec:                     DataTypeDescriptor expressionType = rc.getExpression().getTypeServices();
1:eac0369:                     if( expressionType != null)
1:eac0369:                         perRowUsage += expressionType.estimatedMemoryUsage();
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             /*
1:eac0369:             ** If the proposed conglomerate is a non-covering index, add the 
1:eac0369:             ** size of the RowLocation column to the total.
1:eac0369:             **
1:eac0369:             ** NOTE: We don't have a DataTypeDescriptor representing a
1:eac0369:             ** REF column here, so just add a constant here.
1:eac0369:             */
1:eac0369:             ConglomerateDescriptor cd =
1:eac0369:               getCurrentAccessPath().getConglomerateDescriptor();
1:eac0369:             if (cd != null)
1:eac0369:             {
1:eac0369:                 if (cd.isIndex() && ( ! isCoveringIndex(cd) ) )
1:eac0369:                 {
1:5b12563:                     perRowUsage +=  12.0 ;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:b223f72:         return perRowUsage ;
1:b223f72:     } // end of getPerRowUsage
1:eac0369: 
1:eac0369: 	/** @see Optimizable#hashKeyColumns */
1:eac0369: 	public int[] hashKeyColumns()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(hashKeyColumns != null,
1:eac0369: 				"hashKeyColumns expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return hashKeyColumns;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#setHashKeyColumns */
1:eac0369: 	public void setHashKeyColumns(int[] columnNumbers)
1:eac0369: 	{
1:eac0369: 		hashKeyColumns = columnNumbers;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#feasibleJoinStrategy
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1:eac0369: 										Optimizer optimizer)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		return getCurrentAccessPath().getJoinStrategy().
1:eac0369: 								feasible(this, predList, optimizer);
1:eac0369: 	}
1:eac0369: 
1:1cd0a14:     /** @see Optimizable#memoryUsageOK */
1:b223f72:     public boolean memoryUsageOK( double rowCount, int maxMemoryPerTable)
1:b223f72: 			throws StandardException
1:eac0369:     {
1:eac0369: 		/*
1:eac0369: 		** Don't enforce maximum memory usage for a user-specified join
1:eac0369: 		** strategy.
1:eac0369: 		*/
1:b223f72:         if( userSpecifiedJoinStrategy != null)
1:b223f72:             return true;
1:eac0369: 
1:b223f72:         int intRowCount = (rowCount > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) rowCount;
1:b223f72:         return intRowCount <= maxCapacity( getCurrentAccessPath().getJoinStrategy(), maxMemoryPerTable);
1:eac0369:     }
1:0eb98f1:     
1:0eb98f1: 	/**
1:0eb98f1: 	 * No-op in FromTable.
1:0eb98f1: 	 * 
1:0eb98f1: 	 * @see HalfOuterJoinNode#isJoinColumnForRightOuterJoin
1:0eb98f1: 	 */
1:3bb140c:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
1:0eb98f1: 	{
1:0eb98f1: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#legalJoinOrder
1:eac0369: 	 */
1:eac0369: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
1:eac0369: 	{
1:eac0369: 		// Only those subclasses with dependencies need to override this.
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#getNumColumnsReturned
1:eac0369: 	 */
1:eac0369: 	public int getNumColumnsReturned()
1:eac0369: 	{
1:11f7ee3: 		return getResultColumns().size();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#isTargetTable
1:eac0369: 	 */
1:eac0369: 	public boolean isTargetTable()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#isOneRowScan
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean isOneRowScan() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We simply return isOneRowResultSet() for all
1:eac0369: 		 * subclasses except for EXISTS FBT where
1:eac0369: 		 * the semantics differ between 1 row per probe
1:eac0369: 		 * and whether or not there can be more than 1
1:eac0369: 		 * rows that qualify on a scan.
1:eac0369: 		 */
1:eac0369: 		return isOneRowResultSet();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#initAccessPaths
1:eac0369: 	 */
1:eac0369: 	public void initAccessPaths(Optimizer optimizer)
1:eac0369: 	{
1:eac0369: 		if (currentAccessPath == null)
1:eac0369: 		{
1:eac0369: 			currentAccessPath = new AccessPathImpl(optimizer);
1:eac0369: 		}
1:eac0369: 		if (bestAccessPath == null)
1:eac0369: 		{
1:eac0369: 			bestAccessPath = new AccessPathImpl(optimizer);
1:eac0369: 		}
1:eac0369: 		if (bestSortAvoidancePath == null)
1:eac0369: 		{
1:eac0369: 			bestSortAvoidancePath = new AccessPathImpl(optimizer);
1:eac0369: 		}
1:eac0369: 		if (trulyTheBestAccessPath == null)
1:eac0369: 		{
1:eac0369: 			trulyTheBestAccessPath = new AccessPathImpl(optimizer);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#uniqueJoin
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public double uniqueJoin(OptimizablePredicateList predList)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		return -1.0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Return the user specified join strategy, if any for this table.
1:eac0369: 	 *
1:eac0369: 	 * @return The user specified join strategy, if any for this table.
1:eac0369: 	 */
1:eac0369: 	String getUserSpecifiedJoinStrategy()
1:eac0369: 	{
1:eac0369: 		if (tableProperties == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return tableProperties.getProperty("joinStrategy");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a table that has a FOR UPDATE
1:eac0369: 	 * clause.  Overridden by FromBaseTable.
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:eac0369: 	protected boolean cursorTargetTable()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected CostEstimate getCostEstimate(Optimizer optimizer)
1:eac0369: 	{
1:11f7ee3: 		if (getCostEstimate() == null)
1:eac0369: 		{
1:11f7ee3: 			setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:eac0369: 		}
1:11f7ee3: 		return getCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** This gets a cost estimate for doing scratch calculations.  Typically,
1:eac0369: 	** it will hold the estimated cost of a conglomerate.  If the optimizer
1:eac0369: 	** decides the scratch cost is lower than the best cost estimate so far,
1:eac0369: 	** it will copy the scratch cost to the non-scratch cost estimate,
1:eac0369: 	** which is allocated above.
1:eac0369: 	*/
1:eac0369: 	protected CostEstimate getScratchCostEstimate(Optimizer optimizer)
1:eac0369: 	{
1:11f7ee3: 		if ( getScratchCostEstimate() == null )
1:eac0369: 		{
1:11f7ee3: 			setScratchCostEstimate( getOptimizerFactory().getCostEstimate() );
1:eac0369: 		}
1:eac0369: 
1:11f7ee3: 		return getScratchCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the cost estimate in this node to the given cost estimate.
1:eac0369: 	 */
1:11f7ee3: 	protected void setCostEstimateCost(CostEstimate newCostEstimate)
1:eac0369: 	{
1:11f7ee3: 		getCostEstimate().setCost(newCostEstimate);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Assign the cost estimate in this node to the given cost estimate.
1:eac0369: 	 */
1:eac0369: 	protected void assignCostEstimate(CostEstimate newCostEstimate)
1:eac0369: 	{
1:11f7ee3: 		setCostEstimate( newCostEstimate );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "correlation Name: " + correlationName + "\n" +
1:eac0369: 				(corrTableName != null ?
1:eac0369: 					corrTableName.toString() : "null") + "\n" +
1:eac0369: 				"tableNumber " + tableNumber + "\n" +
1:eac0369: 				"level " + level + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a ResultColumnList with all of the columns in this table.
1:eac0369: 	 * (Used in expanding '*'s.)
1:eac0369: 	 * NOTE: Since this method is for expanding a "*" in the SELECT list,
1:eac0369: 	 * ResultColumn.expression will be a ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @param allTableName		The qualifier on the "*"
1:eac0369: 	 *
1:eac0369: 	 * @return ResultColumnList	List of result columns from this table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ResultColumnList getResultColumnsForList(TableName allTableName,
1:eac0369: 												ResultColumnList inputRcl,
1:eac0369: 												TableName tableName)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		TableName		 exposedName;
1:c83a399:         TableName        toCompare;
1:c83a399: 		/* If allTableName is non-null, then we must check to see if it matches
1:eac0369: 		 * our exposed name.
1:eac0369: 		 */
1:c83a399: 
1:c83a399:         if(correlationName == null)
1:c83a399:            toCompare = tableName;
1:c83a399:         else {
1:c83a399:             if(allTableName != null)
1:c83a399:                 toCompare = makeTableName(allTableName.getSchemaName(),correlationName);
1:c83a399:             else
1:c83a399:                 toCompare = makeTableName(null,correlationName);
1:c83a399:         }
1:c83a399: 
1:c83a399:         if ( allTableName != null &&
1:c83a399:              ! allTableName.equals(toCompare))
1:c83a399:         {
1:c83a399:             return null;
1:c83a399:         }
1:eac0369: 
1:eac0369: 		/* Cache exposed name for this table.
1:eac0369: 		 * The exposed name becomes the qualifier for each column
1:eac0369: 		 * in the expanded list.
1:eac0369: 		 */
1:eac0369: 		if (correlationName == null)
1:eac0369: 		{
1:eac0369: 			exposedName = tableName;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			exposedName = makeTableName(null, correlationName);
1:eac0369: 		}
1:eac0369: 
1:e1f49ca:         final ContextManager cm = getContextManager();
1:e1f49ca:         ResultColumnList rcList = new ResultColumnList(cm);
1:eac0369: 
1:eac0369: 		/* Build a new result column list based off of resultColumns.
1:eac0369: 		 * NOTE: This method will capture any column renaming due to 
1:eac0369: 		 * a derived column list.
1:eac0369: 		 */
1:e1f49ca:         for (ResultColumn rc : inputRcl)
1:eac0369: 		{
1:2f8e6fb:             ColumnReference oldCR = rc.getReference();
1:2f8e6fb:             if ( oldCR != null )
1:2f8e6fb:             {
1:2f8e6fb:                 // for UPDATE actions of MERGE statement, preserve the original table name.
1:2f8e6fb:                 // this is necessary in order to correctly bind the column list of the dummy SELECT.
1:2f8e6fb:                 if ( oldCR.getMergeTableID() != ColumnReference.MERGE_UNKNOWN )
1:2f8e6fb:                 {
1:2f8e6fb:                     exposedName = oldCR.getQualifiedTableName();
1:2f8e6fb:                 }
1:2f8e6fb:             }
1:3e77b5a: 
1:3e77b5a:             ColumnReference newCR = new ColumnReference(rc.getName(), exposedName, cm);
1:3e77b5a:             if ( (oldCR != null ) && (oldCR.getMergeTableID() != ColumnReference.MERGE_UNKNOWN ) )
1:3e77b5a:             {
1:3e77b5a:                 newCR.setMergeTableID( oldCR.getMergeTableID() );
1:3e77b5a:             }
1:2f8e6fb:             
1:e1f49ca:             ResultColumn newRc = new ResultColumn(
1:e1f49ca:                     rc.getName(),
1:3e77b5a:                     newCR,
1:e1f49ca:                     cm);
1:e1f49ca: 
1:e1f49ca:             rcList.addResultColumn(newRc);
1:eac0369: 		}
1:eac0369: 		return rcList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push expressions down to the first ResultSetNode which can do expression
1:eac0369: 	 * evaluation and has the same referenced table map.
1:eac0369: 	 * RESOLVE - This means only pushing down single table expressions to
1:eac0369: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
1:eac0369: 	 * the optimizer will work, we can push down join clauses.
1:eac0369: 	 *
1:eac0369: 	 * @param predicateList	The PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void pushExpressions(PredicateList predicateList)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(predicateList != null,
1:eac0369: 							 "predicateList is expected to be non-null");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the exposed name for this table, which is the name that can
1:eac0369: 	 * be used to refer to it in the rest of the query.
1:eac0369: 	 *
1:eac0369: 	 * @return	The exposed name of this table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     String getExposedName() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.THROWASSERT(
1:eac0369: 							 "getExposedName() not expected to be called for " + this.getClass().getName());
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the table # for this table.  
1:eac0369: 	 *
1:eac0369: 	 * @param tableNumber	The table # for this table.
1:eac0369: 	 */
1:3bb140c:     void setTableNumber(int tableNumber)
1:eac0369: 	{
1:eac0369: 		/* This should only be called if the tableNumber has not been set yet */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(this.tableNumber == -1, 
1:eac0369: 							 "tableNumber is not expected to be already set");
1:eac0369: 		this.tableNumber = tableNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a TableName node representing this FromTable.
1:eac0369: 	 * Expect this to be overridden (and used) by subclasses
1:eac0369: 	 * that may set correlationName to null.
1:eac0369: 	 *
1:eac0369: 	 * @return a TableName node representing this FromTable.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     TableName getTableName()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (correlationName == null) return null;
1:eac0369: 
1:eac0369: 		if (corrTableName == null)
1:eac0369: 		{
1:eac0369: 			corrTableName = makeTableName(null, correlationName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return corrTableName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the (query block) level (0-based) for this FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @param level		The query block level for this FromTable.
1:eac0369: 	 */
1:3bb140c:     void setLevel(int level)
1:eac0369: 	{
1:eac0369: 		this.level = level;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the (query block) level (0-based) for this FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The query block level for this FromTable.
1:eac0369: 	 */
1:3bb140c:     int getLevel()
1:eac0369: 	{
1:eac0369: 		return level;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement (query block) level (0-based) for this FromTable.
1:eac0369: 	 * This is useful when flattening a subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param decrement	The amount to decrement by.
1:eac0369: 	 */
1:eac0369: 	void decrementLevel(int decrement)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			/* NOTE: level doesn't get propagated 
1:eac0369: 			 * to nodes generated after binding.
1:eac0369: 			 */
1:eac0369: 			if (level < decrement && level != 0)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"level (" + level +
1:eac0369: 					") expected to be >= decrement (" +
1:eac0369: 					decrement + ")");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		/* NOTE: level doesn't get propagated 
1:eac0369: 		 * to nodes generated after binding.
1:eac0369: 		 */
1:eac0369: 		if (level > 0)
1:eac0369: 		{
1:eac0369: 			level -= decrement;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	* Get a schema descriptor for the given table.
1:eac0369: 	* Uses this.corrTableName.
1:eac0369: 	*
1:eac0369: 	* @return Schema Descriptor
1:eac0369: 	*
1:eac0369: 	* @exception	StandardException	throws on schema name
1:eac0369: 	*						that doesn't exist	
1:eac0369: 	*/
1:3bb140c:     SchemaDescriptor getSchemaDescriptor() throws StandardException
1:eac0369: 	{
1:eac0369: 		return getSchemaDescriptor(corrTableName);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	* Get a schema descriptor for the given table.
1:eac0369: 	*
1:6b50965: 	* @param	tableName the table name
1:eac0369: 	*
1:eac0369: 	* @return Schema Descriptor
1:eac0369: 	*
1:eac0369: 	* @exception	StandardException	throws on schema name
1:eac0369: 	*						that doesn't exist	
1:eac0369: 	*/
1:3bb140c:     SchemaDescriptor getSchemaDescriptor(TableName tableName)
1:3bb140c:             throws StandardException
1:eac0369: 	{
1:eac0369: 		SchemaDescriptor		sd;
1:eac0369: 
1:eac0369: 		sd = getSchemaDescriptor(tableName.getSchemaName());
1:eac0369: 
1:eac0369: 		return sd;
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not the specified name is an exposed name in
1:eac0369: 	 * the current query block.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The specified name to search for as an exposed name.
1:eac0369: 	 * @param schemaName	Schema name, if non-null.
1:eac0369: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:eac0369: 	 *						names or match on table id.
1:eac0369: 	 *
1:eac0369: 	 * @return The FromTable, if any, with the exposed name.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Only FromBaseTables have schema names
1:eac0369: 		if (schemaName != null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (getExposedName().equals(name))
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this FromTable a JoinNode which can be flattened into 
1:eac0369: 	 * the parents FromList.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not this FromTable can be flattened.
1:eac0369: 	 */
1:3bb140c:     boolean isFlattenableJoinNode()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * no LOJ reordering for this FromTable.
1:eac0369: 	 */
1:3bb140c:     boolean LOJ_reorderable(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Transform any Outer Join into an Inner Join where applicable.
1:eac0369: 	 * (Based on the existence of a null intolerant
1:eac0369: 	 * predicate on the inner table.)
1:eac0369: 	 *
1:eac0369: 	 * @param predicateTree	The predicate tree for the query block
1:eac0369: 	 *
1:eac0369: 	 * @return The new tree top (OuterJoin or InnerJoin).
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Fill the referencedTableMap with this ResultSetNode.
1:eac0369: 	 *
1:eac0369: 	 * @param passedMap	The table map to fill in.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void fillInReferencedTableMap(JBitSet passedMap)
1:eac0369: 	{
1:eac0369: 		if (tableNumber != -1)
1:eac0369: 		{
1:eac0369: 			passedMap.set(tableNumber);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark as updatable all the columns in the result column list of this
1:eac0369: 	 * FromBaseTable that match the columns in the given update column list.
1:eac0369: 	 * If the list is null, it means all the columns are updatable.
1:eac0369: 	 *
1:b153b24:      * @param updateColumns     A list representing the columns
1:eac0369: 	 *							that can be updated.
1:eac0369: 	 */
1:3bb140c:     protected void markUpdatableByCursor(List<String> updateColumns)
1:eac0369: 	{
1:11f7ee3: 		getResultColumns().markUpdatableByCursor(updateColumns);
1:eac0369: 	}
1:eac0369: 
1:b9e22cc:  	/**
1:b9e22cc: 	 * Return true if some columns in this table are updatable.
1:b9e22cc: 	 *
1:b9e22cc: 	 * This method is used in deciding whether updateRow() or
1:b9e22cc: 	 * insertRow() are allowable.
1:b9e22cc: 	 *
1:b9e22cc: 	 * @return true if some columns in this table are updatable.
1:b9e22cc: 	 */
1:b9e22cc: 	boolean columnsAreUpdatable()
1:b9e22cc: 	{
1:b9e22cc: 		return getResultColumns().columnsAreUpdatable();
1:b9e22cc: 	}
1:b9e22cc: 
1:eac0369: 	/**
1:eac0369: 	 * Flatten this FromTable into the outer query block. The steps in
1:eac0369: 	 * flattening are:
1:eac0369: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
1:eac0369: 	 *	   at generate().
1:eac0369: 	 *	o  Append the wherePredicates to the outer list.
1:eac0369: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
1:eac0369: 	 *
1:eac0369: 	 * @param rcl				The RCL from the outer query
1:eac0369: 	 * @param outerPList	PredicateList to append wherePredicates to.
1:eac0369: 	 * @param sql				The SubqueryList from the outer query
1:eac0369: 	 * @param gbl				The group by list, if any
1:2e7e8f6:      * @param havingClause      The HAVING clause, if any
1:eac0369: 	 *
1:eac0369: 	 * @return FromList		The fromList from the underlying SelectNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     FromList flatten(ResultColumnList rcl,
1:eac0369: 							PredicateList outerPList,
1:eac0369: 							SubqueryList sql,
1:2e7e8f6:                             GroupByList gbl,
1:2e7e8f6:                             ValueNode havingClause)
1:eac0369: 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				 "flatten() not expected to be called for " + this);
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize any subqueries that haven't been optimized any where
1:eac0369: 	 * else.  This is useful for a RowResultSetNode as a derived table
1:eac0369: 	 * because it doesn't get optimized otherwise.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell the given RowOrdering about any columns that are constant
1:eac0369: 	 * due to their being equality comparisons with constant expressions.
1:eac0369: 	 */
1:eac0369: 	protected void tellRowOrderingAboutConstantColumns(
1:eac0369: 										RowOrdering	rowOrdering,
1:eac0369: 										OptimizablePredicateList predList)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Tell the RowOrdering about columns that are equal to constant
1:eac0369: 		** expressions.
1:eac0369: 		*/
1:eac0369: 		if (predList != null)
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < predList.size(); i++)
1:eac0369: 			{
1:eac0369: 				Predicate pred = (Predicate) predList.getOptPredicate(i);
1:eac0369: 
1:eac0369: 				/* Is it an = comparison with a constant expression? */
1:eac0369: 				if (pred.equalsComparisonWithConstantExpression(this))
1:eac0369: 				{
1:eac0369: 					/* Get the column being compared to the constant */
1:eac0369: 					ColumnReference cr = pred.getRelop().getColumnOperand(this);
1:eac0369: 
1:eac0369: 					if (cr != null)
1:eac0369: 					{
1:eac0369: 						/* Tell RowOrdering that the column is always ordered */
1:eac0369: 						rowOrdering.columnAlwaysOrdered(this, cr.getColumnNumber());
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 	
1:3bb140c:     boolean needsSpecialRCLBinding()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:b6c6e95: 	/**
1:b6c6e95: 	 * Sets the original or unbound table name for this FromTable.  
1:eac0369: 	 * 
1:b6c6e95: 	 * @param tableName the unbound table name
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     void setOrigTableName(TableName tableName)
1:eac0369: 	{
1:b6c6e95: 		this.origTableName = tableName;
1:eac0369: 	}
1:eac0369: 	
1:b6c6e95: 	/**
1:b6c6e95: 	 * Gets the original or unbound table name for this FromTable.  
1:b6c6e95: 	 * The tableName field can be changed due to synonym resolution.
1:b6c6e95: 	 * Use this method to retrieve the actual unbound tablename.
1:eac0369: 	 * 
1:b6c6e95: 	 * @return TableName the original or unbound tablename
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     TableName getOrigTableName()
1:b6c6e95: 	{
1:b6c6e95: 		return this.origTableName;
1:eac0369: 	}
1:69f8afa: 
1:3e77b5a:     /** set the merge table id */
1:3e77b5a:     void    setMergeTableID( int mergeTableID ) { _mergeTableID = mergeTableID; }
1:3e77b5a: 
1:3e77b5a:     /** get the merge table id */
1:3e77b5a:     int     getMergeTableID() { return _mergeTableID; }
1:3e77b5a: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (origTableName != null) {
1:69f8afa:             origTableName = (TableName) origTableName.accept(v);
1:69f8afa:         }
1:69f8afa: 
1:69f8afa:         if (corrTableName != null) {
1:69f8afa:             corrTableName = (TableName) corrTableName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 Set of object-&gt;trulyTheBestAccessPath mappings used to keep track
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** for resolving column references in MERGE statements in tough cases*/
1:     private int _mergeTableID = ColumnReference.MERGE_UNKNOWN;
/////////////////////////////////////////////////////////////////////////
1: 
1:             ColumnReference newCR = new ColumnReference(rc.getName(), exposedName, cm);
1:             if ( (oldCR != null ) && (oldCR.getMergeTableID() != ColumnReference.MERGE_UNKNOWN ) )
1:             {
1:                 newCR.setMergeTableID( oldCR.getMergeTableID() );
1:             }
1:                     newCR,
/////////////////////////////////////////////////////////////////////////
1:     /** set the merge table id */
1:     void    setMergeTableID( int mergeTableID ) { _mergeTableID = mergeTableID; }
1: 
1:     /** get the merge table id */
1:     int     getMergeTableID() { return _mergeTableID; }
1: 
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimateCost(singleScanCost);
1: 		optimizeSubqueries(getDataDictionary(), getCostEstimate().rowCount());
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimateCost(bestPath.getCostEstimate());
/////////////////////////////////////////////////////////////////////////
1: 		if (getCandidateFinalCostEstimate() != null)
1:         {
1: 			return getCandidateFinalCostEstimate();
1:         }
1:         {
1: 			setCandidateFinalCostEstimate( getCostEstimate() );
1:         }
1:         {
1: 			setCandidateFinalCostEstimate( getTrulyTheBestAccessPath().getCostEstimate() );
1:         }
1: 		return getCandidateFinalCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : getResultColumns()) {
/////////////////////////////////////////////////////////////////////////
1:             FormatableBitSet refCols = getResultColumns().getReferencedFormatableBitSet(cursorTargetTable(), true, false);
/////////////////////////////////////////////////////////////////////////
1:                     ResultColumn rc = getResultColumns().elementAt(i);
/////////////////////////////////////////////////////////////////////////
1: 		return getResultColumns().size();
/////////////////////////////////////////////////////////////////////////
1: 		if (getCostEstimate() == null)
1: 			setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		return getCostEstimate();
/////////////////////////////////////////////////////////////////////////
1: 		if ( getScratchCostEstimate() == null )
1: 			setScratchCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		return getScratchCostEstimate();
1: 	protected void setCostEstimateCost(CostEstimate newCostEstimate)
1: 		getCostEstimate().setCost(newCostEstimate);
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( newCostEstimate );
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().markUpdatableByCursor(updateColumns);
commit:2f8e6fb
/////////////////////////////////////////////////////////////////////////
1:             ColumnReference oldCR = rc.getReference();
1:             if ( oldCR != null )
1:             {
1:                 // for UPDATE actions of MERGE statement, preserve the original table name.
1:                 // this is necessary in order to correctly bind the column list of the dummy SELECT.
1:                 if ( oldCR.getMergeTableID() != ColumnReference.MERGE_UNKNOWN )
1:                 {
1:                     exposedName = oldCR.getQualifiedTableName();
1:                 }
1:             }
1:             
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
1:             if ( optimizerTracingIsOn() ) { getOptimizerTracer().traceConsideringJoinStrategy( ap.getJoinStrategy(), tableNumber ); }
/////////////////////////////////////////////////////////////////////////
1:         if (optimizerTracingIsOn()) {
1:             getOptimizerTracer().traceRememberingJoinStrategy(
1:             if (optimizerTracingIsOn()) {
1:                 getOptimizerTracer().traceRememberingBestAccessPathSubstring(
1:             if (optimizerTracingIsOn()) {
1:                 getOptimizerTracer().
/////////////////////////////////////////////////////////////////////////
1:             if (optimizerTracingIsOn()) {
1:                 getOptimizerTracer().traceRememberingBestUnknownAccessPathSubstring(
/////////////////////////////////////////////////////////////////////////
1:         if ( optimizerTracingIsOn() )
1:         { getOptimizerTracer().traceRememberingBestAccessPath( bestPath, tableNumber, planType ); }
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0: 			costEstimate = getOptimizerFactory().getCostEstimate();
/////////////////////////////////////////////////////////////////////////
0: 			scratchCostEstimate = getOptimizerFactory().getCostEstimate();
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private HashMap<Object,AccessPathImpl> bestPlanMap;
/////////////////////////////////////////////////////////////////////////
1: 				bestPlanMap = new HashMap<Object,AccessPathImpl>();
1: 				ap = bestPlanMap.get(planKey);
/////////////////////////////////////////////////////////////////////////
1: 		ap = bestPlanMap.get(planKey);
commit:9858a84
/////////////////////////////////////////////////////////////////////////
0:             if ( optimizer.tracingIsOn() ) { optimizer.tracer().traceConsideringJoinStrategy( ap.getJoinStrategy(), tableNumber ); }
/////////////////////////////////////////////////////////////////////////
0:         if ( optimizer.tracingIsOn() )
0:         { optimizer.tracer().traceRememberingJoinStrategy( getCurrentAccessPath().getJoinStrategy(), tableNumber ); }
0:             if ( optimizer.tracingIsOn() )
0:             { optimizer.tracer().traceRememberingBestAccessPathSubstring( ap, tableNumber ); }
0:             if ( optimizer.tracingIsOn() )
0:             { optimizer.tracer().traceRememberingBestSortAvoidanceAccessPathSubstring( ap, tableNumber ); }
/////////////////////////////////////////////////////////////////////////
0:             if ( optimizer.tracingIsOn() )
0:             { optimizer.tracer().traceRememberingBestUnknownAccessPathSubstring( ap, tableNumber ); }
/////////////////////////////////////////////////////////////////////////
0:         if ( bestPath.getOptimizer().tracingIsOn() )
0:         { bestPath.getOptimizer().tracer().traceRememberingBestAccessPath( bestPath, tableNumber, planType ); }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b9e22cc
/////////////////////////////////////////////////////////////////////////
1:  	/**
1: 	 * Return true if some columns in this table are updatable.
1: 	 *
1: 	 * This method is used in deciding whether updateRow() or
1: 	 * insertRow() are allowable.
1: 	 *
1: 	 * @return true if some columns in this table are updatable.
1: 	 */
1: 	boolean columnsAreUpdatable()
1: 	{
1: 		return getResultColumns().columnsAreUpdatable();
1: 	}
1: 
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (origTableName != null) {
1:             origTableName = (TableName) origTableName.accept(v);
1:         }
1: 
1:         if (corrTableName != null) {
1:             corrTableName = (TableName) corrTableName.accept(v);
1:         }
1:     }
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:b153b24
/////////////////////////////////////////////////////////////////////////
1:      * @param updateColumns     A list representing the columns
commit:38b5979
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 	protected void markUpdatableByCursor(List updateColumns)
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if any columns containing large objects (BLOBs or CLOBs) are
1:      * referenced in this table.
1:      *
1:      * @return {@code true} if at least one large object column is referenced,
1:      * {@code false} otherwise
1:      */
1:     public boolean hasLargeObjectColumns() {
0:         for (int i = 0; i < resultColumns.size(); i++) {
0:             ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
1:             if (rc.isReferenced()) {
1:                 DataTypeDescriptor type = rc.getType();
1:                 if (type != null && type.getTypeId().isLOBTypeId()) {
1:                     return true;
1:                 }
1:             }
1:         }
1:         return false;
1:     }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:         Enumeration<?> e = tableProperties.keys();
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (ResultColumn rc : resultColumns) {
/////////////////////////////////////////////////////////////////////////
0:                     ResultColumn rc = resultColumns.elementAt(i);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final ContextManager cm = getContextManager();
1:         ResultColumnList rcList = new ResultColumnList(cm);
1:         for (ResultColumn rc : inputRcl)
1:             ResultColumn newRc = new ResultColumn(
1:                     rc.getName(),
0:                     new ColumnReference(rc.getName(), exposedName, cm),
1:                     cm);
1: 
1:             rcList.addResultColumn(newRc);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a table in a FROM list.
1:      *
1:      * @param correlationName   The correlation name
1:      * @param tableProperties   Properties list associated with the table
1:      * @param cm                The context manager
1:      */
1:     FromTable(String correlationName,
1:               Properties tableProperties,
1:               ContextManager cm)
1:     {
1:         super(cm);
1:         this.correlationName = correlationName;
1:         this.tableProperties = tableProperties;
1:         tableNumber = -1;
1:         bestPlanMap = null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         Optimizer opt = ap.getOptimizer();
0:         if (opt.tracingIsOn()) {
0:             opt.tracer().traceRememberingJoinStrategy(
1:                 getCurrentAccessPath().getJoinStrategy(), tableNumber);
1:         }
0:             if (opt.tracingIsOn()) {
0:                 opt.tracer().traceRememberingBestAccessPathSubstring(
1:                     ap, tableNumber);
1:             }
0:             if (opt.tracingIsOn()) {
0:                 opt.tracer().
1:                     traceRememberingBestSortAvoidanceAccessPathSubstring(
1:                         ap, tableNumber);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (opt.tracingIsOn()) {
0:                 opt.tracer().traceRememberingBestUnknownAccessPathSubstring(
1:                     ap, tableNumber);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (bestPlanMap.isEmpty()) {
1:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getFinalCostEstimate()
/////////////////////////////////////////////////////////////////////////
1:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     ResultColumnList getResultColumnsForList(TableName allTableName,
/////////////////////////////////////////////////////////////////////////
0:         ResultColumnList rcList = new ResultColumnList((getContextManager()));
/////////////////////////////////////////////////////////////////////////
0:             valueNode = new ColumnReference(columnName,
0:             resultColumn =
0:                 new ResultColumn(columnName, valueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     String getExposedName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void setTableNumber(int tableNumber)
/////////////////////////////////////////////////////////////////////////
1:     TableName getTableName()
/////////////////////////////////////////////////////////////////////////
1:     void setLevel(int level)
/////////////////////////////////////////////////////////////////////////
1:     int getLevel()
/////////////////////////////////////////////////////////////////////////
1:     SchemaDescriptor getSchemaDescriptor() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     SchemaDescriptor getSchemaDescriptor(TableName tableName)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     boolean isFlattenableJoinNode()
/////////////////////////////////////////////////////////////////////////
1:     boolean LOJ_reorderable(int numTables)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void fillInReferencedTableMap(JBitSet passedMap)
/////////////////////////////////////////////////////////////////////////
1:     protected void markUpdatableByCursor(List<String> updateColumns)
/////////////////////////////////////////////////////////////////////////
1:     FromList flatten(ResultColumnList rcl,
/////////////////////////////////////////////////////////////////////////
1:     boolean needsSpecialRCLBinding()
/////////////////////////////////////////////////////////////////////////
1:     void setOrigTableName(TableName tableName)
/////////////////////////////////////////////////////////////////////////
1:     TableName getOrigTableName()
commit:afe6225
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Properties;
0: import java.util.Vector;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1: import org.apache.derby.impl.sql.execute.HashScanResultSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2e7e8f6
/////////////////////////////////////////////////////////////////////////
1:      * @param havingClause      The HAVING clause, if any
/////////////////////////////////////////////////////////////////////////
1:                             GroupByList gbl,
1:                             ValueNode havingClause)
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0eb98f1
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * No-op in FromTable.
1: 	 * 
1: 	 * @see HalfOuterJoinNode#isJoinColumnForRightOuterJoin
1: 	 */
0: 	public void isJoinColumnForRightOuterJoin(ResultColumn rc) 
1: 	{
1: 		return;
1: 	}
author:Lily Wei
-------------------------------------------------------------------------------
commit:eb7e251
/////////////////////////////////////////////////////////////////////////
1: 					loadFactor = Float.parseFloat(value);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ba1b7ec
/////////////////////////////////////////////////////////////////////////
1:                     DataTypeDescriptor expressionType = rc.getExpression().getTypeServices();
commit:acdff3c
/////////////////////////////////////////////////////////////////////////
0: 	 Set of object->trulyTheBestAccessPath mappings used to keep track
1: 	 with respect to a specific outer query or ancestor node.  In the case
1: 	 of an outer query, the object key will be an instance of OptimizerImpl.
1: 	 In the case of an ancestor node, the object key will be that node itself.
1: 	 Each ancestor node or outer query could potentially have a different
1: 	 idea of what this Optimizable's "best access path" is, so we have to
1: 	 keep track of them all.
0: 	private HashMap bestPlanMap;
1: 
1: 	/** Operations that can be performed on bestPlanMap. */
1: 	protected static final short REMOVE_PLAN = 0;
1: 	protected static final short ADD_PLAN = 1;
1: 	protected static final short LOAD_PLAN = 2;
/////////////////////////////////////////////////////////////////////////
1: 		bestPlanMap = null;
/////////////////////////////////////////////////////////////////////////
1: 		updateBestPlanMap(ADD_PLAN, this);
/////////////////////////////////////////////////////////////////////////
1: 	/** @see Optimizable#updateBestPlanMap */
1: 	public void updateBestPlanMap(short action,
1: 		if (action == REMOVE_PLAN)
1: 		{
1: 			if (bestPlanMap != null)
1: 			{
1: 				bestPlanMap.remove(planKey);
0: 				if (bestPlanMap.size() == 0)
0: 					bestPlanMap = null;
1: 			}
1: 
1: 			return;
1: 		}
1: 
1: 		if (action == ADD_PLAN)
1: 			// If the bestPlanMap already exists, search for an
1: 			if (bestPlanMap == null)
0: 				bestPlanMap = new HashMap();
0: 				ap = (AccessPathImpl)bestPlanMap.get(planKey);
/////////////////////////////////////////////////////////////////////////
1: 			bestPlanMap.put(planKey, ap);
/////////////////////////////////////////////////////////////////////////
1: 		if (bestPlanMap == null)
0: 		ap = (AccessPathImpl)bestPlanMap.get(planKey);
/////////////////////////////////////////////////////////////////////////
1: 		// path later.  See Optimizable.updateBestPlanMap().
1: 		// the required call to updateBestPlanMap() will be
1: 			updateBestPlanMap(ADD_PLAN, optimizer);
1: 				updateBestPlanMap(ADD_PLAN, optimizer);
commit:03eae1d
/////////////////////////////////////////////////////////////////////////
1: abstract class FromTable extends ResultSetNode implements Optimizable
/////////////////////////////////////////////////////////////////////////
commit:df5ffc8
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 Set of optimizer->trulyTheBestAccessPath mappings used to keep track
1: 	 of which of this Optimizable's "trulyTheBestAccessPath" was the best
0: 	 with respect to a specific outer query; the outer query is represented
0: 	 by an instance of Optimizer.  Each outer query could potentially have
0: 	 a different idea of what this Optimizable's "best access path" is, so
0: 	 we have to keep track of them all.
1: 	*/
0: 	private HashMap optimizerToBestPlanMap;
commit:c83a399
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
0: 	public ResultColumnList getResultColumnsForList(TableName allTableName,
/////////////////////////////////////////////////////////////////////////
1:         TableName        toCompare;
1: 		/* If allTableName is non-null, then we must check to see if it matches
1: 
1:         if(correlationName == null)
1:            toCompare = tableName;
1:         else {
1:             if(allTableName != null)
1:                 toCompare = makeTableName(allTableName.getSchemaName(),correlationName);
1:             else
1:                 toCompare = makeTableName(null,correlationName);
1:         }
1: 
1:         if ( allTableName != null &&
1:              ! allTableName.equals(toCompare))
1:         {
1:             return null;
1:         }
commit:df9af89
/////////////////////////////////////////////////////////////////////////
0: 		Enumeration e = tableProperties.keys();
1: 		while (e.hasMoreElements())
1: 			String key = (String) e.nextElement();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.FromTable
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.JoinStrategy;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.execute.HashScanResultSet;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * A FromTable represents a table in the FROM clause of a DML statement.
1:  * It can be either a base table, a subquery or a project restrict.
1:  *
1:  * @see FromBaseTable
1:  * @see FromSubquery
1:  * @see ProjectRestrictNode
1:  *
0:  * @author Jeff Lichtman
1:  */
0: public abstract class FromTable extends ResultSetNode implements Optimizable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	Properties		tableProperties;
1: 	String		correlationName;
1: 	TableName	corrTableName;
1: 	int			tableNumber;
1: 	/* (Query block) level is 0-based. */
1: 	/* RESOLVE - View resolution will have to update the level within
1: 	 * the view tree.
1: 	 */
1: 	int			level;
1: 	// hashKeyColumns are 0-based column #s within the row returned by the store for hash scans
1: 	int[]			hashKeyColumns;
1: 
1: 	// overrides for hash join
1: 	int				initialCapacity = HashScanResultSet.DEFAULT_INITIAL_CAPACITY;
1: 	float			loadFactor = HashScanResultSet.DEFAULT_LOADFACTOR;
1: 	int				maxCapacity = HashScanResultSet.DEFAULT_MAX_CAPACITY;
1: 
1: 	AccessPathImpl			currentAccessPath;
1: 	AccessPathImpl			bestAccessPath;
1: 	AccessPathImpl			bestSortAvoidancePath;
1: 	AccessPathImpl			trulyTheBestAccessPath;
1: 
1: 	private int		joinStrategyNumber;
1: 
1: 	protected String userSpecifiedJoinStrategy;
1: 
1: 	protected CostEstimate bestCostEstimate;
1: 
0: 	private FormatableBitSet refCols;
1: 
1: 	private boolean considerSortAvoidancePath;
1: 
0:   //this flag tells you if all the columns from this table are projected using * from it.
0:   //Used by replication enabled databases where the target-only view failure is detected
0:   //using this boolean
0:   private boolean allColumnsProjected;
1: 
0:   public boolean areAllColumnsProjected() {
0:     return allColumnsProjected;
1:   }
1: 
0:   public void setAllColumnsProjected(boolean flag) {
0:     allColumnsProjected = flag;
1:   }
1: 
1: 	/**
0: 	 * Initializer for a table in a FROM list.
1: 	 *
0: 	 * @param correlationName	The correlation name
0: 	 * @param tableProperties	Properties list associated with the table
1: 	 */
0: 	public void init(Object correlationName, Object tableProperties)
1: 	{
0: 		this.correlationName = (String) correlationName;
0: 		this.tableProperties = (Properties) tableProperties;
0: 		tableNumber = -1;
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 *
1: 	 */
1: 	public CostEstimate optimizeIt(
1: 							Optimizer optimizer,
1: 							OptimizablePredicateList predList,
1: 							CostEstimate outerCost,
1: 							RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		CostEstimate singleScanCost = estimateCost(predList,
1: 												(ConglomerateDescriptor) null,
1: 												outerCost,
1: 												optimizer,
1: 												rowOrdering);
1: 
1: 		/* Make sure there is a cost estimate to set */
1: 		getCostEstimate(optimizer);
1: 
0: 		setCostEstimate(singleScanCost);
1: 
1: 		/* Optimize any subqueries that need to get optimized and
1: 		 * are not optimized any where else.  (Like those
1: 		 * in a RowResultSetNode.)
1: 		 */
0: 		optimizeSubqueries(getDataDictionary(), costEstimate.rowCount());
1: 
1: 		/*
1: 		** Get the cost of this result set in the context of the whole plan.
1: 		*/
1: 		getCurrentAccessPath().
1: 			getJoinStrategy().
1: 				estimateCost(
1: 							this,
1: 							predList,
1: 							(ConglomerateDescriptor) null,
1: 							outerCost,
1: 							optimizer,
1: 							getCostEstimate()
1: 							);
1: 
1: 		optimizer.considerCost(this, predList, getCostEstimate(), outerCost);
1: 
1: 		return getCostEstimate();
1: 	}
1: 
1: 	/**
1: 		@see Optimizable#nextAccessPath
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public boolean nextAccessPath(Optimizer optimizer,
1: 									OptimizablePredicateList predList,
1: 									RowOrdering rowOrdering)
1: 					throws StandardException
1: 	{
1: 		int	numStrat = optimizer.getNumberOfJoinStrategies();
1: 		boolean found = false;
1: 		AccessPath ap = getCurrentAccessPath();
1: 
1: 		/*
1: 		** Most Optimizables have no ordering, so tell the rowOrdering that
1: 		** this Optimizable is unordered, if appropriate.
1: 		*/
1: 		if (userSpecifiedJoinStrategy != null)
1: 		{
1: 			/*
1: 			** User specified a join strategy, so we should look at only one
1: 			** strategy.  If there is a current strategy, we have already
1: 			** looked at the strategy, so go back to null.
1: 			*/
1: 			if (ap.getJoinStrategy() != null)
1: 			{
1:   				ap.setJoinStrategy((JoinStrategy) null);
1: 
1: 				found = false;
1: 			}
1: 			else
1: 			{
1: 				ap.setJoinStrategy(
1: 								optimizer.getJoinStrategy(userSpecifiedJoinStrategy));
1: 
1: 				if (ap.getJoinStrategy() == null)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_STRATEGY, 
1: 						userSpecifiedJoinStrategy, getBaseTableName());
1: 				}
1: 
1: 				found = true;
1: 			}
1: 		}
1: 		else if (joinStrategyNumber < numStrat)
1: 		{
1: 			/* Step through the join strategies. */
1: 			ap.setJoinStrategy(optimizer.getJoinStrategy(joinStrategyNumber));
1: 
1: 			joinStrategyNumber++;
1: 
1: 			found = true;
1: 
0: 			optimizer.trace(Optimizer.CONSIDERING_JOIN_STRATEGY, tableNumber, 0, 0.0,
0: 							ap.getJoinStrategy());
1: 		}
1: 
1: 		/*
1: 		** Tell the RowOrdering about columns that are equal to constant
1: 		** expressions.
1: 		*/
1: 		tellRowOrderingAboutConstantColumns(rowOrdering, predList);
1: 
1: 		return found;
1: 	}
1: 
1: 	/** Most Optimizables cannot be ordered */
1: 	protected boolean canBeOrdered()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** @see Optimizable#getCurrentAccessPath */
1: 	public AccessPath getCurrentAccessPath()
1: 	{
1: 		return currentAccessPath;
1: 	}
1: 
1: 	/** @see Optimizable#getBestAccessPath */
1: 	public AccessPath getBestAccessPath()
1: 	{
1: 		return bestAccessPath;
1: 	}
1: 
1: 	/** @see Optimizable#getBestSortAvoidancePath */
1: 	public AccessPath getBestSortAvoidancePath()
1: 	{
1: 		return bestSortAvoidancePath;
1: 	}
1: 
1: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1: 	public AccessPath getTrulyTheBestAccessPath()
1: 	{
1: 		return trulyTheBestAccessPath;
1: 	}
1: 
1: 	/** @see Optimizable#rememberSortAvoidancePath */
1: 	public void rememberSortAvoidancePath()
1: 	{
1: 		considerSortAvoidancePath = true;
1: 	}
1: 
1: 	/** @see Optimizable#considerSortAvoidancePath */
1: 	public boolean considerSortAvoidancePath()
1: 	{
1: 		return considerSortAvoidancePath;
1: 	}
1: 
1: 	/** @see Optimizable#rememberJoinStrategyAsBest */
1: 	public void rememberJoinStrategyAsBest(AccessPath ap)
1: 	{
0: 		Optimizer optimizer = ap.getOptimizer();
1: 
1: 		ap.setJoinStrategy(getCurrentAccessPath().getJoinStrategy());
1: 
0: 		optimizer.trace(Optimizer.REMEMBERING_JOIN_STRATEGY, tableNumber, 0, 0.0,
0: 			  getCurrentAccessPath().getJoinStrategy());
1: 
1: 		if (ap == bestAccessPath)
1: 		{
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
1: 		}
1: 		else if (ap == bestSortAvoidancePath)
1: 		{
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_SORT_AVOIDANCE_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
1: 		}
1: 		else
1: 		{
1: 			/* We currently get here when optimizing an outer join.
1: 			 * (Problem predates optimizer trace change.)
1: 			 * RESOLVE - fix this at some point.
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"unknown access path type");
1: 			}
1: 			 */
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_UNKNOWN_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#getTableDescriptor */
1: 	public TableDescriptor getTableDescriptor()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getTableDescriptor() not expected to be called for "
1: 				+ getClass().toString());
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 		throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#pullOptPredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void pullOptPredicates(
1: 								OptimizablePredicateList optimizablePredicates)
1: 				throws StandardException
1: 	{
1: 		/* For most types of Optimizable, do nothing */
1: 		return;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1: 	{
1: 		/* For most types of Optimizable, do nothing */
1: 		return this;
1: 	}
1: 
1: 	/** 
1: 	 * @see Optimizable#isCoveringIndex
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** @see Optimizable#getProperties */
1: 	public Properties getProperties()
1: 	{
1: 		return tableProperties;
1: 	}
1: 
1: 	/** @see Optimizable#setProperties */
1: 	public void setProperties(Properties tableProperties)
1: 	{
1: 		this.tableProperties = tableProperties;
1: 	}
1: 
1: 	/** @see Optimizable#verifyProperties 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void verifyProperties(DataDictionary dDictionary)
1: 		throws StandardException
1: 	{
1: 		if (tableProperties == null)
1: 		{
1: 			return;
1: 		}
1: 		/* Check here for:
1: 		 *		invalid properties key
1: 		 *		invalid joinStrategy
1: 		 *		invalid value for hashInitialCapacity
1: 		 *		invalid value for hashLoadFactor
1: 		 *		invalid value for hashMaxCapacity
1: 		 */
0: 		boolean indexSpecified = false;
0: 		Enumeration enum = tableProperties.keys();
0: 		while (enum.hasMoreElements())
1: 		{
0: 			String key = (String) enum.nextElement();
1: 			String value = (String) tableProperties.get(key);
1: 
1: 			if (key.equals("joinStrategy"))
1: 			{
1: 				userSpecifiedJoinStrategy = StringUtil.SQLToUpperCase(value);
1: 			}
1: 			else if (key.equals("hashInitialCapacity"))
1: 			{
1: 				initialCapacity = getIntProperty(value, key);
1: 
1: 				// verify that the specified value is valid
1: 				if (initialCapacity <= 0)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_INITIAL_CAPACITY, 
1: 							String.valueOf(initialCapacity));
1: 				}
1: 			}
1: 			else if (key.equals("hashLoadFactor"))
1: 			{
1: 				try
1: 				{
0: 					loadFactor = Float.valueOf(value).floatValue();
1: 				}
1: 				catch (NumberFormatException nfe)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
1: 							value, key);
1: 				}
1: 
1: 				// verify that the specified value is valid
1: 				if (loadFactor <= 0.0 || loadFactor > 1.0)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_LOAD_FACTOR, 
1: 							value);
1: 				}
1: 			}
1: 			else if (key.equals("hashMaxCapacity"))
1: 			{
1: 				maxCapacity = getIntProperty(value, key);
1: 
1: 				// verify that the specified value is valid
1: 				if (maxCapacity <= 0)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_MAX_CAPACITY, 
1: 							String.valueOf(maxCapacity));
1: 				}
1: 			}
1: 			else
1: 			{
1: 				// No other "legal" values at this time
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_TABLE_PROPERTY, key,
1: 					"joinStrategy");
1: 			}
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#getName 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public String getName() throws StandardException
1: 	{
1: 		return getExposedName();
1: 	}
1: 
1: 	/** @see Optimizable#getBaseTableName */
1: 	public String getBaseTableName()
1: 	{
1: 		return "";
1: 	}
1: 
1: 	/** @see Optimizable#convertAbsoluteToRelativeColumnPosition */
1: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition)
1: 	{
1: 		return absolutePosition;
1: 	}
1: 
1: 	/** @see Optimizable#rememberAsBest */
0: 	public void rememberAsBest(int planType) throws StandardException
1: 	{
1: 		AccessPath bestPath = null;
1: 
1: 		switch (planType)
1: 		{
1: 		  case Optimizer.NORMAL_PLAN:
1: 			bestPath = getBestAccessPath();
1: 			break;
1: 
1: 		  case Optimizer.SORT_AVOIDANCE_PLAN:
1: 			bestPath = getBestSortAvoidancePath();
1: 			break;
1: 
1: 		  default:
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Invalid plan type " + planType);
1: 			}
1: 		}
1: 
1: 		getTrulyTheBestAccessPath().copy(bestPath);
1: 		 
1: 		/* also store the name of the access path; i.e index name/constraint
1: 		 * name if we're using an index to access the base table.
1: 		 */
0: 		ConglomerateDescriptor cd =	bestPath.getConglomerateDescriptor();
1: 
1: 		if (isBaseTable())
1: 		{
1: 			DataDictionary dd = getDataDictionary();
1: 			TableDescriptor td = getTableDescriptor();
1: 			getTrulyTheBestAccessPath().initializeAccessPathName(dd, td);
1: 		}
1: 
0: 		setCostEstimate(bestPath.getCostEstimate());
1: 
0: 		bestPath.getOptimizer().trace(Optimizer.REMEMBERING_BEST_ACCESS_PATH,
0: 							tableNumber, planType, 0.0, bestPath);
1: 	}
1: 
1: 	/** @see Optimizable#startOptimizing */
1: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
1: 	{
1: 		resetJoinStrategies(optimizer);
1: 
1: 		considerSortAvoidancePath = false;
1: 
1: 		/*
1: 		** If there are costs associated with the best and sort access
1: 		** paths, set them to their maximum values, so that any legitimate
1: 		** access path will look cheaper.
1: 		*/
1: 		CostEstimate ce = getBestAccessPath().getCostEstimate();
1: 
1: 		if (ce != null)
1: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
1: 
1: 		ce = getBestSortAvoidancePath().getCostEstimate();
1: 
1: 		if (ce != null)
1: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
1: 
1: 		if (! canBeOrdered())
1: 			rowOrdering.addUnorderedOptimizable(this);
1: 	}
1: 
1: 	/**
1: 	 * This method is called when this table is placed in a potential
1: 	 * join order, or when a new conglomerate is being considered.
1: 	 * Set this join strategy number to 0 to indicate that
1: 	 * no join strategy has been considered for this table yet.
1: 	 */
1: 	protected void resetJoinStrategies(Optimizer optimizer)
1: 	{
1: 		joinStrategyNumber = 0;
1: 		getCurrentAccessPath().setJoinStrategy((JoinStrategy) null);
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#estimateCost
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1: 									ConglomerateDescriptor cd,
1: 									CostEstimate outerCost,
1: 									Optimizer optimizer,
1: 									RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 			 "estimateCost() not expected to be called for " + 
1: 			 getClass().toString());
1: 		}	
1: 
1: 		return null;
1: 	}
1: 
1: 	/** @see Optimizable#isBaseTable */
1: 	public boolean isBaseTable()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** @see Optimizable#isMaterializable 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean isMaterializable()
1: 		throws StandardException
1: 	{
1: 		/* Derived tables are materializable
1: 		 * iff they are not correlated with an outer query block.
1: 		 */
1: 
1: 		HasCorrelatedCRsVisitor visitor = new HasCorrelatedCRsVisitor();
1: 		accept(visitor);
1: 		return !(visitor.hasCorrelatedCRs());
1: 	}
1: 
1: 	/** @see Optimizable#supportsMultipleInstantiations */
1: 	public boolean supportsMultipleInstantiations()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/** @see Optimizable#getTableNumber */
1: 	public int getTableNumber()
1: 	{
1: 		return tableNumber;
1: 	}
1: 
1: 	/** @see Optimizable#hasTableNumber */
1: 	public boolean hasTableNumber()
1: 	{
1: 		return tableNumber >= 0;
1: 	}
1: 
1: 	/** @see Optimizable#forUpdate */
1: 	public boolean forUpdate()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** @see Optimizable#initialCapacity */
1: 	public int initialCapacity()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("Not expected to be called");
1: 		}
1: 
1: 		return 0;
1: 	}
1: 
1: 	/** @see Optimizable#loadFactor */
1: 	public float loadFactor()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("Not expected to be called");
1: 		}
1: 
1: 		return 0.0F;
1: 	}
1: 
1: 	/** @see Optimizable#maxCapacity */
0: 	public int maxCapacity()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("Not expected to be called");
1: 		}
1: 
1: 		return 0;
1: 	}
1: 
1: 	/** @see Optimizable#hashKeyColumns */
1: 	public int[] hashKeyColumns()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(hashKeyColumns != null,
1: 				"hashKeyColumns expected to be non-null");
1: 		}
1: 
1: 		return hashKeyColumns;
1: 	}
1: 
1: 	/** @see Optimizable#setHashKeyColumns */
1: 	public void setHashKeyColumns(int[] columnNumbers)
1: 	{
1: 		hashKeyColumns = columnNumbers;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#feasibleJoinStrategy
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1: 										Optimizer optimizer)
1: 					throws StandardException
1: 	{
1: 		return getCurrentAccessPath().getJoinStrategy().
1: 								feasible(this, predList, optimizer);
1: 	}
1: 
1: 	/**
0: 	 * @see Optimizable#memoryUsage
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public double memoryUsage(double rowCount) throws StandardException
1: 	{
0: 		double retval = 0.0;
1: 		
0: 		// workaround for a jikes bug. Can't directly reference a 
0: 		// double with a value of 12.0 in this classfile. 
0: 		double baseIndexUsage = 1.0;
1: 
1: 		/*
1: 		** Don't enforce maximum memory usage for a user-specified join
1: 		** strategy.
1: 		*/
0: 		if (userSpecifiedJoinStrategy == null)
1: 		{
0: 			FormatableBitSet refCols = getRefCols();
0: 			double perRowUsage = 0.0;
1: 
1: 			/* Add up the memory usage for each referenced column */
1: 			for (int i = 0; i < refCols.size(); i++)
1: 			{
1: 				if (refCols.isSet(i))
1: 				{
0: 					ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
0:                     DataTypeDescriptor expressionType = rc.getExpressionType();
1:                     if( expressionType != null)
1:                         perRowUsage += expressionType.estimatedMemoryUsage();
1: 				}
1: 			}
1: 
1: 			/*
1: 			** If the proposed conglomerate is a non-covering index, add the 
1: 			** size of the RowLocation column to the total.
1: 			**
1: 			** NOTE: We don't have a DataTypeDescriptor representing a
1: 			** REF column here, so just add a constant here.
1: 			*/
1: 			ConglomerateDescriptor cd =
1: 					getCurrentAccessPath().getConglomerateDescriptor();
1: 			if (cd != null)
1: 			{
1: 				if (cd.isIndex() && ( ! isCoveringIndex(cd) ) )
1: 				{
0: 					perRowUsage += ( baseIndexUsage + 11 );
1: 				}
1: 			}
1: 
1: 			/*
0: 			** Let the join strategy tell us how much memory it uses.
0: 			** Some use memory and some don't.
1: 			*/
0: 			retval = getCurrentAccessPath().getJoinStrategy().
0: 											memoryUsage(perRowUsage, rowCount);
1: 		}
1: 
0: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#legalJoinOrder
1: 	 */
1: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
1: 	{
1: 		// Only those subclasses with dependencies need to override this.
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#getNumColumnsReturned
1: 	 */
1: 	public int getNumColumnsReturned()
1: 	{
0: 		return resultColumns.size();
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#isTargetTable
1: 	 */
1: 	public boolean isTargetTable()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#isOneRowScan
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean isOneRowScan() 
1: 		throws StandardException
1: 	{
1: 		/* We simply return isOneRowResultSet() for all
1: 		 * subclasses except for EXISTS FBT where
1: 		 * the semantics differ between 1 row per probe
1: 		 * and whether or not there can be more than 1
1: 		 * rows that qualify on a scan.
1: 		 */
1: 		return isOneRowResultSet();
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#initAccessPaths
1: 	 */
1: 	public void initAccessPaths(Optimizer optimizer)
1: 	{
1: 		if (currentAccessPath == null)
1: 		{
1: 			currentAccessPath = new AccessPathImpl(optimizer);
1: 		}
1: 		if (bestAccessPath == null)
1: 		{
1: 			bestAccessPath = new AccessPathImpl(optimizer);
1: 		}
1: 		if (bestSortAvoidancePath == null)
1: 		{
1: 			bestSortAvoidancePath = new AccessPathImpl(optimizer);
1: 		}
1: 		if (trulyTheBestAccessPath == null)
1: 		{
1: 			trulyTheBestAccessPath = new AccessPathImpl(optimizer);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#uniqueJoin
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public double uniqueJoin(OptimizablePredicateList predList)
1: 						throws StandardException
1: 	{
1: 		return -1.0;
1: 	}
1: 
0: 	private FormatableBitSet getRefCols()
1: 	{
0: 		if (refCols == null)
0: 			refCols = resultColumns.getReferencedFormatableBitSet(cursorTargetTable(), true, false);
1: 
0: 		return refCols;
1: 	}
1: 
1: 
1: 	/** 
1: 	 * Return the user specified join strategy, if any for this table.
1: 	 *
1: 	 * @return The user specified join strategy, if any for this table.
1: 	 */
1: 	String getUserSpecifiedJoinStrategy()
1: 	{
1: 		if (tableProperties == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		return tableProperties.getProperty("joinStrategy");
1: 	}
1: 
1: 	/**
1: 	 * Is this a table that has a FOR UPDATE
1: 	 * clause.  Overridden by FromBaseTable.
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	protected boolean cursorTargetTable()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	protected CostEstimate getCostEstimate(Optimizer optimizer)
1: 	{
0: 		if (costEstimate == null)
1: 		{
0: 			costEstimate = optimizer.newCostEstimate();
1: 		}
0: 		return costEstimate;
1: 	}
1: 
1: 	/*
1: 	** This gets a cost estimate for doing scratch calculations.  Typically,
1: 	** it will hold the estimated cost of a conglomerate.  If the optimizer
1: 	** decides the scratch cost is lower than the best cost estimate so far,
1: 	** it will copy the scratch cost to the non-scratch cost estimate,
1: 	** which is allocated above.
1: 	*/
1: 	protected CostEstimate getScratchCostEstimate(Optimizer optimizer)
1: 	{
0: 		if (scratchCostEstimate == null)
1: 		{
0: 			scratchCostEstimate = optimizer.newCostEstimate();
1: 		}
1: 
0: 		return scratchCostEstimate;
1: 	}
1: 
1: 	/**
1: 	 * Set the cost estimate in this node to the given cost estimate.
1: 	 */
0: 	protected void setCostEstimate(CostEstimate newCostEstimate)
1: 	{
0: 		costEstimate = getCostEstimate();
1: 
0: 		costEstimate.setCost(newCostEstimate);
1: 	}
1: 
1: 	/**
1: 	 * Assign the cost estimate in this node to the given cost estimate.
1: 	 */
1: 	protected void assignCostEstimate(CostEstimate newCostEstimate)
1: 	{
0: 		costEstimate = newCostEstimate;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "correlation Name: " + correlationName + "\n" +
1: 				(corrTableName != null ?
1: 					corrTableName.toString() : "null") + "\n" +
1: 				"tableNumber " + tableNumber + "\n" +
1: 				"level " + level + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return a ResultColumnList with all of the columns in this table.
1: 	 * (Used in expanding '*'s.)
1: 	 * NOTE: Since this method is for expanding a "*" in the SELECT list,
1: 	 * ResultColumn.expression will be a ColumnReference.
1: 	 *
1: 	 * @param allTableName		The qualifier on the "*"
1: 	 *
1: 	 * @return ResultColumnList	List of result columns from this table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultColumnList getResultColumnsForList(String allTableName,
1: 												ResultColumnList inputRcl,
1: 												TableName tableName)
1: 			throws StandardException
1: 	{
0: 		ResultColumnList rcList = null;
0: 		ResultColumn	 resultColumn;
0: 		ValueNode		 valueNode;
0: 		String			 columnName;
1: 		TableName		 exposedName;
1: 
0: 		/* If allTableName is non-null, then we must check to see if it matches 
1: 		 * our exposed name.
1: 		 */
0: 		if (allTableName != null && ! allTableName.equals(getExposedName()))
1: 		{
1: 			return null;
1: 		}
1: 
1: 		/* Cache exposed name for this table.
1: 		 * The exposed name becomes the qualifier for each column
1: 		 * in the expanded list.
1: 		 */
1: 		if (correlationName == null)
1: 		{
1: 			exposedName = tableName;
1: 		}
1: 		else
1: 		{
1: 			exposedName = makeTableName(null, correlationName);
1: 		}
1: 
0: 		rcList = (ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
0: 										getContextManager());
1: 
1: 		/* Build a new result column list based off of resultColumns.
1: 		 * NOTE: This method will capture any column renaming due to 
1: 		 * a derived column list.
1: 		 */
0: 		int inputSize = inputRcl.size();
0: 		for (int index = 0; index < inputSize; index++)
1: 		{
0: 			// Build a ResultColumn/ColumnReference pair for the column //
0: 			columnName = ((ResultColumn) inputRcl.elementAt(index)).getName();
0: 			valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											columnName,
0: 											exposedName,
0: 											getContextManager());
0: 			resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											columnName,
0: 											valueNode,
0: 											getContextManager());
1: 
0: 			// Build the ResultColumnList to return //
0: 			rcList.addResultColumn(resultColumn);
1: 		}
1: 		return rcList;
1: 	}
1: 
1: 	/**
1: 	 * Push expressions down to the first ResultSetNode which can do expression
1: 	 * evaluation and has the same referenced table map.
1: 	 * RESOLVE - This means only pushing down single table expressions to
1: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
1: 	 * the optimizer will work, we can push down join clauses.
1: 	 *
1: 	 * @param predicateList	The PredicateList.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void pushExpressions(PredicateList predicateList)
1: 						throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) 
1: 		{
1: 			SanityManager.ASSERT(predicateList != null,
1: 							 "predicateList is expected to be non-null");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the exposed name for this table, which is the name that can
1: 	 * be used to refer to it in the rest of the query.
1: 	 *
1: 	 * @return	The exposed name of this table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public String getExposedName() throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.THROWASSERT(
1: 							 "getExposedName() not expected to be called for " + this.getClass().getName());
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Set the table # for this table.  
1: 	 *
1: 	 * @param tableNumber	The table # for this table.
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setTableNumber(int tableNumber)
1: 	{
1: 		/* This should only be called if the tableNumber has not been set yet */
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(this.tableNumber == -1, 
1: 							 "tableNumber is not expected to be already set");
1: 		this.tableNumber = tableNumber;
1: 	}
1: 
1: 	/**
1: 	 * Return a TableName node representing this FromTable.
1: 	 * Expect this to be overridden (and used) by subclasses
1: 	 * that may set correlationName to null.
1: 	 *
1: 	 * @return a TableName node representing this FromTable.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public TableName getTableName()
1: 		throws StandardException
1: 	{
1: 		if (correlationName == null) return null;
1: 
1: 		if (corrTableName == null)
1: 		{
1: 			corrTableName = makeTableName(null, correlationName);
1: 		}
1: 
1: 		return corrTableName;
1: 	}
1: 
1: 	/**
1: 	 * Set the (query block) level (0-based) for this FromTable.
1: 	 *
1: 	 * @param level		The query block level for this FromTable.
1: 	 *
0: 	 * @return Nothing
1: 	 */
0: 	public void setLevel(int level)
1: 	{
1: 		this.level = level;
1: 	}
1: 
1: 	/**
1: 	 * Get the (query block) level (0-based) for this FromTable.
1: 	 *
1: 	 * @return int	The query block level for this FromTable.
1: 	 */
0: 	public int getLevel()
1: 	{
1: 		return level;
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for this FromTable.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			/* NOTE: level doesn't get propagated 
1: 			 * to nodes generated after binding.
1: 			 */
1: 			if (level < decrement && level != 0)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"level (" + level +
1: 					") expected to be >= decrement (" +
1: 					decrement + ")");
1: 			}
1: 		}
1: 		/* NOTE: level doesn't get propagated 
1: 		 * to nodes generated after binding.
1: 		 */
1: 		if (level > 0)
1: 		{
1: 			level -= decrement;
1: 		}
1: 	}
1: 
1: 	/**
1: 	* Get a schema descriptor for the given table.
1: 	* Uses this.corrTableName.
1: 	*
1: 	* @return Schema Descriptor
1: 	*
1: 	* @exception	StandardException	throws on schema name
1: 	*						that doesn't exist	
1: 	*/
0: 	public SchemaDescriptor getSchemaDescriptor() throws StandardException
1: 	{
1: 		return getSchemaDescriptor(corrTableName);
1: 	}	
1: 
1: 	/**
1: 	* Get a schema descriptor for the given table.
1: 	*
0: 	* @param	TableName the table name
1: 	*
1: 	* @return Schema Descriptor
1: 	*
1: 	* @exception	StandardException	throws on schema name
1: 	*						that doesn't exist	
1: 	*/
0: 	public SchemaDescriptor getSchemaDescriptor(TableName tableName) throws StandardException
1: 	{
1: 		SchemaDescriptor		sd;
1: 
1: 		sd = getSchemaDescriptor(tableName.getSchemaName());
1: 
1: 		return sd;
1: 	}	
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		// Only FromBaseTables have schema names
1: 		if (schemaName != null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		if (getExposedName().equals(name))
1: 		{
1: 			return this;
1: 		}
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Is this FromTable a JoinNode which can be flattened into 
1: 	 * the parents FromList.
1: 	 *
1: 	 * @return boolean		Whether or not this FromTable can be flattened.
1: 	 */
0: 	public boolean isFlattenableJoinNode()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * no LOJ reordering for this FromTable.
1: 	 */
0: 	public boolean LOJ_reorderable(int numTables)
1: 		throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Transform any Outer Join into an Inner Join where applicable.
1: 	 * (Based on the existence of a null intolerant
1: 	 * predicate on the inner table.)
1: 	 *
1: 	 * @param predicateTree	The predicate tree for the query block
1: 	 *
1: 	 * @return The new tree top (OuterJoin or InnerJoin).
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
1: 		throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Fill the referencedTableMap with this ResultSetNode.
1: 	 *
1: 	 * @param passedMap	The table map to fill in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void fillInReferencedTableMap(JBitSet passedMap)
1: 	{
1: 		if (tableNumber != -1)
1: 		{
1: 			passedMap.set(tableNumber);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark as updatable all the columns in the result column list of this
1: 	 * FromBaseTable that match the columns in the given update column list.
1: 	 * If the list is null, it means all the columns are updatable.
1: 	 *
0: 	 * @param updateColumns		A Vector representing the columns
1: 	 *							that can be updated.
1: 	 */
0: 	protected void markUpdatableByCursor(Vector updateColumns)
1: 	{
0: 		resultColumns.markUpdatableByCursor(updateColumns);
1: 	}
1: 
1: 	/**
1: 	 * Flatten this FromTable into the outer query block. The steps in
1: 	 * flattening are:
1: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
1: 	 *	   at generate().
1: 	 *	o  Append the wherePredicates to the outer list.
1: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
1: 	 *
1: 	 * @param rcl				The RCL from the outer query
1: 	 * @param outerPList	PredicateList to append wherePredicates to.
1: 	 * @param sql				The SubqueryList from the outer query
1: 	 * @param gbl				The group by list, if any
1: 	 *
1: 	 * @return FromList		The fromList from the underlying SelectNode.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public FromList flatten(ResultColumnList rcl,
1: 							PredicateList outerPList,
1: 							SubqueryList sql,
0: 							GroupByList gbl)
1: 
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				 "flatten() not expected to be called for " + this);
1: 		}
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Optimize any subqueries that haven't been optimized any where
1: 	 * else.  This is useful for a RowResultSetNode as a derived table
1: 	 * because it doesn't get optimized otherwise.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
1: 		throws StandardException
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Tell the given RowOrdering about any columns that are constant
1: 	 * due to their being equality comparisons with constant expressions.
1: 	 */
1: 	protected void tellRowOrderingAboutConstantColumns(
1: 										RowOrdering	rowOrdering,
1: 										OptimizablePredicateList predList)
1: 	{
1: 		/*
1: 		** Tell the RowOrdering about columns that are equal to constant
1: 		** expressions.
1: 		*/
1: 		if (predList != null)
1: 		{
1: 			for (int i = 0; i < predList.size(); i++)
1: 			{
1: 				Predicate pred = (Predicate) predList.getOptPredicate(i);
1: 
1: 				/* Is it an = comparison with a constant expression? */
1: 				if (pred.equalsComparisonWithConstantExpression(this))
1: 				{
1: 					/* Get the column being compared to the constant */
1: 					ColumnReference cr = pred.getRelop().getColumnOperand(this);
1: 
1: 					if (cr != null)
1: 					{
1: 						/* Tell RowOrdering that the column is always ordered */
1: 						rowOrdering.columnAlwaysOrdered(this, cr.getColumnNumber());
1: 					}
1: 				}
1: 			}
1: 		}
1: 		
1: 	}
1: 	
0: 	public boolean needsSpecialRCLBinding()
1: 	{
1: 		return false;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:5b12563
/////////////////////////////////////////////////////////////////////////
1:                     perRowUsage +=  12.0 ;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b6c6e95
/////////////////////////////////////////////////////////////////////////
1: 	/** the original unbound table name */
1: 	protected TableName origTableName;
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
1: 	/**
1: 	 * Sets the original or unbound table name for this FromTable.  
0: 	 * 
1: 	 * @param tableName the unbound table name
0: 	 *
0: 	 */
0: 	public void setOrigTableName(TableName tableName) 
1: 	{
1: 		this.origTableName = tableName;
1: 	}
0: 	
1: 	/**
1: 	 * Gets the original or unbound table name for this FromTable.  
1: 	 * The tableName field can be changed due to synonym resolution.
1: 	 * Use this method to retrieve the actual unbound tablename.
0: 	 * 
1: 	 * @return TableName the original or unbound tablename
0: 	 *
0: 	 */
0: 	public TableName getOrigTableName() 
1: 	{
1: 		return this.origTableName;
1: 	}
commit:1cd0a14
/////////////////////////////////////////////////////////////////////////
1:     /** @see Optimizable#memoryUsageOK */
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1:     private double perRowUsage = -1;
0:     
/////////////////////////////////////////////////////////////////////////
1: 	public int maxCapacity( JoinStrategy joinStrategy, int maxMemoryPerTable) throws StandardException
1:         return joinStrategy.maxCapacity( maxCapacity, maxMemoryPerTable, getPerRowUsage());
1:     private double getPerRowUsage() throws StandardException
1:     {
1:         if( perRowUsage < 0)
1:         {
1:             // Do not use getRefCols() because the cached refCols may no longer be valid.
0:             FormatableBitSet refCols = resultColumns.getReferencedFormatableBitSet(cursorTargetTable(), true, false);
1:             perRowUsage = 0.0;
0: 
0:             /* Add up the memory usage for each referenced column */
0:             for (int i = 0; i < refCols.size(); i++)
1:             {
0:                 if (refCols.isSet(i))
1:                 {
0:                     ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
0:                     DataTypeDescriptor expressionType = rc.getExpressionType();
0:                     if( expressionType != null)
0:                         perRowUsage += expressionType.estimatedMemoryUsage();
0:                 }
0:             }
0: 
0:             /*
0:             ** If the proposed conglomerate is a non-covering index, add the 
0:             ** size of the RowLocation column to the total.
0:             **
0:             ** NOTE: We don't have a DataTypeDescriptor representing a
0:             ** REF column here, so just add a constant here.
0:             */
0:             ConglomerateDescriptor cd =
0:               getCurrentAccessPath().getConglomerateDescriptor();
0:             if (cd != null)
1:             {
0:                 if (cd.isIndex() && ( ! isCoveringIndex(cd) ) )
1:                 {
0:                     // workaround for a jikes bug. Can't directly reference a 
0:                     // double with a value of 12.0 in this classfile. 
0:                     double baseIndexUsage = 1.0;
0:                     perRowUsage += ( baseIndexUsage + 11 );
0:                 }
0:             }
0:         }
1:         return perRowUsage ;
1:     } // end of getPerRowUsage
0: 
/////////////////////////////////////////////////////////////////////////
0:     /** @see Optimizable#considerMemoryUsageOK */
1:     public boolean memoryUsageOK( double rowCount, int maxMemoryPerTable)
1: 			throws StandardException
0:     {
1:         if( userSpecifiedJoinStrategy != null)
1:             return true;
1:         int intRowCount = (rowCount > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) rowCount;
1:         return intRowCount <= maxCapacity( getCurrentAccessPath().getJoinStrategy(), maxMemoryPerTable);
0:     }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	* @param	tableName the table name
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Get this table's correlation name, if any.
0: 	 */
1: 	public	String	getCorrelationName() { return correlationName; }
0: 
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		// It's possible that a call to optimize the left/right will cause
1: 		// a new "truly the best" plan to be stored in the underlying base
1: 		// tables.  If that happens and then we decide to skip that plan
1: 		// (which we might do if the call to "considerCost()" below decides
1: 		// the current path is infeasible or not the best) we need to be
1: 		// able to revert back to the "truly the best" plans that we had
1: 		// saved before we got here.  So with this next call we save the
1: 		// current plans using "this" node as the key.  If needed, we'll
1: 		// then make the call to revert the plans in OptimizerImpl's
1: 		// getNextDecoratedPermutation() method.
0: 		addOrLoadBestPlanMapping(true, this);
0: 
/////////////////////////////////////////////////////////////////////////
1: 		Object planKey) throws StandardException
1: 		AccessPath bestPath = getTrulyTheBestAccessPath();
1: 			// If we get to this method before ever optimizing this node, then
1: 			// there will be no best path--so there's nothing to do.
1: 			if (bestPath == null)
1: 				return;
0: 
1: 			// AccessPath for the received key and use that if we can.
0: 				ap = (AccessPathImpl)optimizerToBestPlanMap.get(planKey);
1: 			// If we don't already have an AccessPath for the key,
1: 			// create a new one.  If the key is an OptimizerImpl then
1: 			// we might as well pass it in to the AccessPath constructor;
1: 			// otherwise just pass null.
0: 			{
1: 				if (planKey instanceof Optimizer)
1: 					ap = new AccessPathImpl((Optimizer)planKey);
1: 				else
1: 					ap = new AccessPathImpl((Optimizer)null);
0: 			}
1: 			ap.copy(bestPath);
0: 			optimizerToBestPlanMap.put(planKey, ap);
/////////////////////////////////////////////////////////////////////////
1: 		// This can happen if the key is an OptimizerImpl that tried some
1: 		// join order for which there was no valid plan.
0: 		ap = (AccessPathImpl)optimizerToBestPlanMap.get(planKey);
1: 		// It might be the case that there is no plan stored for
1: 		// the key, in which case there's nothing to load.
1: 		if ((ap == null) || (ap.getCostEstimate() == null))
1: 		bestPath.copy(ap);
/////////////////////////////////////////////////////////////////////////
1: 		// Note: Since this call descends all the way down to base
1: 		// tables, it can be relatively expensive when we have deeply
1: 		// nested subqueries.  So in an attempt to save some work, we
1: 		// skip the call if this node is a ProjectRestrictNode whose
1: 		// child is an Optimizable--in that case the ProjectRestrictNode
1: 		// will in turn call "rememberAsBest" on its child and so
0: 		// the required call to addOrLoadBestPlanMapping() will be
1: 		// made at that time.  If we did it here, too, then we would
1: 		// just end up duplicating the work.
1: 		if (!(this instanceof ProjectRestrictNode))
0: 			addOrLoadBestPlanMapping(true, optimizer);
1: 		else
0: 		{
1: 			ProjectRestrictNode prn = (ProjectRestrictNode)this;
1: 			if (!(prn.getChildResult() instanceof Optimizable))
0: 				addOrLoadBestPlanMapping(true, optimizer);
0: 		}
commit:ab10884
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Get the final CostEstimate for this FromTable.
0: 	 *
1: 	 * @return	The final CostEstimate for this FromTable, which is
1: 	 *  the costEstimate of trulyTheBestAccessPath if there is one.
1: 	 *  If there's no trulyTheBestAccessPath for this node, then
1: 	 *  we just return the value stored in costEstimate as a default.
0: 	 */
0: 	public CostEstimate getFinalCostEstimate()
1: 		throws StandardException
0: 	{
1: 		// If we already found it, just return it.
0: 		if (finalCostEstimate != null)
0: 			return finalCostEstimate;
0: 
1: 		if (getTrulyTheBestAccessPath() == null)
0: 			finalCostEstimate = costEstimate;
1: 		else
0: 			finalCostEstimate = getTrulyTheBestAccessPath().getCostEstimate();
0: 
0: 		return finalCostEstimate;
0: 	}
0: 
commit:62d4560
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0: 	// Set of optimizer->trulyTheBestAccessPath mappings used to keep track
0: 	// of which of this Optimizable's "trulyTheBestAccessPath" was the best
0: 	// with respect to a specific outer query; the outer query is represented
0: 	// by an instance of Optimizer.  Each outer query could potentially have
0: 	// a different idea of what this Optimizable's "best access path" is, so
0: 	// we have to keep track of them all.
0: 	HashMap optimizerToBestPlanMap;
0: 
/////////////////////////////////////////////////////////////////////////
0: 		optimizerToBestPlanMap = null;
/////////////////////////////////////////////////////////////////////////
0: 	/** @see Optimizable#addOrLoadBestPlanMapping */
0: 	public void addOrLoadBestPlanMapping(boolean doAdd,
0: 		Optimizer optimizer) throws StandardException
0: 	{
1: 		AccessPathImpl ap = null;
0: 		if (doAdd)
0: 		{
0: 			// If the optimizerToBestPlanMap already exists, search for an
0: 			// AccessPath for the target optimizer and use that if we can.
0: 			if (optimizerToBestPlanMap == null)
0: 				optimizerToBestPlanMap = new HashMap();
1: 			else
0: 				ap = (AccessPathImpl)optimizerToBestPlanMap.get(optimizer);
0: 
0: 			// If we don't already have an AccessPath for the optimizer,
0: 			// create a new one.
1: 			if (ap == null)
0: 				ap = new AccessPathImpl(optimizer);
0: 
0: 			ap.copy(getTrulyTheBestAccessPath());
0: 			optimizerToBestPlanMap.put(optimizer, ap);
1: 			return;
0: 		}
0: 
1: 		// If we get here, we want to load the best plan from our map
1: 		// into this Optimizable's trulyTheBestAccessPath field.
0: 
1: 		// If we don't have any plans saved, then there's nothing to load.
0: 		// This can happen if the optimizer tried some join order for which
0: 		// there was no valid plan.
0: 		if (optimizerToBestPlanMap == null)
1: 			return;
0: 
0: 		ap = (AccessPathImpl)optimizerToBestPlanMap.get(optimizer);
0: 
0: 		// Again, might be the case that there is no plan stored for
0: 		// the optimizer if no valid plans have been discovered for
0: 		// that optimizer's current join order.
1: 		if (ap == null)
1: 			return;
0: 
1: 		// We found a best plan in our map, so load it into this Optimizable's
1: 		// trulyTheBestAccessPath field.
0: 		getTrulyTheBestAccessPath().copy(ap);
1: 		return;
0: 	}
0: 
1: 	public void rememberAsBest(int planType, Optimizer optimizer)
1: 		throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 
1: 		// Since we just set trulyTheBestAccessPath for the current
1: 		// join order of the received optimizer, take note of what
1: 		// that path is, in case we need to "revert" back to this
0: 		// path later.  See Optimizable.addOrLoadBestPlanMapping().
0: 		addOrLoadBestPlanMapping(true, optimizer);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.JoinStrategy;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.execute.HashScanResultSet;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * A FromTable represents a table in the FROM clause of a DML statement.
0:  * It can be either a base table, a subquery or a project restrict.
0:  *
0:  * @see FromBaseTable
0:  * @see FromSubquery
0:  * @see ProjectRestrictNode
0:  *
0:  * @author Jeff Lichtman
0:  */
0: public abstract class FromTable extends ResultSetNode implements Optimizable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	Properties		tableProperties;
0: 	String		correlationName;
0: 	TableName	corrTableName;
0: 	int			tableNumber;
0: 	/* (Query block) level is 0-based. */
0: 	/* RESOLVE - View resolution will have to update the level within
0: 	 * the view tree.
0: 	 */
0: 	int			level;
0: 	// hashKeyColumns are 0-based column #s within the row returned by the store for hash scans
0: 	int[]			hashKeyColumns;
0: 
0: 	// overrides for hash join
0: 	int				initialCapacity = HashScanResultSet.DEFAULT_INITIAL_CAPACITY;
0: 	float			loadFactor = HashScanResultSet.DEFAULT_LOADFACTOR;
0: 	int				maxCapacity = HashScanResultSet.DEFAULT_MAX_CAPACITY;
0: 
0: 	AccessPathImpl			currentAccessPath;
0: 	AccessPathImpl			bestAccessPath;
0: 	AccessPathImpl			bestSortAvoidancePath;
0: 	AccessPathImpl			trulyTheBestAccessPath;
0: 
0: 	private int		joinStrategyNumber;
0: 
0: 	protected String userSpecifiedJoinStrategy;
0: 
0: 	protected CostEstimate bestCostEstimate;
0: 
0: 	private FormatableBitSet refCols;
0: 
0: 	private boolean considerSortAvoidancePath;
0: 
0:   //this flag tells you if all the columns from this table are projected using * from it.
0:   //Used by replication enabled databases where the target-only view failure is detected
0:   //using this boolean
0:   private boolean allColumnsProjected;
0: 
0:   public boolean areAllColumnsProjected() {
0:     return allColumnsProjected;
0:   }
0: 
0:   public void setAllColumnsProjected(boolean flag) {
0:     allColumnsProjected = flag;
0:   }
0: 
0: 	/**
0: 	 * Initializer for a table in a FROM list.
0: 	 *
0: 	 * @param correlationName	The correlation name
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 */
0: 	public void init(Object correlationName, Object tableProperties)
0: 	{
0: 		this.correlationName = (String) correlationName;
0: 		this.tableProperties = (Properties) tableProperties;
0: 		tableNumber = -1;
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 *
0: 	 */
0: 	public CostEstimate optimizeIt(
0: 							Optimizer optimizer,
0: 							OptimizablePredicateList predList,
0: 							CostEstimate outerCost,
0: 							RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		CostEstimate singleScanCost = estimateCost(predList,
0: 												(ConglomerateDescriptor) null,
0: 												outerCost,
0: 												optimizer,
0: 												rowOrdering);
0: 
0: 		/* Make sure there is a cost estimate to set */
0: 		getCostEstimate(optimizer);
0: 
0: 		setCostEstimate(singleScanCost);
0: 
0: 		/* Optimize any subqueries that need to get optimized and
0: 		 * are not optimized any where else.  (Like those
0: 		 * in a RowResultSetNode.)
0: 		 */
0: 		optimizeSubqueries(getDataDictionary(), costEstimate.rowCount());
0: 
0: 		/*
0: 		** Get the cost of this result set in the context of the whole plan.
0: 		*/
0: 		getCurrentAccessPath().
0: 			getJoinStrategy().
0: 				estimateCost(
0: 							this,
0: 							predList,
0: 							(ConglomerateDescriptor) null,
0: 							outerCost,
0: 							optimizer,
0: 							getCostEstimate()
0: 							);
0: 
0: 		optimizer.considerCost(this, predList, getCostEstimate(), outerCost);
0: 
0: 		return getCostEstimate();
0: 	}
0: 
0: 	/**
0: 		@see Optimizable#nextAccessPath
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public boolean nextAccessPath(Optimizer optimizer,
0: 									OptimizablePredicateList predList,
0: 									RowOrdering rowOrdering)
0: 					throws StandardException
0: 	{
0: 		int	numStrat = optimizer.getNumberOfJoinStrategies();
0: 		boolean found = false;
0: 		AccessPath ap = getCurrentAccessPath();
0: 
0: 		/*
0: 		** Most Optimizables have no ordering, so tell the rowOrdering that
0: 		** this Optimizable is unordered, if appropriate.
0: 		*/
0: 		if (userSpecifiedJoinStrategy != null)
0: 		{
0: 			/*
0: 			** User specified a join strategy, so we should look at only one
0: 			** strategy.  If there is a current strategy, we have already
0: 			** looked at the strategy, so go back to null.
0: 			*/
0: 			if (ap.getJoinStrategy() != null)
0: 			{
0:   				ap.setJoinStrategy((JoinStrategy) null);
0: 
0: 				found = false;
0: 			}
0: 			else
0: 			{
0: 				ap.setJoinStrategy(
0: 								optimizer.getJoinStrategy(userSpecifiedJoinStrategy));
0: 
0: 				if (ap.getJoinStrategy() == null)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_STRATEGY, 
0: 						userSpecifiedJoinStrategy, getBaseTableName());
0: 				}
0: 
0: 				found = true;
0: 			}
0: 		}
0: 		else if (joinStrategyNumber < numStrat)
0: 		{
0: 			/* Step through the join strategies. */
0: 			ap.setJoinStrategy(optimizer.getJoinStrategy(joinStrategyNumber));
0: 
0: 			joinStrategyNumber++;
0: 
0: 			found = true;
0: 
0: 			optimizer.trace(Optimizer.CONSIDERING_JOIN_STRATEGY, tableNumber, 0, 0.0,
0: 							ap.getJoinStrategy());
0: 		}
0: 
0: 		/*
0: 		** Tell the RowOrdering about columns that are equal to constant
0: 		** expressions.
0: 		*/
0: 		tellRowOrderingAboutConstantColumns(rowOrdering, predList);
0: 
0: 		return found;
0: 	}
0: 
0: 	/** Most Optimizables cannot be ordered */
0: 	protected boolean canBeOrdered()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** @see Optimizable#getCurrentAccessPath */
0: 	public AccessPath getCurrentAccessPath()
0: 	{
0: 		return currentAccessPath;
0: 	}
0: 
0: 	/** @see Optimizable#getBestAccessPath */
0: 	public AccessPath getBestAccessPath()
0: 	{
0: 		return bestAccessPath;
0: 	}
0: 
0: 	/** @see Optimizable#getBestSortAvoidancePath */
0: 	public AccessPath getBestSortAvoidancePath()
0: 	{
0: 		return bestSortAvoidancePath;
0: 	}
0: 
0: 	/** @see Optimizable#getTrulyTheBestAccessPath */
0: 	public AccessPath getTrulyTheBestAccessPath()
0: 	{
0: 		return trulyTheBestAccessPath;
0: 	}
0: 
0: 	/** @see Optimizable#rememberSortAvoidancePath */
0: 	public void rememberSortAvoidancePath()
0: 	{
0: 		considerSortAvoidancePath = true;
0: 	}
0: 
0: 	/** @see Optimizable#considerSortAvoidancePath */
0: 	public boolean considerSortAvoidancePath()
0: 	{
0: 		return considerSortAvoidancePath;
0: 	}
0: 
0: 	/** @see Optimizable#rememberJoinStrategyAsBest */
0: 	public void rememberJoinStrategyAsBest(AccessPath ap)
0: 	{
0: 		Optimizer optimizer = ap.getOptimizer();
0: 
0: 		ap.setJoinStrategy(getCurrentAccessPath().getJoinStrategy());
0: 
0: 		optimizer.trace(Optimizer.REMEMBERING_JOIN_STRATEGY, tableNumber, 0, 0.0,
0: 			  getCurrentAccessPath().getJoinStrategy());
0: 
0: 		if (ap == bestAccessPath)
0: 		{
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
0: 		}
0: 		else if (ap == bestSortAvoidancePath)
0: 		{
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_SORT_AVOIDANCE_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
0: 		}
0: 		else
0: 		{
0: 			/* We currently get here when optimizing an outer join.
0: 			 * (Problem predates optimizer trace change.)
0: 			 * RESOLVE - fix this at some point.
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"unknown access path type");
0: 			}
0: 			 */
0: 			optimizer.trace(Optimizer.REMEMBERING_BEST_UNKNOWN_ACCESS_PATH_SUBSTRING, 
0: 							tableNumber, 0, 0.0, ap);
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#getTableDescriptor */
0: 	public TableDescriptor getTableDescriptor()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getTableDescriptor() not expected to be called for "
0: 				+ getClass().toString());
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
0: 		throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#pullOptPredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pullOptPredicates(
0: 								OptimizablePredicateList optimizablePredicates)
0: 				throws StandardException
0: 	{
0: 		/* For most types of Optimizable, do nothing */
0: 		return;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
0: 	{
0: 		/* For most types of Optimizable, do nothing */
0: 		return this;
0: 	}
0: 
0: 	/** 
0: 	 * @see Optimizable#isCoveringIndex
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** @see Optimizable#getProperties */
0: 	public Properties getProperties()
0: 	{
0: 		return tableProperties;
0: 	}
0: 
0: 	/** @see Optimizable#setProperties */
0: 	public void setProperties(Properties tableProperties)
0: 	{
0: 		this.tableProperties = tableProperties;
0: 	}
0: 
0: 	/** @see Optimizable#verifyProperties 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyProperties(DataDictionary dDictionary)
0: 		throws StandardException
0: 	{
0: 		if (tableProperties == null)
0: 		{
0: 			return;
0: 		}
0: 		/* Check here for:
0: 		 *		invalid properties key
0: 		 *		invalid joinStrategy
0: 		 *		invalid value for hashInitialCapacity
0: 		 *		invalid value for hashLoadFactor
0: 		 *		invalid value for hashMaxCapacity
0: 		 */
0: 		boolean indexSpecified = false;
0: 		Enumeration enum = tableProperties.keys();
0: 		while (enum.hasMoreElements())
0: 		{
0: 			String key = (String) enum.nextElement();
0: 			String value = (String) tableProperties.get(key);
0: 
0: 			if (key.equals("joinStrategy"))
0: 			{
0: 				userSpecifiedJoinStrategy = StringUtil.SQLToUpperCase(value);
0: 			}
0: 			else if (key.equals("hashInitialCapacity"))
0: 			{
0: 				initialCapacity = getIntProperty(value, key);
0: 
0: 				// verify that the specified value is valid
0: 				if (initialCapacity <= 0)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_INITIAL_CAPACITY, 
0: 							String.valueOf(initialCapacity));
0: 				}
0: 			}
0: 			else if (key.equals("hashLoadFactor"))
0: 			{
0: 				try
0: 				{
0: 					loadFactor = Float.valueOf(value).floatValue();
0: 				}
0: 				catch (NumberFormatException nfe)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
0: 							value, key);
0: 				}
0: 
0: 				// verify that the specified value is valid
0: 				if (loadFactor <= 0.0 || loadFactor > 1.0)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_LOAD_FACTOR, 
0: 							value);
0: 				}
0: 			}
0: 			else if (key.equals("hashMaxCapacity"))
0: 			{
0: 				maxCapacity = getIntProperty(value, key);
0: 
0: 				// verify that the specified value is valid
0: 				if (maxCapacity <= 0)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_HASH_MAX_CAPACITY, 
0: 							String.valueOf(maxCapacity));
0: 				}
0: 			}
0: 			else
0: 			{
0: 				// No other "legal" values at this time
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_TABLE_PROPERTY, key,
0: 					"joinStrategy");
0: 			}
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#getName 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getName() throws StandardException
0: 	{
0: 		return getExposedName();
0: 	}
0: 
0: 	/** @see Optimizable#getBaseTableName */
0: 	public String getBaseTableName()
0: 	{
0: 		return "";
0: 	}
0: 
0: 	/** @see Optimizable#convertAbsoluteToRelativeColumnPosition */
0: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition)
0: 	{
0: 		return absolutePosition;
0: 	}
0: 
0: 	/** @see Optimizable#rememberAsBest */
0: 	public void rememberAsBest(int planType) throws StandardException
0: 	{
0: 		AccessPath bestPath = null;
0: 
0: 		switch (planType)
0: 		{
0: 		  case Optimizer.NORMAL_PLAN:
0: 			bestPath = getBestAccessPath();
0: 			break;
0: 
0: 		  case Optimizer.SORT_AVOIDANCE_PLAN:
0: 			bestPath = getBestSortAvoidancePath();
0: 			break;
0: 
0: 		  default:
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"Invalid plan type " + planType);
0: 			}
0: 		}
0: 
0: 		getTrulyTheBestAccessPath().copy(bestPath);
0: 		 
0: 		/* also store the name of the access path; i.e index name/constraint
0: 		 * name if we're using an index to access the base table.
0: 		 */
0: 		ConglomerateDescriptor cd =	bestPath.getConglomerateDescriptor();
0: 
0: 		if (isBaseTable())
0: 		{
0: 			DataDictionary dd = getDataDictionary();
0: 			TableDescriptor td = getTableDescriptor();
0: 			getTrulyTheBestAccessPath().initializeAccessPathName(dd, td);
0: 		}
0: 
0: 		setCostEstimate(bestPath.getCostEstimate());
0: 
0: 		bestPath.getOptimizer().trace(Optimizer.REMEMBERING_BEST_ACCESS_PATH,
0: 							tableNumber, planType, 0.0, bestPath);
0: 	}
0: 
0: 	/** @see Optimizable#startOptimizing */
0: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
0: 	{
0: 		resetJoinStrategies(optimizer);
0: 
0: 		considerSortAvoidancePath = false;
0: 
0: 		/*
0: 		** If there are costs associated with the best and sort access
0: 		** paths, set them to their maximum values, so that any legitimate
0: 		** access path will look cheaper.
0: 		*/
0: 		CostEstimate ce = getBestAccessPath().getCostEstimate();
0: 
0: 		if (ce != null)
0: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
0: 
0: 		ce = getBestSortAvoidancePath().getCostEstimate();
0: 
0: 		if (ce != null)
0: 			ce.setCost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
0: 
0: 		if (! canBeOrdered())
0: 			rowOrdering.addUnorderedOptimizable(this);
0: 	}
0: 
0: 	/**
0: 	 * This method is called when this table is placed in a potential
0: 	 * join order, or when a new conglomerate is being considered.
0: 	 * Set this join strategy number to 0 to indicate that
0: 	 * no join strategy has been considered for this table yet.
0: 	 */
0: 	protected void resetJoinStrategies(Optimizer optimizer)
0: 	{
0: 		joinStrategyNumber = 0;
0: 		getCurrentAccessPath().setJoinStrategy((JoinStrategy) null);
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#estimateCost
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
0: 									ConglomerateDescriptor cd,
0: 									CostEstimate outerCost,
0: 									Optimizer optimizer,
0: 									RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 			 "estimateCost() not expected to be called for " + 
0: 			 getClass().toString());
0: 		}	
0: 
0: 		return null;
0: 	}
0: 
0: 	/** @see Optimizable#isBaseTable */
0: 	public boolean isBaseTable()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** @see Optimizable#isMaterializable 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isMaterializable()
0: 		throws StandardException
0: 	{
0: 		/* Derived tables are materializable
0: 		 * iff they are not correlated with an outer query block.
0: 		 */
0: 
0: 		HasCorrelatedCRsVisitor visitor = new HasCorrelatedCRsVisitor();
0: 		accept(visitor);
0: 		return !(visitor.hasCorrelatedCRs());
0: 	}
0: 
0: 	/** @see Optimizable#supportsMultipleInstantiations */
0: 	public boolean supportsMultipleInstantiations()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/** @see Optimizable#getTableNumber */
0: 	public int getTableNumber()
0: 	{
0: 		return tableNumber;
0: 	}
0: 
0: 	/** @see Optimizable#hasTableNumber */
0: 	public boolean hasTableNumber()
0: 	{
0: 		return tableNumber >= 0;
0: 	}
0: 
0: 	/** @see Optimizable#forUpdate */
0: 	public boolean forUpdate()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** @see Optimizable#initialCapacity */
0: 	public int initialCapacity()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Not expected to be called");
0: 		}
0: 
0: 		return 0;
0: 	}
0: 
0: 	/** @see Optimizable#loadFactor */
0: 	public float loadFactor()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Not expected to be called");
0: 		}
0: 
0: 		return 0.0F;
0: 	}
0: 
0: 	/** @see Optimizable#maxCapacity */
0: 	public int maxCapacity()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Not expected to be called");
0: 		}
0: 
0: 		return 0;
0: 	}
0: 
0: 	/** @see Optimizable#hashKeyColumns */
0: 	public int[] hashKeyColumns()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(hashKeyColumns != null,
0: 				"hashKeyColumns expected to be non-null");
0: 		}
0: 
0: 		return hashKeyColumns;
0: 	}
0: 
0: 	/** @see Optimizable#setHashKeyColumns */
0: 	public void setHashKeyColumns(int[] columnNumbers)
0: 	{
0: 		hashKeyColumns = columnNumbers;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#feasibleJoinStrategy
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
0: 										Optimizer optimizer)
0: 					throws StandardException
0: 	{
0: 		return getCurrentAccessPath().getJoinStrategy().
0: 								feasible(this, predList, optimizer);
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#memoryUsage
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double memoryUsage(double rowCount) throws StandardException
0: 	{
0: 		double retval = 0.0;
0: 		
0: 		// workaround for a jikes bug. Can't directly reference a 
0: 		// double with a value of 12.0 in this classfile. 
0: 		double baseIndexUsage = 1.0;
0: 
0: 		/*
0: 		** Don't enforce maximum memory usage for a user-specified join
0: 		** strategy.
0: 		*/
0: 		if (userSpecifiedJoinStrategy == null)
0: 		{
0: 			FormatableBitSet refCols = getRefCols();
0: 			double perRowUsage = 0.0;
0: 
0: 			/* Add up the memory usage for each referenced column */
0: 			for (int i = 0; i < refCols.size(); i++)
0: 			{
0: 				if (refCols.isSet(i))
0: 				{
0: 					ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
0:                     DataTypeDescriptor expressionType = rc.getExpressionType();
0:                     if( expressionType != null)
0:                         perRowUsage += expressionType.estimatedMemoryUsage();
0: 				}
0: 			}
0: 
0: 			/*
0: 			** If the proposed conglomerate is a non-covering index, add the 
0: 			** size of the RowLocation column to the total.
0: 			**
0: 			** NOTE: We don't have a DataTypeDescriptor representing a
0: 			** REF column here, so just add a constant here.
0: 			*/
0: 			ConglomerateDescriptor cd =
0: 					getCurrentAccessPath().getConglomerateDescriptor();
0: 			if (cd != null)
0: 			{
0: 				if (cd.isIndex() && ( ! isCoveringIndex(cd) ) )
0: 				{
0: 					perRowUsage += ( baseIndexUsage + 11 );
0: 				}
0: 			}
0: 
0: 			/*
0: 			** Let the join strategy tell us how much memory it uses.
0: 			** Some use memory and some don't.
0: 			*/
0: 			retval = getCurrentAccessPath().getJoinStrategy().
0: 											memoryUsage(perRowUsage, rowCount);
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#legalJoinOrder
0: 	 */
0: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
0: 	{
0: 		// Only those subclasses with dependencies need to override this.
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#getNumColumnsReturned
0: 	 */
0: 	public int getNumColumnsReturned()
0: 	{
0: 		return resultColumns.size();
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#isTargetTable
0: 	 */
0: 	public boolean isTargetTable()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#isOneRowScan
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isOneRowScan() 
0: 		throws StandardException
0: 	{
0: 		/* We simply return isOneRowResultSet() for all
0: 		 * subclasses except for EXISTS FBT where
0: 		 * the semantics differ between 1 row per probe
0: 		 * and whether or not there can be more than 1
0: 		 * rows that qualify on a scan.
0: 		 */
0: 		return isOneRowResultSet();
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#initAccessPaths
0: 	 */
0: 	public void initAccessPaths(Optimizer optimizer)
0: 	{
0: 		if (currentAccessPath == null)
0: 		{
0: 			currentAccessPath = new AccessPathImpl(optimizer);
0: 		}
0: 		if (bestAccessPath == null)
0: 		{
0: 			bestAccessPath = new AccessPathImpl(optimizer);
0: 		}
0: 		if (bestSortAvoidancePath == null)
0: 		{
0: 			bestSortAvoidancePath = new AccessPathImpl(optimizer);
0: 		}
0: 		if (trulyTheBestAccessPath == null)
0: 		{
0: 			trulyTheBestAccessPath = new AccessPathImpl(optimizer);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#uniqueJoin
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double uniqueJoin(OptimizablePredicateList predList)
0: 						throws StandardException
0: 	{
0: 		return -1.0;
0: 	}
0: 
0: 	private FormatableBitSet getRefCols()
0: 	{
0: 		if (refCols == null)
0: 			refCols = resultColumns.getReferencedFormatableBitSet(cursorTargetTable(), true, false);
0: 
0: 		return refCols;
0: 	}
0: 
0: 
0: 	/** 
0: 	 * Return the user specified join strategy, if any for this table.
0: 	 *
0: 	 * @return The user specified join strategy, if any for this table.
0: 	 */
0: 	String getUserSpecifiedJoinStrategy()
0: 	{
0: 		if (tableProperties == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		return tableProperties.getProperty("joinStrategy");
0: 	}
0: 
0: 	/**
0: 	 * Is this a table that has a FOR UPDATE
0: 	 * clause.  Overridden by FromBaseTable.
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	protected boolean cursorTargetTable()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	protected CostEstimate getCostEstimate(Optimizer optimizer)
0: 	{
0: 		if (costEstimate == null)
0: 		{
0: 			costEstimate = optimizer.newCostEstimate();
0: 		}
0: 		return costEstimate;
0: 	}
0: 
0: 	/*
0: 	** This gets a cost estimate for doing scratch calculations.  Typically,
0: 	** it will hold the estimated cost of a conglomerate.  If the optimizer
0: 	** decides the scratch cost is lower than the best cost estimate so far,
0: 	** it will copy the scratch cost to the non-scratch cost estimate,
0: 	** which is allocated above.
0: 	*/
0: 	protected CostEstimate getScratchCostEstimate(Optimizer optimizer)
0: 	{
0: 		if (scratchCostEstimate == null)
0: 		{
0: 			scratchCostEstimate = optimizer.newCostEstimate();
0: 		}
0: 
0: 		return scratchCostEstimate;
0: 	}
0: 
0: 	/**
0: 	 * Set the cost estimate in this node to the given cost estimate.
0: 	 */
0: 	protected void setCostEstimate(CostEstimate newCostEstimate)
0: 	{
0: 		costEstimate = getCostEstimate();
0: 
0: 		costEstimate.setCost(newCostEstimate);
0: 	}
0: 
0: 	/**
0: 	 * Assign the cost estimate in this node to the given cost estimate.
0: 	 */
0: 	protected void assignCostEstimate(CostEstimate newCostEstimate)
0: 	{
0: 		costEstimate = newCostEstimate;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "correlation Name: " + correlationName + "\n" +
0: 				(corrTableName != null ?
0: 					corrTableName.toString() : "null") + "\n" +
0: 				"tableNumber " + tableNumber + "\n" +
0: 				"level " + level + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return a ResultColumnList with all of the columns in this table.
0: 	 * (Used in expanding '*'s.)
0: 	 * NOTE: Since this method is for expanding a "*" in the SELECT list,
0: 	 * ResultColumn.expression will be a ColumnReference.
0: 	 *
0: 	 * @param allTableName		The qualifier on the "*"
0: 	 *
0: 	 * @return ResultColumnList	List of result columns from this table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultColumnList getResultColumnsForList(String allTableName,
0: 												ResultColumnList inputRcl,
0: 												TableName tableName)
0: 			throws StandardException
0: 	{
0: 		ResultColumnList rcList = null;
0: 		ResultColumn	 resultColumn;
0: 		ValueNode		 valueNode;
0: 		String			 columnName;
0: 		TableName		 exposedName;
0: 
0: 		/* If allTableName is non-null, then we must check to see if it matches 
0: 		 * our exposed name.
0: 		 */
0: 		if (allTableName != null && ! allTableName.equals(getExposedName()))
0: 		{
0: 			return null;
0: 		}
0: 
0: 		/* Cache exposed name for this table.
0: 		 * The exposed name becomes the qualifier for each column
0: 		 * in the expanded list.
0: 		 */
0: 		if (correlationName == null)
0: 		{
0: 			exposedName = tableName;
0: 		}
0: 		else
0: 		{
0: 			exposedName = makeTableName(null, correlationName);
0: 		}
0: 
0: 		rcList = (ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
0: 										getContextManager());
0: 
0: 		/* Build a new result column list based off of resultColumns.
0: 		 * NOTE: This method will capture any column renaming due to 
0: 		 * a derived column list.
0: 		 */
0: 		int inputSize = inputRcl.size();
0: 		for (int index = 0; index < inputSize; index++)
0: 		{
0: 			// Build a ResultColumn/ColumnReference pair for the column //
0: 			columnName = ((ResultColumn) inputRcl.elementAt(index)).getName();
0: 			valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											columnName,
0: 											exposedName,
0: 											getContextManager());
0: 			resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											columnName,
0: 											valueNode,
0: 											getContextManager());
0: 
0: 			// Build the ResultColumnList to return //
0: 			rcList.addResultColumn(resultColumn);
0: 		}
0: 		return rcList;
0: 	}
0: 
0: 	/**
0: 	 * Push expressions down to the first ResultSetNode which can do expression
0: 	 * evaluation and has the same referenced table map.
0: 	 * RESOLVE - This means only pushing down single table expressions to
0: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
0: 	 * the optimizer will work, we can push down join clauses.
0: 	 *
0: 	 * @param predicateList	The PredicateList.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void pushExpressions(PredicateList predicateList)
0: 						throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) 
0: 		{
0: 			SanityManager.ASSERT(predicateList != null,
0: 							 "predicateList is expected to be non-null");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the exposed name for this table, which is the name that can
0: 	 * be used to refer to it in the rest of the query.
0: 	 *
0: 	 * @return	The exposed name of this table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getExposedName() throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.THROWASSERT(
0: 							 "getExposedName() not expected to be called for " + this.getClass().getName());
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Set the table # for this table.  
0: 	 *
0: 	 * @param tableNumber	The table # for this table.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setTableNumber(int tableNumber)
0: 	{
0: 		/* This should only be called if the tableNumber has not been set yet */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(this.tableNumber == -1, 
0: 							 "tableNumber is not expected to be already set");
0: 		this.tableNumber = tableNumber;
0: 	}
0: 
0: 	/**
0: 	 * Return a TableName node representing this FromTable.
0: 	 * Expect this to be overridden (and used) by subclasses
0: 	 * that may set correlationName to null.
0: 	 *
0: 	 * @return a TableName node representing this FromTable.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public TableName getTableName()
0: 		throws StandardException
0: 	{
0: 		if (correlationName == null) return null;
0: 
0: 		if (corrTableName == null)
0: 		{
0: 			corrTableName = makeTableName(null, correlationName);
0: 		}
0: 
0: 		return corrTableName;
0: 	}
0: 
0: 	/**
0: 	 * Set the (query block) level (0-based) for this FromTable.
0: 	 *
0: 	 * @param level		The query block level for this FromTable.
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	public void setLevel(int level)
0: 	{
0: 		this.level = level;
0: 	}
0: 
0: 	/**
0: 	 * Get the (query block) level (0-based) for this FromTable.
0: 	 *
0: 	 * @return int	The query block level for this FromTable.
0: 	 */
0: 	public int getLevel()
0: 	{
0: 		return level;
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for this FromTable.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			/* NOTE: level doesn't get propagated 
0: 			 * to nodes generated after binding.
0: 			 */
0: 			if (level < decrement && level != 0)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"level (" + level +
0: 					") expected to be >= decrement (" +
0: 					decrement + ")");
0: 			}
0: 		}
0: 		/* NOTE: level doesn't get propagated 
0: 		 * to nodes generated after binding.
0: 		 */
0: 		if (level > 0)
0: 		{
0: 			level -= decrement;
0: 		}
0: 	}
0: 
0: 	/**
0: 	* Get a schema descriptor for the given table.
0: 	* Uses this.corrTableName.
0: 	*
0: 	* @return Schema Descriptor
0: 	*
0: 	* @exception	StandardException	throws on schema name
0: 	*						that doesn't exist	
0: 	*/
0: 	public SchemaDescriptor getSchemaDescriptor() throws StandardException
0: 	{
0: 		return getSchemaDescriptor(corrTableName);
0: 	}	
0: 
0: 	/**
0: 	* Get a schema descriptor for the given table.
0: 	*
0: 	* @param	TableName the table name
0: 	*
0: 	* @return Schema Descriptor
0: 	*
0: 	* @exception	StandardException	throws on schema name
0: 	*						that doesn't exist	
0: 	*/
0: 	public SchemaDescriptor getSchemaDescriptor(TableName tableName) throws StandardException
0: 	{
0: 		SchemaDescriptor		sd;
0: 
0: 		sd = getSchemaDescriptor(tableName.getSchemaName());
0: 
0: 		return sd;
0: 	}	
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		// Only FromBaseTables have schema names
0: 		if (schemaName != null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		if (getExposedName().equals(name))
0: 		{
0: 			return this;
0: 		}
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Is this FromTable a JoinNode which can be flattened into 
0: 	 * the parents FromList.
0: 	 *
0: 	 * @return boolean		Whether or not this FromTable can be flattened.
0: 	 */
0: 	public boolean isFlattenableJoinNode()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * no LOJ reordering for this FromTable.
0: 	 */
0: 	public boolean LOJ_reorderable(int numTables)
0: 		throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Transform any Outer Join into an Inner Join where applicable.
0: 	 * (Based on the existence of a null intolerant
0: 	 * predicate on the inner table.)
0: 	 *
0: 	 * @param predicateTree	The predicate tree for the query block
0: 	 *
0: 	 * @return The new tree top (OuterJoin or InnerJoin).
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
0: 		throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Fill the referencedTableMap with this ResultSetNode.
0: 	 *
0: 	 * @param passedMap	The table map to fill in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void fillInReferencedTableMap(JBitSet passedMap)
0: 	{
0: 		if (tableNumber != -1)
0: 		{
0: 			passedMap.set(tableNumber);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark as updatable all the columns in the result column list of this
0: 	 * FromBaseTable that match the columns in the given update column list.
0: 	 * If the list is null, it means all the columns are updatable.
0: 	 *
0: 	 * @param updateColumns		A Vector representing the columns
0: 	 *							that can be updated.
0: 	 */
0: 	protected void markUpdatableByCursor(Vector updateColumns)
0: 	{
0: 		resultColumns.markUpdatableByCursor(updateColumns);
0: 	}
0: 
0: 	/**
0: 	 * Flatten this FromTable into the outer query block. The steps in
0: 	 * flattening are:
0: 	 *	o  Mark all ResultColumns as redundant, so that they are "skipped over"
0: 	 *	   at generate().
0: 	 *	o  Append the wherePredicates to the outer list.
0: 	 *	o  Return the fromList so that the caller will merge the 2 lists 
0: 	 *
0: 	 * @param rcl				The RCL from the outer query
0: 	 * @param outerPList	PredicateList to append wherePredicates to.
0: 	 * @param sql				The SubqueryList from the outer query
0: 	 * @param gbl				The group by list, if any
0: 	 *
0: 	 * @return FromList		The fromList from the underlying SelectNode.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public FromList flatten(ResultColumnList rcl,
0: 							PredicateList outerPList,
0: 							SubqueryList sql,
0: 							GroupByList gbl)
0: 
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				 "flatten() not expected to be called for " + this);
0: 		}
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Optimize any subqueries that haven't been optimized any where
0: 	 * else.  This is useful for a RowResultSetNode as a derived table
0: 	 * because it doesn't get optimized otherwise.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
0: 		throws StandardException
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Tell the given RowOrdering about any columns that are constant
0: 	 * due to their being equality comparisons with constant expressions.
0: 	 */
0: 	protected void tellRowOrderingAboutConstantColumns(
0: 										RowOrdering	rowOrdering,
0: 										OptimizablePredicateList predList)
0: 	{
0: 		/*
0: 		** Tell the RowOrdering about columns that are equal to constant
0: 		** expressions.
0: 		*/
0: 		if (predList != null)
0: 		{
0: 			for (int i = 0; i < predList.size(); i++)
0: 			{
0: 				Predicate pred = (Predicate) predList.getOptPredicate(i);
0: 
0: 				/* Is it an = comparison with a constant expression? */
0: 				if (pred.equalsComparisonWithConstantExpression(this))
0: 				{
0: 					/* Get the column being compared to the constant */
0: 					ColumnReference cr = pred.getRelop().getColumnOperand(this);
0: 
0: 					if (cr != null)
0: 					{
0: 						/* Tell RowOrdering that the column is always ordered */
0: 						rowOrdering.columnAlwaysOrdered(this, cr.getColumnNumber());
0: 					}
0: 				}
0: 			}
0: 		}
0: 		
0: 	}
0: 	
0: 	public boolean needsSpecialRCLBinding()
0: 	{
0: 		return false;
0: 	}
0: }
============================================================================