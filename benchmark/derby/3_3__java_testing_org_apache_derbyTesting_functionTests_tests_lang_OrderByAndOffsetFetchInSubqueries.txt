1:108305b: /*
1:108305b:  * Class org.apache.derbyTesting.functionTests.tests.lang.OrderByAndOffsetFetchInSubqueries
1:108305b:  *
1:108305b:  * Licensed to the Apache Software Foundation (ASF) under one
1:108305b:  * or more contributor license agreements.  See the NOTICE file
1:108305b:  * distributed with this work for additional information
1:108305b:  * regarding copyright ownership.  The ASF licenses this file
1:108305b:  * to you under the Apache License, Version 2.0 (the
1:108305b:  * "License"); you may not use this file except in compliance
1:108305b:  * with the License.  You may obtain a copy of the License at
1:108305b:  *
1:108305b:  *   http://www.apache.org/licenses/LICENSE-2.0
1:108305b:  *
1:108305b:  * Unless required by applicable law or agreed to in writing,
1:108305b:  * software distributed under the License is distributed on an
1:108305b:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:108305b:  * KIND, either express or implied.  See the License for the
1:108305b:  * specific language governing permissions and limitations
1:108305b:  * under the License.
1:108305b:  */
1:108305b: 
1:108305b: package org.apache.derbyTesting.functionTests.tests.lang;
1:108305b: 
1:108305b: import java.sql.PreparedStatement;
1:108305b: import java.sql.ResultSet;
1:b4cda60: import java.sql.SQLException;
1:b4cda60: import java.sql.Statement;
1:108305b: import junit.framework.Test;
1:108305b: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:b4cda60: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:108305b: import org.apache.derbyTesting.junit.JDBC;
1:108305b: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:108305b: import org.apache.derbyTesting.junit.SQLUtilities;
1:b4cda60: import org.apache.derbyTesting.junit.TestConfiguration;
1:108305b: 
1:108305b: /**
1:108305b:  * Tests for DERBY-4397 Allow {@code ORDER BY} in subqueries
1:108305b:  * and       DERBY-4398 Allow {@code OFFSET/FETCH} in subqueries.
1:108305b:  */
1:108305b: public class OrderByAndOffsetFetchInSubqueries extends BaseJDBCTestCase {
1:108305b: 
1:108305b:     final static String SYNTAX_ERROR = "42X01";
1:108305b:     final static String COLUMN_NOT_FOUND = "42X04";
1:108305b:     final static String COLUMN_OUT_OF_RANGE = "42X77";
1:108305b:     final static String ORDER_BY_COLUMN_NOT_FOUND = "42X78";
1:108305b: 
1:108305b:     public OrderByAndOffsetFetchInSubqueries(String name) {
1:108305b:         super(name);
1:108305b:     }
1:108305b: 
1:108305b:     /**
1:108305b:      * Construct top level suite in this JUnit test
1:108305b:      *
1:108305b:      * @return A suite containing embedded and client suites.
1:108305b:      */
1:108305b:     public static Test suite()
1:108305b:     {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("OrderByAndOffsetFetchInSubqueries");
1:108305b: 
1:108305b:         suite.addTest(makeSuite());
1:108305b:         suite.addTest(
1:108305b:              TestConfiguration.clientServerDecorator(makeSuite()));
1:108305b: 
1:108305b:         return suite;
1:108305b:     }
1:108305b: 
1:108305b:     /**
1:108305b:      * Construct suite of tests
1:108305b:      *
1:108305b:      * @return A suite containing the test cases.
1:108305b:      */
1:108305b:     private static Test makeSuite()
1:108305b:     {
1:108305b:         return new CleanDatabaseTestSetup(
1:1ae02c9:             new BaseTestSuite(OrderByAndOffsetFetchInSubqueries.class)) {
1:b4cda60:                 @Override
1:108305b:                 protected void decorateSQL(Statement s)
1:108305b:                         throws SQLException {
1:108305b:                     getConnection().setAutoCommit(false);
1:108305b: 
1:108305b:                     s.execute("create table temp1(s varchar(10))");
1:108305b: 
1:108305b:                     // GENERATED ALWAYS AS IDENTITY
1:108305b:                     s.execute("create table temp2(" +
1:108305b:                               "i integer not null " +
1:108305b:                               "    generated always as identity," +
1:108305b:                               "s varchar(10))");
1:108305b:                     s.execute("create table temp2b(" +
1:108305b:                               "i integer not null " +
1:108305b:                               "    generated always as identity," +
1:108305b:                               "s varchar(10))");
1:108305b:                     // DEFAULT value
1:108305b:                     s.execute("create table temp3(" +
1:108305b:                               "i integer not null " +
1:108305b:                               "    generated always as identity," +
1:108305b:                               "s varchar(10)," +
1:108305b:                               "j integer not null " +
1:108305b:                               "    default 66," +
1:108305b:                               "t varchar(10))");
1:108305b: 
1:108305b:                     // GENERATED ALWAYS AS (expression)
1:108305b:                     s.execute("create table temp4(" +
1:108305b:                               "i integer not null " +
1:108305b:                               "    generated always as identity," +
1:108305b:                               "s varchar(10)," +
1:108305b:                               "j integer not null " +
1:108305b:                               "    generated always as (2*i)," +
1:108305b:                               "t varchar(10))");
1:108305b: 
1:108305b: 
1:108305b:                     s.execute("create table t01(c1 int)");
1:108305b:                     s.execute("create table t02(c2 int)");
1:108305b: 
1:108305b:                     s.execute("create table t_source(c1 int, c2 varchar(10))");
1:108305b:                     s.execute("create table t(i int not null, " +
1:108305b:                               "               constraint c unique (i), " +
1:108305b:                               "               j int, k int)");
1:108305b: 
1:108305b:                     getConnection().commit();
1:108305b:                 }
1:108305b:             };
1:108305b:     }
1:108305b: 
1:108305b:     /**
1:108305b:      * Test {@code INSERT INTO t SELECT .. FROM .. ORDER BY}.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testInsertSelectOrderBy() throws SQLException {
1:108305b:         //
1:108305b:         // Shows that DERBY-4 is now solved.
1:108305b:         //
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:b4cda60:         ResultSet rs;
1:108305b: 
1:108305b:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1:108305b:         s.execute("insert into temp2(s) select s from temp1 order by s");
1:108305b:         s.execute("insert into temp2(s) select s as a1 from temp1 order by a1");
1:108305b:         s.execute("insert into temp2(s) select * from temp1 order by s");
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from temp2");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "a"},
1:108305b:                 {"2", "a"},
1:108305b:                 {"3", "b"},
1:108305b:                 {"4", "c"},
1:108305b:                 {"5", "x"},
1:108305b:                 {"6", "a"},
1:108305b:                 {"7", "a"},
1:108305b:                 {"8", "b"},
1:108305b:                 {"9", "c"},
1:108305b:                 {"10", "x"},
1:108305b:                 {"11", "a"},
1:108305b:                 {"12", "a"},
1:108305b:                 {"13", "b"},
1:108305b:                 {"14", "c"},
1:108305b:                 {"15", "x"}});
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from temp2 order by i");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "a"},
1:108305b:                 {"2", "a"},
1:108305b:                 {"3", "b"},
1:108305b:                 {"4", "c"},
1:108305b:                 {"5", "x"},
1:108305b:                 {"6", "a"},
1:108305b:                 {"7", "a"},
1:108305b:                 {"8", "b"},
1:108305b:                 {"9", "c"},
1:108305b:                 {"10", "x"},
1:108305b:                 {"11", "a"},
1:108305b:                 {"12", "a"},
1:108305b:                 {"13", "b"},
1:108305b:                 {"14", "c"},
1:108305b:                 {"15", "x"}});
1:108305b: 
1:108305b:         s.execute("insert into temp2(s) select s as a1 from temp1 order by s");
1:108305b: 
1:108305b:         // This should be rejected as "no such column" errors:
1:108305b:         assertStatementError(
1:108305b:             COLUMN_NOT_FOUND, s,
1:108305b:             "insert into temp2(s) select s as a1 from temp1 order by no_such");
1:108305b: 
1:108305b:         // A similar example, but with integers rather than strings, and some
1:108305b:         // intermediate select statements to show that the ordering is working.
1:108305b:         //
1:108305b:         s.execute("insert into t01 values (50), (10), (1000), (15), (51)");
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from t01");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"50"},
1:108305b:                 {"10"},
1:108305b:                 {"1000"},
1:108305b:                 {"15"},
1:108305b:                 {"51"}});
1:108305b: 
1:108305b: 
1:108305b:         s.execute("insert into t02 select * from t01 order by c1");
1:108305b:         s.execute("insert into t02 select * from t01");
1:108305b:         s.execute("insert into t02 select * from t01 order by c1");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"50"},
1:108305b:                 {"51"},
1:108305b:                 {"1000"},
1:108305b:                 {"50"},
1:108305b:                 {"10"},
1:108305b:                 {"1000"},
1:108305b:                 {"15"},
1:108305b:                 {"51"},
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"50"},
1:108305b:                 {"51"},
1:108305b:                 {"1000"}});
1:108305b: 
1:108305b:         // Combining ORDER BY and VALUES is not legal SQL, cf.  SQL 2008,
1:108305b:         // section 14.11, Syntactic Rule 17: "A <query expression> simply
1:108305b:         // contained in a <from subquery> shall not be a <table value
1:108305b:         // constructor>. See also discussion in JIRA on DERBY-4413
1:108305b:         // (2009-OCT-23).
1:108305b:         //
1:108305b:         assertStatementError(
1:108305b:              SYNTAX_ERROR, s,
1:108305b:              "insert into t02 values 66 order by 1");
1:108305b:         assertStatementError(
1:108305b:              SYNTAX_ERROR, s,
1:108305b:              "insert into t02 values (901), (920), (903) order by 1");
1:108305b: 
1:108305b:         // But this should work:
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate("insert into t02 select 900 from sys.systables " +
1:108305b:                         "                union values 66 order by 1");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                  {"66"},
1:108305b:                  {"900"}});
1:108305b: 
1:108305b:         // other way around:
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate(
1:108305b:             "insert into t02 values 66 " +
1:108305b:             "       union select 900 from sys.systables order by 1");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                  {"66"},
1:108305b:                  {"900"}});
1:108305b: 
1:108305b:         // and, somewhat perversely (since a plain "values 66 order by 1" is
1:108305b:         // illegal), this:
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate("insert into t02 values 66 " +
1:108305b:                         "       union values 66 order by 1");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                  {"66"}});
1:108305b: 
1:108305b: 
1:108305b:         // UNION
1:108305b:         //
1:108305b:         // ok:
1:108305b:         s.execute("delete from t02");
1:108305b:         s.execute("insert into t02 select * from t01 union all " +
1:108305b:                   "                select * from t01 order by c1");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"10"},
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"15"},
1:108305b:                 {"50"},
1:108305b:                 {"50"},
1:108305b:                 {"51"},
1:108305b:                 {"51"},
1:108305b:                 {"1000"},
1:108305b:                 {"1000"}});
1:108305b: 
1:108305b:         // Not ok (c1 is not a column in the union result set, since t02 has
1:108305b:         // column c02.
1:108305b:         assertStatementError(
1:108305b:             ORDER_BY_COLUMN_NOT_FOUND, s,
1:108305b:             "insert into t02 select * from t01 union all " +
1:108305b:             "                select * from t02 order by c1");
1:108305b: 
1:108305b: 
1:108305b:         // Complication: project away sort column
1:108305b:         s.execute("delete from t02");
1:108305b:         s.execute("insert into t_source " +
1:108305b:                   "    values (1, 'one'), (2, 'two'), (8, 'three')");
1:108305b:         s.execute("insert into t_source(c1) " +
1:108305b:                   "    select c1 from t_source order by c2 desc");
1:108305b:         rs = s.executeQuery("select * from t_source");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "one"},
1:108305b:                 {"2", "two"},
1:108305b:                 {"8", "three"},
1:108305b:                 {"2", null},
1:108305b:                 {"8", null},
1:108305b:                 {"1", null}});
1:108305b: 
1:108305b:         // DERBY-4496
1:108305b:         s.executeUpdate("create table t4496(x varchar(100))");
1:108305b:         s.execute("insert into t4496(x) select ibmreqd from " +
1:108305b:                   "    (select * from sysibm.sysdummy1" +
1:108305b:                   "         order by length(ibmreqd)) t1");
1:108305b: 
1:108305b:         JDBC.assertFullResultSet(
1:108305b:             s.executeQuery("select * from t4496"),
1:108305b:             new String[][]{{"Y"}});
1:108305b: 
1:576d3b7:         // DERBY-6006. INSERT INTO ... SELECT FROM could fail with a
1:576d3b7:         // NullPointerException in insane builds, or XSCH5 or assert in sane
1:576d3b7:         // builds, if the SELECT had an ORDER BY column that was not referenced
1:576d3b7:         // in the select list, and if normalization was required because the
1:576d3b7:         // types in the select list didn't exactly match the types in the
1:576d3b7:         // target table.
1:576d3b7:         //
1:576d3b7:         // In the test case below, the select list has an INT (the literal 1),
1:576d3b7:         // whereas the target type is DOUBLE. Also, the ORDER BY column (X) is
1:576d3b7:         // not in the select list.
1:576d3b7:         s.execute("create table t6006(x double)");
1:576d3b7:         assertUpdateCount(s, 6, "insert into t6006 values 1,2,3,4,5,6");
1:576d3b7:         assertUpdateCount(s, 6,
1:576d3b7:                 "insert into t6006 select 1 from t6006 order by x");
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:b4cda60: 
1:b4cda60:     /**
1:108305b:      * Same test as {@code testInsertSelectOrderBy} but with use of
1:108305b:      * {@code OFFSET/FETCH FIRST}.
1:108305b:      * <p/>
1:108305b:      * Test {@code INSERT INTO t SELECT .. FROM .. ORDER BY} + {@code OFFSET
1:108305b:      * FETCH}
1:108305b:      * <p/>
1:108305b:      * This test is a variant made my modifying {@code testInsertSelectOrderBy}
1:108305b:      * with suitable {@code OFFSET/FETCH FIRST} clauses.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testInsertSelectOrderByOffsetFetch() throws SQLException {
1:108305b:         //
1:108305b:         // Shows that DERBY-4 is now solved.
1:108305b:         //
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:4d044a3: 
1:108305b:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1:108305b:         s.execute("insert into temp2b(s) select s from temp1 order by s " +
1:108305b:                   "    offset 1 rows fetch next 4 rows only");
1:4d044a3: 
1:108305b:         JDBC.assertFullResultSet(
1:108305b:             s.executeQuery("select * from temp2b"),
1:108305b:             new String[][]{
1:108305b:                 {"1", "a"},
1:108305b:                 {"2", "b"},
1:108305b:                 {"3", "c"},
1:108305b:                 {"4", "x"}});
1:7b48c50: 
1:108305b:         s.execute(
1:108305b:             "insert into temp2b(s) select s as a1 from temp1 order by a1" +
1:108305b:             "    offset 1 rows fetch next 4 rows only");
1:7b48c50: 
1:108305b:         s.execute(
1:108305b:             "insert into temp2b(s) select * from temp1 order by s " +
1:108305b:             "    offset 1 rows fetch next 4 rows only");
1:108305b: 
1:b4cda60:         ResultSet rs = s.executeQuery("select * from temp2b");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "a"},
1:108305b:                 {"2", "b"},
1:108305b:                 {"3", "c"},
1:108305b:                 {"4", "x"},
1:108305b:                 {"5", "a"},
1:108305b:                 {"6", "b"},
1:108305b:                 {"7", "c"},
1:108305b:                 {"8", "x"},
1:108305b:                 {"9", "a"},
1:108305b:                 {"10", "b"},
1:108305b:                 {"11", "c"},
1:108305b:                 {"12", "x"}});
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from temp2b order by i");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "a"},
1:108305b:                 {"2", "b"},
1:108305b:                 {"3", "c"},
1:108305b:                 {"4", "x"},
1:108305b:                 {"5", "a"},
1:108305b:                 {"6", "b"},
1:108305b:                 {"7", "c"},
1:108305b:                 {"8", "x"},
1:108305b:                 {"9", "a"},
1:108305b:                 {"10", "b"},
1:108305b:                 {"11", "c"},
1:108305b:                 {"12", "x"}});
1:108305b: 
1:108305b: 
1:108305b:         // A similar example, but with integers rather than strings, and some
1:108305b:         // intermediate select statements to show that the ordering is working.
1:108305b:         //
1:108305b:         s.execute("insert into t01 values (50), (10), (1000), (15), (51)");
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from t01");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"50"},
1:108305b:                 {"10"},
1:108305b:                 {"1000"},
1:108305b:                 {"15"},
1:108305b:                 {"51"}});
1:108305b: 
1:108305b: 
1:108305b:         s.execute(
1:108305b:             "insert into t02 select * from t01 order by c1 " +
1:108305b:             "    fetch first 2 rows only");
1:108305b:         s.execute(
1:108305b:             "insert into t02 select * from t01");
1:108305b:         s.execute(
1:108305b:             "insert into t02 select * from t01 order by c1 offset 0 rows");
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"50"},
1:108305b:                 {"10"},
1:108305b:                 {"1000"},
1:108305b:                 {"15"},
1:108305b:                 {"51"},
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"50"},
1:108305b:                 {"51"},
1:108305b:                 {"1000"}});
1:108305b: 
1:108305b:         // Illegal context
1:108305b:         assertStatementError(
1:108305b:              SYNTAX_ERROR, s,
1:108305b:              "insert into t02 values 66 offset 1 row");
1:108305b: 
1:108305b:         // But this should work:
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate(
1:108305b:             "insert into t02 select 900 from sys.systables " +
1:108305b:             "                union values 66 order by 1 offset 1 row");
1:108305b: 
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                  {"900"}});
1:108305b: 
1:108305b:         // other way around:
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate(
1:108305b:             "insert into t02 values 66 " +
1:108305b:             "       union select 900 from sys.systables fetch next 1 row only");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                  {"66"}});
1:108305b: 
1:108305b:         s.executeUpdate("delete from t02");
1:108305b:         s.executeUpdate("insert into t02 select * from (values 3,4,5 )v " +
1:108305b:                         "    order by 1 offset 1 row fetch next 2 rows only");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"4"},
1:108305b:                 {"5"}});
1:108305b: 
1:108305b: 
1:108305b:         // UNION
1:108305b:         //
1:108305b:         // ok:
1:108305b:         s.execute("delete from t02");
1:108305b:         s.execute("insert into t02 select * from t01 union all " +
1:108305b:                   "                select * from t01 order by c1 " +
1:108305b:                   "                fetch next 4 rows only");
1:108305b:         rs = s.executeQuery("select * from t02");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"10"},
1:108305b:                 {"10"},
1:108305b:                 {"15"},
1:108305b:                 {"15"}});
1:108305b: 
1:108305b:         // EXCEPT
1:108305b:         s.execute("delete from t01");
1:108305b:         s.execute("insert into t02 values 6,7");
1:108305b:         s.execute("insert into t01 select * from t02 except " +
1:108305b:                   "                values 10 order by 1 offset 1 row");
1:108305b:         rs = s.executeQuery("select * from t01");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"7"},
1:108305b:                 {"15"}});
1:108305b: 
1:108305b:         // Complication: project away sort column
1:108305b:         s.execute("delete from t02");
1:108305b:         s.execute("insert into t_source " +
1:108305b:                   "    values (1, 'one'), (2, 'two'), (8, 'three')");
1:108305b:         s.execute("insert into t_source(c1) " +
1:108305b:                   "    select c1 from t_source order by c2 desc " +
1:108305b:                   "    fetch next 2 rows only");
1:108305b:         rs = s.executeQuery("select * from t_source");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "one"},
1:108305b:                 {"2", "two"},
1:108305b:                 {"8", "three"},
1:108305b:                 {"2", null},
1:108305b:                 {"8", null}});
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:4d044a3:     /**
1:108305b:      * {@code SELECT} subqueries with {@code ORDER BY}
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testSelectSubqueriesOrderBy() throws SQLException {
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.execute(
1:108305b:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple SELECT FromSubquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1 from t_source order by c1 desc) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8"}, {"2"}, {"1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1+1 from t_source order by c1+1 desc) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"9"}, {"3"}, {"2"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1,c2 from t_source order by c1 desc,2) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8", "three"}, {"2", "two"}, {"1", "one"}});
1:108305b: 
1:108305b:         // Complication: project away sort column
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c2 from t_source order by c1 desc) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"three"}, {"two"}, {"one"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from " +
1:108305b:             "    (select c2 from t_source order by c1 desc) s order by 1");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"one"}, {"three"}, {"two"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple VALUES FromSubquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:108305b:             "               order by 1 desc) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8", "three"}, {"2", "two"}, {"1", "one"}});
1:108305b: 
1:108305b: 
1:108305b:         /*
1:108305b:          * ORDER BY in EXISTS subquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c1)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c1 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c2 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c2 desc) order by 1 desc");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8"}, {"2"}, {"1"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * NOT EXISTS
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where not exists " +
1:108305b:             "    (select c1 from t_source order by c2 desc) order by 1 desc");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source ot where not exists " +
1:108305b:             "   (select c1 from t_source where ot.c1=(c1/2) order by c2 desc)" +
1:108305b:             "    order by 1 desc");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8"}, {"2"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * IN subquery
1:108305b:          */
1:108305b:         s.executeUpdate("insert into t values (1,10,1), (2,40,1)," +
1:108305b:                         "         (3,45,1), (4,46,1), (5,90,1)");
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by 1 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by i/5 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by j)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b: 
1:108305b:         /*
1:108305b:          * Scalar subquery inside ALL subquery with correlation
1:108305b:          */
1:108305b:         String[][] expected = new String[][]{
1:108305b:             {"1", "10", "1"},
1:108305b:             {"2", "40", "1"}};
1:108305b: 
1:108305b:         // First without any ORDER BYs
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t t_o where i <= all (" +
1:108305b:             "    select i+1 from t where i = t_o.k + (" +
1:108305b:             "        select count(*) from t) - 5)");
1:108305b:         JDBC.assertFullResultSet(rs, expected);
1:108305b: 
1:108305b:         // Then with ORDER BY at both subquery levels; should be the same result
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t t_o where i <= all (" +
1:108305b:             "    select i+1 from t where i = t_o.k + (" +
1:108305b:             "        select count(*) from t order by 1) - 5 " +
1:108305b:             "    order by 1 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, expected);
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:d35198d:     /**
1:108305b:      * {@code SELECT} subqueries with {@code ORDER BY} and {@code OFFSET/FETCH}.
1:108305b:      * <p/>
1:108305b:      * This test is a variant made my modifying {@code
1:d1120df:      * testSelectSubqueriesOrderBy} with suitable {@code OFFSET/FETCH FIRST}
1:108305b:      * clauses.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testSelectSubqueriesOrderByAndOffsetFetch()
1:108305b:             throws SQLException {
1:108305b: 
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.execute(
1:108305b:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple SELECT FromSubquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1 from t_source order by c1 desc " +
1:108305b:             "               offset 1 row) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"2"}, {"1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1+1 from t_source order by c1+1 desc " +
1:108305b:             "               fetch first 2 rows only) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"9"}, {"3"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c1,c2 from t_source order by c1 desc,2 " +
1:108305b:             "               offset 2 rows fetch next 1 row only) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1", "one"}});
1:108305b: 
1:108305b:         // Complication: project away sort column
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (select c2 from t_source order by c1 desc " +
1:108305b:             "               offset 2 rows) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"one"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from " +
1:108305b:             "    (select c2 from t_source order by c1 desc " +
1:108305b:             "     fetch first 2 row only) s order by 1");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"three"}, {"two"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple VALUES FromSubquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:108305b:             "               order by 1 desc offset 1 row) s");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"2", "two"}, {"1", "one"}});
1:108305b: 
1:108305b: 
1:108305b:         /*
1:108305b:          * ORDER BY in EXISTS subquery
1:108305b:          */
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c1 offset 1 row)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         // OFFSET so we get an empty result set:
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c1 offset 3 rows)");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c1 desc " +
1:108305b:             "     fetch first 1 row only)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         // drop order by for once:
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source offset 1 row)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"}, {"2"}, {"8"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c2 desc " +
1:108305b:             "     offset 1 row fetch first 1 row only) " +
1:108305b:             "  order by 1 desc offset 1 row fetch first 1 row only");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"2"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * NOT EXISTS
1:108305b:          */
1:108305b: 
1:108305b:         // We offset outside inner subquery, so NOT EXISTS should hold for all
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source where not exists " +
1:108305b:             "    (select c1 from t_source order by c2 desc " +
1:108305b:             "         offset 3 rows) " +
1:108305b:             "    order by 1 desc");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8"}, {"2"}, {"1"}});
1:108305b: 
1:108305b:         // should remove the hit for 1 below since we offset past it:
1:108305b:         rs = s.executeQuery(
1:108305b:             "select c1 from t_source ot where not exists " +
1:108305b:             "   (select c1 from t_source where ot.c1=(c1/2) order by c2 desc " +
1:108305b:             "        offset 1 row)" +
1:108305b:             "   order by 1 desc");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"8"}, {"2"}, {"1"}});
1:108305b: 
1:108305b:         /*
1:108305b:          * IN subquery
1:108305b:          */
1:108305b:         s.executeUpdate("insert into t values (1,10,1), (2,40,1)," +
1:108305b:                         "         (3,45,1), (4,46,1), (5,90,1)");
1:108305b: 
1:108305b:         // offset away the interesting value in the subquery:
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by 1 desc " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         // turn rs around, and we should get a hit:
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by 1 asc " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by i/5 desc " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by i/5 asc " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by j " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i in (select i/5 from t order by j desc " +
1:108305b:             "                            offset 1 row)");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         /*
1:108305b:          * Scalar subquery inside ALL subquery with correlation
1:108305b:          */
1:108305b:         String[][] expected = new String[][]{
1:108305b:             {"1", "10", "1"},
1:108305b:             {"2", "40", "1"}};
1:108305b: 
1:108305b:         // First without any ORDER BYs
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t t_o where i <= all (" +
1:108305b:             "    select i+1 from t where i = t_o.k + (" +
1:108305b:             "        select count(*) from t) - 5)");
1:108305b:         JDBC.assertFullResultSet(rs, expected);
1:108305b: 
1:108305b:         // Should give null from subquery
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t where i = (select count(*) from t order by 1 " +
1:108305b:             "                           offset 1 row)");
1:108305b:         JDBC.assertEmpty(rs);
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t t_o where i <= all (" +
1:108305b:             "    select i+1 from t where i = t_o.k + cast(null as int) +" +
1:108305b:             "         - 5 " +
1:108305b:             "    order by 1 desc)");
1:108305b:         // Notice the cast(null as int) I use above to check that the
1:108305b:         // subquery in the next query using an offset which makes the scalar
1:108305b:         // subquery return null gives the same result as this one.
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1","10","1"},
1:108305b:                 {"2","40","1"},
1:108305b:                 {"3","45","1"},
1:108305b:                 {"4","46","1"},
1:108305b:                 {"5","90","1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select * from t t_o where i <= all (" +
1:108305b:             "    select i+1 from t where i = t_o.k + (" +
1:108305b:             "        select count(*) from t order by 1 offset 1 row) - 5 " +
1:108305b:             "    order by 1 desc)");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1","10","1"},
1:108305b:                 {"2","40","1"},
1:108305b:                 {"3","45","1"},
1:108305b:                 {"4","46","1"},
1:108305b:                 {"5","90","1"}});
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:7b48c50:     /**
1:108305b:      * Test JOIN with delimited subqueries
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testJoinsWithOffsetFetch() throws SQLException {
1:108305b: 
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1:108305b: 
1:108305b:         PreparedStatement ps = prepareStatement(
1:108305b:             "select * from " +
1:108305b:             "   (select s from temp1 order by s " +
1:108305b:             "                        fetch first ? rows only) t1 join " +
1:108305b:             "   (select s from temp1 order by s offset ? row " +
1:108305b:             "                        fetch first ? row only) t2 " +
1:108305b:             "   on t1.s=t2.s");
1:108305b: 
1:108305b:         ps.setInt(1,2);
1:108305b:         ps.setInt(2,1);
1:108305b:         ps.setInt(3,1);
1:108305b: 
1:108305b:         rs = ps.executeQuery();
1:108305b: 
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"a", "a"},
1:108305b:                 {"a", "a"}});
1:108305b: 
1:108305b:         ps.setInt(1,1);
1:108305b:         rs = ps.executeQuery();
1:108305b: 
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"a", "a"}});
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:108305b:      * Test {@code ORDER BY} in a view definition
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testView() throws SQLException {
1:108305b: 
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.executeUpdate(
1:108305b:             "create view v1 as select i from t order by j desc");
1:108305b:         s.executeUpdate(
1:108305b:             "create view v2 as select i from t order by i");
1:108305b:         s.executeUpdate(
1:108305b:             "insert into t values (1,10,1), (2,40,1)," +
1:108305b:             "         (3,45,1), (4,46,1), (5,90,1)");
1:108305b:         rs = s.executeQuery(
1:108305b:             "select i from v1");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"5"},{"4"},{"3"},{"2"},{"1"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select i from v2");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"},{"2"},{"3"},{"4"},{"5"}});
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b:     /**
1:108305b:      * Test {@code ORDER BY} + {@code FETCH/OFFSET} in a view definition
1:108305b:      * <p/>
1:108305b:      * This test is a variant made my modifying {@code testView} with suitable
1:108305b:      * {@code OFFSET/FETCH FIRST} clauses.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testViewFetchOffset() throws SQLException {
1:108305b: 
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.executeUpdate(
1:108305b:             "create view v1 as select i from t order by j desc " +
1:108305b:             "                  offset 2 rows fetch first 1 row only");
1:108305b:         s.executeUpdate(
1:108305b:             "create view v2 as select i from t order by i " +
1:108305b:             "                  fetch next 2 rows only");
1:108305b: 
1:108305b:         s.executeUpdate(
1:108305b:             "insert into t values (1,10,1), (2,40,1)," +
1:108305b:             "         (3,45,1), (4,46,1), (5,90,1)");
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select i from v1");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1:108305b: 
1:108305b:         rs = s.executeQuery(
1:108305b:             "select i from v2");
1:108305b:         JDBC.assertFullResultSet(rs, new String[][]{
1:108305b:                 {"1"},{"2"}});
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:108305b:      * {@code SELECT} subqueries with {@code ORDER BY} - negative tests
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:108305b:      */
1:108305b:     public void testSelectSubqueriesOrderByNegative() throws SQLException {
1:108305b:         setAutoCommit(false);
1:108305b:         Statement s = createStatement();
1:108305b:         ResultSet rs;
1:108305b: 
1:108305b:         s.execute(
1:108305b:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple SELECT FromSubquery
1:108305b:          */
1:108305b:         assertStatementError(
1:108305b:             COLUMN_NOT_FOUND, s,
1:108305b:             "select * from (select c1 from t_source order by c3 desc) s");
1:108305b: 
1:108305b:         assertStatementError(
1:108305b:             COLUMN_OUT_OF_RANGE, s,
1:108305b:             "select * from (select c1 from t_source order by 3 desc) s");
1:108305b: 
1:108305b: 
1:108305b:         /*
1:108305b:          * Simple VALUES FromSubquery
1:108305b:          */
1:108305b:         assertStatementError(
1:108305b:             COLUMN_OUT_OF_RANGE, s,
1:108305b:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:108305b:             "               order by 3 desc) s");
1:108305b: 
1:108305b:         /*
1:108305b:          * ORDER BY in EXISTS subquery:
1:108305b:          */
1:108305b:         assertStatementError(
1:108305b:             COLUMN_NOT_FOUND, s,
1:108305b:             "select c1 from t_source where exists " +
1:108305b:             "    (select c1 from t_source order by c4)");
1:108305b: 
1:108305b:         rollback();
1:108305b:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:7b48c50:      * {@code SELECT} subqueries with {@code ORDER BY} - check sort avoidance
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:7b48c50:      */
1:7b48c50:     public void testSelectSubqueriesSortAvoidance() throws SQLException {
1:7b48c50:         setAutoCommit(false);
1:7b48c50:         Statement s = createStatement();
1:7b48c50:         ResultSet rs;
1:7b48c50:         RuntimeStatisticsParser rtsp;
1:7b48c50:         s.executeUpdate("create table ts(i int, j int)");
1:7b48c50:         PreparedStatement ps = prepareStatement("insert into ts values(?,?)");
1:7b48c50:         for (int i=0; i < 100; i++) {
1:7b48c50:             ps.setInt(1,i);
1:7b48c50:             ps.setInt(2,i*2);
1:7b48c50:             ps.execute();
1:7b48c50:         }
1:7b48c50: 
1:7b48c50:         s.executeUpdate("create unique index t_i on ts(i)");
1:7b48c50:         s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:7b48c50: 
1:7b48c50:         // ORDER BY inside a subquery should make use of index to avoid
1:7b48c50:         // sorting.
1:7b48c50:         rs = s.executeQuery("select * from (select i from ts order by i)tt");
1:7b48c50:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:7b48c50: 
1:7b48c50:         // Verify that we use the index scan here and no sorting is incurred
1:7b48c50:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TS","T_I"));
1:7b48c50:         assertFalse(rtsp.whatSortingRequired());
1:7b48c50: 
1:7b48c50:         s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:7b48c50:         rollback();
1:7b48c50:     }
1:7b48c50: 
1:108305b:     /**
1:d35198d:      * Prevent pushing of where predicates into selects with fetch
1:d35198d:      * and/or offset (DERBY-5911). Similarly, for windowed selects.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:d35198d:      */
1:d35198d:     public void testPushAvoidance() throws SQLException {
1:d35198d:         setAutoCommit(false);
1:d35198d:         Statement s = createStatement();
1:d35198d:         s.executeUpdate
1:d35198d:             ("CREATE TABLE COFFEES (COF_NAME VARCHAR(254),PRICE INTEGER)");
1:d35198d:         s.executeUpdate
1:d35198d:             ("INSERT INTO COFFEES VALUES ('Colombian', 5)");
1:d35198d:         s.executeUpdate
1:d35198d:             ("INSERT INTO COFFEES VALUES ('French_Roast', 5)");
1:d35198d:         s.executeUpdate
1:d35198d:             ("INSERT INTO COFFEES VALUES ('Colombian_Decaf', 20)");
1:d35198d: 
1:d35198d:         ResultSet rs = s.executeQuery
1:d35198d:             ("select * from " +
1:d35198d:              "    (select COF_NAME, PRICE from COFFEES " +
1:d35198d:              "     order by COF_NAME fetch next 2 rows only" +
1:d35198d:              "    ) t " +
1:d35198d:              "where t.PRICE < 10");
1:d35198d: 
1:d35198d:         JDBC.assertFullResultSet(rs, new String[][]{{"Colombian", "5"}});
1:d35198d: 
1:d35198d:         rs = s.executeQuery
1:d35198d:             ("select * from " +
1:d35198d:              "    (select COF_NAME, PRICE from COFFEES " +
1:d35198d:              "     order by COF_NAME offset 2 row" +
1:d35198d:              "    ) t " +
1:d35198d:              "where t.PRICE < 10");
1:d35198d: 
1:d35198d:         JDBC.assertFullResultSet(rs, new String[][]{{"French_Roast", "5"}});
1:d35198d: 
1:d35198d:         rs = s.executeQuery
1:d35198d:             ("select cof_name, price from " +
1:d35198d:              "   (select row_number() over() as rownum, COF_NAME, PRICE from " +
1:d35198d:              "      (select * from COFFEES order by COF_NAME) i" +
1:d35198d:              "   ) t where rownum <= 2 and PRICE < 10");
1:d35198d: 
1:d35198d:         JDBC.assertFullResultSet(rs, new String[][]{{"Colombian", "5"}});
1:d35198d: 
1:d35198d: 
1:d35198d:         rollback();
1:d35198d:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:4d044a3:      * Test nesting inside set operands, cf. this production in SQL
1:4d044a3:      * 2011, section 7.12:
1:4d044a3:      * <pre>
1:4d044a3:      * <query primary> ::=
1:4d044a3:      *      <simple table>
1:4d044a3:      *   |  <left paren> <query expression body>
1:4d044a3:      *      [ <order by clause> ] [ <result offset clause> ]
1:4d044a3:      *      [ <fetch first clause> ] <right paren>
1:4d044a3:      * </pre>
1:4d044a3:      * The corresponding production in {@code sqlgrammar.jj} is
1:4d044a3:      * {@code nonJoinQueryPrimary}.
1:b4cda60:      *
1:4d044a3:      * Cf. DERBY-6008.
1:b4cda60:      *
1:b4cda60:      * @throws java.sql.SQLException
1:4d044a3:      */
1:4d044a3:     public void testNestingInsideSetOperation() throws SQLException {
1:4d044a3:         setAutoCommit(false);
1:4d044a3:         Statement s = createStatement();
1:4d044a3: 
1:4d044a3:         s.executeUpdate("create table t1(i int, j int )");
1:4d044a3:         s.executeUpdate("create table t2(i int, j int)");
1:4d044a3: 
1:4d044a3:         s.executeUpdate("insert into t1 values (1,1),(4,8),(2,4)");
1:4d044a3:         s.executeUpdate("insert into t2 values (10,10),(40,80),(20,40)");
1:4d044a3: 
1:4d044a3:         ResultSet rs = s.executeQuery(
1:4d044a3:             "(select i from t1 order by j desc offset 1 row) union " +
1:4d044a3:             "(select i from t2 order by j desc offset 1 rows " +
1:4d044a3:                                              "fetch next 1 row only)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"1"}, {"2"}, {"20"}});
1:4d044a3: 
1:4d044a3:         // Without parentheses, expect syntax error
1:4d044a3:         assertCompileError("42X01",
1:4d044a3:                 "select i from t1 order by j desc offset 1 row union " +
1:4d044a3:                 "(select i from t2 order by j desc offset 2 rows)");
1:4d044a3: 
1:4d044a3:         // With VALUES (single) instead of SELECT:
1:4d044a3:         // Single values exercise changes in RowResultSetNode
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:             "(values 1 order by 1 fetch first 1 row only) union " +
1:4d044a3:             "(select i from t2 order by j desc offset 2 rows)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"1"}, {"10"}});
1:4d044a3: 
1:4d044a3:         // With VALUES (single) instead of SELECT and duplicate ordering key
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:             "(values 1 order by 1,1 fetch first 1 row only) union " +
1:4d044a3:             "(select i from t2 order by j desc offset 2 rows)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"1"}, {"10"}});
1:4d044a3: 
1:4d044a3:         // With VALUES (multiple) instead of SELECT
1:4d044a3:         // Multiples values exercise changes in SetOperatorNode when used in
1:4d044a3:         // table value constructor context (UNION).
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:             "(values 1,2 order by 1 desc offset 1 row " +
1:4d044a3:             "                       fetch first 1 row only)" +
1:4d044a3:             " union (select i from t2 order by j desc offset 2 rows)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"1"}, {"10"}});
1:4d044a3: 
1:4d044a3:         // With VALUES (multiple) instead of SELECT plus duplicate ordering
1:4d044a3:         // key
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:             "(values 1,2 order by 1,1 offset 1 row fetch first 1 row only)" +
1:4d044a3:             " union (select i from t2 order by j desc offset 2 rows)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"2"}, {"10"}});
1:4d044a3: 
1:4d044a3:         // Intersect and except
1:4d044a3:         s.executeUpdate(
1:4d044a3:                 "create table countries(name varchar(20), " +
1:4d044a3:                 "                       population int, " +
1:4d044a3:                 "                       area int)");
1:4d044a3: 
1:4d044a3:         s.executeUpdate("insert into countries values" +
1:4d044a3:                 "('Norway', 5033675, 385252)," +
1:4d044a3:                 "('Sweden', 9540065, 449964)," +
1:4d044a3:                 "('Denmark', 5580413, 42894)," +
1:4d044a3:                 "('Iceland', 320060, 103001)," +
1:4d044a3:                 "('Liechtenstein', 36281, 160)");
1:4d044a3: 
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:            "(select name from countries " +
1:4d044a3:            "    order by population desc fetch first 2 rows only)" +
1:4d044a3:            " intersect " +
1:4d044a3:            "(select name from countries " +
1:4d044a3:            "    order by area desc fetch first 2 rows only)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"Sweden"}});
1:4d044a3: 
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:            "(values ('Norway', 5033675, 385252), " +
1:4d044a3:            "        ('Sweden', 9540065, 449964)," +
1:4d044a3:            "        ('Denmark', 5580413, 42894)," +
1:4d044a3:            "        ('Iceland', 320060, 103001)," +
1:4d044a3:            "        ('Liechtenstein', 36281, 160)" +
1:4d044a3:            "    order by 2 desc fetch first 3 rows only)" +
1:4d044a3:            " intersect " +
1:4d044a3:            "(select * from countries " +
1:4d044a3:            "    order by area desc fetch first 3 rows only)");
1:4d044a3:         // Note: we use 3 rows here to check that both sorts work the way they
1:4d044a3:         // should: at the lowest level, the "order by 2 desc", then the
1:4d044a3:         // "fetch first" of only three of those rows, then on top the ascending
1:4d044a3:         // sort on all columns to get the data ready for the intersect.
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"Norway", "5033675", "385252"},
1:4d044a3:             {"Sweden", "9540065", "449964"}});
1:4d044a3: 
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:            "(values ('Norway', 5033675, 385252)" +
1:4d044a3:            "    order by 2 desc fetch first 3 rows only)" +
1:4d044a3:            " intersect " +
1:4d044a3:            "(values ('Norway', 5033675, 385252))");
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"Norway", "5033675", "385252"}});
1:4d044a3: 
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:            "(select name from countries " +
1:4d044a3:            "    order by population desc fetch first 2 rows only)" +
1:4d044a3:            " except " +
1:4d044a3:            "(select name from countries " +
1:4d044a3:            "    order by area desc fetch first 2 rows only)");
1:4d044a3: 
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"Denmark"}});
1:4d044a3: 
1:4d044a3:         rs = s.executeQuery(
1:4d044a3:            "(values ('Norway', 5033675, 385252), " +
1:4d044a3:            "        ('Sweden', 9540065, 449964)," +
1:4d044a3:            "        ('Denmark', 5580413, 42894)," +
1:4d044a3:            "        ('Iceland', 320060, 103001)," +
1:4d044a3:            "        ('Liechtenstein', 36281, 160)" +
1:4d044a3:            "    order by 2 desc fetch first 3 rows only)" +
1:4d044a3:            " except " +
1:4d044a3:            "(select * from countries " +
1:4d044a3:            "    order by area desc fetch first 3 rows only)");
1:4d044a3:         JDBC.assertFullResultSet(rs, new String[][]{
1:4d044a3:             {"Denmark", "5580413", "42894"}});
1:4d044a3: 
1:4d044a3:         rollback();
1:4d044a3:     }
1:576d3b7: 
1:108305b:     /**
1:b4cda60:      * Nested query expression body, with each level contributing to the set of
1:b4cda60:      * ORDER BY and/or OFFSET/FETCH FIRST clauses.
1:b4cda60:      *
1:b4cda60:      * Cf. these productions in SQL 2011, section 7.11:
1:b4cda60:      *
1:b4cda60:      * <pre>
1:b4cda60:      * <query expression> ::=
1:b4cda60:      *    [ <with clause> ] <query expression body>
1:b4cda60:      *    [ <order by clause> ] [ <result offset clause> ]
1:b4cda60:      *    [ <fetch first clause> ]
1:b4cda60:      *
1:b4cda60:      * <query expression body> ::=
1:b4cda60:      *     <query term> ...
1:b4cda60:      * </pre>
1:b4cda60:      *
1:b4cda60:      * One of the productions of {@code <query expression body>}, is
1:b4cda60:      *
1:b4cda60:      * <pre>
1:dbed020:      *    &lt;left paren&gt; &lt;query expression body&gt;
1:b4cda60:      *    [ <order by clause> ] [ <result offset clause> ]
1:b4cda60:      *    [ <fetch first clause> ] <right paren>
1:b4cda60:      * </pre>
1:b4cda60:      * so our clauses nests to arbitrary depth given enough parentheses,
1:b4cda60:      * including ORDER BY and OFFSET/FETCH FIRST clauses. This nesting
1:b4cda60:      * did not work correctly, cf. DERBY-6378.
1:b4cda60:      *
1:b4cda60:      * The corresponding productions in {@code sqlgrammar.jj} is
1:b4cda60:      * {@code queryExpression} and {@code nonJoinQueryPrimary}.
1:b4cda60:      *
1:b4cda60:      * @throws Exception
1:b4cda60:      */
1:b4cda60:     public void testDerby6378() throws Exception
1:b4cda60:     {
1:b4cda60:         setAutoCommit(false);
1:b4cda60:         Statement stm = createStatement();
1:b4cda60:         stm.executeUpdate("create table t1 (a int, b bigint)");
1:b4cda60:         stm.executeUpdate("delete from t1");
1:b4cda60:         stm.executeUpdate("insert into t1 values " +
1:b4cda60:                 "(1,-10), (2,-11), (3,-9), (4,-20), (5,-1)");
1:b4cda60: 
1:b4cda60:         queryAndCheck(stm,
1:b4cda60:                 "(select * from t1 offset 1 row fetch first 1 row only)",
1:b4cda60:                 new String [][] {{"2","-11"}});
1:b4cda60: 
1:b4cda60:         queryAndCheck(stm,
1:b4cda60:                 "(select * from t1 order by a desc fetch first 3 rows only) " +
1:b4cda60:                 "     offset 1 row fetch first 1 row only",
1:b4cda60:                 new String [][] {{"4","-20"}});
1:b4cda60: 
1:b4cda60:         queryAndCheck(stm,
1:b4cda60:                 "((select * from t1 order by a desc) " +
1:b4cda60:                 "     fetch first 3 rows only)",
1:b4cda60:                 new String [][] {{"5","-1"}, {"4","-20"}, {"3","-9"}});
1:b4cda60: 
1:b4cda60:         queryAndCheck(stm,
1:b4cda60:                 "((((select * from t1 order by a desc) " +
1:b4cda60:                 "        fetch first 3 rows only)) " +
1:b4cda60:                 "    order by b) " +
1:b4cda60:                 "fetch first 1 row only",
1:b4cda60:                 new String [][] {{"4","-20"},});
1:b4cda60: 
1:b4cda60:         queryAndCheck(
1:b4cda60:             stm,
1:b4cda60:             "(((((values (1,-10), (2,-11), (3,-9), (4,-20), (5,-1))" +
1:b4cda60:             "            order by 1 desc) " +
1:b4cda60:             "        fetch first 3 rows only)) " +
1:b4cda60:             "    order by 2) " +
1:b4cda60:             "fetch first 1 row only",
1:b4cda60:             new String [][] {{"4","-20"},});
1:b4cda60:         rollback();
1:b4cda60:         stm.close();
1:b4cda60:     }
1:b4cda60: 
1:b4cda60:     private void queryAndCheck(
1:b4cda60:         Statement stm,
1:b4cda60:         String queryText,
1:b4cda60:         String [][] expectedRows) throws SQLException {
1:b4cda60: 
1:b4cda60:         ResultSet rs = stm.executeQuery(queryText);
1:b4cda60:         JDBC.assertFullResultSet(rs, expectedRows);
1:b4cda60:     }
1:b4cda60: 
1:108305b: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *    &lt;left paren&gt; &lt;query expression body&gt;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("OrderByAndOffsetFetchInSubqueries");
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(OrderByAndOffsetFetchInSubqueries.class)) {
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs;
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = s.executeQuery("select * from temp2b");
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      *
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Nested query expression body, with each level contributing to the set of
1:      * ORDER BY and/or OFFSET/FETCH FIRST clauses.
1:      *
1:      * Cf. these productions in SQL 2011, section 7.11:
1:      *
1:      * <pre>
1:      * <query expression> ::=
1:      *    [ <with clause> ] <query expression body>
1:      *    [ <order by clause> ] [ <result offset clause> ]
1:      *    [ <fetch first clause> ]
1:      *
1:      * <query expression body> ::=
1:      *     <query term> ...
1:      * </pre>
1:      *
1:      * One of the productions of {@code <query expression body>}, is
1:      *
1:      * <pre>
0:      *    <left paren> <query expression body
1:      *    [ <order by clause> ] [ <result offset clause> ]
1:      *    [ <fetch first clause> ] <right paren>
1:      * </pre>
1:      * so our clauses nests to arbitrary depth given enough parentheses,
1:      * including ORDER BY and OFFSET/FETCH FIRST clauses. This nesting
1:      * did not work correctly, cf. DERBY-6378.
1:      *
1:      * The corresponding productions in {@code sqlgrammar.jj} is
1:      * {@code queryExpression} and {@code nonJoinQueryPrimary}.
1:      *
1:      * @throws Exception
1:      */
1:     public void testDerby6378() throws Exception
1:     {
1:         setAutoCommit(false);
1:         Statement stm = createStatement();
1:         stm.executeUpdate("create table t1 (a int, b bigint)");
1:         stm.executeUpdate("delete from t1");
1:         stm.executeUpdate("insert into t1 values " +
1:                 "(1,-10), (2,-11), (3,-9), (4,-20), (5,-1)");
1: 
1:         queryAndCheck(stm,
1:                 "(select * from t1 offset 1 row fetch first 1 row only)",
1:                 new String [][] {{"2","-11"}});
1: 
1:         queryAndCheck(stm,
1:                 "(select * from t1 order by a desc fetch first 3 rows only) " +
1:                 "     offset 1 row fetch first 1 row only",
1:                 new String [][] {{"4","-20"}});
1: 
1:         queryAndCheck(stm,
1:                 "((select * from t1 order by a desc) " +
1:                 "     fetch first 3 rows only)",
1:                 new String [][] {{"5","-1"}, {"4","-20"}, {"3","-9"}});
1: 
1:         queryAndCheck(stm,
1:                 "((((select * from t1 order by a desc) " +
1:                 "        fetch first 3 rows only)) " +
1:                 "    order by b) " +
1:                 "fetch first 1 row only",
1:                 new String [][] {{"4","-20"},});
1: 
1:         queryAndCheck(
1:             stm,
1:             "(((((values (1,-10), (2,-11), (3,-9), (4,-20), (5,-1))" +
1:             "            order by 1 desc) " +
1:             "        fetch first 3 rows only)) " +
1:             "    order by 2) " +
1:             "fetch first 1 row only",
1:             new String [][] {{"4","-20"},});
1:         rollback();
1:         stm.close();
1:     }
1: 
1:     private void queryAndCheck(
1:         Statement stm,
1:         String queryText,
1:         String [][] expectedRows) throws SQLException {
1: 
1:         ResultSet rs = stm.executeQuery(queryText);
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:     }
1: 
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Test nesting inside set operands, cf. this production in SQL
1:      * 2011, section 7.12:
1:      * <pre>
1:      * <query primary> ::=
1:      *      <simple table>
1:      *   |  <left paren> <query expression body>
1:      *      [ <order by clause> ] [ <result offset clause> ]
1:      *      [ <fetch first clause> ] <right paren>
1:      * </pre>
1:      * The corresponding production in {@code sqlgrammar.jj} is
1:      * {@code nonJoinQueryPrimary}.
1:      * Cf. DERBY-6008.
1:      */
1:     public void testNestingInsideSetOperation() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate("create table t1(i int, j int )");
1:         s.executeUpdate("create table t2(i int, j int)");
1: 
1:         s.executeUpdate("insert into t1 values (1,1),(4,8),(2,4)");
1:         s.executeUpdate("insert into t2 values (10,10),(40,80),(20,40)");
1: 
1:         ResultSet rs = s.executeQuery(
1:             "(select i from t1 order by j desc offset 1 row) union " +
1:             "(select i from t2 order by j desc offset 1 rows " +
1:                                              "fetch next 1 row only)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"1"}, {"2"}, {"20"}});
1: 
1:         // Without parentheses, expect syntax error
1:         assertCompileError("42X01",
1:                 "select i from t1 order by j desc offset 1 row union " +
1:                 "(select i from t2 order by j desc offset 2 rows)");
1: 
1:         // With VALUES (single) instead of SELECT:
1:         // Single values exercise changes in RowResultSetNode
1:         rs = s.executeQuery(
1:             "(values 1 order by 1 fetch first 1 row only) union " +
1:             "(select i from t2 order by j desc offset 2 rows)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"1"}, {"10"}});
1: 
1:         // With VALUES (single) instead of SELECT and duplicate ordering key
1:         rs = s.executeQuery(
1:             "(values 1 order by 1,1 fetch first 1 row only) union " +
1:             "(select i from t2 order by j desc offset 2 rows)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"1"}, {"10"}});
1: 
1:         // With VALUES (multiple) instead of SELECT
1:         // Multiples values exercise changes in SetOperatorNode when used in
1:         // table value constructor context (UNION).
1:         rs = s.executeQuery(
1:             "(values 1,2 order by 1 desc offset 1 row " +
1:             "                       fetch first 1 row only)" +
1:             " union (select i from t2 order by j desc offset 2 rows)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"1"}, {"10"}});
1: 
1:         // With VALUES (multiple) instead of SELECT plus duplicate ordering
1:         // key
1:         rs = s.executeQuery(
1:             "(values 1,2 order by 1,1 offset 1 row fetch first 1 row only)" +
1:             " union (select i from t2 order by j desc offset 2 rows)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"2"}, {"10"}});
1: 
1:         // Intersect and except
1:         s.executeUpdate(
1:                 "create table countries(name varchar(20), " +
1:                 "                       population int, " +
1:                 "                       area int)");
1: 
1:         s.executeUpdate("insert into countries values" +
1:                 "('Norway', 5033675, 385252)," +
1:                 "('Sweden', 9540065, 449964)," +
1:                 "('Denmark', 5580413, 42894)," +
1:                 "('Iceland', 320060, 103001)," +
1:                 "('Liechtenstein', 36281, 160)");
1: 
1:         rs = s.executeQuery(
1:            "(select name from countries " +
1:            "    order by population desc fetch first 2 rows only)" +
1:            " intersect " +
1:            "(select name from countries " +
1:            "    order by area desc fetch first 2 rows only)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"Sweden"}});
1: 
1:         rs = s.executeQuery(
1:            "(values ('Norway', 5033675, 385252), " +
1:            "        ('Sweden', 9540065, 449964)," +
1:            "        ('Denmark', 5580413, 42894)," +
1:            "        ('Iceland', 320060, 103001)," +
1:            "        ('Liechtenstein', 36281, 160)" +
1:            "    order by 2 desc fetch first 3 rows only)" +
1:            " intersect " +
1:            "(select * from countries " +
1:            "    order by area desc fetch first 3 rows only)");
1:         // Note: we use 3 rows here to check that both sorts work the way they
1:         // should: at the lowest level, the "order by 2 desc", then the
1:         // "fetch first" of only three of those rows, then on top the ascending
1:         // sort on all columns to get the data ready for the intersect.
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"Norway", "5033675", "385252"},
1:             {"Sweden", "9540065", "449964"}});
1: 
1:         rs = s.executeQuery(
1:            "(values ('Norway', 5033675, 385252)" +
1:            "    order by 2 desc fetch first 3 rows only)" +
1:            " intersect " +
1:            "(values ('Norway', 5033675, 385252))");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"Norway", "5033675", "385252"}});
1: 
1:         rs = s.executeQuery(
1:            "(select name from countries " +
1:            "    order by population desc fetch first 2 rows only)" +
1:            " except " +
1:            "(select name from countries " +
1:            "    order by area desc fetch first 2 rows only)");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"Denmark"}});
1: 
1:         rs = s.executeQuery(
1:            "(values ('Norway', 5033675, 385252), " +
1:            "        ('Sweden', 9540065, 449964)," +
1:            "        ('Denmark', 5580413, 42894)," +
1:            "        ('Iceland', 320060, 103001)," +
1:            "        ('Liechtenstein', 36281, 160)" +
1:            "    order by 2 desc fetch first 3 rows only)" +
1:            " except " +
1:            "(select * from countries " +
1:            "    order by area desc fetch first 3 rows only)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:             {"Denmark", "5580413", "42894"}});
1: 
1:         rollback();
1:     }
commit:d35198d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Prevent pushing of where predicates into selects with fetch
1:      * and/or offset (DERBY-5911). Similarly, for windowed selects.
1:      */
1:     public void testPushAvoidance() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.executeUpdate
1:             ("CREATE TABLE COFFEES (COF_NAME VARCHAR(254),PRICE INTEGER)");
1:         s.executeUpdate
1:             ("INSERT INTO COFFEES VALUES ('Colombian', 5)");
1:         s.executeUpdate
1:             ("INSERT INTO COFFEES VALUES ('French_Roast', 5)");
1:         s.executeUpdate
1:             ("INSERT INTO COFFEES VALUES ('Colombian_Decaf', 20)");
1: 
1:         ResultSet rs = s.executeQuery
1:             ("select * from " +
1:              "    (select COF_NAME, PRICE from COFFEES " +
1:              "     order by COF_NAME fetch next 2 rows only" +
1:              "    ) t " +
1:              "where t.PRICE < 10");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{{"Colombian", "5"}});
1: 
1:         rs = s.executeQuery
1:             ("select * from " +
1:              "    (select COF_NAME, PRICE from COFFEES " +
1:              "     order by COF_NAME offset 2 row" +
1:              "    ) t " +
1:              "where t.PRICE < 10");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{{"French_Roast", "5"}});
1: 
1:         rs = s.executeQuery
1:             ("select cof_name, price from " +
1:              "   (select row_number() over() as rownum, COF_NAME, PRICE from " +
1:              "      (select * from COFFEES order by COF_NAME) i" +
1:              "   ) t where rownum <= 2 and PRICE < 10");
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{{"Colombian", "5"}});
1: 
1: 
1:         rollback();
1:     }
commit:7b48c50
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * {@code SELECT} subqueries with {@code ORDER BY} - check sort avoidance
1:      */
1:     public void testSelectSubqueriesSortAvoidance() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1:         RuntimeStatisticsParser rtsp;
1:         s.executeUpdate("create table ts(i int, j int)");
1:         PreparedStatement ps = prepareStatement("insert into ts values(?,?)");
1:         for (int i=0; i < 100; i++) {
1:             ps.setInt(1,i);
1:             ps.setInt(2,i*2);
1:             ps.execute();
1:         }
1: 
1:         s.executeUpdate("create unique index t_i on ts(i)");
1:         s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         // ORDER BY inside a subquery should make use of index to avoid
1:         // sorting.
1:         rs = s.executeQuery("select * from (select i from ts order by i)tt");
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1: 
1:         // Verify that we use the index scan here and no sorting is incurred
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("TS","T_I"));
1:         assertFalse(rtsp.whatSortingRequired());
1: 
1:         s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:         rollback();
1:     }
1: 
commit:d1120df
/////////////////////////////////////////////////////////////////////////
1:      * testSelectSubqueriesOrderBy} with suitable {@code OFFSET/FETCH FIRST}
commit:108305b
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.OrderByAndOffsetFetchInSubqueries
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.SQLException;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1: 
1: /**
1:  * Tests for DERBY-4397 Allow {@code ORDER BY} in subqueries
1:  * and       DERBY-4398 Allow {@code OFFSET/FETCH} in subqueries.
1:  */
1: public class OrderByAndOffsetFetchInSubqueries extends BaseJDBCTestCase {
1: 
1:     final static String SYNTAX_ERROR = "42X01";
1:     final static String COLUMN_NOT_FOUND = "42X04";
1:     final static String COLUMN_OUT_OF_RANGE = "42X77";
1:     final static String ORDER_BY_COLUMN_NOT_FOUND = "42X78";
1: 
1:     public OrderByAndOffsetFetchInSubqueries(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      *
1:      * @return A suite containing embedded and client suites.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("OrderByAndOffsetFetchInSubqueries");
1: 
1:         suite.addTest(makeSuite());
1:         suite.addTest(
1:              TestConfiguration.clientServerDecorator(makeSuite()));
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * Construct suite of tests
1:      *
1:      * @return A suite containing the test cases.
1:      */
1:     private static Test makeSuite()
1:     {
1:         return new CleanDatabaseTestSetup(
0:             new TestSuite(OrderByAndOffsetFetchInSubqueries.class)) {
1:                 protected void decorateSQL(Statement s)
1:                         throws SQLException {
1:                     getConnection().setAutoCommit(false);
1: 
1:                     s.execute("create table temp1(s varchar(10))");
1: 
1:                     // GENERATED ALWAYS AS IDENTITY
1:                     s.execute("create table temp2(" +
1:                               "i integer not null " +
1:                               "    generated always as identity," +
1:                               "s varchar(10))");
1:                     s.execute("create table temp2b(" +
1:                               "i integer not null " +
1:                               "    generated always as identity," +
1:                               "s varchar(10))");
1:                     // DEFAULT value
1:                     s.execute("create table temp3(" +
1:                               "i integer not null " +
1:                               "    generated always as identity," +
1:                               "s varchar(10)," +
1:                               "j integer not null " +
1:                               "    default 66," +
1:                               "t varchar(10))");
1: 
1:                     // GENERATED ALWAYS AS (expression)
1:                     s.execute("create table temp4(" +
1:                               "i integer not null " +
1:                               "    generated always as identity," +
1:                               "s varchar(10)," +
1:                               "j integer not null " +
1:                               "    generated always as (2*i)," +
1:                               "t varchar(10))");
1: 
1: 
1:                     s.execute("create table t01(c1 int)");
1:                     s.execute("create table t02(c2 int)");
1: 
1:                     s.execute("create table t_source(c1 int, c2 varchar(10))");
1:                     s.execute("create table t(i int not null, " +
1:                               "               constraint c unique (i), " +
1:                               "               j int, k int)");
1: 
1:                     getConnection().commit();
1:                 }
1:             };
1:     }
1: 
1:     /**
1:      * Test {@code INSERT INTO t SELECT .. FROM .. ORDER BY}.
1:      */
1:     public void testInsertSelectOrderBy() throws SQLException {
1:         //
1:         // Shows that DERBY-4 is now solved.
1:         //
1:         setAutoCommit(false);
1:         Statement s = createStatement();
0:         ResultSet rs = null;
1: 
1:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1:         s.execute("insert into temp2(s) select s from temp1 order by s");
1:         s.execute("insert into temp2(s) select s as a1 from temp1 order by a1");
1:         s.execute("insert into temp2(s) select * from temp1 order by s");
1: 
1:         rs = s.executeQuery("select * from temp2");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "a"},
1:                 {"2", "a"},
1:                 {"3", "b"},
1:                 {"4", "c"},
1:                 {"5", "x"},
1:                 {"6", "a"},
1:                 {"7", "a"},
1:                 {"8", "b"},
1:                 {"9", "c"},
1:                 {"10", "x"},
1:                 {"11", "a"},
1:                 {"12", "a"},
1:                 {"13", "b"},
1:                 {"14", "c"},
1:                 {"15", "x"}});
1: 
1:         rs = s.executeQuery("select * from temp2 order by i");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "a"},
1:                 {"2", "a"},
1:                 {"3", "b"},
1:                 {"4", "c"},
1:                 {"5", "x"},
1:                 {"6", "a"},
1:                 {"7", "a"},
1:                 {"8", "b"},
1:                 {"9", "c"},
1:                 {"10", "x"},
1:                 {"11", "a"},
1:                 {"12", "a"},
1:                 {"13", "b"},
1:                 {"14", "c"},
1:                 {"15", "x"}});
1: 
1:         s.execute("insert into temp2(s) select s as a1 from temp1 order by s");
1: 
1:         // This should be rejected as "no such column" errors:
1:         assertStatementError(
1:             COLUMN_NOT_FOUND, s,
1:             "insert into temp2(s) select s as a1 from temp1 order by no_such");
1: 
1:         // A similar example, but with integers rather than strings, and some
1:         // intermediate select statements to show that the ordering is working.
1:         //
1:         s.execute("insert into t01 values (50), (10), (1000), (15), (51)");
1: 
1:         rs = s.executeQuery("select * from t01");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"50"},
1:                 {"10"},
1:                 {"1000"},
1:                 {"15"},
1:                 {"51"}});
1: 
1: 
1:         s.execute("insert into t02 select * from t01 order by c1");
1:         s.execute("insert into t02 select * from t01");
1:         s.execute("insert into t02 select * from t01 order by c1");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"10"},
1:                 {"15"},
1:                 {"50"},
1:                 {"51"},
1:                 {"1000"},
1:                 {"50"},
1:                 {"10"},
1:                 {"1000"},
1:                 {"15"},
1:                 {"51"},
1:                 {"10"},
1:                 {"15"},
1:                 {"50"},
1:                 {"51"},
1:                 {"1000"}});
1: 
1:         // Combining ORDER BY and VALUES is not legal SQL, cf.  SQL 2008,
1:         // section 14.11, Syntactic Rule 17: "A <query expression> simply
1:         // contained in a <from subquery> shall not be a <table value
1:         // constructor>. See also discussion in JIRA on DERBY-4413
1:         // (2009-OCT-23).
1:         //
1:         assertStatementError(
1:              SYNTAX_ERROR, s,
1:              "insert into t02 values 66 order by 1");
1:         assertStatementError(
1:              SYNTAX_ERROR, s,
1:              "insert into t02 values (901), (920), (903) order by 1");
1: 
1:         // But this should work:
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate("insert into t02 select 900 from sys.systables " +
1:                         "                union values 66 order by 1");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                  {"66"},
1:                  {"900"}});
1: 
1:         // other way around:
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate(
1:             "insert into t02 values 66 " +
1:             "       union select 900 from sys.systables order by 1");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                  {"66"},
1:                  {"900"}});
1: 
1:         // and, somewhat perversely (since a plain "values 66 order by 1" is
1:         // illegal), this:
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate("insert into t02 values 66 " +
1:                         "       union values 66 order by 1");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                  {"66"}});
1: 
1: 
1:         // UNION
1:         //
1:         // ok:
1:         s.execute("delete from t02");
1:         s.execute("insert into t02 select * from t01 union all " +
1:                   "                select * from t01 order by c1");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"10"},
1:                 {"10"},
1:                 {"15"},
1:                 {"15"},
1:                 {"50"},
1:                 {"50"},
1:                 {"51"},
1:                 {"51"},
1:                 {"1000"},
1:                 {"1000"}});
1: 
1:         // Not ok (c1 is not a column in the union result set, since t02 has
1:         // column c02.
1:         assertStatementError(
1:             ORDER_BY_COLUMN_NOT_FOUND, s,
1:             "insert into t02 select * from t01 union all " +
1:             "                select * from t02 order by c1");
1: 
1: 
1:         // Complication: project away sort column
1:         s.execute("delete from t02");
1:         s.execute("insert into t_source " +
1:                   "    values (1, 'one'), (2, 'two'), (8, 'three')");
1:         s.execute("insert into t_source(c1) " +
1:                   "    select c1 from t_source order by c2 desc");
1:         rs = s.executeQuery("select * from t_source");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "one"},
1:                 {"2", "two"},
1:                 {"8", "three"},
1:                 {"2", null},
1:                 {"8", null},
1:                 {"1", null}});
1: 
1:         // DERBY-4496
1:         s.executeUpdate("create table t4496(x varchar(100))");
1:         s.execute("insert into t4496(x) select ibmreqd from " +
1:                   "    (select * from sysibm.sysdummy1" +
1:                   "         order by length(ibmreqd)) t1");
1: 
1:         JDBC.assertFullResultSet(
1:             s.executeQuery("select * from t4496"),
1:             new String[][]{{"Y"}});
1: 
1:         rollback();
1:     }
1: 
1:     /**
1:      * Same test as {@code testInsertSelectOrderBy} but with use of
1:      * {@code OFFSET/FETCH FIRST}.
1:      * <p/>
1:      * Test {@code INSERT INTO t SELECT .. FROM .. ORDER BY} + {@code OFFSET
1:      * FETCH}
1:      * <p/>
1:      * This test is a variant made my modifying {@code testInsertSelectOrderBy}
1:      * with suitable {@code OFFSET/FETCH FIRST} clauses.
1:      */
1:     public void testInsertSelectOrderByOffsetFetch() throws SQLException {
1:         //
1:         // Shows that DERBY-4 is now solved.
1:         //
1:         setAutoCommit(false);
1:         Statement s = createStatement();
0:         ResultSet rs = null;
1: 
1:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1:         s.execute("insert into temp2b(s) select s from temp1 order by s " +
1:                   "    offset 1 rows fetch next 4 rows only");
1: 
1:         JDBC.assertFullResultSet(
1:             s.executeQuery("select * from temp2b"),
1:             new String[][]{
1:                 {"1", "a"},
1:                 {"2", "b"},
1:                 {"3", "c"},
1:                 {"4", "x"}});
1: 
1:         s.execute(
1:             "insert into temp2b(s) select s as a1 from temp1 order by a1" +
1:             "    offset 1 rows fetch next 4 rows only");
1: 
1:         s.execute(
1:             "insert into temp2b(s) select * from temp1 order by s " +
1:             "    offset 1 rows fetch next 4 rows only");
1: 
0:         rs = s.executeQuery("select * from temp2b");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "a"},
1:                 {"2", "b"},
1:                 {"3", "c"},
1:                 {"4", "x"},
1:                 {"5", "a"},
1:                 {"6", "b"},
1:                 {"7", "c"},
1:                 {"8", "x"},
1:                 {"9", "a"},
1:                 {"10", "b"},
1:                 {"11", "c"},
1:                 {"12", "x"}});
1: 
1:         rs = s.executeQuery("select * from temp2b order by i");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "a"},
1:                 {"2", "b"},
1:                 {"3", "c"},
1:                 {"4", "x"},
1:                 {"5", "a"},
1:                 {"6", "b"},
1:                 {"7", "c"},
1:                 {"8", "x"},
1:                 {"9", "a"},
1:                 {"10", "b"},
1:                 {"11", "c"},
1:                 {"12", "x"}});
1: 
1: 
1:         // A similar example, but with integers rather than strings, and some
1:         // intermediate select statements to show that the ordering is working.
1:         //
1:         s.execute("insert into t01 values (50), (10), (1000), (15), (51)");
1: 
1:         rs = s.executeQuery("select * from t01");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"50"},
1:                 {"10"},
1:                 {"1000"},
1:                 {"15"},
1:                 {"51"}});
1: 
1: 
1:         s.execute(
1:             "insert into t02 select * from t01 order by c1 " +
1:             "    fetch first 2 rows only");
1:         s.execute(
1:             "insert into t02 select * from t01");
1:         s.execute(
1:             "insert into t02 select * from t01 order by c1 offset 0 rows");
1: 
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"10"},
1:                 {"15"},
1:                 {"50"},
1:                 {"10"},
1:                 {"1000"},
1:                 {"15"},
1:                 {"51"},
1:                 {"10"},
1:                 {"15"},
1:                 {"50"},
1:                 {"51"},
1:                 {"1000"}});
1: 
1:         // Illegal context
1:         assertStatementError(
1:              SYNTAX_ERROR, s,
1:              "insert into t02 values 66 offset 1 row");
1: 
1:         // But this should work:
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate(
1:             "insert into t02 select 900 from sys.systables " +
1:             "                union values 66 order by 1 offset 1 row");
1: 
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                  {"900"}});
1: 
1:         // other way around:
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate(
1:             "insert into t02 values 66 " +
1:             "       union select 900 from sys.systables fetch next 1 row only");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                  {"66"}});
1: 
1:         s.executeUpdate("delete from t02");
1:         s.executeUpdate("insert into t02 select * from (values 3,4,5 )v " +
1:                         "    order by 1 offset 1 row fetch next 2 rows only");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"4"},
1:                 {"5"}});
1: 
1: 
1:         // UNION
1:         //
1:         // ok:
1:         s.execute("delete from t02");
1:         s.execute("insert into t02 select * from t01 union all " +
1:                   "                select * from t01 order by c1 " +
1:                   "                fetch next 4 rows only");
1:         rs = s.executeQuery("select * from t02");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"10"},
1:                 {"10"},
1:                 {"15"},
1:                 {"15"}});
1: 
1:         // EXCEPT
1:         s.execute("delete from t01");
1:         s.execute("insert into t02 values 6,7");
1:         s.execute("insert into t01 select * from t02 except " +
1:                   "                values 10 order by 1 offset 1 row");
1:         rs = s.executeQuery("select * from t01");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"7"},
1:                 {"15"}});
1: 
1:         // Complication: project away sort column
1:         s.execute("delete from t02");
1:         s.execute("insert into t_source " +
1:                   "    values (1, 'one'), (2, 'two'), (8, 'three')");
1:         s.execute("insert into t_source(c1) " +
1:                   "    select c1 from t_source order by c2 desc " +
1:                   "    fetch next 2 rows only");
1:         rs = s.executeQuery("select * from t_source");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "one"},
1:                 {"2", "two"},
1:                 {"8", "three"},
1:                 {"2", null},
1:                 {"8", null}});
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * {@code SELECT} subqueries with {@code ORDER BY}
1:      */
1:     public void testSelectSubqueriesOrderBy() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.execute(
1:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1: 
1:         /*
1:          * Simple SELECT FromSubquery
1:          */
1:         rs = s.executeQuery(
1:             "select * from (select c1 from t_source order by c1 desc) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8"}, {"2"}, {"1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from (select c1+1 from t_source order by c1+1 desc) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"9"}, {"3"}, {"2"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from (select c1,c2 from t_source order by c1 desc,2) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8", "three"}, {"2", "two"}, {"1", "one"}});
1: 
1:         // Complication: project away sort column
1:         rs = s.executeQuery(
1:             "select * from (select c2 from t_source order by c1 desc) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"three"}, {"two"}, {"one"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from " +
1:             "    (select c2 from t_source order by c1 desc) s order by 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"one"}, {"three"}, {"two"}});
1: 
1:         /*
1:          * Simple VALUES FromSubquery
1:          */
1:         rs = s.executeQuery(
1:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:             "               order by 1 desc) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8", "three"}, {"2", "two"}, {"1", "one"}});
1: 
1: 
1:         /*
1:          * ORDER BY in EXISTS subquery
1:          */
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c1)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c1 desc)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c2 desc)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c2 desc) order by 1 desc");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8"}, {"2"}, {"1"}});
1: 
1:         /*
1:          * NOT EXISTS
1:          */
1:         rs = s.executeQuery(
1:             "select c1 from t_source where not exists " +
1:             "    (select c1 from t_source order by c2 desc) order by 1 desc");
1:         JDBC.assertEmpty(rs);
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source ot where not exists " +
1:             "   (select c1 from t_source where ot.c1=(c1/2) order by c2 desc)" +
1:             "    order by 1 desc");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8"}, {"2"}});
1: 
1:         /*
1:          * IN subquery
1:          */
1:         s.executeUpdate("insert into t values (1,10,1), (2,40,1)," +
1:                         "         (3,45,1), (4,46,1), (5,90,1)");
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by 1 desc)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by i/5 desc)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by j)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1: 
1:         /*
1:          * Scalar subquery inside ALL subquery with correlation
1:          */
1:         String[][] expected = new String[][]{
1:             {"1", "10", "1"},
1:             {"2", "40", "1"}};
1: 
1:         // First without any ORDER BYs
1:         rs = s.executeQuery(
1:             "select * from t t_o where i <= all (" +
1:             "    select i+1 from t where i = t_o.k + (" +
1:             "        select count(*) from t) - 5)");
1:         JDBC.assertFullResultSet(rs, expected);
1: 
1:         // Then with ORDER BY at both subquery levels; should be the same result
1:         rs = s.executeQuery(
1:             "select * from t t_o where i <= all (" +
1:             "    select i+1 from t where i = t_o.k + (" +
1:             "        select count(*) from t order by 1) - 5 " +
1:             "    order by 1 desc)");
1:         JDBC.assertFullResultSet(rs, expected);
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * {@code SELECT} subqueries with {@code ORDER BY} and {@code OFFSET/FETCH}.
1:      * <p/>
1:      * This test is a variant made my modifying {@code
0:      * testSelectSubqueriesOrderBy} with suitable {@codeOFFSET/FETCH FIRST}
1:      * clauses.
1:      */
1:     public void testSelectSubqueriesOrderByAndOffsetFetch()
1:             throws SQLException {
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.execute(
1:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1: 
1:         /*
1:          * Simple SELECT FromSubquery
1:          */
1:         rs = s.executeQuery(
1:             "select * from (select c1 from t_source order by c1 desc " +
1:             "               offset 1 row) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"2"}, {"1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from (select c1+1 from t_source order by c1+1 desc " +
1:             "               fetch first 2 rows only) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"9"}, {"3"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from (select c1,c2 from t_source order by c1 desc,2 " +
1:             "               offset 2 rows fetch next 1 row only) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1", "one"}});
1: 
1:         // Complication: project away sort column
1:         rs = s.executeQuery(
1:             "select * from (select c2 from t_source order by c1 desc " +
1:             "               offset 2 rows) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"one"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from " +
1:             "    (select c2 from t_source order by c1 desc " +
1:             "     fetch first 2 row only) s order by 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"three"}, {"two"}});
1: 
1:         /*
1:          * Simple VALUES FromSubquery
1:          */
1:         rs = s.executeQuery(
1:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:             "               order by 1 desc offset 1 row) s");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"2", "two"}, {"1", "one"}});
1: 
1: 
1:         /*
1:          * ORDER BY in EXISTS subquery
1:          */
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c1 offset 1 row)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         // OFFSET so we get an empty result set:
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c1 offset 3 rows)");
1:         JDBC.assertEmpty(rs);
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c1 desc " +
1:             "     fetch first 1 row only)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         // drop order by for once:
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source offset 1 row)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}, {"2"}, {"8"}});
1: 
1:         rs = s.executeQuery(
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c2 desc " +
1:             "     offset 1 row fetch first 1 row only) " +
1:             "  order by 1 desc offset 1 row fetch first 1 row only");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"2"}});
1: 
1:         /*
1:          * NOT EXISTS
1:          */
1: 
1:         // We offset outside inner subquery, so NOT EXISTS should hold for all
1:         rs = s.executeQuery(
1:             "select c1 from t_source where not exists " +
1:             "    (select c1 from t_source order by c2 desc " +
1:             "         offset 3 rows) " +
1:             "    order by 1 desc");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8"}, {"2"}, {"1"}});
1: 
1:         // should remove the hit for 1 below since we offset past it:
1:         rs = s.executeQuery(
1:             "select c1 from t_source ot where not exists " +
1:             "   (select c1 from t_source where ot.c1=(c1/2) order by c2 desc " +
1:             "        offset 1 row)" +
1:             "   order by 1 desc");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"8"}, {"2"}, {"1"}});
1: 
1:         /*
1:          * IN subquery
1:          */
1:         s.executeUpdate("insert into t values (1,10,1), (2,40,1)," +
1:                         "         (3,45,1), (4,46,1), (5,90,1)");
1: 
1:         // offset away the interesting value in the subquery:
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by 1 desc " +
1:             "                            offset 1 row)");
1:         JDBC.assertEmpty(rs);
1: 
1:         // turn rs around, and we should get a hit:
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by 1 asc " +
1:             "                            offset 1 row)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by i/5 desc " +
1:             "                            offset 1 row)");
1:         JDBC.assertEmpty(rs);
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by i/5 asc " +
1:             "                            offset 1 row)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by j " +
1:             "                            offset 1 row)");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"1", "10", "1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t where i in (select i/5 from t order by j desc " +
1:             "                            offset 1 row)");
1:         JDBC.assertEmpty(rs);
1: 
1:         /*
1:          * Scalar subquery inside ALL subquery with correlation
1:          */
1:         String[][] expected = new String[][]{
1:             {"1", "10", "1"},
1:             {"2", "40", "1"}};
1: 
1:         // First without any ORDER BYs
1:         rs = s.executeQuery(
1:             "select * from t t_o where i <= all (" +
1:             "    select i+1 from t where i = t_o.k + (" +
1:             "        select count(*) from t) - 5)");
1:         JDBC.assertFullResultSet(rs, expected);
1: 
1:         // Should give null from subquery
1:         rs = s.executeQuery(
1:             "select * from t where i = (select count(*) from t order by 1 " +
1:             "                           offset 1 row)");
1:         JDBC.assertEmpty(rs);
1: 
1:         rs = s.executeQuery(
1:             "select * from t t_o where i <= all (" +
1:             "    select i+1 from t where i = t_o.k + cast(null as int) +" +
1:             "         - 5 " +
1:             "    order by 1 desc)");
1:         // Notice the cast(null as int) I use above to check that the
1:         // subquery in the next query using an offset which makes the scalar
1:         // subquery return null gives the same result as this one.
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1","10","1"},
1:                 {"2","40","1"},
1:                 {"3","45","1"},
1:                 {"4","46","1"},
1:                 {"5","90","1"}});
1: 
1:         rs = s.executeQuery(
1:             "select * from t t_o where i <= all (" +
1:             "    select i+1 from t where i = t_o.k + (" +
1:             "        select count(*) from t order by 1 offset 1 row) - 5 " +
1:             "    order by 1 desc)");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1","10","1"},
1:                 {"2","40","1"},
1:                 {"3","45","1"},
1:                 {"4","46","1"},
1:                 {"5","90","1"}});
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * Test JOIN with delimited subqueries
1:      */
1:     public void testJoinsWithOffsetFetch() throws SQLException {
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.execute("insert into temp1 values 'x','a','c','b','a'");
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "select * from " +
1:             "   (select s from temp1 order by s " +
1:             "                        fetch first ? rows only) t1 join " +
1:             "   (select s from temp1 order by s offset ? row " +
1:             "                        fetch first ? row only) t2 " +
1:             "   on t1.s=t2.s");
1: 
1:         ps.setInt(1,2);
1:         ps.setInt(2,1);
1:         ps.setInt(3,1);
1: 
1:         rs = ps.executeQuery();
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"a", "a"},
1:                 {"a", "a"}});
1: 
1:         ps.setInt(1,1);
1:         rs = ps.executeQuery();
1: 
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"a", "a"}});
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * Test {@code ORDER BY} in a view definition
1:      */
1:     public void testView() throws SQLException {
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.executeUpdate(
1:             "create view v1 as select i from t order by j desc");
1:         s.executeUpdate(
1:             "create view v2 as select i from t order by i");
1:         s.executeUpdate(
1:             "insert into t values (1,10,1), (2,40,1)," +
1:             "         (3,45,1), (4,46,1), (5,90,1)");
1:         rs = s.executeQuery(
1:             "select i from v1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"5"},{"4"},{"3"},{"2"},{"1"}});
1: 
1:         rs = s.executeQuery(
1:             "select i from v2");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},{"2"},{"3"},{"4"},{"5"}});
1: 
1:         rollback();
1:     }
1: 
1:     /**
1:      * Test {@code ORDER BY} + {@code FETCH/OFFSET} in a view definition
1:      * <p/>
1:      * This test is a variant made my modifying {@code testView} with suitable
1:      * {@code OFFSET/FETCH FIRST} clauses.
1:      */
1:     public void testViewFetchOffset() throws SQLException {
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.executeUpdate(
1:             "create view v1 as select i from t order by j desc " +
1:             "                  offset 2 rows fetch first 1 row only");
1:         s.executeUpdate(
1:             "create view v2 as select i from t order by i " +
1:             "                  fetch next 2 rows only");
1: 
1:         s.executeUpdate(
1:             "insert into t values (1,10,1), (2,40,1)," +
1:             "         (3,45,1), (4,46,1), (5,90,1)");
1: 
1:         rs = s.executeQuery(
1:             "select i from v1");
1:         JDBC.assertFullResultSet(rs, new String[][]{{"3"}});
1: 
1:         rs = s.executeQuery(
1:             "select i from v2");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},{"2"}});
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * {@code SELECT} subqueries with {@code ORDER BY} - negative tests
1:      */
1:     public void testSelectSubqueriesOrderByNegative() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         ResultSet rs;
1: 
1:         s.execute(
1:             "insert into t_source values (1, 'one'), (2, 'two'), (8, 'three')");
1: 
1:         /*
1:          * Simple SELECT FromSubquery
1:          */
1:         assertStatementError(
1:             COLUMN_NOT_FOUND, s,
1:             "select * from (select c1 from t_source order by c3 desc) s");
1: 
1:         assertStatementError(
1:             COLUMN_OUT_OF_RANGE, s,
1:             "select * from (select c1 from t_source order by 3 desc) s");
1: 
1: 
1:         /*
1:          * Simple VALUES FromSubquery
1:          */
1:         assertStatementError(
1:             COLUMN_OUT_OF_RANGE, s,
1:             "select * from (values (1, 'one'), (2, 'two'), (8, 'three')" +
1:             "               order by 3 desc) s");
1: 
1:         /*
1:          * ORDER BY in EXISTS subquery:
1:          */
1:         assertStatementError(
1:             COLUMN_NOT_FOUND, s,
1:             "select c1 from t_source where exists " +
1:             "    (select c1 from t_source order by c4)");
1: 
1:         rollback();
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:576d3b7
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6006. INSERT INTO ... SELECT FROM could fail with a
1:         // NullPointerException in insane builds, or XSCH5 or assert in sane
1:         // builds, if the SELECT had an ORDER BY column that was not referenced
1:         // in the select list, and if normalization was required because the
1:         // types in the select list didn't exactly match the types in the
1:         // target table.
1:         //
1:         // In the test case below, the select list has an INT (the literal 1),
1:         // whereas the target type is DOUBLE. Also, the ORDER BY column (X) is
1:         // not in the select list.
1:         s.execute("create table t6006(x double)");
1:         assertUpdateCount(s, 6, "insert into t6006 values 1,2,3,4,5,6");
1:         assertUpdateCount(s, 6,
1:                 "insert into t6006 select 1 from t6006 order by x");
1: 
============================================================================