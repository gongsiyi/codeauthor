1:a56ecfa: /*
3:a56ecfa: 
1:a56ecfa:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NewOptimizerOverridesTest
1:a56ecfa: 
1:a56ecfa:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a56ecfa:    contributor license agreements.  See the NOTICE file distributed with
1:a56ecfa:    this work for additional information regarding copyright ownership.
1:a56ecfa:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a56ecfa:    (the "License"); you may not use this file except in compliance with
1:a56ecfa:    the License.  You may obtain a copy of the License at
1:a56ecfa: 
1:a56ecfa:      http://www.apache.org/licenses/LICENSE-2.0
1:a56ecfa: 
1:a56ecfa:    Unless required by applicable law or agreed to in writing, software
1:a56ecfa:    distributed under the License is distributed on an "AS IS" BASIS,
1:a56ecfa:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a56ecfa:    See the License for the specific language governing permissions and
1:a56ecfa:    limitations under the License.
1:a56ecfa: 
1:a56ecfa:  */
1:a56ecfa: 
1:a56ecfa: package org.apache.derbyTesting.functionTests.tests.lang;
1:a56ecfa: 
1:a56ecfa: import java.io.StringWriter;
1:a56ecfa: import java.sql.Connection;
1:a56ecfa: import java.sql.PreparedStatement;
1:a56ecfa: import java.sql.ResultSet;
1:a56ecfa: import javax.xml.parsers.DocumentBuilderFactory;
1:a56ecfa: import javax.xml.transform.OutputKeys;
1:a56ecfa: import javax.xml.transform.Transformer;
1:a56ecfa: import javax.xml.transform.TransformerFactory;
1:a56ecfa: import javax.xml.transform.dom.DOMSource;
1:a56ecfa: import javax.xml.transform.stream.StreamResult;
1:a56ecfa: import junit.framework.Test;
1:a56ecfa: import org.apache.derby.iapi.services.context.ContextManager;
1:a56ecfa: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:a56ecfa: import org.apache.derby.impl.jdbc.EmbedConnection;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a56ecfa: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:a56ecfa: import org.apache.derbyTesting.junit.TestConfiguration;
1:a56ecfa: import org.w3c.dom.Document;
1:a56ecfa: import org.w3c.dom.Element;
1:a56ecfa: import org.w3c.dom.Node;
1:a56ecfa: import org.w3c.dom.NodeList;
1:a56ecfa: 
1:a56ecfa: /**
1:a56ecfa:  * <p>
1:a56ecfa:  * Test the complete plan overrides added by DERBY-6267.
1:a56ecfa:  * </p>
1:a56ecfa:  */
1:a56ecfa: public class NewOptimizerOverridesTest  extends GeneratedColumnsHelper
1:a56ecfa: {
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // CONSTANTS
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:a56ecfa:     private static  final   String  WRONG_ROW_SOURCE_COUNT = "42ZCC";
1:a56ecfa:     private static  final   String  NOT_LEFT_DEEP = "42ZCD";
1:a56ecfa:     private static  final   String  MISSING_INDEX = "42X65";
1:a56ecfa:     private static  final   String  MISSING_FUNCTION = "42X94";
1:a56ecfa:     private static  final   String  MISSING_SCHEMA = "42Y07";
1:a56ecfa:     private static  final   String  UNSUPPORTED_PLAN_SHAPE = "42Y69";
1:a56ecfa: 
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // STATE
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // CONSTRUCTOR
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:a56ecfa: 
1:a56ecfa:     /**
1:a56ecfa:      * Create a new instance.
1:a56ecfa:      */
1:a56ecfa: 
1:a56ecfa:     public NewOptimizerOverridesTest(String name)
1:a56ecfa:     {
1:a56ecfa:         super(name);
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // JUnit BEHAVIOR
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:a56ecfa: 
1:a56ecfa:     /**
1:a56ecfa:      * Construct top level suite in this JUnit test
1:a56ecfa:      */
1:a56ecfa:     public static Test suite()
1:a56ecfa:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("NewOptimizerOverridesTest");
1:a56ecfa: 
1:a56ecfa:         suite.addTest( TestConfiguration.embeddedSuite( NewOptimizerOverridesTest.class ) );
1:a56ecfa: 
1:a56ecfa:         // use a policy file which allows the xml-based plan reader to access fields in the ResultSet graph
1:a56ecfa:         return new SecurityManagerSetup
1:a56ecfa:             (
1:a56ecfa:              suite,
1:a56ecfa:              "org/apache/derbyTesting/functionTests/tests/lang/resultSetReader.policy"
1:a56ecfa:              );
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     protected void    setUp()
1:a56ecfa:         throws Exception
1:a56ecfa:     {
1:a56ecfa:         super.setUp();
1:a56ecfa: 
1:a56ecfa:         Connection conn = getConnection();
1:a56ecfa: 
1:a56ecfa:         if ( !routineExists( conn, "INTEGERLIST" ) )
1:a56ecfa:         {
1:a56ecfa:             goodStatement
1:a56ecfa:                 (
1:a56ecfa:                  conn,
1:a56ecfa:                  "create function integerList()\n" +
1:a56ecfa:                  "returns table( a int, b int, c int, d int )\n" +
1:a56ecfa:                  "language java parameter style derby_jdbc_result_set no sql\n" +
1:a56ecfa:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.integerList'\n"
1:a56ecfa:                  );
1:a56ecfa:         }
1:a56ecfa:         
1:a56ecfa:         if ( !tableExists( conn, "V" ) )
1:a56ecfa:         {
1:a56ecfa:             goodStatement
1:a56ecfa:                 (
1:a56ecfa:                  conn,
1:a56ecfa:                  "create view v as select tablename from sys.systables"
1:a56ecfa:                  );
1:a56ecfa:         }
1:a56ecfa:     }
1:a56ecfa:     
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // TESTS
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:8eb8753:     /**
1:8eb8753:      * <p>
1:a56ecfa:      * Basic syntax.
1:a56ecfa:      * </p>
1:a56ecfa:      */
1:a56ecfa:     public void test_01_basicSyntax() throws Exception
1:a56ecfa:     {
1:a56ecfa:         Connection conn = getConnection();
1:a56ecfa: 
1:a56ecfa:         // these statements, without optimizer overrides, should run fine
1:a56ecfa:         goodStatement
1:a56ecfa:             ( conn,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n"
1:a56ecfa:               );
1:a56ecfa:         goodStatement
1:a56ecfa:             ( conn,
1:a56ecfa:               "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:a56ecfa:               "where columnnumber = -i.a\n"
1:a56ecfa:               );
1:a56ecfa:         goodStatement
1:a56ecfa:             ( conn,
1:a56ecfa:               "select tablename\n" +
1:a56ecfa:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:a56ecfa:               "where tablename = columnname and columnname = alias\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // properly stated plan
1:a56ecfa:         goodStatement
1:a56ecfa:             ( conn,
1:a56ecfa:               "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:a56ecfa:               "where columnnumber = -i.a\n" +
1:a56ecfa:               "--derbyplan ( app.integerList() # sys.syscolumns_heap )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // wrong number of row sources in the plan
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( WRONG_ROW_SOURCE_COUNT,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:bbb545e:               "--derbyplan sys.syscolumns_heap\n"
1:a56ecfa:               );
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( WRONG_ROW_SOURCE_COUNT,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:bbb545e:               "--derbyplan sys.syscolumns_heap\n"
1:a56ecfa:               );
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( WRONG_ROW_SOURCE_COUNT,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:bbb545e:               "--derbyplan ( ( sys.syscolumns_heap # sys.syscolumns_heap ) * sys.syscolumns_heap )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // unknown conglomerates
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( MISSING_INDEX,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:a56ecfa:               "--derbyplan ( A * C )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // unknown function
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( MISSING_FUNCTION,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:a56ecfa:               "--derbyplan ( A() * C )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // unknown schema
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( MISSING_SCHEMA,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:a56ecfa:               "--derbyplan ( A.B * C )\n"
1:a56ecfa:               );
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( MISSING_SCHEMA,
1:a56ecfa:               "select tablename from v, sys.syscolumns\n" +
1:a56ecfa:               "where tablename = columnname\n" +
1:a56ecfa:               "--derbyplan ( A.B # C.D )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // plan is not left deep
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( NOT_LEFT_DEEP,
1:a56ecfa:               "select tablename\n" +
1:a56ecfa:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:a56ecfa:               "where tablename = columnname and columnname = alias\n" +
1:a56ecfa:               "--derbyplan ( A.B # ( C.D * E ) )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // syntax errors
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( SYNTAX_ERROR,
1:a56ecfa:               "select tablename\n" +
1:a56ecfa:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:a56ecfa:               "where tablename = columnname and columnname = alias\n" +
1:a56ecfa:               "--derbyplan blah blah blah ( ( A.B # C.D ) * E )\n"
1:a56ecfa:               );
1:a56ecfa: 
1:a56ecfa:         // bad join operator
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( LEXICAL_ERROR,
1:a56ecfa:               "select tablename\n" +
1:a56ecfa:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:a56ecfa:               "where tablename = columnname and columnname = alias\n" +
1:a56ecfa:               "--derbyplan ( ( A.B # C.D ) $ E )\n"
1:a56ecfa:               );
1:a56ecfa:     }
1:a56ecfa:     
1:a56ecfa:     /**
1:a56ecfa:      * <p>
1:a56ecfa:      * Verify that plan shapes can be overridden for simple selects.
1:a56ecfa:      * </p>
1:a56ecfa:      */
1:a56ecfa:     public void test_02_simpleSelects() throws Exception
1:a56ecfa:     {
1:a56ecfa:         Connection conn = getConnection();
1:a56ecfa:         String      select;
1:a56ecfa: 
1:a56ecfa:         //
1:a56ecfa:         // 2 RowSource plan.
1:a56ecfa:         //
1:a56ecfa:         select =
1:a56ecfa:             "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:a56ecfa:             "where columnnumber = -i.a\n";
1:a56ecfa: 
1:a56ecfa:         // by itself without an optimizer override. the table function is in the outer slot.
1:a56ecfa:         assertPlanShape
1:a56ecfa:             (
1:a56ecfa:              conn, select,
1:a56ecfa:              "( org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest # SYSCOLUMNS )"
1:a56ecfa:              );
1:a56ecfa: 
1:a56ecfa:         // with an override which places the table function on the inner slot
1:a56ecfa:         assertPlanShape
1:a56ecfa:             (
1:a56ecfa:              conn, select + "\n--derbyplan ( sys.syscolumns_heap * app.integerList() )\n",
1:a56ecfa:              "( SYSCOLUMNS * org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest )"
1:a56ecfa:              );
1:a56ecfa: 
1:a56ecfa:         // hashjoin strategy not allowed for this query
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( UNSUPPORTED_PLAN_SHAPE,
1:a56ecfa:               select + "\n--derbyplan ( sys.syscolumns_heap # app.integerList() )"
1:a56ecfa:               );
1:a56ecfa:         
1:a56ecfa:         //
1:a56ecfa:         // 4 RowSource plan.
1:a56ecfa:         //
1:a56ecfa:         select =
1:a56ecfa:             "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a, sys.syssequences s\n" +
1:a56ecfa:             "where t.tablename = c.columnname and c.columnname = a.alias and a.alias = s.sequencename\n";
1:a56ecfa: 
1:a56ecfa:         // with an override the join order is syssequences, syscolumns, sysaliases, systables
1:a56ecfa:         assertPlanShape
1:a56ecfa:             (
1:a56ecfa:              conn, select + "--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSALIASES_INDEX1) # SYS.SYSTABLES_INDEX1 )\n",
1:a56ecfa:              "( ( ( SYSSEQUENCES_INDEX2 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) # SYSTABLES_INDEX1 )"
1:a56ecfa:              );
1:8eb8753: 
1:a56ecfa:         // missing a RowSource for SYSALIASES
1:a56ecfa:         expectCompilationError
1:a56ecfa:             ( UNSUPPORTED_PLAN_SHAPE,
1:a56ecfa:               select + "\n--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSCOLUMNS_HEAP) # SYS.SYSTABLES_INDEX1 )"
1:a56ecfa:               );
1:a56ecfa: 
1:bbb545e:         //
1:bbb545e:         // Union query with a separate override clause per branch.
1:bbb545e:         //
1:bbb545e:         assertPlanShape
1:bbb545e:             (
1:bbb545e:              conn,
1:bbb545e:              
1:bbb545e:              "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:bbb545e:              "where tablename = columnname and tablename = alias\n" +
1:bbb545e:              "--derbyplan ( ( sys.systables_index1 # sys.syscolumns_heap ) # sys.sysaliases_index1 )\n" +
1:bbb545e:              "union all\n" +
1:bbb545e:              "select columnname from sys.systables t, sys.syscolumns c, sys.syssequences s\n" +
1:bbb545e:              "where tablename = columnname and tablename = sequencename\n" +
1:bbb545e:              "--derbyplan ( ( sys.systables_index1 # sys.syssequences_index2 ) # sys.syscolumns_heap )\n",
1:bbb545e:              
1:bbb545e:              "( ( ( SYSTABLES_INDEX1 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) ) union ( ( ( SYSTABLES_INDEX1 # SYSSEQUENCES_INDEX2 ) # SYSCOLUMNS ) )"
1:bbb545e:              );
1:bbb545e: 
1:bbb545e:         //
1:bbb545e:         // Subquery in the WHERE clause (flattened into the main query).
1:bbb545e:         //
1:bbb545e:         assertPlanShape
1:bbb545e:             (
1:bbb545e:              conn,
1:bbb545e:              
1:bbb545e:              "select tableid, c.referenceid\n" +
1:bbb545e:              "from sys.systables, ( select referenceid from sys.syscolumns ) c\n" +
1:bbb545e:              "where 1=2\n" +
1:bbb545e:              "--derbyplan ( sys.systables_heap * sys.syscolumns_heap )\n",
1:bbb545e:              
1:bbb545e:              "( SYSTABLES * SYSCOLUMNS )"
1:bbb545e:              );
1:bbb545e: 
1:bbb545e:         //
1:bbb545e:         // NOT IN subquery (flattened into outer query block).
1:bbb545e:         //
1:bbb545e:         assertPlanShape
1:bbb545e:             (
1:bbb545e:              conn,
1:bbb545e:              
1:bbb545e:              "select tableid\n" +
1:bbb545e:              "from sys.systables\n" +
1:bbb545e:              "where tableid not in ( select referenceid from sys.syscolumns )\n" +
1:bbb545e:              "--derbyplan ( sys.systables_heap # sys.syscolumns_index1 )\n",
1:bbb545e:              
1:bbb545e:              "( SYSTABLES # SYSCOLUMNS_INDEX1 )"
1:bbb545e:              );
1:a80adca: 
1:a80adca:         //
1:a80adca:         // EXISTS subquery (flattened into outer query block).
1:a80adca:         //
1:a80adca:         expectCompilationError
1:a80adca:             ( UNSUPPORTED_PLAN_SHAPE,
1:a80adca:               "select tableid\n" +
1:a80adca:               "from sys.systables\n" +
1:a80adca:               "where exists ( select referenceid from sys.syscolumns where 1= 2 )\n" +
1:a80adca:               "--derbyplan ( sys.syscolumns_index1 * sys.systables_heap )\n"
1:a80adca:               );
1:a80adca:         assertPlanShape
1:a80adca:             (
1:a80adca:              conn,
1:a80adca:              
1:a80adca:              "select tableid\n" +
1:a80adca:              "from sys.systables\n" +
1:a80adca:              "where exists ( select referenceid from sys.syscolumns where 1= 2 )\n" +
1:a80adca:              "--derbyplan ( sys.systables_heap * sys.syscolumns_index1 )\n",
1:a80adca:              
1:a80adca:              "( SYSTABLES * SYSCOLUMNS_INDEX1 )"
1:a80adca:              );
1:a80adca: 
1:a80adca:         //
1:a80adca:         // IN subquery (flattened into outer query block).
1:a80adca:         //
1:a80adca:         assertPlanShape
1:a80adca:             (
1:a80adca:              conn,
1:a80adca:              
1:a80adca:              "select tableid\n" +
1:a80adca:              "from sys.systables\n" +
1:a80adca:              "where tableid in ( select referenceid || 'foo' from sys.syscolumns )\n" +
1:a80adca:              "--derbyplan ( sys.systables_heap * sys.syscolumns_index1 )\n",
1:a80adca:              
1:a80adca:              "( SYSTABLES * SYSCOLUMNS_INDEX1 )"
1:a80adca:              );
1:bbb545e: 
1:a80adca:         //
1:a80adca:         // Correlated subquery (materialized).
1:a80adca:         //
1:a80adca:         assertPlanShape
1:a80adca:             (
1:a80adca:              conn,
1:a80adca:              
1:a80adca:              "select tableid\n" +
1:a80adca:              "from sys.systables t\n" +
1:a80adca:              "where tableid =\n" +
1:a80adca:              "(\n" +
1:a80adca:              "    select referenceid from sys.syscolumns where referenceid = t.tableid and 1=2\n" +
1:a80adca:              "    --derbyplan sys.syscolumns_index1\n" +
1:a80adca:              ")\n" +
1:a80adca:              "--derbyplan sys.systables_heap\n",
1:a80adca:              
1:a80adca:              "SYSCOLUMNS_INDEX1\n" +
1:a80adca:              "SYSTABLES"
1:a80adca:              );
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     /**
1:a56ecfa:      * <p>
1:8eb8753:      * Verify plan overrides with FETCH/OFFSET clauses. The override must
1:8eb8753:      * be placed after the query expression and before the offset/fetch clause.
1:8eb8753:      * </p>
1:8eb8753:      */
1:8eb8753:     public void test_03_offsetFetch() throws Exception
1:8eb8753:     {
1:8eb8753:         Connection conn = getConnection();
1:8eb8753:         
1:8eb8753:         // with an override the join order is syssequences, syscolumns, sysaliases, systables
1:8eb8753:         assertPlanShape
1:8eb8753:             (
1:8eb8753:              conn,
1:8eb8753: 
1:8eb8753:             "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a, sys.syssequences s\n" +
1:8eb8753:             "where t.tablename = c.columnname and c.columnname = a.alias and a.alias = s.sequencename\n" +
1:8eb8753:              "--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSALIASES_INDEX1) # SYS.SYSTABLES_INDEX1 )\n" +
1:8eb8753:              "fetch first 1 rows only",
1:8eb8753:              
1:8eb8753:              "( ( ( SYSSEQUENCES_INDEX2 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) # SYSTABLES_INDEX1 )"
1:8eb8753:              );
1:8eb8753: 
1:8eb8753:         //
1:8eb8753:         // Correlated subquery (materialized) with a FETCH clause.
1:8eb8753:         //
1:8eb8753:         assertPlanShape
1:8eb8753:             (
1:8eb8753:              conn,
1:8eb8753:              
1:8eb8753:              "select tableid\n" +
1:8eb8753:              "from sys.systables t\n" +
1:8eb8753:              "where tableid =\n" +
1:8eb8753:              "(\n" +
1:8eb8753:              "    select referenceid from sys.syscolumns where referenceid = t.tableid and 1=2\n" +
1:8eb8753:              "    --derbyplan sys.syscolumns_index1\n" +
1:8eb8753:              "    fetch first 1 rows only\n" +
1:8eb8753:              ")\n" +
1:8eb8753:              "--derbyplan sys.systables_heap\n",
1:8eb8753:              
1:8eb8753:              "SYSCOLUMNS_INDEX1\n" +
1:8eb8753:              "SYSTABLES"
1:8eb8753:              );
1:8eb8753:     }
1:a56ecfa:     
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa:     //
1:a56ecfa:     // MINIONS
1:a56ecfa:     //
1:a56ecfa:     ///////////////////////////////////////////////////////////////////////////////////
1:a56ecfa: 
1:a56ecfa:     /** Return true if the SQL routine exists */
1:a56ecfa:     private boolean routineExists( Connection conn, String functionName ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.sysaliases where alias = ?" );
1:a56ecfa:         ps.setString( 1, functionName );
1:a56ecfa: 
1:a56ecfa:         ResultSet rs = ps.executeQuery();
1:a56ecfa:         rs.next();
1:a56ecfa: 
1:a56ecfa:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1:a56ecfa: 
1:a56ecfa:         rs.close();
1:a56ecfa:         ps.close();
1:a56ecfa: 
1:a56ecfa:         return retval;
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     /** Return true if the table exists */
1:a56ecfa:     private boolean tableExists( Connection conn, String tableName ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.systables where tablename = ?" );
1:a56ecfa:         ps.setString( 1, tableName );
1:a56ecfa: 
1:a56ecfa:         ResultSet rs = ps.executeQuery();
1:a56ecfa:         rs.next();
1:a56ecfa: 
1:a56ecfa:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1:a56ecfa: 
1:a56ecfa:         rs.close();
1:a56ecfa:         ps.close();
1:a56ecfa: 
1:a56ecfa:         return retval;
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     /** Assert that a query produces the expected plan shape */
1:a56ecfa:     static  void    assertPlanShape( Connection conn, String query, String expectedPlanShape )
1:a56ecfa:         throws Exception
1:a56ecfa:     {
1:a56ecfa:         ResultSet   rs = conn.prepareStatement( query ).executeQuery();
1:a80adca: 
1:a80adca:         // we need to drain the result set and close it in order to fill in all
1:a80adca:         // of the structures needed by the toXML() machinery. i don't know why.
1:a80adca:         while ( rs.next() ) {}
1:a56ecfa:         rs.close();
1:a56ecfa: 
1:a80adca:         String      actualPlanShape = summarize( getLastQueryPlan( conn, rs ) );
1:a80adca: 
1:a56ecfa:         println( "Expected plan shape = " + expectedPlanShape );
1:a56ecfa:         println( "Actual plan shape = " + actualPlanShape );
1:a56ecfa: 
1:a56ecfa:         assertEquals( expectedPlanShape, actualPlanShape );
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     /** Get an xml-based picture of the plan chosen for the last query. The query is identified by its JDBC ResultSet */
1:a80adca:     public  static  Document    getLastQueryPlan( Connection conn, ResultSet rs ) throws Exception
1:a56ecfa:     {
1:b6a45f5:         LanguageConnectionContext   lcc = ConstraintCharacteristicsTest.getLCC( conn );
1:a56ecfa:         org.apache.derby.iapi.sql.ResultSet derbyRS = lcc.getLastActivation().getResultSet();
1:a56ecfa: 
1:a56ecfa:         Document    doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
1:a56ecfa:         Element     root = doc.createElement( "planTrace" );
1:a56ecfa:         doc.appendChild( root );
1:a56ecfa: 
1:a56ecfa:         derbyRS.toXML( root, "top" );
1:a56ecfa: 
1:a56ecfa:         return doc;
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     public static  String    summarize( Document doc ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         StringBuilder   buffer = new StringBuilder();
1:a56ecfa:         Element     root = getFirstElement( doc.getDocumentElement(), "top" );;
1:a56ecfa: 
1:a56ecfa:         summarize( buffer, root );
1:a56ecfa: 
1:a56ecfa:         return buffer.toString();
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     private static  void    summarize( StringBuilder buffer, Element element ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         String  type = element.getAttribute( "type" );
1:a56ecfa: 
1:a56ecfa:         if ( "HashJoinResultSet".equals( type ) ) { summarizeJoin( buffer, element, "#" ); }
1:a56ecfa:         else if ( "NestedLoopJoinResultSet".equals( type ) ) { summarizeJoin( buffer, element, "*" ); }
1:a80adca:         else if ( "ProjectRestrictResultSet".equals( type ) ) { summarizeProjectRestrict( buffer, element ); }
1:8eb8753:         else if ( "RowCountResultSet".equals( type ) ) { summarizeProjectRestrict( buffer, getFirstElement( element, "source" ) ); }
1:bbb545e:         else if ( "UnionResultSet".equals( type ) ) { summarizeUnion( buffer, element ); }
1:a56ecfa:         else
1:a56ecfa:         {
1:a56ecfa:             String  indexName = element.getAttribute( "indexName" );
1:a56ecfa:             String  tableName = element.getAttribute( "tableName" );
1:a56ecfa:             String  javaClassName = element.getAttribute( "javaClassName" );
1:a56ecfa: 
1:a56ecfa:             if ( indexName.length() != 0 ) { buffer.append( indexName ); }
1:a56ecfa:             else if ( tableName.length() != 0 ) { buffer.append( tableName ); }
1:a56ecfa:             else if ( javaClassName.length() != 0 ) { buffer.append( javaClassName ); }
1:a56ecfa:             else { buffer.append( type ); }
1:a56ecfa:         }
1:a56ecfa:     }
1:a56ecfa: 
1:a80adca:     private static  void    summarizeProjectRestrict( StringBuilder buffer, Element projectRestrict )
1:a80adca:         throws Exception
1:a80adca:     {
1:a80adca:         // look for subqueries attached to this ProjectRestrict node
1:a80adca:         Element subqueryArray = getFirstElement( projectRestrict, "array" );
1:a80adca:         if ( subqueryArray != null ) { summarizeSubqueries( buffer, subqueryArray ); }
1:a80adca: 
1:a80adca:         // now step into the node underneath us, which represents the tuple stream
1:a80adca:         // feeding the ProjectRestrict node
1:a80adca:         summarize( buffer, getFirstElement( projectRestrict, "source" ) );
1:a80adca:     }
1:a80adca: 
1:a80adca:     private static  void    summarizeSubqueries( StringBuilder buffer, Element subqueryArray )
1:a80adca:         throws Exception
1:a80adca:     {
1:a80adca:         NodeList    children = subqueryArray.getChildNodes();
1:a80adca: 
1:a80adca:         for ( int i = 0; i < children.getLength(); i++ )
1:a80adca:         {
1:a80adca:             Node    child = children.item( i );
1:a80adca:             if ( "cell".equals( child.getNodeName() ) )
1:a80adca:             {
1:a80adca:                 Element     source = getFirstElement( (Element) child, "source" );
1:a80adca:                 summarize( buffer, source );
1:a80adca:                 buffer.append( "\n" );
1:a80adca:             }
1:a80adca:         }
1:a80adca:     }
1:a80adca: 
1:a56ecfa:     private static  void    summarizeJoin( StringBuilder buffer, Element element, String joinSymbol )
1:a56ecfa:         throws Exception
1:a56ecfa:     {
1:a56ecfa:         buffer.append( "( " );
1:a56ecfa:         summarize( buffer, getFirstElement( element, "leftResultSet" ) );
1:a56ecfa:         buffer.append( " " + joinSymbol + " " );
1:a56ecfa:         summarize( buffer, getFirstElement( element, "rightResultSet" ) );
1:a56ecfa:         buffer.append( " )" );
1:a56ecfa:     }
1:a56ecfa: 
1:bbb545e:     private static  void    summarizeUnion( StringBuilder buffer, Element union )
1:bbb545e:         throws Exception
1:bbb545e:     {
1:bbb545e:         NodeList    list = union.getChildNodes();
1:bbb545e: 
1:bbb545e:         for ( int i = 0; i < list.getLength(); i++ )
1:bbb545e:         {
1:bbb545e:             Element    child = (Element) list.item( i );
1:bbb545e:             if ( i > 0 ) { buffer.append( " union " ); }
1:bbb545e:             buffer.append( "( " );
1:bbb545e:             summarize( buffer, child );
1:bbb545e:             buffer.append( " )" );
1:bbb545e:         }
1:bbb545e:     }
1:bbb545e: 
1:a56ecfa:     /** Get first element by the give tag name */
1:a56ecfa:     private static  Element    getFirstElement( Element parent, String tag ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         NodeList    list = parent.getChildNodes();
1:a56ecfa: 
1:a56ecfa:         for ( int i = 0; i < list.getLength(); i++ )
1:a56ecfa:         {
1:a56ecfa:             Node    child = list.item( i );
1:a56ecfa:             if ( tag.equals( child.getNodeName() ) ) { return (Element) child; }
1:a56ecfa:         }
1:a56ecfa: 
1:a56ecfa:         return null;
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa:     /** Print a document to a string. Not actually used. Useful for debugging this test. */
1:a56ecfa:     static  String  printDocument( Document doc ) throws Exception
1:a56ecfa:     {
1:a56ecfa:         TransformerFactory transformerFactory = TransformerFactory.newInstance();
1:a56ecfa:         Transformer transformer = transformerFactory.newTransformer();
1:a56ecfa:         DOMSource source = new DOMSource( doc );
1:a56ecfa:         StringWriter    sw = new StringWriter();
1:a56ecfa:         StreamResult result = new StreamResult( sw );
1:a56ecfa:         
1:a56ecfa:         // pretty-print
1:a56ecfa:         transformer.setOutputProperty( OutputKeys.OMIT_XML_DECLARATION, "no" );
1:a56ecfa:         transformer.setOutputProperty( OutputKeys.METHOD, "xml" );
1:a56ecfa:         transformer.setOutputProperty( OutputKeys.INDENT, "yes" );
1:a56ecfa:         transformer.setOutputProperty( OutputKeys.ENCODING, "UTF-8" );
1:a56ecfa:         transformer.setOutputProperty( "{http://xml.apache.org/xslt}indent-amount", "4" );
1:a56ecfa:         
1:a56ecfa:         transformer.transform( source, result );
1:a56ecfa: 
1:a56ecfa:         return sw.toString();
1:a56ecfa:     }
1:a56ecfa: 
1:a56ecfa: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b6a45f5
/////////////////////////////////////////////////////////////////////////
1:         LanguageConnectionContext   lcc = ConstraintCharacteristicsTest.getLCC( conn );
commit:8eb8753
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify plan overrides with FETCH/OFFSET clauses. The override must
1:      * be placed after the query expression and before the offset/fetch clause.
1:      * </p>
1:      */
1:     public void test_03_offsetFetch() throws Exception
1:     {
1:         Connection conn = getConnection();
1:         
1:         // with an override the join order is syssequences, syscolumns, sysaliases, systables
1:         assertPlanShape
1:             (
1:              conn,
1: 
1:             "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a, sys.syssequences s\n" +
1:             "where t.tablename = c.columnname and c.columnname = a.alias and a.alias = s.sequencename\n" +
1:              "--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSALIASES_INDEX1) # SYS.SYSTABLES_INDEX1 )\n" +
1:              "fetch first 1 rows only",
1:              
1:              "( ( ( SYSSEQUENCES_INDEX2 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) # SYSTABLES_INDEX1 )"
1:              );
1: 
1:         //
1:         // Correlated subquery (materialized) with a FETCH clause.
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid\n" +
1:              "from sys.systables t\n" +
1:              "where tableid =\n" +
1:              "(\n" +
1:              "    select referenceid from sys.syscolumns where referenceid = t.tableid and 1=2\n" +
1:              "    --derbyplan sys.syscolumns_index1\n" +
1:              "    fetch first 1 rows only\n" +
1:              ")\n" +
1:              "--derbyplan sys.systables_heap\n",
1:              
1:              "SYSCOLUMNS_INDEX1\n" +
1:              "SYSTABLES"
1:              );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         else if ( "RowCountResultSet".equals( type ) ) { summarizeProjectRestrict( buffer, getFirstElement( element, "source" ) ); }
commit:a80adca
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // EXISTS subquery (flattened into outer query block).
1:         //
1:         expectCompilationError
1:             ( UNSUPPORTED_PLAN_SHAPE,
1:               "select tableid\n" +
1:               "from sys.systables\n" +
1:               "where exists ( select referenceid from sys.syscolumns where 1= 2 )\n" +
1:               "--derbyplan ( sys.syscolumns_index1 * sys.systables_heap )\n"
1:               );
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid\n" +
1:              "from sys.systables\n" +
1:              "where exists ( select referenceid from sys.syscolumns where 1= 2 )\n" +
1:              "--derbyplan ( sys.systables_heap * sys.syscolumns_index1 )\n",
1:              
1:              "( SYSTABLES * SYSCOLUMNS_INDEX1 )"
1:              );
1: 
1:         //
1:         // IN subquery (flattened into outer query block).
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid\n" +
1:              "from sys.systables\n" +
1:              "where tableid in ( select referenceid || 'foo' from sys.syscolumns )\n" +
1:              "--derbyplan ( sys.systables_heap * sys.syscolumns_index1 )\n",
1:              
1:              "( SYSTABLES * SYSCOLUMNS_INDEX1 )"
1:              );
1: 
1:         //
1:         // Correlated subquery (materialized).
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid\n" +
1:              "from sys.systables t\n" +
1:              "where tableid =\n" +
1:              "(\n" +
1:              "    select referenceid from sys.syscolumns where referenceid = t.tableid and 1=2\n" +
1:              "    --derbyplan sys.syscolumns_index1\n" +
1:              ")\n" +
1:              "--derbyplan sys.systables_heap\n",
1:              
1:              "SYSCOLUMNS_INDEX1\n" +
1:              "SYSTABLES"
1:              );
/////////////////////////////////////////////////////////////////////////
1: 
1:         // we need to drain the result set and close it in order to fill in all
1:         // of the structures needed by the toXML() machinery. i don't know why.
1:         while ( rs.next() ) {}
1:         String      actualPlanShape = summarize( getLastQueryPlan( conn, rs ) );
1: 
/////////////////////////////////////////////////////////////////////////
1:     public  static  Document    getLastQueryPlan( Connection conn, ResultSet rs ) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         else if ( "ProjectRestrictResultSet".equals( type ) ) { summarizeProjectRestrict( buffer, element ); }
/////////////////////////////////////////////////////////////////////////
1:     private static  void    summarizeProjectRestrict( StringBuilder buffer, Element projectRestrict )
1:         throws Exception
1:     {
1:         // look for subqueries attached to this ProjectRestrict node
1:         Element subqueryArray = getFirstElement( projectRestrict, "array" );
1:         if ( subqueryArray != null ) { summarizeSubqueries( buffer, subqueryArray ); }
1: 
1:         // now step into the node underneath us, which represents the tuple stream
1:         // feeding the ProjectRestrict node
1:         summarize( buffer, getFirstElement( projectRestrict, "source" ) );
1:     }
1: 
1:     private static  void    summarizeSubqueries( StringBuilder buffer, Element subqueryArray )
1:         throws Exception
1:     {
1:         NodeList    children = subqueryArray.getChildNodes();
1: 
1:         for ( int i = 0; i < children.getLength(); i++ )
1:         {
1:             Node    child = children.item( i );
1:             if ( "cell".equals( child.getNodeName() ) )
1:             {
1:                 Element     source = getFirstElement( (Element) child, "source" );
1:                 summarize( buffer, source );
1:                 buffer.append( "\n" );
1:             }
1:         }
1:     }
1: 
commit:bbb545e
/////////////////////////////////////////////////////////////////////////
1:               "--derbyplan sys.syscolumns_heap\n"
1:               "--derbyplan sys.syscolumns_heap\n"
1:               "--derbyplan ( ( sys.syscolumns_heap # sys.syscolumns_heap ) * sys.syscolumns_heap )\n"
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Union query with a separate override clause per branch.
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:              "where tablename = columnname and tablename = alias\n" +
1:              "--derbyplan ( ( sys.systables_index1 # sys.syscolumns_heap ) # sys.sysaliases_index1 )\n" +
1:              "union all\n" +
1:              "select columnname from sys.systables t, sys.syscolumns c, sys.syssequences s\n" +
1:              "where tablename = columnname and tablename = sequencename\n" +
1:              "--derbyplan ( ( sys.systables_index1 # sys.syssequences_index2 ) # sys.syscolumns_heap )\n",
1:              
1:              "( ( ( SYSTABLES_INDEX1 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) ) union ( ( ( SYSTABLES_INDEX1 # SYSSEQUENCES_INDEX2 ) # SYSCOLUMNS ) )"
1:              );
1: 
1:         //
1:         // Subquery in the WHERE clause (flattened into the main query).
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid, c.referenceid\n" +
1:              "from sys.systables, ( select referenceid from sys.syscolumns ) c\n" +
1:              "where 1=2\n" +
1:              "--derbyplan ( sys.systables_heap * sys.syscolumns_heap )\n",
1:              
1:              "( SYSTABLES * SYSCOLUMNS )"
1:              );
1: 
1:         //
1:         // NOT IN subquery (flattened into outer query block).
1:         //
1:         assertPlanShape
1:             (
1:              conn,
1:              
1:              "select tableid\n" +
1:              "from sys.systables\n" +
1:              "where tableid not in ( select referenceid from sys.syscolumns )\n" +
1:              "--derbyplan ( sys.systables_heap # sys.syscolumns_index1 )\n",
1:              
1:              "( SYSTABLES # SYSCOLUMNS_INDEX1 )"
1:              );
1: 
/////////////////////////////////////////////////////////////////////////
1:         else if ( "UnionResultSet".equals( type ) ) { summarizeUnion( buffer, element ); }
/////////////////////////////////////////////////////////////////////////
1:     private static  void    summarizeUnion( StringBuilder buffer, Element union )
1:         throws Exception
1:     {
1:         NodeList    list = union.getChildNodes();
1: 
1:         for ( int i = 0; i < list.getLength(); i++ )
1:         {
1:             Element    child = (Element) list.item( i );
1:             if ( i > 0 ) { buffer.append( " union " ); }
1:             buffer.append( "( " );
1:             summarize( buffer, child );
1:             buffer.append( " )" );
1:         }
1:     }
1: 
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NewOptimizerOverridesTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.io.StringWriter;
0: import java.sql.CallableStatement;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import javax.xml.parsers.DocumentBuilderFactory;
0: import javax.xml.parsers.ParserConfigurationException;
1: import javax.xml.transform.OutputKeys;
1: import javax.xml.transform.Transformer;
0: import javax.xml.transform.TransformerException;
1: import javax.xml.transform.TransformerFactory;
1: import javax.xml.transform.dom.DOMSource;
1: import javax.xml.transform.stream.StreamResult;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Element;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.Decorator;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.iapi.sql.Activation;
1: 
1: /**
1:  * <p>
1:  * Test the complete plan overrides added by DERBY-6267.
1:  * </p>
1:  */
1: public class NewOptimizerOverridesTest  extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  WRONG_ROW_SOURCE_COUNT = "42ZCC";
1:     private static  final   String  NOT_LEFT_DEEP = "42ZCD";
1:     private static  final   String  MISSING_INDEX = "42X65";
1:     private static  final   String  MISSING_FUNCTION = "42X94";
1:     private static  final   String  MISSING_SCHEMA = "42Y07";
1:     private static  final   String  UNSUPPORTED_PLAN_SHAPE = "42Y69";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public NewOptimizerOverridesTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite       suite = new TestSuite( "NewOptimizerOverridesTest" );
1: 
1:         suite.addTest( TestConfiguration.embeddedSuite( NewOptimizerOverridesTest.class ) );
1: 
1:         // use a policy file which allows the xml-based plan reader to access fields in the ResultSet graph
1:         return new SecurityManagerSetup
1:             (
1:              suite,
1:              "org/apache/derbyTesting/functionTests/tests/lang/resultSetReader.policy"
1:              );
1:     }
1: 
1:     protected void    setUp()
1:         throws Exception
1:     {
1:         super.setUp();
1: 
1:         Connection conn = getConnection();
1: 
1:         if ( !routineExists( conn, "INTEGERLIST" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function integerList()\n" +
1:                  "returns table( a int, b int, c int, d int )\n" +
1:                  "language java parameter style derby_jdbc_result_set no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.integerList'\n"
1:                  );
1:         }
1:         
1:         if ( !tableExists( conn, "V" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create view v as select tablename from sys.systables"
1:                  );
1:         }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Basic syntax.
1:      * </p>
1:      */
1:     public void test_01_basicSyntax() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // these statements, without optimizer overrides, should run fine
1:         goodStatement
1:             ( conn,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:               "where columnnumber = -i.a\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "select tablename\n" +
1:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:               "where tablename = columnname and columnname = alias\n"
1:               );
1: 
1:         // properly stated plan
1:         goodStatement
1:             ( conn,
1:               "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:               "where columnnumber = -i.a\n" +
1:               "--derbyplan ( app.integerList() # sys.syscolumns_heap )\n"
1:               );
1: 
1:         // wrong number of row sources in the plan
1:         expectCompilationError
1:             ( WRONG_ROW_SOURCE_COUNT,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
0:               "--derbyplan A\n"
1:               );
1:         expectCompilationError
1:             ( WRONG_ROW_SOURCE_COUNT,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
0:               "--derbyplan A.B\n"
1:               );
1:         expectCompilationError
1:             ( WRONG_ROW_SOURCE_COUNT,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
0:               "--derbyplan ( ( A.B # C.D ) * E )\n"
1:               );
1: 
1:         // unknown conglomerates
1:         expectCompilationError
1:             ( MISSING_INDEX,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
1:               "--derbyplan ( A * C )\n"
1:               );
1: 
1:         // unknown function
1:         expectCompilationError
1:             ( MISSING_FUNCTION,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
1:               "--derbyplan ( A() * C )\n"
1:               );
1: 
1:         // unknown schema
1:         expectCompilationError
1:             ( MISSING_SCHEMA,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
1:               "--derbyplan ( A.B * C )\n"
1:               );
1:         expectCompilationError
1:             ( MISSING_SCHEMA,
1:               "select tablename from v, sys.syscolumns\n" +
1:               "where tablename = columnname\n" +
1:               "--derbyplan ( A.B # C.D )\n"
1:               );
1: 
1:         // plan is not left deep
1:         expectCompilationError
1:             ( NOT_LEFT_DEEP,
1:               "select tablename\n" +
1:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:               "where tablename = columnname and columnname = alias\n" +
1:               "--derbyplan ( A.B # ( C.D * E ) )\n"
1:               );
1: 
1:         // syntax errors
1:         expectCompilationError
1:             ( SYNTAX_ERROR,
1:               "select tablename\n" +
1:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:               "where tablename = columnname and columnname = alias\n" +
1:               "--derbyplan blah blah blah ( ( A.B # C.D ) * E )\n"
1:               );
1: 
1:         // bad join operator
1:         expectCompilationError
1:             ( LEXICAL_ERROR,
1:               "select tablename\n" +
1:               "from sys.systables t, sys.syscolumns c, sys.sysaliases a\n" +
1:               "where tablename = columnname and columnname = alias\n" +
1:               "--derbyplan ( ( A.B # C.D ) $ E )\n"
1:               );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Verify that plan shapes can be overridden for simple selects.
1:      * </p>
1:      */
1:     public void test_02_simpleSelects() throws Exception
1:     {
1:         Connection conn = getConnection();
1:         String      select;
1: 
1:         //
1:         // 2 RowSource plan.
1:         //
1:         select =
1:             "select columnname from sys.syscolumns, table( integerList() ) i\n" +
1:             "where columnnumber = -i.a\n";
1: 
1:         // by itself without an optimizer override. the table function is in the outer slot.
1:         assertPlanShape
1:             (
1:              conn, select,
1:              "( org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest # SYSCOLUMNS )"
1:              );
1: 
1:         // with an override which places the table function on the inner slot
1:         assertPlanShape
1:             (
1:              conn, select + "\n--derbyplan ( sys.syscolumns_heap * app.integerList() )\n",
1:              "( SYSCOLUMNS * org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest )"
1:              );
1: 
1:         // hashjoin strategy not allowed for this query
1:         expectCompilationError
1:             ( UNSUPPORTED_PLAN_SHAPE,
1:               select + "\n--derbyplan ( sys.syscolumns_heap # app.integerList() )"
1:               );
1:         
1:         //
1:         // 4 RowSource plan.
1:         //
1:         select =
1:             "select tablename from sys.systables t, sys.syscolumns c, sys.sysaliases a, sys.syssequences s\n" +
1:             "where t.tablename = c.columnname and c.columnname = a.alias and a.alias = s.sequencename\n";
1: 
1:         // with an override the join order is syssequences, syscolumns, sysaliases, systables
1:         assertPlanShape
1:             (
1:              conn, select + "--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSALIASES_INDEX1) # SYS.SYSTABLES_INDEX1 )\n",
1:              "( ( ( SYSSEQUENCES_INDEX2 # SYSCOLUMNS ) # SYSALIASES_INDEX1 ) # SYSTABLES_INDEX1 )"
1:              );
1: 
1:         // missing a RowSource for SYSALIASES
1:         expectCompilationError
1:             ( UNSUPPORTED_PLAN_SHAPE,
1:               select + "\n--derbyplan ( ((SYS.SYSSEQUENCES_INDEX2 # SYS.SYSCOLUMNS_HEAP) # SYS.SYSCOLUMNS_HEAP) # SYS.SYSTABLES_INDEX1 )"
1:               );
1: 
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Return true if the SQL routine exists */
1:     private boolean routineExists( Connection conn, String functionName ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.sysaliases where alias = ?" );
1:         ps.setString( 1, functionName );
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
1:     /** Return true if the table exists */
1:     private boolean tableExists( Connection conn, String tableName ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.systables where tablename = ?" );
1:         ps.setString( 1, tableName );
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
1:     /** Assert that a query produces the expected plan shape */
1:     static  void    assertPlanShape( Connection conn, String query, String expectedPlanShape )
1:         throws Exception
1:     {
1:         ResultSet   rs = conn.prepareStatement( query ).executeQuery();
0:         String      actualPlanShape = summarize( getLastQueryPlan( conn, rs ) );
1:         rs.close();
1: 
1:         println( "Expected plan shape = " + expectedPlanShape );
1:         println( "Actual plan shape = " + actualPlanShape );
1: 
1:         assertEquals( expectedPlanShape, actualPlanShape );
1:     }
1: 
1:     /** Get an xml-based picture of the plan chosen for the last query. The query is identified by its JDBC ResultSet */
0:     static  Document    getLastQueryPlan( Connection conn, ResultSet rs ) throws Exception
1:     {
0:         ContextManager      contextManager = ((EmbedConnection) conn).getContextManager();
0:         LanguageConnectionContext   lcc = (LanguageConnectionContext) contextManager.getContext( "LanguageConnectionContext" );
1:         org.apache.derby.iapi.sql.ResultSet derbyRS = lcc.getLastActivation().getResultSet();
1: 
1:         Document    doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
1:         Element     root = doc.createElement( "planTrace" );
1:         doc.appendChild( root );
1: 
1:         derbyRS.toXML( root, "top" );
1: 
1:         return doc;
1:     }
1: 
1:     public static  String    summarize( Document doc ) throws Exception
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1:         Element     root = getFirstElement( doc.getDocumentElement(), "top" );;
1: 
1:         summarize( buffer, root );
1: 
1:         return buffer.toString();
1:     }
1: 
1:     private static  void    summarize( StringBuilder buffer, Element element ) throws Exception
1:     {
1:         String  type = element.getAttribute( "type" );
1: 
1:         if ( "HashJoinResultSet".equals( type ) ) { summarizeJoin( buffer, element, "#" ); }
1:         else if ( "NestedLoopJoinResultSet".equals( type ) ) { summarizeJoin( buffer, element, "*" ); }
0:         else if ( "ProjectRestrictResultSet".equals( type ) ) { summarize( buffer, getFirstElement( element, "source" ) ); }
1:         else
1:         {
1:             String  indexName = element.getAttribute( "indexName" );
1:             String  tableName = element.getAttribute( "tableName" );
1:             String  javaClassName = element.getAttribute( "javaClassName" );
1: 
1:             if ( indexName.length() != 0 ) { buffer.append( indexName ); }
1:             else if ( tableName.length() != 0 ) { buffer.append( tableName ); }
1:             else if ( javaClassName.length() != 0 ) { buffer.append( javaClassName ); }
1:             else { buffer.append( type ); }
1:         }
1:     }
1: 
1:     private static  void    summarizeJoin( StringBuilder buffer, Element element, String joinSymbol )
1:         throws Exception
1:     {
1:         buffer.append( "( " );
1:         summarize( buffer, getFirstElement( element, "leftResultSet" ) );
1:         buffer.append( " " + joinSymbol + " " );
1:         summarize( buffer, getFirstElement( element, "rightResultSet" ) );
1:         buffer.append( " )" );
1:     }
1: 
1:     /** Get first element by the give tag name */
1:     private static  Element    getFirstElement( Element parent, String tag ) throws Exception
1:     {
1:         NodeList    list = parent.getChildNodes();
1: 
1:         for ( int i = 0; i < list.getLength(); i++ )
1:         {
1:             Node    child = list.item( i );
1:             if ( tag.equals( child.getNodeName() ) ) { return (Element) child; }
1:         }
1: 
1:         return null;
1:     }
1: 
1:     /** Print a document to a string. Not actually used. Useful for debugging this test. */
1:     static  String  printDocument( Document doc ) throws Exception
1:     {
1:         TransformerFactory transformerFactory = TransformerFactory.newInstance();
1:         Transformer transformer = transformerFactory.newTransformer();
1:         DOMSource source = new DOMSource( doc );
1:         StringWriter    sw = new StringWriter();
1:         StreamResult result = new StreamResult( sw );
1:         
1:         // pretty-print
1:         transformer.setOutputProperty( OutputKeys.OMIT_XML_DECLARATION, "no" );
1:         transformer.setOutputProperty( OutputKeys.METHOD, "xml" );
1:         transformer.setOutputProperty( OutputKeys.INDENT, "yes" );
1:         transformer.setOutputProperty( OutputKeys.ENCODING, "UTF-8" );
1:         transformer.setOutputProperty( "{http://xml.apache.org/xslt}indent-amount", "4" );
1:         
1:         transformer.transform( source, result );
1: 
1:         return sw.toString();
1:     }
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.Test;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("NewOptimizerOverridesTest");
============================================================================