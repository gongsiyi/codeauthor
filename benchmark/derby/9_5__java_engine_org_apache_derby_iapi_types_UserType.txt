1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.UserType
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
10:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:9548d38: import java.math.BigDecimal;
1:9548d38: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: 
1:eac0369: import java.util.Calendar;
1:eac0369: 
1:eac0369: 
4:eac0369: /**
1:eac0369:  * This contains an instance of a user-defined type, that is, a java object.
3:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class UserType extends DataType
1:eac0369: 						implements UserDataValue
6:eac0369: {
1:eac0369: 	private Object	value;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** DataValueDescriptor interface
1:eac0369: 	** (mostly implemented in DataType)
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( UserType.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac0369:         int sz = BASE_MEMORY_USAGE;
1:eac0369:         if( null != value)
1:eac0369:         {
1:eac0369:             // Probably an underestimate. Examining each field value would be expensive
1:eac0369:             // and would produce an overestimate when fields reference shared objects
1:eac0369:             sz += ClassSize.estimateAndCatalogBase( value.getClass());
7:eac0369:         }
1:eac0369:         
1:eac0369:         return sz;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369: 	public String getString()
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 		{
1:eac0369: 			return value.toString();
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public boolean getBoolean() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			if (value instanceof Boolean) return ((Boolean)value).booleanValue();
1:eac0369: 		return super.getBoolean();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public byte getByte() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow and truncation
1:eac0369: 			if (value instanceof Number) return ((Number)value).byteValue();
1:eac0369: 		return super.getByte();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public short getShort() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow and truncation
1:eac0369: 			if (value instanceof Number) return ((Number)value).shortValue();
1:eac0369: 		return super.getShort();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public int getInt() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow and truncation
1:eac0369: 			if (value instanceof Number) return ((Number)value).intValue();
1:eac0369: 		return super.getInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public long getLong() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow and truncation
1:eac0369: 			if (value instanceof Number) return ((Number)value).longValue();
1:eac0369: 		return super.getLong();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public float getFloat() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow
1:eac0369: 			if (value instanceof Number) return ((Number)value).floatValue();
1:eac0369: 		return super.getFloat();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public double getDouble() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			// REMIND: check for overflow
1:eac0369: 			if (value instanceof Number) return ((Number)value).doubleValue();
1:eac0369: 		return super.getDouble();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public byte[] getBytes() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 			if (value instanceof byte[]) return ((byte[])value);
1:eac0369: 		return super.getBytes();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public Date	getDate( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 		{
1:eac0369: 			if (value instanceof Date) 
1:eac0369: 				return ((Date)value);
1:eac0369: 			else if (value instanceof Timestamp)
1:eac0369: 				return (new SQLTimestamp((Timestamp)value).getDate(cal));
1:eac0369: 		}
1:eac0369: 		return super.getDate(cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public Time	getTime( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 		{
1:eac0369: 			if (value instanceof Time) 
1:eac0369: 				return ((Time)value);
1:eac0369: 			else if (value instanceof Timestamp)
1:eac0369: 				return (new SQLTimestamp((Timestamp)value).getTime(cal));
1:eac0369: 		}
1:eac0369: 		return super.getTime(cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isNull())
1:eac0369: 		{
1:eac0369: 			if (value instanceof Timestamp) 
1:eac0369: 				return ((Timestamp)value);
1:eac0369: 			else if (value instanceof Date)
1:eac0369: 				return (new SQLDate((Date)value).getTimestamp(cal));
1:eac0369: 			else if (value instanceof Time)
1:eac0369: 				return (new SQLTime((Time)value).getTimestamp(cal));
1:eac0369: 		}
1:eac0369: 		return super.getTimestamp(cal);
1:eac0369: 	}
1:eac0369: 
1:d039ced: 	void setObject(Object theValue)
1:d039ced:     {
1:d039ced:         setValue( theValue );
1:d039ced:     }
1:d039ced:     
1:eac0369: 	public Object getObject()
1:eac0369: 	{
1:eac0369: 		return value;
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	public int getLength()
1:eac0369: 	{
1:eac0369: 		return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* this is for DataType's error generator */
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		return isNull() ? "JAVA_OBJECT" : ClassInspector.readableClassName(value.getClass());
1:eac0369: 	}
1:806114c: 	
1:806114c: 	/**
1:806114c: 	 * Get the type name of this value,  overriding
1:806114c: 	 * with the passed in class name (for user/java types).
1:806114c: 	 */
1:806114c: 	String getTypeName(String className)
1:806114c: 	{
1:806114c: 		return className;
1:806114c: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_USERTYPE_ID_V3;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		@exception IOException error writing data
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1:eac0369: 
1:eac0369: 			out.writeObject(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on error reading the object
1:eac0369: 	 * @exception ClassNotFoundException	Thrown if the class of the object
1:eac0369: 	 *										is not found
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) 
2:eac0369:         throws IOException, ClassNotFoundException
1:eac0369: 	{
2:eac0369: 		/* RESOLVE: Sanity check for right class */
2:eac0369: 		value = in.readObject();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10:     /** @see DataValueDescriptor#cloneValue */
1:854dd10:     public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		// Call constructor with all of our info
1:eac0369: 		return new UserType(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new UserType();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		value = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 			value = resultSet.getObject(colNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Orderable interface
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @see org.apache.derby.iapi.types.Orderable
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:073b862:     @SuppressWarnings("unchecked")
1:eac0369: 	public int compare(DataValueDescriptor other)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = other.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull	return
1:eac0369: 		 *	T		T		 	0	(this == other)
1:eac0369: 		 *	F		T		 	-1 	(this < other)
1:eac0369: 		 *	T		F		 	1	(this > other)
1:eac0369: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
1:eac0369: 				return -1;
1:eac0369: 			if (!otherNull)		// thisNull must be true
1:eac0369: 				return 1;
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			Neither are null compare them 
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int comparison;
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:073b862: 			comparison = ((java.lang.Comparable<Object>) value).compareTo(other.getObject());
1:eac0369: 		}
1:eac0369: 		catch (ClassCastException cce)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_INVALID_COMPARE_TO, 
1:eac0369: 						getTypeName(),
1:eac0369: 						ClassInspector.readableClassName(other.getObject().getClass()));
1:eac0369: 		}
1:eac0369: 		/*
1:eac0369: 		** compareTo() can return any negative number if less than, and
1:eac0369: 		** any positive number if greater than.  Change to -1, 0, 1.
1:eac0369: 		*/
1:eac0369: 		if (comparison < 0)
1:eac0369: 			comparison = -1;
1:eac0369: 		else if (comparison > 0)
1:eac0369: 			comparison = 1;
1:eac0369: 
1:eac0369: 		return comparison;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* For usertypes and equal do some special processing when
1:eac0369: 		 * neither value is null.  (Superclass will handle comparison
1:eac0369: 		 * if either value is null.)
1:eac0369: 		 */
1:eac0369: 		if ( (op == ORDER_OP_EQUALS) &&
1:eac0369: 			(! this.isNull()) && (! other.isNull()) ) 
1:eac0369: 		{
1:eac0369: 			// if this object implements java.lang.Comparable (JDK1.2)
1:eac0369: 			// then we let the compareTo method handle equality
1:eac0369: 			// if it doesn't then we use the equals() method
1:eac0369: 			Object o = getObject();
1:eac0369: 
1:eac0369: 			if (!(o instanceof java.lang.Comparable)) 
1:eac0369: 			{
1:eac0369: 				return o.equals(other.getObject());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/** no-arg constructor required by Formattable */
1:eac0369: 	public UserType() { }
1:eac0369: 
1:eac0369: 	public UserType(Object value)
1:eac0369: 	{
1:eac0369: 		this.value = value;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @see UserDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Object value)
1:eac0369: 	{
1:eac0369: 		this.value = value;
1:eac0369: 	}
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:eac0369: 		setValue(theValue.getObject());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see UserDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:9548d38: 	public void setBigDecimal(BigDecimal theValue)
1:eac0369: 	{
1:eac0369: 		// needed to allow serializable BigDecimal
1:d7f7457: 		setValue((Object) theValue);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(String theValue)
1:eac0369: 	{
1:eac0369: 		if (theValue == null)
1:eac0369: 		{
1:eac0369: 			value = null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// Higher levels must have performed type checking for us.
1:eac0369: 			value = theValue;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The = operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:eac0369: 	 * @param left			The value on the left side of the =
1:eac0369: 	 * @param right			The value on the right side of the =
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue equals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(ORDER_OP_EQUALS, right, true, false));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters
1:eac0369: 	 *			are not equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 !left.compare(ORDER_OP_EQUALS, right, true, false));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** String display of value
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return "NULL";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return value.toString();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return 0;
1:eac0369: 		return value.hashCode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int	typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.USER_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check if the value is null.  
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not value is logically null.
1:eac0369: 	 */
1:eac0369: 	public final boolean isNull()
1:eac0369: 	{
1:eac0369: 		return (value == null);
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
commit:073b862
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1: 			comparison = ((java.lang.Comparable<Object>) value).compareTo(other.getObject());
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1: 	void setObject(Object theValue)
1:     {
1:         setValue( theValue );
1:     }
1:     
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal theValue)
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:     /** @see DataValueDescriptor#cloneValue */
1:     public DataValueDescriptor cloneValue(boolean forceMaterialization)
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Get the type name of this value,  overriding
1: 	 * with the passed in class name (for user/java types).
0: 	 * @param className
0: 	 * @return
1: 	 */
1: 	String getTypeName(String className)
1: 	{
1: 		return className;
1: 	}
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0: 	public void setBigDecimal(Number theValue)
1: 		setValue((Object) theValue);
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.UserType
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.catalog.TypeDescriptor;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.UserDataValue;
1: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.*;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.math.BigDecimal;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import java.util.Calendar;
1: 
1: 
1: /**
1:  * This contains an instance of a user-defined type, that is, a java object.
1:  *
1:  */
1: 
1: public class UserType extends DataType
1: 						implements UserDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	private Object	value;
1: 
1: 	/*
1: 	** DataValueDescriptor interface
1: 	** (mostly implemented in DataType)
1: 	*/
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( UserType.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         int sz = BASE_MEMORY_USAGE;
1:         if( null != value)
1:         {
1:             // Probably an underestimate. Examining each field value would be expensive
1:             // and would produce an overestimate when fields reference shared objects
1:             sz += ClassSize.estimateAndCatalogBase( value.getClass());
1:         }
1:         
1:         return sz;
1:     } // end of estimateMemoryUsage
1: 
1: 	public String getString()
1: 	{
1: 		if (! isNull())
1: 		{
1: 			return value.toString();
1: 
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public boolean getBoolean() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			if (value instanceof Boolean) return ((Boolean)value).booleanValue();
1: 		return super.getBoolean();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public byte getByte() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow and truncation
1: 			if (value instanceof Number) return ((Number)value).byteValue();
1: 		return super.getByte();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public short getShort() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow and truncation
1: 			if (value instanceof Number) return ((Number)value).shortValue();
1: 		return super.getShort();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public int getInt() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow and truncation
1: 			if (value instanceof Number) return ((Number)value).intValue();
1: 		return super.getInt();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 
1: 	public long getLong() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow and truncation
1: 			if (value instanceof Number) return ((Number)value).longValue();
1: 		return super.getLong();
1: 	}
1: 
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public float getFloat() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow
1: 			if (value instanceof Number) return ((Number)value).floatValue();
1: 		return super.getFloat();
1: 	}
1: 
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public double getDouble() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			// REMIND: check for overflow
1: 			if (value instanceof Number) return ((Number)value).doubleValue();
1: 		return super.getDouble();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
0: 	public BigDecimal getBigDecimal() throws StandardException
1: 	{
0: 		if (! isNull()) {
0: 			if (value instanceof BigDecimal) return ((BigDecimal)value);
1: 
0: 			if (value instanceof Number)
0: 				return new BigDecimal(((Number) value).doubleValue());
1: 		}
0: 		return super.getBigDecimal();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public byte[] getBytes() throws StandardException
1: 	{
1: 		if (! isNull())
1: 			if (value instanceof byte[]) return ((byte[])value);
1: 		return super.getBytes();
1: 	}
1: 
1: 	/**
1: 
1: 		@exception StandardException thrown on failure
1: 	 */
1: 	public Date	getDate( Calendar cal) throws StandardException
1: 	{
1: 		if (! isNull())
1: 		{
1: 			if (value instanceof Date) 
1: 				return ((Date)value);
1: 			else if (value instanceof Timestamp)
1: 				return (new SQLTimestamp((Timestamp)value).getDate(cal));
1: 		}
1: 		return super.getDate(cal);
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on failure
1: 	 */
1: 	public Time	getTime( Calendar cal) throws StandardException
1: 	{
1: 		if (! isNull())
1: 		{
1: 			if (value instanceof Time) 
1: 				return ((Time)value);
1: 			else if (value instanceof Timestamp)
1: 				return (new SQLTimestamp((Timestamp)value).getTime(cal));
1: 		}
1: 		return super.getTime(cal);
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on failure
1: 	 */
1: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
1: 	{
1: 		if (! isNull())
1: 		{
1: 			if (value instanceof Timestamp) 
1: 				return ((Timestamp)value);
1: 			else if (value instanceof Date)
1: 				return (new SQLDate((Date)value).getTimestamp(cal));
1: 			else if (value instanceof Time)
1: 				return (new SQLTime((Time)value).getTimestamp(cal));
1: 		}
1: 		return super.getTimestamp(cal);
1: 	}
1: 
1: 	public Object getObject()
1: 	{
1: 		return value;
1: 	}
1: 
1: 	/**
0: 	* @see DataValueDescriptor#setObjectForCast
1: 	*
1: 	* @exception StandardException thrown on failure
1: 	*
0: 	* @return me
1: 	*/
0: 	public void setObjectForCast(Object theValue, boolean instanceOfResultType, String resultTypeClassName)
1: 		throws StandardException
1: 	{
0: 		/* This check is a performance problem.  We need to it though
0: 		 * to catch ClassCastExceptions.
1: 		 */
0: 		/* Is the object of the right type? (only do the check if value is non-null */
0: 		if (theValue != null)
1: 		{
0: 			if ( ! instanceOfResultType)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, 
0: 								getTypeName(), resultTypeClassName);
1: 			}
1: 		}
1: 
0: 		setValue(theValue);
1: 	}
1: 		
1: 	public int getLength()
1: 	{
1: 		return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
1: 	}
1: 
1: 	/* this is for DataType's error generator */
1: 	public String getTypeName()
1: 	{
1: 
1: 		return isNull() ? "JAVA_OBJECT" : ClassInspector.readableClassName(value.getClass());
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_USERTYPE_ID_V3;
1: 	}
1: 
1: 	/** 
1: 		@exception IOException error writing data
1: 
1: 	*/
1: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1: 
1: 			out.writeObject(value);
1: 	}
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on error reading the object
1: 	 * @exception ClassNotFoundException	Thrown if the class of the object
1: 	 *										is not found
1: 	 */
1: 	public void readExternal(ObjectInput in) 
1:         throws IOException, ClassNotFoundException
1: 	{
1: 		/* RESOLVE: Sanity check for right class */
1: 		value = in.readObject();
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) 
1:         throws IOException, ClassNotFoundException
1: 	{
1: 		/* RESOLVE: Sanity check for right class */
1: 		value = in.readObject();
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		// Call constructor with all of our info
1: 		return new UserType(value);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new UserType();
1: 	}
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	 *
1: 	 */
1: 
1: 	public void restoreToNull()
1: 	{
1: 		value = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException
1: 	{
1: 			value = resultSet.getObject(colNumber);
1: 	}
1: 
1: 	/**
1: 	 * Orderable interface
1: 	 *
1: 	 *
1: 	 * @see org.apache.derby.iapi.types.Orderable
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public int compare(DataValueDescriptor other)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 		boolean thisNull, otherNull;
1: 
1: 		thisNull = this.isNull();
1: 		otherNull = other.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull	return
1: 		 *	T		T		 	0	(this == other)
1: 		 *	F		T		 	-1 	(this < other)
1: 		 *	T		F		 	1	(this > other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
1: 				return -1;
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
1: 			return 0;
1: 		}
1: 
1: 		/*
1: 			Neither are null compare them 
1: 		 */
1: 
1: 		int comparison;
1: 
1: 		try
1: 		{
0: 			comparison = ((java.lang.Comparable) value).compareTo(other.getObject());
1: 		}
1: 		catch (ClassCastException cce)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_INVALID_COMPARE_TO, 
1: 						getTypeName(),
1: 						ClassInspector.readableClassName(other.getObject().getClass()));
1: 		}
1: 		/*
1: 		** compareTo() can return any negative number if less than, and
1: 		** any positive number if greater than.  Change to -1, 0, 1.
1: 		*/
1: 		if (comparison < 0)
1: 			comparison = -1;
1: 		else if (comparison > 0)
1: 			comparison = 1;
1: 
1: 		return comparison;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || other.isNull())
1: 				return unknownRV;
1: 		}
1: 
1: 		/* For usertypes and equal do some special processing when
1: 		 * neither value is null.  (Superclass will handle comparison
1: 		 * if either value is null.)
1: 		 */
1: 		if ( (op == ORDER_OP_EQUALS) &&
1: 			(! this.isNull()) && (! other.isNull()) ) 
1: 		{
1: 			// if this object implements java.lang.Comparable (JDK1.2)
1: 			// then we let the compareTo method handle equality
1: 			// if it doesn't then we use the equals() method
1: 			Object o = getObject();
1: 
1: 			if (!(o instanceof java.lang.Comparable)) 
1: 			{
1: 				return o.equals(other.getObject());
1: 			}
1: 		}
1: 		
1: 
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/*
1: 	** Class interface
1: 	*/
1: 
1: 	/*
1: 	** Constructors
1: 	*/
1: 
1: 	/** no-arg constructor required by Formattable */
1: 	public UserType() { }
1: 
1: 	public UserType(Object value)
1: 	{
1: 		this.value = value;
1: 	}
1: 	/**
1: 	 * @see UserDataValue#setValue
1: 	 *
1: 	 */
1: 	public void setValue(Object value)
1: 	{
1: 		this.value = value;
1: 	}
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
1: 		setValue(theValue.getObject());
1: 	}
1: 
1: 	/**
1: 	 * @see UserDataValue#setValue
1: 	 *
1: 	 */
0: 	public void setValue(BigDecimal value)
1: 	{
1: 		// needed to allow serializable BigDecimal
0: 		setValue((Object) value);
1: 	}
1: 
1: 	public void setValue(String theValue)
1: 	{
1: 		if (theValue == null)
1: 		{
1: 			value = null;
1: 		}
1: 		else
1: 		{
1: 			// Higher levels must have performed type checking for us.
1: 			value = theValue;
1: 		}
1: 	}
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 	/**
1: 	 * The = operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
1: 	 * @param left			The value on the left side of the =
1: 	 * @param right			The value on the right side of the =
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue equals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(ORDER_OP_EQUALS, right, true, false));
1: 	}
1: 
1: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters
1: 	 *			are not equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 !left.compare(ORDER_OP_EQUALS, right, true, false));
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** String display of value
1: 	*/
1: 
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return "NULL";
1: 		}
1: 		else
1: 		{
1: 			return value.toString();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		if (isNull())
1: 			return 0;
1: 		return value.hashCode();
1: 	}
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int	typePrecedence()
1: 	{
1: 		return TypeId.USER_PRECEDENCE;
1: 	}
1: 
1: 	/**
1: 	 * Check if the value is null.  
1: 	 *
1: 	 * @return Whether or not value is logically null.
1: 	 */
1: 	public final boolean isNull()
1: 	{
1: 		return (value == null);
1: 	}
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c2d0dcc
/////////////////////////////////////////////////////////////////////////
0: 				return new BigDecimal(Double.toString(((Number) value).doubleValue()));
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.UserDataValue;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.*;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.math.BigDecimal;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: import java.util.Calendar;
0: 
0: 
0: /**
0:  * This contains an instance of a user-defined type, that is, a java object.
0:  *
0:  */
0: 
0: public class UserType extends DataType
0: 						implements UserDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private Object	value;
0: 
0: 	/*
0: 	** DataValueDescriptor interface
0: 	** (mostly implemented in DataType)
0: 	*/
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( UserType.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE;
0:         if( null != value)
0:         {
0:             // Probably an underestimate. Examining each field value would be expensive
0:             // and would produce an overestimate when fields reference shared objects
0:             sz += ClassSize.estimateAndCatalogBase( value.getClass());
0:         }
0:         
0:         return sz;
0:     } // end of estimateMemoryUsage
0: 
0: 	public String getString()
0: 	{
0: 		if (! isNull())
0: 		{
0: 			return value.toString();
0: 
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public boolean getBoolean() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			if (value instanceof Boolean) return ((Boolean)value).booleanValue();
0: 		return super.getBoolean();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public byte getByte() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow and truncation
0: 			if (value instanceof Number) return ((Number)value).byteValue();
0: 		return super.getByte();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public short getShort() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow and truncation
0: 			if (value instanceof Number) return ((Number)value).shortValue();
0: 		return super.getShort();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public int getInt() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow and truncation
0: 			if (value instanceof Number) return ((Number)value).intValue();
0: 		return super.getInt();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 
0: 	public long getLong() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow and truncation
0: 			if (value instanceof Number) return ((Number)value).longValue();
0: 		return super.getLong();
0: 	}
0: 
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public float getFloat() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow
0: 			if (value instanceof Number) return ((Number)value).floatValue();
0: 		return super.getFloat();
0: 	}
0: 
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public double getDouble() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			// REMIND: check for overflow
0: 			if (value instanceof Number) return ((Number)value).doubleValue();
0: 		return super.getDouble();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public BigDecimal getBigDecimal() throws StandardException
0: 	{
0: 		if (! isNull()) {
0: 			if (value instanceof BigDecimal) return ((BigDecimal)value);
0: 
0: 			if (value instanceof Number)
0: 				return new BigDecimal(((Number) value).doubleValue());
0: 		}
0: 		return super.getBigDecimal();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public byte[] getBytes() throws StandardException
0: 	{
0: 		if (! isNull())
0: 			if (value instanceof byte[]) return ((byte[])value);
0: 		return super.getBytes();
0: 	}
0: 
0: 	/**
0: 
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Date	getDate( Calendar cal) throws StandardException
0: 	{
0: 		if (! isNull())
0: 		{
0: 			if (value instanceof Date) 
0: 				return ((Date)value);
0: 			else if (value instanceof Timestamp)
0: 				return (new SQLTimestamp((Timestamp)value).getDate(cal));
0: 		}
0: 		return super.getDate(cal);
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Time	getTime( Calendar cal) throws StandardException
0: 	{
0: 		if (! isNull())
0: 		{
0: 			if (value instanceof Time) 
0: 				return ((Time)value);
0: 			else if (value instanceof Timestamp)
0: 				return (new SQLTimestamp((Timestamp)value).getTime(cal));
0: 		}
0: 		return super.getTime(cal);
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
0: 	{
0: 		if (! isNull())
0: 		{
0: 			if (value instanceof Timestamp) 
0: 				return ((Timestamp)value);
0: 			else if (value instanceof Date)
0: 				return (new SQLDate((Date)value).getTimestamp(cal));
0: 			else if (value instanceof Time)
0: 				return (new SQLTime((Time)value).getTimestamp(cal));
0: 		}
0: 		return super.getTimestamp(cal);
0: 	}
0: 
0: 	public Object getObject()
0: 	{
0: 		return value;
0: 	}
0: 
0: 	/**
0: 	* @see DataValueDescriptor#setObjectForCast
0: 	*
0: 	* @exception StandardException thrown on failure
0: 	*
0: 	* @return me
0: 	*/
0: 	public void setObjectForCast(Object theValue, boolean instanceOfResultType, String resultTypeClassName)
0: 		throws StandardException
0: 	{
0: 		/* This check is a performance problem.  We need to it though
0: 		 * to catch ClassCastExceptions.
0: 		 */
0: 		/* Is the object of the right type? (only do the check if value is non-null */
0: 		if (theValue != null)
0: 		{
0: 			if ( ! instanceOfResultType)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, 
0: 								getTypeName(), resultTypeClassName);
0: 			}
0: 		}
0: 
0: 		setValue(theValue);
0: 	}
0: 		
0: 	public int getLength()
0: 	{
0: 		return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
0: 	}
0: 
0: 	/* this is for DataType's error generator */
0: 	public String getTypeName()
0: 	{
0: 
0: 		return isNull() ? "JAVA_OBJECT" : ClassInspector.readableClassName(value.getClass());
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_USERTYPE_ID_V3;
0: 	}
0: 
0: 	/** 
0: 		@exception IOException error writing data
0: 
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
0: 
0: 			out.writeObject(value);
0: 	}
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on error reading the object
0: 	 * @exception ClassNotFoundException	Thrown if the class of the object
0: 	 *										is not found
0: 	 */
0: 	public void readExternal(ObjectInput in) 
0:         throws IOException, ClassNotFoundException
0: 	{
0: 		/* RESOLVE: Sanity check for right class */
0: 		value = in.readObject();
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) 
0:         throws IOException, ClassNotFoundException
0: 	{
0: 		/* RESOLVE: Sanity check for right class */
0: 		value = in.readObject();
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		// Call constructor with all of our info
0: 		return new UserType(value);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new UserType();
0: 	}
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	 *
0: 	 */
0: 
0: 	public void restoreToNull()
0: 	{
0: 		value = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException
0: 	{
0: 			value = resultSet.getObject(colNumber);
0: 	}
0: 
0: 	/**
0: 	 * Orderable interface
0: 	 *
0: 	 *
0: 	 * @see org.apache.derby.iapi.types.Orderable
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public int compare(DataValueDescriptor other)
0: 		throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 		boolean thisNull, otherNull;
0: 
0: 		thisNull = this.isNull();
0: 		otherNull = other.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull	return
0: 		 *	T		T		 	0	(this == other)
0: 		 *	F		T		 	-1 	(this < other)
0: 		 *	T		F		 	1	(this > other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return 1;
0: 			return 0;
0: 		}
0: 
0: 		/*
0: 			Neither are null compare them 
0: 		 */
0: 
0: 		int comparison;
0: 
0: 		try
0: 		{
0: 			comparison = ((java.lang.Comparable) value).compareTo(other.getObject());
0: 		}
0: 		catch (ClassCastException cce)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_COMPARE_TO, 
0: 						getTypeName(),
0: 						ClassInspector.readableClassName(other.getObject().getClass()));
0: 		}
0: 		/*
0: 		** compareTo() can return any negative number if less than, and
0: 		** any positive number if greater than.  Change to -1, 0, 1.
0: 		*/
0: 		if (comparison < 0)
0: 			comparison = -1;
0: 		else if (comparison > 0)
0: 			comparison = 1;
0: 
0: 		return comparison;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || other.isNull())
0: 				return unknownRV;
0: 		}
0: 
0: 		/* For usertypes and equal do some special processing when
0: 		 * neither value is null.  (Superclass will handle comparison
0: 		 * if either value is null.)
0: 		 */
0: 		if ( (op == ORDER_OP_EQUALS) &&
0: 			(! this.isNull()) && (! other.isNull()) ) 
0: 		{
0: 			// if this object implements java.lang.Comparable (JDK1.2)
0: 			// then we let the compareTo method handle equality
0: 			// if it doesn't then we use the equals() method
0: 			Object o = getObject();
0: 
0: 			if (!(o instanceof java.lang.Comparable)) 
0: 			{
0: 				return o.equals(other.getObject());
0: 			}
0: 		}
0: 		
0: 
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/*
0: 	** Class interface
0: 	*/
0: 
0: 	/*
0: 	** Constructors
0: 	*/
0: 
0: 	/** no-arg constructor required by Formattable */
0: 	public UserType() { }
0: 
0: 	public UserType(Object value)
0: 	{
0: 		this.value = value;
0: 	}
0: 	/**
0: 	 * @see UserDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(Object value)
0: 	{
0: 		this.value = value;
0: 	}
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		setValue(theValue.getObject());
0: 	}
0: 
0: 	/**
0: 	 * @see UserDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(BigDecimal value)
0: 	{
0: 		// needed to allow serializable BigDecimal
0: 		setValue((Object) value);
0: 	}
0: 
0: 	public void setValue(String theValue)
0: 	{
0: 		if (theValue == null)
0: 		{
0: 			value = null;
0: 		}
0: 		else
0: 		{
0: 			// Higher levels must have performed type checking for us.
0: 			value = theValue;
0: 		}
0: 	}
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 	/**
0: 	 * The = operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the =
0: 	 * @param right			The value on the right side of the =
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters are equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue equals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(ORDER_OP_EQUALS, right, true, false));
0: 	}
0: 
0: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters
0: 	 *			are not equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue notEquals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 !left.compare(ORDER_OP_EQUALS, right, true, false));
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	** String display of value
0: 	*/
0: 
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return "NULL";
0: 		}
0: 		else
0: 		{
0: 			return value.toString();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		if (isNull())
0: 			return 0;
0: 		return value.hashCode();
0: 	}
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int	typePrecedence()
0: 	{
0: 		return TypeId.USER_PRECEDENCE;
0: 	}
0: 
0: 	/**
0: 	 * Check if the value is null.  
0: 	 *
0: 	 * @return Whether or not value is logically null.
0: 	 */
0: 	public final boolean isNull()
0: 	{
0: 		return (value == null);
0: 	}
0: }
0: 
============================================================================