1:eac0369: /*
2:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.StoreCostController
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: The StoreCostController interface provides methods that an access client
1:eac0369: (most likely the system optimizer) can use to get store's estimated cost of
1:eac0369: various operations on the conglomerate the StoreCostController was opened
1:eac0369: for.
1:eac0369: <p>
1:eac0369: It is likely that the implementation of StoreCostController will open 
1:eac0369: the conglomerate and will leave the conglomerate open until the
1:eac0369: StoreCostController is closed.  This represents a significant amount of
1:eac0369: work, so the caller if possible should attempt to open the StoreCostController
1:eac0369: once per unit of work and rather than close and reopen the controller.  For
1:eac0369: instance if the optimizer needs to cost 2 different scans against a single
1:eac0369: conglomerate, it should use one instance of the StoreCostController.
1:eac0369: <p>
1:eac0369: The locking behavior of the implementation of a StoreCostController is
1:eac0369: undefined, it may or may not get locks on the underlying conglomerate.  It
1:eac0369: may or may not hold locks until end of transaction.  
1:eac0369: An optimal implementation will not get any locks on the underlying 
1:eac0369: conglomerate, thus allowing concurrent access to the table by a executing
1:eac0369: query while another query is optimizing.
1:eac0369: <p>
1:eac0369: @see TransactionController#openStoreCost
1:eac0369: @see RowCountable
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public interface StoreCostController extends RowCountable
1:eac0369: {
1:eac0369:     // The folllowing constants should only be used by StoreCostController
1:eac0369:     // implementors.
1:eac0369: 
1:eac0369:     // The base cost to fetch a cached page, and select a single
1:eac0369:     // heap row by RowLocation, fetching 0 columns.
1:eac0369:     public static final double BASE_CACHED_ROW_FETCH_COST = 0.17;
1:eac0369: 
1:eac0369:     // The base cost to page in a page from disk to cache, and select a single
1:eac0369:     // heap row by RowLocation, fetching 0 columns.
1:eac0369:     public static final double BASE_UNCACHED_ROW_FETCH_COST = 1.5;
1:eac0369: 
1:eac0369:     // The base cost to fetch a single row as part of group fetch scan with
1:eac0369:     // 16 rows per group, fetching 0 columns.
1:eac0369:     public static final double BASE_GROUPSCAN_ROW_COST = 0.12;
1:eac0369: 
1:eac0369:     // The base cost to fetch a single row as part of a nongroup fetch scan
1:eac0369:     // fetching 0 columns.
1:eac0369:     public static final double BASE_NONGROUPSCAN_ROW_FETCH_COST = 0.25;
1:eac0369: 
1:eac0369:     // The base cost to fetch a single row as part of a nongroup fetch scan
1:eac0369:     // fetching 1 columns.
1:eac0369:     public static final double BASE_HASHSCAN_ROW_FETCH_COST = 0.14;
1:eac0369: 
1:eac0369: 
1:eac0369:     // This is an estimate of the per byte cost associated with fetching the 
1:eac0369:     // row from the table, it just assumes the cost scales per byte which is 
1:eac0369:     // probably not true, but a good first guess.  It is meant to be added
1:eac0369:     // to the above costs - for instance the cost of fetching a 100 byte 
1:eac0369:     // row from a page assumed to be in the cache is:
1:eac0369:     //     BASE_CACHED_ROW_FETCH_COST + (100 * BASE_ROW_PER_BYTECOST)
1:eac0369:     //
1:eac0369:     // The estimate for this number is the cost of retrieving all cost from
1:eac0369:     // a cached 100 byte row - the cost of getting 0 colums from cached row.
1:eac0369:     public static final double BASE_ROW_PER_BYTECOST = (0.56 - 0.16) / 100;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Indicates that access to the page necessary to fulfill the fetch
1:eac0369:      * request is likely to be a page "recently" used.  See 
1:eac0369:      * getFetchFromFullKeyCost() and getScanCost().
1:eac0369:      **/
1:eac0369:     public static final int STORECOST_CLUSTERED = 0x01;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Used for the scan_type parameter to the getScanCost() routine.
1:eac0369:      * STORECOST_SCAN_NORMAL indicates that the scan will use the standard 
1:eac0369:      * next/fetch, where each fetch can retrieve 1 or many rows (if 
1:eac0369:      * fetchNextGroup() interface is used).
1:eac0369:      **/
1:eac0369:     public static final int STORECOST_SCAN_SET      = 0x01;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Used for the scan_type parameter to the getScanCost() routine.
1:eac0369:      * STORECOST_SCAN_SET - The entire result set will be retrieved using the
1:eac0369:      * the fetchSet() interface.
1:eac0369:      **/
1:eac0369:     public static final int STORECOST_SCAN_NORMAL   = 0x02;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close the controller.
1:eac0369:      * <p>
1:eac0369:      * Close the open controller.  This method always succeeds, and never 
1:eac0369:      * throws any exceptions. Callers must not use the StoreCostController 
1:eac0369:      * Cost controller after closing it; they are strongly advised to clear
1:eac0369:      * out the scan controller reference after closing.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     void close()
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of calling ConglomerateController.fetch().
1:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ConglomerateController.fetch()
1:eac0369:      * on the current conglomerate.  This gives the cost of finding a record
1:eac0369:      * in the conglomerate given the exact RowLocation of the record in
1:eac0369:      * question. 
1:eac0369:      * <p>
1:eac0369:      * The validColumns parameter describe what kind of row 
1:eac0369:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
1:eac0369:      * complete row.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "templateRow."  templateRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ConglomerateController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one fetch
1:eac0369:      *                            is likely clustered "close" to the next 
1:eac0369:      *                            fetch.  For instance if the query plan were
1:eac0369:      *                            to sort the RowLocations of a heap and then
1:eac0369:      *                            use those RowLocations sequentially to 
1:eac0369:      *                            probe into the heap, then this flag should
1:eac0369:      *                            be specified.  If this flag is not set then
1:eac0369:      *                            access to the table is assumed to be
1:eac0369:      *                            random - ie. the type of access one gets 
1:eac0369:      *                            if you scan an index and probe each row
1:eac0369:      *                            in turn into the base table is "random".
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromRowLocationCost(
1:eac0369:     FormatableBitSet     validColumns,
1:eac0369:     int         access_type)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of exact key lookup.
1:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ScanController.fetch()
1:eac0369:      * on the current conglomerate, with start and stop positions set such
1:eac0369:      * that an exact match is expected.
1:eac0369:      * <p>
1:eac0369:      * This call returns the cost of a fetchNext() performed on a scan which
1:eac0369:      * has been positioned with a start position which specifies exact match
1:eac0369:      * on all keys in the row.
1:eac0369:      * <p>
1:eac0369:      * Example:
1:eac0369:      * <p>
1:eac0369:      * In the case of a btree this call can be used to determine the cost of
1:eac0369:      * doing an exact probe into btree, giving all key columns.  This cost
1:eac0369:      * can be used if the client knows it will be doing an exact key probe
1:eac0369:      * but does not have the key's at optimize time to use to make a call to
1:eac0369:      * getScanCost()
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "templateRow."  templateRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
1:eac0369:      *                            is likely clustered "close" to the previous 
1:eac0369:      *                            scan.  For instance if the query plan were
1:eac0369:      *                            to used repeated "reopenScan()'s" to probe
1:eac0369:      *                            for the next key in an index, then this flag
1:eac0369:      *                            should be be specified.  If this flag is not 
1:eac0369:      *                            set then each scan will be costed independant
1:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
1:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromFullKeyCost(
1:eac0369:     FormatableBitSet     validColumns,
1:eac0369:     int         access_type)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Calculate the cost of a scan.
1:eac0369:      * <p>
1:eac0369:      * Cause this object to calculate the cost of performing the described
1:eac0369:      * scan.  The interface is setup such that first a call is made to
1:eac0369:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:eac0369:      * are made to get various pieces of information about the cost of
1:eac0369:      * the scan.
1:eac0369:      * <p>
1:eac0369:      * For the purposes of costing this routine is going to assume that 
1:eac0369:      * a page will remain in cache between the time one next()/fetchNext()
1:eac0369:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:eac0369:      * <p>
1:eac0369:      * The result of costing the scan is placed in the "cost_result".  
1:eac0369:      * The cost of the scan is stored by calling 
1:eac0369:      * cost_result.setEstimatedCost(cost).
1:eac0369:      * The estimated row count is stored by calling 
1:eac0369:      * cost_result.setEstimatedRowCount(row_count).
1:eac0369:      * <p>
1:eac0369:      * The estimated cost of the scan assumes the caller will 
1:eac0369:      * execute a fetchNext() loop for every row that qualifies between
1:eac0369:      * start and stop position.  Note that this cost is different than
1:eac0369:      * execution a next(),fetch() loop; or if the scan is going to be
1:eac0369:      * terminated by client prior to reaching the stop condition.
1:eac0369:      * <p>
1:eac0369:      * The estimated number of rows returned from the scan 
1:eac0369:      * assumes the caller will execute a fetchNext() loop for every 
1:eac0369:      * row that qualifies between start and stop position.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param scan_type       The type of scan that will be executed.  There
1:eac0369:      *                        are currently 2 types:
1:eac0369:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:eac0369:      *                        using the standard next/fetch, where each fetch
1:eac0369:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:eac0369:      *                        interface is used).
1:eac0369:      *
1:eac0369:      *                        STORECOST_SCAN_SET - The entire result set will
1:eac0369:      *                        be retrieved using the the fetchSet() interface.
1:eac0369:      *
1:eac0369:      * @param row_count       Estimated total row count of the table.  The 
1:eac0369:      *                        current system tracks row counts in heaps better
1:eac0369:      *                        than btree's (btree's have "rows" which are not
1:eac0369:      *                        user rows - branch rows, control rows), so 
1:eac0369:      *                        if available the client should
1:eac0369:      *                        pass in the base table's row count into this
1:eac0369:      *                        routine to be used as the index's row count.
1:eac0369:      *                        If the caller has no idea, pass in -1.
1:eac0369:      *
1:eac0369:      * @param group_size      The number of rows to be returned by a single
1:eac0369:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:eac0369:      *
1:eac0369: 	 * @param forUpdate       Should be true if the caller intends to update 
1:eac0369:      *                        through the scan.
1:eac0369:      * 
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan.  template, 
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      * 
1:eac0369:      * @param template        A prototypical row which the scan may use to
1:eac0369: 	 *                        maintain its position in the conglomerate.  Not 
1:eac0369:      *                        all access method scan types will require this, 
1:eac0369:      *                        if they don't it's ok to pass in null.
1:eac0369:      *                        In order to scan a conglomerate one must 
1:eac0369:      *                        allocate 2 separate "row" templates.  The "row" 
1:eac0369:      *                        template passed into openScan is for the private
1:eac0369:      *                        use of the scan itself, and no access to it
1:eac0369:      *                        should be made by the caller while the scan is 
1:eac0369:      *                        still open.  Because of this the scanner must 
1:eac0369:      *                        allocate another "row" template to hold the 
1:eac0369:      *                        values returned from fetch().  Note that this 
1:eac0369:      *                        template must be for the full row, whether a 
1:eac0369:      *                        partial row scan is being executed or not.
1:eac0369:      *
1:eac0369: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        startSearchOperator, defines the starting 
1:eac0369:      *                        position of the scan.  If null, the starting
1:eac0369:      *                        position of the scan is the first row of the 
1:eac0369:      *                        conglomerate.  The startKeyValue must only
1:eac0369:      *                        reference columns included in the scanColumnList.
1:eac0369:      *
1:f2ee915: 	 * @param startSearchOperator 
1:eac0369:      *                        an operator which defines how the startKeyValue
1:eac0369:      *                        is to be searched for.  If startSearchOperation 
1:eac0369:      *                        is ScanController.GE, the scan starts on the 
1:eac0369:      *                        first row which is greater than or equal to the 
1:eac0369: 	 *                        startKeyValue.  If startSearchOperation is 
1:eac0369:      *                        ScanController.GT, the scan starts on the first
1:eac0369:      *                        row whose key is greater than startKeyValue.  The
1:eac0369:      *                        startSearchOperation parameter is ignored if the
1:eac0369:      *                        startKeyValue parameter is null.
1:eac0369:      *
1:eac0369: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:eac0369:      *                        value which, in combination with the 
1:eac0369:      *                        stopSearchOperator, defines the ending position
1:eac0369:      *                        of the scan.  If null, the ending position of the
1:eac0369:      *                        scan is the last row of the conglomerate.  The
1:eac0369:      *                        stopKeyValue must only reference columns included
1:eac0369:      *                        in the scanColumnList.
1:eac0369:      *
1:f2ee915: 	 * @param stopSearchOperator
1:eac0369:      *                        an operator which defines how the stopKeyValue
1:eac0369:      *                        is used to determine the scan stopping position. 
1:eac0369:      *                        If stopSearchOperation is ScanController.GE, the
1:eac0369:      *                        scan stops just before the first row which is
1:eac0369:      *                        greater than or equal to the stopKeyValue.  If 
1:eac0369:      *                        stopSearchOperation is ScanController.GT, the 
1:eac0369:      *                        scan stops just before the first row whose key 
1:eac0369:      *                        is greater than startKeyValue.  The
1:eac0369:      *                        stopSearchOperation parameter is ignored if the
1:eac0369:      *                        stopKeyValue parameter is null.
1:eac0369:      *
1:eac0369:      *                        
1:eac0369:      * @param access_type     Describe the type of access the query will be
1:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
1:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
1:eac0369:      *                            is likely clustered "close" to the previous 
1:eac0369:      *                            scan.  For instance if the query plan were
1:eac0369:      *                            to used repeated "reopenScan()'s" to probe
1:eac0369:      *                            for the next key in an index, then this flag
1:eac0369:      *                            should be be specified.  If this flag is not 
1:eac0369:      *                            set then each scan will be costed independant
1:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369: 	public void getScanCost(
1:eac0369:         int                     scan_type,
1:eac0369:         long                    row_count,
1:eac0369:         int                     group_size,
1:eac0369: 		boolean                 forUpdate,
1:eac0369: 		FormatableBitSet                 scanColumnList,
1:eac0369: 		DataValueDescriptor[]   template,
1:eac0369: 		DataValueDescriptor[]   startKeyValue,
1:eac0369: 		int                     startSearchOperator,
1:eac0369: 		DataValueDescriptor[]   stopKeyValue,
1:eac0369: 		int                     stopSearchOperator,
1:eac0369:         boolean                 reopen_scan,
1:eac0369:         int                     access_type,
1:eac0369:         StoreCostResult         cost_result)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an "empty" row location object of the correct type.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The empty Rowlocation.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f2ee915
/////////////////////////////////////////////////////////////////////////
1: 	 * @param startSearchOperator 
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stopSearchOperator
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.StoreCostController
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1: 
1: The StoreCostController interface provides methods that an access client
1: (most likely the system optimizer) can use to get store's estimated cost of
1: various operations on the conglomerate the StoreCostController was opened
1: for.
1: <p>
1: It is likely that the implementation of StoreCostController will open 
1: the conglomerate and will leave the conglomerate open until the
1: StoreCostController is closed.  This represents a significant amount of
1: work, so the caller if possible should attempt to open the StoreCostController
1: once per unit of work and rather than close and reopen the controller.  For
1: instance if the optimizer needs to cost 2 different scans against a single
1: conglomerate, it should use one instance of the StoreCostController.
1: <p>
1: The locking behavior of the implementation of a StoreCostController is
1: undefined, it may or may not get locks on the underlying conglomerate.  It
1: may or may not hold locks until end of transaction.  
1: An optimal implementation will not get any locks on the underlying 
1: conglomerate, thus allowing concurrent access to the table by a executing
1: query while another query is optimizing.
1: <p>
1: @see TransactionController#openStoreCost
1: @see RowCountable
1: 
1: **/
1: 
1: public interface StoreCostController extends RowCountable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1:     // The folllowing constants should only be used by StoreCostController
1:     // implementors.
1: 
1:     // The base cost to fetch a cached page, and select a single
1:     // heap row by RowLocation, fetching 0 columns.
1:     public static final double BASE_CACHED_ROW_FETCH_COST = 0.17;
1: 
1:     // The base cost to page in a page from disk to cache, and select a single
1:     // heap row by RowLocation, fetching 0 columns.
1:     public static final double BASE_UNCACHED_ROW_FETCH_COST = 1.5;
1: 
1:     // The base cost to fetch a single row as part of group fetch scan with
1:     // 16 rows per group, fetching 0 columns.
1:     public static final double BASE_GROUPSCAN_ROW_COST = 0.12;
1: 
1:     // The base cost to fetch a single row as part of a nongroup fetch scan
1:     // fetching 0 columns.
1:     public static final double BASE_NONGROUPSCAN_ROW_FETCH_COST = 0.25;
1: 
1:     // The base cost to fetch a single row as part of a nongroup fetch scan
1:     // fetching 1 columns.
1:     public static final double BASE_HASHSCAN_ROW_FETCH_COST = 0.14;
1: 
1: 
1:     // This is an estimate of the per byte cost associated with fetching the 
1:     // row from the table, it just assumes the cost scales per byte which is 
1:     // probably not true, but a good first guess.  It is meant to be added
1:     // to the above costs - for instance the cost of fetching a 100 byte 
1:     // row from a page assumed to be in the cache is:
1:     //     BASE_CACHED_ROW_FETCH_COST + (100 * BASE_ROW_PER_BYTECOST)
1:     //
1:     // The estimate for this number is the cost of retrieving all cost from
1:     // a cached 100 byte row - the cost of getting 0 colums from cached row.
1:     public static final double BASE_ROW_PER_BYTECOST = (0.56 - 0.16) / 100;
1: 
1:     /**
1:      * Indicates that access to the page necessary to fulfill the fetch
1:      * request is likely to be a page "recently" used.  See 
1:      * getFetchFromFullKeyCost() and getScanCost().
1:      **/
1:     public static final int STORECOST_CLUSTERED = 0x01;
1: 
1:     /**
1:      * Used for the scan_type parameter to the getScanCost() routine.
1:      * STORECOST_SCAN_NORMAL indicates that the scan will use the standard 
1:      * next/fetch, where each fetch can retrieve 1 or many rows (if 
1:      * fetchNextGroup() interface is used).
1:      **/
1:     public static final int STORECOST_SCAN_SET      = 0x01;
1: 
1: 
1:     /**
1:      * Used for the scan_type parameter to the getScanCost() routine.
1:      * STORECOST_SCAN_SET - The entire result set will be retrieved using the
1:      * the fetchSet() interface.
1:      **/
1:     public static final int STORECOST_SCAN_NORMAL   = 0x02;
1: 
1:     /**
1:      * Close the controller.
1:      * <p>
1:      * Close the open controller.  This method always succeeds, and never 
1:      * throws any exceptions. Callers must not use the StoreCostController 
1:      * Cost controller after closing it; they are strongly advised to clear
1:      * out the scan controller reference after closing.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void close()
1:         throws StandardException;
1: 
1:     /**
1:      * Return the cost of calling ConglomerateController.fetch().
1:      * <p>
1:      * Return the estimated cost of calling ConglomerateController.fetch()
1:      * on the current conglomerate.  This gives the cost of finding a record
1:      * in the conglomerate given the exact RowLocation of the record in
1:      * question. 
1:      * <p>
1:      * The validColumns parameter describe what kind of row 
1:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
1:      * complete row.
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ConglomerateController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one fetch
1:      *                            is likely clustered "close" to the next 
1:      *                            fetch.  For instance if the query plan were
1:      *                            to sort the RowLocations of a heap and then
1:      *                            use those RowLocations sequentially to 
1:      *                            probe into the heap, then this flag should
1:      *                            be specified.  If this flag is not set then
1:      *                            access to the table is assumed to be
1:      *                            random - ie. the type of access one gets 
1:      *                            if you scan an index and probe each row
1:      *                            in turn into the base table is "random".
1:      *
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromRowLocationCost(
1:     FormatableBitSet     validColumns,
1:     int         access_type)
1: 		throws StandardException;
1: 
1:     /**
1:      * Return the cost of exact key lookup.
1:      * <p>
1:      * Return the estimated cost of calling ScanController.fetch()
1:      * on the current conglomerate, with start and stop positions set such
1:      * that an exact match is expected.
1:      * <p>
1:      * This call returns the cost of a fetchNext() performed on a scan which
1:      * has been positioned with a start position which specifies exact match
1:      * on all keys in the row.
1:      * <p>
1:      * Example:
1:      * <p>
1:      * In the case of a btree this call can be used to determine the cost of
1:      * doing an exact probe into btree, giving all key columns.  This cost
1:      * can be used if the client knows it will be doing an exact key probe
1:      * but does not have the key's at optimize time to use to make a call to
1:      * getScanCost()
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromFullKeyCost(
1:     FormatableBitSet     validColumns,
1:     int         access_type)
1: 		throws StandardException;
1: 
1:     /**
1:      * Calculate the cost of a scan.
1:      * <p>
1:      * Cause this object to calculate the cost of performing the described
1:      * scan.  The interface is setup such that first a call is made to
1:      * calcualteScanCost(), and then subsequent calls to accessor routines
1:      * are made to get various pieces of information about the cost of
1:      * the scan.
1:      * <p>
1:      * For the purposes of costing this routine is going to assume that 
1:      * a page will remain in cache between the time one next()/fetchNext()
1:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:      * <p>
1:      * The result of costing the scan is placed in the "cost_result".  
1:      * The cost of the scan is stored by calling 
1:      * cost_result.setEstimatedCost(cost).
1:      * The estimated row count is stored by calling 
1:      * cost_result.setEstimatedRowCount(row_count).
1:      * <p>
1:      * The estimated cost of the scan assumes the caller will 
1:      * execute a fetchNext() loop for every row that qualifies between
1:      * start and stop position.  Note that this cost is different than
1:      * execution a next(),fetch() loop; or if the scan is going to be
1:      * terminated by client prior to reaching the stop condition.
1:      * <p>
1:      * The estimated number of rows returned from the scan 
1:      * assumes the caller will execute a fetchNext() loop for every 
1:      * row that qualifies between start and stop position.
1:      * <p>
1:      *
1:      *
1:      * @param scan_type       The type of scan that will be executed.  There
1:      *                        are currently 2 types:
1:      *                        STORECOST_SCAN_NORMAL - scans will be executed
1:      *                        using the standard next/fetch, where each fetch
1:      *                        can retrieve 1 or many rows (if fetchNextGroup()
1:      *                        interface is used).
1:      *
1:      *                        STORECOST_SCAN_SET - The entire result set will
1:      *                        be retrieved using the the fetchSet() interface.
1:      *
1:      * @param row_count       Estimated total row count of the table.  The 
1:      *                        current system tracks row counts in heaps better
1:      *                        than btree's (btree's have "rows" which are not
1:      *                        user rows - branch rows, control rows), so 
1:      *                        if available the client should
1:      *                        pass in the base table's row count into this
1:      *                        routine to be used as the index's row count.
1:      *                        If the caller has no idea, pass in -1.
1:      *
1:      * @param group_size      The number of rows to be returned by a single
1:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:      *
1: 	 * @param forUpdate       Should be true if the caller intends to update 
1:      *                        through the scan.
1:      * 
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan.  template, 
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      * 
1:      * @param template        A prototypical row which the scan may use to
1: 	 *                        maintain its position in the conglomerate.  Not 
1:      *                        all access method scan types will require this, 
1:      *                        if they don't it's ok to pass in null.
1:      *                        In order to scan a conglomerate one must 
1:      *                        allocate 2 separate "row" templates.  The "row" 
1:      *                        template passed into openScan is for the private
1:      *                        use of the scan itself, and no access to it
1:      *                        should be made by the caller while the scan is 
1:      *                        still open.  Because of this the scanner must 
1:      *                        allocate another "row" template to hold the 
1:      *                        values returned from fetch().  Note that this 
1:      *                        template must be for the full row, whether a 
1:      *                        partial row scan is being executed or not.
1:      *
1: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        startSearchOperator, defines the starting 
1:      *                        position of the scan.  If null, the starting
1:      *                        position of the scan is the first row of the 
1:      *                        conglomerate.  The startKeyValue must only
1:      *                        reference columns included in the scanColumnList.
1:      *
0: 	 * @param startSearchOperation 
1:      *                        an operator which defines how the startKeyValue
1:      *                        is to be searched for.  If startSearchOperation 
1:      *                        is ScanController.GE, the scan starts on the 
1:      *                        first row which is greater than or equal to the 
1: 	 *                        startKeyValue.  If startSearchOperation is 
1:      *                        ScanController.GT, the scan starts on the first
1:      *                        row whose key is greater than startKeyValue.  The
1:      *                        startSearchOperation parameter is ignored if the
1:      *                        startKeyValue parameter is null.
1:      *
1: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
1:      *                        value which, in combination with the 
1:      *                        stopSearchOperator, defines the ending position
1:      *                        of the scan.  If null, the ending position of the
1:      *                        scan is the last row of the conglomerate.  The
1:      *                        stopKeyValue must only reference columns included
1:      *                        in the scanColumnList.
1:      *
0: 	 * @param stopSearchOperation
1:      *                        an operator which defines how the stopKeyValue
1:      *                        is used to determine the scan stopping position. 
1:      *                        If stopSearchOperation is ScanController.GE, the
1:      *                        scan stops just before the first row which is
1:      *                        greater than or equal to the stopKeyValue.  If 
1:      *                        stopSearchOperation is ScanController.GT, the 
1:      *                        scan stops just before the first row whose key 
1:      *                        is greater than startKeyValue.  The
1:      *                        stopSearchOperation parameter is ignored if the
1:      *                        stopKeyValue parameter is null.
1:      *
1:      *                        
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1: 	public void getScanCost(
1:         int                     scan_type,
1:         long                    row_count,
1:         int                     group_size,
1: 		boolean                 forUpdate,
1: 		FormatableBitSet                 scanColumnList,
1: 		DataValueDescriptor[]   template,
1: 		DataValueDescriptor[]   startKeyValue,
1: 		int                     startSearchOperator,
1: 		DataValueDescriptor[]   stopKeyValue,
1: 		int                     stopSearchOperator,
1:         boolean                 reopen_scan,
1:         int                     access_type,
1:         StoreCostResult         cost_result)
1: 			throws StandardException;
1: 
1:     /**
1:      * Return an "empty" row location object of the correct type.
1:      * <p>
1:      *
1: 	 * @return The empty Rowlocation.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	RowLocation newRowLocationTemplate()
1: 		throws StandardException;
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0: 
0: The StoreCostController interface provides methods that an access client
0: (most likely the system optimizer) can use to get store's estimated cost of
0: various operations on the conglomerate the StoreCostController was opened
0: for.
0: <p>
0: It is likely that the implementation of StoreCostController will open 
0: the conglomerate and will leave the conglomerate open until the
0: StoreCostController is closed.  This represents a significant amount of
0: work, so the caller if possible should attempt to open the StoreCostController
0: once per unit of work and rather than close and reopen the controller.  For
0: instance if the optimizer needs to cost 2 different scans against a single
0: conglomerate, it should use one instance of the StoreCostController.
0: <p>
0: The locking behavior of the implementation of a StoreCostController is
0: undefined, it may or may not get locks on the underlying conglomerate.  It
0: may or may not hold locks until end of transaction.  
0: An optimal implementation will not get any locks on the underlying 
0: conglomerate, thus allowing concurrent access to the table by a executing
0: query while another query is optimizing.
0: <p>
0: @see TransactionController#openStoreCost
0: @see RowCountable
0: 
0: **/
0: 
0: public interface StoreCostController extends RowCountable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0:     // The folllowing constants should only be used by StoreCostController
0:     // implementors.
0: 
0:     // The base cost to fetch a cached page, and select a single
0:     // heap row by RowLocation, fetching 0 columns.
0:     public static final double BASE_CACHED_ROW_FETCH_COST = 0.17;
0: 
0:     // The base cost to page in a page from disk to cache, and select a single
0:     // heap row by RowLocation, fetching 0 columns.
0:     public static final double BASE_UNCACHED_ROW_FETCH_COST = 1.5;
0: 
0:     // The base cost to fetch a single row as part of group fetch scan with
0:     // 16 rows per group, fetching 0 columns.
0:     public static final double BASE_GROUPSCAN_ROW_COST = 0.12;
0: 
0:     // The base cost to fetch a single row as part of a nongroup fetch scan
0:     // fetching 0 columns.
0:     public static final double BASE_NONGROUPSCAN_ROW_FETCH_COST = 0.25;
0: 
0:     // The base cost to fetch a single row as part of a nongroup fetch scan
0:     // fetching 1 columns.
0:     public static final double BASE_HASHSCAN_ROW_FETCH_COST = 0.14;
0: 
0: 
0:     // This is an estimate of the per byte cost associated with fetching the 
0:     // row from the table, it just assumes the cost scales per byte which is 
0:     // probably not true, but a good first guess.  It is meant to be added
0:     // to the above costs - for instance the cost of fetching a 100 byte 
0:     // row from a page assumed to be in the cache is:
0:     //     BASE_CACHED_ROW_FETCH_COST + (100 * BASE_ROW_PER_BYTECOST)
0:     //
0:     // The estimate for this number is the cost of retrieving all cost from
0:     // a cached 100 byte row - the cost of getting 0 colums from cached row.
0:     public static final double BASE_ROW_PER_BYTECOST = (0.56 - 0.16) / 100;
0: 
0:     /**
0:      * Indicates that access to the page necessary to fulfill the fetch
0:      * request is likely to be a page "recently" used.  See 
0:      * getFetchFromFullKeyCost() and getScanCost().
0:      **/
0:     public static final int STORECOST_CLUSTERED = 0x01;
0: 
0:     /**
0:      * Used for the scan_type parameter to the getScanCost() routine.
0:      * STORECOST_SCAN_NORMAL indicates that the scan will use the standard 
0:      * next/fetch, where each fetch can retrieve 1 or many rows (if 
0:      * fetchNextGroup() interface is used).
0:      **/
0:     public static final int STORECOST_SCAN_SET      = 0x01;
0: 
0: 
0:     /**
0:      * Used for the scan_type parameter to the getScanCost() routine.
0:      * STORECOST_SCAN_SET - The entire result set will be retrieved using the
0:      * the fetchSet() interface.
0:      **/
0:     public static final int STORECOST_SCAN_NORMAL   = 0x02;
0: 
0:     /**
0:      * Close the controller.
0:      * <p>
0:      * Close the open controller.  This method always succeeds, and never 
0:      * throws any exceptions. Callers must not use the StoreCostController 
0:      * Cost controller after closing it; they are strongly advised to clear
0:      * out the scan controller reference after closing.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     void close()
0:         throws StandardException;
0: 
0:     /**
0:      * Return the cost of calling ConglomerateController.fetch().
0:      * <p>
0:      * Return the estimated cost of calling ConglomerateController.fetch()
0:      * on the current conglomerate.  This gives the cost of finding a record
0:      * in the conglomerate given the exact RowLocation of the record in
0:      * question. 
0:      * <p>
0:      * The validColumns parameter describe what kind of row 
0:      * is being fetched, ie. it may be cheaper to fetch a partial row than a 
0:      * complete row.
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ConglomerateController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one fetch
0:      *                            is likely clustered "close" to the next 
0:      *                            fetch.  For instance if the query plan were
0:      *                            to sort the RowLocations of a heap and then
0:      *                            use those RowLocations sequentially to 
0:      *                            probe into the heap, then this flag should
0:      *                            be specified.  If this flag is not set then
0:      *                            access to the table is assumed to be
0:      *                            random - ie. the type of access one gets 
0:      *                            if you scan an index and probe each row
0:      *                            in turn into the base table is "random".
0:      *
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromRowLocationCost(
0:     FormatableBitSet     validColumns,
0:     int         access_type)
0: 		throws StandardException;
0: 
0:     /**
0:      * Return the cost of exact key lookup.
0:      * <p>
0:      * Return the estimated cost of calling ScanController.fetch()
0:      * on the current conglomerate, with start and stop positions set such
0:      * that an exact match is expected.
0:      * <p>
0:      * This call returns the cost of a fetchNext() performed on a scan which
0:      * has been positioned with a start position which specifies exact match
0:      * on all keys in the row.
0:      * <p>
0:      * Example:
0:      * <p>
0:      * In the case of a btree this call can be used to determine the cost of
0:      * doing an exact probe into btree, giving all key columns.  This cost
0:      * can be used if the client knows it will be doing an exact key probe
0:      * but does not have the key's at optimize time to use to make a call to
0:      * getScanCost()
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromFullKeyCost(
0:     FormatableBitSet     validColumns,
0:     int         access_type)
0: 		throws StandardException;
0: 
0:     /**
0:      * Calculate the cost of a scan.
0:      * <p>
0:      * Cause this object to calculate the cost of performing the described
0:      * scan.  The interface is setup such that first a call is made to
0:      * calcualteScanCost(), and then subsequent calls to accessor routines
0:      * are made to get various pieces of information about the cost of
0:      * the scan.
0:      * <p>
0:      * For the purposes of costing this routine is going to assume that 
0:      * a page will remain in cache between the time one next()/fetchNext()
0:      * call and a subsequent next()/fetchNext() call is made within a scan.
0:      * <p>
0:      * The result of costing the scan is placed in the "cost_result".  
0:      * The cost of the scan is stored by calling 
0:      * cost_result.setEstimatedCost(cost).
0:      * The estimated row count is stored by calling 
0:      * cost_result.setEstimatedRowCount(row_count).
0:      * <p>
0:      * The estimated cost of the scan assumes the caller will 
0:      * execute a fetchNext() loop for every row that qualifies between
0:      * start and stop position.  Note that this cost is different than
0:      * execution a next(),fetch() loop; or if the scan is going to be
0:      * terminated by client prior to reaching the stop condition.
0:      * <p>
0:      * The estimated number of rows returned from the scan 
0:      * assumes the caller will execute a fetchNext() loop for every 
0:      * row that qualifies between start and stop position.
0:      * <p>
0:      *
0:      *
0:      * @param scan_type       The type of scan that will be executed.  There
0:      *                        are currently 2 types:
0:      *                        STORECOST_SCAN_NORMAL - scans will be executed
0:      *                        using the standard next/fetch, where each fetch
0:      *                        can retrieve 1 or many rows (if fetchNextGroup()
0:      *                        interface is used).
0:      *
0:      *                        STORECOST_SCAN_SET - The entire result set will
0:      *                        be retrieved using the the fetchSet() interface.
0:      *
0:      * @param row_count       Estimated total row count of the table.  The 
0:      *                        current system tracks row counts in heaps better
0:      *                        than btree's (btree's have "rows" which are not
0:      *                        user rows - branch rows, control rows), so 
0:      *                        if available the client should
0:      *                        pass in the base table's row count into this
0:      *                        routine to be used as the index's row count.
0:      *                        If the caller has no idea, pass in -1.
0:      *
0:      * @param group_size      The number of rows to be returned by a single
0:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
0:      *
0: 	 * @param forUpdate       Should be true if the caller intends to update 
0:      *                        through the scan.
0:      * 
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      * 
0:      * @param template        A prototypical row which the scan may use to
0: 	 *                        maintain its position in the conglomerate.  Not 
0:      *                        all access method scan types will require this, 
0:      *                        if they don't it's ok to pass in null.
0:      *                        In order to scan a conglomerate one must 
0:      *                        allocate 2 separate "row" templates.  The "row" 
0:      *                        template passed into openScan is for the private
0:      *                        use of the scan itself, and no access to it
0:      *                        should be made by the caller while the scan is 
0:      *                        still open.  Because of this the scanner must 
0:      *                        allocate another "row" template to hold the 
0:      *                        values returned from fetch().  Note that this 
0:      *                        template must be for the full row, whether a 
0:      *                        partial row scan is being executed or not.
0:      *
0: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        startSearchOperator, defines the starting 
0:      *                        position of the scan.  If null, the starting
0:      *                        position of the scan is the first row of the 
0:      *                        conglomerate.  The startKeyValue must only
0:      *                        reference columns included in the scanColumnList.
0:      *
0: 	 * @param startSearchOperation 
0:      *                        an operator which defines how the startKeyValue
0:      *                        is to be searched for.  If startSearchOperation 
0:      *                        is ScanController.GE, the scan starts on the 
0:      *                        first row which is greater than or equal to the 
0: 	 *                        startKeyValue.  If startSearchOperation is 
0:      *                        ScanController.GT, the scan starts on the first
0:      *                        row whose key is greater than startKeyValue.  The
0:      *                        startSearchOperation parameter is ignored if the
0:      *                        startKeyValue parameter is null.
0:      *
0: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        stopSearchOperator, defines the ending position
0:      *                        of the scan.  If null, the ending position of the
0:      *                        scan is the last row of the conglomerate.  The
0:      *                        stopKeyValue must only reference columns included
0:      *                        in the scanColumnList.
0:      *
0: 	 * @param stopSearchOperation
0:      *                        an operator which defines how the stopKeyValue
0:      *                        is used to determine the scan stopping position. 
0:      *                        If stopSearchOperation is ScanController.GE, the
0:      *                        scan stops just before the first row which is
0:      *                        greater than or equal to the stopKeyValue.  If 
0:      *                        stopSearchOperation is ScanController.GT, the 
0:      *                        scan stops just before the first row whose key 
0:      *                        is greater than startKeyValue.  The
0:      *                        stopSearchOperation parameter is ignored if the
0:      *                        stopKeyValue parameter is null.
0:      *
0:      *                        
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0: 	public void getScanCost(
0:         int                     scan_type,
0:         long                    row_count,
0:         int                     group_size,
0: 		boolean                 forUpdate,
0: 		FormatableBitSet                 scanColumnList,
0: 		DataValueDescriptor[]   template,
0: 		DataValueDescriptor[]   startKeyValue,
0: 		int                     startSearchOperator,
0: 		DataValueDescriptor[]   stopKeyValue,
0: 		int                     stopSearchOperator,
0:         boolean                 reopen_scan,
0:         int                     access_type,
0:         StoreCostResult         cost_result)
0: 			throws StandardException;
0: 
0:     /**
0:      * Return an "empty" row location object of the correct type.
0:      * <p>
0:      *
0: 	 * @return The empty Rowlocation.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	RowLocation newRowLocationTemplate()
0: 		throws StandardException;
0: }
============================================================================