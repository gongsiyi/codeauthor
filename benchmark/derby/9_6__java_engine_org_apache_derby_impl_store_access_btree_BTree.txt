1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTree
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
14:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:0c91b19: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   A b-tree object corresponds to an instance of a b-tree conglomerate.  It 
1:eac0369:   contains the static information about a conglomerate which is built at 
1:eac0369:   create conglomerate time.
1:eac0369:   <p>
1:eac0369:   This generic implementation is expected to be extended by the concreate
1:eac0369:   implementations.
1:eac0369:   <P>
1:eac0369:   The fields are set when the conglomerate is created and never changed 
1:eac0369:   thereafter.  When alter table is supported then it will change under the
1:eac0369:   control of a table level lock.
1:eac0369:   <p>
1:eac0369:   They have package scope because they're read by the scans and controllers.
1:eac0369:   <p>
1:eac0369:   A table of all conglomerates in the system is maintained by the accessmanager.
1:eac0369:   A cache of conglomerates is maintained in the accessmanager, and references
1:eac0369:   to the read only objects are handed out.  A copy of the Conglomerate
1:eac0369:   object is kept in the control row of the root page, so that during logical
1:eac0369:   undo this information can be read without needing to access the possibly
1:eac0369:   corrupt table maintained by the access manager.
1:eac0369: **/
1:eac0369: 
1:eac0369: public abstract class BTree extends GenericConglomerate
2:eac0369: {
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Constants of BTree class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The page number of the root page is always at the fixed page number:
1:eac0369:      * ROOTPAGEID.  This means that given an open container, during logical
1:eac0369:      * undo one can always find the root page and look up the conglomerate
1:eac0369:      * information.
1:eac0369:      **/
1:eac0369:     public static final long ROOTPAGEID = ContainerHandle.FIRST_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 	/** 
1:eac0369:     Property name for the maximum number of rows to place in a btree page (leaf
1:eac0369:     or branch).  Equal to 'derby.access.btreeMaxRowPerPage'.  Used by tests
1:eac0369:     and debugging to exactly control split points, and to make it easier to test
1:eac0369:     tall trees without needing lots of data.
1:eac0369: 	*/
1:eac0369: 	public static final String PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER = 
1:eac0369:         (SanityManager.DEBUG ?  "derby.access.btreeMaxRowPerPage" : null);
1:eac0369: 
1:eac0369:     /* properties of a btree see create(). */
1:eac0369:     public static final String PROPERTY_ALLOWDUPLICATES = "allowDuplicates";
1:eac0369:     public static final String PROPERTY_NKEYFIELDS      = "nKeyFields";
1:eac0369:     public static final String PROPERTY_NUNIQUECOLUMNS  = "nUniqueColumns";
1:eac0369:     public static final String PROPERTY_PARENTLINKS     = "maintainParentLinks";
1:eac0369: 
1:400cc60:     // Property key to indicate if the index will allow duplicate nulls, but
1:400cc60:     // otherwise ensure unique keys. Note that this is not used in the BTree for
1:400cc60:     // deferrable constraints: in this case it handled at the language level,
1:400cc60:     // cf. IndexChanger.
1:28e234d:     public static final String PROPERTY_UNIQUE_WITH_DUPLICATE_NULLS 
1:28e234d:                                                     = "uniqueWithDuplicateNulls";
1:28e234d: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected Fields of BTree class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The id of the container in which this b-tree is stored. 
1:eac0369: 	**/
1:eac0369: 	protected ContainerKey id;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The number of key fields.
1:eac0369: 	**/
1:eac0369: 	protected int nKeyFields;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The number of uniqueness columns.  These are the columns that
1:eac0369: 	are considered for the purpose of detecting duplicate keys and rows.
1:eac0369: 	**/
1:eac0369: 	int nUniqueColumns;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Whether the index allows duplicates or not.
1:eac0369: 	**/
1:eac0369: 	boolean allowDuplicates;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Whether the parent should maintain links from child pages to their parent.
1:eac0369: 	These links are only used for consistency checking purposes.  They improve
1:eac0369: 	consistency checking at the cost of run-time efficiency.
1:eac0369: 	**/
1:eac0369: 	boolean maintainParentLinks;
1:eac0369: 
1:28e234d: 	/**
1:28e234d: 	Attribute to indicate the index allows duplicate only in
1:28e234d: 	case of keys with no part null.  This attribute has no effect if unique
1:28e234d:     is true. If unique is false and isUniqueWithDuplicateNulls is set 
1:28e234d:     to true the index will allow duplicates of any key with at least one
1:28e234d:     column null, but for non null keys will act like a unique index.
1:28e234d: 	**/
1:28e234d: 	boolean uniqueWithDuplicateNulls = false;
1:28e234d: 
1:eac0369:     /**
1:eac0369:     Maximum rows per page to place on a btree leaf or nonleaf page.  Used
1:eac0369:     by testing to finely control split points.  Only changed for debugging
1:eac0369:     purposes.
1:eac0369: 
1:eac0369:     RESOLVE (mikem) - this should not be static.  Need to design a way in
1:eac0369:     debugging mode to get btree created with a persistent "maxRowsPerPage".
1:eac0369:     This hack makes all btrees get created with the "last" maxRowsPerPage 
1:eac0369:     value set.
1:eac0369:     **/
1:eac0369:     static int maxRowsPerPage = Integer.MAX_VALUE;
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Format id of the conglomerate.
1:eac0369: 	**/
1:eac0369: 	protected int conglom_format_id;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     The array of format id's, one for each column in the template.
1:eac0369:     **/
1:b61f876:     protected int[]    format_ids;
1:b61f876: 
1:eac0369: 
1:eac0369: 	//columns sorting order information
1:eac0369: 	// true - Ascending Order ; false -Descending Order
1:eac0369: 	protected boolean[]	ascDescInfo;
1:eac0369: 
1:b61f876:     /**
1:b61f876:     The array of collation id's for each column in the template.
1:b61f876:     **/
1:b61f876:     protected int[]   collation_ids;
1:9a3cbed:     /**
1:9a3cbed:      * Tells if there is at least one column in the conglomerate whose collation
1:9a3cbed:      * isn't StringDataValue.COLLATION_TYPE_UCS_BASIC.
1:9a3cbed:      */
1:9a3cbed:     protected boolean hasCollatedTypes;
1:b61f876: 
1:b61f876: 
1:eac0369: 	/*
1:eac0369: 	** Private Methods of BTree.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Public Methods of BTree.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Abstract Protected locking methods of BTree:
1:eac0369:      *     getBtreeLockingPolicy
1:eac0369:      *     lockScan
1:eac0369:      *     unlockScan
1:eac0369:      *     lockPreviousRow
1:eac0369:      *     lockRowOnPage
1:eac0369:      *     lockRow
1:eac0369:      *     lockTable
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a new btree locking policy from scratch.
2:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     abstract protected BTreeLockingPolicy getBtreeLockingPolicy(
1:eac0369:     Transaction             rawtran,
1:eac0369:     int                     lock_level,
1:eac0369:     int                     mode,
1:eac0369:     int                     isolation_level,
1:eac0369:     ConglomerateController  base_cc,
1:eac0369:     OpenBTree               open_btree)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the base table.
1:eac0369:      * <p>
1:eac0369:      * Assumes that segment of the base container is the same as the segment
1:eac0369:      * of the btree segment.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - we really want to get the lock without opening the container.
1:eac0369:      * raw store will be providing this.
1:eac0369:      *
1:eac0369:      * @param xact_manager Transaction to associate the lock with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     abstract public ConglomerateController lockTable(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     int                 open_mode,
1:eac0369:     int                 lock_level,
1:eac0369:     int                 isolation_level)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of BTree:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a branch row template for this conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Reads the format id's of each of the columns and manufactures object of
1:eac0369:      * the given type for each.  It then uses these "empty" objects to create
1:eac0369:      * a template row.  The object passed in is then added to the last column
1:eac0369:      * of the row.
1:eac0369:      *
1:eac0369: 	 * @return The new template.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     final DataValueDescriptor[] createBranchTemplate(
1:722a889:     Transaction         rawtran,
1:eac0369:     DataValueDescriptor page_ptr)
1:eac0369:         throws StandardException
1:eac0369:     {
1:722a889:         return(
1:722a889:             TemplateRow.newBranchRow(
1:722a889:                 rawtran, format_ids, collation_ids, page_ptr));
2:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public methods of BTree:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a template for this conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Reads the format id's of each of the columns and manufactures object of
1:eac0369:      * the given type for each.  It then uses these "empty" objects to create
1:eac0369:      * a template row.
1:eac0369:      * <p>
1:eac0369:      * This method is public so that B2IUndo() can call it.
1:eac0369:      *
1:eac0369: 	 * @return The new template.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:722a889:     final public DataValueDescriptor[] createTemplate(
1:722a889:     Transaction rawtran)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(format_ids != null);
1:eac0369: 
1:722a889:         return(TemplateRow.newRow(
1:722a889:                     rawtran, 
1:722a889:                     (FormatableBitSet) null, format_ids, collation_ids));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is this a "unique" index?
1:eac0369:      **/
1:eac0369:     final public boolean isUnique()
1:eac0369:     {
1:eac0369:         return(nKeyFields != nUniqueColumns);
1:eac0369:     }
1:28e234d:     
1:28e234d: 
1:28e234d:     /**
1:28e234d:      * Set if the index is unique only for non null keys
1:28e234d:      * 
1:28e234d:      * @param uniqueWithDuplicateNulls true if the index will be unique only for
1:28e234d:      *                                 non null keys
1:28e234d:      */
1:28e234d:     public void setUniqueWithDuplicateNulls (boolean uniqueWithDuplicateNulls) 
1:28e234d:     {
1:28e234d:         this.uniqueWithDuplicateNulls = uniqueWithDuplicateNulls;
1:28e234d:     }
1:28e234d: 
1:28e234d:     /**
1:28e234d:      * Returns if the index type is uniqueWithDuplicateNulls.
1:28e234d:      * @return is index type is uniqueWithDuplicateNulls
1:28e234d:      */
1:28e234d:     public boolean isUniqueWithDuplicateNulls()
1:28e234d:     {
1:28e234d:         return uniqueWithDuplicateNulls;
1:28e234d:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of Conglomerate Interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Add a column to the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Currently B2I does not support this operation.
1:eac0369:      * input template column.  
1:eac0369:      * 
1:eac0369:      * @param xact_manager      Transaction to associate the lock with.
1:eac0369:      * @param column_id        The column number to add this column at.
1:eac0369:      * @param template_column  An instance of the column to be added to table.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void addColumn(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     int                 column_id,
1:b61f876:     Storable            template_column,
1:b61f876:     int                 collation_id)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the id of the container of the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Will have to change when a conglomerate could have more than one 
1:eac0369:      * container.  The ContainerKey is a combination of the container id
1:eac0369:      * and segment id.
1:eac0369:      *
1:eac0369: 	 * @return The ContainerKey.
1:eac0369:      **/
1:eac0369:     public final ContainerKey getId()
1:eac0369:     {
1:eac0369:         return(id);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Do the generic part of creating a b-tree conglomerate.  This method 
1:eac0369:     is called from the concrete subclass (which may also read some properties).
1:eac0369:     <p>
1:eac0369:     This method processes all properties which are generic to all BTree's.  It
1:eac0369:     creates the container for the btree.
1:eac0369:     <p>
1:eac0369: 
1:eac0369:     The following properties are generic to a b-tree conglomerate.  :
1:eac0369: 
1:eac0369:     <UL>
1:eac0369:     <LI>"allowDuplicates" (boolean).  If set to true the table will allow 
1:eac0369:     rows which are duplicate in key column's 0 through (nUniqueColumns - 1).
1:eac0369:     Currently only supports "false".
1:eac0369:     This property is optional, defaults to false.
1:eac0369:     <LI>"nKeyFields"  (integer) Columns 0 through (nKeyFields - 1) will be 
1:eac0369:     included in key of the conglomerate.
1:eac0369:     This implementation requires that "nKeyFields" must be the same as the
1:eac0369:     number of fields in the conglomerate, including the rowLocationColumn.
1:eac0369:     Other implementations may relax this restriction to allow non-key fields
1:eac0369:     in the index.
1:eac0369:     This property is required.
1:eac0369:     <LI>"nUniqueColumns" (integer) Columns 0 through "nUniqueColumns" will be 
1:eac0369:     used to check for uniqueness.  So for a standard SQL non-unique index 
1:eac0369:     implementation set "nUniqueColumns" to the same value as "nKeyFields"; and
1:eac0369:     for a unique index set "nUniqueColumns" to "nKeyFields" - 1 (ie. don't 
1:eac0369:     include the rowLocationColumn in the uniqueness check).
1:eac0369:     This property is required.
1:eac0369:     <LI>"maintainParentLinks" (boolean)
1:eac0369:     Whether the b-tree pages maintain the page number of their parent.  Only
1:eac0369:     used for consistency checking.  It takes a certain amount more effort to
1:eac0369:     maintain these links, but they're really handy for ensuring that the index
1:eac0369:     is consistent.
1:eac0369:     This property is optional, defaults to true.
1:eac0369:     </UL>
1:eac0369: 
1:eac0369:     @exception StandardException Thrown by underlying raw store, or thrown by
1:eac0369:     this routine on an invalid containerid.
1:eac0369:     
1:eac0369: 	**/
1:eac0369: 
1:eac0369: 	public void create(
1:eac0369:     Transaction             rawtran,
1:eac0369:     int                     segmentId,
1:eac0369:     long                    input_containerid,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     Properties              properties,
1:eac0369:     int                     conglom_format_id,
1:eac0369: 	int                     tmpFlag
1:eac0369:     )
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         String result_string;
1:eac0369: 
1:eac0369:         if (properties == null)
1:eac0369:         {
1:eac0369:             throw(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Check input arguments
1:28e234d:         allowDuplicates = 
1:28e234d:             (Boolean.valueOf(properties.getProperty(
1:28e234d:                 PROPERTY_ALLOWDUPLICATES, "false"))).booleanValue();
1:eac0369: 
1:eac0369:         result_string = properties.getProperty(PROPERTY_NKEYFIELDS);
1:eac0369:         if (result_string == null)
1:eac0369:         {
1:eac0369:             throw(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             nKeyFields = Integer.parseInt(result_string);
1:eac0369:         }
1:eac0369: 
1:eac0369:         result_string = properties.getProperty(PROPERTY_NUNIQUECOLUMNS);
1:eac0369:         if (result_string == null)
1:eac0369:         {
1:eac0369:             throw(StandardException.newException(
1:eac0369:                 SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NUNIQUECOLUMNS));
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             nUniqueColumns = Integer.parseInt(result_string);
1:eac0369:         }
1:28e234d:         
1:28e234d:         result_string = 
1:28e234d:             properties.getProperty(
1:28e234d:                 PROPERTY_UNIQUE_WITH_DUPLICATE_NULLS, "false");
1:ce40a31:         uniqueWithDuplicateNulls = Boolean.parseBoolean(result_string);
1:eac0369: 
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             result_string = 
1:eac0369:                 properties.getProperty(PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER);
1:eac0369: 
1:eac0369:             if (result_string != null)
1:eac0369:             {
1:eac0369:                 maxRowsPerPage = Integer.parseInt(result_string);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         maintainParentLinks = (Boolean.valueOf(
1:eac0369:             properties.getProperty(PROPERTY_PARENTLINKS, "true"))).booleanValue();
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - true for now, if we want to support non-key 
1:eac0369:         // fields eventually this assert may be wrong.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			if (template.length != nKeyFields)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"template.length (" + template.length +
1:eac0369: 					") expected to equal nKeyFields (" + 
1:eac0369: 					nKeyFields + ")");
1:eac0369: 			}
1:eac0369:             SanityManager.ASSERT((nUniqueColumns == nKeyFields) || 
1:eac0369:                                  (nUniqueColumns == (nKeyFields - 1)));
1:eac0369:         }
1:eac0369: 
1:eac0369:         // get format id's from each column in template and store it in the
1:eac0369:         // conglomerate state.
1:eac0369:         format_ids = ConglomerateUtil.createFormatIds(template);
1:eac0369: 
1:eac0369:         // copy the format id of the conglomerate.
1:eac0369:         this.conglom_format_id = conglom_format_id;
1:eac0369: 
1:eac0369: 		// Create a container for the b-tree with default page size and 
1:eac0369:         // fill up pages.
1:eac0369: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, "0");
1:eac0369: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, "1");
1:eac0369: 		properties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, "true");
1:eac0369: 
1:eac0369: 		long containerid = 
1:eac0369:             rawtran.addContainer(
1:eac0369:                 segmentId, input_containerid, 
1:eac0369:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
1:eac0369: 
1:eac0369: 		// Make sure the container was actually created.
1:eac0369: 		// Open segment will get cleaned up when transaction is.
1:eac0369: 		if (containerid <= 0)
1:eac0369:         {
1:eac0369:             throw(StandardException.newException(
1:eac0369:                     SQLState.BTREE_CANT_CREATE_CONTAINER)); 
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (input_containerid != ContainerHandle.DEFAULT_ASSIGN_ID)
1:eac0369:                 SanityManager.ASSERT(containerid == input_containerid);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		id = new ContainerKey(segmentId, containerid);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Drop this btree.
1:eac0369: 	This must be done by a concrete implementation.
1:fa09146: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#drop
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public abstract void drop(TransactionManager xact_manager)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Load a b-tree.  This must be done by a concrete implementation.
1:fa09146: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#load
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public abstract long load(
1:eac0369: 	TransactionManager      xact_manager,
1:eac0369: 	boolean                 createConglom,
1:eac0369: 	RowLocationRetRowSource rowSource)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     public long getContainerid()
1:eac0369:     {
1:eac0369:         return(this.id.getContainerId());
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return dynamic information about the conglomerate to be dynamically 
1:eac0369:      * reused in repeated execution of a statement.
1:eac0369:      * <p>
1:eac0369:      * The dynamic info is a set of variables to be used in a given 
1:eac0369:      * ScanController or ConglomerateController.  It can only be used in one 
1:eac0369:      * controller at a time.  It is up to the caller to insure the correct 
1:eac0369:      * thread access to this info.  The type of info in this is a scratch 
1:eac0369:      * template for btree traversal, other scratch variables for qualifier 
1:eac0369:      * evaluation, ...
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The dynamic information.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:57a0040:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:9a3cbed:         return(new OpenConglomerateScratchSpace(
1:9a3cbed:                 format_ids, collation_ids, hasCollatedTypes));
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is this conglomerate temporary?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return whether conglomerate is temporary or not.
1:eac0369:      **/
1:eac0369:     public boolean isTemporary()
1:eac0369:     {
1:eac0369:         return (id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a b-tree controller.
1:eac0369: 	This must be done by a concrete implementation.
1:fa09146: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#open
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public abstract ConglomerateController open(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of Storable Interface (via Conglomerate):
1:eac0369:      *     This class is responsible for re/storing its own state.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return whether the value is null or not.
1:eac0369: 	The containerid being zero is what determines nullness;  subclasses
1:eac0369: 	are not expected to override this method.
1:eac0369: 	@see org.apache.derby.iapi.services.io.Storable#isNull
1:eac0369: 	**/
1:eac0369: 	public boolean isNull()
1:eac0369: 	{
1:eac0369: 		return id == null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Restore the in-memory representation to the null value.
1:eac0369: 	The containerid being zero is what determines nullness;  subclasses
1:eac0369: 	are not expected to override this method.
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	**/
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		id = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Restore the in-memory representation from the stream.
1:eac0369: 
1:eac0369: 	@exception ClassNotFoundException Thrown if the stored representation is
1:eac0369: 	serialized and a class named in the stream could not be found.
1:eac0369: 
1:eac0369:     @exception IOException thrown by readObject()
1:eac0369: 
1:eac0369: 	
1:eac0369: 	@see java.io.Externalizable#readExternal
1:eac0369: 	*/
1:eac0369: 	public void readExternal(ObjectInput in) 
2:eac0369:         throws IOException, ClassNotFoundException
1:eac0369: 	{
2:eac0369:         // read in the conglomerate format id.
2:eac0369:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
1:eac0369: 
2:eac0369: 		// XXX (nat) need to improve error handling
2:eac0369: 		long containerid         = in.readLong();
2:eac0369: 		int segmentid			= in.readInt();
2:eac0369: 		nKeyFields          = in.readInt();
2:eac0369: 		nUniqueColumns      = in.readInt();
2:eac0369: 		allowDuplicates     = in.readBoolean();
2:eac0369: 		maintainParentLinks = in.readBoolean();
1:eac0369: 
2:eac0369:         // read in the array of format id's
2:eac0369:         format_ids = ConglomerateUtil.readFormatIdArray(this.nKeyFields, in);
1:eac0369: 
2:eac0369: 		id = new ContainerKey(segmentid, containerid);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	Store the stored representation of the column value in the stream.
1:eac0369: 	It might be easier to simply store the properties - which would certainly
1:eac0369: 	make upgrading easier.
1:eac0369: 
1:eac0369:     @exception IOException thrown by writeObject()
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) 
1:eac0369:         throws IOException
1:eac0369:     {
1:eac0369:         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);
1:eac0369: 
1:eac0369: 		out.writeLong(id.getContainerId());
1:eac0369: 		out.writeInt((int) id.getSegmentId());
1:eac0369: 		out.writeInt((nKeyFields));
1:eac0369: 		out.writeInt((nUniqueColumns));
1:eac0369: 		out.writeBoolean((allowDuplicates));
1:eac0369: 		out.writeBoolean((maintainParentLinks));
1:eac0369: 
1:eac0369:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public toString() Method:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     public String toString()
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             return  ("BTREE: containerid = " + 
1:eac0369:                      (this.id == null ? "null" : this.id.toString()) +
1:eac0369:                      ";nKeyFields = " + nKeyFields +
1:eac0369:                      ";nUniqueColumns = " + nUniqueColumns +
1:eac0369:                      ";allowDuplicates = " + allowDuplicates);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(super.toString());
1:eac0369:         }
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:         uniqueWithDuplicateNulls = Boolean.parseBoolean(result_string);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:400cc60
/////////////////////////////////////////////////////////////////////////
1:     // Property key to indicate if the index will allow duplicate nulls, but
1:     // otherwise ensure unique keys. Note that this is not used in the BTree for
1:     // deferrable constraints: in this case it handled at the language level,
1:     // cf. IndexChanger.
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells if there is at least one column in the conglomerate whose collation
1:      * isn't StringDataValue.COLLATION_TYPE_UCS_BASIC.
1:      */
1:     protected boolean hasCollatedTypes;
/////////////////////////////////////////////////////////////////////////
1:         return(new OpenConglomerateScratchSpace(
1:                 format_ids, collation_ids, hasCollatedTypes));
commit:57a0040
/////////////////////////////////////////////////////////////////////////
1:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#drop
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#load
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derby.iapi.store.access.conglomerate.Conglomerate#open
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
0:     //property key to indicate if the index will allow duplicate nulls, but
0:     //otherwise insure unique keys
1:     public static final String PROPERTY_UNIQUE_WITH_DUPLICATE_NULLS 
1:                                                     = "uniqueWithDuplicateNulls";
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	Attribute to indicate the index allows duplicate only in
1: 	case of keys with no part null.  This attribute has no effect if unique
1:     is true. If unique is false and isUniqueWithDuplicateNulls is set 
1:     to true the index will allow duplicates of any key with at least one
1:     column null, but for non null keys will act like a unique index.
1: 	**/
1: 	boolean uniqueWithDuplicateNulls = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:     /**
1:      * Set if the index is unique only for non null keys
1:      * 
1:      * @param uniqueWithDuplicateNulls true if the index will be unique only for
1:      *                                 non null keys
1:      */
1:     public void setUniqueWithDuplicateNulls (boolean uniqueWithDuplicateNulls) 
1:     {
1:         this.uniqueWithDuplicateNulls = uniqueWithDuplicateNulls;
1:     }
1: 
1:     /**
1:      * Returns if the index type is uniqueWithDuplicateNulls.
1:      * @return is index type is uniqueWithDuplicateNulls
1:      */
1:     public boolean isUniqueWithDuplicateNulls()
1:     {
1:         return uniqueWithDuplicateNulls;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         allowDuplicates = 
1:             (Boolean.valueOf(properties.getProperty(
1:                 PROPERTY_ALLOWDUPLICATES, "false"))).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:         
1:         result_string = 
1:             properties.getProperty(
1:                 PROPERTY_UNIQUE_WITH_DUPLICATE_NULLS, "false");
0:         uniqueWithDuplicateNulls = new Boolean (result_string).booleanValue();
commit:a4cfe45
/////////////////////////////////////////////////////////////////////////
commit:0c91b19
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.ArrayUtil;
1: 
/////////////////////////////////////////////////////////////////////////
0:         SanityManager.DEBUG_PRINT("BTree.getDynamicCompiledConglomInfo", "collation_ids = " + ArrayUtil.toString(collation_ids));
0:         SanityManager.showTrace(new Throwable());
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:     Transaction         rawtran,
1:         return(
1:             TemplateRow.newBranchRow(
1:                 rawtran, format_ids, collation_ids, page_ptr));
/////////////////////////////////////////////////////////////////////////
1:     final public DataValueDescriptor[] createTemplate(
1:     Transaction rawtran)
1:         return(TemplateRow.newRow(
1:                     rawtran, 
1:                     (FormatableBitSet) null, format_ids, collation_ids));
/////////////////////////////////////////////////////////////////////////
0:         return(new OpenConglomerateScratchSpace(format_ids, collation_ids));
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:     protected int[]    format_ids;
1: 
1:     /**
1:     The array of collation id's for each column in the template.
1:     **/
1:     protected int[]   collation_ids;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     Storable            template_column,
1:     int                 collation_id)
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTree
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.Storable;
1: 
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
1: 
1: 
1: import java.io.IOException;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: 
1: import java.util.Properties;
1: 
1: 
1: /**
1: 
1:   A b-tree object corresponds to an instance of a b-tree conglomerate.  It 
1:   contains the static information about a conglomerate which is built at 
1:   create conglomerate time.
1:   <p>
1:   This generic implementation is expected to be extended by the concreate
1:   implementations.
1:   <P>
1:   The fields are set when the conglomerate is created and never changed 
1:   thereafter.  When alter table is supported then it will change under the
1:   control of a table level lock.
1:   <p>
1:   They have package scope because they're read by the scans and controllers.
1:   <p>
1:   A table of all conglomerates in the system is maintained by the accessmanager.
1:   A cache of conglomerates is maintained in the accessmanager, and references
1:   to the read only objects are handed out.  A copy of the Conglomerate
1:   object is kept in the control row of the root page, so that during logical
1:   undo this information can be read without needing to access the possibly
1:   corrupt table maintained by the access manager.
1: **/
1: 
1: public abstract class BTree extends GenericConglomerate
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     /**************************************************************************
1:      * Public Constants of BTree class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * The page number of the root page is always at the fixed page number:
1:      * ROOTPAGEID.  This means that given an open container, during logical
1:      * undo one can always find the root page and look up the conglomerate
1:      * information.
1:      **/
1:     public static final long ROOTPAGEID = ContainerHandle.FIRST_PAGE_NUMBER;
1: 
1: 	/** 
1:     Property name for the maximum number of rows to place in a btree page (leaf
1:     or branch).  Equal to 'derby.access.btreeMaxRowPerPage'.  Used by tests
1:     and debugging to exactly control split points, and to make it easier to test
1:     tall trees without needing lots of data.
1: 	*/
1: 	public static final String PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER = 
1:         (SanityManager.DEBUG ?  "derby.access.btreeMaxRowPerPage" : null);
1: 
1:     /* properties of a btree see create(). */
1:     public static final String PROPERTY_ALLOWDUPLICATES = "allowDuplicates";
1:     public static final String PROPERTY_NKEYFIELDS      = "nKeyFields";
1:     public static final String PROPERTY_NUNIQUECOLUMNS  = "nUniqueColumns";
1:     public static final String PROPERTY_PARENTLINKS     = "maintainParentLinks";
1: 
1: 
1: 
1:     /**************************************************************************
1:      * Protected Fields of BTree class:
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	The id of the container in which this b-tree is stored. 
1: 	**/
1: 	protected ContainerKey id;
1: 
1: 	/**
1: 	The number of key fields.
1: 	**/
1: 	protected int nKeyFields;
1: 
1: 	/**
1: 	The number of uniqueness columns.  These are the columns that
1: 	are considered for the purpose of detecting duplicate keys and rows.
1: 	**/
1: 	int nUniqueColumns;
1: 
1: 	/**
1: 	Whether the index allows duplicates or not.
1: 	**/
1: 	boolean allowDuplicates;
1: 
1: 	/**
1: 	Whether the parent should maintain links from child pages to their parent.
1: 	These links are only used for consistency checking purposes.  They improve
1: 	consistency checking at the cost of run-time efficiency.
1: 	**/
1: 	boolean maintainParentLinks;
1: 
1:     /**
1:     Maximum rows per page to place on a btree leaf or nonleaf page.  Used
1:     by testing to finely control split points.  Only changed for debugging
1:     purposes.
1: 
1:     RESOLVE (mikem) - this should not be static.  Need to design a way in
1:     debugging mode to get btree created with a persistent "maxRowsPerPage".
1:     This hack makes all btrees get created with the "last" maxRowsPerPage 
1:     value set.
1:     **/
1:     static int maxRowsPerPage = Integer.MAX_VALUE;
1: 
1: 	/**
1:     Format id of the conglomerate.
1: 	**/
1: 	protected int conglom_format_id;
1: 
1:     /**
1:     The array of format id's, one for each column in the template.
1:     **/
0:     int[]    format_ids;
1: 
1: 	//columns sorting order information
1: 	// true - Ascending Order ; false -Descending Order
1: 	protected boolean[]	ascDescInfo;
1: 
1: 	/*
1: 	** Private Methods of BTree.
1: 	*/
1: 
1: 	/*
1: 	** Public Methods of BTree.
1: 	*/
1: 
1: 
1:     /**************************************************************************
1:      * Abstract Protected locking methods of BTree:
1:      *     getBtreeLockingPolicy
1:      *     lockScan
1:      *     unlockScan
1:      *     lockPreviousRow
1:      *     lockRowOnPage
1:      *     lockRow
1:      *     lockTable
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Create a new btree locking policy from scratch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     abstract protected BTreeLockingPolicy getBtreeLockingPolicy(
1:     Transaction             rawtran,
1:     int                     lock_level,
1:     int                     mode,
1:     int                     isolation_level,
1:     ConglomerateController  base_cc,
1:     OpenBTree               open_btree)
1: 		throws StandardException;
1: 
1:     /**
1:      * Lock the base table.
1:      * <p>
1:      * Assumes that segment of the base container is the same as the segment
1:      * of the btree segment.
1:      * <p>
1:      * RESOLVE - we really want to get the lock without opening the container.
1:      * raw store will be providing this.
1:      *
1:      * @param xact_manager Transaction to associate the lock with.
0:      * @param forUpdate    Whether to lock exclusive or share.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     abstract public ConglomerateController lockTable(
1:     TransactionManager  xact_manager,
1:     int                 open_mode,
1:     int                 lock_level,
1:     int                 isolation_level)
1: 		throws StandardException;
1: 
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of BTree:
1:      **************************************************************************
1:      */
1: 
1: 
1:     /**
1:      * Create a branch row template for this conglomerate.
1:      * <p>
1:      * Reads the format id's of each of the columns and manufactures object of
1:      * the given type for each.  It then uses these "empty" objects to create
1:      * a template row.  The object passed in is then added to the last column
1:      * of the row.
1:      *
1: 	 * @return The new template.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     final DataValueDescriptor[] createBranchTemplate(
1:     DataValueDescriptor page_ptr)
1:         throws StandardException
1:     {
0:         return(TemplateRow.newBranchRow(format_ids, page_ptr));
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Public methods of BTree:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Create a template for this conglomerate.
1:      * <p>
1:      * Reads the format id's of each of the columns and manufactures object of
1:      * the given type for each.  It then uses these "empty" objects to create
1:      * a template row.
1:      * <p>
1:      * This method is public so that B2IUndo() can call it.
1:      *
1: 	 * @return The new template.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     final public DataValueDescriptor[] createTemplate()
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(format_ids != null);
1: 
0:         return(TemplateRow.newRow((FormatableBitSet) null, format_ids));
1:     }
1: 
1:     /**
1:      * Is this a "unique" index?
1:      **/
1:     final public boolean isUnique()
1:     {
1:         return(nKeyFields != nUniqueColumns);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of Conglomerate Interface:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Add a column to the conglomerate.
1:      * <p>
1:      * Currently B2I does not support this operation.
1:      * input template column.  
1:      * 
1:      * @param xact_manager      Transaction to associate the lock with.
1:      * @param column_id        The column number to add this column at.
1:      * @param template_column  An instance of the column to be added to table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void addColumn(
1:     TransactionManager  xact_manager,
1:     int                 column_id,
0:     Storable            template_column)
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     /**
1:      * Get the id of the container of the conglomerate.
1:      * <p>
1:      * Will have to change when a conglomerate could have more than one 
1:      * container.  The ContainerKey is a combination of the container id
1:      * and segment id.
1:      *
1: 	 * @return The ContainerKey.
1:      **/
1:     public final ContainerKey getId()
1:     {
1:         return(id);
1:     }
1: 
1: 
1: 	/**
1: 	Do the generic part of creating a b-tree conglomerate.  This method 
1:     is called from the concrete subclass (which may also read some properties).
1:     <p>
1:     This method processes all properties which are generic to all BTree's.  It
1:     creates the container for the btree.
1:     <p>
1: 
1:     The following properties are generic to a b-tree conglomerate.  :
1: 
1:     <UL>
1:     <LI>"allowDuplicates" (boolean).  If set to true the table will allow 
1:     rows which are duplicate in key column's 0 through (nUniqueColumns - 1).
1:     Currently only supports "false".
1:     This property is optional, defaults to false.
1:     <LI>"nKeyFields"  (integer) Columns 0 through (nKeyFields - 1) will be 
1:     included in key of the conglomerate.
1:     This implementation requires that "nKeyFields" must be the same as the
1:     number of fields in the conglomerate, including the rowLocationColumn.
1:     Other implementations may relax this restriction to allow non-key fields
1:     in the index.
1:     This property is required.
1:     <LI>"nUniqueColumns" (integer) Columns 0 through "nUniqueColumns" will be 
1:     used to check for uniqueness.  So for a standard SQL non-unique index 
1:     implementation set "nUniqueColumns" to the same value as "nKeyFields"; and
1:     for a unique index set "nUniqueColumns" to "nKeyFields" - 1 (ie. don't 
1:     include the rowLocationColumn in the uniqueness check).
1:     This property is required.
1:     <LI>"maintainParentLinks" (boolean)
1:     Whether the b-tree pages maintain the page number of their parent.  Only
1:     used for consistency checking.  It takes a certain amount more effort to
1:     maintain these links, but they're really handy for ensuring that the index
1:     is consistent.
1:     This property is optional, defaults to true.
1:     </UL>
1: 
1:     @exception StandardException Thrown by underlying raw store, or thrown by
1:     this routine on an invalid containerid.
1:     
1: 	**/
1: 
1: 	public void create(
1:     Transaction             rawtran,
1:     int                     segmentId,
1:     long                    input_containerid,
1:     DataValueDescriptor[]   template,
1:     Properties              properties,
1:     int                     conglom_format_id,
1: 	int                     tmpFlag
1:     )
1:         throws StandardException
1: 	{
1:         String result_string;
1: 
1:         if (properties == null)
1:         {
1:             throw(
1:                 StandardException.newException(
1:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
1:         }
1: 
1:         // Check input arguments
0:         allowDuplicates = (Boolean.valueOf(
0:             properties.getProperty(PROPERTY_ALLOWDUPLICATES, "false"))).booleanValue();
1: 
1:         result_string = properties.getProperty(PROPERTY_NKEYFIELDS);
1:         if (result_string == null)
1:         {
1:             throw(
1:                 StandardException.newException(
1:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
1:         }
1:         else
1:         {
1:             nKeyFields = Integer.parseInt(result_string);
1:         }
1: 
1:         result_string = properties.getProperty(PROPERTY_NUNIQUECOLUMNS);
1:         if (result_string == null)
1:         {
1:             throw(StandardException.newException(
1:                 SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NUNIQUECOLUMNS));
1:         }
1:         else
1:         {
1:             nUniqueColumns = Integer.parseInt(result_string);
1:         }
1: 
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             result_string = 
1:                 properties.getProperty(PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER);
1: 
1:             if (result_string != null)
1:             {
1:                 maxRowsPerPage = Integer.parseInt(result_string);
1:             }
1:         }
1: 
1:         maintainParentLinks = (Boolean.valueOf(
1:             properties.getProperty(PROPERTY_PARENTLINKS, "true"))).booleanValue();
1: 
1:         // RESOLVE (mikem) - true for now, if we want to support non-key 
1:         // fields eventually this assert may be wrong.
1:         if (SanityManager.DEBUG)
1:         {
1: 			if (template.length != nKeyFields)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"template.length (" + template.length +
1: 					") expected to equal nKeyFields (" + 
1: 					nKeyFields + ")");
1: 			}
1:             SanityManager.ASSERT((nUniqueColumns == nKeyFields) || 
1:                                  (nUniqueColumns == (nKeyFields - 1)));
1:         }
1: 
1:         // get format id's from each column in template and store it in the
1:         // conglomerate state.
1:         format_ids = ConglomerateUtil.createFormatIds(template);
1: 
1:         // copy the format id of the conglomerate.
1:         this.conglom_format_id = conglom_format_id;
1: 
1: 		// Create a container for the b-tree with default page size and 
1:         // fill up pages.
1: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, "0");
1: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, "1");
1: 		properties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, "true");
1: 
1: 		long containerid = 
1:             rawtran.addContainer(
1:                 segmentId, input_containerid, 
1:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
1: 
1: 		// Make sure the container was actually created.
1: 		// Open segment will get cleaned up when transaction is.
1: 		if (containerid <= 0)
1:         {
1:             throw(StandardException.newException(
1:                     SQLState.BTREE_CANT_CREATE_CONTAINER)); 
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (input_containerid != ContainerHandle.DEFAULT_ASSIGN_ID)
1:                 SanityManager.ASSERT(containerid == input_containerid);
1:         }
1: 
1: 		id = new ContainerKey(segmentId, containerid);
1: 	}
1: 
1: 	/**
1: 	Drop this btree.
1: 	This must be done by a concrete implementation.
0: 	@see Conglomerate#drop
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public abstract void drop(TransactionManager xact_manager)
1: 		throws StandardException;
1: 
1: 	/**
1: 	Load a b-tree.  This must be done by a concrete implementation.
0: 	@see Conglomerate#load
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public abstract long load(
1: 	TransactionManager      xact_manager,
1: 	boolean                 createConglom,
1: 	RowLocationRetRowSource rowSource)
1: 		throws StandardException;
1: 
1:     public long getContainerid()
1:     {
1:         return(this.id.getContainerId());
1:     }
1: 
1:     /**
1:      * Return dynamic information about the conglomerate to be dynamically 
1:      * reused in repeated execution of a statement.
1:      * <p>
1:      * The dynamic info is a set of variables to be used in a given 
1:      * ScanController or ConglomerateController.  It can only be used in one 
1:      * controller at a time.  It is up to the caller to insure the correct 
1:      * thread access to this info.  The type of info in this is a scratch 
1:      * template for btree traversal, other scratch variables for qualifier 
1:      * evaluation, ...
1:      * <p>
1:      *
1: 	 * @return The dynamic information.
1:      *
0:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
1: 		throws StandardException
1:     {
0:         return(new OpenConglomerateScratchSpace(format_ids));
1:     }
1: 
1: 
1:     /**
1:      * Is this conglomerate temporary?
1:      * <p>
1:      *
1: 	 * @return whether conglomerate is temporary or not.
1:      **/
1:     public boolean isTemporary()
1:     {
1:         return (id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1:     }
1: 
1: 	/**
1: 	Open a b-tree controller.
1: 	This must be done by a concrete implementation.
0: 	@see Conglomerate#open
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public abstract ConglomerateController open(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException;
1: 
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods of Storable Interface (via Conglomerate):
1:      *     This class is responsible for re/storing its own state.
1:      **************************************************************************
1:      */
1: 
1: 
1: 	/**
1: 	Return whether the value is null or not.
1: 	The containerid being zero is what determines nullness;  subclasses
1: 	are not expected to override this method.
1: 	@see org.apache.derby.iapi.services.io.Storable#isNull
1: 	**/
1: 	public boolean isNull()
1: 	{
1: 		return id == null;
1: 	}
1: 
1: 	/**
1: 	Restore the in-memory representation to the null value.
1: 	The containerid being zero is what determines nullness;  subclasses
1: 	are not expected to override this method.
1: 
1: 	@see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	**/
1: 	public void restoreToNull()
1: 	{
1: 		id = null;
1: 	}
1: 
1: 	/**
1: 	Restore the in-memory representation from the stream.
1: 
1: 	@exception ClassNotFoundException Thrown if the stored representation is
1: 	serialized and a class named in the stream could not be found.
1: 
1:     @exception IOException thrown by readObject()
1: 
1: 	
1: 	@see java.io.Externalizable#readExternal
1: 	*/
1: 	public void readExternal(ObjectInput in) 
1:         throws IOException, ClassNotFoundException
1: 	{
1:         // read in the conglomerate format id.
1:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
1: 
1: 		// XXX (nat) need to improve error handling
1: 		long containerid         = in.readLong();
1: 		int segmentid			= in.readInt();
1: 		nKeyFields          = in.readInt();
1: 		nUniqueColumns      = in.readInt();
1: 		allowDuplicates     = in.readBoolean();
1: 		maintainParentLinks = in.readBoolean();
1: 
1:         // read in the array of format id's
1:         format_ids = ConglomerateUtil.readFormatIdArray(this.nKeyFields, in);
1: 
1: 		id = new ContainerKey(segmentid, containerid);
1: 	}
1: 
0: 	public void readExternalFromArray(ArrayInputStream in) 
1:         throws IOException, ClassNotFoundException
1: 	{
1:         // read in the conglomerate format id.
1:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
1: 
1: 		// XXX (nat) need to improve error handling
1: 		long containerid         = in.readLong();
1: 		int segmentid			= in.readInt();
1: 		nKeyFields          = in.readInt();
1: 		nUniqueColumns      = in.readInt();
1: 		allowDuplicates     = in.readBoolean();
1: 		maintainParentLinks = in.readBoolean();
1: 
1:         // read in the array of format id's
1:         format_ids = ConglomerateUtil.readFormatIdArray(this.nKeyFields, in);
1: 
1: 		id = new ContainerKey(segmentid, containerid);
1: 	}
1: 
1: 	
1: 	/**
1: 	Store the stored representation of the column value in the stream.
1: 	It might be easier to simply store the properties - which would certainly
1: 	make upgrading easier.
1: 
1:     @exception IOException thrown by writeObject()
1: 
1: 	*/
1: 	public void writeExternal(ObjectOutput out) 
1:         throws IOException
1:     {
1:         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);
1: 
1: 		out.writeLong(id.getContainerId());
1: 		out.writeInt((int) id.getSegmentId());
1: 		out.writeInt((nKeyFields));
1: 		out.writeInt((nUniqueColumns));
1: 		out.writeBoolean((allowDuplicates));
1: 		out.writeBoolean((maintainParentLinks));
1: 
1:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
1: 	}
1: 
1:     /**************************************************************************
1:      * Public toString() Method:
1:      **************************************************************************
1:      */
1: 
1:     public String toString()
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             return  ("BTREE: containerid = " + 
1:                      (this.id == null ? "null" : this.id.toString()) +
1:                      ";nKeyFields = " + nKeyFields +
1:                      ";nUniqueColumns = " + nUniqueColumns +
1:                      ";allowDuplicates = " + allowDuplicates);
1:         }
1:         else
1:         {
1:             return(super.toString());
1:         }
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
0: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
0: 
0: 
0: import java.io.IOException;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: 
0: import java.util.Properties;
0: 
0: 
0: /**
0: 
0:   A b-tree object corresponds to an instance of a b-tree conglomerate.  It 
0:   contains the static information about a conglomerate which is built at 
0:   create conglomerate time.
0:   <p>
0:   This generic implementation is expected to be extended by the concreate
0:   implementations.
0:   <P>
0:   The fields are set when the conglomerate is created and never changed 
0:   thereafter.  When alter table is supported then it will change under the
0:   control of a table level lock.
0:   <p>
0:   They have package scope because they're read by the scans and controllers.
0:   <p>
0:   A table of all conglomerates in the system is maintained by the accessmanager.
0:   A cache of conglomerates is maintained in the accessmanager, and references
0:   to the read only objects are handed out.  A copy of the Conglomerate
0:   object is kept in the control row of the root page, so that during logical
0:   undo this information can be read without needing to access the possibly
0:   corrupt table maintained by the access manager.
0: **/
0: 
0: public abstract class BTree extends GenericConglomerate
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     /**************************************************************************
0:      * Public Constants of BTree class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * The page number of the root page is always at the fixed page number:
0:      * ROOTPAGEID.  This means that given an open container, during logical
0:      * undo one can always find the root page and look up the conglomerate
0:      * information.
0:      **/
0:     public static final long ROOTPAGEID = ContainerHandle.FIRST_PAGE_NUMBER;
0: 
0: 	/** 
0:     Property name for the maximum number of rows to place in a btree page (leaf
0:     or branch).  Equal to 'derby.access.btreeMaxRowPerPage'.  Used by tests
0:     and debugging to exactly control split points, and to make it easier to test
0:     tall trees without needing lots of data.
0: 	*/
0: 	public static final String PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER = 
0:         (SanityManager.DEBUG ?  "derby.access.btreeMaxRowPerPage" : null);
0: 
0:     /* properties of a btree see create(). */
0:     public static final String PROPERTY_ALLOWDUPLICATES = "allowDuplicates";
0:     public static final String PROPERTY_NKEYFIELDS      = "nKeyFields";
0:     public static final String PROPERTY_NUNIQUECOLUMNS  = "nUniqueColumns";
0:     public static final String PROPERTY_PARENTLINKS     = "maintainParentLinks";
0: 
0: 
0: 
0:     /**************************************************************************
0:      * Protected Fields of BTree class:
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	The id of the container in which this b-tree is stored. 
0: 	**/
0: 	protected ContainerKey id;
0: 
0: 	/**
0: 	The number of key fields.
0: 	**/
0: 	protected int nKeyFields;
0: 
0: 	/**
0: 	The number of uniqueness columns.  These are the columns that
0: 	are considered for the purpose of detecting duplicate keys and rows.
0: 	**/
0: 	int nUniqueColumns;
0: 
0: 	/**
0: 	Whether the index allows duplicates or not.
0: 	**/
0: 	boolean allowDuplicates;
0: 
0: 	/**
0: 	Whether the parent should maintain links from child pages to their parent.
0: 	These links are only used for consistency checking purposes.  They improve
0: 	consistency checking at the cost of run-time efficiency.
0: 	**/
0: 	boolean maintainParentLinks;
0: 
0:     /**
0:     Maximum rows per page to place on a btree leaf or nonleaf page.  Used
0:     by testing to finely control split points.  Only changed for debugging
0:     purposes.
0: 
0:     RESOLVE (mikem) - this should not be static.  Need to design a way in
0:     debugging mode to get btree created with a persistent "maxRowsPerPage".
0:     This hack makes all btrees get created with the "last" maxRowsPerPage 
0:     value set.
0:     **/
0:     static int maxRowsPerPage = Integer.MAX_VALUE;
0: 
0: 	/**
0:     Format id of the conglomerate.
0: 	**/
0: 	protected int conglom_format_id;
0: 
0:     /**
0:     The array of format id's, one for each column in the template.
0:     **/
0:     int[]    format_ids;
0: 
0: 	//columns sorting order information
0: 	// true - Ascending Order ; false -Descending Order
0: 	protected boolean[]	ascDescInfo;
0: 
0: 	/*
0: 	** Private Methods of BTree.
0: 	*/
0: 
0: 	/*
0: 	** Public Methods of BTree.
0: 	*/
0: 
0: 
0:     /**************************************************************************
0:      * Abstract Protected locking methods of BTree:
0:      *     getBtreeLockingPolicy
0:      *     lockScan
0:      *     unlockScan
0:      *     lockPreviousRow
0:      *     lockRowOnPage
0:      *     lockRow
0:      *     lockTable
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Create a new btree locking policy from scratch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     abstract protected BTreeLockingPolicy getBtreeLockingPolicy(
0:     Transaction             rawtran,
0:     int                     lock_level,
0:     int                     mode,
0:     int                     isolation_level,
0:     ConglomerateController  base_cc,
0:     OpenBTree               open_btree)
0: 		throws StandardException;
0: 
0:     /**
0:      * Lock the base table.
0:      * <p>
0:      * Assumes that segment of the base container is the same as the segment
0:      * of the btree segment.
0:      * <p>
0:      * RESOLVE - we really want to get the lock without opening the container.
0:      * raw store will be providing this.
0:      *
0:      * @param xact_manager Transaction to associate the lock with.
0:      * @param forUpdate    Whether to lock exclusive or share.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     abstract public ConglomerateController lockTable(
0:     TransactionManager  xact_manager,
0:     int                 open_mode,
0:     int                 lock_level,
0:     int                 isolation_level)
0: 		throws StandardException;
0: 
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of BTree:
0:      **************************************************************************
0:      */
0: 
0: 
0:     /**
0:      * Create a branch row template for this conglomerate.
0:      * <p>
0:      * Reads the format id's of each of the columns and manufactures object of
0:      * the given type for each.  It then uses these "empty" objects to create
0:      * a template row.  The object passed in is then added to the last column
0:      * of the row.
0:      *
0: 	 * @return The new template.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     final DataValueDescriptor[] createBranchTemplate(
0:     DataValueDescriptor page_ptr)
0:         throws StandardException
0:     {
0:         return(TemplateRow.newBranchRow(format_ids, page_ptr));
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Public methods of BTree:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Create a template for this conglomerate.
0:      * <p>
0:      * Reads the format id's of each of the columns and manufactures object of
0:      * the given type for each.  It then uses these "empty" objects to create
0:      * a template row.
0:      * <p>
0:      * This method is public so that B2IUndo() can call it.
0:      *
0: 	 * @return The new template.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     final public DataValueDescriptor[] createTemplate()
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(format_ids != null);
0: 
0:         return(TemplateRow.newRow((FormatableBitSet) null, format_ids));
0:     }
0: 
0:     /**
0:      * Is this a "unique" index?
0:      **/
0:     final public boolean isUnique()
0:     {
0:         return(nKeyFields != nUniqueColumns);
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of Conglomerate Interface:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Add a column to the conglomerate.
0:      * <p>
0:      * Currently B2I does not support this operation.
0:      * input template column.  
0:      * 
0:      * @param xact_manager      Transaction to associate the lock with.
0:      * @param column_id        The column number to add this column at.
0:      * @param template_column  An instance of the column to be added to table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void addColumn(
0:     TransactionManager  xact_manager,
0:     int                 column_id,
0:     Storable            template_column)
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     /**
0:      * Get the id of the container of the conglomerate.
0:      * <p>
0:      * Will have to change when a conglomerate could have more than one 
0:      * container.  The ContainerKey is a combination of the container id
0:      * and segment id.
0:      *
0: 	 * @return The ContainerKey.
0:      **/
0:     public final ContainerKey getId()
0:     {
0:         return(id);
0:     }
0: 
0: 
0: 	/**
0: 	Do the generic part of creating a b-tree conglomerate.  This method 
0:     is called from the concrete subclass (which may also read some properties).
0:     <p>
0:     This method processes all properties which are generic to all BTree's.  It
0:     creates the container for the btree.
0:     <p>
0: 
0:     The following properties are generic to a b-tree conglomerate.  :
0: 
0:     <UL>
0:     <LI>"allowDuplicates" (boolean).  If set to true the table will allow 
0:     rows which are duplicate in key column's 0 through (nUniqueColumns - 1).
0:     Currently only supports "false".
0:     This property is optional, defaults to false.
0:     <LI>"nKeyFields"  (integer) Columns 0 through (nKeyFields - 1) will be 
0:     included in key of the conglomerate.
0:     This implementation requires that "nKeyFields" must be the same as the
0:     number of fields in the conglomerate, including the rowLocationColumn.
0:     Other implementations may relax this restriction to allow non-key fields
0:     in the index.
0:     This property is required.
0:     <LI>"nUniqueColumns" (integer) Columns 0 through "nUniqueColumns" will be 
0:     used to check for uniqueness.  So for a standard SQL non-unique index 
0:     implementation set "nUniqueColumns" to the same value as "nKeyFields"; and
0:     for a unique index set "nUniqueColumns" to "nKeyFields" - 1 (ie. don't 
0:     include the rowLocationColumn in the uniqueness check).
0:     This property is required.
0:     <LI>"maintainParentLinks" (boolean)
0:     Whether the b-tree pages maintain the page number of their parent.  Only
0:     used for consistency checking.  It takes a certain amount more effort to
0:     maintain these links, but they're really handy for ensuring that the index
0:     is consistent.
0:     This property is optional, defaults to true.
0:     </UL>
0: 
0:     @exception StandardException Thrown by underlying raw store, or thrown by
0:     this routine on an invalid containerid.
0:     
0: 	**/
0: 
0: 	public void create(
0:     Transaction             rawtran,
0:     int                     segmentId,
0:     long                    input_containerid,
0:     DataValueDescriptor[]   template,
0:     Properties              properties,
0:     int                     conglom_format_id,
0: 	int                     tmpFlag
0:     )
0:         throws StandardException
0: 	{
0:         String result_string;
0: 
0:         if (properties == null)
0:         {
0:             throw(
0:                 StandardException.newException(
0:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
0:         }
0: 
0:         // Check input arguments
0:         allowDuplicates = (Boolean.valueOf(
0:             properties.getProperty(PROPERTY_ALLOWDUPLICATES, "false"))).booleanValue();
0: 
0:         result_string = properties.getProperty(PROPERTY_NKEYFIELDS);
0:         if (result_string == null)
0:         {
0:             throw(
0:                 StandardException.newException(
0:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
0:         }
0:         else
0:         {
0:             nKeyFields = Integer.parseInt(result_string);
0:         }
0: 
0:         result_string = properties.getProperty(PROPERTY_NUNIQUECOLUMNS);
0:         if (result_string == null)
0:         {
0:             throw(StandardException.newException(
0:                 SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NUNIQUECOLUMNS));
0:         }
0:         else
0:         {
0:             nUniqueColumns = Integer.parseInt(result_string);
0:         }
0: 
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             result_string = 
0:                 properties.getProperty(PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER);
0: 
0:             if (result_string != null)
0:             {
0:                 maxRowsPerPage = Integer.parseInt(result_string);
0:             }
0:         }
0: 
0:         maintainParentLinks = (Boolean.valueOf(
0:             properties.getProperty(PROPERTY_PARENTLINKS, "true"))).booleanValue();
0: 
0:         // RESOLVE (mikem) - true for now, if we want to support non-key 
0:         // fields eventually this assert may be wrong.
0:         if (SanityManager.DEBUG)
0:         {
0: 			if (template.length != nKeyFields)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"template.length (" + template.length +
0: 					") expected to equal nKeyFields (" + 
0: 					nKeyFields + ")");
0: 			}
0:             SanityManager.ASSERT((nUniqueColumns == nKeyFields) || 
0:                                  (nUniqueColumns == (nKeyFields - 1)));
0:         }
0: 
0:         // get format id's from each column in template and store it in the
0:         // conglomerate state.
0:         format_ids = ConglomerateUtil.createFormatIds(template);
0: 
0:         // copy the format id of the conglomerate.
0:         this.conglom_format_id = conglom_format_id;
0: 
0: 		// Create a container for the b-tree with default page size and 
0:         // fill up pages.
0: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, "0");
0: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, "1");
0: 		properties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, "true");
0: 
0: 		long containerid = 
0:             rawtran.addContainer(
0:                 segmentId, input_containerid, 
0:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
0: 
0: 		// Make sure the container was actually created.
0: 		// Open segment will get cleaned up when transaction is.
0: 		if (containerid <= 0)
0:         {
0:             throw(StandardException.newException(
0:                     SQLState.BTREE_CANT_CREATE_CONTAINER)); 
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (input_containerid != ContainerHandle.DEFAULT_ASSIGN_ID)
0:                 SanityManager.ASSERT(containerid == input_containerid);
0:         }
0: 
0: 		id = new ContainerKey(segmentId, containerid);
0: 	}
0: 
0: 	/**
0: 	Drop this btree.
0: 	This must be done by a concrete implementation.
0: 	@see Conglomerate#drop
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public abstract void drop(TransactionManager xact_manager)
0: 		throws StandardException;
0: 
0: 	/**
0: 	Load a b-tree.  This must be done by a concrete implementation.
0: 	@see Conglomerate#load
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public abstract long load(
0: 	TransactionManager      xact_manager,
0: 	boolean                 createConglom,
0: 	RowLocationRetRowSource rowSource)
0: 		throws StandardException;
0: 
0:     public long getContainerid()
0:     {
0:         return(this.id.getContainerId());
0:     }
0: 
0:     /**
0:      * Return dynamic information about the conglomerate to be dynamically 
0:      * reused in repeated execution of a statement.
0:      * <p>
0:      * The dynamic info is a set of variables to be used in a given 
0:      * ScanController or ConglomerateController.  It can only be used in one 
0:      * controller at a time.  It is up to the caller to insure the correct 
0:      * thread access to this info.  The type of info in this is a scratch 
0:      * template for btree traversal, other scratch variables for qualifier 
0:      * evaluation, ...
0:      * <p>
0:      *
0: 	 * @return The dynamic information.
0:      *
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
0: 		throws StandardException
0:     {
0:         return(new OpenConglomerateScratchSpace(format_ids));
0:     }
0: 
0: 
0:     /**
0:      * Is this conglomerate temporary?
0:      * <p>
0:      *
0: 	 * @return whether conglomerate is temporary or not.
0:      **/
0:     public boolean isTemporary()
0:     {
0:         return (id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
0:     }
0: 
0: 	/**
0: 	Open a b-tree controller.
0: 	This must be done by a concrete implementation.
0: 	@see Conglomerate#open
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public abstract ConglomerateController open(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException;
0: 
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods of Storable Interface (via Conglomerate):
0:      *     This class is responsible for re/storing its own state.
0:      **************************************************************************
0:      */
0: 
0: 
0: 	/**
0: 	Return whether the value is null or not.
0: 	The containerid being zero is what determines nullness;  subclasses
0: 	are not expected to override this method.
0: 	@see org.apache.derby.iapi.services.io.Storable#isNull
0: 	**/
0: 	public boolean isNull()
0: 	{
0: 		return id == null;
0: 	}
0: 
0: 	/**
0: 	Restore the in-memory representation to the null value.
0: 	The containerid being zero is what determines nullness;  subclasses
0: 	are not expected to override this method.
0: 
0: 	@see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	**/
0: 	public void restoreToNull()
0: 	{
0: 		id = null;
0: 	}
0: 
0: 	/**
0: 	Restore the in-memory representation from the stream.
0: 
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
0: 
0:     @exception IOException thrown by readObject()
0: 
0: 	
0: 	@see java.io.Externalizable#readExternal
0: 	*/
0: 	public void readExternal(ObjectInput in) 
0:         throws IOException, ClassNotFoundException
0: 	{
0:         // read in the conglomerate format id.
0:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
0: 
0: 		// XXX (nat) need to improve error handling
0: 		long containerid         = in.readLong();
0: 		int segmentid			= in.readInt();
0: 		nKeyFields          = in.readInt();
0: 		nUniqueColumns      = in.readInt();
0: 		allowDuplicates     = in.readBoolean();
0: 		maintainParentLinks = in.readBoolean();
0: 
0:         // read in the array of format id's
0:         format_ids = ConglomerateUtil.readFormatIdArray(this.nKeyFields, in);
0: 
0: 		id = new ContainerKey(segmentid, containerid);
0: 	}
0: 
0: 	public void readExternalFromArray(ArrayInputStream in) 
0:         throws IOException, ClassNotFoundException
0: 	{
0:         // read in the conglomerate format id.
0:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
0: 
0: 		// XXX (nat) need to improve error handling
0: 		long containerid         = in.readLong();
0: 		int segmentid			= in.readInt();
0: 		nKeyFields          = in.readInt();
0: 		nUniqueColumns      = in.readInt();
0: 		allowDuplicates     = in.readBoolean();
0: 		maintainParentLinks = in.readBoolean();
0: 
0:         // read in the array of format id's
0:         format_ids = ConglomerateUtil.readFormatIdArray(this.nKeyFields, in);
0: 
0: 		id = new ContainerKey(segmentid, containerid);
0: 	}
0: 
0: 	
0: 	/**
0: 	Store the stored representation of the column value in the stream.
0: 	It might be easier to simply store the properties - which would certainly
0: 	make upgrading easier.
0: 
0:     @exception IOException thrown by writeObject()
0: 
0: 	*/
0: 	public void writeExternal(ObjectOutput out) 
0:         throws IOException
0:     {
0:         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);
0: 
0: 		out.writeLong(id.getContainerId());
0: 		out.writeInt((int) id.getSegmentId());
0: 		out.writeInt((nKeyFields));
0: 		out.writeInt((nUniqueColumns));
0: 		out.writeBoolean((allowDuplicates));
0: 		out.writeBoolean((maintainParentLinks));
0: 
0:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
0: 	}
0: 
0:     /**************************************************************************
0:      * Public toString() Method:
0:      **************************************************************************
0:      */
0: 
0:     public String toString()
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             return  ("BTREE: containerid = " + 
0:                      (this.id == null ? "null" : this.id.toString()) +
0:                      ";nKeyFields = " + nKeyFields +
0:                      ";nUniqueColumns = " + nUniqueColumns +
0:                      ";allowDuplicates = " + allowDuplicates);
0:         }
0:         else
0:         {
0:             return(super.toString());
0:         }
0:     }
0: }
============================================================================