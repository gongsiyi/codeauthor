1:637c1f9: /*
1:637c1f9: 
1:637c1f9: Derby - Class org.apache.derby.client.am.StatementCacheInteractor
1:637c1f9: 
1:637c1f9: Licensed to the Apache Software Foundation (ASF) under one or more
1:637c1f9: contributor license agreements.  See the NOTICE file distributed with
1:637c1f9: this work for additional information regarding copyright ownership.
1:637c1f9: The ASF licenses this file to You under the Apache License, Version 2.0
1:637c1f9: (the "License"); you may not use this file except in compliance with
1:637c1f9: the License.  You may obtain a copy of the License at
1:637c1f9: 
1:637c1f9: http://www.apache.org/licenses/LICENSE-2.0
1:637c1f9: 
1:637c1f9: Unless required by applicable law or agreed to in writing, software
1:637c1f9: distributed under the License is distributed on an "AS IS" BASIS,
1:637c1f9: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:637c1f9: See the License for the specific language governing permissions and
1:637c1f9: limitations under the License.
1:637c1f9: 
1:637c1f9: */
1:637c1f9: 
1:1beab6c: package org.apache.derby.client.am;
1:8a0018d: 
1:69e3d06: import java.sql.CallableStatement;
1:69e3d06: import java.sql.PreparedStatement;
1:1beab6c: import java.sql.SQLException;
1:8a0018d: import java.util.ArrayList;
1:1beab6c: import org.apache.derby.client.am.stmtcache.JDBCStatementCache;
1:1beab6c: import org.apache.derby.client.am.stmtcache.StatementKey;
1:1beab6c: import org.apache.derby.client.am.stmtcache.StatementKeyFactory;
1:1beab6c: import org.apache.derby.jdbc.ClientDriver;
1:8a0018d: import org.apache.derby.shared.common.sanity.SanityManager;
3:1beab6c: 
1:1beab6c: /**
1:1beab6c:  * Utility class encapsulating the logic for interacting with the JDBC statement
1:1beab6c:  * cache when creating new logical statements.
1:1beab6c:  * <p>
1:1beab6c:  * This class was introduced to share code between the pre-JDBC 4 and the JDBC
1:1beab6c:  * 4+ versions of the JDBC classes.
1:1beab6c:  * <p>
1:1beab6c:  * The pattern for the {@code prepareX} methods is:
1:1beab6c:  * <ol> <li>Generate a key for the statement to create.</li>
1:1beab6c:  *      <li>Consult cache to see if an existing statement can be used.</li>
1:1beab6c:  *      <li>Create new statement on physical connection if necessary.</li>
1:8a0018d:  *      <li>Return reference to existing or newly created statement.</li>
1:1beab6c:  * </ol>
1:1beab6c:  */
1:d6cf884: public final class StatementCacheInteractor {
1:1beab6c: 
1:1beab6c:     /** Statement cache for the associated physical connection. */
1:1beab6c:     private final JDBCStatementCache cache;
1:1beab6c:     /**
1:1beab6c:      * The underlying physical connection.
1:1beab6c:      * <p>
1:1beab6c:      * Note that it is the responsibility of the logical statement assoiciated
1:1beab6c:      * with this cache interactor to ensure the interactor methods are not
1:1beab6c:      * invoked if the logical statement has been closed.
1:1beab6c:      */
1:69e3d06:     private final ClientConnection physicalConnection;
1:8a0018d:     /** List of open logical statements created by this cache interactor. */
1:8a0018d:     //@GuardedBy("this")
1:4772c7e:     private final ArrayList<LogicalStatementEntity> openLogicalStatements =
1:4772c7e:             new ArrayList<LogicalStatementEntity>();
1:77a3bd1:     /**
1:77a3bd1:      * Tells if this interactor is in the process of shutting down.
1:77a3bd1:      * <p>
1:77a3bd1:      * If this is true, it means that the logical connection is being closed.
1:77a3bd1:      */
1:77a3bd1:     private boolean connCloseInProgress = false;
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * Creates a new JDBC statement cache interactor.
1:1beab6c:      *
1:1beab6c:      * @param cache statement cache
1:1beab6c:      * @param physicalConnection associated physical connection
1:1beab6c:      */
1:1beab6c:     StatementCacheInteractor(JDBCStatementCache cache,
1:69e3d06:                              ClientConnection physicalConnection) {
1:1beab6c:         this.cache = cache;
1:1beab6c:         this.physicalConnection = physicalConnection;
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareStatement(String)
1:1beab6c:      */
1:0326967:     synchronized PreparedStatement prepareStatement(String sql)
3:1beab6c:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(),
1:2e8051d:                 physicalConnection.holdability());
1:69e3d06:         PreparedStatement ps = cache.getCached(stmtKey);
1:1beab6c:         if (ps == null) {
1:1beab6c:             ps = physicalConnection.prepareStatement(sql);
1:1beab6c:         }
1:8a0018d:         return createLogicalPreparedStatement(ps, stmtKey);
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareStatement(String,int,int)
1:1beab6c:      */
1:0326967:     synchronized PreparedStatement prepareStatement(
1:1beab6c:                                                 String sql,
1:1beab6c:                                                 int resultSetType,
1:1beab6c:                                                 int resultSetConcurrency)
1:1beab6c:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:2e8051d:                 resultSetConcurrency, physicalConnection.holdability());
1:69e3d06:         PreparedStatement ps = cache.getCached(stmtKey);
1:1beab6c:         if (ps == null) {
1:1beab6c:             ps = physicalConnection.prepareStatement(
1:1beab6c:                     sql, resultSetType, resultSetConcurrency);
1:1beab6c:         }
1:8a0018d:         return createLogicalPreparedStatement(ps, stmtKey);
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareStatement(String,int,int,int)
1:1beab6c:      */
1:0326967:     synchronized PreparedStatement prepareStatement(
1:1beab6c:                                                 String sql,
1:1beab6c:                                                 int resultSetType,
1:1beab6c:                                                 int resultSetConcurrency,
1:1beab6c:                                                 int resultSetHoldability)
1:1beab6c:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:2e8051d:                 resultSetConcurrency, resultSetHoldability);
1:1beab6c: 
1:69e3d06:         PreparedStatement ps = cache.getCached(stmtKey);
1:1beab6c:         if (ps == null) {
1:1beab6c:             ps = physicalConnection.prepareStatement(
1:1beab6c:                 sql, resultSetType,resultSetConcurrency, resultSetHoldability);
1:1beab6c:         }
1:8a0018d:         return createLogicalPreparedStatement(ps, stmtKey);
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareStatement(String,int)
1:1beab6c:      */
1:0326967:     synchronized PreparedStatement prepareStatement(
1:1beab6c:                                                 String sql,
1:1beab6c:                                                 int autoGeneratedKeys)
1:1beab6c:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(),
1:2e8051d:                 physicalConnection.getHoldability(), autoGeneratedKeys);
1:69e3d06:         PreparedStatement ps = cache.getCached(stmtKey);
1:1beab6c:         if (ps == null) {
1:1beab6c:             ps = physicalConnection.prepareStatement(sql, autoGeneratedKeys);
1:1beab6c:         }
1:8a0018d:         return createLogicalPreparedStatement(ps, stmtKey);
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareCall(String)
1:1beab6c:      */
1:0326967:     synchronized CallableStatement prepareCall(String sql)
1:1beab6c:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newCallable(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(),
1:2e8051d:                 physicalConnection.holdability());
1:69e3d06:         CallableStatement cs =
1:69e3d06:             (CallableStatement)cache.getCached(stmtKey);
1:b13b17c: 
1:1beab6c:         if (cs == null) {
1:1beab6c:             cs = physicalConnection.prepareCall(sql);
1:1beab6c:         }
1:8a0018d:         return createLogicalCallableStatement(cs, stmtKey);
1:1beab6c:     }
1:b13b17c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareCall(String,int,int)
1:1beab6c:      */
1:0326967:     synchronized CallableStatement prepareCall(String sql,
1:1beab6c:                                                       int resultSetType,
1:1beab6c:                                                       int resultSetConcurrency)
1:8a0018d:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newCallable(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:2e8051d:                 resultSetConcurrency, physicalConnection.holdability());
1:69e3d06:         CallableStatement cs =
1:69e3d06:             (CallableStatement)cache.getCached(stmtKey);
1:b13b17c: 
1:1beab6c:         if (cs == null) {
1:1beab6c:             cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:1beab6c:         }
1:8a0018d:         return createLogicalCallableStatement(cs, stmtKey);
1:1beab6c:     }
1:1beab6c: 
1:1beab6c:     /**
1:1beab6c:      * @see java.sql.Connection#prepareCall(String,int,int,int)
1:1beab6c:      */
1:0326967:     synchronized CallableStatement prepareCall(String sql,
1:1beab6c:                                                       int resultSetType,
1:1beab6c:                                                       int resultSetConcurrency,
1:1beab6c:                                                       int resultSetHoldability)
1:8a0018d:             throws SQLException {
1:1beab6c:         StatementKey stmtKey = StatementKeyFactory.newCallable(
1:2e8051d:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:2e8051d:                 resultSetConcurrency, resultSetHoldability);
1:69e3d06:         CallableStatement cs =
1:69e3d06:             (CallableStatement)cache.getCached(stmtKey);
1:1beab6c: 
1:1beab6c:         if (cs == null) {
1:1beab6c:             cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency,
3:1beab6c:                     resultSetHoldability);
1:8a0018d:         }
1:8a0018d:         return createLogicalCallableStatement(cs, stmtKey);
1:1beab6c:     }
1:8a0018d: 
1:8a0018d:     /**
1:77a3bd1:      * Closes all open logical statements created by this cache interactor.
1:77a3bd1:      * <p>
1:77a3bd1:      * A cache interactor is bound to a single (caching) logical connection.
1:77a3bd1:      * @throws SQLException if closing an open logical connection fails
1:77a3bd1:      */
1:b565f41:     synchronized void closeOpenLogicalStatements()
1:77a3bd1:             throws SQLException {
1:77a3bd1:         // Transist to closing state, to avoid changing the list of open
1:77a3bd1:         // statements as we work our way through the list.
1:77a3bd1:         this.connCloseInProgress = true;
1:77a3bd1:         // Iterate through the list and close the logical statements.
1:4772c7e:         for (LogicalStatementEntity logicalStatement : openLogicalStatements) {
1:77a3bd1:             logicalStatement.close();
1:77a3bd1:         }
1:77a3bd1:         // Clear the list for good measure.
1:77a3bd1:         this.openLogicalStatements.clear();
1:77a3bd1:     }
1:77a3bd1: 
1:77a3bd1:     /**
1:77a3bd1:      * Designates the specified logical statement as closed.
1:77a3bd1:      *
1:77a3bd1:      * @param logicalStmt the logical statement being closed
1:77a3bd1:      */
1:0326967:     synchronized void markClosed(LogicalStatementEntity logicalStmt) {
1:77a3bd1:         // If we are not in the process of shutting down the logical connection,
1:77a3bd1:         // remove the notifying statement from the list of open statements.
1:77a3bd1:         if (!connCloseInProgress) {
1:77a3bd1:             boolean removed = this.openLogicalStatements.remove(logicalStmt);
1:77a3bd1:             if (SanityManager.DEBUG) {
1:77a3bd1:                 SanityManager.ASSERT(removed,
1:77a3bd1:                     "Tried to remove unregistered logical statement: " +
1:77a3bd1:                     logicalStmt);
1:77a3bd1:             }
1:77a3bd1:         }
1:77a3bd1:     }
1:77a3bd1: 
1:77a3bd1:     /**
1:8a0018d:      * Creates a logical prepared statement.
1:8a0018d:      *
1:8a0018d:      * @param ps the underlying physical prepared statement
1:8a0018d:      * @param stmtKey the statement key for the physical statement
1:8a0018d:      * @return A logical prepared statement.
1:8a0018d:      * @throws SQLException if creating a logical prepared statement fails
1:8a0018d:      */
1:69e3d06:     private PreparedStatement createLogicalPreparedStatement(
1:69e3d06:             PreparedStatement ps,
1:b13b17c:             StatementKey stmtKey) throws SQLException {
1:b13b17c: 
1:8a0018d:         LogicalPreparedStatement logicalPs =
1:8a0018d:                 ClientDriver.getFactory().newLogicalPreparedStatement(
1:8a0018d:                                                     ps, stmtKey, this);
1:b13b17c:         this.openLogicalStatements.add(logicalPs);
1:b13b17c:         return logicalPs;
1:8a0018d:     }
1:8a0018d: 
1:8a0018d:     /**
1:8a0018d:      * Creates a logical callable statement.
1:8a0018d:      *
1:8a0018d:      * @param cs the underlying physical callable statement
1:8a0018d:      * @param stmtKey the statement key for the physical statement
1:8a0018d:      * @return A logical callable statement.
1:8a0018d:      * @throws SQLException if creating a logical callable statement fails
1:8a0018d:      */
1:69e3d06:     private CallableStatement createLogicalCallableStatement(
1:69e3d06:             CallableStatement cs,
1:b13b17c:             StatementKey stmtKey) throws SQLException {
1:b13b17c: 
1:8a0018d:         LogicalCallableStatement logicalCs =
1:8a0018d:                 ClientDriver.getFactory().newLogicalCallableStatement(
1:8a0018d:                                                     cs, stmtKey, this);
1:b13b17c:         this.openLogicalStatements.add(logicalCs);
1:b13b17c:         return logicalCs;
1:d6cf884:     }
1:d6cf884: 
1:d6cf884:     /**
1:d6cf884:      * Returns the associated statement cache.
1:d6cf884:      *
1:d6cf884:      * @return A statement cache.
1:d6cf884:      */
1:d6cf884:     JDBCStatementCache getCache() {
1:d6cf884:         return this.cache;
1:1beab6c:     }
1:1beab6c: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     synchronized void closeOpenLogicalStatements()
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     synchronized PreparedStatement prepareStatement(String sql)
/////////////////////////////////////////////////////////////////////////
1:     synchronized PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     synchronized PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     synchronized PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     synchronized CallableStatement prepareCall(String sql)
/////////////////////////////////////////////////////////////////////////
1:     synchronized CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1:     synchronized CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1:     synchronized void markClosed(LogicalStatementEntity logicalStmt) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:     private final ClientConnection physicalConnection;
/////////////////////////////////////////////////////////////////////////
1:                              ClientConnection physicalConnection) {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized PreparedStatement prepareStatement(String sql)
1:         PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized PreparedStatement prepareStatement(
1:         PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized CallableStatement prepareCall(String sql)
1:         CallableStatement cs =
1:             (CallableStatement)cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized CallableStatement prepareCall(String sql,
1:         CallableStatement cs =
1:             (CallableStatement)cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1:         CallableStatement cs =
1:             (CallableStatement)cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
1:     private PreparedStatement createLogicalPreparedStatement(
1:             PreparedStatement ps,
/////////////////////////////////////////////////////////////////////////
1:     private CallableStatement createLogicalCallableStatement(
1:             CallableStatement cs,
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.PreparedStatement prepareStatement(String sql)
0:         java.sql.PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         java.sql.PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.PreparedStatement prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         java.sql.PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.PreparedStatement prepareStatement(
0:         java.sql.PreparedStatement ps = cache.getCached(stmtKey);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.CallableStatement prepareCall(String sql)
0:         java.sql.CallableStatement cs =
0:             (java.sql.CallableStatement)cache.getCached(stmtKey);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.CallableStatement prepareCall(String sql,
0:         java.sql.CallableStatement cs =
0:             (java.sql.CallableStatement)cache.getCached(stmtKey);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public synchronized java.sql.CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
0:         java.sql.CallableStatement cs =
0:             (java.sql.CallableStatement)cache.getCached(stmtKey);
1: 
/////////////////////////////////////////////////////////////////////////
0:     private java.sql.PreparedStatement createLogicalPreparedStatement(
0:             java.sql.PreparedStatement ps,
1:             StatementKey stmtKey) throws SQLException {
1: 
1:         this.openLogicalStatements.add(logicalPs);
1:         return logicalPs;
/////////////////////////////////////////////////////////////////////////
0:     private java.sql.CallableStatement createLogicalCallableStatement(
0:             java.sql.CallableStatement cs,
1:             StatementKey stmtKey) throws SQLException {
1: 
1:         this.openLogicalStatements.add(logicalCs);
1:         return logicalCs;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ArrayList<LogicalStatementEntity> openLogicalStatements =
1:             new ArrayList<LogicalStatementEntity>();
/////////////////////////////////////////////////////////////////////////
1:         for (LogicalStatementEntity logicalStatement : openLogicalStatements) {
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:637c1f9
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derby.client.am.StatementCacheInteractor
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:77a3bd1
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells if this interactor is in the process of shutting down.
1:      * <p>
1:      * If this is true, it means that the logical connection is being closed.
1:      */
1:     private boolean connCloseInProgress = false;
/////////////////////////////////////////////////////////////////////////
1:      * Closes all open logical statements created by this cache interactor.
1:      * <p>
1:      * A cache interactor is bound to a single (caching) logical connection.
1:      * @throws SQLException if closing an open logical connection fails
1:      */
0:     public synchronized void closeOpenLogicalStatements()
1:             throws SQLException {
1:         // Transist to closing state, to avoid changing the list of open
1:         // statements as we work our way through the list.
1:         this.connCloseInProgress = true;
1:         // Iterate through the list and close the logical statements.
0:         Iterator logicalStatements = this.openLogicalStatements.iterator();
0:         while (logicalStatements.hasNext()) {
0:             LogicalStatementEntity logicalStatement =
0:                     (LogicalStatementEntity)logicalStatements.next();
1:             logicalStatement.close();
1:         }
1:         // Clear the list for good measure.
1:         this.openLogicalStatements.clear();
1:     }
1: 
1:     /**
1:      * Designates the specified logical statement as closed.
1:      *
1:      * @param logicalStmt the logical statement being closed
1:      */
0:     public synchronized void markClosed(LogicalStatementEntity logicalStmt) {
1:         // If we are not in the process of shutting down the logical connection,
1:         // remove the notifying statement from the list of open statements.
1:         if (!connCloseInProgress) {
1:             boolean removed = this.openLogicalStatements.remove(logicalStmt);
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(removed,
1:                     "Tried to remove unregistered logical statement: " +
1:                     logicalStmt);
1:             }
1:         }
1:     }
1: 
1:     /**
commit:2e8051d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(),
1:                 physicalConnection.holdability());
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:                 resultSetConcurrency, physicalConnection.holdability());
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:                 resultSetConcurrency, resultSetHoldability);
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(),
1:                 physicalConnection.getHoldability(), autoGeneratedKeys);
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(),
1:                 physicalConnection.holdability());
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:                 resultSetConcurrency, physicalConnection.holdability());
/////////////////////////////////////////////////////////////////////////
1:                 sql, physicalConnection.getCurrentSchemaName(), resultSetType,
1:                 resultSetConcurrency, resultSetHoldability);
commit:8a0018d
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: 
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:  *      <li>Return reference to existing or newly created statement.</li>
/////////////////////////////////////////////////////////////////////////
1:     /** List of open logical statements created by this cache interactor. */
1:     //@GuardedBy("this")
0:     private final ArrayList openLogicalStatements = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalPreparedStatement(ps, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalPreparedStatement(ps, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalPreparedStatement(ps, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalPreparedStatement(ps, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalCallableStatement(cs, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalCallableStatement(cs, stmtKey);
/////////////////////////////////////////////////////////////////////////
1:         return createLogicalCallableStatement(cs, stmtKey);
1:     }
1: 
1:     /**
1:      * Creates a logical prepared statement.
1:      *
1:      * @param ps the underlying physical prepared statement
1:      * @param stmtKey the statement key for the physical statement
1:      * @return A logical prepared statement.
1:      * @throws SQLException if creating a logical prepared statement fails
1:      */
0:     private PreparedStatement createLogicalPreparedStatement(
0:                                                     PreparedStatement ps,
0:                                                     StatementKey stmtKey)
1:             throws SQLException {
1:         LogicalPreparedStatement logicalPs =
1:                 ClientDriver.getFactory().newLogicalPreparedStatement(
1:                                                     ps, stmtKey, this);
0:        this.openLogicalStatements.add(logicalPs);
0:        return logicalPs;
1:     }
1: 
1:     /**
1:      * Creates a logical callable statement.
1:      *
1:      * @param cs the underlying physical callable statement
1:      * @param stmtKey the statement key for the physical statement
1:      * @return A logical callable statement.
1:      * @throws SQLException if creating a logical callable statement fails
1:      */
0:     private CallableStatement createLogicalCallableStatement(
0:                                                     CallableStatement cs,
0:                                                     StatementKey stmtKey)
1:             throws SQLException {
1:         LogicalCallableStatement logicalCs =
1:                 ClientDriver.getFactory().newLogicalCallableStatement(
1:                                                     cs, stmtKey, this);
0:        this.openLogicalStatements.add(logicalCs);
0:        return logicalCs;
commit:d6cf884
/////////////////////////////////////////////////////////////////////////
1: public final class StatementCacheInteractor {
/////////////////////////////////////////////////////////////////////////
0:                     ps, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                 ps, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                     ps, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                     ps, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                     cs, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                     cs, stmtKey, this);
/////////////////////////////////////////////////////////////////////////
0:                     cs, stmtKey, this);
1:     }
1: 
1:     /**
1:      * Returns the associated statement cache.
1:      *
1:      * @return A statement cache.
1:      */
1:     JDBCStatementCache getCache() {
1:         return this.cache;
commit:1beab6c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.client.am;
1: 
0: import java.sql.CallableStatement;
0: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: 
1: import org.apache.derby.client.am.stmtcache.JDBCStatementCache;
1: import org.apache.derby.client.am.stmtcache.StatementKey;
1: import org.apache.derby.client.am.stmtcache.StatementKeyFactory;
1: import org.apache.derby.jdbc.ClientDriver;
1: 
1: /**
1:  * Utility class encapsulating the logic for interacting with the JDBC statement
1:  * cache when creating new logical statements.
1:  * <p>
1:  * This class was introduced to share code between the pre-JDBC 4 and the JDBC
1:  * 4+ versions of the JDBC classes.
1:  * <p>
1:  * The pattern for the {@code prepareX} methods is:
1:  * <ol> <li>Generate a key for the statement to create.</li>
1:  *      <li>Consult cache to see if an existing statement can be used.</li>
1:  *      <li>Create new statement on physical connection if necessary.</li>
0:  *      <li>Return referecne to existing or newly created statement.</li>
1:  * </ol>
1:  */
0: final class StatementCacheInteractor {
1: 
0:     /** TODO: Fetch from connection, see DERBY-3192. */
0:     private final String currentSchema = "APP";
1:     /** Statement cache for the associated physical connection. */
1:     private final JDBCStatementCache cache;
1:     /**
1:      * The underlying physical connection.
1:      * <p>
1:      * Note that it is the responsibility of the logical statement assoiciated
1:      * with this cache interactor to ensure the interactor methods are not
1:      * invoked if the logical statement has been closed.
1:      */
0:     private final Connection physicalConnection;
1: 
1:     /**
1:      * Creates a new JDBC statement cache interactor.
1:      *
1:      * @param cache statement cache
1:      * @param physicalConnection associated physical connection
1:      */
1:     StatementCacheInteractor(JDBCStatementCache cache,
0:                              Connection physicalConnection) {
1:         this.cache = cache;
1:         this.physicalConnection = physicalConnection;
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareStatement(String)
1:      */
0:     public synchronized PreparedStatement prepareStatement(String sql)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
0:                 sql, currentSchema, physicalConnection.holdability());
0:         PreparedStatement ps = cache.getCached(stmtKey);
1:         if (ps == null) {
1:             ps = physicalConnection.prepareStatement(sql);
1:         }
0:         return ClientDriver.getFactory().newLogicalPreparedStatement(
0:                     ps, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareStatement(String,int,int)
1:      */
0:     public synchronized PreparedStatement prepareStatement(
1:                                                 String sql,
1:                                                 int resultSetType,
1:                                                 int resultSetConcurrency)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
0:                 sql, currentSchema, resultSetType, resultSetConcurrency,
0:                 physicalConnection.holdability());
0:         PreparedStatement ps = cache.getCached(stmtKey);
1:         if (ps == null) {
1:             ps = physicalConnection.prepareStatement(
1:                     sql, resultSetType, resultSetConcurrency);
1:         }
0:         return ClientDriver.getFactory().newLogicalPreparedStatement(
0:                 ps, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareStatement(String,int,int,int)
1:      */
0:     public synchronized PreparedStatement prepareStatement(
1:                                                 String sql,
1:                                                 int resultSetType,
1:                                                 int resultSetConcurrency,
1:                                                 int resultSetHoldability)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
0:                 sql, currentSchema, resultSetType, resultSetConcurrency,
1:                 resultSetHoldability);
1: 
0:         PreparedStatement ps = cache.getCached(stmtKey);
1:         if (ps == null) {
1:             ps = physicalConnection.prepareStatement(
1:                 sql, resultSetType,resultSetConcurrency, resultSetHoldability);
1:         }
0:         return ClientDriver.getFactory().newLogicalPreparedStatement(
0:                     ps, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareStatement(String,int)
1:      */
0:     public synchronized PreparedStatement prepareStatement(
1:                                                 String sql,
1:                                                 int autoGeneratedKeys)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newPrepared(
0:                 sql, currentSchema, physicalConnection.getHoldability(),
0:                 autoGeneratedKeys);
0:         PreparedStatement ps = cache.getCached(stmtKey);
1:         if (ps == null) {
1:             ps = physicalConnection.prepareStatement(sql, autoGeneratedKeys);
1:         }
0:         return ClientDriver.getFactory().newLogicalPreparedStatement(
0:                     ps, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareCall(String)
1:      */
0:     public synchronized CallableStatement prepareCall(String sql)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newCallable(
0:                 sql, currentSchema, physicalConnection.holdability());
0:         CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
1:         if (cs == null) {
1:             cs = physicalConnection.prepareCall(sql);
1:         }
0:         return ClientDriver.getFactory().newLogicalCallableStatement(
0:                     cs, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareCall(String,int,int)
1:      */
0:     public synchronized CallableStatement prepareCall(String sql,
1:                                                       int resultSetType,
1:                                                       int resultSetConcurrency)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newCallable(
0:                 sql, currentSchema, resultSetType, resultSetConcurrency,
0:                 physicalConnection.holdability());
0:         CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
1:         if (cs == null) {
1:             cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:         }
0:         return ClientDriver.getFactory().newLogicalCallableStatement(
0:                     cs, stmtKey, cache);
1:     }
1: 
1:     /**
1:      * @see java.sql.Connection#prepareCall(String,int,int,int)
1:      */
0:     public synchronized CallableStatement prepareCall(String sql,
1:                                                       int resultSetType,
1:                                                       int resultSetConcurrency,
1:                                                       int resultSetHoldability)
1:             throws SQLException {
1:         StatementKey stmtKey = StatementKeyFactory.newCallable(
0:                 sql, currentSchema, resultSetType, resultSetConcurrency,
1:                 resultSetHoldability);
0:         CallableStatement cs = (CallableStatement)cache.getCached(stmtKey);
1:         if (cs == null) {
1:             cs = physicalConnection.prepareCall(sql, resultSetType, resultSetConcurrency,
1:                     resultSetHoldability);
1:         }
0:         return ClientDriver.getFactory().newLogicalCallableStatement(
0:                     cs, stmtKey, cache);
1:     }
1: }
============================================================================