1:eac0369: /*
5:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.StoredFieldHeader
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:eac0369: import java.io.EOFException;
1:a5d378d: import java.io.IOException;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.OutputStream;
1:eac0369: 
1:a5d378d: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: import org.apache.derby.iapi.services.io.CompressedNumber;
1:a5d378d: import org.apache.derby.iapi.services.io.DataInputUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369:     A class to provide static methods to manipulate fields in the field header.
1:eac0369: 
1:eac0369: 	A class StoredPage uses to read/write field status and field data length.
1:eac0369: 	No attributes exist in this class, this class provides a set of static
1:eac0369: 	methods for writing field status and field data length, and for reading
1:eac0369: 	field status and field data length.
1:eac0369: 
1:eac0369: 	<P><B>Stored Field Header Format</B><BR>
1:eac0369: 	The field header is broken into two sections.  
1:eac0369:     Only the Status byte is required to be there.
1:eac0369: 	<PRE>
1:eac0369: 	Field header format:
1:eac0369: 	+--------+-------------------+
1:eac0369: 	| status | <fieldDataLength> |
1:eac0369: 	+--------+-------------------+
1:eac0369: 	Overflow page and overflow id are stored as field data.
1:eac0369: 	If the overflow bit in status is set, the field data is the overflow 
1:eac0369:     information.  When the overflow bit is not set in status, then,
1:eac0369: 	fieldData is the actually user data for the field.
1:eac0369: 	That means, field header consists only field status, and field data length.
1:eac0369: 
1:eac0369: 	A non-overflow field:
1:eac0369: 	+--------+-------------------+-------------+
1:eac0369: 	| status | <fieldDataLength> | <fieldData> |
1:eac0369: 	+--------+-------------------+-------------+
1:eac0369: 
1:eac0369: 	An overflow field:
1:eac0369: 	+--------+-------------------+-----------------+--------------+
1:eac0369: 	| status | <fieldDataLength> | <overflow page> | <overflowID> |
1:eac0369: 	+--------+-------------------+-----------------+--------------+
1:eac0369: 
1:eac0369: 	</PRE>
1:eac0369: 	<BR><B>status</B><BR>
1:eac0369: 	The status is 1 byte, it indicates the state of the field.
1:eac0369: 
1:eac0369: 	A FieldHeader can be in the following states:
1:eac0369: 	NULL		- if the field is NULL, no field data length is stored
1:eac0369: 	OVERFLOW	- indicates the field has been overflowed to another page.
1:eac0369: 				  overflow page and overflow ID is stored at the end of the 
1:eac0369:                   user data. field data length must be a number greater or 
1:eac0369:                   equal to 0, indicating the length of the field that is stored
1:eac0369:                   on the current page.
1:eac0369: 
1:eac0369: 				  The format looks like this:
1:eac0369: 				  +--------+-----------------+---------------+------------+
1:eac0369: 				  |<status>|<fieldDataLength>|<overflow page>|<overflowID>|
1:eac0369: 				  +--------+-----------------+---------------+------------+
1:eac0369: 
1:eac0369: 				  overflowPage will be written as compressed long,
1:eac0369: 				  overflowId will be written as compressed Int
1:eac0369: 
1:eac0369: 	NONEXISTENT	- the field no longer exists, 
1:eac0369:                   e.g. column has been dropped during an alter table
1:eac0369: 
1:eac0369: 	EXTENSIBLE	- the field is of user defined data type.  
1:eac0369:                   The field may be tagged.
1:eac0369:                   
1:eac0369: 	TAGGED		- the field is TAGGED if and only if it is EXTENSIBLE.
1:eac0369: 
1:eac0369: 	FIXED		- the field is FIXED if and only if it is used in the log 
1:eac0369:                   records for version 1.2 and higher.
1:eac0369: 
1:eac0369: 	<BR><B>fieldDataLength</B><BR>
1:eac0369: 	The fieldDataLength is only set if the field is not NULL.  It is the length
1:eac0369:     of the field that is stored on the current page.
1:eac0369: 	The fieldDataLength is a variable length CompressedInt.
1:eac0369: 	<BR><B>overflowPage and overflowID</B><BR>
1:eac0369: 	The overflowPage is a variable length CompressedLong, overflowID is a 
1:eac0369:     variable Length CompressedInt.
1:eac0369: 	They are only stored when the field state is OVERFLOW.
1:eac0369: 	And they are not stored in the field header.
1:eac0369: 	Instead, they are stored at the end of the field data.
1:eac0369: 	The reason we do that is to save a copy if the field has to overflow.
1:eac0369: 
1:eac0369: 	<BR> MT - Mutable - Immutable identity - Thread Aware
1:eac0369: */
1:eac0369: public final class StoredFieldHeader
1:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constants of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     // DO NOT use 0x80, some code reads byte into an int without masking the
1:eac0369:     // sign bit, so do not use the high bit in the byte for a field status.
1:eac0369: 	private		static final int FIELD_INITIAL		= 0x00;
1:eac0369: 	public		static final int FIELD_NULL			= 0x01;
1:eac0369: 	public		static final int FIELD_OVERFLOW		= 0x02;
1:eac0369: 	private		static final int FIELD_NOT_NULLABLE	= 0x04;
1:eac0369: 	public		static final int FIELD_EXTENSIBLE	= 0x08;
1:eac0369: 	public		static final int FIELD_TAGGED		= 0x10;
1:eac0369: 	protected	static final int FIELD_FIXED		= 0x20;
1:eac0369: 
1:eac0369: 	public		static final int FIELD_NONEXISTENT	= (FIELD_NOT_NULLABLE | FIELD_NULL);
1:eac0369: 
1:eac0369: 
1:eac0369:     public static final int    STORED_FIELD_HEADER_STATUS_SIZE = 1;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Get accessors for testing bits in the status field.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the status of the field
1:eac0369: 
1:eac0369: 		<BR> MT - single thread required
1:eac0369: 	*/
1:eac0369: 	public static final boolean isNull(int status) {
1:eac0369: 		return ((status & FIELD_NULL) == FIELD_NULL);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isOverflow(int status) {
1:eac0369: 		return ((status & FIELD_OVERFLOW) == FIELD_OVERFLOW);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isNonexistent(int status) {
1:eac0369: 		return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isExtensible(int status) {
1:eac0369: 		return ((status & FIELD_EXTENSIBLE) == FIELD_EXTENSIBLE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isNullorNonExistent(int status) {
1:eac0369:         // just need to check whether null bit is set.
1:eac0369:         // return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
1:eac0369: 		return ((status & FIELD_NULL) != 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isTagged(int status) {
1:eac0369: 		//		if (SanityManager.DEBUG)
1:eac0369: 		//			SanityManager.ASSERT(isExtensible(status), "a field cannot be tagged if it is not extensible");
1:eac0369: 		return ((status & FIELD_TAGGED) == FIELD_TAGGED);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isFixed(int status) {
1:eac0369: 		return ((status & FIELD_FIXED) == FIELD_FIXED);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final boolean isNullable(int status) {
1:eac0369: 		return ((status & FIELD_NOT_NULLABLE) == 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final int size(
1:eac0369:     int status, 
1:eac0369:     int fieldDataLength, 
1:eac0369:     int fieldDataSize) 
1:eac0369:     {
1:eac0369: 
1:eac0369:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:eac0369:         {
1:eac0369:             // usual case - not-null, not-fixed
1:eac0369: 
1:eac0369:             // WARNING - the following code hand inlined from 
1:eac0369:             // CompressedNumber for performance.
1:eac0369:             //
1:eac0369:             // return(CompressedNumber.sizeInt(fieldDataLength) + 1);
1:eac0369:             //
1:eac0369: 
1:eac0369:             if (fieldDataLength <= 
1:eac0369:                         CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE)
1:eac0369:             {
1:eac0369:                 // compressed form is 1 byte
1:eac0369:                 return(2);
1:eac0369:             }
1:eac0369:             else if (fieldDataLength <= 
1:eac0369:                         CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES)
1:eac0369:             {
1:eac0369:                 // compressed form is 2 bytes
1:eac0369:                 return(3);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // compressed form is 4 bytes
1:eac0369:                 return(5);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else if ((status & FIELD_NULL) != 0)
1:eac0369:         {
1:eac0369:             // field is null
1:eac0369: 
1:eac0369: 			return(1);
1:eac0369: 		} 
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // fixed length field
1:eac0369: 
1:eac0369:             return((fieldDataSize > 2) ? 5 : 3);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Set accessors for setting bits in the status field.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	public final static int setInitial() {
1:eac0369: 		return FIELD_INITIAL;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setNull(int status, boolean isNull) {
1:eac0369: 		if (isNull)
1:eac0369: 			status |= FIELD_NULL;
1:eac0369: 		else
1:eac0369: 			status &= ~FIELD_NULL;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setOverflow(int status, boolean isOverflow) {
1:eac0369: 		if (isOverflow)
1:eac0369: 			status |= FIELD_OVERFLOW;
1:eac0369: 		else
1:eac0369: 			status &= ~FIELD_OVERFLOW;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setNonexistent(int status) {
1:eac0369: 		status |= FIELD_NONEXISTENT;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setExtensible(int status, boolean isExtensible) {
1:eac0369: 		if (isExtensible)
1:eac0369: 			status |= FIELD_EXTENSIBLE;
1:eac0369: 		else
1:eac0369: 			status &= ~FIELD_EXTENSIBLE;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setTagged(int status, boolean isTagged) {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isExtensible(status),
1:eac0369: 				"a field cannot be set to tagged if it is not extensible");
1:eac0369: 
1:eac0369: 		if (isTagged)
1:eac0369: 			status |= FIELD_TAGGED;
1:eac0369: 		else
1:eac0369: 			status &= ~FIELD_TAGGED;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final static int setFixed(int status, boolean isFixed) {
1:eac0369: 		if (isFixed)
1:eac0369: 			status |= FIELD_FIXED;
1:eac0369: 		else
1:eac0369: 			status &= ~FIELD_FIXED;
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * routines used to write a field header to a OutputStream
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		write out the field status and field data Length
1:eac0369: 
1:eac0369: 		@exception IOException Thrown by potential I/O errors while writing 
1:eac0369:                                field header.
1:eac0369: 	 */
1:eac0369: 	public static final int write(
1:eac0369:     OutputStream out, 
1:eac0369:     int status, 
1:eac0369:     int fieldDataLength, 
1:eac0369:     int fieldDataSize)
1:eac0369: 		throws IOException 
1:eac0369:     {
1:eac0369: 		int len = 1;
1:eac0369: 
1:eac0369: 		out.write(status);
1:eac0369: 
1:eac0369: 		if (isNull(status))
1:eac0369: 			return len;
1:eac0369: 
1:eac0369: 		if (isFixed(status)) 
1:eac0369:         {
1:eac0369: 			// if the field header is for log, we write it in compressed format,
1:eac0369: 			// then we pad the field, so the total length is fixed.			
1:eac0369:   			if (fieldDataSize > 2) 
1:eac0369:             {
1:eac0369: 				int diffLen = 
1:eac0369:                     fieldDataSize - 
1:eac0369:                     CompressedNumber.writeInt(out, fieldDataLength);
1:eac0369: 
1:eac0369: 				for (int i = diffLen; i > 0; i--)
1:eac0369: 					out.write(0);
1:eac0369: 				len += fieldDataSize;	// size of an int - 4 bytes
1:eac0369: 			} 
1:eac0369:             else 
1:eac0369:             {
1:eac0369: 				// write the int out as a short
1:eac0369: 				out.write((fieldDataLength >>> 8) & 0xFF);
1:eac0369: 				out.write((fieldDataLength >>> 0) & 0xFF);
1:eac0369: 				len += 2;	// size of a short - 2 bytes
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// NOTE: fixed version is used for logs only,
1:eac0369: 			// the overflow information is stored at the end of the optional 
1:eac0369:             // data, not in the field headers.  
1:eac0369:             // That's why we are not writing overflow info here.
1:eac0369: 
1:eac0369: 		} 
1:eac0369:         else 
1:eac0369:         {
1:eac0369: 			// if we are writing the fieldHeader for the page, 
1:eac0369:             // we write in compressed format
1:eac0369: 
1:eac0369: 			len += CompressedNumber.writeInt(out, fieldDataLength);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return len;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * routines used to read a field header from an ObjectInput stream, array
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		read the field status
1:eac0369: 
1:eac0369: 		@exception IOException Thrown by potential I/O errors while reading 
1:eac0369:                                field header.
1:eac0369: 	 */
1:eac0369: 	public static final int readStatus(ObjectInput in) 
1:eac0369:         throws IOException 
1:eac0369:     {
1:eac0369: 		int status;
1:eac0369: 
1:eac0369: 		if ((status = in.read()) >= 0)
1:eac0369:             return status;
1:eac0369:         else
1:eac0369: 			throw new EOFException();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final int readStatus(
1:eac0369:     byte[]      page,
1:eac0369:     int         offset)
1:eac0369:     {
1:eac0369:         return(page[offset]);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:20bc69f:      * read the length of the field and hdr.
1:eac0369:      * <p>
1:eac0369:      * Optimized routine used to skip a field on a page.  It returns the
1:eac0369:      * total length of the field including the header portion.  It operates
1:eac0369:      * directly on the array and does no checking of it's own for limits on
1:eac0369:      * the array length, so an array out of bounds exception may be thrown - 
1:eac0369:      * the routine is meant to be used to read a field from a page so this
1:eac0369:      * should not happen.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The length of the field on the page, including it's header.
1:eac0369:      *
1:eac0369:      * @param data      the array where the field is. 
1:eac0369:      * @param offset    the offset in the array where the field begin, ie. 
1:eac0369:      *                  the status byte is at data[offset].
1:eac0369:      *
1:f668d94:      * @exception IOException if an I/O error occurs
1:eac0369:      **/
1:eac0369: 	public static final int readTotalFieldLength(
1:eac0369:     byte[]      data,
1:eac0369:     int         offset)
1:eac0369: 			throws IOException 
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             // this routine is meant to be called on the page, and FIXED fields
1:eac0369:             // are only used in the log.
1:eac0369: 
1:eac0369:             if (isFixed(data[offset]))
1:eac0369:                 SanityManager.THROWASSERT("routine does not handle FIXED.");
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (((data[offset++]) & FIELD_NULL) != FIELD_NULL)
1:eac0369:         {
1:eac0369:             int value = data[offset];
1:eac0369: 
1:eac0369:             if ((value & ~0x3f) == 0)
1:eac0369:             {
1:eac0369:                 // length is stored in this byte, we also know that the 0x80 bit
1:eac0369:                 // was not set, so no need to mask off the sign extension from
1:eac0369:                 // the byte to int conversion.
1:eac0369: 
1:eac0369:                 // account for 1 byte stored length of field + 1 for status.
1:eac0369:                 return(value + 2);
1:eac0369:             }
1:eac0369:             else if ((value & 0x80) == 0)
1:eac0369:             {
1:eac0369:                 // length stored in 2 bytes. only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 2 byte length is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was not set, so no need to mask off 
1:eac0369:                 // the sign extension from the 1st byte to int conversion.  Need
1:eac0369:                 // to mask the byte in data[offset + 1] to account for possible
1:eac0369:                 // sign extension.
1:eac0369: 
1:eac0369:                 // add 3 to account for 2 byte length + 1 for status
1:eac0369: 
1:eac0369:                 return((((value & 0x3f) << 8) | (data[offset + 1] & 0xff)) + 3);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // length stored in 4 bytes.  only use low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 4 byte length is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:                 // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:eac0369:                 // account for possible sign extension.
1:eac0369: 
1:eac0369: 
1:eac0369:                 // add 5 to account for 4 byte length + 1 added to all returns
1:eac0369:                 return(
1:eac0369:                     (((value            & 0x7f) << 24) |
1:eac0369:                      ((data[offset + 1] & 0xff) << 16) |
1:eac0369:                      ((data[offset + 2] & 0xff) <<  8) |
1:eac0369:                       (data[offset + 3] & 0xff)) + 5);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(1);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public static final int readFieldLengthAndSetStreamPosition(
1:eac0369:     byte[]              data,
1:eac0369:     int                 offset,
1:eac0369:     int                 status,
1:eac0369:     int                 fieldDataSize,
1:eac0369:     ArrayInputStream    ais)
1:eac0369: 			throws IOException 
1:eac0369:     {
1:eac0369:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:eac0369:         {
1:eac0369:             // usual case-not null, not fixed.  Length stored as compressed int.
1:eac0369:             //   return(CompressedNumber.readInt(in));
1:eac0369: 
1:eac0369:             int value = data[offset++];
1:eac0369: 
1:eac0369:             if ((value & ~0x3f) == 0)
1:eac0369:             {
1:eac0369:                 // usual case.
1:eac0369: 
1:eac0369:                 // length is stored in this byte, we also know that the 0x80 bit
1:eac0369:                 // was not set, so no need to mask off the sign extension from
1:eac0369:                 // the byte to int conversion.
1:eac0369: 
1:eac0369:                 // nothing to do, value already has int to return. 
1:eac0369: 
1:eac0369:             }
1:eac0369:             else if ((value & 0x80) == 0)
1:eac0369:             {
1:eac0369:                 // length is stored in 2 bytes.  use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 2 byte length is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was not set, so no need to mask off 
1:eac0369:                 // the sign extension from the 1st byte to int conversion.  
1:eac0369:                 // Need to mask the byte in data[offset + 1] to account for 
1:eac0369:                 // possible sign extension.
1:eac0369: 
1:eac0369:                 value = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
1:eac0369: 
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // length is stored in 4 bytes.  only low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 4 byte length is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:                 // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:eac0369:                 // account for possible sign extension.
1:eac0369: 
1:eac0369: 
1:eac0369:                 // add 5 to account for 4 byte length + 1 added to all returns
1:eac0369:                 value = 
1:eac0369:                     (((value          & 0x7f) << 24) |
1:eac0369:                      ((data[offset++] & 0xff) << 16) |
1:eac0369:                      ((data[offset++] & 0xff) <<  8) |
1:eac0369:                       (data[offset++] & 0xff));
1:eac0369:             }
1:eac0369: 
1:eac0369:             ais.setPosition(offset);
1:eac0369: 
1:eac0369:             return(value);
1:eac0369:         }
1:eac0369:         else if ((status & FIELD_NULL) != 0)
1:eac0369:         {
1:eac0369:             ais.setPosition(offset);
1:eac0369:             return(0);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             int fieldDataLength;
1:eac0369: 
1:eac0369:             // field data length is in a fixed size field, not compressed.
1:eac0369: 
1:eac0369:             if (fieldDataSize <= 2)
1:eac0369:             {
1:eac0369:                 // read it in as short, because it was written out as short
1:eac0369:                 fieldDataLength = 
1:eac0369:                     ((data[offset++] & 0xff) << 8) | (data[offset++] & 0xff);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // fieldDataLength = CompressedNumber.readInt(in);
1:eac0369: 
1:eac0369:                 fieldDataLength = data[offset];
1:eac0369: 
1:eac0369:                 if ((fieldDataLength & ~0x3f) == 0)
1:eac0369:                 {
1:eac0369:                     // usual case.
1:eac0369: 
1:eac0369:                     // length is stored in this byte, we also know that the 0x80
1:eac0369:                     // bit was not set, so no need to mask off the sign 
1:eac0369:                     // extension from the byte to int conversion.
1:eac0369: 
1:eac0369:                     // nothing to do, fieldDataLength already has int to return.
1:eac0369: 
1:eac0369:                 }
1:eac0369:                 else if ((fieldDataLength & 0x80) == 0)
1:eac0369:                 {
1:eac0369:                     // len is stored in 2 bytes.  use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         SanityManager.ASSERT((fieldDataLength & 0x40) == 0x40);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     // top 8 bits of 2 byte length is stored in this byte, we 
1:eac0369:                     // also know that the 0x80 bit was not set, so no need to 
1:eac0369:                     // mask off the sign extension from the 1st byte to int 
1:eac0369:                     // conversion.  Need to mask the byte in data[offset + 1] to
1:eac0369:                     // account for possible sign extension.
1:eac0369: 
1:eac0369:                     fieldDataLength = 
1:eac0369:                         (((fieldDataLength & 0x3f) << 8) | 
1:eac0369:                          (data[offset + 1] & 0xff));
1:eac0369: 
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // len is stored in 4 bytes.  only low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         SanityManager.ASSERT((fieldDataLength & 0x80) == 0x80);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     // top 8 bits of 4 byte length is stored in this byte, we 
1:eac0369:                     // also know that the 0x80 bit was set, so need to mask off
1:eac0369:                     // the sign extension from the 1st byte to int conversion.  
1:eac0369:                     // Need to mask the bytes from the next 3 bytes 
1:eac0369:                     // data[offset + 1,2,3] to account for possible sign 
1:eac0369:                     // extension.
1:eac0369: 
1:eac0369:                     fieldDataLength = 
1:eac0369:                         (((fieldDataLength  & 0x7f) << 24) |
1:eac0369:                          ((data[offset + 1] & 0xff) << 16) |
1:eac0369:                          ((data[offset + 2] & 0xff) <<  8) |
1:eac0369:                           (data[offset + 3] & 0xff));
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 offset = offset + fieldDataSize;
1:eac0369:             } 
1:eac0369: 
1:eac0369:             ais.setPosition(offset);
1:eac0369:             return(fieldDataLength);
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		read the field data length
1:eac0369: 
1:eac0369: 		@exception IOException Thrown by potential I/O errors while reading 
1:eac0369:                                field header.
1:eac0369: 	 */
1:eac0369: 	public static final int readFieldDataLength(
1:eac0369:     ObjectInput in, 
1:eac0369:     int status, 
1:eac0369:     int fieldDataSize)
1:eac0369: 			throws IOException 
1:eac0369:     {
1:eac0369: 		
1:eac0369:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:eac0369:         {
1:eac0369:             // usual case-not null, not fixed.  Length stored as compressed int.
1:eac0369:             return(CompressedNumber.readInt(in));
1:eac0369:         }
1:eac0369:         else if ((status & FIELD_NULL) != 0)
1:eac0369:         {
1:eac0369:             // field is null or non-existent.
1:eac0369:             return(0);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             int fieldDataLength;
1:eac0369: 
1:eac0369:             // field data length is in a fixed size field, not compressed.
1:eac0369: 
1:eac0369:             if (fieldDataSize <= 2)
1:eac0369:             {
1:eac0369:                 // read it in as short, because it was written out as short
1:eac0369:                 int ch1 = in.read();
1:eac0369:                 int ch2 = in.read();
1:eac0369:                 if ((ch1 | ch2) < 0)
1:eac0369:                      throw new EOFException();
1:eac0369: 
1:eac0369:                 fieldDataLength = ((ch1 << 8) + (ch2 << 0));
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 fieldDataLength = 
1:eac0369:                     CompressedNumber.readInt(in);
1:eac0369: 
1:eac0369:                 int diffLen = 
1:eac0369:                     fieldDataSize - 
1:eac0369:                     CompressedNumber.sizeInt(fieldDataLength);
1:eac0369: 
1:eac0369:                 if (diffLen != 0)
1:a5d378d:                     DataInputUtil.skipFully(in, diffLen);
1:eac0369:             } 
1:eac0369: 
1:eac0369:             return(fieldDataLength);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public static String toDebugString(int status)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			StringBuffer str = new StringBuffer(100);
1:eac0369: 			if (isNull(status)) str.append("Null ");
1:eac0369: 			if (isOverflow(status)) str.append("Overflow ");
1:eac0369: 			if (isNonexistent(status)) str.append("Nonexistent ");
1:eac0369: 			if (isExtensible(status)) str.append("Extensible ");
1:eac0369: 			if (isTagged(status)) str.append("Tagged ");
1:eac0369: 			if (isFixed(status)) str.append("Fixed ");
1:eac0369: 			if (isNullable(status)) str.append("Nullable ");
1:eac0369: 			if (str.length() == 0)
1:eac0369: 				str.append("INITIAL ");
1:eac0369: 
1:eac0369: 			return str.toString();
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception IOException if an I/O error occurs
commit:a5d378d
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.DataInputUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:                     DataInputUtil.skipFully(in, diffLen);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1:      * read the length of the field and hdr.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.StoredFieldHeader
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import java.io.IOException;
1: import java.io.EOFException;
1: 
1: import java.io.ObjectInput;
1: import java.io.OutputStream;
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.CompressedNumber;
1: 
0: import java.io.InputStream;
1: 
1: /**
1:     A class to provide static methods to manipulate fields in the field header.
1: 
1: 	A class StoredPage uses to read/write field status and field data length.
1: 	No attributes exist in this class, this class provides a set of static
1: 	methods for writing field status and field data length, and for reading
1: 	field status and field data length.
1: 
1: 	<P><B>Stored Field Header Format</B><BR>
1: 	The field header is broken into two sections.  
1:     Only the Status byte is required to be there.
1: 	<PRE>
1: 	Field header format:
1: 	+--------+-------------------+
1: 	| status | <fieldDataLength> |
1: 	+--------+-------------------+
1: 	Overflow page and overflow id are stored as field data.
1: 	If the overflow bit in status is set, the field data is the overflow 
1:     information.  When the overflow bit is not set in status, then,
1: 	fieldData is the actually user data for the field.
1: 	That means, field header consists only field status, and field data length.
1: 
1: 	A non-overflow field:
1: 	+--------+-------------------+-------------+
1: 	| status | <fieldDataLength> | <fieldData> |
1: 	+--------+-------------------+-------------+
1: 
1: 	An overflow field:
1: 	+--------+-------------------+-----------------+--------------+
1: 	| status | <fieldDataLength> | <overflow page> | <overflowID> |
1: 	+--------+-------------------+-----------------+--------------+
1: 
1: 	</PRE>
1: 	<BR><B>status</B><BR>
1: 	The status is 1 byte, it indicates the state of the field.
1: 
1: 	A FieldHeader can be in the following states:
1: 	NULL		- if the field is NULL, no field data length is stored
1: 	OVERFLOW	- indicates the field has been overflowed to another page.
1: 				  overflow page and overflow ID is stored at the end of the 
1:                   user data. field data length must be a number greater or 
1:                   equal to 0, indicating the length of the field that is stored
1:                   on the current page.
1: 
1: 				  The format looks like this:
1: 				  +--------+-----------------+---------------+------------+
1: 				  |<status>|<fieldDataLength>|<overflow page>|<overflowID>|
1: 				  +--------+-----------------+---------------+------------+
1: 
1: 				  overflowPage will be written as compressed long,
1: 				  overflowId will be written as compressed Int
1: 
1: 	NONEXISTENT	- the field no longer exists, 
1:                   e.g. column has been dropped during an alter table
1: 
1: 	EXTENSIBLE	- the field is of user defined data type.  
1:                   The field may be tagged.
1:                   
1: 	TAGGED		- the field is TAGGED if and only if it is EXTENSIBLE.
1: 
1: 	FIXED		- the field is FIXED if and only if it is used in the log 
1:                   records for version 1.2 and higher.
1: 
1: 	<BR><B>fieldDataLength</B><BR>
1: 	The fieldDataLength is only set if the field is not NULL.  It is the length
1:     of the field that is stored on the current page.
1: 	The fieldDataLength is a variable length CompressedInt.
1: 	<BR><B>overflowPage and overflowID</B><BR>
1: 	The overflowPage is a variable length CompressedLong, overflowID is a 
1:     variable Length CompressedInt.
1: 	They are only stored when the field state is OVERFLOW.
1: 	And they are not stored in the field header.
1: 	Instead, they are stored at the end of the field data.
1: 	The reason we do that is to save a copy if the field has to overflow.
1: 
1: 	<BR> MT - Mutable - Immutable identity - Thread Aware
1: */
1: public final class StoredFieldHeader
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
1:     /**************************************************************************
1:      * Constants of the class
1:      **************************************************************************
1:      */
1: 
1:     // DO NOT use 0x80, some code reads byte into an int without masking the
1:     // sign bit, so do not use the high bit in the byte for a field status.
1: 	private		static final int FIELD_INITIAL		= 0x00;
1: 	public		static final int FIELD_NULL			= 0x01;
1: 	public		static final int FIELD_OVERFLOW		= 0x02;
1: 	private		static final int FIELD_NOT_NULLABLE	= 0x04;
1: 	public		static final int FIELD_EXTENSIBLE	= 0x08;
1: 	public		static final int FIELD_TAGGED		= 0x10;
1: 	protected	static final int FIELD_FIXED		= 0x20;
1: 
1: 	public		static final int FIELD_NONEXISTENT	= (FIELD_NOT_NULLABLE | FIELD_NULL);
1: 
1: 
1:     public static final int    STORED_FIELD_HEADER_STATUS_SIZE = 1;
1: 
1:     /**************************************************************************
1:      * Get accessors for testing bits in the status field.
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 		Get the status of the field
1: 
1: 		<BR> MT - single thread required
1: 	*/
1: 	public static final boolean isNull(int status) {
1: 		return ((status & FIELD_NULL) == FIELD_NULL);
1: 	}
1: 
1: 	public static final boolean isOverflow(int status) {
1: 		return ((status & FIELD_OVERFLOW) == FIELD_OVERFLOW);
1: 	}
1: 
1: 	public static final boolean isNonexistent(int status) {
1: 		return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
1: 	}
1: 
1: 	public static final boolean isExtensible(int status) {
1: 		return ((status & FIELD_EXTENSIBLE) == FIELD_EXTENSIBLE);
1: 	}
1: 
1: 	public static final boolean isNullorNonExistent(int status) {
1:         // just need to check whether null bit is set.
1:         // return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
1: 		return ((status & FIELD_NULL) != 0);
1: 	}
1: 
1: 	public static final boolean isTagged(int status) {
1: 		//		if (SanityManager.DEBUG)
1: 		//			SanityManager.ASSERT(isExtensible(status), "a field cannot be tagged if it is not extensible");
1: 		return ((status & FIELD_TAGGED) == FIELD_TAGGED);
1: 	}
1: 
1: 	public static final boolean isFixed(int status) {
1: 		return ((status & FIELD_FIXED) == FIELD_FIXED);
1: 	}
1: 
1: 	public static final boolean isNullable(int status) {
1: 		return ((status & FIELD_NOT_NULLABLE) == 0);
1: 	}
1: 
1: 	public static final int size(
1:     int status, 
1:     int fieldDataLength, 
1:     int fieldDataSize) 
1:     {
1: 
1:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:         {
1:             // usual case - not-null, not-fixed
1: 
1:             // WARNING - the following code hand inlined from 
1:             // CompressedNumber for performance.
1:             //
1:             // return(CompressedNumber.sizeInt(fieldDataLength) + 1);
1:             //
1: 
1:             if (fieldDataLength <= 
1:                         CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE)
1:             {
1:                 // compressed form is 1 byte
1:                 return(2);
1:             }
1:             else if (fieldDataLength <= 
1:                         CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES)
1:             {
1:                 // compressed form is 2 bytes
1:                 return(3);
1:             }
1:             else
1:             {
1:                 // compressed form is 4 bytes
1:                 return(5);
1:             }
1:         }
1:         else if ((status & FIELD_NULL) != 0)
1:         {
1:             // field is null
1: 
1: 			return(1);
1: 		} 
1:         else
1:         {
1:             // fixed length field
1: 
1:             return((fieldDataSize > 2) ? 5 : 3);
1: 		}
1: 	}
1: 
1: 
1:     /**************************************************************************
1:      * Set accessors for setting bits in the status field.
1:      **************************************************************************
1:      */
1: 
1: 	public final static int setInitial() {
1: 		return FIELD_INITIAL;
1: 	}
1: 
1: 	public final static int setNull(int status, boolean isNull) {
1: 		if (isNull)
1: 			status |= FIELD_NULL;
1: 		else
1: 			status &= ~FIELD_NULL;
1: 		return status;
1: 	}
1: 
1: 	public final static int setOverflow(int status, boolean isOverflow) {
1: 		if (isOverflow)
1: 			status |= FIELD_OVERFLOW;
1: 		else
1: 			status &= ~FIELD_OVERFLOW;
1: 		return status;
1: 	}
1: 
1: 	public final static int setNonexistent(int status) {
1: 		status |= FIELD_NONEXISTENT;
1: 		return status;
1: 	}
1: 
1: 	public final static int setExtensible(int status, boolean isExtensible) {
1: 		if (isExtensible)
1: 			status |= FIELD_EXTENSIBLE;
1: 		else
1: 			status &= ~FIELD_EXTENSIBLE;
1: 		return status;
1: 	}
1: 
1: 	public final static int setTagged(int status, boolean isTagged) {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isExtensible(status),
1: 				"a field cannot be set to tagged if it is not extensible");
1: 
1: 		if (isTagged)
1: 			status |= FIELD_TAGGED;
1: 		else
1: 			status &= ~FIELD_TAGGED;
1: 		return status;
1: 	}
1: 
1: 	public final static int setFixed(int status, boolean isFixed) {
1: 		if (isFixed)
1: 			status |= FIELD_FIXED;
1: 		else
1: 			status &= ~FIELD_FIXED;
1: 		return status;
1: 	}
1: 
1:     /**************************************************************************
1:      * routines used to write a field header to a OutputStream
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 		write out the field status and field data Length
1: 
1: 		@exception IOException Thrown by potential I/O errors while writing 
1:                                field header.
1: 	 */
1: 	public static final int write(
1:     OutputStream out, 
1:     int status, 
1:     int fieldDataLength, 
1:     int fieldDataSize)
1: 		throws IOException 
1:     {
1: 		int len = 1;
1: 
1: 		out.write(status);
1: 
1: 		if (isNull(status))
1: 			return len;
1: 
1: 		if (isFixed(status)) 
1:         {
1: 			// if the field header is for log, we write it in compressed format,
1: 			// then we pad the field, so the total length is fixed.			
1:   			if (fieldDataSize > 2) 
1:             {
1: 				int diffLen = 
1:                     fieldDataSize - 
1:                     CompressedNumber.writeInt(out, fieldDataLength);
1: 
1: 				for (int i = diffLen; i > 0; i--)
1: 					out.write(0);
1: 				len += fieldDataSize;	// size of an int - 4 bytes
1: 			} 
1:             else 
1:             {
1: 				// write the int out as a short
1: 				out.write((fieldDataLength >>> 8) & 0xFF);
1: 				out.write((fieldDataLength >>> 0) & 0xFF);
1: 				len += 2;	// size of a short - 2 bytes
1: 			}
1: 
1: 			// NOTE: fixed version is used for logs only,
1: 			// the overflow information is stored at the end of the optional 
1:             // data, not in the field headers.  
1:             // That's why we are not writing overflow info here.
1: 
1: 		} 
1:         else 
1:         {
1: 			// if we are writing the fieldHeader for the page, 
1:             // we write in compressed format
1: 
1: 			len += CompressedNumber.writeInt(out, fieldDataLength);
1: 		}
1: 
1: 		return len;
1: 	}
1: 
1:     /**************************************************************************
1:      * routines used to read a field header from an ObjectInput stream, array
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 		read the field status
1: 
1: 		@exception IOException Thrown by potential I/O errors while reading 
1:                                field header.
1: 	 */
1: 	public static final int readStatus(ObjectInput in) 
1:         throws IOException 
1:     {
1: 		int status;
1: 
1: 		if ((status = in.read()) >= 0)
1:             return status;
1:         else
1: 			throw new EOFException();
1: 	}
1: 
1: 	public static final int readStatus(
1:     byte[]      page,
1:     int         offset)
1:     {
1:         return(page[offset]);
1:     }
1: 
1:     /**
0:      * read the length of the field and hdr
1:      * <p>
1:      * Optimized routine used to skip a field on a page.  It returns the
1:      * total length of the field including the header portion.  It operates
1:      * directly on the array and does no checking of it's own for limits on
1:      * the array length, so an array out of bounds exception may be thrown - 
1:      * the routine is meant to be used to read a field from a page so this
1:      * should not happen.
1:      * <p>
1:      *
1: 	 * @return The length of the field on the page, including it's header.
1:      *
1:      * @param data      the array where the field is. 
1:      * @param offset    the offset in the array where the field begin, ie. 
1:      *                  the status byte is at data[offset].
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public static final int readTotalFieldLength(
1:     byte[]      data,
1:     int         offset)
1: 			throws IOException 
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             // this routine is meant to be called on the page, and FIXED fields
1:             // are only used in the log.
1: 
1:             if (isFixed(data[offset]))
1:                 SanityManager.THROWASSERT("routine does not handle FIXED.");
1:         }
1: 
1:         if (((data[offset++]) & FIELD_NULL) != FIELD_NULL)
1:         {
1:             int value = data[offset];
1: 
1:             if ((value & ~0x3f) == 0)
1:             {
1:                 // length is stored in this byte, we also know that the 0x80 bit
1:                 // was not set, so no need to mask off the sign extension from
1:                 // the byte to int conversion.
1: 
1:                 // account for 1 byte stored length of field + 1 for status.
1:                 return(value + 2);
1:             }
1:             else if ((value & 0x80) == 0)
1:             {
1:                 // length stored in 2 bytes. only use low 6 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:                 }
1: 
1:                 // top 8 bits of 2 byte length is stored in this byte, we also 
1:                 // know that the 0x80 bit was not set, so no need to mask off 
1:                 // the sign extension from the 1st byte to int conversion.  Need
1:                 // to mask the byte in data[offset + 1] to account for possible
1:                 // sign extension.
1: 
1:                 // add 3 to account for 2 byte length + 1 for status
1: 
1:                 return((((value & 0x3f) << 8) | (data[offset + 1] & 0xff)) + 3);
1:             }
1:             else
1:             {
1:                 // length stored in 4 bytes.  only use low 7 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:                 }
1: 
1:                 // top 8 bits of 4 byte length is stored in this byte, we also 
1:                 // know that the 0x80 bit was set, so need to mask off the 
1:                 // sign extension from the 1st byte to int conversion.  Need to
1:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:                 // account for possible sign extension.
1: 
1: 
1:                 // add 5 to account for 4 byte length + 1 added to all returns
1:                 return(
1:                     (((value            & 0x7f) << 24) |
1:                      ((data[offset + 1] & 0xff) << 16) |
1:                      ((data[offset + 2] & 0xff) <<  8) |
1:                       (data[offset + 3] & 0xff)) + 5);
1:             }
1:         }
1:         else
1:         {
1:             return(1);
1:         }
1: 	}
1: 
1: 
1: 	public static final int readFieldLengthAndSetStreamPosition(
1:     byte[]              data,
1:     int                 offset,
1:     int                 status,
1:     int                 fieldDataSize,
1:     ArrayInputStream    ais)
1: 			throws IOException 
1:     {
1:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:         {
1:             // usual case-not null, not fixed.  Length stored as compressed int.
1:             //   return(CompressedNumber.readInt(in));
1: 
1:             int value = data[offset++];
1: 
1:             if ((value & ~0x3f) == 0)
1:             {
1:                 // usual case.
1: 
1:                 // length is stored in this byte, we also know that the 0x80 bit
1:                 // was not set, so no need to mask off the sign extension from
1:                 // the byte to int conversion.
1: 
1:                 // nothing to do, value already has int to return. 
1: 
1:             }
1:             else if ((value & 0x80) == 0)
1:             {
1:                 // length is stored in 2 bytes.  use low 6 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:                 }
1: 
1:                 // top 8 bits of 2 byte length is stored in this byte, we also 
1:                 // know that the 0x80 bit was not set, so no need to mask off 
1:                 // the sign extension from the 1st byte to int conversion.  
1:                 // Need to mask the byte in data[offset + 1] to account for 
1:                 // possible sign extension.
1: 
1:                 value = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
1: 
1:             }
1:             else
1:             {
1:                 // length is stored in 4 bytes.  only low 7 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:                 }
1: 
1:                 // top 8 bits of 4 byte length is stored in this byte, we also 
1:                 // know that the 0x80 bit was set, so need to mask off the 
1:                 // sign extension from the 1st byte to int conversion.  Need to
1:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:                 // account for possible sign extension.
1: 
1: 
1:                 // add 5 to account for 4 byte length + 1 added to all returns
1:                 value = 
1:                     (((value          & 0x7f) << 24) |
1:                      ((data[offset++] & 0xff) << 16) |
1:                      ((data[offset++] & 0xff) <<  8) |
1:                       (data[offset++] & 0xff));
1:             }
1: 
1:             ais.setPosition(offset);
1: 
1:             return(value);
1:         }
1:         else if ((status & FIELD_NULL) != 0)
1:         {
1:             ais.setPosition(offset);
1:             return(0);
1:         }
1:         else
1:         {
1:             int fieldDataLength;
1: 
1:             // field data length is in a fixed size field, not compressed.
1: 
1:             if (fieldDataSize <= 2)
1:             {
1:                 // read it in as short, because it was written out as short
1:                 fieldDataLength = 
1:                     ((data[offset++] & 0xff) << 8) | (data[offset++] & 0xff);
1:             }
1:             else
1:             {
1:                 // fieldDataLength = CompressedNumber.readInt(in);
1: 
1:                 fieldDataLength = data[offset];
1: 
1:                 if ((fieldDataLength & ~0x3f) == 0)
1:                 {
1:                     // usual case.
1: 
1:                     // length is stored in this byte, we also know that the 0x80
1:                     // bit was not set, so no need to mask off the sign 
1:                     // extension from the byte to int conversion.
1: 
1:                     // nothing to do, fieldDataLength already has int to return.
1: 
1:                 }
1:                 else if ((fieldDataLength & 0x80) == 0)
1:                 {
1:                     // len is stored in 2 bytes.  use low 6 bits from 1st byte.
1: 
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.ASSERT((fieldDataLength & 0x40) == 0x40);
1:                     }
1: 
1:                     // top 8 bits of 2 byte length is stored in this byte, we 
1:                     // also know that the 0x80 bit was not set, so no need to 
1:                     // mask off the sign extension from the 1st byte to int 
1:                     // conversion.  Need to mask the byte in data[offset + 1] to
1:                     // account for possible sign extension.
1: 
1:                     fieldDataLength = 
1:                         (((fieldDataLength & 0x3f) << 8) | 
1:                          (data[offset + 1] & 0xff));
1: 
1:                 }
1:                 else
1:                 {
1:                     // len is stored in 4 bytes.  only low 7 bits from 1st byte.
1: 
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.ASSERT((fieldDataLength & 0x80) == 0x80);
1:                     }
1: 
1:                     // top 8 bits of 4 byte length is stored in this byte, we 
1:                     // also know that the 0x80 bit was set, so need to mask off
1:                     // the sign extension from the 1st byte to int conversion.  
1:                     // Need to mask the bytes from the next 3 bytes 
1:                     // data[offset + 1,2,3] to account for possible sign 
1:                     // extension.
1: 
1:                     fieldDataLength = 
1:                         (((fieldDataLength  & 0x7f) << 24) |
1:                          ((data[offset + 1] & 0xff) << 16) |
1:                          ((data[offset + 2] & 0xff) <<  8) |
1:                           (data[offset + 3] & 0xff));
1:                 }
1: 
1:                 offset = offset + fieldDataSize;
1:             } 
1: 
1:             ais.setPosition(offset);
1:             return(fieldDataLength);
1:         }
1: 
1: 
1: 	}
1: 
1: 	/**
1: 		read the field data length
1: 
1: 		@exception IOException Thrown by potential I/O errors while reading 
1:                                field header.
1: 	 */
1: 	public static final int readFieldDataLength(
1:     ObjectInput in, 
1:     int status, 
1:     int fieldDataSize)
1: 			throws IOException 
1:     {
1: 		
1:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
1:         {
1:             // usual case-not null, not fixed.  Length stored as compressed int.
1:             return(CompressedNumber.readInt(in));
1:         }
1:         else if ((status & FIELD_NULL) != 0)
1:         {
1:             // field is null or non-existent.
1:             return(0);
1:         }
1:         else
1:         {
1:             int fieldDataLength;
1: 
1:             // field data length is in a fixed size field, not compressed.
1: 
1:             if (fieldDataSize <= 2)
1:             {
1:                 // read it in as short, because it was written out as short
1:                 int ch1 = in.read();
1:                 int ch2 = in.read();
1:                 if ((ch1 | ch2) < 0)
1:                      throw new EOFException();
1: 
1:                 fieldDataLength = ((ch1 << 8) + (ch2 << 0));
1:             }
1:             else
1:             {
1:                 fieldDataLength = 
1:                     CompressedNumber.readInt(in);
1: 
1:                 int diffLen = 
1:                     fieldDataSize - 
1:                     CompressedNumber.sizeInt(fieldDataLength);
1: 
1:                 if (diffLen != 0)
0:                     in.skipBytes(diffLen);
1:             } 
1: 
1:             return(fieldDataLength);
1:         }
1: 	}
1: 
1: 
1: 	public static String toDebugString(int status)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			StringBuffer str = new StringBuffer(100);
1: 			if (isNull(status)) str.append("Null ");
1: 			if (isOverflow(status)) str.append("Overflow ");
1: 			if (isNonexistent(status)) str.append("Nonexistent ");
1: 			if (isExtensible(status)) str.append("Extensible ");
1: 			if (isTagged(status)) str.append("Tagged ");
1: 			if (isFixed(status)) str.append("Fixed ");
1: 			if (isNullable(status)) str.append("Nullable ");
1: 			if (str.length() == 0)
1: 				str.append("INITIAL ");
1: 
1: 			return str.toString();
1: 		}
1: 		return null;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.io.IOException;
0: import java.io.EOFException;
0: 
0: import java.io.ObjectInput;
0: import java.io.OutputStream;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.CompressedNumber;
0: 
0: import java.io.InputStream;
0: 
0: /**
0:     A class to provide static methods to manipulate fields in the field header.
0: 
0: 	A class StoredPage uses to read/write field status and field data length.
0: 	No attributes exist in this class, this class provides a set of static
0: 	methods for writing field status and field data length, and for reading
0: 	field status and field data length.
0: 
0: 	<P><B>Stored Field Header Format</B><BR>
0: 	The field header is broken into two sections.  
0:     Only the Status byte is required to be there.
0: 	<PRE>
0: 	Field header format:
0: 	+--------+-------------------+
0: 	| status | <fieldDataLength> |
0: 	+--------+-------------------+
0: 	Overflow page and overflow id are stored as field data.
0: 	If the overflow bit in status is set, the field data is the overflow 
0:     information.  When the overflow bit is not set in status, then,
0: 	fieldData is the actually user data for the field.
0: 	That means, field header consists only field status, and field data length.
0: 
0: 	A non-overflow field:
0: 	+--------+-------------------+-------------+
0: 	| status | <fieldDataLength> | <fieldData> |
0: 	+--------+-------------------+-------------+
0: 
0: 	An overflow field:
0: 	+--------+-------------------+-----------------+--------------+
0: 	| status | <fieldDataLength> | <overflow page> | <overflowID> |
0: 	+--------+-------------------+-----------------+--------------+
0: 
0: 	</PRE>
0: 	<BR><B>status</B><BR>
0: 	The status is 1 byte, it indicates the state of the field.
0: 
0: 	A FieldHeader can be in the following states:
0: 	NULL		- if the field is NULL, no field data length is stored
0: 	OVERFLOW	- indicates the field has been overflowed to another page.
0: 				  overflow page and overflow ID is stored at the end of the 
0:                   user data. field data length must be a number greater or 
0:                   equal to 0, indicating the length of the field that is stored
0:                   on the current page.
0: 
0: 				  The format looks like this:
0: 				  +--------+-----------------+---------------+------------+
0: 				  |<status>|<fieldDataLength>|<overflow page>|<overflowID>|
0: 				  +--------+-----------------+---------------+------------+
0: 
0: 				  overflowPage will be written as compressed long,
0: 				  overflowId will be written as compressed Int
0: 
0: 	NONEXISTENT	- the field no longer exists, 
0:                   e.g. column has been dropped during an alter table
0: 
0: 	EXTENSIBLE	- the field is of user defined data type.  
0:                   The field may be tagged.
0:                   
0: 	TAGGED		- the field is TAGGED if and only if it is EXTENSIBLE.
0: 
0: 	FIXED		- the field is FIXED if and only if it is used in the log 
0:                   records for version 1.2 and higher.
0: 
0: 	<BR><B>fieldDataLength</B><BR>
0: 	The fieldDataLength is only set if the field is not NULL.  It is the length
0:     of the field that is stored on the current page.
0: 	The fieldDataLength is a variable length CompressedInt.
0: 	<BR><B>overflowPage and overflowID</B><BR>
0: 	The overflowPage is a variable length CompressedLong, overflowID is a 
0:     variable Length CompressedInt.
0: 	They are only stored when the field state is OVERFLOW.
0: 	And they are not stored in the field header.
0: 	Instead, they are stored at the end of the field data.
0: 	The reason we do that is to save a copy if the field has to overflow.
0: 
0: 	<BR> MT - Mutable - Immutable identity - Thread Aware
0: */
0: public final class StoredFieldHeader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0:     /**************************************************************************
0:      * Constants of the class
0:      **************************************************************************
0:      */
0: 
0:     // DO NOT use 0x80, some code reads byte into an int without masking the
0:     // sign bit, so do not use the high bit in the byte for a field status.
0: 	private		static final int FIELD_INITIAL		= 0x00;
0: 	public		static final int FIELD_NULL			= 0x01;
0: 	public		static final int FIELD_OVERFLOW		= 0x02;
0: 	private		static final int FIELD_NOT_NULLABLE	= 0x04;
0: 	public		static final int FIELD_EXTENSIBLE	= 0x08;
0: 	public		static final int FIELD_TAGGED		= 0x10;
0: 	protected	static final int FIELD_FIXED		= 0x20;
0: 
0: 	public		static final int FIELD_NONEXISTENT	= (FIELD_NOT_NULLABLE | FIELD_NULL);
0: 
0: 
0:     public static final int    STORED_FIELD_HEADER_STATUS_SIZE = 1;
0: 
0:     /**************************************************************************
0:      * Get accessors for testing bits in the status field.
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 		Get the status of the field
0: 
0: 		<BR> MT - single thread required
0: 	*/
0: 	public static final boolean isNull(int status) {
0: 		return ((status & FIELD_NULL) == FIELD_NULL);
0: 	}
0: 
0: 	public static final boolean isOverflow(int status) {
0: 		return ((status & FIELD_OVERFLOW) == FIELD_OVERFLOW);
0: 	}
0: 
0: 	public static final boolean isNonexistent(int status) {
0: 		return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
0: 	}
0: 
0: 	public static final boolean isExtensible(int status) {
0: 		return ((status & FIELD_EXTENSIBLE) == FIELD_EXTENSIBLE);
0: 	}
0: 
0: 	public static final boolean isNullorNonExistent(int status) {
0:         // just need to check whether null bit is set.
0:         // return ((status & FIELD_NONEXISTENT) == FIELD_NONEXISTENT);
0: 		return ((status & FIELD_NULL) != 0);
0: 	}
0: 
0: 	public static final boolean isTagged(int status) {
0: 		//		if (SanityManager.DEBUG)
0: 		//			SanityManager.ASSERT(isExtensible(status), "a field cannot be tagged if it is not extensible");
0: 		return ((status & FIELD_TAGGED) == FIELD_TAGGED);
0: 	}
0: 
0: 	public static final boolean isFixed(int status) {
0: 		return ((status & FIELD_FIXED) == FIELD_FIXED);
0: 	}
0: 
0: 	public static final boolean isNullable(int status) {
0: 		return ((status & FIELD_NOT_NULLABLE) == 0);
0: 	}
0: 
0: 	public static final int size(
0:     int status, 
0:     int fieldDataLength, 
0:     int fieldDataSize) 
0:     {
0: 
0:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
0:         {
0:             // usual case - not-null, not-fixed
0: 
0:             // WARNING - the following code hand inlined from 
0:             // CompressedNumber for performance.
0:             //
0:             // return(CompressedNumber.sizeInt(fieldDataLength) + 1);
0:             //
0: 
0:             if (fieldDataLength <= 
0:                         CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE)
0:             {
0:                 // compressed form is 1 byte
0:                 return(2);
0:             }
0:             else if (fieldDataLength <= 
0:                         CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES)
0:             {
0:                 // compressed form is 2 bytes
0:                 return(3);
0:             }
0:             else
0:             {
0:                 // compressed form is 4 bytes
0:                 return(5);
0:             }
0:         }
0:         else if ((status & FIELD_NULL) != 0)
0:         {
0:             // field is null
0: 
0: 			return(1);
0: 		} 
0:         else
0:         {
0:             // fixed length field
0: 
0:             return((fieldDataSize > 2) ? 5 : 3);
0: 		}
0: 	}
0: 
0: 
0:     /**************************************************************************
0:      * Set accessors for setting bits in the status field.
0:      **************************************************************************
0:      */
0: 
0: 	public final static int setInitial() {
0: 		return FIELD_INITIAL;
0: 	}
0: 
0: 	public final static int setNull(int status, boolean isNull) {
0: 		if (isNull)
0: 			status |= FIELD_NULL;
0: 		else
0: 			status &= ~FIELD_NULL;
0: 		return status;
0: 	}
0: 
0: 	public final static int setOverflow(int status, boolean isOverflow) {
0: 		if (isOverflow)
0: 			status |= FIELD_OVERFLOW;
0: 		else
0: 			status &= ~FIELD_OVERFLOW;
0: 		return status;
0: 	}
0: 
0: 	public final static int setNonexistent(int status) {
0: 		status |= FIELD_NONEXISTENT;
0: 		return status;
0: 	}
0: 
0: 	public final static int setExtensible(int status, boolean isExtensible) {
0: 		if (isExtensible)
0: 			status |= FIELD_EXTENSIBLE;
0: 		else
0: 			status &= ~FIELD_EXTENSIBLE;
0: 		return status;
0: 	}
0: 
0: 	public final static int setTagged(int status, boolean isTagged) {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isExtensible(status),
0: 				"a field cannot be set to tagged if it is not extensible");
0: 
0: 		if (isTagged)
0: 			status |= FIELD_TAGGED;
0: 		else
0: 			status &= ~FIELD_TAGGED;
0: 		return status;
0: 	}
0: 
0: 	public final static int setFixed(int status, boolean isFixed) {
0: 		if (isFixed)
0: 			status |= FIELD_FIXED;
0: 		else
0: 			status &= ~FIELD_FIXED;
0: 		return status;
0: 	}
0: 
0:     /**************************************************************************
0:      * routines used to write a field header to a OutputStream
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 		write out the field status and field data Length
0: 
0: 		@exception IOException Thrown by potential I/O errors while writing 
0:                                field header.
0: 	 */
0: 	public static final int write(
0:     OutputStream out, 
0:     int status, 
0:     int fieldDataLength, 
0:     int fieldDataSize)
0: 		throws IOException 
0:     {
0: 		int len = 1;
0: 
0: 		out.write(status);
0: 
0: 		if (isNull(status))
0: 			return len;
0: 
0: 		if (isFixed(status)) 
0:         {
0: 			// if the field header is for log, we write it in compressed format,
0: 			// then we pad the field, so the total length is fixed.			
0:   			if (fieldDataSize > 2) 
0:             {
0: 				int diffLen = 
0:                     fieldDataSize - 
0:                     CompressedNumber.writeInt(out, fieldDataLength);
0: 
0: 				for (int i = diffLen; i > 0; i--)
0: 					out.write(0);
0: 				len += fieldDataSize;	// size of an int - 4 bytes
0: 			} 
0:             else 
0:             {
0: 				// write the int out as a short
0: 				out.write((fieldDataLength >>> 8) & 0xFF);
0: 				out.write((fieldDataLength >>> 0) & 0xFF);
0: 				len += 2;	// size of a short - 2 bytes
0: 			}
0: 
0: 			// NOTE: fixed version is used for logs only,
0: 			// the overflow information is stored at the end of the optional 
0:             // data, not in the field headers.  
0:             // That's why we are not writing overflow info here.
0: 
0: 		} 
0:         else 
0:         {
0: 			// if we are writing the fieldHeader for the page, 
0:             // we write in compressed format
0: 
0: 			len += CompressedNumber.writeInt(out, fieldDataLength);
0: 		}
0: 
0: 		return len;
0: 	}
0: 
0:     /**************************************************************************
0:      * routines used to read a field header from an ObjectInput stream, array
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 		read the field status
0: 
0: 		@exception IOException Thrown by potential I/O errors while reading 
0:                                field header.
0: 	 */
0: 	public static final int readStatus(ObjectInput in) 
0:         throws IOException 
0:     {
0: 		int status;
0: 
0: 		if ((status = in.read()) >= 0)
0:             return status;
0:         else
0: 			throw new EOFException();
0: 	}
0: 
0: 	public static final int readStatus(
0:     byte[]      page,
0:     int         offset)
0:     {
0:         return(page[offset]);
0:     }
0: 
0:     /**
0:      * read the length of the field and hdr
0:      * <p>
0:      * Optimized routine used to skip a field on a page.  It returns the
0:      * total length of the field including the header portion.  It operates
0:      * directly on the array and does no checking of it's own for limits on
0:      * the array length, so an array out of bounds exception may be thrown - 
0:      * the routine is meant to be used to read a field from a page so this
0:      * should not happen.
0:      * <p>
0:      *
0: 	 * @return The length of the field on the page, including it's header.
0:      *
0:      * @param data      the array where the field is. 
0:      * @param offset    the offset in the array where the field begin, ie. 
0:      *                  the status byte is at data[offset].
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public static final int readTotalFieldLength(
0:     byte[]      data,
0:     int         offset)
0: 			throws IOException 
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             // this routine is meant to be called on the page, and FIXED fields
0:             // are only used in the log.
0: 
0:             if (isFixed(data[offset]))
0:                 SanityManager.THROWASSERT("routine does not handle FIXED.");
0:         }
0: 
0:         if (((data[offset++]) & FIELD_NULL) != FIELD_NULL)
0:         {
0:             int value = data[offset];
0: 
0:             if ((value & ~0x3f) == 0)
0:             {
0:                 // length is stored in this byte, we also know that the 0x80 bit
0:                 // was not set, so no need to mask off the sign extension from
0:                 // the byte to int conversion.
0: 
0:                 // account for 1 byte stored length of field + 1 for status.
0:                 return(value + 2);
0:             }
0:             else if ((value & 0x80) == 0)
0:             {
0:                 // length stored in 2 bytes. only use low 6 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x40) == 0x40);
0:                 }
0: 
0:                 // top 8 bits of 2 byte length is stored in this byte, we also 
0:                 // know that the 0x80 bit was not set, so no need to mask off 
0:                 // the sign extension from the 1st byte to int conversion.  Need
0:                 // to mask the byte in data[offset + 1] to account for possible
0:                 // sign extension.
0: 
0:                 // add 3 to account for 2 byte length + 1 for status
0: 
0:                 return((((value & 0x3f) << 8) | (data[offset + 1] & 0xff)) + 3);
0:             }
0:             else
0:             {
0:                 // length stored in 4 bytes.  only use low 7 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x80) == 0x80);
0:                 }
0: 
0:                 // top 8 bits of 4 byte length is stored in this byte, we also 
0:                 // know that the 0x80 bit was set, so need to mask off the 
0:                 // sign extension from the 1st byte to int conversion.  Need to
0:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
0:                 // account for possible sign extension.
0: 
0: 
0:                 // add 5 to account for 4 byte length + 1 added to all returns
0:                 return(
0:                     (((value            & 0x7f) << 24) |
0:                      ((data[offset + 1] & 0xff) << 16) |
0:                      ((data[offset + 2] & 0xff) <<  8) |
0:                       (data[offset + 3] & 0xff)) + 5);
0:             }
0:         }
0:         else
0:         {
0:             return(1);
0:         }
0: 	}
0: 
0: 
0: 	public static final int readFieldLengthAndSetStreamPosition(
0:     byte[]              data,
0:     int                 offset,
0:     int                 status,
0:     int                 fieldDataSize,
0:     ArrayInputStream    ais)
0: 			throws IOException 
0:     {
0:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
0:         {
0:             // usual case-not null, not fixed.  Length stored as compressed int.
0:             //   return(CompressedNumber.readInt(in));
0: 
0:             int value = data[offset++];
0: 
0:             if ((value & ~0x3f) == 0)
0:             {
0:                 // usual case.
0: 
0:                 // length is stored in this byte, we also know that the 0x80 bit
0:                 // was not set, so no need to mask off the sign extension from
0:                 // the byte to int conversion.
0: 
0:                 // nothing to do, value already has int to return. 
0: 
0:             }
0:             else if ((value & 0x80) == 0)
0:             {
0:                 // length is stored in 2 bytes.  use low 6 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x40) == 0x40);
0:                 }
0: 
0:                 // top 8 bits of 2 byte length is stored in this byte, we also 
0:                 // know that the 0x80 bit was not set, so no need to mask off 
0:                 // the sign extension from the 1st byte to int conversion.  
0:                 // Need to mask the byte in data[offset + 1] to account for 
0:                 // possible sign extension.
0: 
0:                 value = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
0: 
0:             }
0:             else
0:             {
0:                 // length is stored in 4 bytes.  only low 7 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x80) == 0x80);
0:                 }
0: 
0:                 // top 8 bits of 4 byte length is stored in this byte, we also 
0:                 // know that the 0x80 bit was set, so need to mask off the 
0:                 // sign extension from the 1st byte to int conversion.  Need to
0:                 // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
0:                 // account for possible sign extension.
0: 
0: 
0:                 // add 5 to account for 4 byte length + 1 added to all returns
0:                 value = 
0:                     (((value          & 0x7f) << 24) |
0:                      ((data[offset++] & 0xff) << 16) |
0:                      ((data[offset++] & 0xff) <<  8) |
0:                       (data[offset++] & 0xff));
0:             }
0: 
0:             ais.setPosition(offset);
0: 
0:             return(value);
0:         }
0:         else if ((status & FIELD_NULL) != 0)
0:         {
0:             ais.setPosition(offset);
0:             return(0);
0:         }
0:         else
0:         {
0:             int fieldDataLength;
0: 
0:             // field data length is in a fixed size field, not compressed.
0: 
0:             if (fieldDataSize <= 2)
0:             {
0:                 // read it in as short, because it was written out as short
0:                 fieldDataLength = 
0:                     ((data[offset++] & 0xff) << 8) | (data[offset++] & 0xff);
0:             }
0:             else
0:             {
0:                 // fieldDataLength = CompressedNumber.readInt(in);
0: 
0:                 fieldDataLength = data[offset];
0: 
0:                 if ((fieldDataLength & ~0x3f) == 0)
0:                 {
0:                     // usual case.
0: 
0:                     // length is stored in this byte, we also know that the 0x80
0:                     // bit was not set, so no need to mask off the sign 
0:                     // extension from the byte to int conversion.
0: 
0:                     // nothing to do, fieldDataLength already has int to return.
0: 
0:                 }
0:                 else if ((fieldDataLength & 0x80) == 0)
0:                 {
0:                     // len is stored in 2 bytes.  use low 6 bits from 1st byte.
0: 
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         SanityManager.ASSERT((fieldDataLength & 0x40) == 0x40);
0:                     }
0: 
0:                     // top 8 bits of 2 byte length is stored in this byte, we 
0:                     // also know that the 0x80 bit was not set, so no need to 
0:                     // mask off the sign extension from the 1st byte to int 
0:                     // conversion.  Need to mask the byte in data[offset + 1] to
0:                     // account for possible sign extension.
0: 
0:                     fieldDataLength = 
0:                         (((fieldDataLength & 0x3f) << 8) | 
0:                          (data[offset + 1] & 0xff));
0: 
0:                 }
0:                 else
0:                 {
0:                     // len is stored in 4 bytes.  only low 7 bits from 1st byte.
0: 
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         SanityManager.ASSERT((fieldDataLength & 0x80) == 0x80);
0:                     }
0: 
0:                     // top 8 bits of 4 byte length is stored in this byte, we 
0:                     // also know that the 0x80 bit was set, so need to mask off
0:                     // the sign extension from the 1st byte to int conversion.  
0:                     // Need to mask the bytes from the next 3 bytes 
0:                     // data[offset + 1,2,3] to account for possible sign 
0:                     // extension.
0: 
0:                     fieldDataLength = 
0:                         (((fieldDataLength  & 0x7f) << 24) |
0:                          ((data[offset + 1] & 0xff) << 16) |
0:                          ((data[offset + 2] & 0xff) <<  8) |
0:                           (data[offset + 3] & 0xff));
0:                 }
0: 
0:                 offset = offset + fieldDataSize;
0:             } 
0: 
0:             ais.setPosition(offset);
0:             return(fieldDataLength);
0:         }
0: 
0: 
0: 	}
0: 
0: 	/**
0: 		read the field data length
0: 
0: 		@exception IOException Thrown by potential I/O errors while reading 
0:                                field header.
0: 	 */
0: 	public static final int readFieldDataLength(
0:     ObjectInput in, 
0:     int status, 
0:     int fieldDataSize)
0: 			throws IOException 
0:     {
0: 		
0:         if ((status & (FIELD_NULL | FIELD_FIXED)) == 0)
0:         {
0:             // usual case-not null, not fixed.  Length stored as compressed int.
0:             return(CompressedNumber.readInt(in));
0:         }
0:         else if ((status & FIELD_NULL) != 0)
0:         {
0:             // field is null or non-existent.
0:             return(0);
0:         }
0:         else
0:         {
0:             int fieldDataLength;
0: 
0:             // field data length is in a fixed size field, not compressed.
0: 
0:             if (fieldDataSize <= 2)
0:             {
0:                 // read it in as short, because it was written out as short
0:                 int ch1 = in.read();
0:                 int ch2 = in.read();
0:                 if ((ch1 | ch2) < 0)
0:                      throw new EOFException();
0: 
0:                 fieldDataLength = ((ch1 << 8) + (ch2 << 0));
0:             }
0:             else
0:             {
0:                 fieldDataLength = 
0:                     CompressedNumber.readInt(in);
0: 
0:                 int diffLen = 
0:                     fieldDataSize - 
0:                     CompressedNumber.sizeInt(fieldDataLength);
0: 
0:                 if (diffLen != 0)
0:                     in.skipBytes(diffLen);
0:             } 
0: 
0:             return(fieldDataLength);
0:         }
0: 	}
0: 
0: 
0: 	public static String toDebugString(int status)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer str = new StringBuffer(100);
0: 			if (isNull(status)) str.append("Null ");
0: 			if (isOverflow(status)) str.append("Overflow ");
0: 			if (isNonexistent(status)) str.append("Nonexistent ");
0: 			if (isExtensible(status)) str.append("Extensible ");
0: 			if (isTagged(status)) str.append("Tagged ");
0: 			if (isFixed(status)) str.append("Fixed ");
0: 			if (isNullable(status)) str.append("Nullable ");
0: 			if (str.length() == 0)
0: 				str.append("INITIAL ");
0: 
0: 			return str.toString();
0: 		}
0: 		return null;
0: 	}
0: }
============================================================================