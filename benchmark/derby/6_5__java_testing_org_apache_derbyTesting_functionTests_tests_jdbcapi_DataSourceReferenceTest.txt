1:f7b3a7a: /*
41:f7b3a7a: 
1:f7b3a7a:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DataSourceReferenceTest
1:f7b3a7a: 
1:f7b3a7a:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f7b3a7a:    contributor license agreements.  See the NOTICE file distributed with
1:f7b3a7a:    this work for additional information regarding copyright ownership.
1:f7b3a7a:    The ASF licenses this file to You under the Apache License, Version 2.0
1:f7b3a7a:    (the "License"); you may not use this file except in compliance with
1:f7b3a7a:    the License.  You may obtain a copy of the License at
1:f7b3a7a: 
1:f7b3a7a:       http://www.apache.org/licenses/LICENSE-2.0
1:f7b3a7a: 
1:f7b3a7a:    Unless required by applicable law or agreed to in writing, software
1:f7b3a7a:    distributed under the License is distributed on an "AS IS" BASIS,
1:f7b3a7a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f7b3a7a:    See the License for the specific language governing permissions and
1:f7b3a7a:    limitations under the License.
1:f7b3a7a: 
1:f7b3a7a:  */
1:f7b3a7a: 
1:f7b3a7a: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:f7b3a7a: 
1:f7b3a7a: import java.io.ByteArrayInputStream;
1:f7b3a7a: import java.io.ByteArrayOutputStream;
1:f7b3a7a: import java.io.ObjectInputStream;
1:f7b3a7a: import java.io.ObjectOutputStream;
1:f7b3a7a: import java.lang.reflect.Method;
1:f7b3a7a: import java.util.ArrayList;
1:665f8d8: import java.util.Iterator;
1:665f8d8: import java.util.Properties;
1:f7b3a7a: import javax.naming.Reference;
1:f7b3a7a: import javax.naming.Referenceable;
1:f7b3a7a: import javax.naming.spi.ObjectFactory;
1:f7b3a7a: import junit.framework.Test;
1:f7b3a7a: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:f7b3a7a: import org.apache.derbyTesting.junit.J2EEDataSource;
1:f7b3a7a: import org.apache.derbyTesting.junit.JDBC;
1:f7b3a7a: import org.apache.derbyTesting.junit.JDBCDataSource;
1:f7b3a7a: import org.apache.derbyTesting.junit.TestConfiguration;
1:f7b3a7a: 
1:f7b3a7a: 
1:f7b3a7a: /**
1:665f8d8:  * Test obtaining a <code>javax.naming.Reference</code> from a Derby data
1:665f8d8:  * source and recreating a Derby data source from it.
1:665f8d8:  * <p>
1:665f8d8:  * Tests that the recreated value has the same value for all the properties
1:665f8d8:  * the data source supports. The list of properties is obtained
1:665f8d8:  * dynamically from the getter methods that return int, String, boolean,
1:665f8d8:  * short and long. Should Derby data sources support any other bean
1:665f8d8:  * property types then this test should be modified to pick them up and
1:665f8d8:  * handle them. The test will fail when such a property is added.
1:665f8d8:  * <p>
1:665f8d8:  * Default values of the properties are also tested. Default and set
1:665f8d8:  * values of the properties must be specified by creating a data source
1:665f8d8:  * descriptor.
1:665f8d8:  * <p>
1:f7b3a7a:  * At no point does this test attempt to connect using these data sources.
1:f7b3a7a:  */
1:665f8d8: public class DataSourceReferenceTest
1:665f8d8:         extends BaseJDBCTestCase {
1:f7b3a7a: 
1:665f8d8:     /** Lookup constant for the descriptor array. */
1:665f8d8:     private static final int BASE_DS = 0;
1:665f8d8:     /** Lookup constant for the descriptor array. */
1:665f8d8:     private static final int POOL_DS = 1;
1:665f8d8:     /** Lookup constant for the descriptor array. */
1:665f8d8:     private static final int XA_DS = 2;
1:665f8d8: 
1:665f8d8:     /** Descriptor for the basic embedded data source. */
1:665f8d8:     private static final DataSourceDescriptor BASE_EMBEDDED_DS =
1:665f8d8:             new DataSourceDescriptor("Basic embedded data source");
1:665f8d8: 
1:665f8d8:     static {
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("attributesAsPassword", "true", "false");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("connectionAttributes",
1:665f8d8:                                      "XX_connectionAttributes_2135");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("createDatabase", "create");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("dataSourceName",
1:665f8d8:                                      "XX_dataSourceName_1420");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("databaseName", "XX_databaseName_1206");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("description", "XX_description_1188");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("loginTimeout", "1280", "0");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("password", "XX_password_883");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("shutdownDatabase", "shutdown");
1:665f8d8:         BASE_EMBEDDED_DS.addProperty("user", "XX_user_447");
1:665f8d8:     }
1:665f8d8: 
1:665f8d8:     /** Descriptor for the basic client data source. */
1:665f8d8:     private static final DataSourceDescriptor BASE_CLIENT_DS =
1:665f8d8:             new DataSourceDescriptor("Basic client data source");
1:665f8d8: 
1:665f8d8:     static {
1:665f8d8:         // Properties with default values
1:665f8d8:         BASE_CLIENT_DS.addProperty("loginTimeout", "1280", "0");
1:665f8d8:         BASE_CLIENT_DS.addProperty("portNumber", "1070", "1527");
1:665f8d8:         BASE_CLIENT_DS.addProperty("retrieveMessageText", "false", "true");
1:665f8d8:         BASE_CLIENT_DS.addProperty("securityMechanism", "1851", "4");
1:665f8d8:         BASE_CLIENT_DS.addProperty("serverName", "tmpHostName", "localhost");
1:665f8d8:         BASE_CLIENT_DS.addProperty("ssl", "basic", "off");
1:665f8d8:         BASE_CLIENT_DS.addProperty("user", "XX_user_447", "APP");
1:665f8d8:         // Properties without default values.
1:665f8d8:         BASE_CLIENT_DS.addProperty("connectionAttributes",
1:665f8d8:                                    "XX_connectionAttributes_2135");
1:665f8d8:         BASE_CLIENT_DS.addProperty("createDatabase", "create");
1:665f8d8:         BASE_CLIENT_DS.addProperty("databaseName", "XX_databaseName_1206");
1:665f8d8:         BASE_CLIENT_DS.addProperty("dataSourceName", "XX_dataSourceName_1420");
1:665f8d8:         BASE_CLIENT_DS.addProperty("description", "XX_description_1188");
1:665f8d8:         BASE_CLIENT_DS.addProperty("password", "XX_password_883");
1:665f8d8:         BASE_CLIENT_DS.addProperty("shutdownDatabase", "shutdown");
1:665f8d8:         BASE_CLIENT_DS.addProperty("traceFile", "XX_traceFile_911");
1:665f8d8:         BASE_CLIENT_DS.addProperty("traceFileAppend", "true", "false");
1:665f8d8:         BASE_CLIENT_DS.addProperty("traceLevel", "1031", "-1");
1:665f8d8:         BASE_CLIENT_DS.addProperty("traceDirectory", "XX_traceDirectory_1476");
1:665f8d8:     }
1:665f8d8: 
1:d91d11e:     /** Descriptor for the client connection pool data source. */
1:d91d11e:     private static final DataSourceDescriptor POOL_CLIENT_DS =
1:d91d11e:             new DataSourceDescriptor("Connection pool client data source",
1:d91d11e:                                      BASE_CLIENT_DS);
1:d91d11e: 
1:d91d11e:     static {
1:d91d11e:         POOL_CLIENT_DS.addProperty("maxStatements", "10", "0");
1:d91d11e:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Creates a new fixture.
1:665f8d8:      *
1:665f8d8:      * @param name fixture name
1:665f8d8:      */
1:f7b3a7a:     public DataSourceReferenceTest(String name) {
1:f7b3a7a:         super(name);
1:a8d30d7:     }
1:665f8d8: 
1:f7b3a7a:     /**
1:665f8d8:      * Creates a suite with tests for both embedded and client data sources.
1:665f8d8:      *
1:665f8d8:      * @return A suite with the appropriate tests.
1:f7b3a7a:      */
1:665f8d8:     public static Test suite() {
1:665f8d8:        Test suite;
1:c35e4f0:        if (JDBC.vmSupportsJSR169() || !JDBC.vmSupportsJNDI()) {
1:c35e4f0:             // Referenceable is not supported with JSR169 or without JNDI
1:1ae02c9:             suite = new BaseTestSuite(
1:c35e4f0:                     "DatasourceReferenceTest cannot run with JSR169");
1:665f8d8:         } else {
1:665f8d8:             suite = TestConfiguration.defaultSuite(
1:665f8d8:                                                 DataSourceReferenceTest.class);
1:665f8d8:         }
1:665f8d8:        return suite;
16:f7b3a7a:     }
1:f7b3a7a: 
1:665f8d8:     /**
1:665f8d8:      * Tests a data source, with focus on serialization/deserialization.
1:665f8d8:      * <p>
1:665f8d8:      * For each data source, the following actions are performed:
1:665f8d8:      * <ol> <li>Create an empty data source from the class name.
1:665f8d8:      *      <li>Discover and validate the bean property list.
1:665f8d8:      *      <li>Create a reference and recreate the data source.
1:665f8d8:      *      <li>Compare the original and the empty recreated data source.
1:665f8d8:      *      <li>Serialize the data source and recreate.
1:665f8d8:      *      <li>Compare the original and the deserialized data source.
1:665f8d8:      *      <li>Set a value for every property of the data source.
1:665f8d8:      *      <li>Create a reference and recreate the data source.
1:665f8d8:      *      <li>Compare the populated original and the recreated data source.
1:665f8d8:      *      <li>Serialize the populated data source and recreate.
1:665f8d8:      *      <li>Compare the populated original and the deserialized data source.
1:665f8d8:      * </ol>
1:665f8d8:      *
1:665f8d8:      * @throws Exception on a wide variety of error conditions...
1:665f8d8:      */
1:665f8d8:     public void testDataSourceReference()
1:665f8d8:             throws Exception {
1:665f8d8:         DataSourceDescriptor[] descriptors;
1:665f8d8:         if (usingDerbyNetClient()) {
1:665f8d8:             // Specify client data source descriptors.
1:665f8d8:             descriptors = new DataSourceDescriptor[] {
1:665f8d8:                 BASE_CLIENT_DS, // Base
1:d91d11e:                 POOL_CLIENT_DS, // Pool
1:665f8d8:                 BASE_CLIENT_DS  // XA
1:665f8d8:             };
1:665f8d8:         } else {
1:665f8d8:             // Specify embedded data source descriptors.
1:665f8d8:             descriptors = new DataSourceDescriptor[] {
1:665f8d8:                 BASE_EMBEDDED_DS, // Base
1:665f8d8:                 BASE_EMBEDDED_DS, // Pool
1:665f8d8:                 BASE_EMBEDDED_DS  // XA
1:665f8d8:             };
1:f7b3a7a:         }
1:665f8d8:         // Test basic data source.
1:665f8d8:         String className = JDBCDataSource.getDataSource().getClass().getName();
1:665f8d8:         println("Testing base data source: " + className);
1:665f8d8:         assertDataSourceReference(descriptors[BASE_DS], className);
1:665f8d8: 
1:665f8d8:         // Test connection pool data source.
1:665f8d8:         className =
1:665f8d8:               J2EEDataSource.getConnectionPoolDataSource().getClass().getName();
1:665f8d8:         println("Testing connection pool data source: " + className);
1:665f8d8:         assertDataSourceReference(descriptors[POOL_DS], className);
1:665f8d8: 
1:665f8d8:         // Test XA data source.
1:665f8d8:         className = J2EEDataSource.getXADataSource().getClass().getName();
1:665f8d8:         println("Testing XA data source: " + className);
1:665f8d8:         assertDataSourceReference(descriptors[XA_DS], className);
1:665f8d8:     }
1:665f8d8: 
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Performs the test sequence in the data source.
1:665f8d8:      *
1:665f8d8:      * @param dsDesc data source descriptor
1:665f8d8:      * @param className class name of the data source
1:665f8d8:      * @throws Exception on a wide variety of error conditions...
1:665f8d8:      *
1:665f8d8:      * @see #testDataSourceReference
1:665f8d8:      */
1:665f8d8:     private void assertDataSourceReference(
1:665f8d8:                                         DataSourceDescriptor dsDesc,
1:665f8d8:                                         String className)
1:665f8d8:         throws Exception {
1:665f8d8:         // Instantiate a new data source object and get all its properties.
1:4469400:         Class<?> clazz = Class.forName(className);
1:4469400:         Object dsObj = clazz.getConstructor().newInstance();
1:665f8d8:         String[] properties = getPropertyBeanList(dsObj);
1:665f8d8:         // Validate property set (existence and naming).
1:665f8d8:         assertDataSourceProperties(dsDesc, properties);
1:665f8d8:         // Test recreating the data source
1:665f8d8:         assertDataSourceReferenceEmpty(dsDesc, className);
1:665f8d8:         assertDataSourceReferencePopulated(dsDesc, className);
1:665f8d8:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Asserts that the properties that are in the data source descriptor are
1:665f8d8:      * found in the list of data source properties, and that the data source
1:665f8d8:      * does not contain properties that are not in the descriptor.
1:665f8d8:      * <p>
1:665f8d8:      * No property values are verified in this assert method.
1:665f8d8:      *
1:665f8d8:      * @param dsDesc data source descriptor
1:665f8d8:      * @param properties list of actual data source properties
1:665f8d8:      */
1:665f8d8:     private void assertDataSourceProperties(
1:665f8d8:                                         DataSourceDescriptor dsDesc,
1:665f8d8:                                         String[] properties) {
1:665f8d8:         println("Testing data source bean properties.");
1:665f8d8:         // Validate the identified property names.
1:665f8d8:         for (int i=0; i < properties.length; i++) {
1:665f8d8:             assertTrue("Property '" + properties[i] + "' not in descriptor '" +
1:665f8d8:                     dsDesc.getName() + "'",
1:665f8d8:                     dsDesc.hasProperty(properties[i]));
1:f7b3a7a:         }
1:665f8d8:         // Check that all keys defined by the descriptor is found, and that
1:665f8d8:         // there is only one of each in the data source property list.
1:665f8d8:         Iterator descPropIter = dsDesc.getPropertyIterator();
1:665f8d8:         while (descPropIter.hasNext()) {
1:665f8d8:             String descProp = (String)descPropIter.next();
1:665f8d8:             boolean match = false;
1:665f8d8:             // Iterate through all the data source properties.
1:665f8d8:             for (int i=0; i < properties.length; i++) {
1:665f8d8:                 if (properties[i].equals(descProp)) {
1:665f8d8:                     if (match) {
1:665f8d8:                         fail("Duplicate entry '" + descProp + "' in data " +
1:665f8d8:                                 "source property list");
1:665f8d8:                     }
1:665f8d8:                     // Don't break, continue to look for duplicates.
1:665f8d8:                     match = true;
1:665f8d8:                 }
1:665f8d8:             }
1:665f8d8:             assertTrue("Property '" + descProp + "' not found in data source " +
1:665f8d8:                     "property list", match);
1:665f8d8:         }
1:665f8d8:         // Check if the expected number of properties are found.
1:665f8d8:         // Do this last to hopefully get a more descriptive failure
1:665f8d8:         // message which includes the property name above.
1:665f8d8:         assertEquals(dsDesc.getPropertyCount(), properties.length);
1:665f8d8:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Make sure it is possible to create a new data source using
1:665f8d8:      * <code>Referencable</code>, that the new instance has the correct
1:665f8d8:      * default values set for the bean properties and finally that the
1:665f8d8:      * data source can be serialized/deserialized.
1:665f8d8:      *
1:665f8d8:      * @param dsDesc data source descriptor
1:665f8d8:      * @param className data source class name
1:665f8d8:      * @throws Exception on a wide variety of error conditions...
1:665f8d8:      */
1:665f8d8:     private void assertDataSourceReferenceEmpty(DataSourceDescriptor dsDesc,
1:665f8d8:                                                 String className)
1:665f8d8:             throws Exception {
1:665f8d8:         println("Testing recreated empty data source.");
1:665f8d8:         // Create an empty data source.
1:4469400:         Class<?> clazz = Class.forName(className);
1:4469400:         Object ds = clazz.getConstructor().newInstance();
1:665f8d8:         Referenceable refDs = (Referenceable)ds;
1:665f8d8:         Reference dsAsReference = refDs.getReference();
1:f7b3a7a:         String factoryClassName = dsAsReference.getFactoryClassName();
1:4469400:         clazz = Class.forName(factoryClassName);
1:665f8d8:         ObjectFactory factory =
1:4469400:             (ObjectFactory) clazz.getConstructor().newInstance();
1:665f8d8:         Object recreatedDs =
2:f7b3a7a:             factory.getObjectInstance(dsAsReference, null, null, null);
1:665f8d8:         // Empty, recreated data source should not be the same as the one we
1:665f8d8:         // created earlier on.
1:665f8d8:         assertNotNull("Recreated datasource is <null>", recreatedDs);
1:665f8d8:         assertNotSame(recreatedDs, ds);
1:665f8d8:         compareDataSources(dsDesc, ds, recreatedDs, true);
1:665f8d8: 
1:665f8d8:         // Serialize and recreate data source with default values.
1:f7b3a7a:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:665f8d8:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:f7b3a7a:         oos.writeObject(ds);
1:f7b3a7a:         oos.flush();
1:f7b3a7a:         oos.close();
1:665f8d8:         ByteArrayInputStream bais =
1:665f8d8:                 new ByteArrayInputStream(baos.toByteArray());
1:f7b3a7a:         ObjectInputStream ois = new ObjectInputStream(bais);
1:665f8d8:         recreatedDs = ois.readObject();
1:665f8d8:         compareDataSources(dsDesc, ds, recreatedDs, true);
1:665f8d8:     }
1:90f367e: 
1:665f8d8:     /**
1:665f8d8:      * Make sure it is possible to recreate and serialize/deserialize a
1:665f8d8:      * populated data source.
1:665f8d8:      * <p>
1:665f8d8:      * Populated means the various bean properties have non-default
1:665f8d8:      * values set.
1:665f8d8:      *
1:665f8d8:      * @param dsDesc data source descriptor
1:665f8d8:      * @param className data source class name
1:665f8d8:      * @throws Exception on a wide variety of error conditions...
1:665f8d8:      */
1:665f8d8:     private void assertDataSourceReferencePopulated(
1:665f8d8:                                                 DataSourceDescriptor dsDesc,
1:665f8d8:                                                 String className)
1:665f8d8:             throws Exception {
1:665f8d8:         println("Testing recreated populated data source.");
1:4469400:         Class<?> clazz = Class.forName(className);
1:4469400:         Object ds = clazz.getConstructor().newInstance();
1:665f8d8:         // Populate the data source.
1:665f8d8:         Iterator propIter = dsDesc.getPropertyIterator();
1:665f8d8:         while (propIter.hasNext()) {
1:665f8d8:             String property = (String)propIter.next();
1:665f8d8:             String value = dsDesc.getPropertyValue(property);
1:665f8d8:             Method getMethod = getGet(property, ds);
1:665f8d8:             Method setMethod = getSet(getMethod, ds);
1:665f8d8:             Class paramType = getMethod.getReturnType();
1:665f8d8: 
1:665f8d8:             if (paramType.equals(Integer.TYPE)) {
1:665f8d8:                 setMethod.invoke(ds, new Object[] {Integer.valueOf(value)});
1:665f8d8:             } else if (paramType.equals(String.class)) {
1:665f8d8:                 setMethod.invoke(ds, new Object[] {value});
1:665f8d8:             } else if (paramType.equals(Boolean.TYPE)) {
1:665f8d8:                 setMethod.invoke(ds, new Object[] {Boolean.valueOf(value)});
1:665f8d8:             } else if (paramType.equals(Short.TYPE)) {
1:665f8d8:                 setMethod.invoke(ds, new Object[] {Short.valueOf(value)});
1:665f8d8:             } else if (paramType.equals(Long.TYPE)) {
1:665f8d8:                 setMethod.invoke(ds, new Object[] {Long.valueOf(value)});
1:665f8d8:             } else {
1:665f8d8:                 fail("'" + property + "' not settable - update test!!");
1:665f8d8:             }
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         Referenceable refDs = (Referenceable)ds;
1:665f8d8:         Reference dsAsReference = refDs.getReference();
1:665f8d8:         String factoryClassName = dsAsReference.getFactoryClassName();
1:4469400:         clazz = Class.forName(factoryClassName);
1:665f8d8:         ObjectFactory factory =
1:4469400:             (ObjectFactory) clazz.getConstructor().newInstance();
1:665f8d8:         Object recreatedDs =
1:665f8d8:             factory.getObjectInstance(dsAsReference, null, null, null);
1:665f8d8:         // Recreated should not be same instance as original.
1:665f8d8:         assertNotSame(recreatedDs, ds);
1:665f8d8:         compareDataSources(dsDesc, ds, recreatedDs, false);
1:665f8d8: 
1:665f8d8:         // Serialize and recreate.
1:665f8d8:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:665f8d8:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:f7b3a7a:         oos.writeObject(ds);
1:f7b3a7a:         oos.flush();
1:f7b3a7a:         oos.close();
1:665f8d8:         ByteArrayInputStream bais =
1:665f8d8:                 new ByteArrayInputStream(baos.toByteArray());
1:665f8d8:         ObjectInputStream ois = new ObjectInputStream(bais);
1:665f8d8:         recreatedDs = ois.readObject();
1:665f8d8:         compareDataSources(dsDesc, ds, recreatedDs, false);
1:f7b3a7a:     }
1:f7b3a7a: 
1:665f8d8:     /**
1:665f8d8:      * Compares two data sources expected to be equal.
1:665f8d8:      * <p>
1:665f8d8:      * The data source descriptor is expected to contain both default values
1:665f8d8:      * and set values for the relevant bean properties of the data source(s).
1:665f8d8:      *
1:665f8d8:      * @param dsDesc data source descriptor
1:665f8d8:      * @param ds original data source
1:665f8d8:      * @param rds recreated data source
1:665f8d8:      * @param useDefaultsForComparison <code>true</code> if the default values
1:665f8d8:      *      should be verified, <code>false</code> if the set values should be
1:665f8d8:      *      used for verification
1:665f8d8:      * @throws Exception on a wide variety of error conditions...
1:665f8d8:      * @throws AssertionFailedError if the data sources are not equal
1:665f8d8:      */
1:665f8d8:     private void compareDataSources(DataSourceDescriptor dsDesc,
1:665f8d8:                                        Object ds, Object rds,
1:665f8d8:                                        boolean useDefaultsForComparison)
1:665f8d8:             throws Exception {
1:665f8d8:         Iterator propIter = dsDesc.getPropertyIterator();
1:665f8d8:         while (propIter.hasNext()) {
1:665f8d8:             String property = (String)propIter.next();
1:665f8d8:             Method getMethod = getGet(property, ds);
1:665f8d8: 
1:665f8d8:             // Obtain value from original data source, then the recreated one.
1:665f8d8:             Object dsValue = getMethod.invoke(ds, null);
1:665f8d8:             Object rdsValue = getMethod.invoke(rds, null);
1:665f8d8: 
1:665f8d8:             if (dsValue == null) {
1:665f8d8:                 assertNull(rdsValue);
1:665f8d8:             } else {
1:665f8d8:                 assertEquals(dsValue, rdsValue);
1:665f8d8:             }
1:665f8d8:             // Make sure the value is correct.
1:665f8d8:             if (useDefaultsForComparison) {
1:665f8d8:                 if (dsValue != null) {
1:665f8d8:                     assertEquals("Wrong default value for '" + property + "'",
1:665f8d8:                             dsDesc.getPropertyDefault(property),
1:665f8d8:                             dsValue.toString());
1:665f8d8:                 } else {
1:665f8d8:                     assertNull(dsDesc.getPropertyDefault(property));
1:665f8d8:                 }
1:665f8d8:             } else if (dsValue != null) {
1:665f8d8:                     assertEquals("'" + property + "' has incorrect value",
1:665f8d8:                             dsDesc.getPropertyValue(property),
1:665f8d8:                             dsValue.toString());
1:665f8d8:             } else {
1:665f8d8:                 // We got null from the data source, and we should have set all
1:665f8d8:                 // values to something else than null.
1:665f8d8:                 fail("Test does not handle this situation...");
1:665f8d8:             }
1:665f8d8:         }
1:665f8d8:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Obtains a list of bean properties through reflection.
1:665f8d8:      *
1:665f8d8:      * @param ds the data source to investigate
1:665f8d8:      * @return A list of bean property names.
1:665f8d8:      */
1:665f8d8:     private static String[] getPropertyBeanList(Object ds) {
1:665f8d8:         Method[] allMethods = ds.getClass().getMethods();
1:e18f54b:         ArrayList<String> properties = new ArrayList<String>();
1:665f8d8: 
1:665f8d8:         for (int i = 0; i < allMethods.length; i++) {
1:665f8d8:             Method method = allMethods[i];
1:665f8d8:             String methodName = method.getName();
1:665f8d8:             // Need at least getXX
1:665f8d8:             if (methodName.length() < 5 || !methodName.startsWith("get") ||
1:665f8d8:                     method.getParameterTypes().length != 0) {
1:665f8d8:                 continue;
1:665f8d8:             }
1:665f8d8: 
1:665f8d8:             Class rt = method.getReturnType();
1:665f8d8:             if (rt.equals(Integer.TYPE) || rt.equals(String.class) ||
1:665f8d8:                     rt.equals(Boolean.TYPE) || rt.equals(Short.TYPE) ||
1:665f8d8:                     rt.equals(Long.TYPE)) {
1:665f8d8:                 // Valid Java Bean property.
1:665f8d8:                 // Convert name:
1:665f8d8:                 //    getPassword -> password
1:665f8d8:                 //    getRetrieveMessageText -> retrieveMessageText
1:665f8d8:                 String beanName = methodName.substring(3,4).toLowerCase()
1:665f8d8:                         + methodName.substring(4);
1:f7b3a7a: 
1:f7b3a7a:                 properties.add(beanName);
1:665f8d8:             } else {
1:665f8d8:                 assertFalse("Method '" + methodName + "' with primitive " +
1:665f8d8:                     "return type not supported - update test!!",
1:665f8d8:                     rt.isPrimitive());
1:f7b3a7a:             }
1:f7b3a7a:         }
1:665f8d8: 
1:e18f54b:         return properties.toArray(new String[properties.size()]);
1:f7b3a7a:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * Obtains the specified get method.
1:665f8d8:      *
1:665f8d8:      * @param property property/method name
1:665f8d8:      * @param ds data source object
1:665f8d8:      * @return A method object.
1:665f8d8:      *
1:665f8d8:      * @throws NoSuchMethodException if the method does not exist
1:665f8d8:      */
1:665f8d8:     private static Method getGet(String property, Object ds)
1:665f8d8:             throws NoSuchMethodException {
1:f7b3a7a:         String methodName =
1:f7b3a7a:             "get" + property.substring(0,1).toUpperCase()
1:f7b3a7a:             + property.substring(1);
1:f7b3a7a:         Method m = ds.getClass().getMethod(methodName, null);
1:f7b3a7a:         return m;
1:f7b3a7a:     }
1:f7b3a7a: 
1:665f8d8:     /**
1:665f8d8:      * Obtains the specified set method.
1:665f8d8:      *
1:665f8d8:      * @param getMethod the corresponding get method
1:665f8d8:      * @param ds data source object
1:665f8d8:      * @return A method object.
1:665f8d8:      *
1:665f8d8:      * @throws NoSuchMethodException if the method does not exist
1:665f8d8:      */private static Method getSet(Method getMethod, Object ds)
1:665f8d8:             throws NoSuchMethodException {
1:f7b3a7a:         String methodName = "s" + getMethod.getName().substring(1);
1:f7b3a7a:         Method m = ds.getClass().getMethod(
1:f7b3a7a:             methodName, new Class[] {getMethod.getReturnType()});
1:f7b3a7a:         return m;
1:f7b3a7a:     }
1:665f8d8: 
1:665f8d8:     /**
1:665f8d8:      * A class describing the bean properties of a data source.
1:665f8d8:      * <p>
1:665f8d8:      * A data source is a class implementing
1:665f8d8:      * <code>javax.sql.CommonDataSource</code>.
1:665f8d8:      * <p>
1:665f8d8:      * The data source description consists of the following:
1:665f8d8:      * <ul> <li>A list of property names.
1:665f8d8:      *      <li>A list of default values for the properties that have a default.
1:665f8d8:      *      <li>A list of set values for properties.
1:665f8d8:      * </ul>
1:665f8d8:      * In addition it has a name for convenience.
1:665f8d8:      */
1:665f8d8:     private static class DataSourceDescriptor {
1:665f8d8: 
1:665f8d8:         /** Name of the description. */
1:665f8d8:         private final String dsName;
1:665f8d8:         /**
1:665f8d8:          * Set values for the data source being described.
1:665f8d8:          * <p>
1:665f8d8:          * Note that the keys of this property object describe which bean
1:665f8d8:          * properties exist for the data source.
1:665f8d8:          */
1:665f8d8:         private final Properties propertyValues;
1:665f8d8:         /**
1:665f8d8:          * Default values for bean properties having a default.
1:665f8d8:          * <p>
1:665f8d8:          * Note that not all properties have a default, and the data source
1:665f8d8:          * may therefore have more properties than there entries in this
1:665f8d8:          * list of properties.
1:665f8d8:          */
1:665f8d8:         private final Properties propertyDefaults;
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Creates a new data source description.
1:665f8d8:          *
1:665f8d8:          * @param dsName convenience name for the description/source
1:665f8d8:          */
1:665f8d8:         DataSourceDescriptor(String dsName) {
1:665f8d8:             this.dsName = dsName;
1:665f8d8:             this.propertyValues = new Properties();
1:665f8d8:             this.propertyDefaults = new Properties();
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Creates a new data source description, based off an existing
1:665f8d8:          * description.
1:665f8d8:          * <p>
1:665f8d8:          * All properties and values defined in the existing descriptor will
1:665f8d8:          * also be defined in the new descriptor.
1:665f8d8:          *
1:665f8d8:          * @param dsName convenience name for the description/source
1:665f8d8:          * @param copyFrom existing descriptor to copy properties/values from
1:665f8d8:          */
1:665f8d8:         DataSourceDescriptor(String dsName, DataSourceDescriptor copyFrom) {
1:665f8d8:             this.dsName = dsName;
1:665f8d8:             this.propertyValues = new Properties();
1:665f8d8:             this.propertyValues.putAll(copyFrom.propertyValues);
1:665f8d8:             this.propertyDefaults = new Properties(copyFrom.propertyDefaults);
1:665f8d8:             this.propertyDefaults.putAll(copyFrom.propertyDefaults);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Returns the convenience name of this descriptor.
1:665f8d8:          *
1:665f8d8:          * @return A convenience name.
1:665f8d8:          */
1:665f8d8:         String getName() {
1:665f8d8:             return this.dsName;
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Adds a property to the description, with a value and no associated
1:665f8d8:          * default value.
1:665f8d8:          *
1:665f8d8:          * @param name property name
1:665f8d8:          * @param value property value
1:665f8d8:          * @throws NullPointerException if <code>name</code> or
1:665f8d8:          *      <code>value</code> is <code>null</code>
1:665f8d8:          */
1:665f8d8:         void addProperty(String name, String value) {
1:665f8d8:             this.propertyValues.setProperty(name, value);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Adds a property to the description, with a value and an associated
1:665f8d8:          * default value.
1:665f8d8:          *
1:665f8d8:          * @param name property name
1:665f8d8:          * @param value property value
1:665f8d8:          * @param defaultValue default property value
1:665f8d8:          * @throws NullPointerException if <code>name</code>, <code>value</code>
1:665f8d8:          *      or <code>defaultValue</code> is <code>null</code>
1:665f8d8:          */
1:665f8d8:         void addProperty(String name, String value, String defaultValue) {
1:665f8d8:             this.propertyValues.setProperty(name, value);
1:665f8d8:             this.propertyDefaults.setProperty(name, defaultValue);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Returns the value of the specified property.
1:665f8d8:          *
1:665f8d8:          * @param name property name
1:665f8d8:          * @return The value set for this property.
1:665f8d8:          *
1:665f8d8:          * @throws NullPointerException if <code>name</code> is
1:665f8d8:          *      <code>null</code>
1:665f8d8:          * @throws AssertionFailedError if the property name is not defined by
1:665f8d8:          *      this descriptor
1:665f8d8:          */
1:665f8d8:         String getPropertyValue(String name) {
1:665f8d8:             if (!this.propertyValues.containsKey(name)) {
1:665f8d8:                 fail("Property '" + name + "' not in data source descriptor '" +
1:665f8d8:                         dsName + "'");
1:665f8d8:             }
1:665f8d8:             return this.propertyValues.getProperty(name);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Returns the default value for the specified property.
1:665f8d8:          *
1:665f8d8:          * @param name property name
1:665f8d8:          * @return The default value if specified, <code>null<code> if a default
1:665f8d8:          *      value is not specified.
1:665f8d8:          *
1:665f8d8:          * @throws NullPointerException if <code>name</code> is
1:665f8d8:          *      <code>null</code>
1:665f8d8:          * @throws AssertionFailedError if the property name is not defined by
1:665f8d8:          *      this descriptor
1:665f8d8:          */
1:665f8d8:         String getPropertyDefault(String name) {
1:665f8d8:             if (!this.propertyValues.containsKey(name)) {
1:665f8d8:                 fail("Property '" + name + "' not in data source descriptor '" +
1:665f8d8:                         dsName + "'");
1:665f8d8:             }
1:665f8d8:             return this.propertyDefaults.getProperty(name, null);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Returns an iterator over all bean property names.
1:665f8d8:          *
1:665f8d8:          * @return An iterator.
1:665f8d8:          */
1:665f8d8:         Iterator getPropertyIterator() {
1:665f8d8:             return this.propertyValues.keySet().iterator();
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Tells if the specified property is defined by this descriptor.
1:665f8d8:          *
1:665f8d8:          * @param name property name
1:665f8d8:          * @return <code>true</code> if defined, <code>false</code> if not.
1:665f8d8:          */
1:665f8d8:         boolean hasProperty(String name) {
1:665f8d8:             return this.propertyValues.containsKey(name);
1:665f8d8:         }
1:665f8d8: 
1:665f8d8:         /**
1:665f8d8:          * Returns the number of bean properties defined by this descriptor.
1:665f8d8:          *
1:665f8d8:          * @return The number of bean properties.
1:665f8d8:          */
1:665f8d8:         int getPropertyCount() {
1:665f8d8:             return this.propertyValues.size();
1:665f8d8:         }
1:665f8d8:     } // End class DataSourceDescriptor
1:f7b3a7a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName(className);
1:         Object dsObj = clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName(className);
1:         Object ds = clazz.getConstructor().newInstance();
1:         clazz = Class.forName(factoryClassName);
1:             (ObjectFactory) clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName(className);
1:         Object ds = clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         clazz = Class.forName(factoryClassName);
1:             (ObjectFactory) clazz.getConstructor().newInstance();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             suite = new BaseTestSuite(
commit:c35e4f0
/////////////////////////////////////////////////////////////////////////
1:        if (JDBC.vmSupportsJSR169() || !JDBC.vmSupportsJNDI()) {
1:             // Referenceable is not supported with JSR169 or without JNDI
0:             suite = new TestSuite(
1:                     "DatasourceReferenceTest cannot run with JSR169");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> properties = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         return properties.toArray(new String[properties.size()]);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d91d11e
/////////////////////////////////////////////////////////////////////////
1:     /** Descriptor for the client connection pool data source. */
1:     private static final DataSourceDescriptor POOL_CLIENT_DS =
1:             new DataSourceDescriptor("Connection pool client data source",
1:                                      BASE_CLIENT_DS);
1: 
1:     static {
1:         POOL_CLIENT_DS.addProperty("maxStatements", "10", "0");
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 POOL_CLIENT_DS, // Pool
commit:665f8d8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1:  * Test obtaining a <code>javax.naming.Reference</code> from a Derby data
1:  * source and recreating a Derby data source from it.
1:  * <p>
1:  * Tests that the recreated value has the same value for all the properties
1:  * the data source supports. The list of properties is obtained
1:  * dynamically from the getter methods that return int, String, boolean,
1:  * short and long. Should Derby data sources support any other bean
1:  * property types then this test should be modified to pick them up and
1:  * handle them. The test will fail when such a property is added.
1:  * <p>
1:  * Default values of the properties are also tested. Default and set
1:  * values of the properties must be specified by creating a data source
1:  * descriptor.
1:  * <p>
1: public class DataSourceReferenceTest
1:         extends BaseJDBCTestCase {
1:     /** Lookup constant for the descriptor array. */
1:     private static final int BASE_DS = 0;
1:     /** Lookup constant for the descriptor array. */
1:     private static final int POOL_DS = 1;
1:     /** Lookup constant for the descriptor array. */
1:     private static final int XA_DS = 2;
1: 
1:     /** Descriptor for the basic embedded data source. */
1:     private static final DataSourceDescriptor BASE_EMBEDDED_DS =
1:             new DataSourceDescriptor("Basic embedded data source");
1: 
1:     static {
1:         BASE_EMBEDDED_DS.addProperty("attributesAsPassword", "true", "false");
1:         BASE_EMBEDDED_DS.addProperty("connectionAttributes",
1:                                      "XX_connectionAttributes_2135");
1:         BASE_EMBEDDED_DS.addProperty("createDatabase", "create");
1:         BASE_EMBEDDED_DS.addProperty("dataSourceName",
1:                                      "XX_dataSourceName_1420");
1:         BASE_EMBEDDED_DS.addProperty("databaseName", "XX_databaseName_1206");
1:         BASE_EMBEDDED_DS.addProperty("description", "XX_description_1188");
1:         BASE_EMBEDDED_DS.addProperty("loginTimeout", "1280", "0");
1:         BASE_EMBEDDED_DS.addProperty("password", "XX_password_883");
1:         BASE_EMBEDDED_DS.addProperty("shutdownDatabase", "shutdown");
1:         BASE_EMBEDDED_DS.addProperty("user", "XX_user_447");
1:     }
1: 
1:     /** Descriptor for the basic client data source. */
1:     private static final DataSourceDescriptor BASE_CLIENT_DS =
1:             new DataSourceDescriptor("Basic client data source");
1: 
1:     static {
1:         // Properties with default values
1:         BASE_CLIENT_DS.addProperty("loginTimeout", "1280", "0");
1:         BASE_CLIENT_DS.addProperty("portNumber", "1070", "1527");
1:         BASE_CLIENT_DS.addProperty("retrieveMessageText", "false", "true");
1:         BASE_CLIENT_DS.addProperty("securityMechanism", "1851", "4");
1:         BASE_CLIENT_DS.addProperty("serverName", "tmpHostName", "localhost");
1:         BASE_CLIENT_DS.addProperty("ssl", "basic", "off");
1:         BASE_CLIENT_DS.addProperty("user", "XX_user_447", "APP");
1:         // Properties without default values.
1:         BASE_CLIENT_DS.addProperty("connectionAttributes",
1:                                    "XX_connectionAttributes_2135");
1:         BASE_CLIENT_DS.addProperty("createDatabase", "create");
1:         BASE_CLIENT_DS.addProperty("databaseName", "XX_databaseName_1206");
1:         BASE_CLIENT_DS.addProperty("dataSourceName", "XX_dataSourceName_1420");
1:         BASE_CLIENT_DS.addProperty("description", "XX_description_1188");
1:         BASE_CLIENT_DS.addProperty("password", "XX_password_883");
1:         BASE_CLIENT_DS.addProperty("shutdownDatabase", "shutdown");
1:         BASE_CLIENT_DS.addProperty("traceFile", "XX_traceFile_911");
1:         BASE_CLIENT_DS.addProperty("traceFileAppend", "true", "false");
1:         BASE_CLIENT_DS.addProperty("traceLevel", "1031", "-1");
1:         BASE_CLIENT_DS.addProperty("traceDirectory", "XX_traceDirectory_1476");
1:     }
1: 
1: 
1:     /**
1:      * Creates a new fixture.
1:      *
1:      * @param name fixture name
1:      */
1: 
1:      * Creates a suite with tests for both embedded and client data sources.
1:      *
1:      * @return A suite with the appropriate tests.
1:     public static Test suite() {
1:        Test suite;
0:        if (JDBC.vmSupportsJSR169()) {
0:             // Referenceable is not supported with JSR169
0:             suite = new TestSuite("DatasourceTest cannot run with JSR169");
1:         } else {
1:             suite = TestConfiguration.defaultSuite(
1:                                                 DataSourceReferenceTest.class);
1:         }
1:        return suite;
1:     /**
1:      * Tests a data source, with focus on serialization/deserialization.
1:      * <p>
1:      * For each data source, the following actions are performed:
1:      * <ol> <li>Create an empty data source from the class name.
1:      *      <li>Discover and validate the bean property list.
1:      *      <li>Create a reference and recreate the data source.
1:      *      <li>Compare the original and the empty recreated data source.
1:      *      <li>Serialize the data source and recreate.
1:      *      <li>Compare the original and the deserialized data source.
1:      *      <li>Set a value for every property of the data source.
1:      *      <li>Create a reference and recreate the data source.
1:      *      <li>Compare the populated original and the recreated data source.
1:      *      <li>Serialize the populated data source and recreate.
1:      *      <li>Compare the populated original and the deserialized data source.
1:      * </ol>
1:      *
1:      * @throws Exception on a wide variety of error conditions...
1:      */
1:     public void testDataSourceReference()
1:             throws Exception {
1:         DataSourceDescriptor[] descriptors;
1:         if (usingDerbyNetClient()) {
1:             // Specify client data source descriptors.
1:             descriptors = new DataSourceDescriptor[] {
1:                 BASE_CLIENT_DS, // Base
0:                 BASE_CLIENT_DS,   // Pool
1:                 BASE_CLIENT_DS  // XA
1:             };
1:         } else {
1:             // Specify embedded data source descriptors.
1:             descriptors = new DataSourceDescriptor[] {
1:                 BASE_EMBEDDED_DS, // Base
1:                 BASE_EMBEDDED_DS, // Pool
1:                 BASE_EMBEDDED_DS  // XA
1:             };
1:         // Test basic data source.
1:         String className = JDBCDataSource.getDataSource().getClass().getName();
1:         println("Testing base data source: " + className);
1:         assertDataSourceReference(descriptors[BASE_DS], className);
1: 
1:         // Test connection pool data source.
1:         className =
1:               J2EEDataSource.getConnectionPoolDataSource().getClass().getName();
1:         println("Testing connection pool data source: " + className);
1:         assertDataSourceReference(descriptors[POOL_DS], className);
1: 
1:         // Test XA data source.
1:         className = J2EEDataSource.getXADataSource().getClass().getName();
1:         println("Testing XA data source: " + className);
1:         assertDataSourceReference(descriptors[XA_DS], className);
1:     }
1: 
1: 
1:     /**
1:      * Performs the test sequence in the data source.
1:      *
1:      * @param dsDesc data source descriptor
1:      * @param className class name of the data source
1:      * @throws Exception on a wide variety of error conditions...
1:      *
1:      * @see #testDataSourceReference
1:      */
1:     private void assertDataSourceReference(
1:                                         DataSourceDescriptor dsDesc,
1:                                         String className)
1:         throws Exception {
1:         // Instantiate a new data source object and get all its properties.
0:         Object dsObj = Class.forName(className).newInstance();
1:         String[] properties = getPropertyBeanList(dsObj);
1:         // Validate property set (existence and naming).
1:         assertDataSourceProperties(dsDesc, properties);
1:         // Test recreating the data source
1:         assertDataSourceReferenceEmpty(dsDesc, className);
1:         assertDataSourceReferencePopulated(dsDesc, className);
1:     }
1: 
1:     /**
1:      * Asserts that the properties that are in the data source descriptor are
1:      * found in the list of data source properties, and that the data source
1:      * does not contain properties that are not in the descriptor.
1:      * <p>
1:      * No property values are verified in this assert method.
1:      *
1:      * @param dsDesc data source descriptor
1:      * @param properties list of actual data source properties
1:      */
1:     private void assertDataSourceProperties(
1:                                         DataSourceDescriptor dsDesc,
1:                                         String[] properties) {
1:         println("Testing data source bean properties.");
1:         // Validate the identified property names.
1:         for (int i=0; i < properties.length; i++) {
1:             assertTrue("Property '" + properties[i] + "' not in descriptor '" +
1:                     dsDesc.getName() + "'",
1:                     dsDesc.hasProperty(properties[i]));
1:         // Check that all keys defined by the descriptor is found, and that
1:         // there is only one of each in the data source property list.
1:         Iterator descPropIter = dsDesc.getPropertyIterator();
1:         while (descPropIter.hasNext()) {
1:             String descProp = (String)descPropIter.next();
1:             boolean match = false;
1:             // Iterate through all the data source properties.
1:             for (int i=0; i < properties.length; i++) {
1:                 if (properties[i].equals(descProp)) {
1:                     if (match) {
1:                         fail("Duplicate entry '" + descProp + "' in data " +
1:                                 "source property list");
1:                     }
1:                     // Don't break, continue to look for duplicates.
1:                     match = true;
1:                 }
1:             }
1:             assertTrue("Property '" + descProp + "' not found in data source " +
1:                     "property list", match);
1:         }
1:         // Check if the expected number of properties are found.
1:         // Do this last to hopefully get a more descriptive failure
1:         // message which includes the property name above.
1:         assertEquals(dsDesc.getPropertyCount(), properties.length);
1:     }
1: 
1:     /**
1:      * Make sure it is possible to create a new data source using
1:      * <code>Referencable</code>, that the new instance has the correct
1:      * default values set for the bean properties and finally that the
1:      * data source can be serialized/deserialized.
1:      *
1:      * @param dsDesc data source descriptor
1:      * @param className data source class name
1:      * @throws Exception on a wide variety of error conditions...
1:      */
1:     private void assertDataSourceReferenceEmpty(DataSourceDescriptor dsDesc,
1:                                                 String className)
1:             throws Exception {
1:         println("Testing recreated empty data source.");
1:         // Create an empty data source.
0:         Object ds = Class.forName(className).newInstance();
1:         Referenceable refDs = (Referenceable)ds;
1:         Reference dsAsReference = refDs.getReference();
1:         ObjectFactory factory =
0:             (ObjectFactory)Class.forName(factoryClassName).newInstance();
1:         Object recreatedDs =
1:         // Empty, recreated data source should not be the same as the one we
1:         // created earlier on.
1:         assertNotNull("Recreated datasource is <null>", recreatedDs);
1:         assertNotSame(recreatedDs, ds);
1:         compareDataSources(dsDesc, ds, recreatedDs, true);
1: 
1:         // Serialize and recreate data source with default values.
1:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:         ByteArrayInputStream bais =
1:                 new ByteArrayInputStream(baos.toByteArray());
1:         recreatedDs = ois.readObject();
1:         compareDataSources(dsDesc, ds, recreatedDs, true);
1:     }
1:     /**
1:      * Make sure it is possible to recreate and serialize/deserialize a
1:      * populated data source.
1:      * <p>
1:      * Populated means the various bean properties have non-default
1:      * values set.
1:      *
1:      * @param dsDesc data source descriptor
1:      * @param className data source class name
1:      * @throws Exception on a wide variety of error conditions...
1:      */
1:     private void assertDataSourceReferencePopulated(
1:                                                 DataSourceDescriptor dsDesc,
1:                                                 String className)
1:             throws Exception {
1:         println("Testing recreated populated data source.");
0:         Object ds = Class.forName(className).newInstance();
1:         // Populate the data source.
1:         Iterator propIter = dsDesc.getPropertyIterator();
1:         while (propIter.hasNext()) {
1:             String property = (String)propIter.next();
1:             String value = dsDesc.getPropertyValue(property);
1:             Method getMethod = getGet(property, ds);
1:             Method setMethod = getSet(getMethod, ds);
1:             Class paramType = getMethod.getReturnType();
1: 
1:             if (paramType.equals(Integer.TYPE)) {
1:                 setMethod.invoke(ds, new Object[] {Integer.valueOf(value)});
1:             } else if (paramType.equals(String.class)) {
1:                 setMethod.invoke(ds, new Object[] {value});
1:             } else if (paramType.equals(Boolean.TYPE)) {
1:                 setMethod.invoke(ds, new Object[] {Boolean.valueOf(value)});
1:             } else if (paramType.equals(Short.TYPE)) {
1:                 setMethod.invoke(ds, new Object[] {Short.valueOf(value)});
1:             } else if (paramType.equals(Long.TYPE)) {
1:                 setMethod.invoke(ds, new Object[] {Long.valueOf(value)});
1:             } else {
1:                 fail("'" + property + "' not settable - update test!!");
1:             }
1:         }
1: 
1:         Referenceable refDs = (Referenceable)ds;
1:         Reference dsAsReference = refDs.getReference();
1:         String factoryClassName = dsAsReference.getFactoryClassName();
1:         ObjectFactory factory =
0:             (ObjectFactory)Class.forName(factoryClassName).newInstance();
1:         Object recreatedDs =
1:             factory.getObjectInstance(dsAsReference, null, null, null);
1:         // Recreated should not be same instance as original.
1:         assertNotSame(recreatedDs, ds);
1:         compareDataSources(dsDesc, ds, recreatedDs, false);
1: 
1:         // Serialize and recreate.
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:         ByteArrayInputStream bais =
1:                 new ByteArrayInputStream(baos.toByteArray());
1:         ObjectInputStream ois = new ObjectInputStream(bais);
1:         recreatedDs = ois.readObject();
1:         compareDataSources(dsDesc, ds, recreatedDs, false);
1:     /**
1:      * Compares two data sources expected to be equal.
1:      * <p>
1:      * The data source descriptor is expected to contain both default values
1:      * and set values for the relevant bean properties of the data source(s).
1:      *
1:      * @param dsDesc data source descriptor
1:      * @param ds original data source
1:      * @param rds recreated data source
1:      * @param useDefaultsForComparison <code>true</code> if the default values
1:      *      should be verified, <code>false</code> if the set values should be
1:      *      used for verification
1:      * @throws Exception on a wide variety of error conditions...
1:      * @throws AssertionFailedError if the data sources are not equal
1:      */
1:     private void compareDataSources(DataSourceDescriptor dsDesc,
1:                                        Object ds, Object rds,
1:                                        boolean useDefaultsForComparison)
1:             throws Exception {
1:         Iterator propIter = dsDesc.getPropertyIterator();
1:         while (propIter.hasNext()) {
1:             String property = (String)propIter.next();
1:             Method getMethod = getGet(property, ds);
1: 
1:             // Obtain value from original data source, then the recreated one.
1:             Object dsValue = getMethod.invoke(ds, null);
1:             Object rdsValue = getMethod.invoke(rds, null);
1: 
1:             if (dsValue == null) {
1:                 assertNull(rdsValue);
1:             } else {
1:                 assertEquals(dsValue, rdsValue);
1:             }
1:             // Make sure the value is correct.
1:             if (useDefaultsForComparison) {
1:                 if (dsValue != null) {
1:                     assertEquals("Wrong default value for '" + property + "'",
1:                             dsDesc.getPropertyDefault(property),
1:                             dsValue.toString());
1:                 } else {
1:                     assertNull(dsDesc.getPropertyDefault(property));
1:                 }
1:             } else if (dsValue != null) {
1:                     assertEquals("'" + property + "' has incorrect value",
1:                             dsDesc.getPropertyValue(property),
1:                             dsValue.toString());
1:             } else {
1:                 // We got null from the data source, and we should have set all
1:                 // values to something else than null.
1:                 fail("Test does not handle this situation...");
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Obtains a list of bean properties through reflection.
1:      *
1:      * @param ds the data source to investigate
1:      * @return A list of bean property names.
1:      */
1:     private static String[] getPropertyBeanList(Object ds) {
1:         Method[] allMethods = ds.getClass().getMethods();
0:         ArrayList properties = new ArrayList();
1: 
1:         for (int i = 0; i < allMethods.length; i++) {
1:             Method method = allMethods[i];
1:             String methodName = method.getName();
1:             // Need at least getXX
1:             if (methodName.length() < 5 || !methodName.startsWith("get") ||
1:                     method.getParameterTypes().length != 0) {
1:                 continue;
1:             }
1: 
1:             Class rt = method.getReturnType();
1:             if (rt.equals(Integer.TYPE) || rt.equals(String.class) ||
1:                     rt.equals(Boolean.TYPE) || rt.equals(Short.TYPE) ||
1:                     rt.equals(Long.TYPE)) {
1:                 // Valid Java Bean property.
1:                 // Convert name:
1:                 //    getPassword -> password
1:                 //    getRetrieveMessageText -> retrieveMessageText
1:                 String beanName = methodName.substring(3,4).toLowerCase()
1:                         + methodName.substring(4);
1:             } else {
1:                 assertFalse("Method '" + methodName + "' with primitive " +
1:                     "return type not supported - update test!!",
1:                     rt.isPrimitive());
1: 
0:         return (String[])properties.toArray(new String[properties.size()]);
1: 
1:     /**
1:      * Obtains the specified get method.
1:      *
1:      * @param property property/method name
1:      * @param ds data source object
1:      * @return A method object.
1:      *
1:      * @throws NoSuchMethodException if the method does not exist
1:      */
1:     private static Method getGet(String property, Object ds)
1:             throws NoSuchMethodException {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Obtains the specified set method.
1:      *
1:      * @param getMethod the corresponding get method
1:      * @param ds data source object
1:      * @return A method object.
1:      *
1:      * @throws NoSuchMethodException if the method does not exist
1:      */private static Method getSet(Method getMethod, Object ds)
1:             throws NoSuchMethodException {
1: 
1:     /**
1:      * A class describing the bean properties of a data source.
1:      * <p>
1:      * A data source is a class implementing
1:      * <code>javax.sql.CommonDataSource</code>.
1:      * <p>
1:      * The data source description consists of the following:
1:      * <ul> <li>A list of property names.
1:      *      <li>A list of default values for the properties that have a default.
1:      *      <li>A list of set values for properties.
1:      * </ul>
1:      * In addition it has a name for convenience.
1:      */
1:     private static class DataSourceDescriptor {
1: 
1:         /** Name of the description. */
1:         private final String dsName;
1:         /**
1:          * Set values for the data source being described.
1:          * <p>
1:          * Note that the keys of this property object describe which bean
1:          * properties exist for the data source.
1:          */
1:         private final Properties propertyValues;
1:         /**
1:          * Default values for bean properties having a default.
1:          * <p>
1:          * Note that not all properties have a default, and the data source
1:          * may therefore have more properties than there entries in this
1:          * list of properties.
1:          */
1:         private final Properties propertyDefaults;
1: 
1:         /**
1:          * Creates a new data source description.
1:          *
1:          * @param dsName convenience name for the description/source
1:          */
1:         DataSourceDescriptor(String dsName) {
1:             this.dsName = dsName;
1:             this.propertyValues = new Properties();
1:             this.propertyDefaults = new Properties();
1:         }
1: 
1:         /**
1:          * Creates a new data source description, based off an existing
1:          * description.
1:          * <p>
1:          * All properties and values defined in the existing descriptor will
1:          * also be defined in the new descriptor.
1:          *
1:          * @param dsName convenience name for the description/source
1:          * @param copyFrom existing descriptor to copy properties/values from
1:          */
1:         DataSourceDescriptor(String dsName, DataSourceDescriptor copyFrom) {
1:             this.dsName = dsName;
1:             this.propertyValues = new Properties();
1:             this.propertyValues.putAll(copyFrom.propertyValues);
1:             this.propertyDefaults = new Properties(copyFrom.propertyDefaults);
1:             this.propertyDefaults.putAll(copyFrom.propertyDefaults);
1:         }
1: 
1:         /**
1:          * Returns the convenience name of this descriptor.
1:          *
1:          * @return A convenience name.
1:          */
1:         String getName() {
1:             return this.dsName;
1:         }
1: 
1:         /**
1:          * Adds a property to the description, with a value and no associated
1:          * default value.
1:          *
1:          * @param name property name
1:          * @param value property value
1:          * @throws NullPointerException if <code>name</code> or
1:          *      <code>value</code> is <code>null</code>
1:          */
1:         void addProperty(String name, String value) {
1:             this.propertyValues.setProperty(name, value);
1:         }
1: 
1:         /**
1:          * Adds a property to the description, with a value and an associated
1:          * default value.
1:          *
1:          * @param name property name
1:          * @param value property value
1:          * @param defaultValue default property value
1:          * @throws NullPointerException if <code>name</code>, <code>value</code>
1:          *      or <code>defaultValue</code> is <code>null</code>
1:          */
1:         void addProperty(String name, String value, String defaultValue) {
1:             this.propertyValues.setProperty(name, value);
1:             this.propertyDefaults.setProperty(name, defaultValue);
1:         }
1: 
1:         /**
1:          * Returns the value of the specified property.
1:          *
1:          * @param name property name
1:          * @return The value set for this property.
1:          *
1:          * @throws NullPointerException if <code>name</code> is
1:          *      <code>null</code>
1:          * @throws AssertionFailedError if the property name is not defined by
1:          *      this descriptor
1:          */
1:         String getPropertyValue(String name) {
1:             if (!this.propertyValues.containsKey(name)) {
1:                 fail("Property '" + name + "' not in data source descriptor '" +
1:                         dsName + "'");
1:             }
1:             return this.propertyValues.getProperty(name);
1:         }
1: 
1:         /**
1:          * Returns the default value for the specified property.
1:          *
1:          * @param name property name
1:          * @return The default value if specified, <code>null<code> if a default
1:          *      value is not specified.
1:          *
1:          * @throws NullPointerException if <code>name</code> is
1:          *      <code>null</code>
1:          * @throws AssertionFailedError if the property name is not defined by
1:          *      this descriptor
1:          */
1:         String getPropertyDefault(String name) {
1:             if (!this.propertyValues.containsKey(name)) {
1:                 fail("Property '" + name + "' not in data source descriptor '" +
1:                         dsName + "'");
1:             }
1:             return this.propertyDefaults.getProperty(name, null);
1:         }
1: 
1:         /**
1:          * Returns an iterator over all bean property names.
1:          *
1:          * @return An iterator.
1:          */
1:         Iterator getPropertyIterator() {
1:             return this.propertyValues.keySet().iterator();
1:         }
1: 
1:         /**
1:          * Tells if the specified property is defined by this descriptor.
1:          *
1:          * @param name property name
1:          * @return <code>true</code> if defined, <code>false</code> if not.
1:          */
1:         boolean hasProperty(String name) {
1:             return this.propertyValues.containsKey(name);
1:         }
1: 
1:         /**
1:          * Returns the number of bean properties defined by this descriptor.
1:          *
1:          * @return The number of bean properties.
1:          */
1:         int getPropertyCount() {
1:             return this.propertyValues.size();
1:         }
1:     } // End class DataSourceDescriptor
commit:a8d30d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: }
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5839503
/////////////////////////////////////////////////////////////////////////
0:          {"serverName", "tmphostName"}, null, 
0:          {"ssl","off"}, null, null, 
/////////////////////////////////////////////////////////////////////////
0:          {"ssl","basic"},
/////////////////////////////////////////////////////////////////////////
0:             expectedValues[expectedArrayIndex][17][1] =
/////////////////////////////////////////////////////////////////////////
0:                 else if (property.equals("ssl"))
0:                     value = "basic";
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:90f367e
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2559 - with jdk16, this recreatedDS will be null.
0:         // bailing out
0:         if (JDBC.vmSupportsJDBC4())
0:             return;
1:         
commit:f7b3a7a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DataSourceReferenceTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.lang.reflect.Method;
1: import java.util.ArrayList;
0: import java.util.Arrays;
1: 
1: import javax.naming.Reference;
1: import javax.naming.Referenceable;
1: import javax.naming.spi.ObjectFactory;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
0:  * Test obtaining a javax.naming.Reference from a Derby data source
0:  * and recreating a Derby data source from it. Tests that the recreated
0:  * value has the same value for all the properties the data source supports.
0:  * The list of properties is obtained dynamically from the getXXX methods
0:  * that return int, String, boolean, short, long. Should Derby data sources
0:  * support any other bean property types then this test should be modified
0:  * to pick them up and handle them. Hopefully the test should fail when such
0:  * a property is added.
0:  * 
1:  * At no point does this test attempt to connect using these data sources.
1:  */
0: public class DataSourceReferenceTest extends BaseJDBCTestCase {
1: 
0:     private static String[][][] expectedValues = {
0:         // org.apache.derby.jdbc.Embedded*DataSource
0:         {{"attributesAsPassword", "false"}, null, null, null, null, null, 
0:          {"loginTimeout", "0"}, null, null, null}, 
0:         {{"attributesAsPassword", "true"}, 
0:          {"connectionAttributes", "XX_connectionAttributes_2135"},
0:          {"createDatabase", "create"},
0:          {"dataSourceName", "XX_dataSourceName_1420"},
0:          {"databaseName", "XX_databaseName_1206"},
0:          {"description", "XX_description_1188"},
0:          {"loginTimeout", "1280"},
0:          {"password", "XX_password_883"},
0:          {"shutdownDatabase", "shutdown"},
0:          {"user", "XX_user_447"}},
0:         // org.apache.derby.jdbc.Client*DataSource
0:         { null, null, null, null, null, {"loginTimeout", "0"}, null, 
0:          {"portNumber", "tmpportno"},
0:          {"retrieveMessageText", "true"},
0:          {"securityMechanism", "4"},
0:          {"serverName", "tmphostName"}, null, null, null, 
0:          {"traceFileAppend", "false"},
0:          {"traceLevel", "-1"},
0:          {"user", "tmpUserName"}},
0:         {{"connectionAttributes", "XX_connectionAttributes_2135"},
0:          {"createDatabase", "create"},
0:          {"dataSourceName", "XX_dataSourceName_1420"},
0:          {"databaseName", "XX_databaseName_1206"},
0:          {"description", "XX_description_1188"},
0:          {"loginTimeout", "1280"},
0:          {"password", "XX_password_883"},
0:          {"portNumber", "1070"},
0:          {"retrieveMessageText", "false"},
0:          {"securityMechanism", "1805"},
0:          {"serverName", "XX_serverName_1048"},
0:          {"shutdownDatabase", "shutdown"},
0:          {"traceDirectory", "XX_traceDirectory_1476"},
0:          {"traceFile", "XX_traceFile_911"},
0:          {"traceFileAppend", "true"},
0:          {"traceLevel", "1031"},
0:          {"user", "XX_user_447"}}
0:     };
1:     
1:     public DataSourceReferenceTest(String name) {
1:         super(name);
1:     }
1:     
0:     public static Test suite() {
0:         if (JDBC.vmSupportsJSR169())
0:         {
0:             // Referencable is not supported with JSR169
0:             TestSuite suite = 
0:                 new TestSuite("DatasourceTest cannot run with JSR169");
0:             return suite;
1:         }
0:         else
0:         {
0:             return 
0:                 TestConfiguration.defaultSuite(DataSourceReferenceTest.class);
1:         }
1:     }
1:     
1:     /**
0:      * Test a data source
0:      * <OL>
0:      * <LI> Create an empty one from the class name
0:      * <LI> Discover the property list
0:      * <LI> Create a reference and recreate a data source
0:      * <LI> Compare the two
0:      * <LI> Serialize the data source and recreate
0:      * <LI> Compare the two
0:      * <LI> Set every property for the data source
0:      * <LI> Create a reference and recreate a data source
0:      * <LI> Compare the two
0:      * </OL>
0:      * @throws Exception
1:      */
0:     public static void testDSReference() throws Exception
0:     {
0:         String ds;
0:         ds = JDBCDataSource.getDataSource().getClass().getName();
0:         int expectedArray=0;
0:         if (usingDerbyNetClient())
0:             expectedArray = 2;
0:         assertDataSourceReference(expectedArray, ds);
0:         ds = J2EEDataSource.getConnectionPoolDataSource().getClass().getName();
0:         assertDataSourceReference(expectedArray, ds);
0:         ds = J2EEDataSource.getXADataSource().getClass().getName();
0:         assertDataSourceReference(expectedArray, ds);
1:     }
1:         
0:     public static void assertDataSourceReference(
0:         int expectedArrayIndex, String dsName) throws Exception {
1: 
0:         if (usingDerbyNetClient())
0:         {
0:             expectedValues[expectedArrayIndex][7][1] =
0:                 String.valueOf(TestConfiguration.getCurrent().getPort());
0:             expectedValues[expectedArrayIndex][10][1] =
0:                 TestConfiguration.getCurrent().getHostName();
0:             expectedValues[expectedArrayIndex][16][1] =
0:                 TestConfiguration.getCurrent().getUserName();
1:         }
1:         
0:         Object ds = Class.forName(dsName).newInstance();
1:         
0:         println("DataSource class " + dsName);
0:         String[] properties = getPropertyBeanList(ds);
0:         assertEquals(
0:             expectedValues[expectedArrayIndex+1].length, properties.length);
0:         println(" property list");
1:         
0:         for (int i = 0; i < properties.length; i++)
0:         {
0:             assertEquals(
0:                 expectedValues[expectedArrayIndex+1][i][0], properties[i]);
0:             println("  " + properties[i]);
1:         }
1:         
0:         Referenceable refDS = (Referenceable) ds;
1:         
0:         Reference dsAsReference = refDS.getReference();
1:         
1:         String factoryClassName = dsAsReference.getFactoryClassName();
1:         
0:         ObjectFactory factory = 
0:             (ObjectFactory) Class.forName(factoryClassName).newInstance();  
1:         
0:         Object recreatedDS = 
1:             factory.getObjectInstance(dsAsReference, null, null, null);
1:         
0:         println(" empty DataSource recreated using Reference as " +
0:             recreatedDS.getClass().getName());
0:         // empty DataSource recreated using Reference should not be 
0:         // the same as the original
0:         assertNotSame(recreatedDS, ds);
1:         
0:         compareDS(expectedArrayIndex, properties, ds, recreatedDS);
1:         
0:         // now serialize and recreate
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
0:         ObjectOutputStream oos = new ObjectOutputStream(baos);  
1:         oos.writeObject(ds);
1:         oos.flush();
1:         oos.close();
0:         ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
1:         ObjectInputStream ois = new ObjectInputStream(bais);
0:         recreatedDS = ois.readObject();
0:         println(" empty DataSource recreated using serialization");
0:         compareDS(expectedArrayIndex, properties, ds, recreatedDS);
1:         
0:         // now populate the data source
0:         for (int i = 0; i < properties.length; i++)
0:         {
0:             String property = properties[i];
0:             Method getMethod = getGet(property, ds);
1:             
0:             Method setMethod = getSet(getMethod, ds);
1:             
0:             Class pt = getMethod.getReturnType();
1:             
0:             // generate a somewhat unique value for a property
0:             int val = 0;
0:             for (int j = 0; j < property.length(); j++)
0:                 val += property.charAt(j);
1:             
0:             if (pt.equals(Integer.TYPE))
0:             {
0:                 setMethod.invoke(ds, new Object[] {new Integer(val)});
0:                 continue;
1:             }
0:             if (pt.equals(String.class))
0:             {
0:                 String value;
0:                 if (property.equals("createDatabase"))
0:                     value = "create";
0:                 else if (property.equals("shutdownDatabase"))
0:                     value = "shutdown";
0:                 else
0:                     value = "XX_" + property + "_" + val;
1:                     
0:                 setMethod.invoke(ds, new Object[] {value});
0:                 continue;
1:             }
0:             if (pt.equals(Boolean.TYPE))
0:             {
0:                 // set the opposite value
0:                 Object gbv = getMethod.invoke(ds, null);
0:                 Boolean sbv = 
0:                     Boolean.FALSE.equals(gbv) ? Boolean.TRUE : Boolean.FALSE;
0:                 setMethod.invoke(ds, new Object[] {sbv});
0:                 continue;
1:             }           
0:             if (pt.equals(Short.TYPE))
0:             {
0:                 setMethod.invoke(ds, new Object[] {new Short((short)val)});
0:                 continue;
1:             }
0:             if (pt.equals(Long.TYPE))
0:             {
0:                 setMethod.invoke(ds, new Object[] {new Long(val)});
0:                 continue;
1:             }
0:             fail ( property + " not settable - update test!!");
1:         }
1:         
0:         dsAsReference = refDS.getReference();
0:         recreatedDS = 
1:             factory.getObjectInstance(dsAsReference, null, null, null);
0:         println(" populated DataSource recreated using Reference as " 
0:             + recreatedDS.getClass().getName());
0:         // again, recreated should not be same instance
0:         assertNotSame(recreatedDS, ds);
1:         
0:         compareDS(expectedArrayIndex+1, properties, ds, recreatedDS);     
1: 
0:         // now serialize and recreate
0:         baos = new ByteArrayOutputStream();
0:         oos = new ObjectOutputStream(baos); 
1:         oos.writeObject(ds);
1:         oos.flush();
1:         oos.close();
0:         bais = new ByteArrayInputStream(baos.toByteArray());
0:         ois = new ObjectInputStream(bais);
0:         recreatedDS = ois.readObject();
0:         println(" populated DataSource recreated using serialization");
0:         compareDS(expectedArrayIndex+1, properties, ds, recreatedDS);
1:     }
1:     
0:     private static String[] getPropertyBeanList(Object ds) throws Exception
0:     {
0:         Method[] allMethods = ds.getClass().getMethods();
1:         
0:         ArrayList properties = new ArrayList();
0:         for (int i = 0; i < allMethods.length; i++)
0:         {
0:             Method m = allMethods[i];
0:             String methodName = m.getName();
0:             // Need at least getXX
0:             if (methodName.length() < 5)
0:                 continue;
0:             if (!methodName.startsWith("get"))
0:                 continue;
0:             if (m.getParameterTypes().length != 0)
0:                 continue;
1: 
0:             Class rt = m.getReturnType();
1:             
0:             if (rt.equals(Integer.TYPE) || rt.equals(String.class) || 
0:                 rt.equals(Boolean.TYPE) || rt.equals(Short.TYPE) ||
0:                 rt.equals(Long.TYPE))
0:             {
0:                 // valid Java Bean property
0:                  String beanName = methodName.substring(3,4).toLowerCase() 
0:                      + methodName.substring(4);
1: 
1:                 properties.add(beanName);
0:                 continue;
1:             }
1:         
1:             
0:             assertFalse(rt.isPrimitive());
0:             println("if rt.isPrimitive, method " + methodName + 
0:                 " not supported - update test!!");
1: 
1:         }
1:         
0:         String[] propertyList = (String[]) properties.toArray(new String[0]);
1:         
0:         Arrays.sort(propertyList);
1:         
0:         return propertyList;
1:     }
1:     
0:     private static Method getGet(String property, Object ds) throws Exception
0:     {
1:         String methodName =
1:             "get" + property.substring(0,1).toUpperCase()
1:             + property.substring(1);
1:         Method m = ds.getClass().getMethod(methodName, null);
1:         return m;
1:     }
1: 
0:     private static Method getSet(Method getMethod, Object ds) throws Exception
0:     {
1:         String methodName = "s" + getMethod.getName().substring(1);
1:         Method m = ds.getClass().getMethod(
1:             methodName, new Class[] {getMethod.getReturnType()});
1:         return m;
1:     }   
1: 
0:     private static void compareDS(int expectedValuesArrayIndex,
0:         String[] properties, Object ds, Object rds) throws Exception
0:     {
0:         println(" Start compare recreated");
0:         for (int i = 0; i < properties.length; i++)
0:         {
0:             Method getMethod = getGet(properties[i], ds);
1:             
0:             Object dsValue = getMethod.invoke(ds, null);
0:             Object rdsValue = getMethod.invoke(rds, null);
1:             
0:             if (dsValue == null)
0:             {
0:                 // properties[i] originally null, should be recreated as null.
0:                 assertNull(rdsValue);
1:             }
0:             else
0:             {
0:                 // properties[i] originally dsValue, should be recreated as
0:                 // rdsValue
0:                 assertEquals(dsValue, rdsValue);
1:             }
0:             if (dsValue != null)
0:             {
0:                 assertEquals(expectedValues[expectedValuesArrayIndex][i][0], 
0:                     properties[i]);
0:                 assertEquals(expectedValues[expectedValuesArrayIndex][i][1], 
0:                     dsValue.toString());
1:             }
1:         }
1:     }
1: }
============================================================================