2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.InternalTriggerExecutionContext
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
10:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:801cf0d: import java.sql.ResultSet;
1:1a36302: import java.sql.SQLException;
1:eac0369: import java.util.Hashtable;
1:44370a8: import java.util.Map;
1:1a36302: import java.util.Vector;
1:1a36302: 
1:1a36302: import org.apache.derby.catalog.UUID;
1:1a36302: import org.apache.derby.iapi.db.TriggerExecutionContext;
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:1a36302: import org.apache.derby.iapi.error.PublicAPI;
1:1a36302: import org.apache.derby.iapi.error.StandardException;
1:1a36302: import org.apache.derby.iapi.jdbc.ConnectionContext;
1:1a36302: import org.apache.derby.iapi.reference.SQLState;
1:1a36302: import org.apache.derby.iapi.services.i18n.MessageService;
1:1a36302: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:1a36302: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:1a36302: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:1a36302: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:1a36302: import org.apache.derby.iapi.sql.execute.ExecRow;
1:1a36302: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
1:1a36302: import org.apache.derby.iapi.types.DataValueDescriptor;
5:eac0369: /**
1:eac0369:  * There is one of these beasts per INSERT/DELETE/UPDATE 
1:eac0369:  * statement.  It fulfills the contract for the externally
1:eac0369:  * visible trigger execution context and it validates
1:eac0369:  * that a statement that is about to be executed doesn't
1:eac0369:  * violate the restrictions placed upon what can be executed
1:eac0369:  * from a trigger.
1:eac0369:  * <p>
1:eac0369:  * Note that it is crucial that cleanup() is called once
1:eac0369:  * the DML has completed, cleanup() makes sure that users
1:eac0369:  * can't do something invalid on a tec reference that they
1:eac0369:  * were holding from when the trigger fired.
6:eac0369:  *
1:eac0369:  */
1:ca6ed17: class InternalTriggerExecutionContext
1:ca6ed17:         implements TriggerExecutionContext, ExecutionStmtValidator
19:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** Immutable
1:eac0369: 	*/
1:eac0369: 	protected int					dmlType;
1:eac0369: 	protected String				statementText;
1:eac0369: 	protected ConnectionContext		cc;
1:eac0369: 	protected UUID					targetTableId;
1:eac0369: 	protected String				targetTableName;
1:eac0369: 	protected LanguageConnectionContext lcc;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Mutable
1:eac0369: 	*/
1:eac0369: 	protected CursorResultSet		beforeResultSet;
1:eac0369: 	protected CursorResultSet		afterResultSet;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * used exclusively for InsertResultSets which have autoincrement 
1:eac0369: 	 * columns.
1:eac0369: 	 */
1:eac0369: 	protected ExecRow				afterRow;
1:eac0369: 								
1:eac0369: 	protected boolean				cleanupCalled;
1:eac0369: 	protected TriggerEvent			event;
1:eac0369: 	protected TriggerDescriptor		triggerd;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Used to track all the result sets we have given out to
1:eac0369: 	** users.  When the trigger context is no longer valid,
1:eac0369: 	** we close all the result sets that may be in the user
1:eac0369: 	** space because they can no longer provide meaningful
1:eac0369: 	** results.
1:eac0369: 	*/
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     private Vector<ResultSet>   resultSetVector;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * aiCounters is a vector of AutoincrementCounters used to keep state which
1:eac0369: 	 * might be used by the trigger. This is only used by Insert triggers--
1:eac0369: 	 * Delete and Update triggers do not use this variable.
1:eac0369: 	 * 
1:eac0369: 	 * @see AutoincrementCounter
1:eac0369: 	 * 
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     private Vector<AutoincrementCounter> aiCounters;
1:eac0369: 	
1:eac0369: 	/**
1:dbed020:      * aiHT is a hash table of auto increment (key, value) pairs. This is used
1:801cf0d:      * for auto increment values generated by the trigger.
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:71c8e86: 	private Hashtable<String,Long> aiHT;
1:eac0369: 
1:eac0369: 	/**
1:801cf0d:      * Build a trigger execution context.
1:eac0369: 	 * <p>
1:eac0369: 	 * About the only thing of real interest to outside observers
1:eac0369: 	 * is that it pushes itself as the trigger execution context
1:eac0369: 	 * in the lcc.  Be sure to call <i>cleanup()</i> when you
1:eac0369: 	 * are done, or you will be flogged like the reprobate that
1:eac0369: 	 * you are.
1:eac0369: 	 *
1:eac0369: 	 * @param lcc	the lcc
1:eac0369: 	 * @param statementText	the text of the statement that caused the
1:eac0369: 	 *		trigger to fire.  may be null if we are replicating
1:eac0369: 	 * @param targetTableId	the UUID of the table upon which the trigger
1:eac0369: 	 *		fired
1:eac0369: 	 * @param targetTableName	the name of the table upon which the trigger
1:eac0369: 	 *		fired
1:eac0369: 	 * @param aiCounters		A vector of AutoincrementCounters to keep state
1:eac0369: 	 * 							of the ai columns in this insert trigger.a
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings({"UseOfObsoleteCollectionType", "LeakingThisInConstructor"})
1:ca6ed17:     InternalTriggerExecutionContext
1:eac0369: 	(
1:eac0369: 		LanguageConnectionContext	lcc,
1:eac0369: 		ConnectionContext			cc,
1:eac0369: 		String 						statementText,
1:eac0369: 		int 						dmlType,
1:eac0369: 		UUID						targetTableId,
1:eac0369: 		String						targetTableName,
1:801cf0d:         Vector<AutoincrementCounter> aiCounters
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:eac0369: 		this.dmlType = dmlType;
1:eac0369: 		this.statementText = statementText;
1:eac0369: 		this.cc = cc;
1:eac0369: 		this.lcc = lcc;
1:eac0369: 		this.targetTableId = targetTableId;
1:eac0369: 		this.targetTableName = targetTableName;
1:71c8e86: 		this.resultSetVector = new Vector<java.sql.ResultSet>();
1:eac0369: 		this.aiCounters = aiCounters;
1:eac0369: 
1:eac0369: 		lcc.pushTriggerExecutionContext(this);
16:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setBeforeResultSet(CursorResultSet rs)
1:eac0369: 	{
1:eac0369: 		beforeResultSet = rs;	
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setAfterResultSet(CursorResultSet rs)
1:eac0369: 	     throws StandardException
1:eac0369: 	{
1:eac0369: 		afterResultSet = rs;	
1:eac0369: 		
1:eac0369: 		if (aiCounters != null)
1:eac0369: 		{
1:eac0369: 			if (triggerd.isRowTrigger())
1:eac0369: 			{
1:eac0369: 				// An after row trigger needs to see the "first" row inserted 
1:eac0369: 				rs.open();
1:eac0369: 				afterRow = rs.getNextRow();
2:eac0369: 				rs.close();
1:eac0369: 			}
1:eac0369: 			else 
1:eac0369: 			{
1:eac0369: 				// after statement trigger needs to look at the last value.
1:eac0369: 				if (!triggerd.isBeforeTrigger())
1:eac0369: 					resetAICounters(false);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setCurrentTriggerEvent(TriggerEvent event)
1:eac0369: 	{
1:eac0369: 		this.event = event;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void clearCurrentTriggerEvent()
1:eac0369: 	{
1:eac0369: 		event = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setTrigger(TriggerDescriptor triggerd)
1:eac0369: 	{
1:eac0369: 		this.triggerd = triggerd;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	void clearTrigger() throws StandardException
1:eac0369: 	{
1:eac0369: 		event = null;
1:eac0369: 		triggerd = null;
1:eac0369: 		if (afterResultSet != null)
1:eac0369: 		{
1:eac0369: 			afterResultSet.close();
1:eac0369: 			afterResultSet = null;
1:eac0369: 		}
1:eac0369: 		if (beforeResultSet != null)
1:eac0369: 		{
1:eac0369: 			beforeResultSet.close();
1:eac0369: 			beforeResultSet = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Cleanup the trigger execution context.  <B>MUST</B>
1:eac0369: 	 * be called when the caller is done with the trigger
1:eac0369: 	 * execution context.
1:eac0369: 	 * <p>
1:eac0369: 	 * We go to somewhat exaggerated lengths to free up
1:eac0369: 	 * all our resources here because a user may hold on
1:eac0369: 	 * to a TEC after it is valid, so we clean everything
1:eac0369: 	 * up to be on the safe side.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on unexpected error
1:eac0369: 	 */
1:eac0369: 	protected void cleanup()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:8bef59d:         if (lcc != null) {
1:8bef59d:             lcc.popTriggerExecutionContext(this);
1:8bef59d:         }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Explicitly close all result sets that we have
1:eac0369: 		** given out to the user.  
1:eac0369: 	 	*/
1:8bef59d:         if (resultSetVector != null) {
1:8bef59d:             for (ResultSet rs : resultSetVector) {
1:8bef59d:                 try {
1:8bef59d:                     rs.close();
1:8bef59d:                 } catch (SQLException se) {
1:8bef59d:                 }
1:8bef59d:             }
1:eac0369: 		}
1:eac0369: 		resultSetVector = null;
1:eac0369: 	
1:eac0369: 		/*
1:eac0369: 		** We should have already closed our underlying
1:eac0369: 		** ExecResultSets by closing the jdbc result sets,
1:eac0369: 		** but in case we got an error that we caught and
1:eac0369: 		** ignored, explicitly close them.
1:eac0369: 		*/	
1:eac0369: 		if (afterResultSet != null)
1:eac0369: 		{
1:eac0369: 			afterResultSet.close();
1:eac0369: 			afterResultSet = null;
1:eac0369: 		}
1:eac0369: 		if (beforeResultSet != null)
1:eac0369: 		{
1:eac0369: 			beforeResultSet.close();
1:eac0369: 			beforeResultSet = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		lcc = null;
1:eac0369: 		cleanupCalled = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make sure that the user isn't trying to get a result
1:eac0369: 	 * set after we have cleaned up. 
1:eac0369: 	 */
1:eac0369: 	private void ensureProperContext() throws SQLException
1:eac0369: 	{
1:eac0369: 		if (cleanupCalled)
1:eac0369: 		{
1:eac0369: 			throw new SQLException(
1:eac0369: 				MessageService.getTextMessage(
1:eac0369: 									SQLState.LANG_STATEMENT_CLOSED_NO_REASON),
1:eac0369: 									"XCL31",
1:eac0369: 									ExceptionSeverity.STATEMENT_SEVERITY
1:eac0369: 									);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ExecutionStmtValidator
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Make sure that whatever statement is about to be executed
1:eac0369: 	 * is ok from the context of this trigger.
1:eac0369: 	 * <p>
1:eac0369: 	 * Note that we are sub classed in replication for checks
1:eac0369: 	 * for replication specific language.
1:eac0369: 	 *
1:eac0369: 	 * @param constantAction the constant action of the action
1:eac0369: 	 *	that we are to validate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void validateStatement(ConstantAction constantAction) throws StandardException
1:eac0369: 	{
1:3b1291b: 
1:3b1291b: 		// DDL statements are not allowed in triggers. Direct use of DDL
1:3b1291b: 		// statements in a trigger's action statement is disallowed by the
1:3b1291b: 		// parser. However, this runtime check is needed to prevent execution
1:3b1291b: 		// of DDL statements by procedures within a trigger context. 
1:3b1291b:  		if (constantAction instanceof DDLConstantAction) {
1:870f7cd: 			throw StandardException.newException(SQLState.LANG_NO_DDL_IN_TRIGGER, triggerd.getName());
1:eac0369: 		}
1:698f7a2: 		
1:3b1291b: 		// No INSERT/UPDATE/DELETE for a before trigger. There is no need to 
1:3b1291b:  		// check this here because parser does not allow these DML statements
1:3b1291b:  		// in a trigger's action statement in a before trigger. Parser also 
1:3b1291b:  		// disallows creation of before triggers calling procedures that modify
1:3b1291b:  		// SQL data.   
1:3b1291b: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// TriggerExectionContext
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the target table name upon which the 
1:eac0369: 	 * trigger event is declared.
1:eac0369: 	 *
1:eac0369: 	 * @return the target table
1:eac0369: 	 */
1:eac0369: 	public String getTargetTableName()
1:eac0369: 	{
1:eac0369: 		return targetTableName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the target table UUID upon which the 
1:eac0369: 	 * trigger event is declared.
1:eac0369: 	 *
1:eac0369: 	 * @return the uuid of the target table
1:eac0369: 	 */
1:eac0369: 	public UUID getTargetTableId()
1:eac0369: 	{
1:eac0369: 		return targetTableId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the type for the event that caused the
1:eac0369: 	 * trigger to fire.
1:eac0369: 	 *
1:eac0369: 	 * @return the event type (e.g. UPDATE_EVENT)
1:eac0369: 	 */
1:eac0369: 	public int getEventType()
1:eac0369: 	{
1:eac0369: 		return dmlType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the text of the statement that caused the
1:eac0369: 	 * trigger to fire.
1:eac0369: 	 *
1:eac0369: 	 * @return the statement text
1:eac0369: 	 */
1:eac0369: 	public String getEventStatementText()
1:eac0369: 	{
1:eac0369: 		return statementText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns a result set row the old images of the changed rows.
1:eac0369: 	 * For a row trigger, the result set will have a single row.  For
1:eac0369: 	 * a statement trigger, this result set has every row that has
1:eac0369: 	 * changed or will change.  If a statement trigger does not affect 
1:eac0369: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
1:eac0369: 	 * will return false).
1:eac0369: 	 *
1:eac0369: 	 * @return the ResultSet containing before images of the rows 
1:eac0369: 	 * changed by the triggering event.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException if called after the triggering event has
1:eac0369: 	 * completed
1:eac0369: 	 */
1:eac0369: 	public java.sql.ResultSet getOldRowSet() throws SQLException
1:eac0369: 	{
1:eac0369: 		ensureProperContext();
1:eac0369: 		if (beforeResultSet == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			CursorResultSet brs = beforeResultSet;
1:eac0369: 			/* We should really shallow clone the result set, because it could be used
1:eac0369: 			 * at multiple places independently in trigger action.  This is a bug found
1:eac0369: 			 * during the fix of beetle 4373.
1:eac0369: 			 */
1:eac0369: 			if (brs instanceof TemporaryRowHolderResultSet)
1:eac0369: 				brs = (CursorResultSet) ((TemporaryRowHolderResultSet) brs).clone();
1:eac0369: 			else if (brs instanceof TableScanResultSet)
1:eac0369: 				brs = (CursorResultSet) ((TableScanResultSet) brs).clone();
1:eac0369: 			brs.open();
1:eac0369: 			java.sql.ResultSet rs = cc.getResultSet(brs);
1:eac0369: 			resultSetVector.addElement(rs);
1:eac0369: 			return rs;
1:eac0369: 		} catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns a result set row the new images of the changed rows.
1:eac0369: 	 * For a row trigger, the result set will have a single row.  For
1:eac0369: 	 * a statement trigger, this result set has every row that has
1:eac0369: 	 * changed or will change.  If a statement trigger does not affect 
1:eac0369: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
1:eac0369: 	 * will return false).
1:eac0369: 	 *
1:eac0369: 	 * @return the ResultSet containing after images of the rows 
1:eac0369: 	 * changed by the triggering event.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException if called after the triggering event has
1:eac0369: 	 * completed
1:eac0369: 	 */
1:eac0369: 	public java.sql.ResultSet getNewRowSet() throws SQLException
1:eac0369: 	{
1:eac0369: 		ensureProperContext();
1:eac0369: 
1:eac0369: 		if (afterResultSet == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			/* We should really shallow clone the result set, because it could be used
1:eac0369: 			 * at multiple places independently in trigger action.  This is a bug found
1:eac0369: 			 * during the fix of beetle 4373.
1:eac0369: 			 */
1:eac0369: 			CursorResultSet ars = afterResultSet;
1:eac0369: 			if (ars instanceof TemporaryRowHolderResultSet)
1:eac0369: 				ars = (CursorResultSet) ((TemporaryRowHolderResultSet) ars).clone();
1:eac0369: 			else if (ars instanceof TableScanResultSet)
1:eac0369: 				ars = (CursorResultSet) ((TableScanResultSet) ars).clone();
1:eac0369: 			ars.open();
1:eac0369: 			java.sql.ResultSet rs = cc.getResultSet(ars);
1:eac0369: 			resultSetVector.addElement(rs);
1:eac0369: 			return rs;
1:eac0369: 		} catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Like getBeforeResultSet(), but returns a result set positioned
1:eac0369: 	 * on the first row of the before result set.  Used as a convenience
1:eac0369: 	 * to get a column for a row trigger.  Equivalent to getBeforeResultSet()
1:eac0369: 	 * followed by next().
1:eac0369: 	 *
1:eac0369: 	 * @return the ResultSet positioned on the old row image.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException if called after the triggering event has
1:eac0369: 	 * completed
1:eac0369: 	 */
1:eac0369: 	public java.sql.ResultSet getOldRow() throws SQLException
1:eac0369: 	{
1:eac0369: 		java.sql.ResultSet rs = getOldRowSet();
1:eac0369: 		if (rs != null)
1:eac0369: 			rs.next();
1:eac0369: 		
1:eac0369: 		return rs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Like getAfterResultSet(), but returns a result set positioned
1:eac0369: 	 * on the first row of the before result set.  Used as a convenience
1:eac0369: 	 * to get a column for a row trigger.  Equivalent to getAfterResultSet()
1:eac0369: 	 * followed by next().
1:eac0369: 	 *
1:eac0369: 	 * @return the ResultSet positioned on the new row image.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException if called after the triggering event has
1:eac0369: 	 * completed
1:eac0369: 	 */
1:eac0369: 	public java.sql.ResultSet getNewRow() throws SQLException
1:eac0369: 	{
1:eac0369: 		java.sql.ResultSet rs = getNewRowSet();
1:eac0369: 		if (rs != null)
1:eac0369: 			rs.next();
1:eac0369: 		return rs;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public Long getAutoincrementValue(String identity)
1:eac0369: 	{
1:eac0369: 		// first search the hashtable-- this represents the ai values generated
1:eac0369: 		// by this trigger.
1:eac0369: 		if (aiHT != null)
1:eac0369: 			{
1:801cf0d:                 Long value = aiHT.get(identity);
1:eac0369: 				if (value != null)
1:eac0369: 					return value;
1:eac0369: 			}
1:eac0369: 		
1:eac0369: 		
1:eac0369: 		// If we didn't find it in the hashtable search in the counters which
1:eac0369: 		// represent values inherited by trigger from insert statements.
1:eac0369: 		if (aiCounters != null)
1:eac0369: 		{
1:801cf0d:             for (AutoincrementCounter aic : aiCounters)
1:eac0369: 			{
1:eac0369: 				if (identity.equals(aic.getIdentity()))
1:eac0369: 				{
1:eac0369: 					return aic.getCurrentValue();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		// didn't find it-- return NULL.
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 	/**
1:801cf0d:      * Copy a map of auto increment values into the trigger
1:801cf0d:      * execution context hash table of auto increment values.
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:71c8e86: 	public void copyHashtableToAIHT(Map<String,Long> from)
1:eac0369: 	{
1:eac0369: 		if (from == null)
1:eac0369: 			return;
1:eac0369: 		if (aiHT == null)
1:71c8e86: 			aiHT = new Hashtable<String,Long>();
1:44370a8: 
1:44370a8: 		aiHT.putAll(from);
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/** 
1:eac0369: 	 * Reset Autoincrement counters to the beginning or the end.
1:eac0369: 	 * 
1:eac0369: 	 * @param		begin		if True, reset the AutoincremnetCounter to the
1:eac0369: 	 *                          beginning-- used to reset the counters for the
1:eac0369: 	 * 							next trigger. If false, reset it to the end--
1:eac0369: 	 *                          this sets up the counter appropriately for a
1:eac0369: 	 *                          AFTER STATEMENT trigger.
1:eac0369: 	 */
1:eac0369: 	public void resetAICounters(boolean begin)
1:eac0369: 	{
1:eac0369: 		if (aiCounters == null)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		afterRow = null;
1:eac0369: 
1:801cf0d:         for (AutoincrementCounter aic : aiCounters)
1:eac0369: 		{
1:eac0369: 			aic.reset(begin);
1:eac0369: 		}
1:eac0369: 	}	
1:eac0369: 	
1:eac0369: 	/**
1:801cf0d:      * Update auto increment counters from the last row inserted.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void updateAICounters() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (aiCounters == null)
1:eac0369: 			return;
1:eac0369: 
1:801cf0d:         for (AutoincrementCounter aic : aiCounters)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor dvd = afterRow.getColumn(aic.getColumnPosition());
1:eac0369: 			aic.update(dvd.getLong());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:801cf0d:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		return triggerd.getName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * aiHT is a hash table of auto increment (key, value) pairs. This is used
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0: 	private Vector<java.sql.ResultSet>	resultSetVector;
/////////////////////////////////////////////////////////////////////////
1: 	private Hashtable<String,Long> aiHT;
/////////////////////////////////////////////////////////////////////////
1: 		this.resultSetVector = new Vector<java.sql.ResultSet>();
/////////////////////////////////////////////////////////////////////////
0: 		for (Enumeration<java.sql.ResultSet> e = resultSetVector.elements();
0: 			java.sql.ResultSet rs = e.nextElement();
/////////////////////////////////////////////////////////////////////////
1: 	public void copyHashtableToAIHT(Map<String,Long> from)
1: 			aiHT = new Hashtable<String,Long>();
commit:870f7cd
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_NO_DDL_IN_TRIGGER, triggerd.getName());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8bef59d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (lcc != null) {
1:             lcc.popTriggerExecutionContext(this);
1:         }
1:         if (resultSetVector != null) {
1:             for (ResultSet rs : resultSetVector) {
1:                 try {
1:                     rs.close();
1:                 } catch (SQLException se) {
1:                 }
1:             }
commit:c67f5dd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e22e8dc
/////////////////////////////////////////////////////////////////////////
commit:ca6ed17
/////////////////////////////////////////////////////////////////////////
1: class InternalTriggerExecutionContext
1:         implements TriggerExecutionContext, ExecutionStmtValidator
/////////////////////////////////////////////////////////////////////////
1:     InternalTriggerExecutionContext
commit:44370a8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: 	 * Copy a map of autoincrement values into the trigger 
0: 	public void copyHashtableToAIHT(Map from)
1: 
1: 		aiHT.putAll(from);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     private Vector<ResultSet>   resultSetVector;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     private Vector<AutoincrementCounter> aiCounters;
0:      * aiHT is a hash table of auto increment <key, value> pairs. This is used
1:      * for auto increment values generated by the trigger.
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:      * Build a trigger execution context.
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({"UseOfObsoleteCollectionType", "LeakingThisInConstructor"})
/////////////////////////////////////////////////////////////////////////
1:         Vector<AutoincrementCounter> aiCounters
/////////////////////////////////////////////////////////////////////////
1:                 Long value = aiHT.get(identity);
/////////////////////////////////////////////////////////////////////////
1:             for (AutoincrementCounter aic : aiCounters)
/////////////////////////////////////////////////////////////////////////
1:      * Copy a map of auto increment values into the trigger
1:      * execution context hash table of auto increment values.
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
1:         for (AutoincrementCounter aic : aiCounters)
1:      * Update auto increment counters from the last row inserted.
/////////////////////////////////////////////////////////////////////////
1:         for (AutoincrementCounter aic : aiCounters)
1:     @Override
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:1a36302
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import java.util.Vector;
1: 
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.db.TriggerExecutionContext;
1: import org.apache.derby.iapi.error.PublicAPI;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3b1291b
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// DDL statements are not allowed in triggers. Direct use of DDL
1: 		// statements in a trigger's action statement is disallowed by the
1: 		// parser. However, this runtime check is needed to prevent execution
1: 		// of DDL statements by procedures within a trigger context. 
1:  		if (constantAction instanceof DDLConstantAction) {
1: 		// No INSERT/UPDATE/DELETE for a before trigger. There is no need to 
1:  		// check this here because parser does not allow these DML statements
1:  		// in a trigger's action statement in a before trigger. Parser also 
1:  		// disallows creation of before triggers calling procedures that modify
1:  		// SQL data.   
1: 		
commit:cec114a
/////////////////////////////////////////////////////////////////////////
0: 		// DDL statements are not allowed in triggers. Parser does not allow 
0: 		// DDL statements in a trigger's action statement. This runtime check
0: 		// is needed only for DDL statements executed by procedures within a 
0: 		// trigger context. 
0: 		// No INSERT/UPDATE/DELETE for a before trigger. Parser does not allow 
0: 		// these DML statements in a trigger's action statement in a before 
0: 		// trigger. Currently, parser does not disallow creation of before 
0: 		// triggers calling procedures that modify SQL data. This runtime check
0: 		// is needed to not allow execution of these DML statements by procedures
0: 		// within a before trigger context. 
0: 	 	else if (triggerd.isBeforeTrigger() && 
commit:698f7a2
/////////////////////////////////////////////////////////////////////////
0: 		// DDL statements are not allowed in triggers
0: 		if (constantAction instanceof DDLConstantAction) {
0: 			throw StandardException.newException(SQLState.LANG_NO_DDL_IN_TRIGGER, triggerd.getName(), constantAction.toString());
1: 		
0: 		** No INSERT/UPDATE/DELETE for a before trigger.
0: 			throw StandardException.newException(SQLState.LANG_NO_DML_IN_TRIGGER, triggerd.getName(), targetTableName);
commit:df9af89
/////////////////////////////////////////////////////////////////////////
0: 		for (Enumeration e = resultSetVector.elements();
0: 			 e.hasMoreElements(); )
0: 			java.sql.ResultSet rs = (java.sql.ResultSet)e.nextElement();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.InternalTriggerExecutionContext
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.jdbc.ConnectionContext; 
0: import org.apache.derby.catalog.UUID;
0: import java.util.Enumeration;
0: import java.util.Vector;
1: import java.util.Hashtable;
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.sql.Statement;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: /**
1:  * There is one of these beasts per INSERT/DELETE/UPDATE 
1:  * statement.  It fulfills the contract for the externally
1:  * visible trigger execution context and it validates
1:  * that a statement that is about to be executed doesn't
1:  * violate the restrictions placed upon what can be executed
1:  * from a trigger.
1:  * <p>
1:  * Note that it is crucial that cleanup() is called once
1:  * the DML has completed, cleanup() makes sure that users
1:  * can't do something invalid on a tec reference that they
1:  * were holding from when the trigger fired.
1:  *
1:  */
0: public class InternalTriggerExecutionContext implements TriggerExecutionContext, ExecutionStmtValidator
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1: 	** Immutable
1: 	*/
0: 	protected int[]					changedColIds;
0: 	protected String[]				changedColNames;
1: 	protected int					dmlType;
1: 	protected String				statementText;
1: 	protected ConnectionContext		cc;
1: 	protected UUID					targetTableId;
1: 	protected String				targetTableName;
1: 	protected LanguageConnectionContext lcc;
1: 
1: 	/*
1: 	** Mutable
1: 	*/
1: 	protected CursorResultSet		beforeResultSet;
1: 	protected CursorResultSet		afterResultSet;
1: 
1: 	/**
1: 	 * used exclusively for InsertResultSets which have autoincrement 
1: 	 * columns.
1: 	 */
1: 	protected ExecRow				afterRow;
1: 								
1: 	protected boolean				cleanupCalled;
1: 	protected TriggerEvent			event;
1: 	protected TriggerDescriptor		triggerd;
1: 
1: 	/*
1: 	** Used to track all the result sets we have given out to
1: 	** users.  When the trigger context is no longer valid,
1: 	** we close all the result sets that may be in the user
1: 	** space because they can no longer provide meaningful
1: 	** results.
1: 	*/
0: 	private Vector	resultSetVector;
1: 
1: 	/**
1: 	 * aiCounters is a vector of AutoincrementCounters used to keep state which
1: 	 * might be used by the trigger. This is only used by Insert triggers--
1: 	 * Delete and Update triggers do not use this variable.
1: 	 * 
1: 	 * @see AutoincrementCounter
1: 	 * 
1: 	 */
0: 	private Vector aiCounters;
1: 	
1: 	/**
0: 	 * aiHT is a hashtable of autincrement <key, value> pairs. This is used for
0: 	 * ai values generated by the trigger.
1: 	 */
0: 	private Hashtable aiHT;
1: 
1: 	/**
0: 	 * Build me a big old nasty trigger execution context.
0: 	 * Damnit.
1: 	 * <p>
1: 	 * About the only thing of real interest to outside observers
1: 	 * is that it pushes itself as the trigger execution context
1: 	 * in the lcc.  Be sure to call <i>cleanup()</i> when you
1: 	 * are done, or you will be flogged like the reprobate that
1: 	 * you are.
1: 	 *
1: 	 * @param lcc	the lcc
0: 	 * @param jdbcFactory	the jdbc factory
1: 	 * @param statementText	the text of the statement that caused the
1: 	 *		trigger to fire.  may be null if we are replicating
0: 	 * @param changedColIds	the list of columns that changed.  Null
0: 	 *		for all columns or INSERT/DELETE.
0: 	 * @param changedColNames	the names that correspond to changedColIds
1: 	 * @param targetTableId	the UUID of the table upon which the trigger
1: 	 *		fired
1: 	 * @param targetTableName	the name of the table upon which the trigger
1: 	 *		fired
1: 	 * @param aiCounters		A vector of AutoincrementCounters to keep state
1: 	 * 							of the ai columns in this insert trigger.a
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public InternalTriggerExecutionContext
1: 	(
1: 		LanguageConnectionContext	lcc,
1: 		ConnectionContext			cc,
1: 		String 						statementText,
1: 		int 						dmlType,
0: 		int[]						changedColIds,
0: 		String[]					changedColNames,
1: 		UUID						targetTableId,
1: 		String						targetTableName,
0: 		Vector						aiCounters
1: 	) throws StandardException
1: 	{
1: 		this.dmlType = dmlType;
0: 		this.changedColIds = changedColIds;
0: 		this.changedColNames = changedColNames;
1: 		this.statementText = statementText;
1: 		this.cc = cc;
1: 		this.lcc = lcc;
1: 		this.targetTableId = targetTableId;
1: 		this.targetTableName = targetTableName;
0: 		this.resultSetVector = new Vector();
1: 		this.aiCounters = aiCounters;
1: 
0: 		if (SanityManager.DEBUG)
1: 		{	
0: 			if ((changedColIds == null) != (changedColNames == null))
1: 			{
0: 				SanityManager.THROWASSERT("bad changed cols, "+
0: 					"(changedColsIds == null) = "+(changedColIds == null)+ 
0: 					"  (changedColsNames == null) = "+(changedColNames == null));
1: 			}
0: 			if (changedColIds != null)
1: 			{
0: 				SanityManager.ASSERT(changedColIds.length == changedColNames.length, 
0: 					"different number of changed col ids vs names");
1: 			}
1: 		}
1: 
1: 		lcc.pushTriggerExecutionContext(this);
1: 	}
1: 
1: 	void setBeforeResultSet(CursorResultSet rs)
1: 	{
1: 		beforeResultSet = rs;	
1: 	}
1: 
1: 	void setAfterResultSet(CursorResultSet rs)
1: 	     throws StandardException
1: 	{
1: 		afterResultSet = rs;	
1: 		
1: 		if (aiCounters != null)
1: 		{
1: 			if (triggerd.isRowTrigger())
1: 			{
1: 				// An after row trigger needs to see the "first" row inserted 
1: 				rs.open();
1: 				afterRow = rs.getNextRow();
1: 				rs.close();
1: 			}
1: 			else 
1: 			{
1: 				// after statement trigger needs to look at the last value.
1: 				if (!triggerd.isBeforeTrigger())
1: 					resetAICounters(false);
1: 			}
1: 		}
1: 	}
1: 
1: 	void setCurrentTriggerEvent(TriggerEvent event)
1: 	{
1: 		this.event = event;
1: 	}
1: 
1: 	void clearCurrentTriggerEvent()
1: 	{
1: 		event = null;
1: 	}
1: 
1: 	void setTrigger(TriggerDescriptor triggerd)
1: 	{
1: 		this.triggerd = triggerd;
1: 	}
1: 	
1: 	void clearTrigger() throws StandardException
1: 	{
1: 		event = null;
1: 		triggerd = null;
1: 		if (afterResultSet != null)
1: 		{
1: 			afterResultSet.close();
1: 			afterResultSet = null;
1: 		}
1: 		if (beforeResultSet != null)
1: 		{
1: 			beforeResultSet.close();
1: 			beforeResultSet = null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Cleanup the trigger execution context.  <B>MUST</B>
1: 	 * be called when the caller is done with the trigger
1: 	 * execution context.
1: 	 * <p>
1: 	 * We go to somewhat exaggerated lengths to free up
1: 	 * all our resources here because a user may hold on
1: 	 * to a TEC after it is valid, so we clean everything
1: 	 * up to be on the safe side.
1: 	 *
1: 	 * @exception StandardException on unexpected error
1: 	 */
1: 	protected void cleanup()
1: 		throws StandardException
1: 	{
0: 		lcc.popTriggerExecutionContext(this);
1: 
1: 		/*
1: 		** Explicitly close all result sets that we have
1: 		** given out to the user.  
1: 	 	*/
0: 		for (Enumeration enum = resultSetVector.elements();
0: 			 enum.hasMoreElements(); )
1: 		{
0: 			java.sql.ResultSet rs = (java.sql.ResultSet)enum.nextElement();
1: 			try
1: 			{
1: 				rs.close();
0: 			} catch (SQLException se) {}
1: 		}
1: 		resultSetVector = null;
1: 	
1: 		/*
1: 		** We should have already closed our underlying
1: 		** ExecResultSets by closing the jdbc result sets,
1: 		** but in case we got an error that we caught and
1: 		** ignored, explicitly close them.
1: 		*/	
1: 		if (afterResultSet != null)
1: 		{
1: 			afterResultSet.close();
1: 			afterResultSet = null;
1: 		}
1: 		if (beforeResultSet != null)
1: 		{
1: 			beforeResultSet.close();
1: 			beforeResultSet = null;
1: 		}
1: 
1: 		lcc = null;
1: 		cleanupCalled = true;
1: 	}
1: 
1: 	/**
1: 	 * Make sure that the user isn't trying to get a result
1: 	 * set after we have cleaned up. 
1: 	 */
1: 	private void ensureProperContext() throws SQLException
1: 	{
1: 		if (cleanupCalled)
1: 		{
1: 			throw new SQLException(
1: 				MessageService.getTextMessage(
1: 									SQLState.LANG_STATEMENT_CLOSED_NO_REASON),
1: 									"XCL31",
1: 									ExceptionSeverity.STATEMENT_SEVERITY
1: 									);
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// ExecutionStmtValidator
1: 	//
1: 	/////////////////////////////////////////////////////////
1: 	/**
1: 	 * Make sure that whatever statement is about to be executed
1: 	 * is ok from the context of this trigger.
1: 	 * <p>
1: 	 * Note that we are sub classed in replication for checks
1: 	 * for replication specific language.
1: 	 *
1: 	 * @param constantAction the constant action of the action
1: 	 *	that we are to validate
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void validateStatement(ConstantAction constantAction) throws StandardException
1: 	{
0: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (constantAction instanceof DDLConstantAction)
0: 				SanityManager.THROWASSERT("DDL NOT SUPPORTED IN TRIGGER");
1: 		}
1: 
1: 		/*
0: 		** No INSERT/UPDATE/DELETE on trigger table
0: 		** for a before trigger.
1: 	 	*/
0: 		else if (triggerd.isBeforeTrigger() && 
0: 				constantAction instanceof WriteCursorConstantAction)
1: 		{
0: 			if (constantAction.modifiesTableId(targetTableId))
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_NO_DML_IN_TRIGGER, triggerd.getName(), targetTableName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// TriggerExectionContext
1: 	//
1: 	/////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get the target table name upon which the 
1: 	 * trigger event is declared.
1: 	 *
1: 	 * @return the target table
1: 	 */
1: 	public String getTargetTableName()
1: 	{
1: 		return targetTableName;
1: 	}
1: 
1: 	/**
1: 	 * Get the target table UUID upon which the 
1: 	 * trigger event is declared.
1: 	 *
1: 	 * @return the uuid of the target table
1: 	 */
1: 	public UUID getTargetTableId()
1: 	{
1: 		return targetTableId;
1: 	}
1: 
1: 	/**
1: 	 * Get the type for the event that caused the
1: 	 * trigger to fire.
1: 	 *
1: 	 * @return the event type (e.g. UPDATE_EVENT)
1: 	 */
1: 	public int getEventType()
1: 	{
1: 		return dmlType;
1: 	}
1: 
1: 	/**
1: 	 * Get the text of the statement that caused the
1: 	 * trigger to fire.
1: 	 *
1: 	 * @return the statement text
1: 	 */
1: 	public String getEventStatementText()
1: 	{
1: 		return statementText;
1: 	}
1: 
1: 	/**
0: 	 * Get the columns that have been modified by the statement
0: 	 * that caused this trigger to fire.  If all columns are
0: 	 * modified, will return null (e.g. for INSERT or DELETE will
0: 	 * return null).
1: 	 *
0: 	 * @return an array of Strings
1: 	 */
0: 	public String[] getModifiedColumns()
1: 	{
0: 		return changedColNames;
1: 	}
1: 
1: 	/**
0: 	 * Find out of a column was changed, by column name
1: 	 *
0: 	 * @param columnName the column to check
1:  	 *
0: 	 * @return true if the column was modified by this statement.
0: 	 * Note that this will always return true for INSERT
0: 	 * and DELETE regardless of the column name passed in.
1: 	 */
0: 	public boolean wasColumnModified(String columnName)
1: 	{
0: 		if (changedColNames == null)
1: 		{
0: 			return true;
1: 		}
1: 
0: 		for (int i = 0; i < changedColNames.length; i++)
1: 		{
0: 			if (changedColNames[i].equals(columnName))
1: 			{
0: 				return true;
1: 			}
1: 		}
0: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Find out of a column was changed, by column number
1: 	 *
0: 	 * @param columnNumber the column to check
1:  	 *
0: 	 * @return true if the column was modified by this statement.
0: 	 * Note that this will always return true for INSERT
0: 	 * and DELETE regardless of the column name passed in.
1: 	 */
0: 	public boolean wasColumnModified(int columnNumber)
1: 	{
0: 		if (changedColIds == null)
1: 		{
0: 			return true;
1: 		}
1: 
0: 		for (int i = 0; i < changedColNames.length; i++)
1: 		{
0: 			if (changedColIds[i] == columnNumber)
1: 			{
0: 				return true;
1: 			}
1: 		}
0: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns a result set row the old images of the changed rows.
1: 	 * For a row trigger, the result set will have a single row.  For
1: 	 * a statement trigger, this result set has every row that has
1: 	 * changed or will change.  If a statement trigger does not affect 
1: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
1: 	 * will return false).
1: 	 *
1: 	 * @return the ResultSet containing before images of the rows 
1: 	 * changed by the triggering event.
1: 	 *
1: 	 * @exception SQLException if called after the triggering event has
1: 	 * completed
1: 	 */
1: 	public java.sql.ResultSet getOldRowSet() throws SQLException
1: 	{
1: 		ensureProperContext();
1: 		if (beforeResultSet == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		try
1: 		{
1: 			CursorResultSet brs = beforeResultSet;
1: 			/* We should really shallow clone the result set, because it could be used
1: 			 * at multiple places independently in trigger action.  This is a bug found
1: 			 * during the fix of beetle 4373.
1: 			 */
1: 			if (brs instanceof TemporaryRowHolderResultSet)
1: 				brs = (CursorResultSet) ((TemporaryRowHolderResultSet) brs).clone();
1: 			else if (brs instanceof TableScanResultSet)
1: 				brs = (CursorResultSet) ((TableScanResultSet) brs).clone();
1: 			brs.open();
1: 			java.sql.ResultSet rs = cc.getResultSet(brs);
1: 			resultSetVector.addElement(rs);
1: 			return rs;
1: 		} catch (StandardException se)
1: 		{
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Returns a result set row the new images of the changed rows.
1: 	 * For a row trigger, the result set will have a single row.  For
1: 	 * a statement trigger, this result set has every row that has
1: 	 * changed or will change.  If a statement trigger does not affect 
1: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
1: 	 * will return false).
1: 	 *
1: 	 * @return the ResultSet containing after images of the rows 
1: 	 * changed by the triggering event.
1: 	 *
1: 	 * @exception SQLException if called after the triggering event has
1: 	 * completed
1: 	 */
1: 	public java.sql.ResultSet getNewRowSet() throws SQLException
1: 	{
1: 		ensureProperContext();
1: 
1: 		if (afterResultSet == null)
1: 		{
1: 			return null;
1: 		}
1: 		try
1: 		{
1: 			/* We should really shallow clone the result set, because it could be used
1: 			 * at multiple places independently in trigger action.  This is a bug found
1: 			 * during the fix of beetle 4373.
1: 			 */
1: 			CursorResultSet ars = afterResultSet;
1: 			if (ars instanceof TemporaryRowHolderResultSet)
1: 				ars = (CursorResultSet) ((TemporaryRowHolderResultSet) ars).clone();
1: 			else if (ars instanceof TableScanResultSet)
1: 				ars = (CursorResultSet) ((TableScanResultSet) ars).clone();
1: 			ars.open();
1: 			java.sql.ResultSet rs = cc.getResultSet(ars);
1: 			resultSetVector.addElement(rs);
1: 			return rs;
1: 		} catch (StandardException se)
1: 		{
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Like getBeforeResultSet(), but returns a result set positioned
1: 	 * on the first row of the before result set.  Used as a convenience
1: 	 * to get a column for a row trigger.  Equivalent to getBeforeResultSet()
1: 	 * followed by next().
1: 	 *
1: 	 * @return the ResultSet positioned on the old row image.
1: 	 *
1: 	 * @exception SQLException if called after the triggering event has
1: 	 * completed
1: 	 */
1: 	public java.sql.ResultSet getOldRow() throws SQLException
1: 	{
1: 		java.sql.ResultSet rs = getOldRowSet();
1: 		if (rs != null)
1: 			rs.next();
1: 		
1: 		return rs;
1: 	}
1: 
1: 	/**
1: 	 * Like getAfterResultSet(), but returns a result set positioned
1: 	 * on the first row of the before result set.  Used as a convenience
1: 	 * to get a column for a row trigger.  Equivalent to getAfterResultSet()
1: 	 * followed by next().
1: 	 *
1: 	 * @return the ResultSet positioned on the new row image.
1: 	 *
1: 	 * @exception SQLException if called after the triggering event has
1: 	 * completed
1: 	 */
1: 	public java.sql.ResultSet getNewRow() throws SQLException
1: 	{
1: 		java.sql.ResultSet rs = getNewRowSet();
1: 		if (rs != null)
1: 			rs.next();
1: 		return rs;
1: 	}
1: 	
1: 	public Long getAutoincrementValue(String identity)
1: 	{
1: 		// first search the hashtable-- this represents the ai values generated
1: 		// by this trigger.
1: 		if (aiHT != null)
1: 			{
0: 				Long value = (Long)aiHT.get(identity);
1: 				if (value != null)
1: 					return value;
1: 			}
1: 		
1: 		
1: 		// If we didn't find it in the hashtable search in the counters which
1: 		// represent values inherited by trigger from insert statements.
1: 		if (aiCounters != null)
1: 		{
0: 			for (int i = 0; i < aiCounters.size(); i++)
1: 			{
0: 				AutoincrementCounter aic = 
0: 					(AutoincrementCounter)aiCounters.elementAt(i);
1: 
0: 				//				System.out.println("in itec:getaivalue " + aic);
1: 				if (identity.equals(aic.getIdentity()))
1: 				{
0: 					//					System.out.println("in itec:getvalue--returning " +  aic.getCurrentValue());
1: 					return aic.getCurrentValue();
1: 				}
1: 			}
1: 		}
1: 		
1: 		// didn't find it-- return NULL.
1: 		return null;
1: 	}
1: 	/**
0: 	 * Copy a hashtable of autoincrement values into the trigger 
0: 	 * execution context hashtable of autoincrement values.
1: 	 */
0: 	public void copyHashtableToAIHT(Hashtable from)
1: 	{
1: 		if (from == null)
1: 			return;
1: 		if (aiHT == null)
0: 			aiHT = new Hashtable();
0: 		for (Enumeration e = from.keys(); e.hasMoreElements(); )
1: 		{
0: 			Object key = e.nextElement();
0: 			Object value = from.get(key);
0: 			aiHT.put(key, value);
0: 			//			System.out.println(" in itec:chte-- " + key + " " + value);
1: 		}
1: 	}
1: 		
1: 	/** 
1: 	 * Reset Autoincrement counters to the beginning or the end.
1: 	 * 
1: 	 * @param		begin		if True, reset the AutoincremnetCounter to the
1: 	 *                          beginning-- used to reset the counters for the
1: 	 * 							next trigger. If false, reset it to the end--
1: 	 *                          this sets up the counter appropriately for a
1: 	 *                          AFTER STATEMENT trigger.
1: 	 */
1: 	public void resetAICounters(boolean begin)
1: 	{
1: 		if (aiCounters == null)
1: 			return;
1: 
1: 		afterRow = null;
1: 
0: 		int size = aiCounters.size();
0: 		for (int i = 0; i < size; i++)
1: 		{
0: 			AutoincrementCounter aic = 
0: 				(AutoincrementCounter)aiCounters.elementAt(i);
1: 			aic.reset(begin);
1: 		}
1: 	}	
1: 	
1: 	/**
0: 	 * Update Autoincrement Counters from the last row inserted.
1: 	 *
1: 	 */
1: 	public void updateAICounters() throws StandardException
1: 	{
1: 		if (aiCounters == null)
1: 			return;
1: 
0: 		int size = aiCounters.size();
0: 		for (int i = 0; i < size; i++)
1: 		{
0: 			AutoincrementCounter aic = 
0: 				(AutoincrementCounter)aiCounters.elementAt(i);
1: 			DataValueDescriptor dvd = afterRow.getColumn(aic.getColumnPosition());
1: 			aic.update(dvd.getLong());
1: 		}
1: 	}
1: 
1: 
1: 	public String toString() {
1: 		return triggerd.getName();
1: 	}
1: 
1: 
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.jdbc.ConnectionContext; 
0: import org.apache.derby.catalog.UUID;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: /**
0:  * There is one of these beasts per INSERT/DELETE/UPDATE 
0:  * statement.  It fulfills the contract for the externally
0:  * visible trigger execution context and it validates
0:  * that a statement that is about to be executed doesn't
0:  * violate the restrictions placed upon what can be executed
0:  * from a trigger.
0:  * <p>
0:  * Note that it is crucial that cleanup() is called once
0:  * the DML has completed, cleanup() makes sure that users
0:  * can't do something invalid on a tec reference that they
0:  * were holding from when the trigger fired.
0:  *
0:  */
0: public class InternalTriggerExecutionContext implements TriggerExecutionContext, ExecutionStmtValidator
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0: 	** Immutable
0: 	*/
0: 	protected int[]					changedColIds;
0: 	protected String[]				changedColNames;
0: 	protected int					dmlType;
0: 	protected String				statementText;
0: 	protected ConnectionContext		cc;
0: 	protected UUID					targetTableId;
0: 	protected String				targetTableName;
0: 	protected LanguageConnectionContext lcc;
0: 
0: 	/*
0: 	** Mutable
0: 	*/
0: 	protected CursorResultSet		beforeResultSet;
0: 	protected CursorResultSet		afterResultSet;
0: 
0: 	/**
0: 	 * used exclusively for InsertResultSets which have autoincrement 
0: 	 * columns.
0: 	 */
0: 	protected ExecRow				afterRow;
0: 								
0: 	protected boolean				cleanupCalled;
0: 	protected TriggerEvent			event;
0: 	protected TriggerDescriptor		triggerd;
0: 
0: 	/*
0: 	** Used to track all the result sets we have given out to
0: 	** users.  When the trigger context is no longer valid,
0: 	** we close all the result sets that may be in the user
0: 	** space because they can no longer provide meaningful
0: 	** results.
0: 	*/
0: 	private Vector	resultSetVector;
0: 
0: 	/**
0: 	 * aiCounters is a vector of AutoincrementCounters used to keep state which
0: 	 * might be used by the trigger. This is only used by Insert triggers--
0: 	 * Delete and Update triggers do not use this variable.
0: 	 * 
0: 	 * @see AutoincrementCounter
0: 	 * 
0: 	 */
0: 	private Vector aiCounters;
0: 	
0: 	/**
0: 	 * aiHT is a hashtable of autincrement <key, value> pairs. This is used for
0: 	 * ai values generated by the trigger.
0: 	 */
0: 	private Hashtable aiHT;
0: 
0: 	/**
0: 	 * Build me a big old nasty trigger execution context.
0: 	 * Damnit.
0: 	 * <p>
0: 	 * About the only thing of real interest to outside observers
0: 	 * is that it pushes itself as the trigger execution context
0: 	 * in the lcc.  Be sure to call <i>cleanup()</i> when you
0: 	 * are done, or you will be flogged like the reprobate that
0: 	 * you are.
0: 	 *
0: 	 * @param lcc	the lcc
0: 	 * @param jdbcFactory	the jdbc factory
0: 	 * @param statementText	the text of the statement that caused the
0: 	 *		trigger to fire.  may be null if we are replicating
0: 	 * @param changedColIds	the list of columns that changed.  Null
0: 	 *		for all columns or INSERT/DELETE.
0: 	 * @param changedColNames	the names that correspond to changedColIds
0: 	 * @param targetTableId	the UUID of the table upon which the trigger
0: 	 *		fired
0: 	 * @param targetTableName	the name of the table upon which the trigger
0: 	 *		fired
0: 	 * @param aiCounters		A vector of AutoincrementCounters to keep state
0: 	 * 							of the ai columns in this insert trigger.a
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public InternalTriggerExecutionContext
0: 	(
0: 		LanguageConnectionContext	lcc,
0: 		ConnectionContext			cc,
0: 		String 						statementText,
0: 		int 						dmlType,
0: 		int[]						changedColIds,
0: 		String[]					changedColNames,
0: 		UUID						targetTableId,
0: 		String						targetTableName,
0: 		Vector						aiCounters
0: 	) throws StandardException
0: 	{
0: 		this.dmlType = dmlType;
0: 		this.changedColIds = changedColIds;
0: 		this.changedColNames = changedColNames;
0: 		this.statementText = statementText;
0: 		this.cc = cc;
0: 		this.lcc = lcc;
0: 		this.targetTableId = targetTableId;
0: 		this.targetTableName = targetTableName;
0: 		this.resultSetVector = new Vector();
0: 		this.aiCounters = aiCounters;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{	
0: 			if ((changedColIds == null) != (changedColNames == null))
0: 			{
0: 				SanityManager.THROWASSERT("bad changed cols, "+
0: 					"(changedColsIds == null) = "+(changedColIds == null)+ 
0: 					"  (changedColsNames == null) = "+(changedColNames == null));
0: 			}
0: 			if (changedColIds != null)
0: 			{
0: 				SanityManager.ASSERT(changedColIds.length == changedColNames.length, 
0: 					"different number of changed col ids vs names");
0: 			}
0: 		}
0: 
0: 		lcc.pushTriggerExecutionContext(this);
0: 	}
0: 
0: 	void setBeforeResultSet(CursorResultSet rs)
0: 	{
0: 		beforeResultSet = rs;	
0: 	}
0: 
0: 	void setAfterResultSet(CursorResultSet rs)
0: 	     throws StandardException
0: 	{
0: 		afterResultSet = rs;	
0: 		
0: 		if (aiCounters != null)
0: 		{
0: 			if (triggerd.isRowTrigger())
0: 			{
0: 				// An after row trigger needs to see the "first" row inserted 
0: 				rs.open();
0: 				afterRow = rs.getNextRow();
0: 				rs.close();
0: 			}
0: 			else 
0: 			{
0: 				// after statement trigger needs to look at the last value.
0: 				if (!triggerd.isBeforeTrigger())
0: 					resetAICounters(false);
0: 			}
0: 		}
0: 	}
0: 
0: 	void setCurrentTriggerEvent(TriggerEvent event)
0: 	{
0: 		this.event = event;
0: 	}
0: 
0: 	void clearCurrentTriggerEvent()
0: 	{
0: 		event = null;
0: 	}
0: 
0: 	void setTrigger(TriggerDescriptor triggerd)
0: 	{
0: 		this.triggerd = triggerd;
0: 	}
0: 	
0: 	void clearTrigger() throws StandardException
0: 	{
0: 		event = null;
0: 		triggerd = null;
0: 		if (afterResultSet != null)
0: 		{
0: 			afterResultSet.close();
0: 			afterResultSet = null;
0: 		}
0: 		if (beforeResultSet != null)
0: 		{
0: 			beforeResultSet.close();
0: 			beforeResultSet = null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Cleanup the trigger execution context.  <B>MUST</B>
0: 	 * be called when the caller is done with the trigger
0: 	 * execution context.
0: 	 * <p>
0: 	 * We go to somewhat exaggerated lengths to free up
0: 	 * all our resources here because a user may hold on
0: 	 * to a TEC after it is valid, so we clean everything
0: 	 * up to be on the safe side.
0: 	 *
0: 	 * @exception StandardException on unexpected error
0: 	 */
0: 	protected void cleanup()
0: 		throws StandardException
0: 	{
0: 		lcc.popTriggerExecutionContext(this);
0: 
0: 		/*
0: 		** Explicitly close all result sets that we have
0: 		** given out to the user.  
0: 	 	*/
0: 		for (Enumeration enum = resultSetVector.elements();
0: 			 enum.hasMoreElements(); )
0: 		{
0: 			java.sql.ResultSet rs = (java.sql.ResultSet)enum.nextElement();
0: 			try
0: 			{
0: 				rs.close();
0: 			} catch (SQLException se) {}
0: 		}
0: 		resultSetVector = null;
0: 	
0: 		/*
0: 		** We should have already closed our underlying
0: 		** ExecResultSets by closing the jdbc result sets,
0: 		** but in case we got an error that we caught and
0: 		** ignored, explicitly close them.
0: 		*/	
0: 		if (afterResultSet != null)
0: 		{
0: 			afterResultSet.close();
0: 			afterResultSet = null;
0: 		}
0: 		if (beforeResultSet != null)
0: 		{
0: 			beforeResultSet.close();
0: 			beforeResultSet = null;
0: 		}
0: 
0: 		lcc = null;
0: 		cleanupCalled = true;
0: 	}
0: 
0: 	/**
0: 	 * Make sure that the user isn't trying to get a result
0: 	 * set after we have cleaned up. 
0: 	 */
0: 	private void ensureProperContext() throws SQLException
0: 	{
0: 		if (cleanupCalled)
0: 		{
0: 			throw new SQLException(
0: 				MessageService.getTextMessage(
0: 									SQLState.LANG_STATEMENT_CLOSED_NO_REASON),
0: 									"XCL31",
0: 									ExceptionSeverity.STATEMENT_SEVERITY
0: 									);
0: 		}
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// ExecutionStmtValidator
0: 	//
0: 	/////////////////////////////////////////////////////////
0: 	/**
0: 	 * Make sure that whatever statement is about to be executed
0: 	 * is ok from the context of this trigger.
0: 	 * <p>
0: 	 * Note that we are sub classed in replication for checks
0: 	 * for replication specific language.
0: 	 *
0: 	 * @param constantAction the constant action of the action
0: 	 *	that we are to validate
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void validateStatement(ConstantAction constantAction) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (constantAction instanceof DDLConstantAction)
0: 				SanityManager.THROWASSERT("DDL NOT SUPPORTED IN TRIGGER");
0: 		}
0: 
0: 		/*
0: 		** No INSERT/UPDATE/DELETE on trigger table
0: 		** for a before trigger.
0: 	 	*/
0: 		else if (triggerd.isBeforeTrigger() && 
0: 				constantAction instanceof WriteCursorConstantAction)
0: 		{
0: 			if (constantAction.modifiesTableId(targetTableId))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_NO_DML_IN_TRIGGER, triggerd.getName(), targetTableName);
0: 			}
0: 		}
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// TriggerExectionContext
0: 	//
0: 	/////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Get the target table name upon which the 
0: 	 * trigger event is declared.
0: 	 *
0: 	 * @return the target table
0: 	 */
0: 	public String getTargetTableName()
0: 	{
0: 		return targetTableName;
0: 	}
0: 
0: 	/**
0: 	 * Get the target table UUID upon which the 
0: 	 * trigger event is declared.
0: 	 *
0: 	 * @return the uuid of the target table
0: 	 */
0: 	public UUID getTargetTableId()
0: 	{
0: 		return targetTableId;
0: 	}
0: 
0: 	/**
0: 	 * Get the type for the event that caused the
0: 	 * trigger to fire.
0: 	 *
0: 	 * @return the event type (e.g. UPDATE_EVENT)
0: 	 */
0: 	public int getEventType()
0: 	{
0: 		return dmlType;
0: 	}
0: 
0: 	/**
0: 	 * Get the text of the statement that caused the
0: 	 * trigger to fire.
0: 	 *
0: 	 * @return the statement text
0: 	 */
0: 	public String getEventStatementText()
0: 	{
0: 		return statementText;
0: 	}
0: 
0: 	/**
0: 	 * Get the columns that have been modified by the statement
0: 	 * that caused this trigger to fire.  If all columns are
0: 	 * modified, will return null (e.g. for INSERT or DELETE will
0: 	 * return null).
0: 	 *
0: 	 * @return an array of Strings
0: 	 */
0: 	public String[] getModifiedColumns()
0: 	{
0: 		return changedColNames;
0: 	}
0: 
0: 	/**
0: 	 * Find out of a column was changed, by column name
0: 	 *
0: 	 * @param columnName the column to check
0:  	 *
0: 	 * @return true if the column was modified by this statement.
0: 	 * Note that this will always return true for INSERT
0: 	 * and DELETE regardless of the column name passed in.
0: 	 */
0: 	public boolean wasColumnModified(String columnName)
0: 	{
0: 		if (changedColNames == null)
0: 		{
0: 			return true;
0: 		}
0: 
0: 		for (int i = 0; i < changedColNames.length; i++)
0: 		{
0: 			if (changedColNames[i].equals(columnName))
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Find out of a column was changed, by column number
0: 	 *
0: 	 * @param columnNumber the column to check
0:  	 *
0: 	 * @return true if the column was modified by this statement.
0: 	 * Note that this will always return true for INSERT
0: 	 * and DELETE regardless of the column name passed in.
0: 	 */
0: 	public boolean wasColumnModified(int columnNumber)
0: 	{
0: 		if (changedColIds == null)
0: 		{
0: 			return true;
0: 		}
0: 
0: 		for (int i = 0; i < changedColNames.length; i++)
0: 		{
0: 			if (changedColIds[i] == columnNumber)
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Returns a result set row the old images of the changed rows.
0: 	 * For a row trigger, the result set will have a single row.  For
0: 	 * a statement trigger, this result set has every row that has
0: 	 * changed or will change.  If a statement trigger does not affect 
0: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
0: 	 * will return false).
0: 	 *
0: 	 * @return the ResultSet containing before images of the rows 
0: 	 * changed by the triggering event.
0: 	 *
0: 	 * @exception SQLException if called after the triggering event has
0: 	 * completed
0: 	 */
0: 	public java.sql.ResultSet getOldRowSet() throws SQLException
0: 	{
0: 		ensureProperContext();
0: 		if (beforeResultSet == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		try
0: 		{
0: 			CursorResultSet brs = beforeResultSet;
0: 			/* We should really shallow clone the result set, because it could be used
0: 			 * at multiple places independently in trigger action.  This is a bug found
0: 			 * during the fix of beetle 4373.
0: 			 */
0: 			if (brs instanceof TemporaryRowHolderResultSet)
0: 				brs = (CursorResultSet) ((TemporaryRowHolderResultSet) brs).clone();
0: 			else if (brs instanceof TableScanResultSet)
0: 				brs = (CursorResultSet) ((TableScanResultSet) brs).clone();
0: 			brs.open();
0: 			java.sql.ResultSet rs = cc.getResultSet(brs);
0: 			resultSetVector.addElement(rs);
0: 			return rs;
0: 		} catch (StandardException se)
0: 		{
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Returns a result set row the new images of the changed rows.
0: 	 * For a row trigger, the result set will have a single row.  For
0: 	 * a statement trigger, this result set has every row that has
0: 	 * changed or will change.  If a statement trigger does not affect 
0: 	 * a row, then the result set will be empty (i.e. ResultSet.next()
0: 	 * will return false).
0: 	 *
0: 	 * @return the ResultSet containing after images of the rows 
0: 	 * changed by the triggering event.
0: 	 *
0: 	 * @exception SQLException if called after the triggering event has
0: 	 * completed
0: 	 */
0: 	public java.sql.ResultSet getNewRowSet() throws SQLException
0: 	{
0: 		ensureProperContext();
0: 
0: 		if (afterResultSet == null)
0: 		{
0: 			return null;
0: 		}
0: 		try
0: 		{
0: 			/* We should really shallow clone the result set, because it could be used
0: 			 * at multiple places independently in trigger action.  This is a bug found
0: 			 * during the fix of beetle 4373.
0: 			 */
0: 			CursorResultSet ars = afterResultSet;
0: 			if (ars instanceof TemporaryRowHolderResultSet)
0: 				ars = (CursorResultSet) ((TemporaryRowHolderResultSet) ars).clone();
0: 			else if (ars instanceof TableScanResultSet)
0: 				ars = (CursorResultSet) ((TableScanResultSet) ars).clone();
0: 			ars.open();
0: 			java.sql.ResultSet rs = cc.getResultSet(ars);
0: 			resultSetVector.addElement(rs);
0: 			return rs;
0: 		} catch (StandardException se)
0: 		{
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Like getBeforeResultSet(), but returns a result set positioned
0: 	 * on the first row of the before result set.  Used as a convenience
0: 	 * to get a column for a row trigger.  Equivalent to getBeforeResultSet()
0: 	 * followed by next().
0: 	 *
0: 	 * @return the ResultSet positioned on the old row image.
0: 	 *
0: 	 * @exception SQLException if called after the triggering event has
0: 	 * completed
0: 	 */
0: 	public java.sql.ResultSet getOldRow() throws SQLException
0: 	{
0: 		java.sql.ResultSet rs = getOldRowSet();
0: 		if (rs != null)
0: 			rs.next();
0: 		
0: 		return rs;
0: 	}
0: 
0: 	/**
0: 	 * Like getAfterResultSet(), but returns a result set positioned
0: 	 * on the first row of the before result set.  Used as a convenience
0: 	 * to get a column for a row trigger.  Equivalent to getAfterResultSet()
0: 	 * followed by next().
0: 	 *
0: 	 * @return the ResultSet positioned on the new row image.
0: 	 *
0: 	 * @exception SQLException if called after the triggering event has
0: 	 * completed
0: 	 */
0: 	public java.sql.ResultSet getNewRow() throws SQLException
0: 	{
0: 		java.sql.ResultSet rs = getNewRowSet();
0: 		if (rs != null)
0: 			rs.next();
0: 		return rs;
0: 	}
0: 	
0: 	public Long getAutoincrementValue(String identity)
0: 	{
0: 		// first search the hashtable-- this represents the ai values generated
0: 		// by this trigger.
0: 		if (aiHT != null)
0: 			{
0: 				Long value = (Long)aiHT.get(identity);
0: 				if (value != null)
0: 					return value;
0: 			}
0: 		
0: 		
0: 		// If we didn't find it in the hashtable search in the counters which
0: 		// represent values inherited by trigger from insert statements.
0: 		if (aiCounters != null)
0: 		{
0: 			for (int i = 0; i < aiCounters.size(); i++)
0: 			{
0: 				AutoincrementCounter aic = 
0: 					(AutoincrementCounter)aiCounters.elementAt(i);
0: 
0: 				//				System.out.println("in itec:getaivalue " + aic);
0: 				if (identity.equals(aic.getIdentity()))
0: 				{
0: 					//					System.out.println("in itec:getvalue--returning " +  aic.getCurrentValue());
0: 					return aic.getCurrentValue();
0: 				}
0: 			}
0: 		}
0: 		
0: 		// didn't find it-- return NULL.
0: 		return null;
0: 	}
0: 	/**
0: 	 * Copy a hashtable of autoincrement values into the trigger 
0: 	 * execution context hashtable of autoincrement values.
0: 	 */
0: 	public void copyHashtableToAIHT(Hashtable from)
0: 	{
0: 		if (from == null)
0: 			return;
0: 		if (aiHT == null)
0: 			aiHT = new Hashtable();
0: 		for (Enumeration e = from.keys(); e.hasMoreElements(); )
0: 		{
0: 			Object key = e.nextElement();
0: 			Object value = from.get(key);
0: 			aiHT.put(key, value);
0: 			//			System.out.println(" in itec:chte-- " + key + " " + value);
0: 		}
0: 	}
0: 		
0: 	/** 
0: 	 * Reset Autoincrement counters to the beginning or the end.
0: 	 * 
0: 	 * @param		begin		if True, reset the AutoincremnetCounter to the
0: 	 *                          beginning-- used to reset the counters for the
0: 	 * 							next trigger. If false, reset it to the end--
0: 	 *                          this sets up the counter appropriately for a
0: 	 *                          AFTER STATEMENT trigger.
0: 	 */
0: 	public void resetAICounters(boolean begin)
0: 	{
0: 		if (aiCounters == null)
0: 			return;
0: 
0: 		afterRow = null;
0: 
0: 		int size = aiCounters.size();
0: 		for (int i = 0; i < size; i++)
0: 		{
0: 			AutoincrementCounter aic = 
0: 				(AutoincrementCounter)aiCounters.elementAt(i);
0: 			aic.reset(begin);
0: 		}
0: 	}	
0: 	
0: 	/**
0: 	 * Update Autoincrement Counters from the last row inserted.
0: 	 *
0: 	 */
0: 	public void updateAICounters() throws StandardException
0: 	{
0: 		if (aiCounters == null)
0: 			return;
0: 
0: 		int size = aiCounters.size();
0: 		for (int i = 0; i < size; i++)
0: 		{
0: 			AutoincrementCounter aic = 
0: 				(AutoincrementCounter)aiCounters.elementAt(i);
0: 			DataValueDescriptor dvd = afterRow.getColumn(aic.getColumnPosition());
0: 			aic.update(dvd.getLong());
0: 		}
0: 	}
0: 
0: 
0: 	public String toString() {
0: 		return triggerd.getName();
0: 	}
0: 
0: 
0: }
============================================================================