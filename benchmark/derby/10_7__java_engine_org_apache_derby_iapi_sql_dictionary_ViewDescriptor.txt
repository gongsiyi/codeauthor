1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.ViewDescriptor
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
13:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.Dependent;
1:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.catalog.DependableFinder;
1:eac0369: import org.apache.derby.catalog.Dependable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * This is the implementation of ViewDescriptor. Users of View descriptors
1:eac0369:  * should only use the following methods:
1:eac0369:  * <ol>
1:eac0369:  * <li> getUUID
1:eac0369:  * <li> setUUID
1:eac0369:  * <li> getViewText
1:eac0369:  * <li> setViewName
1:eac0369:  * <li> getCheckOptionType
1:eac0369:  * <li> getCompSchemaId
1:eac0369:  * </ol>
3:eac0369:  *
1:eac0369:  * @version 0.1
1:eac0369:  */
1:eac0369: 
1:f2fad75: public final class ViewDescriptor extends UniqueTupleDescriptor
1:f2fad75: 	implements Dependent, Provider
5:eac0369: {
1:feb5bb2: 	private final int			checkOption;
1:eac0369: 	private String		viewName;
1:feb5bb2: 	private final String		viewText;
1:eac0369: 	private UUID		uuid;
1:feb5bb2: 	private final UUID		compSchemaId;
1:eac0369: 
1:eac0369: 	public static final	int NO_CHECK_OPTION = 0;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a ViewDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1:eac0369: 	 * @param viewID	The UUID for the view
1:eac0369: 	 * @param viewName	The name of the view
1:eac0369: 	 * @param viewText	The text of the query expression from the view definition.
1:eac0369: 	 * @param checkOption	int check option type
1:eac0369: 	 * @param compSchemaId	the schemaid to compile in
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public ViewDescriptor(DataDictionary dataDictionary, UUID viewID, String viewName, String viewText, 
1:eac0369: 							  int checkOption, UUID compSchemaId)
1:eac0369: 	{
1:eac0369: 		super( dataDictionary );
1:eac0369: 
1:eac0369: 		uuid = viewID;
1:eac0369: 		this.viewText = viewText;
1:eac0369: 		this.viewName = viewName;
1:eac0369: 
1:eac0369: 		/* RESOLVE - No check options for now */
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (checkOption != ViewDescriptor.NO_CHECK_OPTION)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("checkOption (" + checkOption +
1:eac0369: 				") expected to be " + ViewDescriptor.NO_CHECK_OPTION);
4:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		this.checkOption = checkOption;
1:eac0369: 		this.compSchemaId = compSchemaId;
1:eac0369: 	}
1:eac0369: 
1:f8fa8cf: 	//
1:eac0369: 	// ViewDescriptor interface
2:eac0369: 	//
1:eac0369: 
1:398a043: 	/**
1:eac0369: 	 * Gets the UUID of the view.
1:eac0369: 	 *
1:eac0369: 	 * @return	The UUID of the view.
1:eac0369: 	 */
1:eac0369: 	public UUID	getUUID()
1:eac0369: 	{
1:eac0369: 		return uuid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the UUID of the view.
1:eac0369: 	 *
1:eac0369: 	 * @param uuid	The UUID of the view.
1:eac0369: 	 */
1:eac0369: 	public void	setUUID(UUID uuid)
1:eac0369: 	{
1:eac0369: 		this.uuid = uuid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the text of the view definition.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String containing the text of the CREATE VIEW
1:eac0369: 	 *		statement that created the view
1:eac0369: 	 */
1:eac0369: 	public String	getViewText()
1:eac0369: 	{
1:eac0369: 		return viewText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the name of the view.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The name of the view.
1:eac0369: 	 */
1:eac0369: 	public void	setViewName(String name)
1:eac0369: 	{
1:eac0369: 		viewName = name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets an identifier telling what type of check option
1:eac0369: 	 * is on this view.
1:eac0369: 	 *
1:eac0369: 	 * @return	An identifier telling what type of check option
1:eac0369: 	 *			is on the view.
1:eac0369: 	 */
1:eac0369: 	public int	getCheckOptionType()
1:eac0369: 	{
1:eac0369: 		return checkOption;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the compilation type schema id when this view
1:eac0369: 	 * was first bound.
1:eac0369: 	 *
1:eac0369: 	 * @return the schema UUID
1:eac0369: 	 */
1:eac0369: 	public UUID getCompSchemaId()
1:eac0369: 	{
1:eac0369: 		return compSchemaId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Provider interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 		@return the stored form of this provider
1:eac0369: 
1:eac0369: 			@see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public DependableFinder getDependableFinder()
1:eac0369: 	{
1:eac0369: 	    return getDependableFinder(StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Provider.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this provider.
1:eac0369: 	 */
1:eac0369: 	public String getObjectName()
1:eac0369: 	{
1:eac0369: 		return viewName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's UUID 
1:eac0369: 	 *
1:eac0369: 	 * @return String	The provider's UUID
1:eac0369: 	 */
1:eac0369: 	public UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return uuid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's type.
1:eac0369: 	 *
1:eac0369: 	 * @return String		The provider's type.
1:eac0369: 	 */
1:eac0369: 	public String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.VIEW;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Dependent Inteface
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 		Check that all of the dependent's dependencies are valid.
1:eac0369: 
1:eac0369: 		@return true if the dependent is currently valid
1:eac0369: 	 */
1:eac0369: 	public boolean isValid()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Prepare to mark the dependent as invalid (due to at least one of
1:eac0369: 		its dependencies being invalid).
1:eac0369: 
1:eac0369: 		@param action	The action causing the invalidation
1:eac0369: 		@param p		the provider
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public void prepareToInvalidate(Provider p, int action,
1:eac0369: 					LanguageConnectionContext lcc) 
3:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		switch ( action )
1:eac0369: 		{
1:eac0369: 			/*
2:eac0369: 			 * We don't care about creating or dropping indexes or
1:eac0369: 			 * alter table on an underlying table.
1:eac0369: 			 */
1:eac0369: 		    case DependencyManager.CREATE_INDEX:
1:eac0369: 		    case DependencyManager.DROP_INDEX:
1:ee5857f: 		    case DependencyManager.DROP_COLUMN:
1:eac0369: 		    case DependencyManager.CREATE_CONSTRAINT:
1:eac0369: 		    case DependencyManager.ALTER_TABLE:
1:eac0369: 		    case DependencyManager.CREATE_TRIGGER:
1:eac0369: 		    case DependencyManager.DROP_TRIGGER:
1:eac0369: 
1:eac0369: 		    case DependencyManager.BULK_INSERT:
1:eac0369: 		    case DependencyManager.COMPRESS_TABLE:
1:eac0369: 		    case DependencyManager.RENAME_INDEX:
1:eac0369: 			case DependencyManager.UPDATE_STATISTICS:
1:eac0369: 			case DependencyManager.DROP_STATISTICS:
1:eac0369: 			case DependencyManager.TRUNCATE_TABLE:
1:eac0369: 			/*
1:eac0369: 			** Set constriants is a bit odd in that it
1:eac0369: 			** will send a SET_CONSTRAINTS on the table
1:eac0369: 			** when it enables a constraint, rather than
1:eac0369: 			** on the constraint.  So since we depend on
1:eac0369: 			** the table, we have to deal with this action.
1:eac0369: 			*/
1:eac0369: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1:eac0369: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1:71408ab: 			//When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1:71408ab: 			//types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1:71408ab: 			//don't do anything here. Later in makeInvalid method, we make  
1:71408ab: 			//the ViewDescriptor drop itself. 
1:08313de: 		    case DependencyManager.REVOKE_PRIVILEGE:
1:ee5857f: 
1:eb38311: 			// When a role grant is revoked, any a view dependent on priviliges
1:eb38311: 			// obtained through that role grant will dropped. We don't do
1:eb38311: 			// anything here. Later in makeInvalid method, we make the
1:eb38311: 			// ViewDescriptor drop itself.
1:eb38311: 			case DependencyManager.REVOKE_ROLE:
1:763e014: 
1:e4caed2: 			// Only used by Activations
1:e4caed2: 		    case DependencyManager.RECHECK_PRIVILEGES:
1:763e014: 
1:e4caed2: 				break;
1:763e014: 				// When REVOKE_PRIVILEGE gets sent to a
1:763e014: 				// TablePermsDescriptor we must also send
1:763e014: 				// INTERNAL_RECOMPILE_REQUEST to its Dependents which
1:763e014: 				// may be GPSs needing re-compilation. But Dependents
1:763e014: 				// could also be ViewDescriptors, which then also need
1:763e014: 				// to handle this event.
1:763e014: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:08313de: 		    	break;
1:e4caed2: 
1:71408ab: 			//Notice that REVOKE_PRIVILEGE_RESTRICT is not caught earlier.
1:71408ab: 		    //It gets handled in this default: action where an exception
1:71408ab: 		    //will be thrown. This is because, if such an invalidation 
1:71408ab: 		    //action type is ever received by a dependent, the dependent 
1:71408ab: 		    //show throw an exception.
1:71408ab: 			//In Derby, at this point, REVOKE_PRIVILEGE_RESTRICT gets sent
1:71408ab: 		    //when execute privilege on a routine is getting revoked.
1:ee5857f: 		    // DROP_COLUMN_RESTRICT is similar. Any case which arrives
1:ee5857f: 		    // at this default: statement causes the exception to be
1:ee5857f: 		    // thrown, indicating that the DDL modification should be
1:ee5857f: 		    // rejected because a view is dependent on the underlying
1:ee5857f: 		    // object (table, column, privilege, etc.)
2:eac0369: 		    default:
1:e4caed2: 
1:eac0369: 				DependencyManager dm;
1:eb38311: 
1:eac0369: 				dm = getDataDictionary().getDependencyManager();
1:eac0369: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_VIEW, 
1:eac0369: 					dm.getActionString(action), 
1:eac0369: 					p.getObjectName(), viewName);
1:76faa49: 
1:eac0369: 		}	// end switch
1:eac0369: 	}
1:76faa49: 
1:eac0369: 	/**
1:eac0369: 		Mark the dependent as invalid (due to at least one of
1:eac0369: 		its dependencies being invalid).
1:eac0369: 
1:eac0369: 		@param	action	The action causing the invalidation
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		switch ( action )
1:eac0369: 		{
1:71408ab: 			/* We don't care about creating or dropping indexes or
1:eac0369: 			 * alter table on an underlying table.
1:eac0369: 			 */
1:eac0369: 		    case DependencyManager.CREATE_INDEX:
1:eac0369: 		    case DependencyManager.DROP_INDEX:
1:eac0369: 		    case DependencyManager.ALTER_TABLE:
1:eac0369: 		    case DependencyManager.CREATE_CONSTRAINT:
1:eac0369: 		    case DependencyManager.BULK_INSERT:
1:eac0369: 		    case DependencyManager.COMPRESS_TABLE:
1:eac0369: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1:eac0369: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1:eac0369: 		    case DependencyManager.CREATE_TRIGGER:
1:eac0369: 		    case DependencyManager.DROP_TRIGGER:
1:eac0369: 		    case DependencyManager.RENAME_INDEX:
1:eac0369: 			case DependencyManager.UPDATE_STATISTICS:
1:eac0369: 			case DependencyManager.DROP_STATISTICS:
1:eac0369: 			case DependencyManager.TRUNCATE_TABLE:
1:eac0369: 
1:e4caed2: 				// Only used by Activations
1:e4caed2: 			case DependencyManager.RECHECK_PRIVILEGES:
1:eac0369: 
1:763e014: 				// When REVOKE_PRIVILEGE gets sent to a
1:763e014: 				// TablePermsDescriptor we must also send
1:763e014: 				// INTERNAL_RECOMPILE_REQUEST to its Dependents which
1:763e014: 				// may be GPSs needing re-compilation. But Dependents
1:763e014: 				// could also be ViewDescriptors, which then also need
1:763e014: 				// to handle this event.
1:763e014: 		    case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
3:eac0369: 				break;
1:eac0369: 
1:e4caed2: 				// When REVOKE_PRIVILEGE gets sent (this happens for privilege
1:e4caed2: 				// types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER),
1:e4caed2: 				// we make the ViewDescriptor drop itself. REVOKE_ROLE also
1:e4caed2: 				// drops the dependent view.
1:ee5857f:             case DependencyManager.DROP_COLUMN:
1:76faa49: 		    case DependencyManager.REVOKE_PRIVILEGE:
1:e4caed2: 			case DependencyManager.REVOKE_ROLE:
1:398a043:                 
1:398a043:                 TableDescriptor td = 
1:398a043:                         getDataDictionary().getTableDescriptor(uuid);
1:398a043:                 
1:398a043:                 if (td == null) { 
1:398a043:                     // DERBY-5567 already dropped via another dependency 
1:398a043:                     break;
1:398a043:                 }
1:398a043:                 
1:398a043:                 // DERBY-5567 keep original action
1:398a043:                 drop(lcc, td.getSchemaDescriptor(), td, action);
1:eac0369: 
1:ee5857f:                 lcc.getLastActivation().addWarning(
1:ee5857f:                         StandardException.newWarning(
1:ee5857f:                         SQLState.LANG_VIEW_DROPPED,
1:ee5857f:                         this.getObjectName() ));
1:398a043:                 break;
1:eac0369: 
1:398a043:             default:
1:eac0369: 
1:eac0369: 				/* We should never get here, since we can't have dangling references */
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("did not expect to get called");
1:eac0369: 				}
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 		}	// end switch
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the contents of the ViewDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @return The contents as a String
1:eac0369: 	 */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return	"uuid: " + uuid + " viewName: " + viewName + "\n" +
1:eac0369: 				"viewText: " + viewText + "\n" +
1:eac0369: 				"checkOption: " + checkOption + "\n" +
1:eac0369: 				"compSchemaId: " + compSchemaId + "\n";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:398a043:      * Drop this descriptor, if not already done.
1:398a043:      * 
1:398a043:      * @param lcc current language connection context
1:398a043:      * @param sd schema descriptor
1:398a043:      * @param td table descriptor for this view
1:398a043:      * @throws StandardException standard error policy
1:398a043:      */
1:398a043:     public void drop(
1:398a043:             LanguageConnectionContext lcc,
1:398a043:             SchemaDescriptor sd,
1:398a043:             TableDescriptor td) throws StandardException
1:398a043:     {
1:398a043:         drop(lcc, sd, td, DependencyManager.DROP_VIEW);
1:398a043:     }
1:398a043: 
1:398a043:     /**
1:398a043:      * Drop this descriptor, if not already done, due to action.
1:398a043:      * If action is not {@code DependencyManager.DROP_VIEW}, the descriptor is 
1:398a043:      * dropped due to dropping some other object, e.g. a table column.
1:398a043:      * 
1:398a043:      * @param lcc current language connection context
1:398a043:      * @param sd schema descriptor
1:398a043:      * @param td table descriptor for this view
1:398a043:      * @param action action
1:398a043:      * @throws StandardException standard error policy
1:398a043:      */
1:398a043:     private void drop(
1:398a043:             LanguageConnectionContext lcc,
1:398a043:             SchemaDescriptor sd,
1:398a043:             TableDescriptor td,
1:398a043:             int action) throws StandardException
1:398a043:     {
1:9213b42:         DataDictionary dd = getDataDictionary();
1:9213b42:         DependencyManager dm = dd.getDependencyManager();
1:9213b42:         TransactionController tc = lcc.getTransactionExecute();
1:398a043: 
1:eac0369: 		/* Drop the columns */
1:eac0369: 		dd.dropAllColumnDescriptors(td.getUUID(), tc);
1:9213b42: 
1:eac0369: 		/* Prepare all dependents to invalidate.  (This is there chance
1:eac0369: 		 * to say that they can't be invalidated.  For example, an open
1:eac0369: 		 * cursor referencing a table/view that the user is attempting to
1:eac0369: 		 * drop.) If no one objects, then invalidate any dependent objects.
1:eac0369: 		 */
1:398a043:         dm.invalidateFor(td, action, lcc);
1:eac0369: 
1:eac0369: 		/* Clear the dependencies for the view */
1:eac0369: 		dm.clearDependencies(lcc, this);
1:eac0369: 
1:eac0369: 		/* Drop the view */
1:eac0369: 		dd.dropViewDescriptor(this, tc);
1:eac0369: 
1:b7e13a9: 		/* Drop all table and column permission descriptors */
1:b7e13a9: 		dd.dropAllTableAndColPermDescriptors(td.getUUID(), tc);
1:eac0369: 
1:eac0369: 		/* Drop the table */
1:eac0369: 		dd.dropTableDescriptor(td, sd, tc);
1:eac0369: 	}
1:eac0369: 
1:398a043:     public String getName() {
1:398a043:         return viewName;
1:398a043:     }
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:ee5857f
/////////////////////////////////////////////////////////////////////////
1: 		    case DependencyManager.DROP_COLUMN:
/////////////////////////////////////////////////////////////////////////
1: 		    // DROP_COLUMN_RESTRICT is similar. Any case which arrives
1: 		    // at this default: statement causes the exception to be
1: 		    // thrown, indicating that the DDL modification should be
1: 		    // rejected because a view is dependent on the underlying
1: 		    // object (table, column, privilege, etc.)
/////////////////////////////////////////////////////////////////////////
1: 		    case DependencyManager.DROP_COLUMN:
1: 
1:                                 lcc.getLastActivation().addWarning(
1:                                     StandardException.newWarning(
1:                                         SQLState.LANG_VIEW_DROPPED,
1:                                         this.getObjectName() ));
0:                                 return;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1: public final class ViewDescriptor extends UniqueTupleDescriptor
1: 	implements Dependent, Provider
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f17b81f
/////////////////////////////////////////////////////////////////////////
commit:fd4430d
/////////////////////////////////////////////////////////////////////////
commit:763e014
/////////////////////////////////////////////////////////////////////////
1: 
1: 				// When REVOKE_PRIVILEGE gets sent to a
1: 				// TablePermsDescriptor we must also send
1: 				// INTERNAL_RECOMPILE_REQUEST to its Dependents which
1: 				// may be GPSs needing re-compilation. But Dependents
1: 				// could also be ViewDescriptors, which then also need
1: 				// to handle this event.
1: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
/////////////////////////////////////////////////////////////////////////
1: 
1: 				// When REVOKE_PRIVILEGE gets sent to a
1: 				// TablePermsDescriptor we must also send
1: 				// INTERNAL_RECOMPILE_REQUEST to its Dependents which
1: 				// may be GPSs needing re-compilation. But Dependents
1: 				// could also be ViewDescriptors, which then also need
1: 				// to handle this event.
1: 		    case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:398a043
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.depend.BasicDependencyManager;
/////////////////////////////////////////////////////////////////////////
0:             case DependencyManager.DROP_COLUMN:
1:                 
1:                 TableDescriptor td = 
1:                         getDataDictionary().getTableDescriptor(uuid);
1:                 
1:                 if (td == null) { 
1:                     // DERBY-5567 already dropped via another dependency 
1:                     break;
1:                 }
1:                 
1:                 // DERBY-5567 keep original action
1:                 drop(lcc, td.getSchemaDescriptor(), td, action);
0:                 lcc.getLastActivation().addWarning(
0:                         StandardException.newWarning(
0:                         SQLState.LANG_VIEW_DROPPED,
0:                         this.getObjectName() ));
1:                 break;
1:             default:
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Drop this descriptor, if not already done.
1:      * 
1:      * @param lcc current language connection context
1:      * @param sd schema descriptor
1:      * @param td table descriptor for this view
1:      * @throws StandardException standard error policy
1:      */
1:     public void drop(
1:             LanguageConnectionContext lcc,
1:             SchemaDescriptor sd,
1:             TableDescriptor td) throws StandardException
1:     {
1:         drop(lcc, sd, td, DependencyManager.DROP_VIEW);
1:     }
1: 
1:     /**
1:      * Drop this descriptor, if not already done, due to action.
1:      * If action is not {@code DependencyManager.DROP_VIEW}, the descriptor is 
1:      * dropped due to dropping some other object, e.g. a table column.
1:      * 
1:      * @param lcc current language connection context
1:      * @param sd schema descriptor
1:      * @param td table descriptor for this view
1:      * @param action action
1:      * @throws StandardException standard error policy
1:      */
1:     private void drop(
1:             LanguageConnectionContext lcc,
1:             SchemaDescriptor sd,
1:             TableDescriptor td,
1:             int action) throws StandardException
1:     {
1: 
/////////////////////////////////////////////////////////////////////////
1:         dm.invalidateFor(td, action, lcc);
/////////////////////////////////////////////////////////////////////////
1:     public String getName() {
1:         return viewName;
1:     }
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
1: 			// Only used by Activations
1: 		    case DependencyManager.RECHECK_PRIVILEGES:
1: 
1: 				break;
/////////////////////////////////////////////////////////////////////////
1: 				// Only used by Activations
1: 			case DependencyManager.RECHECK_PRIVILEGES:
1: 
/////////////////////////////////////////////////////////////////////////
1: 				// When REVOKE_PRIVILEGE gets sent (this happens for privilege
1: 				// types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER),
1: 				// we make the ViewDescriptor drop itself. REVOKE_ROLE also
1: 				// drops the dependent view.
1: 			case DependencyManager.REVOKE_ROLE:
commit:eb38311
/////////////////////////////////////////////////////////////////////////
1: 			// When a role grant is revoked, any a view dependent on priviliges
1: 			// obtained through that role grant will dropped. We don't do
1: 			// anything here. Later in makeInvalid method, we make the
1: 			// ViewDescriptor drop itself.
1: 			case DependencyManager.REVOKE_ROLE:
1: 
/////////////////////////////////////////////////////////////////////////
0: 		    case DependencyManager.REVOKE_ROLE:
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9213b42
/////////////////////////////////////////////////////////////////////////
0: 				drop(lcc, 
0: 						getDataDictionary().getTableDescriptor(uuid));
/////////////////////////////////////////////////////////////////////////
0: 	public void drop(LanguageConnectionContext lcc,
0: 							  SchemaDescriptor sd, TableDescriptor td)
1:         DataDictionary dd = getDataDictionary();
1:         DependencyManager dm = dd.getDependencyManager();
1:         TransactionController tc = lcc.getTransactionExecute();
1:         
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
commit:71408ab
/////////////////////////////////////////////////////////////////////////
1: 			//When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1: 			//types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1: 			//don't do anything here. Later in makeInvalid method, we make  
1: 			//the ViewDescriptor drop itself. 
1: 			//Notice that REVOKE_PRIVILEGE_RESTRICT is not caught earlier.
1: 		    //It gets handled in this default: action where an exception
1: 		    //will be thrown. This is because, if such an invalidation 
1: 		    //action type is ever received by a dependent, the dependent 
1: 		    //show throw an exception.
1: 			//In Derby, at this point, REVOKE_PRIVILEGE_RESTRICT gets sent
1: 		    //when execute privilege on a routine is getting revoked.
/////////////////////////////////////////////////////////////////////////
1: 			/* We don't care about creating or dropping indexes or
/////////////////////////////////////////////////////////////////////////
0: 			//When REVOKE_PRIVILEGE gets sent (this happens for privilege 
0: 			//types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
0: 			//make the ViewDescriptor drop itself. 
commit:f8fa8cf
/////////////////////////////////////////////////////////////////////////
0: 		    //Notice that REVOKE_EXECUTE_PRIVILEGE is not included here.
0: 		    //This is because Derby supports only RESTRICT form of revoke 
0: 		    //execute and that means that if there are any dependent objects 
0: 		    //on execute permission on routine, revoke execute on that 
0: 		    //routine should fail
1: 		    //
0: 		    //For all the other types of revoke privileges, for instance,
0: 		    //SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER, we don't 
0: 		    //do anything here and later in makeInvalid, we make the 
0: 		    //ViewDescriptor drop itself. 
/////////////////////////////////////////////////////////////////////////
0: 	    	//Notice that REVOKE_EXECUTE_PRIVILEGE is not included here.
0: 	    	//This is because Derby supports only RESTRICT form of revoke 
0: 		    //execute and that means that if there are any dependent 
0: 		    //objects on execute permission on routine, revoke execute on 
0: 		    //that routine should fail. This behvaior for revoke execute
0: 		    //gets implemented in prepareToInvalidate method
commit:76faa49
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.execute.DropTriggerConstantAction;
/////////////////////////////////////////////////////////////////////////
1: 
1: 		    case DependencyManager.REVOKE_PRIVILEGE:
0: 				dropViewWork(getDataDictionary(), 
0: 						getDataDictionary().getDependencyManager(), lcc,
0: 						lcc.getTransactionExecute(), 
0: 						getDataDictionary().getTableDescriptor(uuid).getSchemaDescriptor(),
0: 						getDataDictionary().getTableDescriptor(uuid), false);
0: 			    return;
1: 
commit:08313de
/////////////////////////////////////////////////////////////////////////
0: 				//ignore revoke privilege action for now
1: 		    case DependencyManager.REVOKE_PRIVILEGE:
1: 		    	break;
/////////////////////////////////////////////////////////////////////////
0: 				//ignore revoke privilege action for now
0: 		    case DependencyManager.REVOKE_PRIVILEGE:
commit:feb5bb2
/////////////////////////////////////////////////////////////////////////
0: public final class ViewDescriptor extends TupleDescriptor
1: 	private final int			checkOption;
1: 	private final String		viewText;
1: 	private final UUID		compSchemaId;
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.ViewDescriptor
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.StatementType;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: /**
1:  * This is the implementation of ViewDescriptor. Users of View descriptors
1:  * should only use the following methods:
1:  * <ol>
1:  * <li> getUUID
1:  * <li> setUUID
1:  * <li> getViewText
1:  * <li> setViewName
1:  * <li> getCheckOptionType
1:  * <li> getCompSchemaId
1:  * </ol>
1:  *
1:  * @version 0.1
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class ViewDescriptor extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Dependent, Provider
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private int			checkOption;
1: 	private String		viewName;
0: 	private String		viewText;
1: 	private UUID		uuid;
0: 	private UUID		compSchemaId;
1: 
1: 	public static final	int NO_CHECK_OPTION = 0;
1: 
1: 	/**
1: 	 * Constructor for a ViewDescriptor.
1: 	 *
1: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1: 	 * @param viewID	The UUID for the view
1: 	 * @param viewName	The name of the view
1: 	 * @param viewText	The text of the query expression from the view definition.
1: 	 * @param checkOption	int check option type
1: 	 * @param compSchemaId	the schemaid to compile in
1: 	 */
1: 
1: 	public ViewDescriptor(DataDictionary dataDictionary, UUID viewID, String viewName, String viewText, 
1: 							  int checkOption, UUID compSchemaId)
1: 	{
1: 		super( dataDictionary );
1: 
1: 		uuid = viewID;
1: 		this.viewText = viewText;
1: 		this.viewName = viewName;
1: 
1: 		/* RESOLVE - No check options for now */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (checkOption != ViewDescriptor.NO_CHECK_OPTION)
1: 			{
1: 				SanityManager.THROWASSERT("checkOption (" + checkOption +
1: 				") expected to be " + ViewDescriptor.NO_CHECK_OPTION);
1: 			}
1: 		}
1: 		this.checkOption = checkOption;
1: 		this.compSchemaId = compSchemaId;
1: 	}
1: 
1: 	//
1: 	// ViewDescriptor interface
1: 	//
1: 
1: 	/**
1: 	 * Gets the UUID of the view.
1: 	 *
1: 	 * @return	The UUID of the view.
1: 	 */
1: 	public UUID	getUUID()
1: 	{
1: 		return uuid;
1: 	}
1: 
1: 	/**
1: 	 * Sets the UUID of the view.
1: 	 *
1: 	 * @param uuid	The UUID of the view.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void	setUUID(UUID uuid)
1: 	{
1: 		this.uuid = uuid;
1: 	}
1: 
1: 	/**
1: 	 * Gets the text of the view definition.
1: 	 *
1: 	 * @return	A String containing the text of the CREATE VIEW
1: 	 *		statement that created the view
1: 	 */
1: 	public String	getViewText()
1: 	{
1: 		return viewText;
1: 	}
1: 
1: 	/**
1: 	 * Sets the name of the view.
1: 	 *
1: 	 * @param name	The name of the view.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void	setViewName(String name)
1: 	{
1: 		viewName = name;
1: 	}
1: 
1: 	/**
1: 	 * Gets an identifier telling what type of check option
1: 	 * is on this view.
1: 	 *
1: 	 * @return	An identifier telling what type of check option
1: 	 *			is on the view.
1: 	 */
1: 	public int	getCheckOptionType()
1: 	{
1: 		return checkOption;
1: 	}
1: 
1: 	/**
1: 	 * Get the compilation type schema id when this view
1: 	 * was first bound.
1: 	 *
1: 	 * @return the schema UUID
1: 	 */
1: 	public UUID getCompSchemaId()
1: 	{
1: 		return compSchemaId;
1: 	}
1: 
1: 
1: 	//
1: 	// Provider interface
1: 	//
1: 
1: 	/**		
1: 		@return the stored form of this provider
1: 
1: 			@see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder()
1: 	{
1: 	    return getDependableFinder(StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID);
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Provider.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this provider.
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return viewName;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's UUID 
1: 	 *
1: 	 * @return String	The provider's UUID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return uuid;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's type.
1: 	 *
1: 	 * @return String		The provider's type.
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.VIEW;
1: 	}
1: 
1: 	//
1: 	// Dependent Inteface
1: 	//
1: 	/**
1: 		Check that all of the dependent's dependencies are valid.
1: 
1: 		@return true if the dependent is currently valid
1: 	 */
1: 	public boolean isValid()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 		Prepare to mark the dependent as invalid (due to at least one of
1: 		its dependencies being invalid).
1: 
1: 		@param action	The action causing the invalidation
1: 		@param p		the provider
1: 
1: 		@exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action,
1: 					LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		switch ( action )
1: 		{
1: 			/*
1: 			 * We don't care about creating or dropping indexes or
1: 			 * alter table on an underlying table.
1: 			 */
1: 		    case DependencyManager.CREATE_INDEX:
1: 		    case DependencyManager.DROP_INDEX:
1: 		    case DependencyManager.CREATE_CONSTRAINT:
1: 		    case DependencyManager.ALTER_TABLE:
1: 		    case DependencyManager.CREATE_TRIGGER:
1: 		    case DependencyManager.DROP_TRIGGER:
1: 
1: 		    case DependencyManager.BULK_INSERT:
1: 		    case DependencyManager.COMPRESS_TABLE:
0: 		    case DependencyManager.DROP_TABLE_CASCADE:
0: 		    case DependencyManager.DROP_COLUMN_CASCADE:
0: 		    case DependencyManager.DROP_VIEW_CASCADE:
1: 		    case DependencyManager.RENAME_INDEX:
1: 			case DependencyManager.UPDATE_STATISTICS:
1: 			case DependencyManager.DROP_STATISTICS:
1: 			case DependencyManager.TRUNCATE_TABLE:
1: 			/*
1: 			** Set constriants is a bit odd in that it
1: 			** will send a SET_CONSTRAINTS on the table
1: 			** when it enables a constraint, rather than
1: 			** on the constraint.  So since we depend on
1: 			** the table, we have to deal with this action.
1: 			*/
1: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1: 				break;
1: 
1: 		    default:
1: 
1: 				DependencyManager dm;
1: 
1: 				dm = getDataDictionary().getDependencyManager();
1: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_VIEW, 
1: 					dm.getActionString(action), 
1: 					p.getObjectName(), viewName);
1: 
1: 		}	// end switch
1: 	}
1: 
1: 	/**
1: 		Mark the dependent as invalid (due to at least one of
1: 		its dependencies being invalid).
1: 
1: 		@param	action	The action causing the invalidation
1: 
1: 		@exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		switch ( action )
1: 		{
0: 			/* creating or dropping another publication won't affect
0: 			 * this view. so we allow these actions.
1: 			 * We don't care about creating or dropping indexes or
1: 			 * alter table on an underlying table.
1: 			 */
1: 		    case DependencyManager.CREATE_INDEX:
1: 		    case DependencyManager.DROP_INDEX:
1: 		    case DependencyManager.ALTER_TABLE:
1: 		    case DependencyManager.CREATE_CONSTRAINT:
1: 		    case DependencyManager.BULK_INSERT:
1: 		    case DependencyManager.COMPRESS_TABLE:
1: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1: 		    case DependencyManager.CREATE_TRIGGER:
1: 		    case DependencyManager.DROP_TRIGGER:
1: 		    case DependencyManager.RENAME_INDEX:
1: 			case DependencyManager.UPDATE_STATISTICS:
1: 			case DependencyManager.DROP_STATISTICS:
1: 			case DependencyManager.TRUNCATE_TABLE:
1: 				break;
1: 		
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
0: 				dropViewCascade(lcc);
1: 				break;
1: 
1: 		    default:
1: 
1: 				/* We should never get here, since we can't have dangling references */
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("did not expect to get called");
1: 				}
1: 				break;
1: 
1: 		}	// end switch
1: 
1: 	}
1: 
1: 	/**
0: 		Attempt to revalidate the dependent. For prepared statements,
0: 		this could go through its dependencies and check that they
0: 		are up to date; if not, it would recompile the statement.
0: 		Any failure during this attempt should throw
0: 		StandardException.unableToRevalidate().
1: 
0: 		@exception StandardException thrown if unable to make it valid
1: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 	}
1: 
1: 	//
1: 	// class interface
1: 	//
1: 
1: 	/**
1: 	 * Prints the contents of the ViewDescriptor
1: 	 *
1: 	 * @return The contents as a String
1: 	 */
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return	"uuid: " + uuid + " viewName: " + viewName + "\n" +
1: 				"viewText: " + viewText + "\n" +
1: 				"checkOption: " + checkOption + "\n" +
1: 				"compSchemaId: " + compSchemaId + "\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 	/**
0: 	   Drops the dependent view as part of a drop table cascade
1: 	 
0: 	   @exception StandardException thrown if failure occurs in dropping view
1: 	 */
0: 	private void dropViewCascade(LanguageConnectionContext lcc) throws StandardException
1: 	{
0: 		DataDictionary dd = getDataDictionary();
1: 
0: 		DependencyManager dm = dd.getDependencyManager();
0: 		TransactionController tc = lcc.getTransactionCompile();
0: 		SchemaDescriptor sd= dd.getSchemaDescriptor(compSchemaId, tc);
1: 
0: 		TableDescriptor td = dd.getTableDescriptor(uuid);
1: 
0: 		// we may have already dropped this view if it was a view on top of
0: 		// another view
0: 		// For example a->va->vva, creates 3 dependencies va->a, vva->a, vva->va
0: 		if (td == null)
0: 			return;
1: 
0: 		// make sure the table is a view
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT((td.getTableType() == TableDescriptor.VIEW_TYPE), 
0: 							"table descriptor not view type for view "+viewName);
1: 		}
1: 
0: 		// drop the View
0: 		dropViewWork(dd, dm, lcc, tc, sd, td, true);
0: 		lcc.getLastActivation().addWarning(
0: 						StandardException.newWarning(SQLState.LANG_VIEW_DROPPED,
0:  							td.getName()));
1: 	}
1: 
0: 	public void dropViewWork(DataDictionary dd, DependencyManager dm,
0: 							  LanguageConnectionContext lcc, TransactionController tc,
0: 							  SchemaDescriptor sd, TableDescriptor td, boolean cascade)
1: 		throws StandardException
1: 	{
1: 		/* Drop the columns */
1: 		dd.dropAllColumnDescriptors(td.getUUID(), tc);
1: 
1: 		/* Prepare all dependents to invalidate.  (This is there chance
1: 		 * to say that they can't be invalidated.  For example, an open
1: 		 * cursor referencing a table/view that the user is attempting to
1: 		 * drop.) If no one objects, then invalidate any dependent objects.
1: 		 */
0: 		dm.invalidateFor(td,
0: 			cascade ? DependencyManager.DROP_VIEW_CASCADE : DependencyManager.DROP_VIEW, lcc);
1: 
1: 		/* Clear the dependencies for the view */
1: 		dm.clearDependencies(lcc, this);
1: 
1: 		/* Drop the view */
1: 		dd.dropViewDescriptor(this, tc);
1: 
1: 		/* Drop the table */
1: 		dd.dropTableDescriptor(td, sd, tc);
1: 	}
1: 
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b7e13a9
/////////////////////////////////////////////////////////////////////////
1: 		/* Drop all table and column permission descriptors */
1: 		dd.dropAllTableAndColPermDescriptors(td.getUUID(), tc);
0: 
commit:93e7f0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		dm.invalidateFor(td, DependencyManager.DROP_VIEW, lcc);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: /**
0:  * This is the implementation of ViewDescriptor. Users of View descriptors
0:  * should only use the following methods:
0:  * <ol>
0:  * <li> getUUID
0:  * <li> setUUID
0:  * <li> getViewText
0:  * <li> setViewName
0:  * <li> getCheckOptionType
0:  * <li> getCompSchemaId
0:  * </ol>
0:  *
0:  * @version 0.1
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class ViewDescriptor extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Dependent, Provider
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private int			checkOption;
0: 	private String		viewName;
0: 	private String		viewText;
0: 	private UUID		uuid;
0: 	private UUID		compSchemaId;
0: 
0: 	public static final	int NO_CHECK_OPTION = 0;
0: 
0: 	/**
0: 	 * Constructor for a ViewDescriptor.
0: 	 *
0: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
0: 	 * @param viewID	The UUID for the view
0: 	 * @param viewName	The name of the view
0: 	 * @param viewText	The text of the query expression from the view definition.
0: 	 * @param checkOption	int check option type
0: 	 * @param compSchemaId	the schemaid to compile in
0: 	 */
0: 
0: 	public ViewDescriptor(DataDictionary dataDictionary, UUID viewID, String viewName, String viewText, 
0: 							  int checkOption, UUID compSchemaId)
0: 	{
0: 		super( dataDictionary );
0: 
0: 		uuid = viewID;
0: 		this.viewText = viewText;
0: 		this.viewName = viewName;
0: 
0: 		/* RESOLVE - No check options for now */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (checkOption != ViewDescriptor.NO_CHECK_OPTION)
0: 			{
0: 				SanityManager.THROWASSERT("checkOption (" + checkOption +
0: 				") expected to be " + ViewDescriptor.NO_CHECK_OPTION);
0: 			}
0: 		}
0: 		this.checkOption = checkOption;
0: 		this.compSchemaId = compSchemaId;
0: 	}
0: 
0: 	//
0: 	// ViewDescriptor interface
0: 	//
0: 
0: 	/**
0: 	 * Gets the UUID of the view.
0: 	 *
0: 	 * @return	The UUID of the view.
0: 	 */
0: 	public UUID	getUUID()
0: 	{
0: 		return uuid;
0: 	}
0: 
0: 	/**
0: 	 * Sets the UUID of the view.
0: 	 *
0: 	 * @param uuid	The UUID of the view.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void	setUUID(UUID uuid)
0: 	{
0: 		this.uuid = uuid;
0: 	}
0: 
0: 	/**
0: 	 * Gets the text of the view definition.
0: 	 *
0: 	 * @return	A String containing the text of the CREATE VIEW
0: 	 *		statement that created the view
0: 	 */
0: 	public String	getViewText()
0: 	{
0: 		return viewText;
0: 	}
0: 
0: 	/**
0: 	 * Sets the name of the view.
0: 	 *
0: 	 * @param name	The name of the view.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void	setViewName(String name)
0: 	{
0: 		viewName = name;
0: 	}
0: 
0: 	/**
0: 	 * Gets an identifier telling what type of check option
0: 	 * is on this view.
0: 	 *
0: 	 * @return	An identifier telling what type of check option
0: 	 *			is on the view.
0: 	 */
0: 	public int	getCheckOptionType()
0: 	{
0: 		return checkOption;
0: 	}
0: 
0: 	/**
0: 	 * Get the compilation type schema id when this view
0: 	 * was first bound.
0: 	 *
0: 	 * @return the schema UUID
0: 	 */
0: 	public UUID getCompSchemaId()
0: 	{
0: 		return compSchemaId;
0: 	}
0: 
0: 
0: 	//
0: 	// Provider interface
0: 	//
0: 
0: 	/**		
0: 		@return the stored form of this provider
0: 
0: 			@see Dependable#getDependableFinder
0: 	 */
0: 	public DependableFinder getDependableFinder()
0: 	{
0: 	    return getDependableFinder(StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID);
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Provider.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this provider.
0: 	 */
0: 	public String getObjectName()
0: 	{
0: 		return viewName;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's UUID 
0: 	 *
0: 	 * @return String	The provider's UUID
0: 	 */
0: 	public UUID getObjectID()
0: 	{
0: 		return uuid;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's type.
0: 	 *
0: 	 * @return String		The provider's type.
0: 	 */
0: 	public String getClassType()
0: 	{
0: 		return Dependable.VIEW;
0: 	}
0: 
0: 	//
0: 	// Dependent Inteface
0: 	//
0: 	/**
0: 		Check that all of the dependent's dependencies are valid.
0: 
0: 		@return true if the dependent is currently valid
0: 	 */
0: 	public boolean isValid()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 		Prepare to mark the dependent as invalid (due to at least one of
0: 		its dependencies being invalid).
0: 
0: 		@param action	The action causing the invalidation
0: 		@param p		the provider
0: 
0: 		@exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public void prepareToInvalidate(Provider p, int action,
0: 					LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		switch ( action )
0: 		{
0: 			/*
0: 			 * We don't care about creating or dropping indexes or
0: 			 * alter table on an underlying table.
0: 			 */
0: 		    case DependencyManager.CREATE_INDEX:
0: 		    case DependencyManager.DROP_INDEX:
0: 		    case DependencyManager.CREATE_CONSTRAINT:
0: 		    case DependencyManager.ALTER_TABLE:
0: 		    case DependencyManager.CREATE_TRIGGER:
0: 		    case DependencyManager.DROP_TRIGGER:
0: 
0: 		    case DependencyManager.BULK_INSERT:
0: 		    case DependencyManager.COMPRESS_TABLE:
0: 		    case DependencyManager.DROP_TABLE_CASCADE:
0: 		    case DependencyManager.DROP_COLUMN_CASCADE:
0: 		    case DependencyManager.DROP_VIEW_CASCADE:
0: 		    case DependencyManager.RENAME_INDEX:
0: 			case DependencyManager.UPDATE_STATISTICS:
0: 			case DependencyManager.DROP_STATISTICS:
0: 			case DependencyManager.TRUNCATE_TABLE:
0: 			/*
0: 			** Set constriants is a bit odd in that it
0: 			** will send a SET_CONSTRAINTS on the table
0: 			** when it enables a constraint, rather than
0: 			** on the constraint.  So since we depend on
0: 			** the table, we have to deal with this action.
0: 			*/
0: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
0: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
0: 				break;
0: 
0: 		    default:
0: 
0: 				DependencyManager dm;
0: 
0: 				dm = getDataDictionary().getDependencyManager();
0: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_VIEW, 
0: 					dm.getActionString(action), 
0: 					p.getObjectName(), viewName);
0: 
0: 		}	// end switch
0: 	}
0: 
0: 	/**
0: 		Mark the dependent as invalid (due to at least one of
0: 		its dependencies being invalid).
0: 
0: 		@param	action	The action causing the invalidation
0: 
0: 		@exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		switch ( action )
0: 		{
0: 			/* creating or dropping another publication won't affect
0: 			 * this view. so we allow these actions.
0: 			 * We don't care about creating or dropping indexes or
0: 			 * alter table on an underlying table.
0: 			 */
0: 		    case DependencyManager.CREATE_INDEX:
0: 		    case DependencyManager.DROP_INDEX:
0: 		    case DependencyManager.ALTER_TABLE:
0: 		    case DependencyManager.CREATE_CONSTRAINT:
0: 		    case DependencyManager.BULK_INSERT:
0: 		    case DependencyManager.COMPRESS_TABLE:
0: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
0: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
0: 		    case DependencyManager.CREATE_TRIGGER:
0: 		    case DependencyManager.DROP_TRIGGER:
0: 		    case DependencyManager.RENAME_INDEX:
0: 			case DependencyManager.UPDATE_STATISTICS:
0: 			case DependencyManager.DROP_STATISTICS:
0: 			case DependencyManager.TRUNCATE_TABLE:
0: 				break;
0: 		
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
0: 				dropViewCascade(lcc);
0: 				break;
0: 
0: 		    default:
0: 
0: 				/* We should never get here, since we can't have dangling references */
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("did not expect to get called");
0: 				}
0: 				break;
0: 
0: 		}	// end switch
0: 
0: 	}
0: 
0: 	/**
0: 		Attempt to revalidate the dependent. For prepared statements,
0: 		this could go through its dependencies and check that they
0: 		are up to date; if not, it would recompile the statement.
0: 		Any failure during this attempt should throw
0: 		StandardException.unableToRevalidate().
0: 
0: 		@exception StandardException thrown if unable to make it valid
0: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 	}
0: 
0: 	//
0: 	// class interface
0: 	//
0: 
0: 	/**
0: 	 * Prints the contents of the ViewDescriptor
0: 	 *
0: 	 * @return The contents as a String
0: 	 */
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return	"uuid: " + uuid + " viewName: " + viewName + "\n" +
0: 				"viewText: " + viewText + "\n" +
0: 				"checkOption: " + checkOption + "\n" +
0: 				"compSchemaId: " + compSchemaId + "\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 	/**
0: 	   Drops the dependent view as part of a drop table cascade
0: 	 
0: 	   @exception StandardException thrown if failure occurs in dropping view
0: 	 */
0: 	private void dropViewCascade(LanguageConnectionContext lcc) throws StandardException
0: 	{
0: 		DataDictionary dd = getDataDictionary();
0: 
0: 		DependencyManager dm = dd.getDependencyManager();
0: 		TransactionController tc = lcc.getTransactionCompile();
0: 		SchemaDescriptor sd= dd.getSchemaDescriptor(compSchemaId, tc);
0: 
0: 		TableDescriptor td = dd.getTableDescriptor(uuid);
0: 
0: 		// we may have already dropped this view if it was a view on top of
0: 		// another view
0: 		// For example a->va->vva, creates 3 dependencies va->a, vva->a, vva->va
0: 		if (td == null)
0: 			return;
0: 
0: 		// make sure the table is a view
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT((td.getTableType() == TableDescriptor.VIEW_TYPE), 
0: 							"table descriptor not view type for view "+viewName);
0: 		}
0: 
0: 		// drop the View
0: 		dropViewWork(dd, dm, lcc, tc, sd, td, true);
0: 		lcc.getLastActivation().addWarning(
0: 						StandardException.newWarning(SQLState.LANG_VIEW_DROPPED,
0:  							td.getName()));
0: 	}
0: 
0: 	public void dropViewWork(DataDictionary dd, DependencyManager dm,
0: 							  LanguageConnectionContext lcc, TransactionController tc,
0: 							  SchemaDescriptor sd, TableDescriptor td, boolean cascade)
0: 		throws StandardException
0: 	{
0: 		/* Drop the columns */
0: 		dd.dropAllColumnDescriptors(td.getUUID(), tc);
0: 
0: 		/* Prepare all dependents to invalidate.  (This is there chance
0: 		 * to say that they can't be invalidated.  For example, an open
0: 		 * cursor referencing a table/view that the user is attempting to
0: 		 * drop.) If no one objects, then invalidate any dependent objects.
0: 		 */
0: 		dm.invalidateFor(td,
0: 			cascade ? DependencyManager.DROP_VIEW_CASCADE : DependencyManager.DROP_VIEW, lcc);
0: 
0: 		/* Clear the dependencies for the view */
0: 		dm.clearDependencies(lcc, this);
0: 
0: 		/* Drop the view */
0: 		dd.dropViewDescriptor(this, tc);
0: 
0: 		/* Drop the table */
0: 		dd.dropTableDescriptor(td, sd, tc);
0: 	}
0: 
0: 
0: }
============================================================================