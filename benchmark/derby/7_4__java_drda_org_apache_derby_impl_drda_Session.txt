1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.Session
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
12:eac0369: 
2:2e4a36f:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.OutputStream;
1:eac0369: import java.net.Socket;
1:db4c995: import java.sql.SQLException;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.Hashtable;
1:eac0369: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:eac0369: 
3:2e4a36f: /**
1:4f996a4:     Session stores information about the current session
1:4f996a4:     It is used so that a DRDAConnThread can work on any session.
1:2e4a36f: */
1:eac0369: class Session
1:45680ff: {
1:eac0369: 
1:db9a013:     // session states
1:4f996a4:     protected static final int INIT = 1;    // before exchange of server attributes
1:db9a013:     protected static final int ATTEXC = 2;  // after first exchange of server attributes
1:db9a013:     protected static final int SECACC = 3;  // after ACCSEC (Security Manager Accessed)
1:db9a013:     protected static final int CHKSEC = 4;  // after SECCHK  (Checked Security)
1:db9a013:     protected static final int CLOSED = 5;  // session has ended
1:eac0369: 
1:4f996a4:     // session types
1:4f996a4:     protected static final int DRDA_SESSION = 1;
1:4f996a4:     protected static final int CMD_SESSION = 2;
1:4f996a4:     
1:4f996a4:     // trace name prefix and suffix
1:4f996a4:     private static final String TRACENAME_PREFIX = "Server";
1:4f996a4:     private static final String TRACENAME_SUFFIX = ".trace";
1:eac0369: 
1:4f996a4:     // session information
1:db9a013:     protected Socket clientSocket;      // session socket
1:db9a013:     protected int connNum;              // connection number
1:db9a013:     protected InputStream sessionInput; // session input stream
1:db9a013:     protected OutputStream sessionOutput;   // session output stream
1:db9a013:     protected String traceFileName;     // trace file name for session
1:db9a013:     protected boolean traceOn;          // whether trace is currently on for the session
1:4f996a4:     protected int state;                // the current state of the session
1:db9a013:     protected int sessionType;          // type of session - DRDA or NetworkServerControl command
1:4f996a4:     protected String drdaID;            // DRDA ID of the session
1:4f996a4:     protected DssTrace dssTrace;        // trace object associated with the session
1:4f996a4:     protected AppRequester appRequester;    // Application requester for this session
1:4f996a4:     protected Database database;        // current database
1:db9a013:     protected int qryinsid;             // unique identifier for each query
1:db9a013:     protected LocalizedResource langUtil;       // localization information for command session
1:4f996a4:                                         // client
1:eac0369: 
1:27fbf33:     /** Table of databases accessed in this session. */
1:db9a013:     private Hashtable<String, Database> dbtable;
1:4f996a4:     private NetworkServerControlImpl nsctrl;        // NetworkServerControlImpl needed for logging
1:45680ff:                                                         // message if tracing fails.
1:45680ff:                                                         
1:eac0369: 
1:4f996a4:     // constructor
1:4f996a4:     /**
1:4f996a4:      * Session constructor
1:4f996a4:      * 
1:db9a013:      * @param connNum       connection number
1:db9a013:      * @param clientSocket  communications socket for this session
1:4f996a4:      * @param traceDirectory    location for trace files
1:db9a013:      * @param traceOn       whether to start tracing this connection
1:4f996a4:      *
1:4f996a4:      * @exception throws IOException
1:4f996a4:      */
1:4f996a4:     Session (NetworkServerControlImpl nsctrl, int connNum, Socket clientSocket, String traceDirectory,
1:4f996a4:             boolean traceOn) throws Exception
1:4f996a4:     {
1:1bc7674:         this.nsctrl = nsctrl;
1:4f996a4:         this.connNum = connNum;
1:4f996a4:         this.clientSocket = clientSocket;
1:4f996a4:         this.traceOn = traceOn;
1:4f996a4:         if (traceOn)
1:4f996a4:             dssTrace = new DssTrace(); 
1:27fbf33:         dbtable = new Hashtable<String, Database>();
1:4f996a4:         initialize(traceDirectory);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Close session - close connection sockets and set state to closed
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void close() throws SQLException
1:4f996a4:     {
1:4f996a4:         
1:4f996a4:         try {
1:4f996a4:             sessionInput.close();
1:4f996a4:             sessionOutput.close();
1:4f996a4:             clientSocket.close();
1:4f996a4:             setTraceOff();
1:4f996a4:             if (dbtable != null)
1:4f996a4:                 for (Enumeration e = dbtable.elements() ; e.hasMoreElements() ;) 
1:4f996a4:                 {
1:4f996a4:                     ((Database) e.nextElement()).close();
1:4f996a4:                 }
1:4f996a4:             
1:4f996a4:         }catch (IOException e) {} // ignore IOException when we are shutting down
1:4f996a4:         finally {
1:4f996a4:             state = CLOSED;
1:4f996a4:             dbtable = null;
1:4f996a4:             database = null;
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * initialize a server trace for the DRDA protocol
1:4f996a4:      * 
1:4f996a4:      * @param traceDirectory - directory for trace file
1:1bc7674:      * @param throwException - true if we should throw an exception if
1:1bc7674:      *                         turning on tracing fails.  We do this
1:1bc7674:      *                         for NetworkServerControl API commands.
1:4f996a4:      * @throws IOException 
1:4f996a4:      */
1:4f996a4:     protected void initTrace(String traceDirectory, boolean throwException)  throws Exception
1:4f996a4:     {
1:4f996a4:         if (traceDirectory != null)
1:4f996a4:             traceFileName = traceDirectory + "/" + TRACENAME_PREFIX+
1:4f996a4:                 connNum+ TRACENAME_SUFFIX;
1:4f996a4:         else
1:4f996a4:             traceFileName = TRACENAME_PREFIX +connNum+ TRACENAME_SUFFIX;
1:4f996a4:         
1:4f996a4:         if (dssTrace == null)
1:4f996a4:             dssTrace = new DssTrace();
1:1bc7674:         try {
1:1bc7674:             dssTrace.startComBufferTrace(traceFileName);
1:1bc7674:             traceOn = true;
1:1bc7674:         } catch (Exception e) {   
1:1bc7674:             if (throwException) {
1:1bc7674:                 throw e;
1:1bc7674:             }
1:1bc7674:             // If there is an error starting tracing for the session,
1:1bc7674:             // log to the console and derby.log and do not turn tracing on.
1:1bc7674:             // let connection continue.
1:1bc7674:             nsctrl.consoleExceptionPrintTrace(e);
1:1bc7674:         }              
1:4f996a4:     }
1:5028317: 
1:4f996a4:     /**
1:4f996a4:      * Set tracing on
1:4f996a4:      * 
1:db9a013:      * @param traceDirectory    directory for trace files
1:4f996a4:      * @throws Exception 
1:4f996a4:      */
1:4f996a4:     protected void setTraceOn(String traceDirectory, boolean throwException) throws Exception
1:4f996a4:     {
1:4f996a4:         if (traceOn)
1:4f996a4:             return;
1:4f996a4:         initTrace(traceDirectory, throwException);    
1:4f996a4:     }
1:5028317: 
1:4f996a4:     /**
1:4f996a4:      * Get whether tracing is on 
1:4f996a4:      *
1:4f996a4:      * @return true if tracing is on false otherwise
1:4f996a4:      */
1:4f996a4:     protected boolean isTraceOn()
1:4f996a4:     {
1:4f996a4:         if (traceOn)
1:4f996a4:             return true;
1:4f996a4:         else
1:4f996a4:             return false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get connection number
1:4f996a4:      *
1:4f996a4:      * @return connection number
1:4f996a4:      */
1:4f996a4:     protected int getConnNum()
1:4f996a4:     {
1:4f996a4:         return connNum;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Set tracing off
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void setTraceOff()
1:4f996a4:     {
1:4f996a4:         if (! traceOn)
1:4f996a4:             return;
1:4f996a4:         traceOn = false;
1:4f996a4:         if (traceFileName != null)
1:4f996a4:             dssTrace.stopComBufferTrace();
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Add database to session table
1:4f996a4:      */
1:4f996a4:     protected void addDatabase(Database d)
1:4f996a4:     {
1:4f996a4:         dbtable.put(d.getDatabaseName(), d);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get database
1:4f996a4:      */
1:4f996a4:     protected Database getDatabase(String dbName)
1:4f996a4:     {
1:4f996a4:         return (Database)dbtable.get(dbName);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get requried security checkpoint.
1:4f996a4:      * Used to verify EXCSAT/ACCSEC/SECCHK order.
1:4f996a4:      *
1:4f996a4:      *  @return next required Security checkpoint or -1 if 
1:4f996a4:      *          neither ACCSEC or SECCHK are required at this time.
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected int getRequiredSecurityCodepoint()
1:4f996a4:     {
1:4f996a4:         switch (state)
1:4f996a4:         {
1:4f996a4:             case ATTEXC:
1:4f996a4:                 // On initial exchange of attributes we require ACCSEC 
1:4f996a4:                 // to access security manager
1:4f996a4:                 return CodePoint.ACCSEC;
1:4f996a4:             case SECACC:
1:4f996a4:                 // After security manager has been accessed successfully we
1:4f996a4:                 // require SECCHK to check security
1:4f996a4:                 return CodePoint.SECCHK;
1:4f996a4:             default:
1:4f996a4:                 return -1;
1:db9a013:         }
1:4f996a4:     }
1:2e4a36f: 
1:4f996a4:     /**
1:4f996a4:      * Check if a security codepoint is required
1:4f996a4:      *
1:4f996a4:      * @return true if ACCSEC or SECCHK are required at this time.
1:4f996a4:      */
1:4f996a4:     protected boolean requiresSecurityCodepoint()
1:4f996a4:     {
1:4f996a4:         return (getRequiredSecurityCodepoint() != -1);
1:4f996a4:     }
1:2e4a36f: 
1:4f996a4:     /**
1:4f996a4:      * Set Session state
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void setState(int s)
1:4f996a4:     {
1:4f996a4:         state = s;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Get session into initial state
1:4f996a4:      *
1:4f996a4:      * @param traceDirectory    - directory for trace files
1:4f996a4:      */
1:4f996a4:     private void initialize(String traceDirectory)
1:4f996a4:         throws Exception
1:4f996a4:     {
1:4f996a4:         sessionInput = clientSocket.getInputStream();
1:4f996a4:         sessionOutput = clientSocket.getOutputStream();
1:4f996a4:         if (traceOn)
1:4f996a4:             initTrace(traceDirectory,false);
1:4f996a4:         state = INIT;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected  String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
1:4f996a4:     {
1:4f996a4:         String s = "";
1:4f996a4:         s += indent +  localLangUtil.getTextMessage("DRDA_RuntimeInfoSessionNumber.I")
1:4f996a4:             + connNum + "\n";
1:4f1dcde: 
1:4f1dcde:         // DERBY-6714: database can be null if the session gets closed
1:4f1dcde:         // while we construct the runtime info.
1:4f1dcde:         Database db = database;
1:4f1dcde:         if (db != null) {
1:4f1dcde:             s += db.buildRuntimeInfo(indent, localLangUtil);
1:4f1dcde:             s += "\n";
1:4f1dcde:         }
1:4f1dcde: 
2:4f996a4:         return s;
1:4f996a4:     }
1:4f996a4: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4f1dcde
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-6714: database can be null if the session gets closed
1:         // while we construct the runtime info.
1:         Database db = database;
1:         if (db != null) {
1:             s += db.buildRuntimeInfo(indent, localLangUtil);
1:             s += "\n";
1:         }
1: 
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     // session states
1:     protected static final int ATTEXC = 2;  // after first exchange of server attributes
1:     protected static final int SECACC = 3;  // after ACCSEC (Security Manager Accessed)
1:     protected static final int CHKSEC = 4;  // after SECCHK  (Checked Security)
1:     protected static final int CLOSED = 5;  // session has ended
/////////////////////////////////////////////////////////////////////////
1:     protected Socket clientSocket;      // session socket
1:     protected int connNum;              // connection number
1:     protected InputStream sessionInput; // session input stream
1:     protected OutputStream sessionOutput;   // session output stream
1:     protected String traceFileName;     // trace file name for session
1:     protected boolean traceOn;          // whether trace is currently on for the session
1:     protected int sessionType;          // type of session - DRDA or NetworkServerControl command
1:     protected int qryinsid;             // unique identifier for each query
1:     protected LocalizedResource langUtil;       // localization information for command session
1:     private Hashtable<String, Database> dbtable;
/////////////////////////////////////////////////////////////////////////
1:      * @param connNum       connection number
1:      * @param clientSocket  communications socket for this session
1:      * @param traceOn       whether to start tracing this connection
/////////////////////////////////////////////////////////////////////////
1:      * @param traceDirectory    directory for trace files
/////////////////////////////////////////////////////////////////////////
1:         }
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1:     /** Table of databases accessed in this session. */
0:     private	Hashtable<String, Database> dbtable;
/////////////////////////////////////////////////////////////////////////
1: 		dbtable = new Hashtable<String, Database>();
commit:1bc7674
/////////////////////////////////////////////////////////////////////////
1:         this.nsctrl = nsctrl;
/////////////////////////////////////////////////////////////////////////
1:      * @param throwException - true if we should throw an exception if
1:      *                         turning on tracing fails.  We do this
1:      *                         for NetworkServerControl API commands.
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             dssTrace.startComBufferTrace(traceFileName);
1:             traceOn = true;
1:         } catch (Exception e) {   
1:             if (throwException) {
1:                 throw e;
1:             }
1:             // If there is an error starting tracing for the session,
1:             // log to the console and derby.log and do not turn tracing on.
1:             // let connection continue.
1:             nsctrl.consoleExceptionPrintTrace(e);
1:         }              
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     Session stores information about the current session
1:     It is used so that a DRDAConnThread can work on any session.
0:     // session states       
1:     protected static final int INIT = 1;    // before exchange of server attributes
0:     protected static final int ATTEXC = 2;    // after first exchange of server attributes
0:     protected static final int SECACC = 3;    // after ACCSEC (Security Manager Accessed)
0:     protected static final int CHKSEC = 4;    // after SECCHK  (Checked Security)
0:     protected static final int CLOSED = 5;    // session has ended
1:     // session types
1:     protected static final int DRDA_SESSION = 1;
1:     protected static final int CMD_SESSION = 2;
1:     
1:     // trace name prefix and suffix
1:     private static final String TRACENAME_PREFIX = "Server";
1:     private static final String TRACENAME_SUFFIX = ".trace";
1:     // session information
0:     protected Socket clientSocket;        // session socket
0:     protected int connNum;                // connection number
0:     protected InputStream sessionInput;    // session input stream
0:     protected OutputStream sessionOutput;    // session output stream
0:     protected String traceFileName;        // trace file name for session
0:     protected boolean traceOn;            // whether trace is currently on for the session
1:     protected int state;                // the current state of the session
0:     protected int sessionType;            // type of session - DRDA or NetworkServerControl command
1:     protected String drdaID;            // DRDA ID of the session
1:     protected DssTrace dssTrace;        // trace object associated with the session
1:     protected AppRequester appRequester;    // Application requester for this session
1:     protected Database database;        // current database
0:     protected int qryinsid;                // unique identifier for each query
0:     protected LocalizedResource langUtil;        // localization information for command session
1:                                         // client
0:     private    Hashtable<String, Database> dbtable;
1:     private NetworkServerControlImpl nsctrl;        // NetworkServerControlImpl needed for logging
1:     // constructor
1:     /**
1:      * Session constructor
1:      * 
0:      * @param connNum        connection number
0:      * @param clientSocket    communications socket for this session
1:      * @param traceDirectory    location for trace files
0:      * @param traceOn        whether to start tracing this connection
1:      *
1:      * @exception throws IOException
1:      */
1:     Session (NetworkServerControlImpl nsctrl, int connNum, Socket clientSocket, String traceDirectory,
1:             boolean traceOn) throws Exception
1:     {
1:         this.connNum = connNum;
1:         this.clientSocket = clientSocket;
1:         this.traceOn = traceOn;
1:         if (traceOn)
1:             dssTrace = new DssTrace(); 
0:         dbtable = new Hashtable<String, Database>();
1:         initialize(traceDirectory);
1:     }
1:     /**
1:      * Close session - close connection sockets and set state to closed
1:      * 
1:      */
1:     protected void close() throws SQLException
1:     {
1:         
1:         try {
1:             sessionInput.close();
1:             sessionOutput.close();
1:             clientSocket.close();
1:             setTraceOff();
1:             if (dbtable != null)
1:                 for (Enumeration e = dbtable.elements() ; e.hasMoreElements() ;) 
1:                 {
1:                     ((Database) e.nextElement()).close();
1:                 }
1:             
1:         }catch (IOException e) {} // ignore IOException when we are shutting down
1:         finally {
1:             state = CLOSED;
1:             dbtable = null;
1:             database = null;
1:         }
1:     }
1:     /**
1:      * initialize a server trace for the DRDA protocol
1:      * 
1:      * @param traceDirectory - directory for trace file
1:      * @throws IOException 
1:      */
1:     protected void initTrace(String traceDirectory, boolean throwException)  throws Exception
1:     {
1:         if (traceDirectory != null)
1:             traceFileName = traceDirectory + "/" + TRACENAME_PREFIX+
1:                 connNum+ TRACENAME_SUFFIX;
1:         else
1:             traceFileName = TRACENAME_PREFIX +connNum+ TRACENAME_SUFFIX;
1:         
1:         if (dssTrace == null)
1:             dssTrace = new DssTrace();
/////////////////////////////////////////////////////////////////////////
1:     }
1:     /**
1:      * Set tracing on
1:      * 
0:      * @param traceDirectory     directory for trace files
1:      * @throws Exception 
1:      */
1:     protected void setTraceOn(String traceDirectory, boolean throwException) throws Exception
1:     {
1:         if (traceOn)
1:             return;
1:         initTrace(traceDirectory, throwException);    
1:     }
1:     /**
1:      * Get whether tracing is on 
1:      *
1:      * @return true if tracing is on false otherwise
1:      */
1:     protected boolean isTraceOn()
1:     {
1:         if (traceOn)
1:             return true;
1:         else
1:             return false;
1:     }
1:     /**
1:      * Get connection number
1:      *
1:      * @return connection number
1:      */
1:     protected int getConnNum()
1:     {
1:         return connNum;
1:     }
1:     /**
1:      * Set tracing off
1:      * 
1:      */
1:     protected void setTraceOff()
1:     {
1:         if (! traceOn)
1:             return;
1:         traceOn = false;
1:         if (traceFileName != null)
1:             dssTrace.stopComBufferTrace();
1:     }
1:     /**
1:      * Add database to session table
1:      */
1:     protected void addDatabase(Database d)
1:     {
1:         dbtable.put(d.getDatabaseName(), d);
1:     }
1:     /**
1:      * Get database
1:      */
1:     protected Database getDatabase(String dbName)
1:     {
1:         return (Database)dbtable.get(dbName);
1:     }
1:     /**
1:      * Get requried security checkpoint.
1:      * Used to verify EXCSAT/ACCSEC/SECCHK order.
1:      *
1:      *  @return next required Security checkpoint or -1 if 
1:      *          neither ACCSEC or SECCHK are required at this time.
1:      *
1:      */
1:     protected int getRequiredSecurityCodepoint()
1:     {
1:         switch (state)
1:         {
1:             case ATTEXC:
1:                 // On initial exchange of attributes we require ACCSEC 
1:                 // to access security manager
1:                 return CodePoint.ACCSEC;
1:             case SECACC:
1:                 // After security manager has been accessed successfully we
1:                 // require SECCHK to check security
1:                 return CodePoint.SECCHK;
1:             default:
1:                 return -1;
1:         }     
1:     }
1:     /**
1:      * Check if a security codepoint is required
1:      *
1:      * @return true if ACCSEC or SECCHK are required at this time.
1:      */
1:     protected boolean requiresSecurityCodepoint()
1:     {
1:         return (getRequiredSecurityCodepoint() != -1);
1:     }
1:     /**
1:      * Set Session state
1:      * 
1:      */
1:     protected void setState(int s)
1:     {
1:         state = s;
1:     }
1:     
1:     /**
1:      * Get session into initial state
1:      *
1:      * @param traceDirectory    - directory for trace files
1:      */
1:     private void initialize(String traceDirectory)
1:         throws Exception
1:     {
1:         sessionInput = clientSocket.getInputStream();
1:         sessionOutput = clientSocket.getOutputStream();
1:         if (traceOn)
1:             initTrace(traceDirectory,false);
1:         state = INIT;
1:     }
1:     protected  String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
1:     {
1:         String s = "";
1:         s += indent +  localLangUtil.getTextMessage("DRDA_RuntimeInfoSessionNumber.I")
1:             + connNum + "\n";
0:         if (database == null)
1:             return s;
0:         s += database.buildRuntimeInfo(indent,localLangUtil);
0:         s += "\n";
1:         return s;
1:     }
commit:df2ca5a
/////////////////////////////////////////////////////////////////////////
0: 		dbtable.put(d.getDatabaseName(), d);
commit:45680ff
/////////////////////////////////////////////////////////////////////////
0: 	private NetworkServerControlImpl nsctrl;        // NetworkServerControlImpl needed for logging
1:                                                         // message if tracing fails.
1:                                                         
/////////////////////////////////////////////////////////////////////////
0: 	Session (NetworkServerControlImpl nsctrl, int connNum, Socket clientSocket, String traceDirectory,
0: 			boolean traceOn) throws Exception
0:                 this.nsctrl = nsctrl;
/////////////////////////////////////////////////////////////////////////
0:          * @param throwException - true if we should throw an exception if turning on tracing fails.
0:          *                         We do this for NetworkServerControl API commands.
0: 	protected void initTrace(String traceDirectory, boolean throwException)  throws Exception
/////////////////////////////////////////////////////////////////////////
0:                 try {
0:                     dssTrace.startComBufferTrace (traceFileName);
0:                     traceOn = true;
0:                 } catch (Exception e)
1:                 {   
0:                     if (throwException)
0:                         throw e;
0:                     // If there is an error starting tracing for the session,
0:                     // log to the console and derby.log and do not turn tracing on.
0:                     // let connection continue.
0:                     nsctrl.consoleExceptionPrintTrace(e);
0:                 }              
0: 	 * @throws Exception 
0: 	protected void setTraceOn(String traceDirectory, boolean throwException) throws Exception
0: 		initTrace(traceDirectory, throwException);    
/////////////////////////////////////////////////////////////////////////
0: 		throws Exception
0: 			initTrace(traceDirectory,false);
commit:5028317
/////////////////////////////////////////////////////////////////////////
0: 	 * @throws IOException 
0: 	protected void initTrace(String traceDirectory) throws IOException 
1: 		
0: 		traceOn = true;
0: 	 * @throws IOException 
0: 	protected void setTraceOn(String traceDirectory) throws IOException
0: 		initTrace(traceDirectory);    
1: 
commit:2e4a44e
/////////////////////////////////////////////////////////////////////////
commit:2e4a36f
/////////////////////////////////////////////////////////////////////////
0: 	// session states	   
0: 	protected static final int ATTEXC = 2;	// after first exchange of server attributes
0: 	protected static final int SECACC = 3;	// after ACCSEC (Security Manager Accessed)
0: 	protected static final int CHKSEC = 4;	// after SECCHK  (Checked Security)
0: 	protected static final int CLOSED = 5;	// session has ended
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Get requried security checkpoint.
0: 	 * Used to verify EXCSAT/ACCSEC/SECCHK order.
0: 	 *
0: 	 *  @return next required Security checkpoint or -1 if 
0: 	 *          neither ACCSEC or SECCHK are required at this time.
0: 	 *
1: 	 */
0: 	protected int getRequiredSecurityCodepoint()
0: 	{
0: 		switch (state)
0: 		{
0: 			case ATTEXC:
0: 				// On initial exchange of attributes we require ACCSEC 
0: 				// to access security manager
0: 				return CodePoint.ACCSEC;
0: 			case SECACC:
0: 				// After security manager has been accessed successfully we
0: 				// require SECCHK to check security
0: 				return CodePoint.SECCHK;
0: 			default:
0: 				return -1;
0: 		}	 
0: 	}
0: 	 * Check if a security codepoint is required
0: 	 *
0: 	 * @return true if ACCSEC or SECCHK are required at this time.
1: 	 */
0: 	protected boolean requiresSecurityCodepoint()
0: 	{
0: 		return (getRequiredSecurityCodepoint() != -1);
0: 	}
1: 
1: 	/**
0: 	 * Set Session state
0: 	 * 
1: 	 */
0: 	protected void setState(int s)
0: 	{
0: 		state = s;
0: 	}
1: 	
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e2807b6
/////////////////////////////////////////////////////////////////////////
0: 			setTraceOff();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	Session (int connNum, Socket clientSocket, String traceDirectory,
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.Session
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.net.Socket;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
0: import java.sql.SQLException;
1: 
0: /**
0: 	Session stores information about the current session
0: 	It is used so that a DRDAConnThread can work on any session.
0: */
1: class Session
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
0: 	// session states
0: 	protected static final int INIT = 1;	// before exchange of server attributes
0: 	protected static final int ATTEXC = 2;	// after exchange of server attributes
0: 	protected static final int CLOSED = 3;	// session has ended
1: 
0: 	// session types
0: 	protected static final int DRDA_SESSION = 1;
0: 	protected static final int CMD_SESSION = 2;
1: 	
0: 	// trace name prefix and suffix
0: 	private static final String TRACENAME_PREFIX = "Server";
0: 	private static final String TRACENAME_SUFFIX = ".trace";
1: 
0: 	// session information
0: 	protected Socket clientSocket;		// session socket
0: 	protected int connNum;				// connection number
0: 	protected InputStream sessionInput;	// session input stream
0: 	protected OutputStream sessionOutput;	// session output stream
0: 	protected String traceFileName;		// trace file name for session
0: 	protected boolean traceOn;			// whether trace is currently on for the session
0: 	protected int state;				// the current state of the session
0: 	protected int sessionType;			// type of session - DRDA or NetworkServerControl command
0: 	protected String drdaID;			// DRDA ID of the session
0: 	protected DssTrace dssTrace;		// trace object associated with the session
0: 	protected AppRequester appRequester;	// Application requester for this session
0: 	protected Database database;		// current database
0: 	protected int qryinsid;				// unique identifier for each query
0: 	protected LocalizedResource langUtil;		// localization information for command session
0: 										// client
1: 
0: 	private	Hashtable	dbtable;		// Table of databases accessed in this session
1: 
0: 	// constructor
0: 	/**
0: 	 * Session constructor
0: 	 * 
0: 	 * @param connNum		connection number
0: 	 * @param clientSocket	communications socket for this session
0: 	 * @param traceDirectory	location for trace files
0: 	 * @param traceOn		whether to start tracing this connection
0: 	 *
0: 	 * @exception throws IOException
0: 	 */
0: 	protected Session (int connNum, Socket clientSocket, String traceDirectory,
0: 			boolean traceOn) throws IOException
0: 	{
0: 		this.connNum = connNum;
0: 		this.clientSocket = clientSocket;
0: 		this.traceOn = traceOn;
0: 		if (traceOn)
0: 			dssTrace = new DssTrace(); 
0: 		dbtable = new Hashtable();
0: 		initialize(traceDirectory);
0: 	}
1: 
0: 	/**
0: 	 * Close session - close connection sockets and set state to closed
0: 	 * 
0: 	 */
0: 	protected void close() throws SQLException
0: 	{
1: 		
0: 		try {
0: 			sessionInput.close();
0: 			sessionOutput.close();
0: 			clientSocket.close();
0: 			if (dbtable != null)
0: 				for (Enumeration e = dbtable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					((Database) e.nextElement()).close();
0: 				}
1: 			
0: 		}catch (IOException e) {} // ignore IOException when we are shutting down
0: 		finally {
0: 			state = CLOSED;
0: 			dbtable = null;
0: 			database = null;
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * initialize a server trace for the DRDA protocol
0: 	 * 
0: 	 * @param traceDirectory - directory for trace file
0: 	 */
0: 	protected void initTrace(String traceDirectory)
0: 	{
0: 		if (traceDirectory != null)
0: 			traceFileName = traceDirectory + "/" + TRACENAME_PREFIX+
0: 				connNum+ TRACENAME_SUFFIX;
0: 		else
0: 			traceFileName = TRACENAME_PREFIX +connNum+ TRACENAME_SUFFIX;
0: 		traceOn = true;
0: 		if (dssTrace == null)
0: 			dssTrace = new DssTrace();
0: 		dssTrace.startComBufferTrace (traceFileName);
0: 	}
1: 
0: 	/**
0: 	 * Set tracing on
0: 	 * 
0: 	 * @param traceDirectory 	directory for trace files
0: 	 */
0: 	protected void setTraceOn(String traceDirectory)
0: 	{
0: 		if (traceOn)
0: 			return;
0: 		initTrace(traceDirectory);
0: 	}
0: 	/**
0: 	 * Get whether tracing is on 
0: 	 *
0: 	 * @return true if tracing is on false otherwise
0: 	 */
0: 	protected boolean isTraceOn()
0: 	{
0: 		if (traceOn)
0: 			return true;
0: 		else
0: 			return false;
0: 	}
1: 
0: 	/**
0: 	 * Get connection number
0: 	 *
0: 	 * @return connection number
0: 	 */
0: 	protected int getConnNum()
0: 	{
0: 		return connNum;
0: 	}
1: 
0: 	/**
0: 	 * Set tracing off
0: 	 * 
0: 	 */
0: 	protected void setTraceOff()
0: 	{
0: 		if (! traceOn)
0: 			return;
0: 		traceOn = false;
0: 		if (traceFileName != null)
0: 			dssTrace.stopComBufferTrace();
0: 	}
0: 	/**
0: 	 * Add database to session table
0: 	 */
0: 	protected void addDatabase(Database d)
0: 	{
0: 		dbtable.put(d.dbName, d);
0: 	}
1: 
0: 	/**
0: 	 * Get database
0: 	 */
0: 	protected Database getDatabase(String dbName)
0: 	{
0: 		return (Database)dbtable.get(dbName);
0: 	}
1: 
1: 
0: 	/**
0: 	 * Get session into initial state
0: 	 *
0: 	 * @param traceDirectory	- directory for trace files
0: 	 */
0: 	private void initialize(String traceDirectory)
0: 		throws IOException
0: 	{
0: 		sessionInput = clientSocket.getInputStream();
0: 		sessionOutput = clientSocket.getOutputStream();
0: 		if (traceOn)
0: 			initTrace(traceDirectory);
0: 		state = INIT;
0: 	}
1: 
0: 	protected  String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
0: 	{
0: 		String s = "";
0: 		s += indent +  localLangUtil.getTextMessage("DRDA_RuntimeInfoSessionNumber.I")
0: 			+ connNum + "\n";
0: 		if (database == null)
0: 			return s;
0: 		s += database.buildRuntimeInfo(indent,localLangUtil);
0: 		s += "\n";
0: 		return s;
0: 	}
1: 
0: 	private String getStateString(int s)
0: 	{
0: 		switch (s)
0: 		{
0: 			case INIT: 
0: 				return "INIT";
0: 			case ATTEXC:
0: 				return "ATTEXC";
0: 			case CLOSED:
0: 				return "CLOSED";
0: 			default:
0: 				return "UNKNOWN_STATE";
1: 
0: 		}
0: 	}
1: 
0: 	private String getTypeString(int t)
0: 	{
0: 		switch (t)
0: 		{
0: 			case DRDA_SESSION:
0: 				return "DRDA_SESSION";
0: 			case CMD_SESSION:
0: 				return "CMD_SESSION";
0: 			default:
0: 				return "UNKNOWN_TYPE";
0: 		}
1: 					
0: 	}
0: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.net.Socket;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
0: import java.sql.SQLException;
0: 
0: /**
0: 	Session stores information about the current session
0: 	It is used so that a DRDAConnThread can work on any session.
0: */
0: class Session
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0: 	// session states
0: 	protected static final int INIT = 1;	// before exchange of server attributes
0: 	protected static final int ATTEXC = 2;	// after exchange of server attributes
0: 	protected static final int CLOSED = 3;	// session has ended
0: 
0: 	// session types
0: 	protected static final int DRDA_SESSION = 1;
0: 	protected static final int CMD_SESSION = 2;
0: 	
0: 	// trace name prefix and suffix
0: 	private static final String TRACENAME_PREFIX = "Server";
0: 	private static final String TRACENAME_SUFFIX = ".trace";
0: 
0: 	// session information
0: 	protected Socket clientSocket;		// session socket
0: 	protected int connNum;				// connection number
0: 	protected InputStream sessionInput;	// session input stream
0: 	protected OutputStream sessionOutput;	// session output stream
0: 	protected String traceFileName;		// trace file name for session
0: 	protected boolean traceOn;			// whether trace is currently on for the session
0: 	protected int state;				// the current state of the session
0: 	protected int sessionType;			// type of session - DRDA or NetworkServerControl command
0: 	protected String drdaID;			// DRDA ID of the session
0: 	protected DssTrace dssTrace;		// trace object associated with the session
0: 	protected AppRequester appRequester;	// Application requester for this session
0: 	protected Database database;		// current database
0: 	protected int qryinsid;				// unique identifier for each query
0: 	protected LocalizedResource langUtil;		// localization information for command session
0: 										// client
0: 
0: 	private	Hashtable	dbtable;		// Table of databases accessed in this session
0: 
0: 	// constructor
0: 	/**
0: 	 * Session constructor
0: 	 * 
0: 	 * @param connNum		connection number
0: 	 * @param clientSocket	communications socket for this session
0: 	 * @param traceDirectory	location for trace files
0: 	 * @param traceOn		whether to start tracing this connection
0: 	 *
0: 	 * @exception throws IOException
0: 	 */
0: 	protected Session (int connNum, Socket clientSocket, String traceDirectory,
0: 			boolean traceOn) throws IOException
0: 	{
0: 		this.connNum = connNum;
0: 		this.clientSocket = clientSocket;
0: 		this.traceOn = traceOn;
0: 		if (traceOn)
0: 			dssTrace = new DssTrace(); 
0: 		dbtable = new Hashtable();
0: 		initialize(traceDirectory);
0: 	}
0: 
0: 	/**
0: 	 * Close session - close connection sockets and set state to closed
0: 	 * 
0: 	 */
0: 	protected void close() throws SQLException
0: 	{
0: 		
0: 		try {
0: 			sessionInput.close();
0: 			sessionOutput.close();
0: 			clientSocket.close();
0: 			if (dbtable != null)
0: 				for (Enumeration e = dbtable.elements() ; e.hasMoreElements() ;) 
0: 				{
0: 					((Database) e.nextElement()).close();
0: 				}
0: 			
0: 		}catch (IOException e) {} // ignore IOException when we are shutting down
0: 		finally {
0: 			state = CLOSED;
0: 			dbtable = null;
0: 			database = null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * initialize a server trace for the DRDA protocol
0: 	 * 
0: 	 * @param traceDirectory - directory for trace file
0: 	 */
0: 	protected void initTrace(String traceDirectory)
0: 	{
0: 		if (traceDirectory != null)
0: 			traceFileName = traceDirectory + "/" + TRACENAME_PREFIX+
0: 				connNum+ TRACENAME_SUFFIX;
0: 		else
0: 			traceFileName = TRACENAME_PREFIX +connNum+ TRACENAME_SUFFIX;
0: 		traceOn = true;
0: 		if (dssTrace == null)
0: 			dssTrace = new DssTrace();
0: 		dssTrace.startComBufferTrace (traceFileName);
0: 	}
0: 
0: 	/**
0: 	 * Set tracing on
0: 	 * 
0: 	 * @param traceDirectory 	directory for trace files
0: 	 */
0: 	protected void setTraceOn(String traceDirectory)
0: 	{
0: 		if (traceOn)
0: 			return;
0: 		initTrace(traceDirectory);
0: 	}
0: 	/**
0: 	 * Get whether tracing is on 
0: 	 *
0: 	 * @return true if tracing is on false otherwise
0: 	 */
0: 	protected boolean isTraceOn()
0: 	{
0: 		if (traceOn)
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	/**
0: 	 * Get connection number
0: 	 *
0: 	 * @return connection number
0: 	 */
0: 	protected int getConnNum()
0: 	{
0: 		return connNum;
0: 	}
0: 
0: 	/**
0: 	 * Set tracing off
0: 	 * 
0: 	 */
0: 	protected void setTraceOff()
0: 	{
0: 		if (! traceOn)
0: 			return;
0: 		traceOn = false;
0: 		if (traceFileName != null)
0: 			dssTrace.stopComBufferTrace();
0: 	}
0: 	/**
0: 	 * Add database to session table
0: 	 */
0: 	protected void addDatabase(Database d)
0: 	{
0: 		dbtable.put(d.dbName, d);
0: 	}
0: 
0: 	/**
0: 	 * Get database
0: 	 */
0: 	protected Database getDatabase(String dbName)
0: 	{
0: 		return (Database)dbtable.get(dbName);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get session into initial state
0: 	 *
0: 	 * @param traceDirectory	- directory for trace files
0: 	 */
0: 	private void initialize(String traceDirectory)
0: 		throws IOException
0: 	{
0: 		sessionInput = clientSocket.getInputStream();
0: 		sessionOutput = clientSocket.getOutputStream();
0: 		if (traceOn)
0: 			initTrace(traceDirectory);
0: 		state = INIT;
0: 	}
0: 
0: 	protected  String buildRuntimeInfo(String indent, LocalizedResource localLangUtil)
0: 	{
0: 		String s = "";
0: 		s += indent +  localLangUtil.getTextMessage("DRDA_RuntimeInfoSessionNumber.I")
0: 			+ connNum + "\n";
0: 		if (database == null)
0: 			return s;
0: 		s += database.buildRuntimeInfo(indent,localLangUtil);
0: 		s += "\n";
0: 		return s;
0: 	}
0: 
0: 	private String getStateString(int s)
0: 	{
0: 		switch (s)
0: 		{
0: 			case INIT: 
0: 				return "INIT";
0: 			case ATTEXC:
0: 				return "ATTEXC";
0: 			case CLOSED:
0: 				return "CLOSED";
0: 			default:
0: 				return "UNKNOWN_STATE";
0: 
0: 		}
0: 	}
0: 
0: 	private String getTypeString(int t)
0: 	{
0: 		switch (t)
0: 		{
0: 			case DRDA_SESSION:
0: 				return "DRDA_SESSION";
0: 			case CMD_SESSION:
0: 				return "CMD_SESSION";
0: 			default:
0: 				return "UNKNOWN_TYPE";
0: 		}
0: 					
0: 	}
0: }
============================================================================