1:eac0369: /*
2:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BranchControlRow
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.SQLLongint;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
2:eac0369: /**
1:787ceb4:  * @derby.formatId ACCESS_BTREE_BRANCHCONTROLROW_V1_ID
3:eac0369:  *
1:787ceb4:  * @derby.purpose    Btree pages all have a control row at the front of every page.
1:eac0369:  *             To determine the type of row, read the first column which is a
1:eac0369:  *             format id and it tells what kind of control row it is.
1:eac0369:  *
1:787ceb4:  * @derby.upgrade    RESOLVE.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout
1:eac0369:  * column 1 - control row type         : StorableFormatId
1:eac0369:  * column 2 - left sibling page number : SQLLongint
1:eac0369:  * column 3 - right sibling page number: SQLLongint
1:eac0369:  * column 4 - parent page number       : SQLLongint
1:eac0369:  * column 5 - level number (0 is leaf) : SQLLongint
1:eac0369:  * column 6 - isRoot                   : SQLLongint
1:eac0369:  * column 7 - Conglomerate object      : null unless it is root else
1:eac0369:  *                                       a Conglomerate object, matching
1:eac0369:  *                                       that of current table.
1:eac0369:  *                                       Currently this field
1:eac0369:  *                                       is only used by logical undo and
1:eac0369:  *                                       the type of object is inferred by
1:eac0369:  *                                       the logical undo code.
1:eac0369:  * column 8 - left child page number   : SQLLongint
1:eac0369:  **/
1:eac0369: 
1:eac0369: /**
1:eac0369: A branch row contains key fields and the pointer to the child page.
1:eac0369: **/
1:eac0369: public class BranchControlRow extends ControlRow
1:eac0369: {
1:eac0369:     protected SQLLongint    left_child_page = null;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Only allocate one child_pageno_buf to read the page pointer field into,
1:eac0369:      * then cache to "empty" object for reuse by the page itself.
1:eac0369:      **/
1:eac0369:     transient SQLLongint     child_pageno_buf = null;
1:eac0369: 
1:eac0369:     /* Column assignments */
1:eac0369:     private static final int CR_LEFTCHILD     = ControlRow.CR_COLID_LAST + 1;
1:eac0369:     private static final int CR_COLID_LAST    = CR_LEFTCHILD;
1:eac0369:     private static final int CR_NCOLUMNS      = CR_COLID_LAST + 1;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * bit sets used to fetch single columns at a time.
1:eac0369:      **/
1:eac0369:     protected static final FormatableBitSet   CR_LEFTCHILD_BITMAP = 
1:eac0369:         new FormatableBitSet(CR_LEFTCHILD + 1);
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors of BranchControlRow
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     static 
1:eac0369:     {
1:eac0369:         CR_LEFTCHILD_BITMAP.set(CR_LEFTCHILD);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * No arg constructor.
1:eac0369:      * <p>
1:eac0369:      * Public no arg constructor is for the monitor to call for format
1:eac0369:      * id implementation, it should not be called for any other reason.
1:eac0369:      **/
1:eac0369:     public BranchControlRow()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public BranchControlRow(
1:eac0369:     OpenBTree       open_btree,
1:eac0369:     Page            page,
1:eac0369:     int             level,
1:eac0369:     ControlRow      parent,
1:eac0369:     boolean         isRoot,
1:eac0369:     long            left_child)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		super(open_btree, page,
1:eac0369:               level, parent, isRoot);
1:eac0369: 
1:eac0369:         this.left_child_page = new SQLLongint(left_child);
1:eac0369: 
1:eac0369:         // finish initializing the row to be used for interacting with
1:eac0369:         // raw store to insert, fetch, and update the control row on the page.
1:eac0369:         this.row[CR_LEFTCHILD] = left_child_page;
1:eac0369: 
1:eac0369:         // set up buffer to read a branch row's page number into.
1:eac0369:         child_pageno_buf = new SQLLongint();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Non - Debug/consistency check Methods of ControlRow:
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Perform page specific initialization.
1:eac0369:      * <p>
1:eac0369:      **/
1:4a2b0d9:     protected final void controlRowInit()
1:eac0369:     {
1:eac0369:         child_pageno_buf = new SQLLongint();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the current page the leftmost leaf of tree?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return true if the current page is the leftmost leaf of the tree,
1:eac0369:      *              else return false.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean isLeftmostLeaf()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(false);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the current page the rightmost leaf of tree?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return true if the current page is the rightmost leaf of the tree,
1:eac0369:      *              else return false.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean isRightmostLeaf()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(false);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the number of columns in the control row.  
1:eac0369:      * <p>
1:eac0369:      * Control rows all share the first columns as defined by this class and
1:eac0369:      * then add columns to the end of the control row.  For instance a branch
1:eac0369:      * control row add a child page pointer field.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The total number of columns in the control row.
1:eac0369:      **/
1:eac0369:     protected final int getNumberOfControlRowColumns()
1:eac0369:     {
1:eac0369:         return(this.CR_NCOLUMNS);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public static long restartSplitFor(
1:eac0369:     OpenBTree               open_btree,
1:eac0369:     DataValueDescriptor[]	template,
1:eac0369:     BranchControlRow        parent,
1:eac0369:     ControlRow              child,
1:eac0369:     DataValueDescriptor[]	newbranchrow,
1:eac0369:     DataValueDescriptor[]	splitrow,
1:eac0369:     int                     flag)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         // release parent and current latch
1:eac0369:         parent.release();
1:eac0369:         child.release();
1:eac0369:         parent = null;
1:eac0369:         child  = null;
1:eac0369: 
1:eac0369:         // Get the root page back, and perform a split following the
1:eac0369:         // branch row which would not fit.
1:4a2b0d9:         ControlRow root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(root.page.isLatched());
1:eac0369: 
1:eac0369:         return(root.splitFor(open_btree, template, null, newbranchrow, flag));
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Perform a recursive search, ultimately returning the latched
1:eac0369: 	 ** leaf page and row slot after which the given key belongs.
1:eac0369: 	 ** The slot is returned in the result structure.  If the key
1:eac0369: 	 ** exists on the page, the result.exact will be true.  Otherwise,
1:eac0369: 	 ** result.exact will be false, and the row slot returned will be
1:eac0369: 	 ** the one immediately preceding the position at which the key
1:eac0369: 	 ** belongs.
1:eac0369:      **
1:eac0369:      ** @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	public ControlRow search(SearchParameters sp)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow childpage    = null;
1:eac0369:         long       childpageid;
1:eac0369:         boolean    got_error    = true;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             searchForEntry(sp);
1:eac0369: 
1:eac0369:             if (sp.searchForOptimizer)
1:eac0369:             {
1:eac0369:                 // Update left_fraction to be used to esitimate the number of
1:eac0369:                 // rows left of the current search key.
1:eac0369: 
1:eac0369:                 // Some search results leave the search positioned on the 0th
1:eac0369:                 // slot which is a control row, in branch pages this results
1:eac0369:                 // in following the left page pointer, there is no key 
1:eac0369:                 // associated with this slot.  Set left_rows to be the number
1:eac0369:                 // of leaf page pointers on the page which are left
1:eac0369:                 // of the current slot.
1:eac0369:                 float left_rows = sp.resultSlot;
1:eac0369: 
1:eac0369:                 // include the control row count here, as it accounts for the
1:eac0369:                 // left page pointer which has no associated key.
1:eac0369:                 int   row_count = this.page.recordCount();
1:eac0369: 
1:eac0369:                 if (this.getIsRoot())
1:eac0369:                 {
1:eac0369:                     sp.current_fraction = 1;
1:eac0369:                     sp.left_fraction    = 0;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // calculate the fraction of rows in the table which are left 
1:eac0369:                 // of the current slot in the search.  This number represents
1:eac0369:                 // the fraction of rows in the sub-tree which includes all 
1:eac0369:                 // rows left of rows pointed at by the sub-tree to be followed
1:eac0369:                 // by the code below which descends the child page pointer.
1:eac0369:                 // After the search is 
1:eac0369:                 // completed (sp.left_fraction * number of rows), is the 
1:eac0369:                 // estimated number of rows to the left of the current row.
1:eac0369:                 sp.left_fraction    += 
1:eac0369:                     (sp.current_fraction) * (left_rows / row_count);
1:eac0369: 
1:eac0369:                 sp.current_fraction = 
1:eac0369:                     (sp.current_fraction) * (((float) 1) / row_count);
1:eac0369:             }
1:eac0369: 
1:eac0369:             childpage =
1:eac0369:                 this.getChildPageAtSlot(sp.btree, sp.resultSlot);
1:eac0369: 
1:eac0369:             this.release();
1:eac0369: 
1:eac0369:             got_error = false;
1:eac0369: 
1:eac0369:             return childpage.search(sp);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (got_error)
1:eac0369:             {
1:eac0369:                 if (childpage != null)
1:eac0369:                     childpage.release();
1:eac0369:                 if (this.page.isLatched())
1:eac0369:                     this.release();
1:eac0369:             }
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Search and return the left most leaf page.
1:eac0369:      * <p>
1:eac0369: 	 * Perform a recursive search, ultimately returning the
1:eac0369:      * leftmost leaf page which is the first leaf page in the
1:eac0369: 	 * leaf sibling chain.  (This method might better be called
1:eac0369: 	 * getFirstLeafPage()).
1:eac0369:      *
1:eac0369: 	 * @return The leftmost leaf page.
1:eac0369:      *
2:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow searchLeft(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow childpage    = null;
1:eac0369:         boolean    got_error    = true;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             childpage = this.getLeftChild(btree);
1:eac0369:             this.release();
1:eac0369: 
1:eac0369:             got_error = false;
1:eac0369:             return childpage.searchLeft(btree);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (got_error)
1:eac0369:             {
1:eac0369:                 if (childpage != null)
1:eac0369:                     childpage.release();
1:eac0369:                 if (this.page.isLatched())
1:eac0369:                     this.release();
1:eac0369:             }
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Search and return the right most leaf page.
1:eac0369:      * <p>
1:eac0369: 	 * Perform a recursive search, ultimately returning the
1:eac0369: 	 * rightmost leaf page which is the last leaf page in the
1:eac0369: 	 * leaf sibling chain.  (This method might better be called
1:eac0369: 	 * getLastLeafPage()).
1:eac0369:      *
1:eac0369: 	 * @return The rightmost leaf page.
1:eac0369:      *
1:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow searchRight(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow childpage    = null;
1:eac0369:         boolean    got_error    = true;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             childpage = this.getRightChild(btree);
1:eac0369:             this.release();
1:eac0369: 
1:eac0369:             got_error = false;
1:eac0369:             return(childpage.searchRight(btree));
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (got_error)
1:eac0369:             {
1:eac0369:                 if (childpage != null)
1:eac0369:                     childpage.release();
1:eac0369:                 if (this.page.isLatched())
1:eac0369:                     this.release();
1:eac0369:             }
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 **	Perform a recursive shrink operation for the key.
1:eac0369: 	 ** If this method returns true, the caller should
1:eac0369: 	 ** remove the corresponding entry for the page.
1:eac0369: 	 ** This routine is not guaranteed to successfully
1:eac0369: 	 ** shrink anything.  The page lead to by the key might
1:eac0369: 	 ** turn out not to be empty by the time shrink gets
1:eac0369: 	 ** there, and shrinks will give up if there is a deadlock.
1:eac0369: 	 ** <P>
1:eac0369: 	 ** The receiver page must be latched on entry and is
1:eac0369: 	 ** returned latched.
1:eac0369:      **
1:eac0369:      ** @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	protected boolean shrinkFor(
1:eac0369:     OpenBTree               open_btree, 
1:eac0369:     DataValueDescriptor[]   shrink_key)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow childpage = null;
1:eac0369:         boolean    shrinkme  = false;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.page.isLatched());
1:eac0369: 
1:eac0369:             // Find the child page for the shrink key.
1:eac0369: 
1:eac0369:             BranchRow branch_template =
1:722a889:                 BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:722a889:                     open_btree.getConglomerate());
1:722a889: 
1:eac0369:             SearchParameters sp = new SearchParameters(
1:eac0369:                 shrink_key,
1:eac0369:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:eac0369:                 branch_template.getRow(), open_btree, false);
1:eac0369: 
1:eac0369:             this.searchForEntry(sp);
1:eac0369:             childpage = this.getChildPageAtSlot(sp.btree, sp.resultSlot);
1:eac0369: 
1:eac0369:             // Recursively shrink the child.  If this call returns
1:eac0369:             // true, then the child page has been deleted from its
1:eac0369:             // sibling chain, and we have to delete the entry for it
1:eac0369:             // in this page.
1:eac0369: 
1:eac0369:             if (childpage.shrinkFor(open_btree, shrink_key))
1:eac0369:             {
1:eac0369:                 // Child was deallocated.
1:eac0369:                 if (sp.resultSlot != 0)
1:eac0369:                 {
1:eac0369:                     // Remove the corresponding branch row.  This call assumes
1:eac0369:                     // that raw store will shift all higher slots down to fill
1:eac0369:                     // the purged slot.
1:eac0369:                     this.page.purgeAtSlot(sp.resultSlot, 1, true);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // Shrunk slot is zero, which means the left child page was
1:eac0369:                     // deallocated. If the current page is empty, then
1:eac0369:                     // we have to deallocate it.  Otherwise, we "slide" the rows
1:eac0369:                     // down, making the first index row into the left child,
1:eac0369:                     // and the second index row into the first, etc.
1:eac0369: 
1:eac0369:                     if (this.page.recordCount() > 1)
1:eac0369:                     {
1:eac0369:                         // There is a branch row on this page (besides the
1:eac0369:                         // control row).  Make the first branch row into the
1:eac0369:                         // left child.
1:eac0369: 
1:eac0369:                         long leftchildpageid =
1:eac0369:                             getChildPageIdAtSlot(open_btree, 1);
1:eac0369: 
1:eac0369:                         this.setLeftChildPageno(leftchildpageid);
1:eac0369: 
1:eac0369:                         // purge the row we just made the "left child", this
1:eac0369:                         // will automatically shifta all other rows "left" in
1:eac0369:                         // the tree.
1:eac0369:                         this.page.purgeAtSlot(1, 1, true);
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         // We shrunk the left child which was the last child on
1:eac0369:                         // the page.  This means that this entire subtree is
1:eac0369:                         // empty.  Again, there are two cases: root vs.
1:eac0369:                         // non-root.  Because this method waits till pages are
1:eac0369:                         // completely empty before deallocating them from the
1:eac0369:                         // index, an empty root page means an empty index.
1:eac0369:                         // If this page is not the root, then simply
1:eac0369:                         // deallocate it and return that fact to the caller.
1:eac0369: 
1:eac0369:                         if (this.getIsRoot())
1:eac0369:                         {
1:eac0369:                             // The root page has become empty.  If the root page
1:eac0369:                             // is empty, then the index is empty.  What has to
1:eac0369:                             // happen here is that this page has to be
1:eac0369:                             // converted back to an empty leaf page.
1:eac0369: 
1:eac0369:                             // With the current interface, after this page has
1:eac0369:                             // been converted to a leaf, the caller will be
1:eac0369:                             // left with a branch control row object, although
1:eac0369:                             // the page is a leaf page.  This same problem was
1:eac0369:                             // addressed in splitFor by adjusting the interface
1:eac0369:                             // - the two routines should at least have the same
1:eac0369:                             // interface style.
1:eac0369: 
1:eac0369:                             if (SanityManager.DEBUG)
1:eac0369:                             {
1:eac0369:                                 SanityManager.ASSERT(
1:eac0369:                                     this.page.recordCount() == 1);
1:eac0369:                             }
1:eac0369: 
1:eac0369:                             LeafControlRow newleafroot = new LeafControlRow(
1:eac0369:                                 open_btree, this.page, null, true);
1:eac0369: 
1:eac0369:                             newleafroot.page.updateAtSlot(
1:eac0369:                                 0, newleafroot.getRow(), 
1:eac0369:                                 (FormatableBitSet) null);
1:eac0369: 
1:eac0369:                             newleafroot.release();
1:eac0369: 
1:eac0369:                             shrinkme = true;
1:eac0369:                         }
1:eac0369:                         else
1:eac0369:                         {
1:eac0369:                             // This page is empty, but it's not the root.  We
1:eac0369:                             // have to unlink this page from its siblings, and
1:eac0369:                             // return to the parent branch page that its
1:eac0369:                             // branch row should be removed.
1:eac0369: 
1:eac0369:                             // Unlink this page from its siblings.
1:eac0369:                             if (this.unlink(open_btree))
1:eac0369:                             {
1:eac0369:                                 // Tell the caller to remove entry.
1:eac0369:                                 shrinkme = true;
1:eac0369:                             }
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             // If shrinkme then the page has been unlatched either by
1:eac0369:             // page.removePage(), or by the process of changing the root branch
1:eac0369:             // page to a root leaf page.
1:eac0369:             if (!shrinkme)
1:eac0369:                 this.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(shrinkme);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Perform a top down split pass making room for the the key in "row".
1:eac0369:      * <p>
1:eac0369:      * Perform a split such that a subsequent call to insert
1:eac0369: 	 * given the argument index row will likely find room for it.  Since 
1:eac0369:      * latches are released the client must code for the case where another
1:eac0369:      * user has grabbed the space made available by the split pass and be
1:eac0369:      * ready to do another split.
1:eac0369:      * <p>
1:eac0369:      * Latches:
1:eac0369:      * o PARENT    : is latched on entry (unless the split is the root then
1:eac0369:      *               there is no parent.
1:eac0369:      * o THISBRANCH: the current page is latched on entry.
1:eac0369:      * o CHILD     : latch the child page which will be pointed at by the
1:eac0369:      *               left child pointer of the new page.
1:eac0369:      *               RESOLVE (mikem) -see comments below
1:eac0369:      * o NEWPAGE   : Allocate and latch new page.
1:eac0369:      * o CHILD     : release. (RESOLVE)
1:eac0369:      * o fixparents: latch pages and reset their parent pointers.
1:eac0369:      *               Conditionally fix up the parent links on the pages
1:eac0369:      *               pointed at by the newly allocated page.  First get latch
1:eac0369:      *               and release on the left child page and then loop through
1:eac0369:      *               slots on NEWPAGE, from left to right getting and
1:eac0369:      *               releasing latches.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @return page number of the newly allocated leaf page created by split.
1:eac0369:      *
1:06dbbcf:      * @param open_btree The open btree to associate latches with.
1:eac0369:      * @param template   A scratch area to use while searching for split pass.
1:06dbbcf:      * @param parent     The parent page of the current page in the split pass.
1:eac0369:      *                   starts at null for root.
1:06dbbcf:      * @param splitrow   The key to make room for during the split pass.
1:eac0369:      * @param flag       A flag used to direct where point of split should be
1:eac0369:      *                   chosen.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected long splitFor(
1:eac0369:     OpenBTree               open_btree,
1:eac0369:     DataValueDescriptor[]	template,
1:eac0369:     BranchControlRow        parent,
1:eac0369:     DataValueDescriptor[]	splitrow,
1:eac0369:     int                     flag)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		int        childpageid;
1:eac0369: 		ControlRow childpage;
1:eac0369: 
1:eac0369: 		// On entry, the parent page is either latched by the caller,
1:eac0369: 		// or it's null (which implies that this object is the root).
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(parent != null || this.getIsRoot());
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 parent == null || parent.page.isLatched(),
1:eac0369:                 "parent page is not latched");
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(this.page.isLatched(),
1:eac0369:                 "page is not latched:");
1:eac0369:         }
1:eac0369: 
1:0750c7b:         if ((this.page.recordCount() - 1 >= BTree.maxRowsPerPage) ||
1:eac0369:             (!this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
1:eac0369: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
1:eac0369:         {
1:eac0369: 
1:eac0369:             if (this.page.recordCount() == 1)
1:eac0369:             {
1:eac0369:                 // RESOLVE (mikem) long row issue.  For now it makes no sense
1:eac0369:                 // to split if there are no rows.  So if spaceForRecord() fails
1:eac0369:                 // on empty page, we throw exception.
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_NO_SPACE_FOR_KEY);
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Track.BranchSplit++;
1:eac0369: 
1:eac0369: 			if (this.getIsRoot())
1:eac0369: 			{
1:eac0369: 				// Track.BranchSplitRoot++;
1:eac0369: 				growRoot(open_btree, template, this);
1:eac0369: 
1:eac0369: 				parent = (BranchControlRow)
1:4a2b0d9:                     ControlRow.get(open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369: 
1:eac0369: 				return(parent.splitFor(
1:eac0369:                         open_btree, template, null, splitrow, flag));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// At this point we know that this page has to be split and
1:eac0369: 			// that it isn't a root page.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(!this.getIsRoot());
1:eac0369:                 SanityManager.ASSERT(parent != null);
1:eac0369:             }
1:eac0369: 
1:eac0369:             int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
1:eac0369: 
1:eac0369:             if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
1:eac0369:             {
1:eac0369:                 // move all the row to the new page
1:eac0369:                 splitpoint = 1;
1:eac0369:             }
1:eac0369:             else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
1:eac0369:             {
1:eac0369:                 // This is not optimal as we would rather move no rows to the
1:eac0369:                 // next page, but what should we use as a discriminator?
1:eac0369:                 splitpoint = this.page.recordCount() - 1;
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369: 				if (splitpoint <= 0)
1:eac0369:                 	SanityManager.THROWASSERT(this + "yikes! splitpoint of 0!");
1:eac0369:             }
1:eac0369: 
1:eac0369: 
1:eac0369:             // Before any logged operation is done in the current internal
1:eac0369:             // xact, make sure that there is room in the parent to insert
1:eac0369:             // the new branch row.
1:eac0369:             //
1:eac0369: 			// Create a new branch row which points to the new page,
1:eac0369:             // and insert it on parent page.
1:eac0369: 
1:eac0369:             // Read in the branch row which is at the split point.
1:eac0369:             BranchRow split_branch_row =
1:722a889:                 BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:722a889:                     open_btree.getConglomerate());
1:eac0369: 
1:eac0369:             this.page.fetchFromSlot(
1:eac0369:                 (RecordHandle) null, splitpoint, split_branch_row.getRow(), 
1:eac0369:                 (FetchDescriptor) null, true);
1:eac0369: 
1:eac0369:             // Create the branch row to insert onto the parent page.  For now
1:eac0369:             // use a fake page number because we don't know the real page
1:eac0369:             // number until the allocate is done, but want to delay the
1:eac0369:             // allocate until we know the insert will succeed.
1:eac0369: 			BranchRow newbranchrow =
1:eac0369:                 split_branch_row.createBranchRowFromOldBranchRow(
1:eac0369:                         BranchRow.DUMMY_PAGE_NUMBER);
1:eac0369: 
1:eac0369:             // At this point we have guaranteed there is space in the parent
1:eac0369:             // page for splitrow, but it could be the case that the new
1:eac0369:             // "newbranchrow" does not fit on the parent page.
1:eac0369:             if (!parent.page.spaceForInsert(
1:eac0369:                     newbranchrow.getRow(), (FormatableBitSet) null,
1:eac0369: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
1:eac0369:             {
1:eac0369:                 // There is no room on the parent page to complete a split at
1:eac0369:                 // the current level, so restart the split at top with the
1:eac0369:                 // branchrow that did not fit.  On return from this routine
1:eac0369:                 // there is no way to know the state of the tree, so the
1:eac0369:                 // current split pass recursion must end.
1:eac0369:                 return(
1:56a7b39:                     BranchControlRow.restartSplitFor(
1:eac0369:                         open_btree, template, parent, this,
1:eac0369:                         newbranchrow.getRow(), splitrow, flag));
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Get the child page for the index row at the split point
1:eac0369: 			// This will be the left child for	the new page.  We're
1:eac0369: 			// getting the page because BranchControlRow.Allocate
1:eac0369: 			// sets the left child pointer from a BranchControlRow.
1:eac0369: 			// If there were a version which just took the pageid,
1:eac0369: 			// we wouldn't have to get the page (the latch on this
1:eac0369: 			// page is enough to ensure that the child page won't
1:eac0369: 			// disappear).
1:eac0369: 
1:eac0369:             childpage = this.getChildPageAtSlot(open_btree, splitpoint);
1:eac0369: 
1:eac0369: 			// Allocate a new branch page and link it to the
1:eac0369: 			// right of the current page.
1:eac0369: 			BranchControlRow newbranch =
1:4a2b0d9:                 BranchControlRow.allocate(open_btree, childpage,
1:eac0369:                     this.getLevel(), parent);
1:eac0369: 			newbranch.linkRight(open_btree, this);
1:eac0369: 
1:eac0369: 
1:eac0369:             // Test fail after allocation
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("branch_split_abort1"))
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Done with the child page.
1:eac0369: 			childpage.release();
1:eac0369: 
1:eac0369:             // Now that we know the page number of the new child page update
1:eac0369:             // the branch row to be inserted with the correct value.
1:eac0369:             newbranchrow.setPageNumber(newbranch.page.getPageNumber());
1:eac0369: 
1:eac0369:             BranchRow branch_template =
1:722a889:                 BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:722a889:                     open_btree.getConglomerate());
1:eac0369: 			SearchParameters sp = new SearchParameters(
1:eac0369:                 newbranchrow.getRow(),
1:eac0369:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:eac0369:                 branch_template.getRow(),
1:eac0369:                 open_btree, false);
1:eac0369: 
1:eac0369: 			parent.searchForEntry(sp);
1:eac0369: 
1:eac0369: 			byte insertFlag = Page.INSERT_INITIAL;
1:eac0369: 			insertFlag |= Page.INSERT_DEFAULT;
1:eac0369: 			insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
1:eac0369: 			if (parent.page.insertAtSlot(
1:eac0369:                     sp.resultSlot + 1,
1:eac0369:                     newbranchrow.getRow(),
1:eac0369:                     (FormatableBitSet) null,
1:eac0369:                     (LogicalUndo)null,
1:eac0369:                     insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)
1:eac0369: 					== null)
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369:             // Test fail after of row onto parent page.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("branch_split_abort2"))
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             // newbranchrow only valid while contents of split_branch_row
1:eac0369:             // remain unchanged.
1:eac0369:             newbranchrow = null;
1:eac0369: 
1:eac0369: 			// Copy the rows from the split point, but not including it (since
1:eac0369:             // the split point is turning into the left child of the new
1:eac0369:             // branch), onto the new page.  Purge the rows including the split
1:eac0369: 			// point from the current page.
1:eac0369:             int num_rows_to_move = this.page.recordCount() - (splitpoint + 1);
1:eac0369: 
1:eac0369:             if (num_rows_to_move > 0)
1:eac0369:             {
1:eac0369:                 this.page.copyAndPurge(
1:eac0369:                     newbranch.page, splitpoint + 1, num_rows_to_move, 1);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // remove the splitpoint row, we didn't copy it because it became
1:eac0369:             // the "left child", but we do need to get rid of it.
1:eac0369: 			this.page.purgeAtSlot(splitpoint, 1, true);
1:eac0369: 
1:eac0369:             // Test fail after of copy of rows to new page.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("branch_split_abort3"))
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             // Test fail after purge of rows on old page.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("branch_split_abort4"))
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             // Check pages that have been altered by above split
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:                 {
1:eac0369:                     parent.checkConsistency(open_btree, null, false);
1:eac0369:                     newbranch.checkConsistency(open_btree, parent, false);
1:eac0369:                     this.checkConsistency(open_btree, parent, false);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Fix up the parent links on the pages for the rows that moved to
1:eac0369:             // the new branch.
1:eac0369: 			newbranch.fixChildrensParents(open_btree, null);
1:eac0369: 
1:eac0369:             // At this point a unit of work in the split down the tree has
1:eac0369:             // been performed in an internal transaction (ie. writes have been
1:eac0369:             // done to latched pages), and the resulting
1:eac0369:             // tree is logically consistent, thus the work can be committed.
1:eac0369:             // This work must be committed before any latches are released.
1:eac0369:             open_btree.getXactMgr().commit();
1:eac0369: 
1:eac0369: 			// Decide whether we're following the current page or the new page.
1:eac0369: 			BranchControlRow pagetofollow;
1:eac0369: 
1:4a2b0d9:             if (compareIndexRowToKey(
1:eac0369:                     splitrow, 
1:eac0369:                     split_branch_row.getRow(),
1:eac0369:                     split_branch_row.getRow().length - 1, 0,
1:eac0369: 					open_btree.getConglomerate().ascDescInfo) >= 0)
1:eac0369:             {
1:eac0369:                 // Follow the new branch
1:eac0369: 				pagetofollow = newbranch;
1:eac0369: 				this.release();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// Follow the current branch
1:eac0369: 				pagetofollow = this;
1:eac0369: 				newbranch.release();
1:eac0369: 			}
1:eac0369: 
1:eac0369:             // At this point we hold latches on the parent, and the current
1:eac0369:             // child of the page that we are following.  Note that committing
1:eac0369:             // the internal transaction did not release the latches.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(parent != null);
1:eac0369:                 SanityManager.ASSERT(parent.page.isLatched());
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                         pagetofollow.page.isLatched());
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// Recurse down the tree splitting if necessary.
1:eac0369: 			return(
1:eac0369:                 pagetofollow.splitFor(
1:eac0369:                     open_btree, template, parent, splitrow, flag));
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 this.checkConsistency(open_btree, parent, false);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Don't need the parent any more.
1:eac0369: 		if (parent != null)
1:eac0369: 			parent.release();
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - should this be passed in?
1:eac0369:         BranchRow branch_template =
1:722a889:             BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:722a889:                     open_btree.getConglomerate());
1:722a889: 
1:eac0369: 		SearchParameters sp = new SearchParameters(
1:eac0369:             splitrow, 
1:eac0369:             SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:eac0369:             branch_template.getRow(), 
1:eac0369:             open_btree, false);
1:eac0369: 
1:eac0369: 		searchForEntry(sp);
1:eac0369: 
1:eac0369:         childpage = this.getChildPageAtSlot(open_btree, sp.resultSlot);
1:eac0369: 
1:eac0369:         return(childpage.splitFor(open_btree, template, this, splitrow, flag));
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Debug/consistency check Methods of ControlRow:
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Perform consistency checks for a branch page.  The checks
1:eac0369: 	 ** specific to a branch page are:
1:eac0369: 	 ** <menu>
1:eac0369: 	 ** <li> The rows on the page are indeed branch rows, and
1:eac0369: 	 **      they all have the correct number of fields (which
1:eac0369: 	 **      is the b-tree's key fields plus one for the child
1:eac0369: 	 **      page number.
1:eac0369: 	 ** <li> The child pages pointed to by the left child pointer
1:eac0369: 	 **      and the index rows are linked together in the same
1:eac0369: 	 **      order that they appear on the page.
1:eac0369: 	 ** <li> The child pages themselves are all consistent.
1:eac0369: 	 ** </menu>
1:eac0369: 	 ** This method also performs the consistency checks that
1:eac0369: 	 ** are common to both leaf and branch pages (see
1:eac0369: 	 ** ControlRow.checkGeneric).
1:eac0369:      **
1:eac0369:      ** @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	public int checkConsistency(
1:eac0369:     OpenBTree  btree,
1:eac0369:     ControlRow parent,
1:eac0369:     boolean    check_other_pages)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// Do the consistency checks that are common to all
1:eac0369: 		// types of pages.
1:eac0369: 		checkGeneric(btree, parent, check_other_pages);
1:eac0369: 
1:eac0369:         // Branch specific Control Row checks.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 this.getLevel() > 0, "branch not above level 0");
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) - how to check right version?
1:eac0369:             /*
1:eac0369: 			if (this.getVersion() != CURRENT_BRANCH_VERSION)
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369:                 	"Expected branch version:(" + CURRENT_BRANCH_VERSION +
1:eac0369:                 	") but got (" + this.getVersion());
1:eac0369:             */
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) ==
1:eac0369:                 BranchControlRow.CR_NCOLUMNS);
1:eac0369:             SanityManager.ASSERT(getLeftChildPageno() !=
1:eac0369:                                  ContainerHandle.INVALID_PAGE_NUMBER);
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) - this makes an assumption about page numbering,
1:eac0369:             // that may not be always valid in all implementations but has
1:eac0369:             // been useful in finding bugs with uninitialized fields.
1:eac0369:             SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// The remaining checks are specific to branch pages.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 
1:eac0369:             // Check that all the branch rows are branch rows
1:eac0369:             // (we'll get a case error otherwise), and have the right
1:eac0369:             // number of columns.  Every branch row should have the
1:eac0369:             // btree's	key columns plus one for the child link.
1:eac0369:             int numslots = this.page.recordCount();
1:eac0369:             for (int slot = 1; slot < numslots; slot++)
1:eac0369:             {
1:eac0369: 				if ((this.page.fetchNumFieldsAtSlot(slot) !=
1:eac0369:                      (btree.getConglomerate().nKeyFields + 1)))
1:eac0369:                 	SanityManager.THROWASSERT(
1:eac0369:                     	"row[" + slot + "]"
1:eac0369:                         + " has " + this.page.fetchNumFieldsAtSlot(slot)
1:eac0369:                         + " columns, should have at least " +
1:eac0369:                         (btree.getConglomerate().nKeyFields + 1));
1:eac0369: 
1:eac0369:                 SanityManager.ASSERT(this.getChildPageIdAtSlot(btree, slot) !=
1:eac0369:                         ContainerHandle.INVALID_PAGE_NUMBER);
1:eac0369: 
1:eac0369:                 // Rows on branch pages are never deleted, they are only purged.
1:eac0369:                 SanityManager.ASSERT(!this.page.isDeletedAtSlot(slot));
1:eac0369: 
1:eac0369:                 // RESOLVE (mikem) - this makes an assumption about page
1:eac0369:                 // numbering, that may not be always valid in all
1:eac0369:                 // implementations but has been useful in finding bugs with
1:eac0369:                 // uninitialized fields.
1:eac0369:                 SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Check that the linkage of the children is in the
1:eac0369: 		// same order as the branch rows.
1:eac0369:         // RESOLVE (mikem) enable when multiple latches work.
1:eac0369:         if (check_other_pages)
1:eac0369: 		    checkChildOrderAgainstRowOrder(btree);
1:eac0369: 
1:eac0369: 		// Check the children.
1:eac0369: 		int nchildren = 0;
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) enable when multiple latches work.
1:eac0369:         if (check_other_pages)
1:eac0369:             nchildren = checkChildren(btree);
1:eac0369: 
1:eac0369: 		// Return the number of children visited plus one for this page.
1:eac0369: 		return nchildren + 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private int checkChildren(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 		int         nchildren = 0;
1:eac0369:         ControlRow  childpage = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // Check the left child.
1:eac0369:             childpage = this.getLeftChild(btree);
1:eac0369:             nchildren += childpage.checkConsistency(btree, this, true);
1:eac0369:             childpage.release();
1:eac0369:             childpage = null;
1:eac0369: 
1:eac0369:             // Check children from each index row.
1:eac0369:             int numslots = this.page.recordCount();
1:eac0369:             for (int slot = 1; slot < numslots; slot++)
1:eac0369:             {
1:eac0369:                 childpage = this.getChildPageAtSlot(btree, slot);
1:eac0369:                 nchildren += childpage.checkConsistency(btree, this, true);
1:eac0369:                 childpage.release();
1:eac0369:                 childpage = null;
1:eac0369:             }
1:eac0369: 
1:eac0369:             return(nchildren);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (childpage != null)
1:eac0369:                 childpage.release();
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 	private void checkChildOrderAgainstRowOrder(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		ControlRow cur  = null;
1:eac0369: 		ControlRow prev = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             prev = this.getLeftChild(btree);
1:eac0369: 
1:eac0369:             int numslots = this.page.recordCount();
1:eac0369:             for (int slot = 1; slot < numslots; slot++)
1:eac0369:             {
1:eac0369:                 cur = this.getChildPageAtSlot(btree, slot);
1:eac0369: 
1:eac0369:                 long shouldbecur_pageno = prev.getrightSiblingPageNumber();
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369: 					if (shouldbecur_pageno != cur.page.getPageNumber())
1:eac0369:                     	SanityManager.THROWASSERT(
1:eac0369:                         	"child linkage error going right.\n" +
1:eac0369:                         	"cur page control row = " + cur + "\n" +
1:eac0369:                         	"prev page control row = " + prev + "\n");
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 long shouldbeprev_pageno = cur.getleftSiblingPageNumber();
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         shouldbeprev_pageno == prev.page.getPageNumber(),
1:eac0369:                         "child linkeage error going left");
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 prev.release();
1:eac0369:                 prev = cur;
1:eac0369:                 cur  = null;
1:eac0369:             }
1:eac0369: 
1:eac0369:             prev.release();
1:eac0369:             prev = null;
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (prev != null)
1:eac0369:                 prev.release();
1:eac0369:             if (cur != null)
1:eac0369:                 cur.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Recursively print the tree starting at current node in tree.
1:eac0369:      *
1:eac0369:      * @param btree the open btree to print.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void printTree(
1:eac0369:     OpenBTree  btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
1:eac0369: 
1:eac0369:             ControlRow      child = null;
1:eac0369: 
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 child = this.getLeftChild(btree);
1:eac0369: 
1:eac0369:                 child.printTree(btree);
1:eac0369:                 child.release();
1:eac0369:                 child = null;
1:eac0369: 
1:eac0369:                 int numslots = this.page.recordCount();
1:eac0369:                 for (int slot = 1; slot < numslots; slot++)
1:eac0369:                 {
1:eac0369:                     child = this.getChildPageAtSlot(btree, slot);
1:eac0369:                     child.printTree(btree);
1:eac0369:                     child.release();
1:eac0369:                     child = null;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             finally
1:eac0369:             {
1:eac0369:                 if (child != null)
1:eac0369:                     child.release();
1:eac0369:             }
1:eac0369: 
1:eac0369:             return;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Private methods of BranchControlRow
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      ** Add a level to the tree by moving the current branch-root page up
1:eac0369:      ** one level and adding a new page as it's left child.  On exit the
1:eac0369:      ** current root page remains the root of the tree.
1:eac0369: 	 ** <P>
1:eac0369: 	 ** On entry, the current branch root page is expected to be latched.
1:eac0369:      ** On exit, all latches will have been released.
1:eac0369:      ** <P>
1:eac0369:      ** Latch order:
1:eac0369:      **    o ROOT: on entry current root is latched.
1:eac0369:      **            No other latches should be held.
1:eac0369:      **    o ROOT_OLDCHILD: Get and Latch root's left child page.
1:eac0369:      **    o ROOT_NEWCHILD: Allocate a new branch page with latch.
1:eac0369:      **    o Conditionally fix up the parent links on the pages pointed at
1:eac0369:      **      by the newly allocated page.  Loop through slots on ROOT_NEWCHILD,
1:eac0369:      **      from left to right getting and releasing latches.  Note that
1:eac0369:      **      fixChildrensParents() must not latch the leftchild as ROOT_OLDCHILD
1:eac0369:      **      is already latched.
1:eac0369:      **    RESOLVE: (mikem) does order of release matter.
1:eac0369:      **    o ROOT         : released.
1:eac0369:      **    o ROOT_NEWCHILD: released.
1:eac0369:      **    o ROOT_OLDCHILD: released.
1:eac0369: 	 **/
1:eac0369: 	private static void growRoot(
1:eac0369:     OpenBTree               open_btree,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     BranchControlRow        root)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         ControlRow       leftchild = null;
1:eac0369:         BranchControlRow branch    = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(root.page.isLatched());
1:eac0369:                 SanityManager.ASSERT(root.getIsRoot());
1:eac0369:             }
1:eac0369: 
1:eac0369:             // System.out.println("Growing root: control row = " + root);
1:eac0369:             // System.out.println("Growing root: page = " + root.page);
1:eac0369: 
1:eac0369:             // Get and latch the current root's left child.  This will become
1:eac0369:             // the left child on the new branch page (and the new
1:eac0369:             // branch will become the left child of the root).
1:eac0369:             leftchild = root.getLeftChild(open_btree);
1:eac0369: 
1:eac0369:             // Allocate a new branch page.	 This one will take the
1:eac0369:             // rows from the root, and remain at the old root's level.
1:eac0369:             // Its parent is the root.
1:eac0369:             branch =
1:4a2b0d9:                 BranchControlRow.allocate(
1:eac0369:                     open_btree, leftchild, root.getLevel(), root);
1:eac0369: 
1:eac0369:             // Copy all the index rows from the root to the new branch.
1:eac0369:             // Purge the index rows from the root now that they're safely on the
1:eac0369:             // new branch page.  Leave the branch control row on the page.
1:eac0369:             root.page.copyAndPurge(branch.page, 1, root.page.recordCount() - 1, 1);
1:eac0369: 
1:eac0369:             // Set the root's left child to be the new branch.
1:eac0369:             root.setLeftChild(branch);
1:eac0369: 
1:eac0369:             // Move the root up a level
1:eac0369:             root.setLevel(root.getLevel() + 1);
1:eac0369: 
1:eac0369:             // The parent of the old root's children has changed.
1:eac0369:             // It used to be page 0 (the old root, but now it's
1:eac0369:             // the new branch page.  Fix this up.
1:eac0369:             branch.fixChildrensParents(open_btree, leftchild);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:                 {
1:eac0369:                     root.checkConsistency(open_btree, null, false);
1:eac0369:                     branch.checkConsistency(open_btree, root, false);
1:eac0369:                     leftchild.checkConsistency(open_btree, branch, false);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             // At this point a unit of work in the split down the tree has
1:eac0369:             // been performed in an internal transaction.  This work must
1:eac0369:             // be committed before any latches are released.
1:eac0369:             open_btree.getXactMgr().commit();
1:eac0369: 
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             // At the end of a growRoot() no latches are held, the caller must
1:eac0369:             // restart at the root.
1:eac0369:             //
1:eac0369:             root.release();
1:eac0369:             if (branch != null)
1:eac0369:                 branch.release();
1:eac0369:             if (leftchild != null)
1:eac0369:                 leftchild.release();
1:eac0369:         }
1:eac0369:         return;
1:eac0369: 	}
1:eac0369:     /**
1:eac0369:      * Allocate a new leaf page to the conglomerate.
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369:      */
1:4a2b0d9:     private static BranchControlRow allocate(
1:eac0369:     OpenBTree         open_btree,
1:eac0369:     ControlRow        leftchild,
1:eac0369:     int               level,
1:eac0369:     ControlRow        parent)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         Page      page      = open_btree.container.addPage();
1:eac0369: 
1:eac0369:         // Create a control row for the new page.
1:eac0369:         BranchControlRow control_row =
1:eac0369:             new BranchControlRow(
1:eac0369:                 open_btree, page, level,
1:eac0369:                 parent, false, leftchild.page.getPageNumber());
1:eac0369: 
1:eac0369:         // Insert the control row on the page.
1:eac0369: 		byte insertFlag = Page.INSERT_INITIAL;
1:eac0369: 		insertFlag |= Page.INSERT_DEFAULT;
1:eac0369:         page.insertAtSlot(
1:eac0369:             Page.FIRST_SLOT_NUMBER,
1:eac0369:             control_row.getRow(),
1:eac0369:             (FormatableBitSet) null, 
1:eac0369:             (LogicalUndo)null,
1:eac0369:             insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1:eac0369: 
1:eac0369:         // Page is returned latched.
1:eac0369:         return(control_row);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	protected void setLeftChildPageno(long leftchild_pageno)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// Store the field.
1:eac0369: 		if (left_child_page == null)
1:eac0369: 			left_child_page = new SQLLongint(leftchild_pageno);
1:eac0369:         else
1:eac0369:             this.left_child_page.setValue(leftchild_pageno);
1:eac0369: 
1:eac0369: 		// Write the field through to the underlying row
1:eac0369: 		this.page.updateFieldAtSlot(
1:eac0369:             CR_SLOT, CR_LEFTCHILD, this.left_child_page, null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void setLeftChild(ControlRow leftchild)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         this.setLeftChildPageno(leftchild.page.getPageNumber());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** A branch page that has just been allocated as part
1:eac0369: 	 ** of a split has index rows and a left child pointer
1:eac0369: 	 ** that were copied from another page.  The parent
1:eac0369: 	 ** link on the corresponding pages will still point to
1:eac0369: 	 ** the original page.  This method fixes their parent
1:eac0369: 	 ** pointers so that they point to the curren page like
1:eac0369: 	 ** they're supposed to.
1:eac0369: 	 ** <P>
1:eac0369: 	 ** Note that maintaining the parent link is kind of a
1:eac0369: 	 ** pain, and will slow down applications.  It's only
1:eac0369: 	 ** needed for consistency checks, so we may want to
1:eac0369: 	 ** have implementations that don't bother to maintain it.
1:dbed020:      ** <P>
1:eac0369:      ** This
1:eac0369: 	 **/
1:eac0369: 	private void fixChildrensParents(
1:eac0369:     OpenBTree       btree,
1:eac0369:     ControlRow      leftchild)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         ControlRow child = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (leftchild == null)
1:eac0369:             {
1:eac0369:                 child = this.getLeftChild(btree);
1:eac0369:                 child.setParent(this.page.getPageNumber());
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:                     {
1:eac0369:                         child.checkConsistency(btree, this, false);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 child.release();
1:eac0369:                 child = null;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 leftchild.setParent(this.page.getPageNumber());
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:                     {
1:eac0369:                         leftchild.checkConsistency(btree, this, false);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             int numslots = this.page.recordCount();
1:eac0369:             for (int slot = 1; slot < numslots; slot++)
1:eac0369:             {
1:eac0369:                 child = getChildPageAtSlot(btree, slot);
1:eac0369:                 child.setParent(this.page.getPageNumber());
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:                     {
1:eac0369:                         child.checkConsistency(btree, this, false);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 child.release();
1:eac0369:                 child = null;
1:eac0369:             }
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (child != null)
1:eac0369:                 child.release();
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private long getChildPageIdAtSlot(
1:eac0369:     OpenBTree       btree,
1:eac0369:     int             slot)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         long child_page_id;
1:eac0369: 
1:eac0369:         if (slot == 0)
1:eac0369:         {
1:eac0369:             child_page_id = this.getLeftChildPageno();
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             this.page.fetchFieldFromSlot(
1:eac0369:                 slot, btree.getConglomerate().nKeyFields, child_pageno_buf);
1:eac0369:             child_page_id = child_pageno_buf.getLong();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(child_page_id);
1:eac0369:     }
1:eac0369: 
1:eac0369:     protected ControlRow getChildPageAtSlot(
1:eac0369:     OpenBTree       open_btree,
1:eac0369:     int             slot)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow  child_control_row;
1:eac0369: 
1:eac0369:         if (slot == 0)
1:eac0369:         {
1:eac0369:             child_control_row = this.getLeftChild(open_btree);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             this.page.fetchFieldFromSlot(
1:eac0369:                 slot, open_btree.getConglomerate().nKeyFields, 
1:eac0369:                 child_pageno_buf);
1:eac0369: 
1:eac0369:             child_control_row =
1:4a2b0d9:                 ControlRow.get(open_btree, child_pageno_buf.getLong());
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(child_control_row);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the left child pointer for the page.
1:eac0369:      * <p>
1:eac0369:      * Leaf pages don't have children, so they override this and return null.
1:eac0369:      *
1:eac0369: 	 * @return The page which is the leftmost child of this page.
1:eac0369:      *
1:06dbbcf:      * @param open_btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ControlRow getLeftChild(OpenBTree open_btree)
1:eac0369:             throws StandardException
1:eac0369:     {
1:4a2b0d9:          return(ControlRow.get(open_btree, this.getLeftChildPageno()));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the right child pointer for the page.
1:eac0369:      * <p>
1:eac0369:      * Leaf pages don't have children, so they override this and return null.
1:eac0369:      *
1:eac0369: 	 * @return The page which is the rightmost child of this page.
1:eac0369:      *
1:eac0369:      * @param open_btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow getRightChild(OpenBTree open_btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow right_child;
1:eac0369:         int        num_slots = this.page.recordCount();
1:eac0369: 
1:eac0369:         // if num_slots is 1 then there are no branch rows, so just follow
1:eac0369:         // the left page pointer, else if num_slots is > 1 then follow the
1:eac0369:         // last branch row to find the rightmost child.
1:eac0369:         right_child = 
1:eac0369:             (num_slots == 1 ? 
1:4a2b0d9:                 ControlRow.get(open_btree, this.getLeftChildPageno()) :
1:eac0369:                 getChildPageAtSlot(open_btree, (num_slots - 1)));
1:eac0369: 
1:eac0369:         return(right_child);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Return the left child page number for the page.  Leaf pages
1:eac0369: 	 ** don't have left children, so they override this and return
1:eac0369: 	 ** null.
1:eac0369: 	 **/
1:eac0369: 	long getLeftChildPageno()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (this.left_child_page == null)
1:eac0369:         {
1:eac0369:             this.left_child_page = new SQLLongint();
1:eac0369: 
1:eac0369:             scratch_row[CR_LEFTCHILD] = this.left_child_page;
1:eac0369: 
1:eac0369:             fetchDesc.setValidColumns(CR_LEFTCHILD_BITMAP);
1:eac0369:             this.page.fetchFromSlot(
1:eac0369:                (RecordHandle) null, CR_SLOT, scratch_row, fetchDesc, false); 
1:eac0369:         }
1:eac0369:         return(left_child_page.getLong());
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * TypedFormat:
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId()
1:eac0369:     {
1:eac0369: 		return StoredFormatIds.ACCESS_BTREE_BRANCHCONTROLROW_V1_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return a new template for reading a data row from the current page.
1:eac0369:      * <p>
1:eac0369:      * Default implementation for rows which are the same as the conglomerates
1:eac0369:      * template, sub-classes can alter if underlying template is different
1:eac0369:      * (for instance branch rows add an extra field at the end).
1:eac0369:      *
1:eac0369: 	 * @return Newly allocated template.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public DataValueDescriptor[] getRowTemplate(OpenBTree    open_btree)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:eac0369:                     open_btree.getConglomerate()).getRow());
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** The standard toString.
1:eac0369: 	 **/
1:eac0369: 	public String toString()
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             String string = super.toString();
1:eac0369: 
1:eac0369:             try 
1:eac0369:             {
1:eac0369:                 string += "left child page = " + getLeftChildPageno() + ";";
1:eac0369:                 
1:eac0369:             }
1:eac0369:             catch (Throwable t)
1:eac0369:             {
1:eac0369:                 string += "error encountered while doing ControlRow.toString()";
1:eac0369:             }
1:eac0369: 
1:eac0369:             return(string);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(null);
1:eac0369:         }
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      ** <P>
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0750c7b
/////////////////////////////////////////////////////////////////////////
1:         if ((this.page.recordCount() - 1 >= BTree.maxRowsPerPage) ||
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_BTREE_BRANCHCONTROLROW_V1_ID
1:  * @derby.purpose    Btree pages all have a control row at the front of every page.
1:  * @derby.upgrade    RESOLVE.
1:  * @derby.diskLayout
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1:                     BranchControlRow.restartSplitFor(
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:                 BranchRow.createEmptyTemplate(
1:                     open_btree.getRawTran(),
1:                     open_btree.getConglomerate());
1: 
/////////////////////////////////////////////////////////////////////////
1:                 BranchRow.createEmptyTemplate(
1:                     open_btree.getRawTran(),
1:                     open_btree.getConglomerate());
/////////////////////////////////////////////////////////////////////////
1:                 BranchRow.createEmptyTemplate(
1:                     open_btree.getRawTran(),
1:                     open_btree.getConglomerate());
/////////////////////////////////////////////////////////////////////////
1:             BranchRow.createEmptyTemplate(
1:                     open_btree.getRawTran(),
1:                     open_btree.getConglomerate());
1: 
/////////////////////////////////////////////////////////////////////////
1:                     open_btree.getRawTran(),
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
1:      * @param open_btree The open btree to associate latches with.
1:      * @param parent     The parent page of the current page in the split pass.
1:      * @param splitrow   The key to make room for during the split pass.
/////////////////////////////////////////////////////////////////////////
1:      * @param open_btree  The open btree to associate latches/locks with.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:     protected final void controlRowInit()
/////////////////////////////////////////////////////////////////////////
1:         ControlRow root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:                     ControlRow.get(open_btree, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:                 BranchControlRow.allocate(open_btree, childpage,
/////////////////////////////////////////////////////////////////////////
1:             if (compareIndexRowToKey(
/////////////////////////////////////////////////////////////////////////
1:                 BranchControlRow.allocate(
/////////////////////////////////////////////////////////////////////////
1:     private static BranchControlRow allocate(
/////////////////////////////////////////////////////////////////////////
1:                 ControlRow.get(open_btree, child_pageno_buf.getLong());
/////////////////////////////////////////////////////////////////////////
1:          return(ControlRow.get(open_btree, this.getLeftChildPageno()));
/////////////////////////////////////////////////////////////////////////
1:                 ControlRow.get(open_btree, this.getLeftChildPageno()) :
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BranchControlRow
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.SQLLongint;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
0:  * @format_id ACCESS_BTREE_BRANCHCONTROLROW_V1_ID
1:  *
0:  * @purpose    Btree pages all have a control row at the front of every page.
1:  *             To determine the type of row, read the first column which is a
1:  *             format id and it tells what kind of control row it is.
1:  *
0:  * @upgrade    RESOLVE.
1:  *
0:  * @disk_layout
1:  * column 1 - control row type         : StorableFormatId
1:  * column 2 - left sibling page number : SQLLongint
1:  * column 3 - right sibling page number: SQLLongint
1:  * column 4 - parent page number       : SQLLongint
1:  * column 5 - level number (0 is leaf) : SQLLongint
1:  * column 6 - isRoot                   : SQLLongint
1:  * column 7 - Conglomerate object      : null unless it is root else
1:  *                                       a Conglomerate object, matching
1:  *                                       that of current table.
1:  *                                       Currently this field
1:  *                                       is only used by logical undo and
1:  *                                       the type of object is inferred by
1:  *                                       the logical undo code.
1:  * column 8 - left child page number   : SQLLongint
1:  **/
1: 
1: /**
1: A branch row contains key fields and the pointer to the child page.
1: **/
1: public class BranchControlRow extends ControlRow
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     protected SQLLongint    left_child_page = null;
1: 
1: 
1:     /**
1:      * Only allocate one child_pageno_buf to read the page pointer field into,
1:      * then cache to "empty" object for reuse by the page itself.
1:      **/
1:     transient SQLLongint     child_pageno_buf = null;
1: 
1:     /* Column assignments */
1:     private static final int CR_LEFTCHILD     = ControlRow.CR_COLID_LAST + 1;
1:     private static final int CR_COLID_LAST    = CR_LEFTCHILD;
1:     private static final int CR_NCOLUMNS      = CR_COLID_LAST + 1;
1: 
1:     /**
1:      * bit sets used to fetch single columns at a time.
1:      **/
1:     protected static final FormatableBitSet   CR_LEFTCHILD_BITMAP = 
1:         new FormatableBitSet(CR_LEFTCHILD + 1);
1: 
1: 	/*
1: 	** Constructors of BranchControlRow
1: 	*/
1: 
1:     static 
1:     {
1:         CR_LEFTCHILD_BITMAP.set(CR_LEFTCHILD);
1:     }
1: 
1:     /**
1:      * No arg constructor.
1:      * <p>
1:      * Public no arg constructor is for the monitor to call for format
1:      * id implementation, it should not be called for any other reason.
1:      **/
1:     public BranchControlRow()
1:     {
1:     }
1: 
1: 	public BranchControlRow(
1:     OpenBTree       open_btree,
1:     Page            page,
1:     int             level,
1:     ControlRow      parent,
1:     boolean         isRoot,
1:     long            left_child)
1:         throws StandardException
1: 	{
1: 		super(open_btree, page,
1:               level, parent, isRoot);
1: 
1:         this.left_child_page = new SQLLongint(left_child);
1: 
1:         // finish initializing the row to be used for interacting with
1:         // raw store to insert, fetch, and update the control row on the page.
1:         this.row[CR_LEFTCHILD] = left_child_page;
1: 
1:         // set up buffer to read a branch row's page number into.
1:         child_pageno_buf = new SQLLongint();
1: 	}
1: 
1: 	/*
1: 	** Non - Debug/consistency check Methods of ControlRow:
1: 	*/
1: 
1:     /**
1:      * Perform page specific initialization.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      **/
0:     protected final void ControlRowInit()
1:     {
1:         child_pageno_buf = new SQLLongint();
1:     }
1: 
1:     /**
1:      * Is the current page the leftmost leaf of tree?
1:      * <p>
1:      *
1: 	 * @return true if the current page is the leftmost leaf of the tree,
1:      *              else return false.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean isLeftmostLeaf()
1: 		throws StandardException
1:     {
1:         return(false);
1:     }
1: 
1:     /**
1:      * Is the current page the rightmost leaf of tree?
1:      * <p>
1:      *
1: 	 * @return true if the current page is the rightmost leaf of the tree,
1:      *              else return false.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean isRightmostLeaf()
1: 		throws StandardException
1:     {
1:         return(false);
1:     }
1: 
1:     /**
1:      * Get the number of columns in the control row.  
1:      * <p>
1:      * Control rows all share the first columns as defined by this class and
1:      * then add columns to the end of the control row.  For instance a branch
1:      * control row add a child page pointer field.
1:      * <p>
1:      *
1: 	 * @return The total number of columns in the control row.
1:      **/
1:     protected final int getNumberOfControlRowColumns()
1:     {
1:         return(this.CR_NCOLUMNS);
1:     }
1: 
1: 	public static long restartSplitFor(
1:     OpenBTree               open_btree,
1:     DataValueDescriptor[]	template,
1:     BranchControlRow        parent,
1:     ControlRow              child,
1:     DataValueDescriptor[]	newbranchrow,
1:     DataValueDescriptor[]	splitrow,
1:     int                     flag)
1:         throws StandardException
1: 	{
1:         // release parent and current latch
1:         parent.release();
1:         child.release();
1:         parent = null;
1:         child  = null;
1: 
1:         // Get the root page back, and perform a split following the
1:         // branch row which would not fit.
0:         ControlRow root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(root.page.isLatched());
1: 
1:         return(root.splitFor(open_btree, template, null, newbranchrow, flag));
1:     }
1: 
1: 
1: 	/**
1: 	 ** Perform a recursive search, ultimately returning the latched
1: 	 ** leaf page and row slot after which the given key belongs.
1: 	 ** The slot is returned in the result structure.  If the key
1: 	 ** exists on the page, the result.exact will be true.  Otherwise,
1: 	 ** result.exact will be false, and the row slot returned will be
1: 	 ** the one immediately preceding the position at which the key
1: 	 ** belongs.
1:      **
1:      ** @exception StandardException Standard exception policy.
1: 	 **/
1: 	public ControlRow search(SearchParameters sp)
1:         throws StandardException
1:     {
1:         ControlRow childpage    = null;
1:         long       childpageid;
1:         boolean    got_error    = true;
1: 
1:         try
1:         {
1:             searchForEntry(sp);
1: 
1:             if (sp.searchForOptimizer)
1:             {
1:                 // Update left_fraction to be used to esitimate the number of
1:                 // rows left of the current search key.
1: 
1:                 // Some search results leave the search positioned on the 0th
1:                 // slot which is a control row, in branch pages this results
1:                 // in following the left page pointer, there is no key 
1:                 // associated with this slot.  Set left_rows to be the number
1:                 // of leaf page pointers on the page which are left
1:                 // of the current slot.
1:                 float left_rows = sp.resultSlot;
1: 
1:                 // include the control row count here, as it accounts for the
1:                 // left page pointer which has no associated key.
1:                 int   row_count = this.page.recordCount();
1: 
1:                 if (this.getIsRoot())
1:                 {
1:                     sp.current_fraction = 1;
1:                     sp.left_fraction    = 0;
1:                 }
1: 
1:                 // calculate the fraction of rows in the table which are left 
1:                 // of the current slot in the search.  This number represents
1:                 // the fraction of rows in the sub-tree which includes all 
1:                 // rows left of rows pointed at by the sub-tree to be followed
1:                 // by the code below which descends the child page pointer.
1:                 // After the search is 
1:                 // completed (sp.left_fraction * number of rows), is the 
1:                 // estimated number of rows to the left of the current row.
1:                 sp.left_fraction    += 
1:                     (sp.current_fraction) * (left_rows / row_count);
1: 
1:                 sp.current_fraction = 
1:                     (sp.current_fraction) * (((float) 1) / row_count);
1:             }
1: 
1:             childpage =
1:                 this.getChildPageAtSlot(sp.btree, sp.resultSlot);
1: 
1:             this.release();
1: 
1:             got_error = false;
1: 
1:             return childpage.search(sp);
1:         }
1:         finally
1:         {
1:             if (got_error)
1:             {
1:                 if (childpage != null)
1:                     childpage.release();
1:                 if (this.page.isLatched())
1:                     this.release();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Search and return the left most leaf page.
1:      * <p>
1: 	 * Perform a recursive search, ultimately returning the
1:      * leftmost leaf page which is the first leaf page in the
1: 	 * leaf sibling chain.  (This method might better be called
1: 	 * getFirstLeafPage()).
1:      *
1: 	 * @return The leftmost leaf page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow searchLeft(OpenBTree btree)
1:         throws StandardException
1:     {
1:         ControlRow childpage    = null;
1:         boolean    got_error    = true;
1: 
1:         try
1:         {
1:             childpage = this.getLeftChild(btree);
1:             this.release();
1: 
1:             got_error = false;
1:             return childpage.searchLeft(btree);
1:         }
1:         finally
1:         {
1:             if (got_error)
1:             {
1:                 if (childpage != null)
1:                     childpage.release();
1:                 if (this.page.isLatched())
1:                     this.release();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Search and return the right most leaf page.
1:      * <p>
1: 	 * Perform a recursive search, ultimately returning the
1: 	 * rightmost leaf page which is the last leaf page in the
1: 	 * leaf sibling chain.  (This method might better be called
1: 	 * getLastLeafPage()).
1:      *
1: 	 * @return The rightmost leaf page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow searchRight(OpenBTree btree)
1:         throws StandardException
1:     {
1:         ControlRow childpage    = null;
1:         boolean    got_error    = true;
1: 
1:         try
1:         {
1:             childpage = this.getRightChild(btree);
1:             this.release();
1: 
1:             got_error = false;
1:             return(childpage.searchRight(btree));
1:         }
1:         finally
1:         {
1:             if (got_error)
1:             {
1:                 if (childpage != null)
1:                     childpage.release();
1:                 if (this.page.isLatched())
1:                     this.release();
1:             }
1:         }
1:     }
1: 
1: 
1: 	/**
1: 	 **	Perform a recursive shrink operation for the key.
1: 	 ** If this method returns true, the caller should
1: 	 ** remove the corresponding entry for the page.
1: 	 ** This routine is not guaranteed to successfully
1: 	 ** shrink anything.  The page lead to by the key might
1: 	 ** turn out not to be empty by the time shrink gets
1: 	 ** there, and shrinks will give up if there is a deadlock.
1: 	 ** <P>
1: 	 ** The receiver page must be latched on entry and is
1: 	 ** returned latched.
1:      **
1:      ** @exception StandardException Standard exception policy.
1: 	 **/
1: 	protected boolean shrinkFor(
1:     OpenBTree               open_btree, 
1:     DataValueDescriptor[]   shrink_key)
1:         throws StandardException
1:     {
1:         ControlRow childpage = null;
1:         boolean    shrinkme  = false;
1: 
1:         try
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.page.isLatched());
1: 
1:             // Find the child page for the shrink key.
1: 
1:             BranchRow branch_template =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
1:             SearchParameters sp = new SearchParameters(
1:                 shrink_key,
1:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:                 branch_template.getRow(), open_btree, false);
1: 
1:             this.searchForEntry(sp);
1:             childpage = this.getChildPageAtSlot(sp.btree, sp.resultSlot);
1: 
1:             // Recursively shrink the child.  If this call returns
1:             // true, then the child page has been deleted from its
1:             // sibling chain, and we have to delete the entry for it
1:             // in this page.
1: 
1:             if (childpage.shrinkFor(open_btree, shrink_key))
1:             {
1:                 // Child was deallocated.
1:                 if (sp.resultSlot != 0)
1:                 {
1:                     // Remove the corresponding branch row.  This call assumes
1:                     // that raw store will shift all higher slots down to fill
1:                     // the purged slot.
1:                     this.page.purgeAtSlot(sp.resultSlot, 1, true);
1:                 }
1:                 else
1:                 {
1:                     // Shrunk slot is zero, which means the left child page was
1:                     // deallocated. If the current page is empty, then
1:                     // we have to deallocate it.  Otherwise, we "slide" the rows
1:                     // down, making the first index row into the left child,
1:                     // and the second index row into the first, etc.
1: 
1:                     if (this.page.recordCount() > 1)
1:                     {
1:                         // There is a branch row on this page (besides the
1:                         // control row).  Make the first branch row into the
1:                         // left child.
1: 
1:                         long leftchildpageid =
1:                             getChildPageIdAtSlot(open_btree, 1);
1: 
1:                         this.setLeftChildPageno(leftchildpageid);
1: 
1:                         // purge the row we just made the "left child", this
1:                         // will automatically shifta all other rows "left" in
1:                         // the tree.
1:                         this.page.purgeAtSlot(1, 1, true);
1:                     }
1:                     else
1:                     {
1:                         // We shrunk the left child which was the last child on
1:                         // the page.  This means that this entire subtree is
1:                         // empty.  Again, there are two cases: root vs.
1:                         // non-root.  Because this method waits till pages are
1:                         // completely empty before deallocating them from the
1:                         // index, an empty root page means an empty index.
1:                         // If this page is not the root, then simply
1:                         // deallocate it and return that fact to the caller.
1: 
1:                         if (this.getIsRoot())
1:                         {
1:                             // The root page has become empty.  If the root page
1:                             // is empty, then the index is empty.  What has to
1:                             // happen here is that this page has to be
1:                             // converted back to an empty leaf page.
1: 
1:                             // With the current interface, after this page has
1:                             // been converted to a leaf, the caller will be
1:                             // left with a branch control row object, although
1:                             // the page is a leaf page.  This same problem was
1:                             // addressed in splitFor by adjusting the interface
1:                             // - the two routines should at least have the same
1:                             // interface style.
1: 
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 SanityManager.ASSERT(
1:                                     this.page.recordCount() == 1);
1:                             }
1: 
1:                             LeafControlRow newleafroot = new LeafControlRow(
1:                                 open_btree, this.page, null, true);
1: 
1:                             newleafroot.page.updateAtSlot(
1:                                 0, newleafroot.getRow(), 
1:                                 (FormatableBitSet) null);
1: 
1:                             newleafroot.release();
1: 
1:                             shrinkme = true;
1:                         }
1:                         else
1:                         {
1:                             // This page is empty, but it's not the root.  We
1:                             // have to unlink this page from its siblings, and
1:                             // return to the parent branch page that its
1:                             // branch row should be removed.
1: 
1:                             // Unlink this page from its siblings.
1:                             if (this.unlink(open_btree))
1:                             {
1:                                 // Tell the caller to remove entry.
1:                                 shrinkme = true;
1:                             }
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:         finally
1:         {
1:             // If shrinkme then the page has been unlatched either by
1:             // page.removePage(), or by the process of changing the root branch
1:             // page to a root leaf page.
1:             if (!shrinkme)
1:                 this.release();
1:         }
1: 
1:         return(shrinkme);
1:     }
1: 
1:     /**
1:      * Perform a top down split pass making room for the the key in "row".
1:      * <p>
1:      * Perform a split such that a subsequent call to insert
1: 	 * given the argument index row will likely find room for it.  Since 
1:      * latches are released the client must code for the case where another
1:      * user has grabbed the space made available by the split pass and be
1:      * ready to do another split.
1:      * <p>
1:      * Latches:
1:      * o PARENT    : is latched on entry (unless the split is the root then
1:      *               there is no parent.
1:      * o THISBRANCH: the current page is latched on entry.
1:      * o CHILD     : latch the child page which will be pointed at by the
1:      *               left child pointer of the new page.
1:      *               RESOLVE (mikem) -see comments below
1:      * o NEWPAGE   : Allocate and latch new page.
1:      * o CHILD     : release. (RESOLVE)
1:      * o fixparents: latch pages and reset their parent pointers.
1:      *               Conditionally fix up the parent links on the pages
1:      *               pointed at by the newly allocated page.  First get latch
1:      *               and release on the left child page and then loop through
1:      *               slots on NEWPAGE, from left to right getting and
1:      *               releasing latches.
1:      *
1:      *
1: 	 * @return page number of the newly allocated leaf page created by split.
1:      *
0:      * @param btree      The open btree to associate latches with.
1:      * @param template   A scratch area to use while searching for split pass.
0:      * @param parentpage The parent page of the current page in the split pass.
1:      *                   starts at null for root.
0:      * @param row        The key to make room for during the split pass.
1:      * @param flag       A flag used to direct where point of split should be
1:      *                   chosen.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected long splitFor(
1:     OpenBTree               open_btree,
1:     DataValueDescriptor[]	template,
1:     BranchControlRow        parent,
1:     DataValueDescriptor[]	splitrow,
1:     int                     flag)
1:         throws StandardException
1: 	{
1: 		int        childpageid;
1: 		ControlRow childpage;
1: 
1: 		// On entry, the parent page is either latched by the caller,
1: 		// or it's null (which implies that this object is the root).
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(parent != null || this.getIsRoot());
1: 
1:             SanityManager.ASSERT(
1:                 parent == null || parent.page.isLatched(),
1:                 "parent page is not latched");
1: 
1:             SanityManager.ASSERT(this.page.isLatched(),
1:                 "page is not latched:");
1:         }
1: 
0:         if ((this.page.recordCount() - 1 >=
0:                 open_btree.getConglomerate().maxRowsPerPage) ||
1:             (!this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
1: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
1:         {
1: 
1:             if (this.page.recordCount() == 1)
1:             {
1:                 // RESOLVE (mikem) long row issue.  For now it makes no sense
1:                 // to split if there are no rows.  So if spaceForRecord() fails
1:                 // on empty page, we throw exception.
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_NO_SPACE_FOR_KEY);
1:             }
1: 
1: 			// Track.BranchSplit++;
1: 
1: 			if (this.getIsRoot())
1: 			{
1: 				// Track.BranchSplitRoot++;
1: 				growRoot(open_btree, template, this);
1: 
1: 				parent = (BranchControlRow)
0:                     ControlRow.Get(open_btree, BTree.ROOTPAGEID);
1: 
1: 
1: 				return(parent.splitFor(
1:                         open_btree, template, null, splitrow, flag));
1: 			}
1: 
1: 			// At this point we know that this page has to be split and
1: 			// that it isn't a root page.
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(!this.getIsRoot());
1:                 SanityManager.ASSERT(parent != null);
1:             }
1: 
1:             int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
1: 
1:             if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
1:             {
1:                 // move all the row to the new page
1:                 splitpoint = 1;
1:             }
1:             else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
1:             {
1:                 // This is not optimal as we would rather move no rows to the
1:                 // next page, but what should we use as a discriminator?
1:                 splitpoint = this.page.recordCount() - 1;
1:             }
1: 
1:             if (SanityManager.DEBUG)
1:             {
1: 				if (splitpoint <= 0)
1:                 	SanityManager.THROWASSERT(this + "yikes! splitpoint of 0!");
1:             }
1: 
1: 
1:             // Before any logged operation is done in the current internal
1:             // xact, make sure that there is room in the parent to insert
1:             // the new branch row.
1:             //
1: 			// Create a new branch row which points to the new page,
1:             // and insert it on parent page.
1: 
1:             // Read in the branch row which is at the split point.
1:             BranchRow split_branch_row =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
1: 
1:             this.page.fetchFromSlot(
1:                 (RecordHandle) null, splitpoint, split_branch_row.getRow(), 
1:                 (FetchDescriptor) null, true);
1: 
1:             // Create the branch row to insert onto the parent page.  For now
1:             // use a fake page number because we don't know the real page
1:             // number until the allocate is done, but want to delay the
1:             // allocate until we know the insert will succeed.
1: 			BranchRow newbranchrow =
1:                 split_branch_row.createBranchRowFromOldBranchRow(
1:                         BranchRow.DUMMY_PAGE_NUMBER);
1: 
1:             // At this point we have guaranteed there is space in the parent
1:             // page for splitrow, but it could be the case that the new
1:             // "newbranchrow" does not fit on the parent page.
1:             if (!parent.page.spaceForInsert(
1:                     newbranchrow.getRow(), (FormatableBitSet) null,
1: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
1:             {
1:                 // There is no room on the parent page to complete a split at
1:                 // the current level, so restart the split at top with the
1:                 // branchrow that did not fit.  On return from this routine
1:                 // there is no way to know the state of the tree, so the
1:                 // current split pass recursion must end.
1:                 return(
0:                     parent.restartSplitFor(
1:                         open_btree, template, parent, this,
1:                         newbranchrow.getRow(), splitrow, flag));
1:             }
1: 
1: 			// Get the child page for the index row at the split point
1: 			// This will be the left child for	the new page.  We're
1: 			// getting the page because BranchControlRow.Allocate
1: 			// sets the left child pointer from a BranchControlRow.
1: 			// If there were a version which just took the pageid,
1: 			// we wouldn't have to get the page (the latch on this
1: 			// page is enough to ensure that the child page won't
1: 			// disappear).
1: 
1:             childpage = this.getChildPageAtSlot(open_btree, splitpoint);
1: 
1: 			// Allocate a new branch page and link it to the
1: 			// right of the current page.
1: 			BranchControlRow newbranch =
0:                 BranchControlRow.Allocate(open_btree, childpage,
1:                     this.getLevel(), parent);
1: 			newbranch.linkRight(open_btree, this);
1: 
1: 
1:             // Test fail after allocation
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("branch_split_abort1"))
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:                 }
1:             }
1: 
1: 			// Done with the child page.
1: 			childpage.release();
1: 
1:             // Now that we know the page number of the new child page update
1:             // the branch row to be inserted with the correct value.
1:             newbranchrow.setPageNumber(newbranch.page.getPageNumber());
1: 
1:             BranchRow branch_template =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
1: 			SearchParameters sp = new SearchParameters(
1:                 newbranchrow.getRow(),
1:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:                 branch_template.getRow(),
1:                 open_btree, false);
1: 
1: 			parent.searchForEntry(sp);
1: 
1: 			byte insertFlag = Page.INSERT_INITIAL;
1: 			insertFlag |= Page.INSERT_DEFAULT;
1: 			insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
1: 			if (parent.page.insertAtSlot(
1:                     sp.resultSlot + 1,
1:                     newbranchrow.getRow(),
1:                     (FormatableBitSet) null,
1:                     (LogicalUndo)null,
1:                     insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)
1: 					== null)
1:             {
1:                 throw StandardException.newException(
1:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
1: 			}
1: 
1: 
1:             // Test fail after of row onto parent page.
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("branch_split_abort2"))
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:                 }
1:             }
1: 
1:             // newbranchrow only valid while contents of split_branch_row
1:             // remain unchanged.
1:             newbranchrow = null;
1: 
1: 			// Copy the rows from the split point, but not including it (since
1:             // the split point is turning into the left child of the new
1:             // branch), onto the new page.  Purge the rows including the split
1: 			// point from the current page.
1:             int num_rows_to_move = this.page.recordCount() - (splitpoint + 1);
1: 
1:             if (num_rows_to_move > 0)
1:             {
1:                 this.page.copyAndPurge(
1:                     newbranch.page, splitpoint + 1, num_rows_to_move, 1);
1:             }
1: 
1:             // remove the splitpoint row, we didn't copy it because it became
1:             // the "left child", but we do need to get rid of it.
1: 			this.page.purgeAtSlot(splitpoint, 1, true);
1: 
1:             // Test fail after of copy of rows to new page.
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("branch_split_abort3"))
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:                 }
1:             }
1: 
1:             // Test fail after purge of rows on old page.
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("branch_split_abort4"))
1:                 {
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
1:                 }
1:             }
1: 
1:             // Check pages that have been altered by above split
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:                 {
1:                     parent.checkConsistency(open_btree, null, false);
1:                     newbranch.checkConsistency(open_btree, parent, false);
1:                     this.checkConsistency(open_btree, parent, false);
1:                 }
1:             }
1: 
1: 			// Fix up the parent links on the pages for the rows that moved to
1:             // the new branch.
1: 			newbranch.fixChildrensParents(open_btree, null);
1: 
1:             // At this point a unit of work in the split down the tree has
1:             // been performed in an internal transaction (ie. writes have been
1:             // done to latched pages), and the resulting
1:             // tree is logically consistent, thus the work can be committed.
1:             // This work must be committed before any latches are released.
1:             open_btree.getXactMgr().commit();
1: 
1: 			// Decide whether we're following the current page or the new page.
1: 			BranchControlRow pagetofollow;
1: 
0:             if (CompareIndexRowToKey(
1:                     splitrow, 
1:                     split_branch_row.getRow(),
1:                     split_branch_row.getRow().length - 1, 0,
1: 					open_btree.getConglomerate().ascDescInfo) >= 0)
1:             {
1:                 // Follow the new branch
1: 				pagetofollow = newbranch;
1: 				this.release();
1: 			}
1: 			else
1: 			{
1: 				// Follow the current branch
1: 				pagetofollow = this;
1: 				newbranch.release();
1: 			}
1: 
1:             // At this point we hold latches on the parent, and the current
1:             // child of the page that we are following.  Note that committing
1:             // the internal transaction did not release the latches.
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(parent != null);
1:                 SanityManager.ASSERT(parent.page.isLatched());
1:                 SanityManager.ASSERT(
1:                         pagetofollow.page.isLatched());
1:             }
1: 
1: 			// Recurse down the tree splitting if necessary.
1: 			return(
1:                 pagetofollow.splitFor(
1:                     open_btree, template, parent, splitrow, flag));
1: 		}
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 this.checkConsistency(open_btree, parent, false);
1:             }
1:         }
1: 
1: 		// Don't need the parent any more.
1: 		if (parent != null)
1: 			parent.release();
1: 
1:         // RESOLVE (mikem) - should this be passed in?
1:         BranchRow branch_template =
0:             BranchRow.createEmptyTemplate(open_btree.getConglomerate());
1: 		SearchParameters sp = new SearchParameters(
1:             splitrow, 
1:             SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:             branch_template.getRow(), 
1:             open_btree, false);
1: 
1: 		searchForEntry(sp);
1: 
1:         childpage = this.getChildPageAtSlot(open_btree, sp.resultSlot);
1: 
1:         return(childpage.splitFor(open_btree, template, this, splitrow, flag));
1:     }
1: 
1: 	/*
1: 	** Debug/consistency check Methods of ControlRow:
1: 	*/
1: 
1: 
1: 	/**
1: 	 ** Perform consistency checks for a branch page.  The checks
1: 	 ** specific to a branch page are:
1: 	 ** <menu>
1: 	 ** <li> The rows on the page are indeed branch rows, and
1: 	 **      they all have the correct number of fields (which
1: 	 **      is the b-tree's key fields plus one for the child
1: 	 **      page number.
1: 	 ** <li> The child pages pointed to by the left child pointer
1: 	 **      and the index rows are linked together in the same
1: 	 **      order that they appear on the page.
1: 	 ** <li> The child pages themselves are all consistent.
1: 	 ** </menu>
1: 	 ** This method also performs the consistency checks that
1: 	 ** are common to both leaf and branch pages (see
1: 	 ** ControlRow.checkGeneric).
1:      **
1:      ** @exception StandardException Standard exception policy.
1: 	 **/
1: 	public int checkConsistency(
1:     OpenBTree  btree,
1:     ControlRow parent,
1:     boolean    check_other_pages)
1:         throws StandardException
1: 	{
1: 		// Do the consistency checks that are common to all
1: 		// types of pages.
1: 		checkGeneric(btree, parent, check_other_pages);
1: 
1:         // Branch specific Control Row checks.
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 this.getLevel() > 0, "branch not above level 0");
1: 
1:             // RESOLVE (mikem) - how to check right version?
1:             /*
1: 			if (this.getVersion() != CURRENT_BRANCH_VERSION)
1:             	SanityManager.THROWASSERT(
1:                 	"Expected branch version:(" + CURRENT_BRANCH_VERSION +
1:                 	") but got (" + this.getVersion());
1:             */
1:             SanityManager.ASSERT(
1:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) ==
1:                 BranchControlRow.CR_NCOLUMNS);
1:             SanityManager.ASSERT(getLeftChildPageno() !=
1:                                  ContainerHandle.INVALID_PAGE_NUMBER);
1: 
1:             // RESOLVE (mikem) - this makes an assumption about page numbering,
1:             // that may not be always valid in all implementations but has
1:             // been useful in finding bugs with uninitialized fields.
1:             SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
1:         }
1: 
1: 		// The remaining checks are specific to branch pages.
1:         if (SanityManager.DEBUG)
1:         {
1: 
1:             // Check that all the branch rows are branch rows
1:             // (we'll get a case error otherwise), and have the right
1:             // number of columns.  Every branch row should have the
1:             // btree's	key columns plus one for the child link.
1:             int numslots = this.page.recordCount();
1:             for (int slot = 1; slot < numslots; slot++)
1:             {
1: 				if ((this.page.fetchNumFieldsAtSlot(slot) !=
1:                      (btree.getConglomerate().nKeyFields + 1)))
1:                 	SanityManager.THROWASSERT(
1:                     	"row[" + slot + "]"
1:                         + " has " + this.page.fetchNumFieldsAtSlot(slot)
1:                         + " columns, should have at least " +
1:                         (btree.getConglomerate().nKeyFields + 1));
1: 
1:                 SanityManager.ASSERT(this.getChildPageIdAtSlot(btree, slot) !=
1:                         ContainerHandle.INVALID_PAGE_NUMBER);
1: 
1:                 // Rows on branch pages are never deleted, they are only purged.
1:                 SanityManager.ASSERT(!this.page.isDeletedAtSlot(slot));
1: 
1:                 // RESOLVE (mikem) - this makes an assumption about page
1:                 // numbering, that may not be always valid in all
1:                 // implementations but has been useful in finding bugs with
1:                 // uninitialized fields.
1:                 SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
1:             }
1:         }
1: 
1: 		// Check that the linkage of the children is in the
1: 		// same order as the branch rows.
1:         // RESOLVE (mikem) enable when multiple latches work.
1:         if (check_other_pages)
1: 		    checkChildOrderAgainstRowOrder(btree);
1: 
1: 		// Check the children.
1: 		int nchildren = 0;
1: 
1:         // RESOLVE (mikem) enable when multiple latches work.
1:         if (check_other_pages)
1:             nchildren = checkChildren(btree);
1: 
1: 		// Return the number of children visited plus one for this page.
1: 		return nchildren + 1;
1: 	}
1: 
1:     private int checkChildren(OpenBTree btree)
1:         throws StandardException
1:     {
1: 		int         nchildren = 0;
1:         ControlRow  childpage = null;
1: 
1:         try
1:         {
1:             // Check the left child.
1:             childpage = this.getLeftChild(btree);
1:             nchildren += childpage.checkConsistency(btree, this, true);
1:             childpage.release();
1:             childpage = null;
1: 
1:             // Check children from each index row.
1:             int numslots = this.page.recordCount();
1:             for (int slot = 1; slot < numslots; slot++)
1:             {
1:                 childpage = this.getChildPageAtSlot(btree, slot);
1:                 nchildren += childpage.checkConsistency(btree, this, true);
1:                 childpage.release();
1:                 childpage = null;
1:             }
1: 
1:             return(nchildren);
1:         }
1:         finally
1:         {
1:             if (childpage != null)
1:                 childpage.release();
1:         }
1:     }
1: 
1: 	private void checkChildOrderAgainstRowOrder(OpenBTree btree)
1:         throws StandardException
1: 	{
1: 		ControlRow cur  = null;
1: 		ControlRow prev = null;
1: 
1:         try
1:         {
1:             prev = this.getLeftChild(btree);
1: 
1:             int numslots = this.page.recordCount();
1:             for (int slot = 1; slot < numslots; slot++)
1:             {
1:                 cur = this.getChildPageAtSlot(btree, slot);
1: 
1:                 long shouldbecur_pageno = prev.getrightSiblingPageNumber();
1:                 if (SanityManager.DEBUG)
1:                 {
1: 					if (shouldbecur_pageno != cur.page.getPageNumber())
1:                     	SanityManager.THROWASSERT(
1:                         	"child linkage error going right.\n" +
1:                         	"cur page control row = " + cur + "\n" +
1:                         	"prev page control row = " + prev + "\n");
1:                 }
1: 
1:                 long shouldbeprev_pageno = cur.getleftSiblingPageNumber();
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(
1:                         shouldbeprev_pageno == prev.page.getPageNumber(),
1:                         "child linkeage error going left");
1:                 }
1: 
1:                 prev.release();
1:                 prev = cur;
1:                 cur  = null;
1:             }
1: 
1:             prev.release();
1:             prev = null;
1:         }
1:         finally
1:         {
1:             if (prev != null)
1:                 prev.release();
1:             if (cur != null)
1:                 cur.release();
1:         }
1: 
1:         return;
1: 	}
1: 
1:     /**
1:      * Recursively print the tree starting at current node in tree.
1:      *
1:      * @param btree the open btree to print.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void printTree(
1:     OpenBTree  btree)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
1: 
1:             ControlRow      child = null;
1: 
1:             try
1:             {
1:                 child = this.getLeftChild(btree);
1: 
1:                 child.printTree(btree);
1:                 child.release();
1:                 child = null;
1: 
1:                 int numslots = this.page.recordCount();
1:                 for (int slot = 1; slot < numslots; slot++)
1:                 {
1:                     child = this.getChildPageAtSlot(btree, slot);
1:                     child.printTree(btree);
1:                     child.release();
1:                     child = null;
1:                 }
1:             }
1:             finally
1:             {
1:                 if (child != null)
1:                     child.release();
1:             }
1: 
1:             return;
1:         }
1:     }
1: 
1: 	/*
1: 	 * Private methods of BranchControlRow
1: 	 */
1: 
1: 	/**
1:      ** Add a level to the tree by moving the current branch-root page up
1:      ** one level and adding a new page as it's left child.  On exit the
1:      ** current root page remains the root of the tree.
1: 	 ** <P>
1: 	 ** On entry, the current branch root page is expected to be latched.
1:      ** On exit, all latches will have been released.
1:      ** <P>
1:      ** Latch order:
1:      **    o ROOT: on entry current root is latched.
1:      **            No other latches should be held.
1:      **    o ROOT_OLDCHILD: Get and Latch root's left child page.
1:      **    o ROOT_NEWCHILD: Allocate a new branch page with latch.
1:      **    o Conditionally fix up the parent links on the pages pointed at
1:      **      by the newly allocated page.  Loop through slots on ROOT_NEWCHILD,
1:      **      from left to right getting and releasing latches.  Note that
1:      **      fixChildrensParents() must not latch the leftchild as ROOT_OLDCHILD
1:      **      is already latched.
1:      **    RESOLVE: (mikem) does order of release matter.
1:      **    o ROOT         : released.
1:      **    o ROOT_NEWCHILD: released.
1:      **    o ROOT_OLDCHILD: released.
1: 	 **/
1: 	private static void growRoot(
1:     OpenBTree               open_btree,
1:     DataValueDescriptor[]   template,
1:     BranchControlRow        root)
1:         throws StandardException
1: 	{
1:         ControlRow       leftchild = null;
1:         BranchControlRow branch    = null;
1: 
1:         try
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(root.page.isLatched());
1:                 SanityManager.ASSERT(root.getIsRoot());
1:             }
1: 
1:             // System.out.println("Growing root: control row = " + root);
1:             // System.out.println("Growing root: page = " + root.page);
1: 
1:             // Get and latch the current root's left child.  This will become
1:             // the left child on the new branch page (and the new
1:             // branch will become the left child of the root).
1:             leftchild = root.getLeftChild(open_btree);
1: 
1:             // Allocate a new branch page.	 This one will take the
1:             // rows from the root, and remain at the old root's level.
1:             // Its parent is the root.
1:             branch =
0:                 BranchControlRow.Allocate(
1:                     open_btree, leftchild, root.getLevel(), root);
1: 
1:             // Copy all the index rows from the root to the new branch.
1:             // Purge the index rows from the root now that they're safely on the
1:             // new branch page.  Leave the branch control row on the page.
1:             root.page.copyAndPurge(branch.page, 1, root.page.recordCount() - 1, 1);
1: 
1:             // Set the root's left child to be the new branch.
1:             root.setLeftChild(branch);
1: 
1:             // Move the root up a level
1:             root.setLevel(root.getLevel() + 1);
1: 
1:             // The parent of the old root's children has changed.
1:             // It used to be page 0 (the old root, but now it's
1:             // the new branch page.  Fix this up.
1:             branch.fixChildrensParents(open_btree, leftchild);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:                 {
1:                     root.checkConsistency(open_btree, null, false);
1:                     branch.checkConsistency(open_btree, root, false);
1:                     leftchild.checkConsistency(open_btree, branch, false);
1:                 }
1:             }
1: 
1:             // At this point a unit of work in the split down the tree has
1:             // been performed in an internal transaction.  This work must
1:             // be committed before any latches are released.
1:             open_btree.getXactMgr().commit();
1: 
1:         }
1:         finally
1:         {
1:             // At the end of a growRoot() no latches are held, the caller must
1:             // restart at the root.
1:             //
1:             root.release();
1:             if (branch != null)
1:                 branch.release();
1:             if (leftchild != null)
1:                 leftchild.release();
1:         }
1:         return;
1: 	}
1:     /**
1:      * Allocate a new leaf page to the conglomerate.
1:      *
1:      * @exception StandardException Standard exception policy.
1:      */
0:     private static BranchControlRow Allocate(
1:     OpenBTree         open_btree,
1:     ControlRow        leftchild,
1:     int               level,
1:     ControlRow        parent)
1:         throws StandardException
1:     {
1:         Page      page      = open_btree.container.addPage();
1: 
1:         // Create a control row for the new page.
1:         BranchControlRow control_row =
1:             new BranchControlRow(
1:                 open_btree, page, level,
1:                 parent, false, leftchild.page.getPageNumber());
1: 
1:         // Insert the control row on the page.
1: 		byte insertFlag = Page.INSERT_INITIAL;
1: 		insertFlag |= Page.INSERT_DEFAULT;
1:         page.insertAtSlot(
1:             Page.FIRST_SLOT_NUMBER,
1:             control_row.getRow(),
1:             (FormatableBitSet) null, 
1:             (LogicalUndo)null,
1:             insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1: 
1:         // Page is returned latched.
1:         return(control_row);
1:     }
1: 
1: 	protected void setLeftChildPageno(long leftchild_pageno)
1:         throws StandardException
1: 	{
1: 		// Store the field.
1: 		if (left_child_page == null)
1: 			left_child_page = new SQLLongint(leftchild_pageno);
1:         else
1:             this.left_child_page.setValue(leftchild_pageno);
1: 
1: 		// Write the field through to the underlying row
1: 		this.page.updateFieldAtSlot(
1:             CR_SLOT, CR_LEFTCHILD, this.left_child_page, null);
1: 	}
1: 
1: 	protected void setLeftChild(ControlRow leftchild)
1:         throws StandardException
1: 	{
1:         this.setLeftChildPageno(leftchild.page.getPageNumber());
1: 	}
1: 
1: 	/**
1: 	 ** A branch page that has just been allocated as part
1: 	 ** of a split has index rows and a left child pointer
1: 	 ** that were copied from another page.  The parent
1: 	 ** link on the corresponding pages will still point to
1: 	 ** the original page.  This method fixes their parent
1: 	 ** pointers so that they point to the curren page like
1: 	 ** they're supposed to.
1: 	 ** <P>
1: 	 ** Note that maintaining the parent link is kind of a
1: 	 ** pain, and will slow down applications.  It's only
1: 	 ** needed for consistency checks, so we may want to
1: 	 ** have implementations that don't bother to maintain it.
0:      ** <P)
1:      ** This
1: 	 **/
1: 	private void fixChildrensParents(
1:     OpenBTree       btree,
1:     ControlRow      leftchild)
1:         throws StandardException
1: 	{
1:         ControlRow child = null;
1: 
1:         try
1:         {
1:             if (leftchild == null)
1:             {
1:                 child = this.getLeftChild(btree);
1:                 child.setParent(this.page.getPageNumber());
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:                     {
1:                         child.checkConsistency(btree, this, false);
1:                     }
1:                 }
1: 
1:                 child.release();
1:                 child = null;
1:             }
1:             else
1:             {
1:                 leftchild.setParent(this.page.getPageNumber());
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:                     {
1:                         leftchild.checkConsistency(btree, this, false);
1:                     }
1:                 }
1:             }
1: 
1:             int numslots = this.page.recordCount();
1:             for (int slot = 1; slot < numslots; slot++)
1:             {
1:                 child = getChildPageAtSlot(btree, slot);
1:                 child.setParent(this.page.getPageNumber());
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:                     {
1:                         child.checkConsistency(btree, this, false);
1:                     }
1:                 }
1: 
1:                 child.release();
1:                 child = null;
1:             }
1:         }
1:         finally
1:         {
1:             if (child != null)
1:                 child.release();
1:         }
1: 	}
1: 
1:     private long getChildPageIdAtSlot(
1:     OpenBTree       btree,
1:     int             slot)
1:         throws StandardException
1:     {
1:         long child_page_id;
1: 
1:         if (slot == 0)
1:         {
1:             child_page_id = this.getLeftChildPageno();
1:         }
1:         else
1:         {
1:             this.page.fetchFieldFromSlot(
1:                 slot, btree.getConglomerate().nKeyFields, child_pageno_buf);
1:             child_page_id = child_pageno_buf.getLong();
1:         }
1: 
1:         return(child_page_id);
1:     }
1: 
1:     protected ControlRow getChildPageAtSlot(
1:     OpenBTree       open_btree,
1:     int             slot)
1:         throws StandardException
1:     {
1:         ControlRow  child_control_row;
1: 
1:         if (slot == 0)
1:         {
1:             child_control_row = this.getLeftChild(open_btree);
1:         }
1:         else
1:         {
1:             this.page.fetchFieldFromSlot(
1:                 slot, open_btree.getConglomerate().nKeyFields, 
1:                 child_pageno_buf);
1: 
1:             child_control_row =
0:                 ControlRow.Get(open_btree, child_pageno_buf.getLong());
1:         }
1: 
1:         return(child_control_row);
1:     }
1: 
1:     /**
1:      * Return the left child pointer for the page.
1:      * <p>
1:      * Leaf pages don't have children, so they override this and return null.
1:      *
1: 	 * @return The page which is the leftmost child of this page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ControlRow getLeftChild(OpenBTree open_btree)
1:             throws StandardException
1:     {
0:          return(ControlRow.Get(open_btree, this.getLeftChildPageno()));
1:     }
1: 
1:     /**
1:      * Return the right child pointer for the page.
1:      * <p>
1:      * Leaf pages don't have children, so they override this and return null.
1:      *
1: 	 * @return The page which is the rightmost child of this page.
1:      *
1:      * @param open_btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow getRightChild(OpenBTree open_btree)
1:         throws StandardException
1:     {
1:         ControlRow right_child;
1:         int        num_slots = this.page.recordCount();
1: 
1:         // if num_slots is 1 then there are no branch rows, so just follow
1:         // the left page pointer, else if num_slots is > 1 then follow the
1:         // last branch row to find the rightmost child.
1:         right_child = 
1:             (num_slots == 1 ? 
0:                 ControlRow.Get(open_btree, this.getLeftChildPageno()) :
1:                 getChildPageAtSlot(open_btree, (num_slots - 1)));
1: 
1:         return(right_child);
1:     }
1: 
1: 	/**
1: 	 ** Return the left child page number for the page.  Leaf pages
1: 	 ** don't have left children, so they override this and return
1: 	 ** null.
1: 	 **/
1: 	long getLeftChildPageno()
1:         throws StandardException
1:     {
1:         if (this.left_child_page == null)
1:         {
1:             this.left_child_page = new SQLLongint();
1: 
1:             scratch_row[CR_LEFTCHILD] = this.left_child_page;
1: 
1:             fetchDesc.setValidColumns(CR_LEFTCHILD_BITMAP);
1:             this.page.fetchFromSlot(
1:                (RecordHandle) null, CR_SLOT, scratch_row, fetchDesc, false); 
1:         }
1:         return(left_child_page.getLong());
1:     }
1: 
1: 	/*
1: 	 * TypedFormat:
1: 	 */
1: 
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId()
1:     {
1: 		return StoredFormatIds.ACCESS_BTREE_BRANCHCONTROLROW_V1_ID;
1: 	}
1: 
1:     /**
1:      * Return a new template for reading a data row from the current page.
1:      * <p>
1:      * Default implementation for rows which are the same as the conglomerates
1:      * template, sub-classes can alter if underlying template is different
1:      * (for instance branch rows add an extra field at the end).
1:      *
1: 	 * @return Newly allocated template.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public DataValueDescriptor[] getRowTemplate(OpenBTree    open_btree)
1: 		throws StandardException
1:     {
1:         return(BranchRow.createEmptyTemplate(
1:                     open_btree.getConglomerate()).getRow());
1:     }
1: 
1: 	/**
1: 	 ** The standard toString.
1: 	 **/
1: 	public String toString()
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             String string = super.toString();
1: 
1:             try 
1:             {
1:                 string += "left child page = " + getLeftChildPageno() + ";";
1:                 
1:             }
1:             catch (Throwable t)
1:             {
1:                 string += "error encountered while doing ControlRow.toString()";
1:             }
1: 
1:             return(string);
1:         }
1:         else
1:         {
1:             return(null);
1:         }
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.SQLLongint;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * @format_id ACCESS_BTREE_BRANCHCONTROLROW_V1_ID
0:  *
0:  * @purpose    Btree pages all have a control row at the front of every page.
0:  *             To determine the type of row, read the first column which is a
0:  *             format id and it tells what kind of control row it is.
0:  *
0:  * @upgrade    RESOLVE.
0:  *
0:  * @disk_layout
0:  * column 1 - control row type         : StorableFormatId
0:  * column 2 - left sibling page number : SQLLongint
0:  * column 3 - right sibling page number: SQLLongint
0:  * column 4 - parent page number       : SQLLongint
0:  * column 5 - level number (0 is leaf) : SQLLongint
0:  * column 6 - isRoot                   : SQLLongint
0:  * column 7 - Conglomerate object      : null unless it is root else
0:  *                                       a Conglomerate object, matching
0:  *                                       that of current table.
0:  *                                       Currently this field
0:  *                                       is only used by logical undo and
0:  *                                       the type of object is inferred by
0:  *                                       the logical undo code.
0:  * column 8 - left child page number   : SQLLongint
0:  **/
0: 
0: /**
0: A branch row contains key fields and the pointer to the child page.
0: **/
0: public class BranchControlRow extends ControlRow
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     protected SQLLongint    left_child_page = null;
0: 
0: 
0:     /**
0:      * Only allocate one child_pageno_buf to read the page pointer field into,
0:      * then cache to "empty" object for reuse by the page itself.
0:      **/
0:     transient SQLLongint     child_pageno_buf = null;
0: 
0:     /* Column assignments */
0:     private static final int CR_LEFTCHILD     = ControlRow.CR_COLID_LAST + 1;
0:     private static final int CR_COLID_LAST    = CR_LEFTCHILD;
0:     private static final int CR_NCOLUMNS      = CR_COLID_LAST + 1;
0: 
0:     /**
0:      * bit sets used to fetch single columns at a time.
0:      **/
0:     protected static final FormatableBitSet   CR_LEFTCHILD_BITMAP = 
0:         new FormatableBitSet(CR_LEFTCHILD + 1);
0: 
0: 	/*
0: 	** Constructors of BranchControlRow
0: 	*/
0: 
0:     static 
0:     {
0:         CR_LEFTCHILD_BITMAP.set(CR_LEFTCHILD);
0:     }
0: 
0:     /**
0:      * No arg constructor.
0:      * <p>
0:      * Public no arg constructor is for the monitor to call for format
0:      * id implementation, it should not be called for any other reason.
0:      **/
0:     public BranchControlRow()
0:     {
0:     }
0: 
0: 	public BranchControlRow(
0:     OpenBTree       open_btree,
0:     Page            page,
0:     int             level,
0:     ControlRow      parent,
0:     boolean         isRoot,
0:     long            left_child)
0:         throws StandardException
0: 	{
0: 		super(open_btree, page,
0:               level, parent, isRoot);
0: 
0:         this.left_child_page = new SQLLongint(left_child);
0: 
0:         // finish initializing the row to be used for interacting with
0:         // raw store to insert, fetch, and update the control row on the page.
0:         this.row[CR_LEFTCHILD] = left_child_page;
0: 
0:         // set up buffer to read a branch row's page number into.
0:         child_pageno_buf = new SQLLongint();
0: 	}
0: 
0: 	/*
0: 	** Non - Debug/consistency check Methods of ControlRow:
0: 	*/
0: 
0:     /**
0:      * Perform page specific initialization.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      **/
0:     protected final void ControlRowInit()
0:     {
0:         child_pageno_buf = new SQLLongint();
0:     }
0: 
0:     /**
0:      * Is the current page the leftmost leaf of tree?
0:      * <p>
0:      *
0: 	 * @return true if the current page is the leftmost leaf of the tree,
0:      *              else return false.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean isLeftmostLeaf()
0: 		throws StandardException
0:     {
0:         return(false);
0:     }
0: 
0:     /**
0:      * Is the current page the rightmost leaf of tree?
0:      * <p>
0:      *
0: 	 * @return true if the current page is the rightmost leaf of the tree,
0:      *              else return false.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean isRightmostLeaf()
0: 		throws StandardException
0:     {
0:         return(false);
0:     }
0: 
0:     /**
0:      * Get the number of columns in the control row.  
0:      * <p>
0:      * Control rows all share the first columns as defined by this class and
0:      * then add columns to the end of the control row.  For instance a branch
0:      * control row add a child page pointer field.
0:      * <p>
0:      *
0: 	 * @return The total number of columns in the control row.
0:      **/
0:     protected final int getNumberOfControlRowColumns()
0:     {
0:         return(this.CR_NCOLUMNS);
0:     }
0: 
0: 	public static long restartSplitFor(
0:     OpenBTree               open_btree,
0:     DataValueDescriptor[]	template,
0:     BranchControlRow        parent,
0:     ControlRow              child,
0:     DataValueDescriptor[]	newbranchrow,
0:     DataValueDescriptor[]	splitrow,
0:     int                     flag)
0:         throws StandardException
0: 	{
0:         // release parent and current latch
0:         parent.release();
0:         child.release();
0:         parent = null;
0:         child  = null;
0: 
0:         // Get the root page back, and perform a split following the
0:         // branch row which would not fit.
0:         ControlRow root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(root.page.isLatched());
0: 
0:         return(root.splitFor(open_btree, template, null, newbranchrow, flag));
0:     }
0: 
0: 
0: 	/**
0: 	 ** Perform a recursive search, ultimately returning the latched
0: 	 ** leaf page and row slot after which the given key belongs.
0: 	 ** The slot is returned in the result structure.  If the key
0: 	 ** exists on the page, the result.exact will be true.  Otherwise,
0: 	 ** result.exact will be false, and the row slot returned will be
0: 	 ** the one immediately preceding the position at which the key
0: 	 ** belongs.
0:      **
0:      ** @exception StandardException Standard exception policy.
0: 	 **/
0: 	public ControlRow search(SearchParameters sp)
0:         throws StandardException
0:     {
0:         ControlRow childpage    = null;
0:         long       childpageid;
0:         boolean    got_error    = true;
0: 
0:         try
0:         {
0:             searchForEntry(sp);
0: 
0:             if (sp.searchForOptimizer)
0:             {
0:                 // Update left_fraction to be used to esitimate the number of
0:                 // rows left of the current search key.
0: 
0:                 // Some search results leave the search positioned on the 0th
0:                 // slot which is a control row, in branch pages this results
0:                 // in following the left page pointer, there is no key 
0:                 // associated with this slot.  Set left_rows to be the number
0:                 // of leaf page pointers on the page which are left
0:                 // of the current slot.
0:                 float left_rows = sp.resultSlot;
0: 
0:                 // include the control row count here, as it accounts for the
0:                 // left page pointer which has no associated key.
0:                 int   row_count = this.page.recordCount();
0: 
0:                 if (this.getIsRoot())
0:                 {
0:                     sp.current_fraction = 1;
0:                     sp.left_fraction    = 0;
0:                 }
0: 
0:                 // calculate the fraction of rows in the table which are left 
0:                 // of the current slot in the search.  This number represents
0:                 // the fraction of rows in the sub-tree which includes all 
0:                 // rows left of rows pointed at by the sub-tree to be followed
0:                 // by the code below which descends the child page pointer.
0:                 // After the search is 
0:                 // completed (sp.left_fraction * number of rows), is the 
0:                 // estimated number of rows to the left of the current row.
0:                 sp.left_fraction    += 
0:                     (sp.current_fraction) * (left_rows / row_count);
0: 
0:                 sp.current_fraction = 
0:                     (sp.current_fraction) * (((float) 1) / row_count);
0:             }
0: 
0:             childpage =
0:                 this.getChildPageAtSlot(sp.btree, sp.resultSlot);
0: 
0:             this.release();
0: 
0:             got_error = false;
0: 
0:             return childpage.search(sp);
0:         }
0:         finally
0:         {
0:             if (got_error)
0:             {
0:                 if (childpage != null)
0:                     childpage.release();
0:                 if (this.page.isLatched())
0:                     this.release();
0:             }
0:         }
0:     }
0: 
0:     /**
0:      * Search and return the left most leaf page.
0:      * <p>
0: 	 * Perform a recursive search, ultimately returning the
0:      * leftmost leaf page which is the first leaf page in the
0: 	 * leaf sibling chain.  (This method might better be called
0: 	 * getFirstLeafPage()).
0:      *
0: 	 * @return The leftmost leaf page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow searchLeft(OpenBTree btree)
0:         throws StandardException
0:     {
0:         ControlRow childpage    = null;
0:         boolean    got_error    = true;
0: 
0:         try
0:         {
0:             childpage = this.getLeftChild(btree);
0:             this.release();
0: 
0:             got_error = false;
0:             return childpage.searchLeft(btree);
0:         }
0:         finally
0:         {
0:             if (got_error)
0:             {
0:                 if (childpage != null)
0:                     childpage.release();
0:                 if (this.page.isLatched())
0:                     this.release();
0:             }
0:         }
0:     }
0: 
0:     /**
0:      * Search and return the right most leaf page.
0:      * <p>
0: 	 * Perform a recursive search, ultimately returning the
0: 	 * rightmost leaf page which is the last leaf page in the
0: 	 * leaf sibling chain.  (This method might better be called
0: 	 * getLastLeafPage()).
0:      *
0: 	 * @return The rightmost leaf page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow searchRight(OpenBTree btree)
0:         throws StandardException
0:     {
0:         ControlRow childpage    = null;
0:         boolean    got_error    = true;
0: 
0:         try
0:         {
0:             childpage = this.getRightChild(btree);
0:             this.release();
0: 
0:             got_error = false;
0:             return(childpage.searchRight(btree));
0:         }
0:         finally
0:         {
0:             if (got_error)
0:             {
0:                 if (childpage != null)
0:                     childpage.release();
0:                 if (this.page.isLatched())
0:                     this.release();
0:             }
0:         }
0:     }
0: 
0: 
0: 	/**
0: 	 **	Perform a recursive shrink operation for the key.
0: 	 ** If this method returns true, the caller should
0: 	 ** remove the corresponding entry for the page.
0: 	 ** This routine is not guaranteed to successfully
0: 	 ** shrink anything.  The page lead to by the key might
0: 	 ** turn out not to be empty by the time shrink gets
0: 	 ** there, and shrinks will give up if there is a deadlock.
0: 	 ** <P>
0: 	 ** The receiver page must be latched on entry and is
0: 	 ** returned latched.
0:      **
0:      ** @exception StandardException Standard exception policy.
0: 	 **/
0: 	protected boolean shrinkFor(
0:     OpenBTree               open_btree, 
0:     DataValueDescriptor[]   shrink_key)
0:         throws StandardException
0:     {
0:         ControlRow childpage = null;
0:         boolean    shrinkme  = false;
0: 
0:         try
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.page.isLatched());
0: 
0:             // Find the child page for the shrink key.
0: 
0:             BranchRow branch_template =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
0:             SearchParameters sp = new SearchParameters(
0:                 shrink_key,
0:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
0:                 branch_template.getRow(), open_btree, false);
0: 
0:             this.searchForEntry(sp);
0:             childpage = this.getChildPageAtSlot(sp.btree, sp.resultSlot);
0: 
0:             // Recursively shrink the child.  If this call returns
0:             // true, then the child page has been deleted from its
0:             // sibling chain, and we have to delete the entry for it
0:             // in this page.
0: 
0:             if (childpage.shrinkFor(open_btree, shrink_key))
0:             {
0:                 // Child was deallocated.
0:                 if (sp.resultSlot != 0)
0:                 {
0:                     // Remove the corresponding branch row.  This call assumes
0:                     // that raw store will shift all higher slots down to fill
0:                     // the purged slot.
0:                     this.page.purgeAtSlot(sp.resultSlot, 1, true);
0:                 }
0:                 else
0:                 {
0:                     // Shrunk slot is zero, which means the left child page was
0:                     // deallocated. If the current page is empty, then
0:                     // we have to deallocate it.  Otherwise, we "slide" the rows
0:                     // down, making the first index row into the left child,
0:                     // and the second index row into the first, etc.
0: 
0:                     if (this.page.recordCount() > 1)
0:                     {
0:                         // There is a branch row on this page (besides the
0:                         // control row).  Make the first branch row into the
0:                         // left child.
0: 
0:                         long leftchildpageid =
0:                             getChildPageIdAtSlot(open_btree, 1);
0: 
0:                         this.setLeftChildPageno(leftchildpageid);
0: 
0:                         // purge the row we just made the "left child", this
0:                         // will automatically shifta all other rows "left" in
0:                         // the tree.
0:                         this.page.purgeAtSlot(1, 1, true);
0:                     }
0:                     else
0:                     {
0:                         // We shrunk the left child which was the last child on
0:                         // the page.  This means that this entire subtree is
0:                         // empty.  Again, there are two cases: root vs.
0:                         // non-root.  Because this method waits till pages are
0:                         // completely empty before deallocating them from the
0:                         // index, an empty root page means an empty index.
0:                         // If this page is not the root, then simply
0:                         // deallocate it and return that fact to the caller.
0: 
0:                         if (this.getIsRoot())
0:                         {
0:                             // The root page has become empty.  If the root page
0:                             // is empty, then the index is empty.  What has to
0:                             // happen here is that this page has to be
0:                             // converted back to an empty leaf page.
0: 
0:                             // With the current interface, after this page has
0:                             // been converted to a leaf, the caller will be
0:                             // left with a branch control row object, although
0:                             // the page is a leaf page.  This same problem was
0:                             // addressed in splitFor by adjusting the interface
0:                             // - the two routines should at least have the same
0:                             // interface style.
0: 
0:                             if (SanityManager.DEBUG)
0:                             {
0:                                 SanityManager.ASSERT(
0:                                     this.page.recordCount() == 1);
0:                             }
0: 
0:                             LeafControlRow newleafroot = new LeafControlRow(
0:                                 open_btree, this.page, null, true);
0: 
0:                             newleafroot.page.updateAtSlot(
0:                                 0, newleafroot.getRow(), 
0:                                 (FormatableBitSet) null);
0: 
0:                             newleafroot.release();
0: 
0:                             shrinkme = true;
0:                         }
0:                         else
0:                         {
0:                             // This page is empty, but it's not the root.  We
0:                             // have to unlink this page from its siblings, and
0:                             // return to the parent branch page that its
0:                             // branch row should be removed.
0: 
0:                             // Unlink this page from its siblings.
0:                             if (this.unlink(open_btree))
0:                             {
0:                                 // Tell the caller to remove entry.
0:                                 shrinkme = true;
0:                             }
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         finally
0:         {
0:             // If shrinkme then the page has been unlatched either by
0:             // page.removePage(), or by the process of changing the root branch
0:             // page to a root leaf page.
0:             if (!shrinkme)
0:                 this.release();
0:         }
0: 
0:         return(shrinkme);
0:     }
0: 
0:     /**
0:      * Perform a top down split pass making room for the the key in "row".
0:      * <p>
0:      * Perform a split such that a subsequent call to insert
0: 	 * given the argument index row will likely find room for it.  Since 
0:      * latches are released the client must code for the case where another
0:      * user has grabbed the space made available by the split pass and be
0:      * ready to do another split.
0:      * <p>
0:      * Latches:
0:      * o PARENT    : is latched on entry (unless the split is the root then
0:      *               there is no parent.
0:      * o THISBRANCH: the current page is latched on entry.
0:      * o CHILD     : latch the child page which will be pointed at by the
0:      *               left child pointer of the new page.
0:      *               RESOLVE (mikem) -see comments below
0:      * o NEWPAGE   : Allocate and latch new page.
0:      * o CHILD     : release. (RESOLVE)
0:      * o fixparents: latch pages and reset their parent pointers.
0:      *               Conditionally fix up the parent links on the pages
0:      *               pointed at by the newly allocated page.  First get latch
0:      *               and release on the left child page and then loop through
0:      *               slots on NEWPAGE, from left to right getting and
0:      *               releasing latches.
0:      *
0:      *
0: 	 * @return page number of the newly allocated leaf page created by split.
0:      *
0:      * @param btree      The open btree to associate latches with.
0:      * @param template   A scratch area to use while searching for split pass.
0:      * @param parentpage The parent page of the current page in the split pass.
0:      *                   starts at null for root.
0:      * @param row        The key to make room for during the split pass.
0:      * @param flag       A flag used to direct where point of split should be
0:      *                   chosen.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected long splitFor(
0:     OpenBTree               open_btree,
0:     DataValueDescriptor[]	template,
0:     BranchControlRow        parent,
0:     DataValueDescriptor[]	splitrow,
0:     int                     flag)
0:         throws StandardException
0: 	{
0: 		int        childpageid;
0: 		ControlRow childpage;
0: 
0: 		// On entry, the parent page is either latched by the caller,
0: 		// or it's null (which implies that this object is the root).
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(parent != null || this.getIsRoot());
0: 
0:             SanityManager.ASSERT(
0:                 parent == null || parent.page.isLatched(),
0:                 "parent page is not latched");
0: 
0:             SanityManager.ASSERT(this.page.isLatched(),
0:                 "page is not latched:");
0:         }
0: 
0:         if ((this.page.recordCount() - 1 >=
0:                 open_btree.getConglomerate().maxRowsPerPage) ||
0:             (!this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
0: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
0:         {
0: 
0:             if (this.page.recordCount() == 1)
0:             {
0:                 // RESOLVE (mikem) long row issue.  For now it makes no sense
0:                 // to split if there are no rows.  So if spaceForRecord() fails
0:                 // on empty page, we throw exception.
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_NO_SPACE_FOR_KEY);
0:             }
0: 
0: 			// Track.BranchSplit++;
0: 
0: 			if (this.getIsRoot())
0: 			{
0: 				// Track.BranchSplitRoot++;
0: 				growRoot(open_btree, template, this);
0: 
0: 				parent = (BranchControlRow)
0:                     ControlRow.Get(open_btree, BTree.ROOTPAGEID);
0: 
0: 
0: 				return(parent.splitFor(
0:                         open_btree, template, null, splitrow, flag));
0: 			}
0: 
0: 			// At this point we know that this page has to be split and
0: 			// that it isn't a root page.
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(!this.getIsRoot());
0:                 SanityManager.ASSERT(parent != null);
0:             }
0: 
0:             int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
0: 
0:             if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
0:             {
0:                 // move all the row to the new page
0:                 splitpoint = 1;
0:             }
0:             else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
0:             {
0:                 // This is not optimal as we would rather move no rows to the
0:                 // next page, but what should we use as a discriminator?
0:                 splitpoint = this.page.recordCount() - 1;
0:             }
0: 
0:             if (SanityManager.DEBUG)
0:             {
0: 				if (splitpoint <= 0)
0:                 	SanityManager.THROWASSERT(this + "yikes! splitpoint of 0!");
0:             }
0: 
0: 
0:             // Before any logged operation is done in the current internal
0:             // xact, make sure that there is room in the parent to insert
0:             // the new branch row.
0:             //
0: 			// Create a new branch row which points to the new page,
0:             // and insert it on parent page.
0: 
0:             // Read in the branch row which is at the split point.
0:             BranchRow split_branch_row =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
0: 
0:             this.page.fetchFromSlot(
0:                 (RecordHandle) null, splitpoint, split_branch_row.getRow(), 
0:                 (FetchDescriptor) null, true);
0: 
0:             // Create the branch row to insert onto the parent page.  For now
0:             // use a fake page number because we don't know the real page
0:             // number until the allocate is done, but want to delay the
0:             // allocate until we know the insert will succeed.
0: 			BranchRow newbranchrow =
0:                 split_branch_row.createBranchRowFromOldBranchRow(
0:                         BranchRow.DUMMY_PAGE_NUMBER);
0: 
0:             // At this point we have guaranteed there is space in the parent
0:             // page for splitrow, but it could be the case that the new
0:             // "newbranchrow" does not fit on the parent page.
0:             if (!parent.page.spaceForInsert(
0:                     newbranchrow.getRow(), (FormatableBitSet) null,
0: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
0:             {
0:                 // There is no room on the parent page to complete a split at
0:                 // the current level, so restart the split at top with the
0:                 // branchrow that did not fit.  On return from this routine
0:                 // there is no way to know the state of the tree, so the
0:                 // current split pass recursion must end.
0:                 return(
0:                     parent.restartSplitFor(
0:                         open_btree, template, parent, this,
0:                         newbranchrow.getRow(), splitrow, flag));
0:             }
0: 
0: 			// Get the child page for the index row at the split point
0: 			// This will be the left child for	the new page.  We're
0: 			// getting the page because BranchControlRow.Allocate
0: 			// sets the left child pointer from a BranchControlRow.
0: 			// If there were a version which just took the pageid,
0: 			// we wouldn't have to get the page (the latch on this
0: 			// page is enough to ensure that the child page won't
0: 			// disappear).
0: 
0:             childpage = this.getChildPageAtSlot(open_btree, splitpoint);
0: 
0: 			// Allocate a new branch page and link it to the
0: 			// right of the current page.
0: 			BranchControlRow newbranch =
0:                 BranchControlRow.Allocate(open_btree, childpage,
0:                     this.getLevel(), parent);
0: 			newbranch.linkRight(open_btree, this);
0: 
0: 
0:             // Test fail after allocation
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("branch_split_abort1"))
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
0:                 }
0:             }
0: 
0: 			// Done with the child page.
0: 			childpage.release();
0: 
0:             // Now that we know the page number of the new child page update
0:             // the branch row to be inserted with the correct value.
0:             newbranchrow.setPageNumber(newbranch.page.getPageNumber());
0: 
0:             BranchRow branch_template =
0:                 BranchRow.createEmptyTemplate(open_btree.getConglomerate());
0: 			SearchParameters sp = new SearchParameters(
0:                 newbranchrow.getRow(),
0:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
0:                 branch_template.getRow(),
0:                 open_btree, false);
0: 
0: 			parent.searchForEntry(sp);
0: 
0: 			byte insertFlag = Page.INSERT_INITIAL;
0: 			insertFlag |= Page.INSERT_DEFAULT;
0: 			insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
0: 			if (parent.page.insertAtSlot(
0:                     sp.resultSlot + 1,
0:                     newbranchrow.getRow(),
0:                     (FormatableBitSet) null,
0:                     (LogicalUndo)null,
0:                     insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)
0: 					== null)
0:             {
0:                 throw StandardException.newException(
0:                             SQLState.BTREE_NO_SPACE_FOR_KEY);
0: 			}
0: 
0: 
0:             // Test fail after of row onto parent page.
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("branch_split_abort2"))
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
0:                 }
0:             }
0: 
0:             // newbranchrow only valid while contents of split_branch_row
0:             // remain unchanged.
0:             newbranchrow = null;
0: 
0: 			// Copy the rows from the split point, but not including it (since
0:             // the split point is turning into the left child of the new
0:             // branch), onto the new page.  Purge the rows including the split
0: 			// point from the current page.
0:             int num_rows_to_move = this.page.recordCount() - (splitpoint + 1);
0: 
0:             if (num_rows_to_move > 0)
0:             {
0:                 this.page.copyAndPurge(
0:                     newbranch.page, splitpoint + 1, num_rows_to_move, 1);
0:             }
0: 
0:             // remove the splitpoint row, we didn't copy it because it became
0:             // the "left child", but we do need to get rid of it.
0: 			this.page.purgeAtSlot(splitpoint, 1, true);
0: 
0:             // Test fail after of copy of rows to new page.
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("branch_split_abort3"))
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
0:                 }
0:             }
0: 
0:             // Test fail after purge of rows on old page.
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("branch_split_abort4"))
0:                 {
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_ABORT_THROUGH_TRACE);
0:                 }
0:             }
0: 
0:             // Check pages that have been altered by above split
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:                 {
0:                     parent.checkConsistency(open_btree, null, false);
0:                     newbranch.checkConsistency(open_btree, parent, false);
0:                     this.checkConsistency(open_btree, parent, false);
0:                 }
0:             }
0: 
0: 			// Fix up the parent links on the pages for the rows that moved to
0:             // the new branch.
0: 			newbranch.fixChildrensParents(open_btree, null);
0: 
0:             // At this point a unit of work in the split down the tree has
0:             // been performed in an internal transaction (ie. writes have been
0:             // done to latched pages), and the resulting
0:             // tree is logically consistent, thus the work can be committed.
0:             // This work must be committed before any latches are released.
0:             open_btree.getXactMgr().commit();
0: 
0: 			// Decide whether we're following the current page or the new page.
0: 			BranchControlRow pagetofollow;
0: 
0:             if (CompareIndexRowToKey(
0:                     splitrow, 
0:                     split_branch_row.getRow(),
0:                     split_branch_row.getRow().length - 1, 0,
0: 					open_btree.getConglomerate().ascDescInfo) >= 0)
0:             {
0:                 // Follow the new branch
0: 				pagetofollow = newbranch;
0: 				this.release();
0: 			}
0: 			else
0: 			{
0: 				// Follow the current branch
0: 				pagetofollow = this;
0: 				newbranch.release();
0: 			}
0: 
0:             // At this point we hold latches on the parent, and the current
0:             // child of the page that we are following.  Note that committing
0:             // the internal transaction did not release the latches.
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(parent != null);
0:                 SanityManager.ASSERT(parent.page.isLatched());
0:                 SanityManager.ASSERT(
0:                         pagetofollow.page.isLatched());
0:             }
0: 
0: 			// Recurse down the tree splitting if necessary.
0: 			return(
0:                 pagetofollow.splitFor(
0:                     open_btree, template, parent, splitrow, flag));
0: 		}
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 this.checkConsistency(open_btree, parent, false);
0:             }
0:         }
0: 
0: 		// Don't need the parent any more.
0: 		if (parent != null)
0: 			parent.release();
0: 
0:         // RESOLVE (mikem) - should this be passed in?
0:         BranchRow branch_template =
0:             BranchRow.createEmptyTemplate(open_btree.getConglomerate());
0: 		SearchParameters sp = new SearchParameters(
0:             splitrow, 
0:             SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
0:             branch_template.getRow(), 
0:             open_btree, false);
0: 
0: 		searchForEntry(sp);
0: 
0:         childpage = this.getChildPageAtSlot(open_btree, sp.resultSlot);
0: 
0:         return(childpage.splitFor(open_btree, template, this, splitrow, flag));
0:     }
0: 
0: 	/*
0: 	** Debug/consistency check Methods of ControlRow:
0: 	*/
0: 
0: 
0: 	/**
0: 	 ** Perform consistency checks for a branch page.  The checks
0: 	 ** specific to a branch page are:
0: 	 ** <menu>
0: 	 ** <li> The rows on the page are indeed branch rows, and
0: 	 **      they all have the correct number of fields (which
0: 	 **      is the b-tree's key fields plus one for the child
0: 	 **      page number.
0: 	 ** <li> The child pages pointed to by the left child pointer
0: 	 **      and the index rows are linked together in the same
0: 	 **      order that they appear on the page.
0: 	 ** <li> The child pages themselves are all consistent.
0: 	 ** </menu>
0: 	 ** This method also performs the consistency checks that
0: 	 ** are common to both leaf and branch pages (see
0: 	 ** ControlRow.checkGeneric).
0:      **
0:      ** @exception StandardException Standard exception policy.
0: 	 **/
0: 	public int checkConsistency(
0:     OpenBTree  btree,
0:     ControlRow parent,
0:     boolean    check_other_pages)
0:         throws StandardException
0: 	{
0: 		// Do the consistency checks that are common to all
0: 		// types of pages.
0: 		checkGeneric(btree, parent, check_other_pages);
0: 
0:         // Branch specific Control Row checks.
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 this.getLevel() > 0, "branch not above level 0");
0: 
0:             // RESOLVE (mikem) - how to check right version?
0:             /*
0: 			if (this.getVersion() != CURRENT_BRANCH_VERSION)
0:             	SanityManager.THROWASSERT(
0:                 	"Expected branch version:(" + CURRENT_BRANCH_VERSION +
0:                 	") but got (" + this.getVersion());
0:             */
0:             SanityManager.ASSERT(
0:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) ==
0:                 BranchControlRow.CR_NCOLUMNS);
0:             SanityManager.ASSERT(getLeftChildPageno() !=
0:                                  ContainerHandle.INVALID_PAGE_NUMBER);
0: 
0:             // RESOLVE (mikem) - this makes an assumption about page numbering,
0:             // that may not be always valid in all implementations but has
0:             // been useful in finding bugs with uninitialized fields.
0:             SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
0:         }
0: 
0: 		// The remaining checks are specific to branch pages.
0:         if (SanityManager.DEBUG)
0:         {
0: 
0:             // Check that all the branch rows are branch rows
0:             // (we'll get a case error otherwise), and have the right
0:             // number of columns.  Every branch row should have the
0:             // btree's	key columns plus one for the child link.
0:             int numslots = this.page.recordCount();
0:             for (int slot = 1; slot < numslots; slot++)
0:             {
0: 				if ((this.page.fetchNumFieldsAtSlot(slot) !=
0:                      (btree.getConglomerate().nKeyFields + 1)))
0:                 	SanityManager.THROWASSERT(
0:                     	"row[" + slot + "]"
0:                         + " has " + this.page.fetchNumFieldsAtSlot(slot)
0:                         + " columns, should have at least " +
0:                         (btree.getConglomerate().nKeyFields + 1));
0: 
0:                 SanityManager.ASSERT(this.getChildPageIdAtSlot(btree, slot) !=
0:                         ContainerHandle.INVALID_PAGE_NUMBER);
0: 
0:                 // Rows on branch pages are never deleted, they are only purged.
0:                 SanityManager.ASSERT(!this.page.isDeletedAtSlot(slot));
0: 
0:                 // RESOLVE (mikem) - this makes an assumption about page
0:                 // numbering, that may not be always valid in all
0:                 // implementations but has been useful in finding bugs with
0:                 // uninitialized fields.
0:                 SanityManager.ASSERT(getLeftChildPageno() >= BTree.ROOTPAGEID);
0:             }
0:         }
0: 
0: 		// Check that the linkage of the children is in the
0: 		// same order as the branch rows.
0:         // RESOLVE (mikem) enable when multiple latches work.
0:         if (check_other_pages)
0: 		    checkChildOrderAgainstRowOrder(btree);
0: 
0: 		// Check the children.
0: 		int nchildren = 0;
0: 
0:         // RESOLVE (mikem) enable when multiple latches work.
0:         if (check_other_pages)
0:             nchildren = checkChildren(btree);
0: 
0: 		// Return the number of children visited plus one for this page.
0: 		return nchildren + 1;
0: 	}
0: 
0:     private int checkChildren(OpenBTree btree)
0:         throws StandardException
0:     {
0: 		int         nchildren = 0;
0:         ControlRow  childpage = null;
0: 
0:         try
0:         {
0:             // Check the left child.
0:             childpage = this.getLeftChild(btree);
0:             nchildren += childpage.checkConsistency(btree, this, true);
0:             childpage.release();
0:             childpage = null;
0: 
0:             // Check children from each index row.
0:             int numslots = this.page.recordCount();
0:             for (int slot = 1; slot < numslots; slot++)
0:             {
0:                 childpage = this.getChildPageAtSlot(btree, slot);
0:                 nchildren += childpage.checkConsistency(btree, this, true);
0:                 childpage.release();
0:                 childpage = null;
0:             }
0: 
0:             return(nchildren);
0:         }
0:         finally
0:         {
0:             if (childpage != null)
0:                 childpage.release();
0:         }
0:     }
0: 
0: 	private void checkChildOrderAgainstRowOrder(OpenBTree btree)
0:         throws StandardException
0: 	{
0: 		ControlRow cur  = null;
0: 		ControlRow prev = null;
0: 
0:         try
0:         {
0:             prev = this.getLeftChild(btree);
0: 
0:             int numslots = this.page.recordCount();
0:             for (int slot = 1; slot < numslots; slot++)
0:             {
0:                 cur = this.getChildPageAtSlot(btree, slot);
0: 
0:                 long shouldbecur_pageno = prev.getrightSiblingPageNumber();
0:                 if (SanityManager.DEBUG)
0:                 {
0: 					if (shouldbecur_pageno != cur.page.getPageNumber())
0:                     	SanityManager.THROWASSERT(
0:                         	"child linkage error going right.\n" +
0:                         	"cur page control row = " + cur + "\n" +
0:                         	"prev page control row = " + prev + "\n");
0:                 }
0: 
0:                 long shouldbeprev_pageno = cur.getleftSiblingPageNumber();
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT(
0:                         shouldbeprev_pageno == prev.page.getPageNumber(),
0:                         "child linkeage error going left");
0:                 }
0: 
0:                 prev.release();
0:                 prev = cur;
0:                 cur  = null;
0:             }
0: 
0:             prev.release();
0:             prev = null;
0:         }
0:         finally
0:         {
0:             if (prev != null)
0:                 prev.release();
0:             if (cur != null)
0:                 cur.release();
0:         }
0: 
0:         return;
0: 	}
0: 
0:     /**
0:      * Recursively print the tree starting at current node in tree.
0:      *
0:      * @param btree the open btree to print.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void printTree(
0:     OpenBTree  btree)
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
0: 
0:             ControlRow      child = null;
0: 
0:             try
0:             {
0:                 child = this.getLeftChild(btree);
0: 
0:                 child.printTree(btree);
0:                 child.release();
0:                 child = null;
0: 
0:                 int numslots = this.page.recordCount();
0:                 for (int slot = 1; slot < numslots; slot++)
0:                 {
0:                     child = this.getChildPageAtSlot(btree, slot);
0:                     child.printTree(btree);
0:                     child.release();
0:                     child = null;
0:                 }
0:             }
0:             finally
0:             {
0:                 if (child != null)
0:                     child.release();
0:             }
0: 
0:             return;
0:         }
0:     }
0: 
0: 	/*
0: 	 * Private methods of BranchControlRow
0: 	 */
0: 
0: 	/**
0:      ** Add a level to the tree by moving the current branch-root page up
0:      ** one level and adding a new page as it's left child.  On exit the
0:      ** current root page remains the root of the tree.
0: 	 ** <P>
0: 	 ** On entry, the current branch root page is expected to be latched.
0:      ** On exit, all latches will have been released.
0:      ** <P>
0:      ** Latch order:
0:      **    o ROOT: on entry current root is latched.
0:      **            No other latches should be held.
0:      **    o ROOT_OLDCHILD: Get and Latch root's left child page.
0:      **    o ROOT_NEWCHILD: Allocate a new branch page with latch.
0:      **    o Conditionally fix up the parent links on the pages pointed at
0:      **      by the newly allocated page.  Loop through slots on ROOT_NEWCHILD,
0:      **      from left to right getting and releasing latches.  Note that
0:      **      fixChildrensParents() must not latch the leftchild as ROOT_OLDCHILD
0:      **      is already latched.
0:      **    RESOLVE: (mikem) does order of release matter.
0:      **    o ROOT         : released.
0:      **    o ROOT_NEWCHILD: released.
0:      **    o ROOT_OLDCHILD: released.
0: 	 **/
0: 	private static void growRoot(
0:     OpenBTree               open_btree,
0:     DataValueDescriptor[]   template,
0:     BranchControlRow        root)
0:         throws StandardException
0: 	{
0:         ControlRow       leftchild = null;
0:         BranchControlRow branch    = null;
0: 
0:         try
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(root.page.isLatched());
0:                 SanityManager.ASSERT(root.getIsRoot());
0:             }
0: 
0:             // System.out.println("Growing root: control row = " + root);
0:             // System.out.println("Growing root: page = " + root.page);
0: 
0:             // Get and latch the current root's left child.  This will become
0:             // the left child on the new branch page (and the new
0:             // branch will become the left child of the root).
0:             leftchild = root.getLeftChild(open_btree);
0: 
0:             // Allocate a new branch page.	 This one will take the
0:             // rows from the root, and remain at the old root's level.
0:             // Its parent is the root.
0:             branch =
0:                 BranchControlRow.Allocate(
0:                     open_btree, leftchild, root.getLevel(), root);
0: 
0:             // Copy all the index rows from the root to the new branch.
0:             // Purge the index rows from the root now that they're safely on the
0:             // new branch page.  Leave the branch control row on the page.
0:             root.page.copyAndPurge(branch.page, 1, root.page.recordCount() - 1, 1);
0: 
0:             // Set the root's left child to be the new branch.
0:             root.setLeftChild(branch);
0: 
0:             // Move the root up a level
0:             root.setLevel(root.getLevel() + 1);
0: 
0:             // The parent of the old root's children has changed.
0:             // It used to be page 0 (the old root, but now it's
0:             // the new branch page.  Fix this up.
0:             branch.fixChildrensParents(open_btree, leftchild);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:                 {
0:                     root.checkConsistency(open_btree, null, false);
0:                     branch.checkConsistency(open_btree, root, false);
0:                     leftchild.checkConsistency(open_btree, branch, false);
0:                 }
0:             }
0: 
0:             // At this point a unit of work in the split down the tree has
0:             // been performed in an internal transaction.  This work must
0:             // be committed before any latches are released.
0:             open_btree.getXactMgr().commit();
0: 
0:         }
0:         finally
0:         {
0:             // At the end of a growRoot() no latches are held, the caller must
0:             // restart at the root.
0:             //
0:             root.release();
0:             if (branch != null)
0:                 branch.release();
0:             if (leftchild != null)
0:                 leftchild.release();
0:         }
0:         return;
0: 	}
0:     /**
0:      * Allocate a new leaf page to the conglomerate.
0:      *
0:      * @exception StandardException Standard exception policy.
0:      */
0:     private static BranchControlRow Allocate(
0:     OpenBTree         open_btree,
0:     ControlRow        leftchild,
0:     int               level,
0:     ControlRow        parent)
0:         throws StandardException
0:     {
0:         Page      page      = open_btree.container.addPage();
0: 
0:         // Create a control row for the new page.
0:         BranchControlRow control_row =
0:             new BranchControlRow(
0:                 open_btree, page, level,
0:                 parent, false, leftchild.page.getPageNumber());
0: 
0:         // Insert the control row on the page.
0: 		byte insertFlag = Page.INSERT_INITIAL;
0: 		insertFlag |= Page.INSERT_DEFAULT;
0:         page.insertAtSlot(
0:             Page.FIRST_SLOT_NUMBER,
0:             control_row.getRow(),
0:             (FormatableBitSet) null, 
0:             (LogicalUndo)null,
0:             insertFlag, AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
0: 
0:         // Page is returned latched.
0:         return(control_row);
0:     }
0: 
0: 	protected void setLeftChildPageno(long leftchild_pageno)
0:         throws StandardException
0: 	{
0: 		// Store the field.
0: 		if (left_child_page == null)
0: 			left_child_page = new SQLLongint(leftchild_pageno);
0:         else
0:             this.left_child_page.setValue(leftchild_pageno);
0: 
0: 		// Write the field through to the underlying row
0: 		this.page.updateFieldAtSlot(
0:             CR_SLOT, CR_LEFTCHILD, this.left_child_page, null);
0: 	}
0: 
0: 	protected void setLeftChild(ControlRow leftchild)
0:         throws StandardException
0: 	{
0:         this.setLeftChildPageno(leftchild.page.getPageNumber());
0: 	}
0: 
0: 	/**
0: 	 ** A branch page that has just been allocated as part
0: 	 ** of a split has index rows and a left child pointer
0: 	 ** that were copied from another page.  The parent
0: 	 ** link on the corresponding pages will still point to
0: 	 ** the original page.  This method fixes their parent
0: 	 ** pointers so that they point to the curren page like
0: 	 ** they're supposed to.
0: 	 ** <P>
0: 	 ** Note that maintaining the parent link is kind of a
0: 	 ** pain, and will slow down applications.  It's only
0: 	 ** needed for consistency checks, so we may want to
0: 	 ** have implementations that don't bother to maintain it.
0:      ** <P)
0:      ** This
0: 	 **/
0: 	private void fixChildrensParents(
0:     OpenBTree       btree,
0:     ControlRow      leftchild)
0:         throws StandardException
0: 	{
0:         ControlRow child = null;
0: 
0:         try
0:         {
0:             if (leftchild == null)
0:             {
0:                 child = this.getLeftChild(btree);
0:                 child.setParent(this.page.getPageNumber());
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:                     {
0:                         child.checkConsistency(btree, this, false);
0:                     }
0:                 }
0: 
0:                 child.release();
0:                 child = null;
0:             }
0:             else
0:             {
0:                 leftchild.setParent(this.page.getPageNumber());
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:                     {
0:                         leftchild.checkConsistency(btree, this, false);
0:                     }
0:                 }
0:             }
0: 
0:             int numslots = this.page.recordCount();
0:             for (int slot = 1; slot < numslots; slot++)
0:             {
0:                 child = getChildPageAtSlot(btree, slot);
0:                 child.setParent(this.page.getPageNumber());
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:                     {
0:                         child.checkConsistency(btree, this, false);
0:                     }
0:                 }
0: 
0:                 child.release();
0:                 child = null;
0:             }
0:         }
0:         finally
0:         {
0:             if (child != null)
0:                 child.release();
0:         }
0: 	}
0: 
0:     private long getChildPageIdAtSlot(
0:     OpenBTree       btree,
0:     int             slot)
0:         throws StandardException
0:     {
0:         long child_page_id;
0: 
0:         if (slot == 0)
0:         {
0:             child_page_id = this.getLeftChildPageno();
0:         }
0:         else
0:         {
0:             this.page.fetchFieldFromSlot(
0:                 slot, btree.getConglomerate().nKeyFields, child_pageno_buf);
0:             child_page_id = child_pageno_buf.getLong();
0:         }
0: 
0:         return(child_page_id);
0:     }
0: 
0:     protected ControlRow getChildPageAtSlot(
0:     OpenBTree       open_btree,
0:     int             slot)
0:         throws StandardException
0:     {
0:         ControlRow  child_control_row;
0: 
0:         if (slot == 0)
0:         {
0:             child_control_row = this.getLeftChild(open_btree);
0:         }
0:         else
0:         {
0:             this.page.fetchFieldFromSlot(
0:                 slot, open_btree.getConglomerate().nKeyFields, 
0:                 child_pageno_buf);
0: 
0:             child_control_row =
0:                 ControlRow.Get(open_btree, child_pageno_buf.getLong());
0:         }
0: 
0:         return(child_control_row);
0:     }
0: 
0:     /**
0:      * Return the left child pointer for the page.
0:      * <p>
0:      * Leaf pages don't have children, so they override this and return null.
0:      *
0: 	 * @return The page which is the leftmost child of this page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ControlRow getLeftChild(OpenBTree open_btree)
0:             throws StandardException
0:     {
0:          return(ControlRow.Get(open_btree, this.getLeftChildPageno()));
0:     }
0: 
0:     /**
0:      * Return the right child pointer for the page.
0:      * <p>
0:      * Leaf pages don't have children, so they override this and return null.
0:      *
0: 	 * @return The page which is the rightmost child of this page.
0:      *
0:      * @param open_btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow getRightChild(OpenBTree open_btree)
0:         throws StandardException
0:     {
0:         ControlRow right_child;
0:         int        num_slots = this.page.recordCount();
0: 
0:         // if num_slots is 1 then there are no branch rows, so just follow
0:         // the left page pointer, else if num_slots is > 1 then follow the
0:         // last branch row to find the rightmost child.
0:         right_child = 
0:             (num_slots == 1 ? 
0:                 ControlRow.Get(open_btree, this.getLeftChildPageno()) :
0:                 getChildPageAtSlot(open_btree, (num_slots - 1)));
0: 
0:         return(right_child);
0:     }
0: 
0: 	/**
0: 	 ** Return the left child page number for the page.  Leaf pages
0: 	 ** don't have left children, so they override this and return
0: 	 ** null.
0: 	 **/
0: 	long getLeftChildPageno()
0:         throws StandardException
0:     {
0:         if (this.left_child_page == null)
0:         {
0:             this.left_child_page = new SQLLongint();
0: 
0:             scratch_row[CR_LEFTCHILD] = this.left_child_page;
0: 
0:             fetchDesc.setValidColumns(CR_LEFTCHILD_BITMAP);
0:             this.page.fetchFromSlot(
0:                (RecordHandle) null, CR_SLOT, scratch_row, fetchDesc, false); 
0:         }
0:         return(left_child_page.getLong());
0:     }
0: 
0: 	/*
0: 	 * TypedFormat:
0: 	 */
0: 
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId()
0:     {
0: 		return StoredFormatIds.ACCESS_BTREE_BRANCHCONTROLROW_V1_ID;
0: 	}
0: 
0:     /**
0:      * Return a new template for reading a data row from the current page.
0:      * <p>
0:      * Default implementation for rows which are the same as the conglomerates
0:      * template, sub-classes can alter if underlying template is different
0:      * (for instance branch rows add an extra field at the end).
0:      *
0: 	 * @return Newly allocated template.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public DataValueDescriptor[] getRowTemplate(OpenBTree    open_btree)
0: 		throws StandardException
0:     {
0:         return(BranchRow.createEmptyTemplate(
0:                     open_btree.getConglomerate()).getRow());
0:     }
0: 
0: 	/**
0: 	 ** The standard toString.
0: 	 **/
0: 	public String toString()
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             String string = super.toString();
0: 
0:             try 
0:             {
0:                 string += "left child page = " + getLeftChildPageno() + ";";
0:                 
0:             }
0:             catch (Throwable t)
0:             {
0:                 string += "error encountered while doing ControlRow.toString()";
0:             }
0: 
0:             return(string);
0:         }
0:         else
0:         {
0:             return(null);
0:         }
0:     }
0: }
============================================================================