1:070d37e: 
3:eac0369: /*
1:392ac57: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CompilerContextImpl
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:eac0369:  */
15:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.sql.SQLWarning;
1:3bb140c: import java.util.ArrayList;
1:b7730e4: import java.util.HashMap;
1:b7730e4: import java.util.Iterator;
1:b7730e4: import java.util.List;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.ExceptionSeverity;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.compiler.JavaFactory;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextImpl;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Parser;
1:070d37e: import org.apache.derby.iapi.sql.compile.Visitable;
1:070d37e: import org.apache.derby.iapi.sql.compile.VisitableFilter;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:3bb140c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:3bb140c: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1:3bb140c: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:3bb140c: import org.apache.derby.iapi.sql.depend.Dependent;
1:3bb140c: import org.apache.derby.iapi.sql.depend.Provider;
1:3bb140c: import org.apache.derby.iapi.sql.depend.ProviderList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:98c7520: import org.apache.derby.iapi.sql.dictionary.PermDescriptor;
1:98c7520: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:e671fc7: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.StatementColumnPermission;
1:98c7520: import org.apache.derby.iapi.sql.dictionary.StatementGenericPermission;
1:71c8e86: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.StatementRolePermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.StatementSchemaPermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.StatementTablePermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.iapi.store.access.SortCostController;
1:3bb140c: import org.apache.derby.iapi.store.access.StoreCostController;
1:38f02ec: import org.apache.derby.iapi.transaction.TransactionControl;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: 
1:d387dac: /**
1:eac0369:  *
1:d387dac:  * CompilerContextImpl, implementation of CompilerContext.
1:d387dac:  * CompilerContext and hence CompilerContextImpl objects are private to a LanguageConnectionContext.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public class CompilerContextImpl extends ContextImpl
1:61070a6: 	implements CompilerContext {
1:eac0369: 
1:fc9fd0d:     private static  final   int SCOPE_CELL = 0;
1:fc9fd0d:     
4:eac0369: 	//
1:eac0369: 	// Context interface       
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown by makeInvalid() call
1:eac0369: 	 */
1:eac0369: 	public void cleanupOnError(Throwable error) throws StandardException {
1:eac0369: 
1:eac0369: 		setInUse(false);
1:eac0369: 		resetContext();
1:eac0369: 
1:eac0369: 		if (error instanceof StandardException) {
1:eac0369: 
1:eac0369: 			StandardException se = (StandardException) error;
1:eac0369: 			// if something went wrong with the compile,
1:eac0369: 			// we need to mark the statement invalid.
1:eac0369: 			// REVISIT: do we want instead to remove it,
1:eac0369: 			// so the cache doesn't get full of garbage input
1:eac0369: 			// that won't even parse?
1:5a50776:             
1:5a50776:             int severity = se.getSeverity();
1:eac0369: 
1:5a50776: 			if (severity < ExceptionSeverity.SYSTEM_SEVERITY) 
1:eac0369: 			{
1:eac0369: 				if (currentDependent != null)
1:eac0369: 				{
1:eac0369: 					currentDependent.makeInvalid(DependencyManager.COMPILE_FAILED,
1:eac0369: 												 lcc);
1:eac0369: 				}
1:eac0369: 				closeStoreCostControllers();
1:eac0369: 				closeSortCostControllers();
1:eac0369: 			}
1:eac0369: 			// anything system or worse, or non-DB errors,
1:eac0369: 			// will cause the whole system to shut down.
1:46df255:             
1:5a50776:             if (severity >= ExceptionSeverity.SESSION_SEVERITY)
1:5a50776:                 popMe();
1:eac0369: 		}
1:5a50776: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Reset compiler context (as for instance, when we recycle a context for
1:eac0369: 	  *	use by another compilation.
1:eac0369: 	  */
1:eac0369: 	public	void	resetContext()
1:eac0369: 	{
1:eac0369: 		nextColumnNumber = 1;
1:eac0369: 		nextTableNumber = 0;
1:eac0369: 		nextSubqueryNumber = 0;
1:eac0369: 		resetNextResultSetNumber();
1:eac0369: 		nextEquivalenceClass = -1;
1:eac0369: 		compilationSchema = null;
1:eac0369: 		parameterList = null;
1:eac0369: 		parameterDescriptors = null;
1:38f02ec: 		scanIsolationLevel = TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
1:eac0369: 		warnings = null;
1:eac0369: 		savedObjects = null;
1:eac0369: 		reliability = CompilerContext.SQL_LEGAL;
1:eac0369: 		returnParameterFlag = false;
1:b7730e4: 		initRequiredPriv();
1:392ac57: 		defaultSchemaStack = null;
1:e671fc7:         referencedSequences = null;
1:070d37e:         privilegeCheckFilters =  null;
1:fc9fd0d:         namedScopes = null;
1:b93f9db:         skippingTypePrivileges = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CompilerContext interface
1:eac0369: 	//
1:eac0369: 	// we might want these to refuse to return
1:eac0369: 	// anything if they are in-use -- would require
1:eac0369: 	// the interface provide a 'done' call, and
1:eac0369: 	// we would mark them in-use whenever a get happened.
1:eac0369: 	public Parser getParser() {
1:eac0369: 		return parser;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:       * Get the OptimizerFactory for this context
1:eac0369: 	  *
1:3bb140c:       * @return The OptimizerFactory for this context.
1:eac0369: 	  */
1:3bb140c:     public  OptimizerFactory    getOptimizerFactory()
1:3bb140c:     {   return lcf.getOptimizerFactory(); }
1:eac0369: 
1:eac0369: 
1:eac0369: 	public int getNextColumnNumber()
1:eac0369: 	{
1:eac0369: 		return nextColumnNumber++;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getNextTableNumber()
1:eac0369: 	{
1:eac0369: 		return nextTableNumber++;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getNumTables()
1:eac0369: 	{
1:eac0369: 		return nextTableNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current next subquery number from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The next subquery number for the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public int getNextSubqueryNumber()
1:eac0369: 	{
1:eac0369: 		return nextSubqueryNumber++;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of subquerys in the current statement from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The number of subquerys in the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public int getNumSubquerys()
1:eac0369: 	{
1:eac0369: 		return nextSubqueryNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getNextResultSetNumber()
1:eac0369: 	{
1:eac0369: 		return nextResultSetNumber++;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void resetNextResultSetNumber()
1:eac0369: 	{
1:eac0369: 		nextResultSetNumber = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getNumResultSets()
1:eac0369: 	{
1:eac0369: 		return nextResultSetNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getUniqueClassName()
1:eac0369: 	{
1:eac0369: 		// REMIND: should get a new UUID if we roll over...
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:     		SanityManager.ASSERT(nextClassName <= Long.MAX_VALUE);
1:eac0369:     	}
1:eac0369: 		return classPrefix.concat(Long.toHexString(nextClassName++));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the next equivalence class for equijoin clauses.
1:eac0369: 	 *
1:eac0369: 	 * @return The next equivalence class for equijoin clauses.
1:eac0369: 	 */
1:eac0369: 	public int getNextEquivalenceClass()
1:eac0369: 	{
1:eac0369: 		return ++nextEquivalenceClass;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ClassFactory getClassFactory()
1:eac0369: 	{
1:eac0369: 		return lcf.getClassFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public JavaFactory getJavaFactory()
1:eac0369: 	{
1:eac0369: 		return lcf.getJavaFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setCurrentDependent(Dependent d) {
1:eac0369: 		currentDependent = d;
1:d0c5d9c: 	}
1:d0c5d9c: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current auxiliary provider list from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return	The current AuxiliaryProviderList.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public ProviderList getCurrentAuxiliaryProviderList()
1:eac0369: 	{
1:eac0369: 		return currentAPL;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the current auxiliary provider list for this CompilerContext.
1:eac0369: 	 *
1:6b50965: 	 * @param apl	The new current AuxiliaryProviderList.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void setCurrentAuxiliaryProviderList(ProviderList apl)
1:eac0369: 	{
1:eac0369: 		currentAPL = apl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void createDependency(Provider p) throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:d387dac: 		SanityManager.ASSERT(currentDependent != null,
1:eac0369: 				"no current dependent for compilation");
1:eac0369: 
1:d387dac: 		if (dm == null)
1:d387dac: 			dm = lcc.getDataDictionary().getDependencyManager();
1:d387dac: 		dm.addDependency(currentDependent, p, getContextManager());
1:eac0369: 		addProviderToAuxiliaryList(p);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a dependency between two objects.
1:eac0369: 	 *
1:eac0369: 	 * @param d	The Dependent object.
1:eac0369: 	 * @param p	The Provider of the dependency.
2:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	void createDependency(Dependent d, Provider p) throws StandardException
1:eac0369: 	{
1:d387dac: 		if (dm == null)
1:d387dac: 			dm = lcc.getDataDictionary().getDependencyManager();
1:eac0369: 
1:eac0369: 		dm.addDependency(d, p, getContextManager());
1:eac0369: 		addProviderToAuxiliaryList(p);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a Provider to the current AuxiliaryProviderList, if one exists.
1:eac0369: 	 *
1:eac0369: 	 * @param p		The Provider to add.
1:eac0369: 	 */
1:eac0369: 	private void addProviderToAuxiliaryList(Provider p)
1:eac0369: 	{
1:eac0369: 		if (currentAPL != null)
1:eac0369: 		{
1:eac0369: 			currentAPL.addProvider(p);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int addSavedObject(Object obj) {
1:1c6c2e8:         if (savedObjects == null) {
1:71c8e86:             savedObjects = new ArrayList<Object>();
1:1c6c2e8:         }
1:eac0369: 
1:a32eb9f: 		savedObjects.add(obj);
1:eac0369: 		return savedObjects.size()-1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object[] getSavedObjects() {
1:eac0369: 		if (savedObjects == null) return null;
1:eac0369: 
1:47d4a4c: 		Object[] retVal = savedObjects.toArray();
1:eac0369: 		savedObjects = null; // erase to start over
1:eac0369: 		return retVal;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see CompilerContext#setSavedObjects */
1:71c8e86:     public void setSavedObjects(List<Object> objs)
1:eac0369: 	{
1:71c8e86:         Iterator<Object> it = objs.iterator();
1:554386c:         while (it.hasNext()) {
1:554386c:             addSavedObject(it.next());
1:554386c:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see CompilerContext#setCursorInfo */
1:eac0369: 	public void setCursorInfo(Object cursorInfo)
1:eac0369: 	{
1:eac0369: 		this.cursorInfo = cursorInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see CompilerContext#getCursorInfo */
1:eac0369: 	public Object getCursorInfo()
1:eac0369: 	{
1:eac0369: 		return cursorInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/** @see CompilerContext#firstOnStack */
1:eac0369: 	public void firstOnStack()
1:eac0369: 	{
1:eac0369: 		firstOnStack = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see CompilerContext#isFirstOnStack */
1:eac0369: 	public boolean isFirstOnStack()
1:eac0369: 	{
1:eac0369: 		return firstOnStack;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the in use state for the compiler context.
1:eac0369: 	 *
1:eac0369: 	 * @param inUse	 The new inUse state for the compiler context.
1:eac0369: 	 */
1:eac0369: 	public void setInUse(boolean inUse)
1:eac0369: 	{
1:eac0369: 		this.inUse = inUse;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Close the StoreCostControllers associated with this CompilerContext
1:eac0369: 		** when the context is no longer in use.
1:eac0369: 		*/
1:eac0369: 		if ( ! inUse)
1:eac0369: 		{
1:eac0369: 			closeStoreCostControllers();
1:eac0369: 			closeSortCostControllers();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the in use state for the compiler context.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	The in use state for the compiler context.
1:eac0369: 	 */
1:eac0369: 	public boolean getInUse()
1:eac0369: 	{
1:eac0369: 		return inUse;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets which kind of query fragments are NOT allowed. Basically,
1:eac0369: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
1:eac0369: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
1:eac0369: 	 *
1:eac0369: 	 * @param reliability	bitmask of types of query fragments to be forbidden
1:eac0369: 	 *						see the reliability bitmasks in CompilerContext.java
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void	setReliability(int reliability) { this.reliability = reliability; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the reliability requirements of this clause. See setReliability()
1:eac0369: 	 * for a definition of clause reliability.
1:eac0369: 	 *
1:eac0369: 	 * @return a bitmask of which types of query fragments are to be forbidden
1:eac0369: 	 */
1:eac0369: 	public int getReliability() { return reliability; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#getStoreCostController
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:d387dac: 	public StoreCostController getStoreCostController(long conglomerateNumber)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:bb5be6f:         Long conglomNum = conglomerateNumber;
1:eac0369: 
1:1c6c2e8:         // Try to find the given conglomerate number among the already
1:1c6c2e8:         // opened conglomerates.
1:71c8e86:         StoreCostController retval =
1:1c6c2e8:                 storeCostControllers.get(conglomNum);
1:eac0369: 
1:1c6c2e8:         if (retval == null) {
1:1c6c2e8:             // Not found, so get a StoreCostController from the store.
1:1c6c2e8:             retval = lcc.getTransactionCompile()
1:1c6c2e8:                         .openStoreCost(conglomerateNumber);
1:1c6c2e8:             storeCostControllers.put(conglomNum, retval);
1:1c6c2e8:         }
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private void closeStoreCostControllers()
1:eac0369: 	{
1:71c8e86:         Iterator<StoreCostController> it = storeCostControllers.values().iterator();
1:1c6c2e8:         while (it.hasNext())
1:eac0369: 		{
1:71c8e86:             StoreCostController scc = it.next();
1:eac0369: 			try {
1:eac0369: 				scc.close();
1:eac0369: 			} catch (StandardException se) {
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:a32eb9f: 		storeCostControllers.clear();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#getSortCostController
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public SortCostController getSortCostController() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Re-use a single SortCostController for each compilation
1:eac0369: 		*/
1:eac0369: 		if (sortCostController == null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Get a StoreCostController from the store.
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			sortCostController =
1:402f3c2: 				lcc.getTransactionCompile().openSortCostController();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sortCostController;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void closeSortCostControllers()
1:eac0369: 	{
1:eac0369: 		if (sortCostController != null)
1:eac0369: 		{
1:eac0369: 			sortCostController.close();
1:eac0369: 			sortCostController = null;	
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the compilation schema descriptor for this compilation context.
1:eac0369: 	   Will be null if no default schema lookups have occured. Ie.
1:eac0369: 	   the statement is independent of the current schema.
1:eac0369: 	 * 
1:eac0369: 	 * @return the compilation schema descirptor
1:eac0369: 	 */
1:eac0369: 	public SchemaDescriptor getCompilationSchema()
1:eac0369: 	{
1:eac0369: 		return compilationSchema;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the compilation schema descriptor for this compilation context.
1:eac0369: 	 *
1:6b50965: 	 * @param newDefault	the compilation schema
1:eac0369: 	 * 
1:eac0369: 	 * @return the previous compilation schema descirptor
1:eac0369: 	 */
1:eac0369: 	public SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault)
1:eac0369: 	{
1:eac0369: 		SchemaDescriptor tmpSchema = compilationSchema;
1:eac0369: 		compilationSchema = newDefault;
1:eac0369: 		return tmpSchema;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:392ac57: 	 * @see CompilerContext#pushCompilationSchema
1:392ac57: 	 */
1:392ac57: 	public void pushCompilationSchema(SchemaDescriptor sd)
1:392ac57: 	{
1:392ac57: 		if (defaultSchemaStack == null) {
1:71c8e86: 			defaultSchemaStack = new ArrayList<SchemaDescriptor>(2);
1:392ac57: 		}
1:392ac57: 
1:392ac57: 		defaultSchemaStack.add(defaultSchemaStack.size(),
1:392ac57: 							   getCompilationSchema());
1:392ac57: 		setCompilationSchema(sd);
1:392ac57: 	}
1:392ac57: 
1:392ac57: 	/**
1:392ac57: 	 * @see CompilerContext#popCompilationSchema
1:392ac57: 	 */
1:392ac57: 	public void popCompilationSchema()
1:392ac57: 	{
1:392ac57: 		SchemaDescriptor sd =
1:71c8e86: 			defaultSchemaStack.remove(
1:392ac57: 				defaultSchemaStack.size() - 1);
1:392ac57: 		setCompilationSchema(sd);
1:392ac57: 	}
1:392ac57: 
1:392ac57: 	/**
1:eac0369: 	 * @see CompilerContext#setParameterList
1:eac0369: 	 */
1:3bb140c:     public void setParameterList(List<ParameterNode> parameterList)
1:eac0369: 	{
1:eac0369: 		this.parameterList = parameterList;
1:eac0369: 
1:eac0369: 		/* Don't create param descriptors array if there are no params */
1:eac0369: 		int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();
1:eac0369: 
1:eac0369: 		if (numberOfParameters > 0)
1:eac0369: 		{
1:eac0369: 			parameterDescriptors = new DataTypeDescriptor[numberOfParameters];
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#getParameterList
1:eac0369: 	 */
1:3bb140c:     public List<ParameterNode> getParameterList()
1:eac0369: 	{
1:eac0369: 		return parameterList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#setReturnParameterFlag
1:eac0369: 	 */
1:eac0369: 	public void setReturnParameterFlag()
1:eac0369: 	{
1:eac0369: 		returnParameterFlag = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#getReturnParameterFlag
1:eac0369: 	 */
1:eac0369: 	public boolean getReturnParameterFlag()
1:eac0369: 	{
1:eac0369: 		return returnParameterFlag;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b49cc55:      * Get an array of type descriptors for all the ? parameters.
1:eac0369: 	 */
1:b49cc55:     DataTypeDescriptor[] getParameterTypes()
1:eac0369: 	{
1:eac0369: 		return parameterDescriptors;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#setScanIsolationLevel
1:eac0369: 	 */
1:eac0369: 	public void setScanIsolationLevel(int isolationLevel)
1:eac0369: 	{
1:eac0369: 		scanIsolationLevel = isolationLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * @see CompilerContext#getScanIsolationLevel
1:eac0369: 	 */
1:eac0369: 	public int getScanIsolationLevel()
1:eac0369: 	{
1:eac0369: 		return scanIsolationLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see CompilerContext#getTypeCompilerFactory
1:eac0369: 	 */
1:eac0369: 	public TypeCompilerFactory getTypeCompilerFactory()
1:eac0369: 	{
1:eac0369: 		return typeCompilerFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a compile time warning.
1:eac0369: 	*/
1:eac0369: 	public void addWarning(SQLWarning warning) {
1:eac0369: 		if (warnings == null)
1:eac0369: 			warnings = warning;
1:eac0369: 		else
1:eac0369: 			warnings.setNextWarning(warning);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the chain of compile time warnings.
1:eac0369: 	*/
1:eac0369: 	public SQLWarning getWarnings() {
1:eac0369: 		return warnings;
1:eac0369: 	}
1:eac0369: 
1:e1f49ca:     /*
1:e1f49ca:      * class interface
1:e1f49ca:      */
1:eac0369: 
1:e1f49ca:     /**
1:e1f49ca:      * This constructor creates and saves the parser using the language
1:e1f49ca:      * connection factory when the context is created (when the first statement
1:e1f49ca:      * comes in, likely).
1:e1f49ca:      */
1:e1f49ca:     @SuppressWarnings("LeakingThisInConstructor")
1:d387dac: 	public CompilerContextImpl(ContextManager cm,
1:d387dac: 			LanguageConnectionContext lcc,
1:eac0369: 		TypeCompilerFactory typeCompilerFactory )
1:eac0369: 	{
1:eac0369: 		super(cm, CompilerContext.CONTEXT_ID);
1:eac0369: 
1:d387dac: 		this.lcc = lcc;
1:d387dac: 		lcf = lcc.getLanguageConnectionFactory();
1:eac0369: 		this.parser = lcf.newParser(this);
1:eac0369: 		this.typeCompilerFactory = typeCompilerFactory;
1:eac0369: 
1:eac0369: 		// the prefix for classes in this connection
1:eac0369: 		classPrefix = "ac"+lcf.getUUIDFactory().createUUID().toString().replace('-','x');
1:eac0369: 
1:b7730e4: 		initRequiredPriv();
1:eac0369: 	}
1:eac0369: 
1:b7730e4: 	private void initRequiredPriv()
1:eac0369: 	{
1:b7730e4: 		currPrivType = Authorizer.NULL_PRIV;
1:b7730e4: 		privTypeStack.clear();
1:b7730e4: 		requiredColumnPrivileges = null;
1:b7730e4: 		requiredTablePrivileges = null;
1:c45f5b1: 		requiredSchemaPrivileges = null;
1:b7730e4: 		requiredRoutinePrivileges = null;
1:98c7520: 		requiredUsagePrivileges = null;
1:ee59de8: 		requiredRolePrivileges = null;
1:e1f49ca: 
1:e1f49ca:         if( lcc.usesSqlAuthorization())
1:eac0369: 		{
1:71c8e86: 			requiredColumnPrivileges = new HashMap<StatementTablePermission,StatementColumnPermission>();
1:71c8e86: 			requiredTablePrivileges = new HashMap<StatementTablePermission,StatementTablePermission>();
1:71c8e86: 			requiredSchemaPrivileges = new HashMap<StatementSchemaPermission,StatementSchemaPermission>();
1:71c8e86: 			requiredRoutinePrivileges = new HashMap<UUID,Integer>();
1:71c8e86: 			requiredUsagePrivileges = new HashMap<UUID,String>();
1:71c8e86: 			requiredRolePrivileges = new HashMap<StatementRolePermission,StatementRolePermission>();
1:eac0369: 		}
1:b7730e4: 	} // end of initRequiredPriv
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Sets the current privilege type context. Column and table nodes do not know
1:b7730e4: 	 * how they are being used. Higher level nodes in the query tree do not know what
1:b7730e4: 	 * is being referenced.
1:b7730e4: 	 * Keeping the context allows the two to come together.
1:eac0369: 	 *
1:b7730e4: 	 * @param privType One of the privilege types in org.apache.derby.iapi.sql.conn.Authorizer.
1:eac0369: 	 */
1:b7730e4: 	public void pushCurrentPrivType( int privType)
1:eac0369: 	{
1:bb5be6f: 		privTypeStack.add(currPrivType);
1:b7730e4: 		currPrivType = privType;
1:eac0369: 	}
1:eac0369: 
1:b7730e4: 	public void popCurrentPrivType( )
11:b7730e4: 	{
1:71c8e86:         Integer top = privTypeStack.remove(privTypeStack.size() - 1);
1:98d628e:         currPrivType = top.intValue();
1:eac0369: 	}
1:eac0369: 
1:c45f5b1: 	/**
1:b7730e4: 	 * Add a column privilege to the list of used column privileges.
1:eac0369: 	 *
1:797228c: 	 * @param column The column whose privileges we're interested in.
1:eac0369: 	 */
1:b7730e4: 	public void addRequiredColumnPriv( ColumnDescriptor column)
1:b7730e4: 	{
1:b7730e4: 		if( requiredColumnPrivileges == null // Using old style authorization
1:b7730e4: 			|| currPrivType == Authorizer.NULL_PRIV
1:b7730e4: 			|| currPrivType == Authorizer.DELETE_PRIV // Table privilege only
1:b7730e4: 			|| currPrivType == Authorizer.INSERT_PRIV // Table privilege only
1:b7730e4: 			|| currPrivType == Authorizer.TRIGGER_PRIV // Table privilege only
1:b7730e4: 			|| currPrivType == Authorizer.EXECUTE_PRIV
1:b7730e4: 			|| column == null)
1:18792e2:         {
1:eac0369: 			return;
1:18792e2:         }
1:18792e2: 
1:eac0369: 		/*
1:797228c: 		* Note that to look up the privileges for this column,
1:797228c: 		* we need to know what table the column is in. However,
1:797228c: 		* not all ColumnDescriptor objects are associated with
1:797228c: 		* a table object. Sometimes a ColumnDescriptor
1:797228c: 		* describes a column but doesn't specify the table. An
1:797228c: 		* example of this occurs in the set-clause of the
1:797228c: 		* UPDATE statement in SQL, where we may have a
1:797228c: 		* ColumnDescriptor which describes the expression that
1:797228c: 		* is being used in the UPDATE statement to provide the
1:797228c: 		* new value that will be computed by the UPDATE. In such a
1:797228c: 		* case, there is no column privilege to be added, so we
1:797228c: 		* just take an early return. DERBY-1583 has more details.
1:eac0369: 		*/
1:b7730e4: 		TableDescriptor td = column.getTableDescriptor();
1:797228c: 		if (td == null)
1:797228c: 			return;
1:58d069a: 
1:58d069a: 		if (td.getTableType() ==
1:58d069a: 				TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) {
1:58d069a: 			return; // no priv needed, it is per session anyway
1:58d069a: 		}
1:58d069a: 
1:b7730e4: 		UUID tableUUID = td.getUUID();
1:46df255: 
1:46df255: 		//DERBY-4191
1:46df255: 		if( currPrivType == Authorizer.MIN_SELECT_PRIV){
1:e3720ab:             // If we are here for MIN_SELECT_PRIV requirement, then first
1:e3720ab:             // check if there is already a SELECT privilege requirement on any
1:e3720ab:             // of the columns in the table, or on the table itself. If yes,
1:e3720ab:             // then we do not need to add MIN_SELECT_PRIV requirement for the
1:e3720ab:             // table because that requirement is already getting satisfied with
1:e3720ab:             // the already existing SELECT privilege requirement.
1:46df255: 			StatementTablePermission key = new StatementTablePermission( 
1:46df255: 					tableUUID, Authorizer.SELECT_PRIV);
1:e3720ab:             if (requiredColumnPrivileges.containsKey(key) ||
1:e3720ab:                     requiredTablePrivileges.containsKey(key)) {
1:46df255: 				return;
1:e3720ab:             }
1:46df255: 		}
1:46df255: 		if( currPrivType == Authorizer.SELECT_PRIV){
1:46df255: 			//If we are here for SELECT_PRIV requirement, then first check
1:46df255: 			//if there is already any MIN_SELECT_PRIV privilege required
1:46df255: 			//on this table. If yes, then that requirement will be fulfilled
1:46df255: 			//by the SELECT_PRIV requirement we are adding now. Because of
1:46df255: 			//that, remove the MIN_SELECT_PRIV privilege requirement
1:46df255: 			StatementTablePermission key = new StatementTablePermission( 
1:46df255: 					tableUUID, Authorizer.MIN_SELECT_PRIV);
1:e3720ab:             requiredColumnPrivileges.remove(key);
1:46df255: 		}
1:46df255: 		
1:b7730e4: 		StatementTablePermission key = new StatementTablePermission( tableUUID, currPrivType);
2:46df255: 		StatementColumnPermission tableColumnPrivileges
1:71c8e86: 		  = requiredColumnPrivileges.get( key);
1:b7730e4: 		if( tableColumnPrivileges == null)
1:eac0369: 		{
1:b7730e4: 			tableColumnPrivileges = new StatementColumnPermission( tableUUID,
1:b7730e4: 																   currPrivType,
1:b7730e4: 																   new FormatableBitSet( td.getNumberOfColumns()));
1:c45f5b1: 			requiredColumnPrivileges.put(key, tableColumnPrivileges);
1:eac0369: 		}
1:c45f5b1: 		tableColumnPrivileges.getColumns().set(column.getPosition() - 1);
1:b7730e4: 	} // end of addRequiredColumnPriv
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Add a table or view privilege to the list of used table privileges.
1:eac0369: 	 *
1:e1987c6: 	 * @see CompilerContext#addRequiredRoutinePriv
1:eac0369: 	 */
1:b7730e4: 	public void addRequiredTablePriv( TableDescriptor table)
1:eac0369: 	{
1:b7730e4: 		if( requiredTablePrivileges == null || table == null)
2:b7730e4: 			return;
1:eac0369: 
1:58d069a: 		if (table.getTableType() ==
1:58d069a: 				TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) {
1:58d069a: 			return; // no priv needed, it is per session anyway
1:58d069a: 		}
1:58d069a: 
1:46df255: 		if( currPrivType == Authorizer.SELECT_PRIV){
1:46df255: 			//DERBY-4191
1:46df255: 			//Check if there is any MIN_SELECT_PRIV select privilege required
1:46df255: 			//on this table. If yes, then that requirement will be fulfilled
1:46df255: 			//by the SELECT_PRIV requirement we are adding now. Because of
1:46df255: 			//that, remove the MIN_SELECT_PRIV privilege requirement
1:46df255: 			StatementTablePermission key = new StatementTablePermission( 
1:46df255: 					table.getUUID(), Authorizer.MIN_SELECT_PRIV);
1:e3720ab:             requiredColumnPrivileges.remove(key);
1:46df255: 		}
1:46df255: 
1:b7730e4: 		StatementTablePermission key = new StatementTablePermission( table.getUUID(), currPrivType);
1:c45f5b1: 		requiredTablePrivileges.put(key, key);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Add a routine execute privilege to the list of used routine privileges.
1:eac0369: 	 *
1:e1987c6: 	 * @see CompilerContext#addRequiredRoutinePriv
1:eac0369: 	 */
1:b7730e4: 	public void addRequiredRoutinePriv( AliasDescriptor routine)
1:eac0369: 	{
1:b7730e4: 		// routine == null for built in routines
1:b7730e4: 		if( requiredRoutinePrivileges == null || routine == null)
1:b7730e4: 			return;
1:eac0369: 
1:d50d4ab: 		// Ignore SYSFUN routines for permission scheme
1:d50d4ab: 		if (routine.getSchemaUUID().toString().equals(SchemaDescriptor.SYSFUN_SCHEMA_UUID))
1:d50d4ab: 			return;
1:eac0369: 
1:c45f5b1:  		if (requiredRoutinePrivileges.get(routine.getUUID()) == null)
1:bb5be6f: 			requiredRoutinePrivileges.put(routine.getUUID(), 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:98c7520: 	 * @see CompilerContext#addRequiredUsagePriv
1:98c7520: 	 */
1:98c7520: 	public void addRequiredUsagePriv( PrivilegedSQLObject usableObject )
1:98c7520:     {
1:98c7520: 		if( requiredUsagePrivileges == null || usableObject == null) { return; }
1:98c7520: 
1:98c7520:         UUID objectID = usableObject.getUUID();
1:98c7520:         String objectType = usableObject.getObjectTypeName();
1:98c7520: 
1:98c7520:  		if (requiredUsagePrivileges.get( objectID ) == null)
1:98c7520:         { requiredUsagePrivileges.put( objectID, objectType ); }
1:98c7520:     }
1:98c7520:     
1:98c7520: 	/**
1:c45f5b1: 	 * Add a required schema privilege to the list privileges.
1:eac0369: 	 *
1:e1987c6: 	 * @see CompilerContext#addRequiredSchemaPriv
1:eac0369: 	 */
1:28c633d: 	public void addRequiredSchemaPriv(String schemaName, String aid, int privType)
1:eac0369: 	{
1:50ba36b: 		if( requiredSchemaPrivileges == null || schemaName == null)
1:c45f5b1: 			return;
1:eac0369: 
1:50ba36b: 		StatementSchemaPermission key = new 
1:50ba36b: 				StatementSchemaPermission(schemaName, aid, privType);
1:eac0369: 
1:c45f5b1: 		requiredSchemaPrivileges.put(key, key);
1:eac0369: 	}
1:ee59de8: 
1:eac0369: 
1:ee59de8: 	/**
1:ee59de8: 	 * Add a required role privilege to the list privileges.
1:ee59de8: 	 *
1:ee59de8: 	 * @see CompilerContext#addRequiredRolePriv
1:ee59de8: 	 */
1:ee59de8: 	public void addRequiredRolePriv(String roleName, int privType)
1:ee59de8: 	{
1:ee59de8: 		if( requiredRolePrivileges == null)
1:ee59de8: 			return;
1:ee59de8: 
1:ee59de8: 		StatementRolePermission key = new
1:ee59de8: 			StatementRolePermission(roleName, privType);
1:ee59de8: 
1:ee59de8: 		requiredRolePrivileges.put(key, key);
1:ee59de8: 	}
1:ee59de8: 
1:ee59de8: 
5:b7730e4: 	/**
1:b7730e4: 	 * @return The list of required privileges.
1:eac0369: 	 */
1:71c8e86: 	public List<StatementPermission> getRequiredPermissionsList()
1:eac0369: 	{
1:b7730e4: 		int size = 0;
1:b7730e4: 		if( requiredRoutinePrivileges != null)
1:98c7520:         { size += requiredRoutinePrivileges.size(); }
1:98c7520: 		if( requiredUsagePrivileges != null)
1:98c7520:         { size += requiredUsagePrivileges.size(); }
1:b7730e4: 		if( requiredTablePrivileges != null)
1:98c7520:         { size += requiredTablePrivileges.size(); }
1:c45f5b1: 		if( requiredSchemaPrivileges != null)
1:98c7520:         { size += requiredSchemaPrivileges.size(); }
1:b7730e4: 		if( requiredColumnPrivileges != null)
1:98c7520:         { size += requiredColumnPrivileges.size(); }
1:ee59de8: 		if( requiredRolePrivileges != null)
1:98c7520:         { size += requiredRolePrivileges.size(); }
1:eac0369: 		
1:71c8e86: 		ArrayList<StatementPermission> list = new ArrayList<StatementPermission>( size);
1:b7730e4: 		if( requiredRoutinePrivileges != null)
1:eac0369: 		{
1:71c8e86: 			for( Iterator<UUID> itr = requiredRoutinePrivileges.keySet().iterator(); itr.hasNext();)
1:c45f5b1: 			{
1:71c8e86: 				UUID routineUUID = itr.next();
1:eac0369: 				
1:b7730e4: 				list.add( new StatementRoutinePermission( routineUUID));
1:98c7520: 			}
1:98c7520: 		}
1:98c7520: 		if( requiredUsagePrivileges != null)
1:98c7520: 		{
1:71c8e86: 			for( Iterator<UUID> itr = requiredUsagePrivileges.keySet().iterator(); itr.hasNext();)
1:98c7520: 			{
1:71c8e86: 				UUID objectID = itr.next();
1:98c7520: 				
1:3bb140c:                 list.add(new StatementGenericPermission(
1:3bb140c:                         objectID,
1:3bb140c:                         requiredUsagePrivileges.get(objectID),
1:3bb140c:                         PermDescriptor.USAGE_PRIV));
1:eac0369: 			}
1:eac0369: 		}
1:b7730e4: 		if( requiredTablePrivileges != null)
1:c45f5b1: 		{
1:71c8e86: 			for( Iterator<StatementTablePermission> itr = requiredTablePrivileges.values().iterator(); itr.hasNext();)
1:b7730e4: 			{
1:b7730e4: 				list.add( itr.next());
1:eac0369: 			}
1:eac0369: 		}
1:c45f5b1: 		if( requiredSchemaPrivileges != null)
1:ee59de8: 		{
1:71c8e86: 			for( Iterator<StatementSchemaPermission> itr = requiredSchemaPrivileges.values().iterator(); itr.hasNext();)
1:c45f5b1: 			{
1:c45f5b1: 				list.add( itr.next());
1:eac0369: 			}
1:c45f5b1: 		}
1:b7730e4: 		if( requiredColumnPrivileges != null)
1:b7730e4: 		{
1:71c8e86: 			for( Iterator<StatementColumnPermission> itr = requiredColumnPrivileges.values().iterator(); itr.hasNext();)
1:b7730e4: 			{
1:b7730e4: 				list.add( itr.next());
1:c45f5b1: 			}
1:c45f5b1: 		}
1:ee59de8: 		if( requiredRolePrivileges != null)
1:b7730e4: 		{
1:71c8e86: 			for( Iterator<StatementRolePermission> itr = requiredRolePrivileges.values().iterator();
1:ee59de8: 				 itr.hasNext();)
1:ee59de8: 			{
1:ee59de8: 				list.add( itr.next());
1:ee59de8: 			}
1:ee59de8: 		}
1:b7730e4: 		return list;
1:b7730e4: 	} // end of getRequiredPermissionsList
1:eac0369: 
1:e671fc7: 	public void addReferencedSequence( SequenceDescriptor sd )
1:e671fc7:     {
1:71c8e86:         if ( referencedSequences == null ) { referencedSequences = new HashMap<UUID,SequenceDescriptor>(); }
1:e671fc7: 
1:e671fc7:         referencedSequences.put( sd.getUUID(), sd );
1:e671fc7:     }
1:e671fc7: 
1:e671fc7: 	/**
1:e671fc7: 	 * Report whether the given sequence has been referenced already.
1:e671fc7: 	 */
1:e671fc7:     public boolean isReferenced( SequenceDescriptor sd )
1:e671fc7:     {
1:e671fc7:         if ( referencedSequences == null ) { return false; }
1:e671fc7: 
1:e671fc7:         return referencedSequences.containsKey( sd.getUUID() );
1:e671fc7:     }
1:e671fc7: 
1:070d37e:     public  void    addPrivilegeFilter( VisitableFilter vf )
1:070d37e:     {
1:070d37e:         if ( privilegeCheckFilters == null ) { privilegeCheckFilters = new ArrayList<VisitableFilter>(); }
1:070d37e:         
1:070d37e:         privilegeCheckFilters.add( vf );
1:070d37e:     }
1:070d37e: 
1:070d37e:     public  void    removePrivilegeFilter( VisitableFilter vf )
1:070d37e:     {
1:070d37e:         if ( (vf != null) && (privilegeCheckFilters != null) )
1:070d37e:         {
1:070d37e:             privilegeCheckFilters.remove( vf );
1:070d37e:         }
1:070d37e:     }
1:070d37e: 
1:070d37e:     public  boolean passesPrivilegeFilters( Visitable visitable )
1:070d37e:         throws StandardException
1:070d37e:     {
1:070d37e:         // if there are no filters, then all QueryTreeNodes pass.
1:070d37e:         if ( privilegeCheckFilters == null ) { return true; }
1:070d37e: 
1:070d37e:         for ( VisitableFilter filter : privilegeCheckFilters )
1:070d37e:         {
1:070d37e:             if ( !filter.accept( visitable ) ) { return false; }
1:070d37e:         }
1:070d37e: 
1:070d37e:         return true;
1:070d37e:     }
1:070d37e:     
1:fc9fd0d:     public  void    beginScope( String scopeName )
1:fc9fd0d:     {
1:fc9fd0d:         if ( namedScopes == null ) { namedScopes = new HashMap<String,int[]>(); }
1:fc9fd0d:         
1:fc9fd0d:         int[]   scopeDepth = namedScopes.get( scopeName );
1:fc9fd0d:         if ( scopeDepth == null )
1:fc9fd0d:         {
1:fc9fd0d:             scopeDepth = new int[ SCOPE_CELL + 1 ];
1:fc9fd0d:             namedScopes.put( scopeName, scopeDepth );
1:fc9fd0d:         }
1:fc9fd0d: 
1:fc9fd0d:         scopeDepth[ SCOPE_CELL ]++;
1:fc9fd0d:     }
1:fc9fd0d:     
1:fc9fd0d:     public  void    endScope( String scopeName )
1:fc9fd0d:     {
1:fc9fd0d:         if ( namedScopes == null ) { return; }
1:fc9fd0d: 
1:fc9fd0d:         int[]   scopeDepth = namedScopes.get( scopeName );
1:fc9fd0d:         if ( scopeDepth == null )   { return; }
1:fc9fd0d: 
1:fc9fd0d:         scopeDepth[ SCOPE_CELL ]--;
1:fc9fd0d: 
1:fc9fd0d:         if ( scopeDepth[ SCOPE_CELL ] <= 0 ) { namedScopes.remove( scopeName ); }
1:fc9fd0d:     }
1:fc9fd0d: 
1:fc9fd0d:     public  int     scopeDepth( String scopeName )
1:fc9fd0d:     {
1:fc9fd0d:         if ( namedScopes == null ) { return 0; }
1:fc9fd0d: 
1:fc9fd0d:         int[]   scopeDepth = namedScopes.get( scopeName );
1:fc9fd0d:         if ( scopeDepth == null )   { return 0; }
1:fc9fd0d:         else { return scopeDepth[ SCOPE_CELL ]; }
1:fc9fd0d:     }
1:fc9fd0d: 
1:b93f9db:     /** Set whether we should skip adding USAGE privileges for user-defined types */
1:b93f9db:     public  boolean    skipTypePrivileges( boolean skip )
1:b93f9db:     {
1:b93f9db:         boolean oldValue = skippingTypePrivileges;
1:b93f9db:         
1:b93f9db:         skippingTypePrivileges = skip;
1:b93f9db: 
1:b93f9db:         return oldValue;
1:b93f9db:     }
1:b93f9db: 
1:b93f9db:     /** Return whether we are skipping USAGE privileges for user-defined types */
1:b93f9db:     public  boolean skippingTypePrivileges()
1:b93f9db:     {
1:b93f9db:         return skippingTypePrivileges;
1:b93f9db:     }
1:fc9fd0d: 
1:eac0369: 	/*
1:fc9fd0d: 	** Context state must be reset in resetContext()
1:797228c: 	*/
1:eac0369: 
1:eac0369: 	private final Parser 		parser;
1:d387dac: 	private final LanguageConnectionContext lcc;
1:d387dac: 	private final LanguageConnectionFactory lcf;
1:eac0369: 	private TypeCompilerFactory	typeCompilerFactory;
1:eac0369: 	private Dependent			currentDependent;
1:d387dac: 	private DependencyManager	dm;
1:eac0369: 	private boolean				firstOnStack;
1:eac0369: 	private boolean				inUse;
1:eac0369: 	private int					reliability = CompilerContext.SQL_LEGAL;
1:eac0369: 	private	int					nextColumnNumber = 1;
1:eac0369: 	private int					nextTableNumber;
1:eac0369: 	private int					nextSubqueryNumber;
1:eac0369: 	private int					nextResultSetNumber;
1:eac0369: 	private int					scanIsolationLevel;
1:eac0369: 	private int					nextEquivalenceClass = -1;
1:eac0369: 	private long				nextClassName;
1:71c8e86: 	private List<Object>				savedObjects;
1:eac0369: 	private String				classPrefix;
1:eac0369: 	private SchemaDescriptor	compilationSchema;
1:fc9fd0d:     private ArrayList<VisitableFilter> privilegeCheckFilters;
1:fc9fd0d:     private HashMap<String,int[]> namedScopes;
1:b93f9db:     private boolean             skippingTypePrivileges;
1:392ac57: 
1:392ac57: 	/**
1:392ac57: 	 * Saved execution time default schema, if we need to change it
1:392ac57: 	 * temporarily.
1:392ac57: 	 */
1:71c8e86: 	private ArrayList<SchemaDescriptor>        	defaultSchemaStack;
1:392ac57: 
1:eac0369: 	private ProviderList		currentAPL;
1:eac0369: 	private boolean returnParameterFlag;
1:eac0369: 
1:1c6c2e8:     /**
1:1c6c2e8:      * Map that contains all store cost controllers opened in this compiler
1:1c6c2e8:      * context. Conglomerate id (long) is the key.
1:1c6c2e8:      */
1:71c8e86:     private final HashMap<Long,StoreCostController> storeCostControllers = new HashMap<Long,StoreCostController>();
1:eac0369: 
1:eac0369: 	private SortCostController	sortCostController;
1:eac0369: 
1:3bb140c:     private List<ParameterNode> parameterList;
1:eac0369: 
1:eac0369: 	/* Type descriptors for the ? parameters */
1:eac0369: 	private DataTypeDescriptor[]	parameterDescriptors;
1:eac0369: 
1:eac0369: 	private Object				cursorInfo;
1:eac0369: 
1:eac0369: 	private SQLWarning warnings;
1:eac0369: 
1:71c8e86: 	private final ArrayList<Integer> privTypeStack = new ArrayList<Integer>();
1:b7730e4: 	private int currPrivType = Authorizer.NULL_PRIV;
1:71c8e86: 	private HashMap<StatementTablePermission,StatementColumnPermission> requiredColumnPrivileges;
1:71c8e86: 	private HashMap<StatementTablePermission,StatementTablePermission> requiredTablePrivileges;
1:71c8e86: 	private HashMap<StatementSchemaPermission,StatementSchemaPermission> requiredSchemaPrivileges;
1:71c8e86: 	private HashMap<UUID,Integer> requiredRoutinePrivileges;
1:71c8e86: 	private HashMap<UUID,String> requiredUsagePrivileges;
1:71c8e86: 	private HashMap<StatementRolePermission,StatementRolePermission> requiredRolePrivileges;
1:71c8e86:     private HashMap<UUID,SequenceDescriptor> referencedSequences;
1:070d37e:     
1:b7730e4: } // end of class CompilerContextImpl
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Long conglomNum = conglomerateNumber;
/////////////////////////////////////////////////////////////////////////
1: 		privTypeStack.add(currPrivType);
/////////////////////////////////////////////////////////////////////////
1: 			requiredRoutinePrivileges.put(routine.getUUID(), 1);
commit:e3720ab
/////////////////////////////////////////////////////////////////////////
1:             // If we are here for MIN_SELECT_PRIV requirement, then first
1:             // check if there is already a SELECT privilege requirement on any
1:             // of the columns in the table, or on the table itself. If yes,
1:             // then we do not need to add MIN_SELECT_PRIV requirement for the
1:             // table because that requirement is already getting satisfied with
1:             // the already existing SELECT privilege requirement.
1:             if (requiredColumnPrivileges.containsKey(key) ||
1:                     requiredTablePrivileges.containsKey(key)) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             requiredColumnPrivileges.remove(key);
/////////////////////////////////////////////////////////////////////////
1:             requiredColumnPrivileges.remove(key);
commit:b49cc55
/////////////////////////////////////////////////////////////////////////
1:      * Get an array of type descriptors for all the ? parameters.
1:     DataTypeDescriptor[] getParameterTypes()
commit:554386c
/////////////////////////////////////////////////////////////////////////
0:     public void setSavedObjects(List objs)
0:         Iterator it = objs.iterator();
1:         while (it.hasNext()) {
1:             addSavedObject(it.next());
1:         }
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				lcc.getTransactionCompile().openSortCostController();
commit:98d628e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		privTypeStack.add(ReuseFactory.getInteger(currPrivType));
0:         Integer top = (Integer) privTypeStack.remove(privTypeStack.size() - 1);
1:         currPrivType = top.intValue();
/////////////////////////////////////////////////////////////////////////
0: 	private final ArrayList privTypeStack = new ArrayList();
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (savedObjects == null) {
0:             savedObjects = new ArrayList();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         Long conglomNum = ReuseFactory.getLong(conglomerateNumber);
1:         // Try to find the given conglomerate number among the already
1:         // opened conglomerates.
0:         StoreCostController retval = (StoreCostController)
1:                 storeCostControllers.get(conglomNum);
1:         if (retval == null) {
1:             // Not found, so get a StoreCostController from the store.
1:             retval = lcc.getTransactionCompile()
1:                         .openStoreCost(conglomerateNumber);
1:             storeCostControllers.put(conglomNum, retval);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         Iterator it = storeCostControllers.values().iterator();
1:         while (it.hasNext())
0:             StoreCostController scc = (StoreCostController) it.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Map that contains all store cost controllers opened in this compiler
1:      * context. Conglomerate id (long) is the key.
1:      */
0:     private final HashMap storeCostControllers = new HashMap();
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: 		Object[] retVal = savedObjects.toArray();
/////////////////////////////////////////////////////////////////////////
0: 		storeCostControllers.add(retval);
0: 		storeCostConglomIds.add(new Long(conglomerateNumber));
/////////////////////////////////////////////////////////////////////////
0: 	private List				savedObjects;
/////////////////////////////////////////////////////////////////////////
0:     private final List storeCostControllers = new Vector();
0:     private final List storeCostConglomIds = new Vector();
commit:38b5979
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public void setParameterList(List parameterList)
/////////////////////////////////////////////////////////////////////////
0: 	public List getParameterList()
/////////////////////////////////////////////////////////////////////////
0: 	private List parameterList;
commit:878e211
/////////////////////////////////////////////////////////////////////////
commit:d0c5d9c
/////////////////////////////////////////////////////////////////////////
0:     public Dependent getCurrentDependent() {
0:         return currentDependent;
1:     }
1: 
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1: 		savedObjects.add(obj);
/////////////////////////////////////////////////////////////////////////
0: 			Long conglomId = (Long) storeCostConglomIds.get(i);
0: 				return (StoreCostController) storeCostControllers.get(i);
/////////////////////////////////////////////////////////////////////////
0: 		storeCostControllers.add(storeCostControllers.size(), retval);
0: 		storeCostConglomIds.add(storeCostConglomIds.size(), new Long(conglomerateNumber));
/////////////////////////////////////////////////////////////////////////
0: 				(StoreCostController) storeCostControllers.get(i);
1: 		storeCostControllers.clear();
0: 		storeCostConglomIds.clear();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:18792e2
/////////////////////////////////////////////////////////////////////////
1:         {
1:         }
1: 
commit:b93f9db
/////////////////////////////////////////////////////////////////////////
1:         skippingTypePrivileges = false;
/////////////////////////////////////////////////////////////////////////
1:     /** Set whether we should skip adding USAGE privileges for user-defined types */
1:     public  boolean    skipTypePrivileges( boolean skip )
1:     {
1:         boolean oldValue = skippingTypePrivileges;
1:         
1:         skippingTypePrivileges = skip;
1: 
1:         return oldValue;
1:     }
1: 
1:     /** Return whether we are skipping USAGE privileges for user-defined types */
1:     public  boolean skippingTypePrivileges()
1:     {
1:         return skippingTypePrivileges;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     private boolean             skippingTypePrivileges;
commit:fc9fd0d
/////////////////////////////////////////////////////////////////////////
1:     private static  final   int SCOPE_CELL = 0;
1:     
/////////////////////////////////////////////////////////////////////////
1:         namedScopes = null;
/////////////////////////////////////////////////////////////////////////
1:     public  void    beginScope( String scopeName )
1:     {
1:         if ( namedScopes == null ) { namedScopes = new HashMap<String,int[]>(); }
1:         
1:         int[]   scopeDepth = namedScopes.get( scopeName );
1:         if ( scopeDepth == null )
1:         {
1:             scopeDepth = new int[ SCOPE_CELL + 1 ];
1:             namedScopes.put( scopeName, scopeDepth );
1:         }
1: 
1:         scopeDepth[ SCOPE_CELL ]++;
1:     }
1:     
1:     public  void    endScope( String scopeName )
1:     {
1:         if ( namedScopes == null ) { return; }
1: 
1:         int[]   scopeDepth = namedScopes.get( scopeName );
1:         if ( scopeDepth == null )   { return; }
1: 
1:         scopeDepth[ SCOPE_CELL ]--;
1: 
1:         if ( scopeDepth[ SCOPE_CELL ] <= 0 ) { namedScopes.remove( scopeName ); }
1:     }
1: 
1:     public  int     scopeDepth( String scopeName )
1:     {
1:         if ( namedScopes == null ) { return 0; }
1: 
1:         int[]   scopeDepth = namedScopes.get( scopeName );
1:         if ( scopeDepth == null )   { return 0; }
1:         else { return scopeDepth[ SCOPE_CELL ]; }
1:     }
1: 
1: 
1: 	** Context state must be reset in resetContext()
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<VisitableFilter> privilegeCheckFilters;
1:     private HashMap<String,int[]> namedScopes;
/////////////////////////////////////////////////////////////////////////
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.VisitableFilter;
/////////////////////////////////////////////////////////////////////////
1:         privilegeCheckFilters =  null;
/////////////////////////////////////////////////////////////////////////
1:     public  void    addPrivilegeFilter( VisitableFilter vf )
1:     {
1:         if ( privilegeCheckFilters == null ) { privilegeCheckFilters = new ArrayList<VisitableFilter>(); }
1:         
1:         privilegeCheckFilters.add( vf );
1:     }
1: 
1:     public  void    removePrivilegeFilter( VisitableFilter vf )
1:     {
1:         if ( (vf != null) && (privilegeCheckFilters != null) )
1:         {
1:             privilegeCheckFilters.remove( vf );
1:         }
1:     }
1: 
1:     public  boolean passesPrivilegeFilters( Visitable visitable )
1:         throws StandardException
1:     {
1:         // if there are no filters, then all QueryTreeNodes pass.
1:         if ( privilegeCheckFilters == null ) { return true; }
1: 
1:         for ( VisitableFilter filter : privilegeCheckFilters )
1:         {
1:             if ( !filter.accept( visitable ) ) { return false; }
1:         }
1: 
1:         return true;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
0:     private ArrayList<VisitableFilter> privilegeCheckFilters;
1:     
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
/////////////////////////////////////////////////////////////////////////
1:             savedObjects = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
1:     public void setSavedObjects(List<Object> objs)
1:         Iterator<Object> it = objs.iterator();
/////////////////////////////////////////////////////////////////////////
1:         StoreCostController retval =
/////////////////////////////////////////////////////////////////////////
1:         Iterator<StoreCostController> it = storeCostControllers.values().iterator();
1:             StoreCostController scc = it.next();
/////////////////////////////////////////////////////////////////////////
1: 			defaultSchemaStack = new ArrayList<SchemaDescriptor>(2);
/////////////////////////////////////////////////////////////////////////
1: 			defaultSchemaStack.remove(
/////////////////////////////////////////////////////////////////////////
1: 			requiredColumnPrivileges = new HashMap<StatementTablePermission,StatementColumnPermission>();
1: 			requiredTablePrivileges = new HashMap<StatementTablePermission,StatementTablePermission>();
1: 			requiredSchemaPrivileges = new HashMap<StatementSchemaPermission,StatementSchemaPermission>();
1: 			requiredRoutinePrivileges = new HashMap<UUID,Integer>();
1: 			requiredUsagePrivileges = new HashMap<UUID,String>();
1: 			requiredRolePrivileges = new HashMap<StatementRolePermission,StatementRolePermission>();
/////////////////////////////////////////////////////////////////////////
1:         Integer top = privTypeStack.remove(privTypeStack.size() - 1);
/////////////////////////////////////////////////////////////////////////
1: 			  = requiredColumnPrivileges.get( key);
/////////////////////////////////////////////////////////////////////////
0: 			  = requiredColumnPrivileges.get( key);
0: 		  = requiredColumnPrivileges.get( key);
/////////////////////////////////////////////////////////////////////////
0: 			  = requiredColumnPrivileges.get( key);
/////////////////////////////////////////////////////////////////////////
1: 	public List<StatementPermission> getRequiredPermissionsList()
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<StatementPermission> list = new ArrayList<StatementPermission>( size);
1: 			for( Iterator<UUID> itr = requiredRoutinePrivileges.keySet().iterator(); itr.hasNext();)
1: 				UUID routineUUID = itr.next();
1: 			for( Iterator<UUID> itr = requiredUsagePrivileges.keySet().iterator(); itr.hasNext();)
1: 				UUID objectID = itr.next();
1: 			for( Iterator<StatementTablePermission> itr = requiredTablePrivileges.values().iterator(); itr.hasNext();)
1: 			for( Iterator<StatementSchemaPermission> itr = requiredSchemaPrivileges.values().iterator(); itr.hasNext();)
1: 			for( Iterator<StatementColumnPermission> itr = requiredColumnPrivileges.values().iterator(); itr.hasNext();)
1: 			for( Iterator<StatementRolePermission> itr = requiredRolePrivileges.values().iterator();
/////////////////////////////////////////////////////////////////////////
1:         if ( referencedSequences == null ) { referencedSequences = new HashMap<UUID,SequenceDescriptor>(); }
/////////////////////////////////////////////////////////////////////////
1: 	private List<Object>				savedObjects;
/////////////////////////////////////////////////////////////////////////
1: 	private ArrayList<SchemaDescriptor>        	defaultSchemaStack;
/////////////////////////////////////////////////////////////////////////
1:     private final HashMap<Long,StoreCostController> storeCostControllers = new HashMap<Long,StoreCostController>();
/////////////////////////////////////////////////////////////////////////
1: 	private final ArrayList<Integer> privTypeStack = new ArrayList<Integer>();
1: 	private HashMap<StatementTablePermission,StatementColumnPermission> requiredColumnPrivileges;
1: 	private HashMap<StatementTablePermission,StatementTablePermission> requiredTablePrivileges;
1: 	private HashMap<StatementSchemaPermission,StatementSchemaPermission> requiredSchemaPrivileges;
1: 	private HashMap<UUID,Integer> requiredRoutinePrivileges;
1: 	private HashMap<UUID,String> requiredUsagePrivileges;
1: 	private HashMap<StatementRolePermission,StatementRolePermission> requiredRolePrivileges;
1:     private HashMap<UUID,SequenceDescriptor> referencedSequences;
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.transaction.TransactionControl;
/////////////////////////////////////////////////////////////////////////
1: 		scanIsolationLevel = TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         referencedSequences = null;
/////////////////////////////////////////////////////////////////////////
1: 	public void addReferencedSequence( SequenceDescriptor sd )
1:     {
0:         if ( referencedSequences == null ) { referencedSequences = new HashMap(); }
1: 
1:         referencedSequences.put( sd.getUUID(), sd );
1:     }
1: 
1: 	/**
1: 	 * Report whether the given sequence has been referenced already.
1: 	 */
1:     public boolean isReferenced( SequenceDescriptor sd )
1:     {
1:         if ( referencedSequences == null ) { return false; }
1: 
1:         return referencedSequences.containsKey( sd.getUUID() );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private HashMap referencedSequences;
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.PermDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1: import org.apache.derby.iapi.sql.dictionary.StatementGenericPermission;
/////////////////////////////////////////////////////////////////////////
1: 		requiredUsagePrivileges = null;
/////////////////////////////////////////////////////////////////////////
0: 			requiredUsagePrivileges = new HashMap();
/////////////////////////////////////////////////////////////////////////
1: 	 * @see CompilerContext#addRequiredUsagePriv
1: 	 */
1: 	public void addRequiredUsagePriv( PrivilegedSQLObject usableObject )
1:     {
1: 		if( requiredUsagePrivileges == null || usableObject == null) { return; }
1: 
1:         UUID objectID = usableObject.getUUID();
1:         String objectType = usableObject.getObjectTypeName();
1: 
1:  		if (requiredUsagePrivileges.get( objectID ) == null)
1:         { requiredUsagePrivileges.put( objectID, objectType ); }
1:     }
1:     
1: 	/**
/////////////////////////////////////////////////////////////////////////
1:         { size += requiredRoutinePrivileges.size(); }
1: 		if( requiredUsagePrivileges != null)
1:         { size += requiredUsagePrivileges.size(); }
1:         { size += requiredTablePrivileges.size(); }
1:         { size += requiredSchemaPrivileges.size(); }
1:         { size += requiredColumnPrivileges.size(); }
1:         { size += requiredRolePrivileges.size(); }
/////////////////////////////////////////////////////////////////////////
1: 		if( requiredUsagePrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredUsagePrivileges.keySet().iterator(); itr.hasNext();)
1: 			{
0: 				UUID objectID = (UUID) itr.next();
1: 				
0: 				list.add( new StatementGenericPermission( objectID, (String) requiredUsagePrivileges.get( objectID ), PermDescriptor.USAGE_PRIV ) );
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 	private HashMap requiredUsagePrivileges;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * class interface
1:      */
1:     /**
1:      * This constructor creates and saves the parser using the language
1:      * connection factory when the context is created (when the first statement
1:      * comes in, likely).
1:      */
1:     @SuppressWarnings("LeakingThisInConstructor")
/////////////////////////////////////////////////////////////////////////
1: 
1:         if( lcc.usesSqlAuthorization())
commit:9bf29d2
/////////////////////////////////////////////////////////////////////////
0:     DataTypeDescriptor[] getParameterTypes()
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.compiler.JavaFactory;
1: import org.apache.derby.iapi.services.context.ContextImpl;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1: import org.apache.derby.iapi.sql.compile.Parser;
1: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.PermDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.StatementColumnPermission;
0: import org.apache.derby.iapi.sql.dictionary.StatementGenericPermission;
0: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementRolePermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementSchemaPermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementTablePermission;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.store.access.SortCostController;
1: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.transaction.TransactionControl;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1:       * Get the OptimizerFactory for this context
1:       * @return The OptimizerFactory for this context.
1:     public  OptimizerFactory    getOptimizerFactory()
1:     {   return lcf.getOptimizerFactory(); }
/////////////////////////////////////////////////////////////////////////
1:     public void setParameterList(List<ParameterNode> parameterList)
/////////////////////////////////////////////////////////////////////////
1:     public List<ParameterNode> getParameterList()
/////////////////////////////////////////////////////////////////////////
0:     public DataTypeDescriptor[] getParameterTypes()
/////////////////////////////////////////////////////////////////////////
1:                 list.add(new StatementGenericPermission(
1:                         objectID,
1:                         requiredUsagePrivileges.get(objectID),
1:                         PermDescriptor.USAGE_PRIV));
/////////////////////////////////////////////////////////////////////////
1:     private List<ParameterNode> parameterList;
commit:392ac57
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 		defaultSchemaStack = null;
/////////////////////////////////////////////////////////////////////////
1: 	 * @see CompilerContext#pushCompilationSchema
1: 	 */
1: 	public void pushCompilationSchema(SchemaDescriptor sd)
1: 	{
1: 		if (defaultSchemaStack == null) {
0: 			defaultSchemaStack = new ArrayList(2);
1: 		}
1: 
1: 		defaultSchemaStack.add(defaultSchemaStack.size(),
1: 							   getCompilationSchema());
1: 		setCompilationSchema(sd);
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#popCompilationSchema
1: 	 */
1: 	public void popCompilationSchema()
1: 	{
1: 		SchemaDescriptor sd =
0: 			(SchemaDescriptor)defaultSchemaStack.remove(
1: 				defaultSchemaStack.size() - 1);
1: 		setCompilationSchema(sd);
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Saved execution time default schema, if we need to change it
1: 	 * temporarily.
1: 	 */
0: 	private ArrayList        	defaultSchemaStack;
1: 
commit:58d069a
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if (td.getTableType() ==
1: 				TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) {
1: 			return; // no priv needed, it is per session anyway
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (table.getTableType() ==
1: 				TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) {
1: 			return; // no priv needed, it is per session anyway
1: 		}
1: 
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.StatementRolePermission;
/////////////////////////////////////////////////////////////////////////
1: 		requiredRolePrivileges = null;
/////////////////////////////////////////////////////////////////////////
0: 			requiredRolePrivileges = new HashMap();
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Add a required role privilege to the list privileges.
1: 	 *
1: 	 * @see CompilerContext#addRequiredRolePriv
1: 	 */
1: 	public void addRequiredRolePriv(String roleName, int privType)
1: 	{
1: 		if( requiredRolePrivileges == null)
1: 			return;
1: 
1: 		StatementRolePermission key = new
1: 			StatementRolePermission(roleName, privType);
1: 
1: 		requiredRolePrivileges.put(key, key);
1: 	}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if( requiredRolePrivileges != null)
0: 			size += requiredRolePrivileges.size();
/////////////////////////////////////////////////////////////////////////
1: 		if( requiredRolePrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredRolePrivileges.values().iterator();
1: 				 itr.hasNext();)
1: 			{
1: 				list.add( itr.next());
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 	private HashMap requiredRolePrivileges;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:46df255
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 		//DERBY-4191
1: 		if( currPrivType == Authorizer.MIN_SELECT_PRIV){
0: 			//If we are here for MIN_SELECT_PRIV requirement, then first
0: 			//check if there is already a SELECT privilege requirement on any 
0: 			//of the columns in the table. If yes, then we do not need to add 
0: 			//MIN_SELECT_PRIV requirement for the table because that 
0: 			//requirement is already getting satisfied with the already
0: 			//existing SELECT privilege requirement
1: 			StatementTablePermission key = new StatementTablePermission( 
1: 					tableUUID, Authorizer.SELECT_PRIV);
1: 			StatementColumnPermission tableColumnPrivileges
0: 			  = (StatementColumnPermission) requiredColumnPrivileges.get( key);
0: 			if( tableColumnPrivileges != null)
1: 				return;
1: 		}
1: 		if( currPrivType == Authorizer.SELECT_PRIV){
1: 			//If we are here for SELECT_PRIV requirement, then first check
1: 			//if there is already any MIN_SELECT_PRIV privilege required
1: 			//on this table. If yes, then that requirement will be fulfilled
1: 			//by the SELECT_PRIV requirement we are adding now. Because of
1: 			//that, remove the MIN_SELECT_PRIV privilege requirement
1: 			StatementTablePermission key = new StatementTablePermission( 
1: 					tableUUID, Authorizer.MIN_SELECT_PRIV);
1: 			StatementColumnPermission tableColumnPrivileges
0: 			  = (StatementColumnPermission) requiredColumnPrivileges.get( key);
0: 			if( tableColumnPrivileges != null)
0: 				requiredColumnPrivileges.remove(key);
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		if( currPrivType == Authorizer.SELECT_PRIV){
1: 			//DERBY-4191
1: 			//Check if there is any MIN_SELECT_PRIV select privilege required
1: 			//on this table. If yes, then that requirement will be fulfilled
1: 			//by the SELECT_PRIV requirement we are adding now. Because of
1: 			//that, remove the MIN_SELECT_PRIV privilege requirement
1: 			StatementTablePermission key = new StatementTablePermission( 
1: 					table.getUUID(), Authorizer.MIN_SELECT_PRIV);
0: 			StatementColumnPermission tableColumnPrivileges
0: 			  = (StatementColumnPermission) requiredColumnPrivileges.get( key);
0: 			if( tableColumnPrivileges != null)
0: 				requiredColumnPrivileges.remove(key);
1: 		}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:58f22ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5a50776
/////////////////////////////////////////////////////////////////////////
1:             
1:             int severity = se.getSeverity();
1: 			if (severity < ExceptionSeverity.SYSTEM_SEVERITY) 
/////////////////////////////////////////////////////////////////////////
1:             
1:             if (severity >= ExceptionSeverity.SESSION_SEVERITY)
1:                 popMe();
commit:d387dac
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * CompilerContextImpl, implementation of CompilerContext.
1:  * CompilerContext and hence CompilerContextImpl objects are private to a LanguageConnectionContext.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		SanityManager.ASSERT(currentDependent != null,
1: 		if (dm == null)
1: 			dm = lcc.getDataDictionary().getDependencyManager();
1: 		dm.addDependency(currentDependent, p, getContextManager());
/////////////////////////////////////////////////////////////////////////
1: 		if (dm == null)
1: 			dm = lcc.getDataDictionary().getDependencyManager();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public StoreCostController getStoreCostController(long conglomerateNumber)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public CompilerContextImpl(ContextManager cm,
1: 			LanguageConnectionContext lcc,
1: 		this.lcc = lcc;
1: 		lcf = lcc.getLanguageConnectionFactory();
/////////////////////////////////////////////////////////////////////////
1: 	private final LanguageConnectionContext lcc;
1: 	private final LanguageConnectionFactory lcf;
1: 	private DependencyManager	dm;
/////////////////////////////////////////////////////////////////////////
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CompilerContextImpl
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
1: 	implements CompilerContext {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: 
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.SortCostController;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.context.ContextImpl;
1: 
1: import java.sql.SQLWarning;
0: import java.util.Vector;
0: import java.util.Properties;
1: 
1: /*
1:  *
0:  * CompilerContextImpl
1:  *
1:  */
1: public class CompilerContextImpl extends ContextImpl
0: 	implements CompilerContext { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	//
1: 	// Context interface       
1: 	//
1: 
1: 	/**
1: 		@exception StandardException thrown by makeInvalid() call
1: 	 */
1: 	public void cleanupOnError(Throwable error) throws StandardException {
1: 
1: 		setInUse(false);
1: 		resetContext();
1: 
1: 		if (error instanceof StandardException) {
1: 
1: 			StandardException se = (StandardException) error;
1: 			// if something went wrong with the compile,
1: 			// we need to mark the statement invalid.
1: 			// REVISIT: do we want instead to remove it,
1: 			// so the cache doesn't get full of garbage input
1: 			// that won't even parse?
1: 
0: 			if (se.getSeverity() < ExceptionSeverity.SYSTEM_SEVERITY) 
1: 			{
1: 				if (currentDependent != null)
1: 				{
0: 					LanguageConnectionContext lcc;
1: 
0: 					/* Find the LanguageConnectionContext */
0: 					lcc = (LanguageConnectionContext)
0: 						getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
1: 					currentDependent.makeInvalid(DependencyManager.COMPILE_FAILED,
1: 												 lcc);
1: 				}
1: 				closeStoreCostControllers();
1: 				closeSortCostControllers();
1: 			}
1: 			// anything system or worse, or non-DB errors,
1: 			// will cause the whole system to shut down.
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	  *	Reset compiler context (as for instance, when we recycle a context for
1: 	  *	use by another compilation.
1: 	  */
1: 	public	void	resetContext()
1: 	{
1: 		nextColumnNumber = 1;
1: 		nextTableNumber = 0;
1: 		nextSubqueryNumber = 0;
1: 		resetNextResultSetNumber();
1: 		nextEquivalenceClass = -1;
1: 		compilationSchema = null;
1: 		parameterList = null;
1: 		parameterDescriptors = null;
0: 		scanIsolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
1: 		warnings = null;
1: 		savedObjects = null;
1: 		reliability = CompilerContext.SQL_LEGAL;
1: 		returnParameterFlag = false;
1: 	}
1: 
1: 	//
1: 	// CompilerContext interface
1: 	//
1: 	// we might want these to refuse to return
1: 	// anything if they are in-use -- would require
1: 	// the interface provide a 'done' call, and
1: 	// we would mark them in-use whenever a get happened.
1: 	public Parser getParser() {
1: 		return parser;
1: 	}
1: 
1: 	/**
0: 	  *	Get the NodeFactory for this context
1: 	  *
0: 	  *	@return	The NodeFactory for this context.
1: 	  */
0: 	public	NodeFactory	getNodeFactory()
0: 	{	return lcf.getNodeFactory(); }
1: 
1: 
1: 	public int getNextColumnNumber()
1: 	{
1: 		return nextColumnNumber++;
1: 	}
1: 
1: 	public int getNextTableNumber()
1: 	{
1: 		return nextTableNumber++;
1: 	}
1: 
1: 	public int getNumTables()
1: 	{
1: 		return nextTableNumber;
1: 	}
1: 
1: 	/**
1: 	 * Get the current next subquery number from this CompilerContext.
1: 	 *
1: 	 * @return int	The next subquery number for the current statement.
1: 	 *
1: 	 */
1: 
1: 	public int getNextSubqueryNumber()
1: 	{
1: 		return nextSubqueryNumber++;
1: 	}
1: 
1: 	/**
1: 	 * Get the number of subquerys in the current statement from this CompilerContext.
1: 	 *
1: 	 * @return int	The number of subquerys in the current statement.
1: 	 *
1: 	 */
1: 
1: 	public int getNumSubquerys()
1: 	{
1: 		return nextSubqueryNumber;
1: 	}
1: 
1: 	public int getNextResultSetNumber()
1: 	{
1: 		return nextResultSetNumber++;
1: 	}
1: 
1: 	public void resetNextResultSetNumber()
1: 	{
1: 		nextResultSetNumber = 0;
1: 	}
1: 
1: 	public int getNumResultSets()
1: 	{
1: 		return nextResultSetNumber;
1: 	}
1: 
1: 	public String getUniqueClassName()
1: 	{
1: 		// REMIND: should get a new UUID if we roll over...
1: 		if (SanityManager.DEBUG)
1: 		{
1:     		SanityManager.ASSERT(nextClassName <= Long.MAX_VALUE);
1:     	}
1: 		return classPrefix.concat(Long.toHexString(nextClassName++));
1: 	}
1: 
1: 	/**
1: 	 * Get the next equivalence class for equijoin clauses.
1: 	 *
1: 	 * @return The next equivalence class for equijoin clauses.
1: 	 */
1: 	public int getNextEquivalenceClass()
1: 	{
1: 		return ++nextEquivalenceClass;
1: 	}
1: 
1: 	public ClassFactory getClassFactory()
1: 	{
1: 		return lcf.getClassFactory();
1: 	}
1: 
1: 	public JavaFactory getJavaFactory()
1: 	{
1: 		return lcf.getJavaFactory();
1: 	}
1: 
1: 
0: 	public Dependent getCurrentDependent() {
0: 		return currentDependent;
1: 	}
1: 
1: 	public void setCurrentDependent(Dependent d) {
1: 		currentDependent = d;
1: 	}
1: 
1: 	/**
1: 	 * Get the current auxiliary provider list from this CompilerContext.
1: 	 *
1: 	 * @return	The current AuxiliaryProviderList.
1: 	 *
1: 	 */
1: 
1: 	public ProviderList getCurrentAuxiliaryProviderList()
1: 	{
1: 		return currentAPL;
1: 	}
1: 
1: 	/**
1: 	 * Set the current auxiliary provider list for this CompilerContext.
1: 	 *
0: 	 * @param adl	The new current AuxiliaryProviderList.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 
1: 	public void setCurrentAuxiliaryProviderList(ProviderList apl)
1: 	{
1: 		currentAPL = apl;
1: 	}
1: 
1: 	public void createDependency(Provider p) throws StandardException {
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(getCurrentDependent() != null,
1: 				"no current dependent for compilation");
1: 
0: 		LanguageConnectionContext	lcc = (LanguageConnectionContext)
0: 			getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
0: 		dm.addDependency(getCurrentDependent(), p, getContextManager());
1: 		addProviderToAuxiliaryList(p);
1: 	}
1: 
1: 	/**
1: 	 * Add a dependency between two objects.
1: 	 *
1: 	 * @param d	The Dependent object.
1: 	 * @param p	The Provider of the dependency.
1: 	 * @exception StandardException thrown on failure.
1: 	 *
1: 	 */
1: 	public	void createDependency(Dependent d, Provider p) throws StandardException
1: 	{
0: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 			getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
1: 
1: 		dm.addDependency(d, p, getContextManager());
1: 		addProviderToAuxiliaryList(p);
1: 	}
1: 
1: 	/**
1: 	 * Add a Provider to the current AuxiliaryProviderList, if one exists.
1: 	 *
1: 	 * @param p		The Provider to add.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	private void addProviderToAuxiliaryList(Provider p)
1: 		throws StandardException
1: 	{
1: 		if (currentAPL != null)
1: 		{
1: 			currentAPL.addProvider(p);
1: 		}
1: 	}
1: 
1: 	public int addSavedObject(Object obj) {
0: 		if (savedObjects == null) savedObjects = new Vector();
1: 
0: 		savedObjects.addElement(obj);
1: 		return savedObjects.size()-1;
1: 	}
1: 
1: 	public Object[] getSavedObjects() {
1: 		if (savedObjects == null) return null;
1: 
0: 		Object[] retVal = new Object[savedObjects.size()];
0: 		savedObjects.copyInto(retVal);
1: 		savedObjects = null; // erase to start over
1: 		return retVal;
1: 	}
1: 
1: 	/** @see CompilerContext#setSavedObjects */
0: 	public void setSavedObjects(Object[] objs) 
1: 	{
0: 		if (objs == null)
1: 		{
1: 			return;
1: 		}
1: 
0: 		for (int i = 0; i < objs.length; i++)
1: 		{
0: 			addSavedObject(objs[i]);
1: 		}		
1: 	}
1: 
0: 	/** @see CompilerContext#setParams */
0: 	public void setParams(ParameterValueSet params)
1: 	{
0: 		this.params = params;
1: 	}
1: 
0: 	/** @see CompilerContext#getParams */
0: 	public ParameterValueSet getParams()
1: 	{
0: 		ParameterValueSet tmpParams = this.params;
0: 		this.params = null;
0: 		return tmpParams;
1: 	}
1: 
1: 	/** @see CompilerContext#setCursorInfo */
1: 	public void setCursorInfo(Object cursorInfo)
1: 	{
1: 		this.cursorInfo = cursorInfo;
1: 	}
1: 
1: 	/** @see CompilerContext#getCursorInfo */
1: 	public Object getCursorInfo()
1: 	{
1: 		return cursorInfo;
1: 	}
1: 
1: 	
1: 	/** @see CompilerContext#firstOnStack */
1: 	public void firstOnStack()
1: 	{
1: 		firstOnStack = true;
1: 	}
1: 
1: 	/** @see CompilerContext#isFirstOnStack */
1: 	public boolean isFirstOnStack()
1: 	{
1: 		return firstOnStack;
1: 	}
1: 
1: 	/**
1: 	 * Set the in use state for the compiler context.
1: 	 *
1: 	 * @param inUse	 The new inUse state for the compiler context.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 */
1: 	public void setInUse(boolean inUse)
1: 	{
1: 		this.inUse = inUse;
1: 
1: 		/*
1: 		** Close the StoreCostControllers associated with this CompilerContext
1: 		** when the context is no longer in use.
1: 		*/
1: 		if ( ! inUse)
1: 		{
1: 			closeStoreCostControllers();
1: 			closeSortCostControllers();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the in use state for the compiler context.
1: 	 *
1: 	 * @return boolean	The in use state for the compiler context.
1: 	 */
1: 	public boolean getInUse()
1: 	{
1: 		return inUse;
1: 	}
1: 
1: 	/**
1: 	 * Sets which kind of query fragments are NOT allowed. Basically,
1: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
1: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
1: 	 *
1: 	 * @param reliability	bitmask of types of query fragments to be forbidden
1: 	 *						see the reliability bitmasks in CompilerContext.java
1: 	 *
1: 	 */
1: 	public void	setReliability(int reliability) { this.reliability = reliability; }
1: 
1: 	/**
1: 	 * Return the reliability requirements of this clause. See setReliability()
1: 	 * for a definition of clause reliability.
1: 	 *
1: 	 * @return a bitmask of which types of query fragments are to be forbidden
1: 	 */
1: 	public int getReliability() { return reliability; }
1: 
1: 	/**
1: 	 * @see CompilerContext#getStoreCostController
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public StoreCostController getStoreCostController(long conglomerateNumber,
0: 													  LanguageConnectionContext lcc)
1: 			throws StandardException
1: 	{
1: 		/*
0: 		** Try to find the given conglomerate number in the array of
0: 		** conglom ids.
1: 		*/
0: 		for (int i = 0; i < storeCostConglomIds.size(); i++)
1: 		{
0: 			Long conglomId = (Long) storeCostConglomIds.elementAt(i);
0: 			if (conglomId.longValue() == conglomerateNumber)
0: 				return (StoreCostController) storeCostControllers.elementAt(i);
1: 		}
1: 
1: 		/*
0: 		** Not found, so get a StoreCostController from the store.
1: 		*/
0: 		StoreCostController retval =
0: 						lcc.getTransactionCompile().openStoreCost(conglomerateNumber);
1: 
0: 		/* Put it in the array */
0: 		storeCostControllers.insertElementAt(retval,
0: 											storeCostControllers.size());
1: 
0: 		/* Put the conglomerate number in its array */
0: 		storeCostConglomIds.insertElementAt(
0: 								new Long(conglomerateNumber),
0: 								storeCostConglomIds.size());
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 *
1: 	 */
1: 	private void closeStoreCostControllers()
1: 	{
0: 		for (int i = 0; i < storeCostControllers.size(); i++)
1: 		{
0: 			StoreCostController scc =
0: 				(StoreCostController) storeCostControllers.elementAt(i);
1: 			try {
1: 				scc.close();
1: 			} catch (StandardException se) {
1: 			}
1: 		}
1: 
0: 		storeCostControllers.removeAllElements();
0: 		storeCostConglomIds.removeAllElements();
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getSortCostController
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public SortCostController getSortCostController() throws StandardException
1: 	{
1: 		/*
1: 		** Re-use a single SortCostController for each compilation
1: 		*/
1: 		if (sortCostController == null)
1: 		{
1: 			/*
1: 			** Get a StoreCostController from the store.
1: 			*/
0: 			LanguageConnectionContext lcc;
1: 
0: 			/* Find the LanguageConnectionContext */
0: 			lcc = (LanguageConnectionContext)
0: 				getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
1: 
1: 			sortCostController =
0: 				lcc.getTransactionCompile().openSortCostController((Properties) null);
1: 		}
1: 
1: 		return sortCostController;
1: 	}
1: 
1: 	/**
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void closeSortCostControllers()
1: 	{
1: 		if (sortCostController != null)
1: 		{
1: 			sortCostController.close();
1: 			sortCostController = null;	
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the compilation schema descriptor for this compilation context.
1: 	   Will be null if no default schema lookups have occured. Ie.
1: 	   the statement is independent of the current schema.
1: 	 * 
1: 	 * @return the compilation schema descirptor
1: 	 */
1: 	public SchemaDescriptor getCompilationSchema()
1: 	{
1: 		return compilationSchema;
1: 	}
1: 
1: 	/**
1: 	 * Set the compilation schema descriptor for this compilation context.
1: 	 *
0: 	 * @param the compilation schema
1: 	 * 
1: 	 * @return the previous compilation schema descirptor
1: 	 */
1: 	public SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault)
1: 	{
1: 		SchemaDescriptor tmpSchema = compilationSchema;
1: 		compilationSchema = newDefault;
1: 		return tmpSchema;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#setParameterList
1: 	 */
0: 	public void setParameterList(Vector parameterList)
1: 	{
1: 		this.parameterList = parameterList;
1: 
1: 		/* Don't create param descriptors array if there are no params */
1: 		int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();
1: 
1: 		if (numberOfParameters > 0)
1: 		{
1: 			parameterDescriptors = new DataTypeDescriptor[numberOfParameters];
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getParameterList
1: 	 */
0: 	public Vector getParameterList()
1: 	{
1: 		return parameterList;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#setReturnParameterFlag
1: 	 */
1: 	public void setReturnParameterFlag()
1: 	{
1: 		returnParameterFlag = true;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getReturnParameterFlag
1: 	 */
1: 	public boolean getReturnParameterFlag()
1: 	{
1: 		return returnParameterFlag;
1: 	}
1: 
1: 	/**
0: 	 * @see CompilerContext#getParameterTypes
1: 	 */
0: 	public DataTypeDescriptor[] getParameterTypes()
1: 	{
1: 		return parameterDescriptors;
1: 	}
1: 
1: 	/**
0: 	 * @see CompilerContext#getNextParameterNumber
1: 	 */
0: 	public int getNextParameterNumber()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(parameterList != null,
0: 				"parameterList is expected to be non-null");
1: 		}
1: 		
0: 		// Parameter #s are 0-based
0: 		return parameterList.size();
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#setScanIsolationLevel
1: 	 */
1: 	public void setScanIsolationLevel(int isolationLevel)
1: 	{
1: 		scanIsolationLevel = isolationLevel;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getScanIsolationLevel
1: 	 */
1: 	public int getScanIsolationLevel()
1: 	{
1: 		return scanIsolationLevel;
1: 	}
1: 
1: 	/**
0: 	 * @see CompilerContext#setEntryIsolationLevel
1: 	 */
0: 	public void setEntryIsolationLevel(int isolationLevel)
1: 	{
0: 		this.entryIsolationLevel = isolationLevel;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getScanIsolationLevel
1: 	 */
0: 	public int getEntryIsolationLevel()
1: 	{
0: 		return entryIsolationLevel;
1: 	}
1: 
1: 	/**
1: 	 * @see CompilerContext#getTypeCompilerFactory
1: 	 */
1: 	public TypeCompilerFactory getTypeCompilerFactory()
1: 	{
1: 		return typeCompilerFactory;
1: 	}
1: 
1: 
1: 	/**
1: 		Add a compile time warning.
1: 	*/
1: 	public void addWarning(SQLWarning warning) {
1: 		if (warnings == null)
1: 			warnings = warning;
1: 		else
1: 			warnings.setNextWarning(warning);
1: 	}
1: 
1: 	/**
1: 		Get the chain of compile time warnings.
1: 	*/
1: 	public SQLWarning getWarnings() {
1: 		return warnings;
1: 	}
1: 
0: 	/////////////////////////////////////////////////////////////////////////////////////
1: 	//
0: 	// class interface
1: 	//
0: 	// this constructor is called with the parser
0: 	// to be saved when the context
0: 	// is created (when the first statement comes in, likely).
1: 	//
0: 	/////////////////////////////////////////////////////////////////////////////////////
1: 
0: 	public CompilerContextImpl(ContextManager cm, LanguageConnectionFactory lcf,
1: 		TypeCompilerFactory typeCompilerFactory )
1: 	{
1: 		super(cm, CompilerContext.CONTEXT_ID);
1: 
1: 		this.parser = lcf.newParser(this);
0: 		this.lcf = lcf;
1: 		this.typeCompilerFactory = typeCompilerFactory;
1: 
1: 		// the prefix for classes in this connection
1: 		classPrefix = "ac"+lcf.getUUIDFactory().createUUID().toString().replace('-','x');
1: 	}
1: 
1: 	/*
0: 	** Context state must be reset in restContext()
1: 	*/
1: 
1: 	private final Parser 		parser;
0: 	private LanguageConnectionFactory lcf;
1: 	private TypeCompilerFactory	typeCompilerFactory;
1: 	private Dependent			currentDependent;
0: 	private DependencyManager	dmgr;
1: 	private boolean				firstOnStack;
1: 	private boolean				inUse;
1: 	private int					reliability = CompilerContext.SQL_LEGAL;
1: 	private	int					nextColumnNumber = 1;
1: 	private int					nextTableNumber;
1: 	private int					nextSubqueryNumber;
1: 	private int					nextResultSetNumber;
0: 	private int					entryIsolationLevel;
1: 	private int					scanIsolationLevel;
1: 	private int					nextEquivalenceClass = -1;
1: 	private long				nextClassName;
0: 	private Vector				savedObjects;
1: 	private String				classPrefix;
0: 	private ParameterValueSet	params;
1: 	private SchemaDescriptor	compilationSchema;
1: 	private ProviderList		currentAPL;
1: 	private boolean returnParameterFlag;
1: 
0: 	private Vector				storeCostControllers = new Vector();
0: 	private Vector				storeCostConglomIds = new Vector();
1: 
1: 	private SortCostController	sortCostController;
1: 
0: 	private Vector parameterList;
1: 
1: 	/* Type descriptors for the ? parameters */
1: 	private DataTypeDescriptor[]	parameterDescriptors;
1: 
1: 	private Object				cursorInfo;
1: 
1: 	private SQLWarning warnings;
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28c633d
/////////////////////////////////////////////////////////////////////////
1: 	public void addRequiredSchemaPriv(String schemaName, String aid, int privType)
commit:797228c
/////////////////////////////////////////////////////////////////////////
1: 	 * @param column The column whose privileges we're interested in.
/////////////////////////////////////////////////////////////////////////
0: 		/*
1: 		* Note that to look up the privileges for this column,
1: 		* we need to know what table the column is in. However,
1: 		* not all ColumnDescriptor objects are associated with
1: 		* a table object. Sometimes a ColumnDescriptor
1: 		* describes a column but doesn't specify the table. An
1: 		* example of this occurs in the set-clause of the
1: 		* UPDATE statement in SQL, where we may have a
1: 		* ColumnDescriptor which describes the expression that
1: 		* is being used in the UPDATE statement to provide the
1: 		* new value that will be computed by the UPDATE. In such a
1: 		* case, there is no column privilege to be added, so we
1: 		* just take an early return. DERBY-1583 has more details.
1: 		*/
1: 		if (td == null)
1: 			return;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param apl	The new current AuxiliaryProviderList.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param newDefault	the compilation schema
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d50d4ab
/////////////////////////////////////////////////////////////////////////
1: 		// Ignore SYSFUN routines for permission scheme
1: 		if (routine.getSchemaUUID().toString().equals(SchemaDescriptor.SYSFUN_SCHEMA_UUID))
1: 			return;
0: 
commit:5ec8510
/////////////////////////////////////////////////////////////////////////
0: 		if( lcc.usesSqlAuthorization())
commit:e1987c6
/////////////////////////////////////////////////////////////////////////
1: 	 * @see CompilerContext#addRequiredRoutinePriv
/////////////////////////////////////////////////////////////////////////
1: 	 * @see CompilerContext#addRequiredRoutinePriv
/////////////////////////////////////////////////////////////////////////
1: 	 * @see CompilerContext#addRequiredSchemaPriv
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
0: 	public void addRequiredSchemaPriv(String schemaName, String aid, boolean privType)
1: 		if( requiredSchemaPrivileges == null || schemaName == null)
1: 		StatementSchemaPermission key = new 
1: 				StatementSchemaPermission(schemaName, aid, privType);
commit:70a12d9
/////////////////////////////////////////////////////////////////////////
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.StatementSchemaPermission;
/////////////////////////////////////////////////////////////////////////
1: 		requiredSchemaPrivileges = null;
/////////////////////////////////////////////////////////////////////////
0: 			requiredSchemaPrivileges = new HashMap();
/////////////////////////////////////////////////////////////////////////
1: 			requiredColumnPrivileges.put(key, tableColumnPrivileges);
1: 		tableColumnPrivileges.getColumns().set(column.getPosition() - 1);
/////////////////////////////////////////////////////////////////////////
1: 		requiredTablePrivileges.put(key, key);
/////////////////////////////////////////////////////////////////////////
0: 
0: 		/* GrantRevoke TODO: Implement routine privilege checks. Commented out for now.
1:  		if (requiredRoutinePrivileges.get(routine.getUUID()) == null)
0:  			requiredRoutinePrivileges.put(routine.getUUID(), ReuseFactory.getInteger(1));
0: 		*/
1: 	}
0: 
1: 	/**
1: 	 * Add a required schema privilege to the list privileges.
0: 	 *
0: 	 * @param SchemaDescriptor
0: 	 */
0: 	public void addRequiredSchemaPriv(SchemaDescriptor sd)
1: 	{
0: 		if( requiredSchemaPrivileges == null || sd == null)
1: 			return;
0: 
0: 		StatementSchemaPermission key = new StatementSchemaPermission(sd.getUUID());
0: 
1: 		requiredSchemaPrivileges.put(key, key);
/////////////////////////////////////////////////////////////////////////
1: 		if( requiredSchemaPrivileges != null)
0: 			size += requiredSchemaPrivileges.size();
/////////////////////////////////////////////////////////////////////////
1: 		if( requiredSchemaPrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredSchemaPrivileges.values().iterator(); itr.hasNext();)
1: 			{
1: 				list.add( itr.next());
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 	private HashMap requiredSchemaPrivileges;
commit:2c6ca76
/////////////////////////////////////////////////////////////////////////
0: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 		getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		if( lcc.usesSqlStandardPermissions())
0: 			requiredColumnPrivileges = new HashMap();
0: 			requiredTablePrivileges = new HashMap();
0: 			requiredRoutinePrivileges = new HashMap();
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.UUID;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.StatementTablePermission;
0: import org.apache.derby.iapi.sql.dictionary.StatementColumnPermission;
0: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import java.util.HashMap;
1: import java.util.Iterator;
0: import java.util.Map.Entry;
0: import java.util.BitSet;
1: import java.util.List;
0: import java.util.Stack;
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: 		initRequiredPriv();
/////////////////////////////////////////////////////////////////////////
0: 
1: 		initRequiredPriv();
1: 	private void initRequiredPriv()
1: 	{
1: 		currPrivType = Authorizer.NULL_PRIV;
1: 		privTypeStack.clear();
1: 		requiredColumnPrivileges = null;
1: 		requiredTablePrivileges = null;
1: 		requiredRoutinePrivileges = null;
0: 		try
1: 		{
0: 			LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 			getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 			if( lcc.getAuthorizer().usesSqlStandardPermissions())
1: 			{
0: 				requiredColumnPrivileges = new HashMap();
0: 				requiredTablePrivileges = new HashMap();
0: 				requiredRoutinePrivileges = new HashMap();
0: 			}
0: 		}
0: 		catch( StandardException se){}
1: 	} // end of initRequiredPriv
0: 
1: 	/**
1: 	 * Sets the current privilege type context. Column and table nodes do not know
1: 	 * how they are being used. Higher level nodes in the query tree do not know what
1: 	 * is being referenced.
1: 	 * Keeping the context allows the two to come together.
0: 	 *
1: 	 * @param privType One of the privilege types in org.apache.derby.iapi.sql.conn.Authorizer.
0: 	 */
1: 	public void pushCurrentPrivType( int privType)
1: 	{
0: 		privTypeStack.push( ReuseFactory.getInteger( currPrivType));
1: 		currPrivType = privType;
0: 	}
0: 
1: 	public void popCurrentPrivType( )
1: 	{
0: 		currPrivType = ((Integer) privTypeStack.pop()).intValue();
0: 	}
0: 	
1: 	/**
1: 	 * Add a column privilege to the list of used column privileges.
0: 	 *
0: 	 * @param column
0: 	 */
1: 	public void addRequiredColumnPriv( ColumnDescriptor column)
1: 	{
1: 		if( requiredColumnPrivileges == null // Using old style authorization
1: 			|| currPrivType == Authorizer.NULL_PRIV
1: 			|| currPrivType == Authorizer.DELETE_PRIV // Table privilege only
1: 			|| currPrivType == Authorizer.INSERT_PRIV // Table privilege only
1: 			|| currPrivType == Authorizer.TRIGGER_PRIV // Table privilege only
1: 			|| currPrivType == Authorizer.EXECUTE_PRIV
1: 			|| column == null)
1: 			return;
1: 		TableDescriptor td = column.getTableDescriptor();
1: 		UUID tableUUID = td.getUUID();
1: 		StatementTablePermission key = new StatementTablePermission( tableUUID, currPrivType);
0: 		StatementColumnPermission tableColumnPrivileges
0: 		  = (StatementColumnPermission) requiredColumnPrivileges.get( key);
1: 		if( tableColumnPrivileges == null)
1: 		{
1: 			tableColumnPrivileges = new StatementColumnPermission( tableUUID,
1: 																   currPrivType,
1: 																   new FormatableBitSet( td.getNumberOfColumns()));
0: 			requiredColumnPrivileges.put( key, tableColumnPrivileges);
0: 		}
0: 		tableColumnPrivileges.getColumns().set( column.getPosition() - 1);
1: 	} // end of addRequiredColumnPriv
0: 
1: 	/**
1: 	 * Add a table or view privilege to the list of used table privileges.
0: 	 *
0: 	 * @param table
0: 	 */
1: 	public void addRequiredTablePriv( TableDescriptor table)
1: 	{
1: 		if( requiredTablePrivileges == null || table == null)
1: 			return;
0: 
1: 		StatementTablePermission key = new StatementTablePermission( table.getUUID(), currPrivType);
0: 		requiredTablePrivileges.put( key, key);
0: 	}
0: 
1: 	/**
1: 	 * Add a routine execute privilege to the list of used routine privileges.
0: 	 *
0: 	 * @param routine
0: 	 */
1: 	public void addRequiredRoutinePriv( AliasDescriptor routine)
1: 	{
1: 		// routine == null for built in routines
1: 		if( requiredRoutinePrivileges == null || routine == null)
1: 			return;
0: 		if( requiredRoutinePrivileges.get( routine.getUUID()) == null)
0: 			requiredRoutinePrivileges.put( routine.getUUID(), ReuseFactory.getInteger(1));
0: 	}
0: 
1: 	/**
1: 	 * @return The list of required privileges.
0: 	 */
0: 	public List getRequiredPermissionsList()
1: 	{
1: 		int size = 0;
1: 		if( requiredRoutinePrivileges != null)
0: 			size += requiredRoutinePrivileges.size();
1: 		if( requiredTablePrivileges != null)
0: 			size += requiredTablePrivileges.size();
1: 		if( requiredColumnPrivileges != null)
0: 			size += requiredColumnPrivileges.size();
0: 		
0: 		ArrayList list = new ArrayList( size);
1: 		if( requiredRoutinePrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredRoutinePrivileges.keySet().iterator(); itr.hasNext();)
1: 			{
0: 				UUID routineUUID = (UUID) itr.next();
0: 				
1: 				list.add( new StatementRoutinePermission( routineUUID));
0: 			}
0: 		}
1: 		if( requiredTablePrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredTablePrivileges.values().iterator(); itr.hasNext();)
1: 			{
1: 				list.add( itr.next());
0: 			}
0: 		}
1: 		if( requiredColumnPrivileges != null)
1: 		{
0: 			for( Iterator itr = requiredColumnPrivileges.values().iterator(); itr.hasNext();)
1: 			{
1: 				list.add( itr.next());
0: 			}
0: 		}
1: 		return list;
1: 	} // end of getRequiredPermissionsList
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	private Stack privTypeStack = new Stack();
1: 	private int currPrivType = Authorizer.NULL_PRIV;
0: 	private HashMap requiredColumnPrivileges;
0: 	private HashMap requiredTablePrivileges;
0: 	private HashMap requiredRoutinePrivileges;
1: } // end of class CompilerContextImpl
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: 
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.SortCostController;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextImpl;
0: 
0: import java.sql.SQLWarning;
0: import java.util.Vector;
0: import java.util.Properties;
0: 
0: /*
0:  *
0:  * CompilerContextImpl
0:  *
0:  */
0: public class CompilerContextImpl extends ContextImpl
0: 	implements CompilerContext { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	//
0: 	// Context interface       
0: 	//
0: 
0: 	/**
0: 		@exception StandardException thrown by makeInvalid() call
0: 	 */
0: 	public void cleanupOnError(Throwable error) throws StandardException {
0: 
0: 		setInUse(false);
0: 		resetContext();
0: 
0: 		if (error instanceof StandardException) {
0: 
0: 			StandardException se = (StandardException) error;
0: 			// if something went wrong with the compile,
0: 			// we need to mark the statement invalid.
0: 			// REVISIT: do we want instead to remove it,
0: 			// so the cache doesn't get full of garbage input
0: 			// that won't even parse?
0: 
0: 			if (se.getSeverity() < ExceptionSeverity.SYSTEM_SEVERITY) 
0: 			{
0: 				if (currentDependent != null)
0: 				{
0: 					LanguageConnectionContext lcc;
0: 
0: 					/* Find the LanguageConnectionContext */
0: 					lcc = (LanguageConnectionContext)
0: 						getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 					currentDependent.makeInvalid(DependencyManager.COMPILE_FAILED,
0: 												 lcc);
0: 				}
0: 				closeStoreCostControllers();
0: 				closeSortCostControllers();
0: 			}
0: 			// anything system or worse, or non-DB errors,
0: 			// will cause the whole system to shut down.
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	  *	Reset compiler context (as for instance, when we recycle a context for
0: 	  *	use by another compilation.
0: 	  */
0: 	public	void	resetContext()
0: 	{
0: 		nextColumnNumber = 1;
0: 		nextTableNumber = 0;
0: 		nextSubqueryNumber = 0;
0: 		resetNextResultSetNumber();
0: 		nextEquivalenceClass = -1;
0: 		compilationSchema = null;
0: 		parameterList = null;
0: 		parameterDescriptors = null;
0: 		scanIsolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
0: 		warnings = null;
0: 		savedObjects = null;
0: 		reliability = CompilerContext.SQL_LEGAL;
0: 		returnParameterFlag = false;
0: 	}
0: 
0: 	//
0: 	// CompilerContext interface
0: 	//
0: 	// we might want these to refuse to return
0: 	// anything if they are in-use -- would require
0: 	// the interface provide a 'done' call, and
0: 	// we would mark them in-use whenever a get happened.
0: 	public Parser getParser() {
0: 		return parser;
0: 	}
0: 
0: 	/**
0: 	  *	Get the NodeFactory for this context
0: 	  *
0: 	  *	@return	The NodeFactory for this context.
0: 	  */
0: 	public	NodeFactory	getNodeFactory()
0: 	{	return lcf.getNodeFactory(); }
0: 
0: 
0: 	public int getNextColumnNumber()
0: 	{
0: 		return nextColumnNumber++;
0: 	}
0: 
0: 	public int getNextTableNumber()
0: 	{
0: 		return nextTableNumber++;
0: 	}
0: 
0: 	public int getNumTables()
0: 	{
0: 		return nextTableNumber;
0: 	}
0: 
0: 	/**
0: 	 * Get the current next subquery number from this CompilerContext.
0: 	 *
0: 	 * @return int	The next subquery number for the current statement.
0: 	 *
0: 	 */
0: 
0: 	public int getNextSubqueryNumber()
0: 	{
0: 		return nextSubqueryNumber++;
0: 	}
0: 
0: 	/**
0: 	 * Get the number of subquerys in the current statement from this CompilerContext.
0: 	 *
0: 	 * @return int	The number of subquerys in the current statement.
0: 	 *
0: 	 */
0: 
0: 	public int getNumSubquerys()
0: 	{
0: 		return nextSubqueryNumber;
0: 	}
0: 
0: 	public int getNextResultSetNumber()
0: 	{
0: 		return nextResultSetNumber++;
0: 	}
0: 
0: 	public void resetNextResultSetNumber()
0: 	{
0: 		nextResultSetNumber = 0;
0: 	}
0: 
0: 	public int getNumResultSets()
0: 	{
0: 		return nextResultSetNumber;
0: 	}
0: 
0: 	public String getUniqueClassName()
0: 	{
0: 		// REMIND: should get a new UUID if we roll over...
0: 		if (SanityManager.DEBUG)
0: 		{
0:     		SanityManager.ASSERT(nextClassName <= Long.MAX_VALUE);
0:     	}
0: 		return classPrefix.concat(Long.toHexString(nextClassName++));
0: 	}
0: 
0: 	/**
0: 	 * Get the next equivalence class for equijoin clauses.
0: 	 *
0: 	 * @return The next equivalence class for equijoin clauses.
0: 	 */
0: 	public int getNextEquivalenceClass()
0: 	{
0: 		return ++nextEquivalenceClass;
0: 	}
0: 
0: 	public ClassFactory getClassFactory()
0: 	{
0: 		return lcf.getClassFactory();
0: 	}
0: 
0: 	public JavaFactory getJavaFactory()
0: 	{
0: 		return lcf.getJavaFactory();
0: 	}
0: 
0: 
0: 	public Dependent getCurrentDependent() {
0: 		return currentDependent;
0: 	}
0: 
0: 	public void setCurrentDependent(Dependent d) {
0: 		currentDependent = d;
0: 	}
0: 
0: 	/**
0: 	 * Get the current auxiliary provider list from this CompilerContext.
0: 	 *
0: 	 * @return	The current AuxiliaryProviderList.
0: 	 *
0: 	 */
0: 
0: 	public ProviderList getCurrentAuxiliaryProviderList()
0: 	{
0: 		return currentAPL;
0: 	}
0: 
0: 	/**
0: 	 * Set the current auxiliary provider list for this CompilerContext.
0: 	 *
0: 	 * @param adl	The new current AuxiliaryProviderList.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 
0: 	public void setCurrentAuxiliaryProviderList(ProviderList apl)
0: 	{
0: 		currentAPL = apl;
0: 	}
0: 
0: 	public void createDependency(Provider p) throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(getCurrentDependent() != null,
0: 				"no current dependent for compilation");
0: 
0: 		LanguageConnectionContext	lcc = (LanguageConnectionContext)
0: 			getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
0: 		dm.addDependency(getCurrentDependent(), p, getContextManager());
0: 		addProviderToAuxiliaryList(p);
0: 	}
0: 
0: 	/**
0: 	 * Add a dependency between two objects.
0: 	 *
0: 	 * @param d	The Dependent object.
0: 	 * @param p	The Provider of the dependency.
0: 	 * @exception StandardException thrown on failure.
0: 	 *
0: 	 */
0: 	public	void createDependency(Dependent d, Provider p) throws StandardException
0: 	{
0: 		LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 			getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
0: 
0: 		dm.addDependency(d, p, getContextManager());
0: 		addProviderToAuxiliaryList(p);
0: 	}
0: 
0: 	/**
0: 	 * Add a Provider to the current AuxiliaryProviderList, if one exists.
0: 	 *
0: 	 * @param p		The Provider to add.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	private void addProviderToAuxiliaryList(Provider p)
0: 		throws StandardException
0: 	{
0: 		if (currentAPL != null)
0: 		{
0: 			currentAPL.addProvider(p);
0: 		}
0: 	}
0: 
0: 	public int addSavedObject(Object obj) {
0: 		if (savedObjects == null) savedObjects = new Vector();
0: 
0: 		savedObjects.addElement(obj);
0: 		return savedObjects.size()-1;
0: 	}
0: 
0: 	public Object[] getSavedObjects() {
0: 		if (savedObjects == null) return null;
0: 
0: 		Object[] retVal = new Object[savedObjects.size()];
0: 		savedObjects.copyInto(retVal);
0: 		savedObjects = null; // erase to start over
0: 		return retVal;
0: 	}
0: 
0: 	/** @see CompilerContext#setSavedObjects */
0: 	public void setSavedObjects(Object[] objs) 
0: 	{
0: 		if (objs == null)
0: 		{
0: 			return;
0: 		}
0: 
0: 		for (int i = 0; i < objs.length; i++)
0: 		{
0: 			addSavedObject(objs[i]);
0: 		}		
0: 	}
0: 
0: 	/** @see CompilerContext#setParams */
0: 	public void setParams(ParameterValueSet params)
0: 	{
0: 		this.params = params;
0: 	}
0: 
0: 	/** @see CompilerContext#getParams */
0: 	public ParameterValueSet getParams()
0: 	{
0: 		ParameterValueSet tmpParams = this.params;
0: 		this.params = null;
0: 		return tmpParams;
0: 	}
0: 
0: 	/** @see CompilerContext#setCursorInfo */
0: 	public void setCursorInfo(Object cursorInfo)
0: 	{
0: 		this.cursorInfo = cursorInfo;
0: 	}
0: 
0: 	/** @see CompilerContext#getCursorInfo */
0: 	public Object getCursorInfo()
0: 	{
0: 		return cursorInfo;
0: 	}
0: 
0: 	
0: 	/** @see CompilerContext#firstOnStack */
0: 	public void firstOnStack()
0: 	{
0: 		firstOnStack = true;
0: 	}
0: 
0: 	/** @see CompilerContext#isFirstOnStack */
0: 	public boolean isFirstOnStack()
0: 	{
0: 		return firstOnStack;
0: 	}
0: 
0: 	/**
0: 	 * Set the in use state for the compiler context.
0: 	 *
0: 	 * @param inUse	 The new inUse state for the compiler context.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 */
0: 	public void setInUse(boolean inUse)
0: 	{
0: 		this.inUse = inUse;
0: 
0: 		/*
0: 		** Close the StoreCostControllers associated with this CompilerContext
0: 		** when the context is no longer in use.
0: 		*/
0: 		if ( ! inUse)
0: 		{
0: 			closeStoreCostControllers();
0: 			closeSortCostControllers();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the in use state for the compiler context.
0: 	 *
0: 	 * @return boolean	The in use state for the compiler context.
0: 	 */
0: 	public boolean getInUse()
0: 	{
0: 		return inUse;
0: 	}
0: 
0: 	/**
0: 	 * Sets which kind of query fragments are NOT allowed. Basically,
0: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
0: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
0: 	 *
0: 	 * @param reliability	bitmask of types of query fragments to be forbidden
0: 	 *						see the reliability bitmasks in CompilerContext.java
0: 	 *
0: 	 */
0: 	public void	setReliability(int reliability) { this.reliability = reliability; }
0: 
0: 	/**
0: 	 * Return the reliability requirements of this clause. See setReliability()
0: 	 * for a definition of clause reliability.
0: 	 *
0: 	 * @return a bitmask of which types of query fragments are to be forbidden
0: 	 */
0: 	public int getReliability() { return reliability; }
0: 
0: 	/**
0: 	 * @see CompilerContext#getStoreCostController
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public StoreCostController getStoreCostController(long conglomerateNumber,
0: 													  LanguageConnectionContext lcc)
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** Try to find the given conglomerate number in the array of
0: 		** conglom ids.
0: 		*/
0: 		for (int i = 0; i < storeCostConglomIds.size(); i++)
0: 		{
0: 			Long conglomId = (Long) storeCostConglomIds.elementAt(i);
0: 			if (conglomId.longValue() == conglomerateNumber)
0: 				return (StoreCostController) storeCostControllers.elementAt(i);
0: 		}
0: 
0: 		/*
0: 		** Not found, so get a StoreCostController from the store.
0: 		*/
0: 		StoreCostController retval =
0: 						lcc.getTransactionCompile().openStoreCost(conglomerateNumber);
0: 
0: 		/* Put it in the array */
0: 		storeCostControllers.insertElementAt(retval,
0: 											storeCostControllers.size());
0: 
0: 		/* Put the conglomerate number in its array */
0: 		storeCostConglomIds.insertElementAt(
0: 								new Long(conglomerateNumber),
0: 								storeCostConglomIds.size());
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 */
0: 	private void closeStoreCostControllers()
0: 	{
0: 		for (int i = 0; i < storeCostControllers.size(); i++)
0: 		{
0: 			StoreCostController scc =
0: 				(StoreCostController) storeCostControllers.elementAt(i);
0: 			try {
0: 				scc.close();
0: 			} catch (StandardException se) {
0: 			}
0: 		}
0: 
0: 		storeCostControllers.removeAllElements();
0: 		storeCostConglomIds.removeAllElements();
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getSortCostController
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public SortCostController getSortCostController() throws StandardException
0: 	{
0: 		/*
0: 		** Re-use a single SortCostController for each compilation
0: 		*/
0: 		if (sortCostController == null)
0: 		{
0: 			/*
0: 			** Get a StoreCostController from the store.
0: 			*/
0: 			LanguageConnectionContext lcc;
0: 
0: 			/* Find the LanguageConnectionContext */
0: 			lcc = (LanguageConnectionContext)
0: 				getContextManager().getContext(LanguageConnectionContext.CONTEXT_ID);
0: 
0: 			sortCostController =
0: 				lcc.getTransactionCompile().openSortCostController((Properties) null);
0: 		}
0: 
0: 		return sortCostController;
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void closeSortCostControllers()
0: 	{
0: 		if (sortCostController != null)
0: 		{
0: 			sortCostController.close();
0: 			sortCostController = null;	
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the compilation schema descriptor for this compilation context.
0: 	   Will be null if no default schema lookups have occured. Ie.
0: 	   the statement is independent of the current schema.
0: 	 * 
0: 	 * @return the compilation schema descirptor
0: 	 */
0: 	public SchemaDescriptor getCompilationSchema()
0: 	{
0: 		return compilationSchema;
0: 	}
0: 
0: 	/**
0: 	 * Set the compilation schema descriptor for this compilation context.
0: 	 *
0: 	 * @param the compilation schema
0: 	 * 
0: 	 * @return the previous compilation schema descirptor
0: 	 */
0: 	public SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault)
0: 	{
0: 		SchemaDescriptor tmpSchema = compilationSchema;
0: 		compilationSchema = newDefault;
0: 		return tmpSchema;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#setParameterList
0: 	 */
0: 	public void setParameterList(Vector parameterList)
0: 	{
0: 		this.parameterList = parameterList;
0: 
0: 		/* Don't create param descriptors array if there are no params */
0: 		int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();
0: 
0: 		if (numberOfParameters > 0)
0: 		{
0: 			parameterDescriptors = new DataTypeDescriptor[numberOfParameters];
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getParameterList
0: 	 */
0: 	public Vector getParameterList()
0: 	{
0: 		return parameterList;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#setReturnParameterFlag
0: 	 */
0: 	public void setReturnParameterFlag()
0: 	{
0: 		returnParameterFlag = true;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getReturnParameterFlag
0: 	 */
0: 	public boolean getReturnParameterFlag()
0: 	{
0: 		return returnParameterFlag;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getParameterTypes
0: 	 */
0: 	public DataTypeDescriptor[] getParameterTypes()
0: 	{
0: 		return parameterDescriptors;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getNextParameterNumber
0: 	 */
0: 	public int getNextParameterNumber()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(parameterList != null,
0: 				"parameterList is expected to be non-null");
0: 		}
0: 		
0: 		// Parameter #s are 0-based
0: 		return parameterList.size();
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#setScanIsolationLevel
0: 	 */
0: 	public void setScanIsolationLevel(int isolationLevel)
0: 	{
0: 		scanIsolationLevel = isolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getScanIsolationLevel
0: 	 */
0: 	public int getScanIsolationLevel()
0: 	{
0: 		return scanIsolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#setEntryIsolationLevel
0: 	 */
0: 	public void setEntryIsolationLevel(int isolationLevel)
0: 	{
0: 		this.entryIsolationLevel = isolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getScanIsolationLevel
0: 	 */
0: 	public int getEntryIsolationLevel()
0: 	{
0: 		return entryIsolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see CompilerContext#getTypeCompilerFactory
0: 	 */
0: 	public TypeCompilerFactory getTypeCompilerFactory()
0: 	{
0: 		return typeCompilerFactory;
0: 	}
0: 
0: 
0: 	/**
0: 		Add a compile time warning.
0: 	*/
0: 	public void addWarning(SQLWarning warning) {
0: 		if (warnings == null)
0: 			warnings = warning;
0: 		else
0: 			warnings.setNextWarning(warning);
0: 	}
0: 
0: 	/**
0: 		Get the chain of compile time warnings.
0: 	*/
0: 	public SQLWarning getWarnings() {
0: 		return warnings;
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// class interface
0: 	//
0: 	// this constructor is called with the parser
0: 	// to be saved when the context
0: 	// is created (when the first statement comes in, likely).
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 
0: 	public CompilerContextImpl(ContextManager cm, LanguageConnectionFactory lcf,
0: 		TypeCompilerFactory typeCompilerFactory )
0: 	{
0: 		super(cm, CompilerContext.CONTEXT_ID);
0: 
0: 		this.parser = lcf.newParser(this);
0: 		this.lcf = lcf;
0: 		this.typeCompilerFactory = typeCompilerFactory;
0: 
0: 		// the prefix for classes in this connection
0: 		classPrefix = "ac"+lcf.getUUIDFactory().createUUID().toString().replace('-','x');
0: 	}
0: 
0: 	/*
0: 	** Context state must be reset in restContext()
0: 	*/
0: 
0: 	private final Parser 		parser;
0: 	private LanguageConnectionFactory lcf;
0: 	private TypeCompilerFactory	typeCompilerFactory;
0: 	private Dependent			currentDependent;
0: 	private DependencyManager	dmgr;
0: 	private boolean				firstOnStack;
0: 	private boolean				inUse;
0: 	private int					reliability = CompilerContext.SQL_LEGAL;
0: 	private	int					nextColumnNumber = 1;
0: 	private int					nextTableNumber;
0: 	private int					nextSubqueryNumber;
0: 	private int					nextResultSetNumber;
0: 	private int					entryIsolationLevel;
0: 	private int					scanIsolationLevel;
0: 	private int					nextEquivalenceClass = -1;
0: 	private long				nextClassName;
0: 	private Vector				savedObjects;
0: 	private String				classPrefix;
0: 	private ParameterValueSet	params;
0: 	private SchemaDescriptor	compilationSchema;
0: 	private ProviderList		currentAPL;
0: 	private boolean returnParameterFlag;
0: 
0: 	private Vector				storeCostControllers = new Vector();
0: 	private Vector				storeCostConglomIds = new Vector();
0: 
0: 	private SortCostController	sortCostController;
0: 
0: 	private Vector parameterList;
0: 
0: 	/* Type descriptors for the ? parameters */
0: 	private DataTypeDescriptor[]	parameterDescriptors;
0: 
0: 	private Object				cursorInfo;
0: 
0: 	private SQLWarning warnings;
0: }
============================================================================