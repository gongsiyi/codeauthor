1:9a9b932: /*
35:9a9b932: 
1:9a9b932:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.GeneratedColumnsHelper
1:9a9b932: 
1:9a9b932:    Licensed to the Apache Software Foundation (ASF) under one or more
1:9a9b932:    contributor license agreements.  See the NOTICE file distributed with
1:9a9b932:    this work for additional information regarding copyright ownership.
1:9a9b932:    The ASF licenses this file to you under the Apache License, Version 2.0
1:9a9b932:    (the "License"); you may not use this file except in compliance with
1:9a9b932:    the License.  You may obtain a copy of the License at
1:9a9b932: 
1:9a9b932:      http://www.apache.org/licenses/LICENSE-2.0
1:9a9b932: 
1:9a9b932:    Unless required by applicable law or agreed to in writing, software
1:9a9b932:    distributed under the License is distributed on an "AS IS" BASIS,
1:9a9b932:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9a9b932:    See the License for the specific language governing permissions and
1:9a9b932:    limitations under the License.
1:9a9b932: 
10:9a9b932:  */
1:9a9b932: 
1:9a9b932: package org.apache.derbyTesting.functionTests.tests.lang;
1:9a9b932: 
1:9a9b932: import java.sql.SQLException;
1:9a9b932: import java.sql.SQLWarning;
1:33bfdc0: import java.sql.CallableStatement;
1:9a9b932: import java.sql.Connection;
1:9a9b932: import java.sql.Statement;
1:9a9b932: import java.sql.PreparedStatement;
1:9a9b932: import java.sql.ResultSet;
1:9a9b932: import java.util.ArrayList;
1:3f5c48a: import java.util.Arrays;
1:9a9b932: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:9a9b932: 
1:9a9b932: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:9a9b932: 
10:9a9b932: /**
1:9a9b932:  * <p>
1:9a9b932:  * Helper routines for testing generated columns. See DERBY-481.
1:9a9b932:  * </p>
1:45c6691:  */
1:9a9b932: public class GeneratedColumnsHelper extends BaseJDBCTestCase
1:45c6691: {
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932:     //
1:9a9b932:     // CONSTANTS
1:9a9b932:     //
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:98c7520: 
1:661c2e6:     protected static final    String NOT_IMPLEMENTED = "0A000";
1:139ca85:     protected static final    String OBJECT_DOES_NOT_EXIST = "42X94";
1:139ca85:     protected static final    String NONEXISTENT_OBJECT = "42Y55";
1:9a9b932:     protected static  final   String  REDUNDANT_CLAUSE = "42613";
1:b8b524c:     protected static  final   String  CANT_CONTAIN_NULLS = "42831";
1:9a9b932:     protected static  final   String  ILLEGAL_AGGREGATE = "42XA1";
1:9a9b932:     protected static  final   String  UNSTABLE_RESULTS = "42XA2";
1:9a9b932:     protected static  final   String  CANT_OVERRIDE_GENERATION_CLAUSE = "42XA3";
1:9a9b932:     protected static  final   String  CANT_REFERENCE_GENERATED_COLUMN = "42XA4";
1:9a9b932:     protected static  final   String  ROUTINE_CANT_ISSUE_SQL = "42XA5";
1:9a9b932:     protected static  final   String  BAD_FOREIGN_KEY_ACTION = "42XA6";
1:9a9b932:     protected static  final   String  ILLEGAL_ADD_DEFAULT = "42XA7";
1:9a9b932:     protected static  final   String  ILLEGAL_RENAME = "42XA8";
1:fce10ba:     protected static  final   String  NEED_EXPLICIT_DATATYPE = "42XA9";
1:e735448:     protected static  final   String  BAD_BEFORE_TRIGGER = "42XAA";
1:b8b524c:     protected static  final   String  NOT_NULL_NEEDS_DATATYPE = "42XAB";
1:45c6691:     
1:9a9b932:     protected static  final   String  NOT_NULL_VIOLATION = "23502";
1:9a9b932:     protected static  final   String  CONSTRAINT_VIOLATION = "23513";
1:9a9b932:     protected static  final   String  FOREIGN_KEY_VIOLATION = "23503";
1:9a9b932:     protected static  final   String  ILLEGAL_DUPLICATE = "23505";
1:9a9b932:     protected static  final   String  SYNTAX_ERROR = "42X01";
1:a56ecfa:     protected static  final   String  LEXICAL_ERROR = "42X02";
1:9a9b932:     protected static  final   String  COLUMN_OUT_OF_SCOPE = "42X04";
1:9a9b932:     protected static  final   String  OPERATION_FORBIDDEN = "X0Y25";
1:9a9b932: 
1:9a9b932:     protected static  final   String  LACK_TABLE_PRIV = "42500";
1:9a9b932:     protected static  final   String  LACK_COLUMN_PRIV = "42502";
1:9a9b932:     protected static  final   String  LACK_EXECUTE_PRIV = "42504";
1:98c7520:     protected static  final   String  LACK_USAGE_PRIV = "42504";
1:97a8b1c:     protected static  final   String  CANT_MODIFY_IDENTITY = "42Z23";
1:9a9b932:     
1:9a9b932:     protected static  final   String  CASCADED_COLUMN_DROP_WARNING = "01009";
1:9a9b932:     protected static  final   String  CONSTRAINT_DROPPED_WARNING = "01500";
1:9a9b932:     protected static  final   String  TRIGGER_DROPPED_WARNING = "01502";
1:c341dc4:     protected static  final   String  LANG_INVALID_USE_OF_DEFAULT = "42Y85";
1:98c7520:     protected static  final   String  GRANT_REVOKE_NOT_ALLOWED = "42509";
1:8e352d6:     protected static  final   String  MISSING_OBJECT = "X0X81";
1:98c7520:     protected static  final   String  ROUTINE_DEPENDS_ON_TYPE = "X0Y30";
1:98c7520:     protected static  final   String  TABLE_DEPENDS_ON_TYPE = "X0Y29";
1:2f4a1a0:     protected static  final   String  VIEW_DEPENDENCY = "X0Y23";
1:90f42b4:     protected static  final   String  NON_EMPTY_SCHEMA = "X0Y54";
1:e5114fd:     protected static  final   String  JAVA_EXCEPTION = "XJ001";
1:f2a5622:     protected static  final   String  ILLEGAL_UDT_CLASS = "42Z10";
1:f2a5622:     protected static  final   String  FORBIDDEN_ORDERING_OPERATION = "X0X67";
1:f2a5622:     protected static  final   String  ILLEGAL_AGG = "42Y22";
1:f2a5622:     protected static  final   String  ILLEGAL_COMPARISON = "42818";
1:30fa79b:     protected static  final   String  ILLEGAL_STORAGE = "42821";
1:30fa79b:     protected static  final   String  BAD_CAST = "42846";
1:3b77ab8:     protected static  final   String  DUPLICATE_CLAUSE = "42XAJ";
1:2f4a1a0:     protected static  final   String  FORBIDDEN_DROP_TRIGGER = "X0Y24";
1:8e352d6:     protected static  final   String  LOCK_TIMEOUT = "40XL1";
1:8e352d6:     protected static  final   String  TOO_MUCH_CONTENTION = "X0Y84";
1:eff9169:     protected static  final   String  STRING_TRUNCATION = "22001";
1:9a9b932: 
1:daffaee:     protected   static  final   String  NO_GENERIC_PERMISSION = "42504";
1:daffaee:     protected   static  final   String  NO_SELECT_OR_UPDATE_PERMISSION = "42502";
1:daffaee:     protected   static  final   String  NO_TABLE_PERMISSION = "42500";
1:daffaee: 
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932:     //
1:9a9b932:     // STATE
1:9a9b932:     //
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932: 
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932:     //
1:9a9b932:     // CONSTRUCTOR
1:9a9b932:     //
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932: 
1:9a9b932: 
1:9a9b932:     /**
1:9a9b932:      * Create a new instance.
1:9a9b932:      */
1:9a9b932: 
1:9a9b932:     public GeneratedColumnsHelper(String name)
1:45c6691:     {
1:9a9b932:         super(name);
1:45c6691:     }
1:33bfdc0: 
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:9a9b932:     //
1:9a9b932:     // HELPER METHODS
1:9a9b932:     //
1:9a9b932:     ///////////////////////////////////////////////////////////////////////////////////
1:33bfdc0: 
1:33bfdc0:     /**
1:45c6691:      * Assert that the in-place update raises the expected error.
1:33bfdc0:      */
1:45c6691:     protected void    expectUpdateRowError( ResultSet rs, String sqlState )
1:45c6691:         throws Exception
1:33bfdc0:     {
1:45c6691:         println( "\nExpecting " + sqlState + " when updating row" );
1:98c7520: 
1:98c7520:         try {
1:45c6691:             rs.updateRow();
1:45c6691:             fail( "Expected error: " + sqlState );
1:33bfdc0:         }
1:45c6691:         catch (SQLException se)
1:98c7520:         {
1:98c7520:             assertSQLState( sqlState, se );
1:98c7520:         }
1:98c7520:     }
1:98c7520: 
1:98c7520:     /**
1:45c6691:      * Assert that the in-place insert raises the expected error.
1:98c7520:      */
1:45c6691:     protected void    expectInsertRowError( ResultSet rs, String sqlState )
1:45c6691:         throws Exception
1:98c7520:     {
1:45c6691:         println( "\nExpecting " + sqlState + " when inserting row" );
1:98c7520: 
2:45c6691:         try {
1:45c6691:             rs.insertRow();
1:45c6691:             fail( "Expected error: " + sqlState );
1:45c6691:         }
1:45c6691:         catch (SQLException se)
1:45c6691:         {
2:45c6691:             assertSQLState( sqlState, se );
1:45c6691:         }
1:45c6691:     }
1:98c7520: 
1:45c6691:     /**
1:9a9b932:      * Assert that the statement text, when executed, raises a warning.
1:45c6691:      */
1:9a9b932:     protected void    expectExecutionWarning( Connection conn, String sqlState, String query )
4:9a9b932:         throws Exception
1:45c6691:     {
1:9a9b932:         expectExecutionWarnings( conn, new String[] { sqlState }, query );
1:45c6691:     }
1:45c6691: 
1:45c6691:     /**
1:508a010:      * Assert that the statement text, when executed, raises no warnings.
1:508a010:      */
1:508a010:     protected void    expectNoWarning( Connection conn, String query )
1:508a010:         throws Exception
1:508a010:     {
1:508a010:         expectExecutionWarnings( conn, new String[] { }, query );
1:508a010:     }
1:508a010: 
1:508a010:     /**
1:9a9b932:      * Assert that the statement text, when executed, raises a warning.
1:9a9b932:      */
1:9a9b932:     protected void    expectExecutionWarnings( Connection conn, String[] sqlStates, String query )
1:9a9b932:         throws Exception
1:fce10ba:     {
1:9a9b932:         println( "\nExpecting warnings " + fill( sqlStates ).toString() + " when executing:\n\t"  );
3:9a9b932:         PreparedStatement   ps = chattyPrepare( conn, query );
1:45c6691: 
2:9a9b932:         ps.execute();
1:45c6691: 
1:9a9b932:         int idx = 0;
1:9a9b932: 
1:9a9b932:         for ( SQLWarning sqlWarning = ps.getWarnings(); sqlWarning != null; sqlWarning = sqlWarning.getNextWarning() )
14:9a9b932:         {
1:9a9b932:             String          actualSQLState = sqlWarning.getSQLState();
1:9a9b932: 
1:9a9b932:             if ( idx >= sqlStates.length )
1:9a9b932:             {
1:9a9b932:                 fail( "Got more warnings than we expected." );
1:45c6691:             }
1:9a9b932: 
1:9a9b932:             String  expectedSqlState = sqlStates[ idx++ ];
1:9a9b932: 
1:9a9b932:             assertEquals( expectedSqlState, actualSQLState );
14:9a9b932:         }
1:9a9b932: 
1:9a9b932:         assertEquals( idx, sqlStates.length );
1:9a9b932: 
1:15b837e:         ps.close();
1:508a010:     }
1:508a010: 
1:508a010:     /**
1:9a9b932:      * <p>
1:9a9b932:      * Assert whether a routine is expected to be DETERMINISTIC.
1:9a9b932:      * </p>
1:508a010:      */
1:9a9b932:     public  void    assertDeterministic( Connection conn, String routineName, boolean isDeterministic )
1:9a9b932:         throws Exception
1:508a010:     {
1:9a9b932:         PreparedStatement   ps = conn.prepareStatement
1:9a9b932:             (
1:9a9b932:              "select a.aliasinfo\n" +
1:9a9b932:              "from sys.sysaliases a\n" +
1:9a9b932:              "where alias =  ?"
1:9a9b932:              );
1:9a9b932:         ps.setString( 1, routineName );
1:9a9b932:         ResultSet               rs = ps.executeQuery();
1:508a010: 
1:9a9b932:         rs.next();
1:9a9b932:         RoutineAliasInfo    rai = (RoutineAliasInfo) rs.getObject( 1 );
1:508a010: 
1:9a9b932:         assertEquals( isDeterministic, rai.isDeterministic() );
1:45c6691: 
2:9a9b932:         rs.close();
1:508a010:         ps.close();
1:45c6691:     }
1:45c6691: 
1:9a9b932:     /**
1:fce10ba:      * Assert that a table has the correct column types.
1:fce10ba:      */
1:fce10ba:     protected void assertColumnTypes( Connection conn, String tableName, String[][] columnTypes )
1:fce10ba:         throws Exception
1:45c6691:     {
1:fce10ba:         PreparedStatement   ps = chattyPrepare
1:fce10ba:             (
1:fce10ba:              conn,
1:fce10ba:              "select c.columnname, c.columndatatype\n" +
1:fce10ba:              "from sys.syscolumns c, sys.systables t\n" +
1:fce10ba:              "where t.tablename = ?\n" +
1:fce10ba:              "and t.tableid = c.referenceid\n" +
1:fce10ba:              "order by c.columnname\n"
1:fce10ba:              );
1:fce10ba:         ps.setString( 1, tableName );
1:fce10ba:         ResultSet                   rs = ps.executeQuery();
1:fce10ba: 
1:fce10ba:         assertResults( rs, columnTypes, true );
1:fce10ba: 
1:fce10ba:         rs.close();
1:fce10ba:         ps.close();
1:fce10ba:     }
1:fce10ba:         
1:fce10ba:     /**
1:98c7520:      * Test that a privilege can't be revoked if an object depends on it.
1:98c7520:      */
1:98c7520:     protected void verifyRevokePrivilege
1:98c7520:         (
1:98c7520:          Connection grantorConnection,
1:98c7520:          Connection granteeConnection,
1:98c7520:          String grantStatement,
1:98c7520:          String revokeStatement,
1:98c7520:          String createStatement,
1:98c7520:          String dropStatement,
1:98c7520:          String badRevokeSQLState
1:98c7520:          ) throws Exception
1:98c7520:     {
1:98c7520:         expectExecutionError
1:98c7520:             (
1:98c7520:              granteeConnection,
1:98c7520:              LACK_USAGE_PRIV,
1:98c7520:              createStatement
1:98c7520:              );
1:98c7520:         goodStatement
1:98c7520:             (
1:98c7520:              grantorConnection,
1:98c7520:              grantStatement
1:98c7520:              );
1:98c7520:         goodStatement
1:98c7520:             (
1:98c7520:              granteeConnection,
1:98c7520:              createStatement
1:98c7520:              );
1:98c7520:         expectExecutionError
1:98c7520:             (
1:98c7520:              grantorConnection,
1:98c7520:              badRevokeSQLState,
1:98c7520:              revokeStatement
1:98c7520:              );
1:98c7520:         goodStatement
1:98c7520:             (
1:98c7520:              granteeConnection,
1:98c7520:              dropStatement
1:98c7520:              );
1:98c7520:         goodStatement
1:98c7520:             (
1:98c7520:              grantorConnection,
1:98c7520:              revokeStatement
1:98c7520:              );
1:98c7520:     }
1:98c7520: 
1:98c7520:     /**
1:2f4a1a0:      * Test that a restricted drop is blocked by an object.
1:2f4a1a0:      */
1:2f4a1a0:     protected void verifyRestrictedDrop
1:2f4a1a0:         (
1:2f4a1a0:          Connection conn,
1:2f4a1a0:          String createDependentObject,
1:2f4a1a0:          String dropDependentObject,
1:2f4a1a0:          String createStatement,
1:2f4a1a0:          String dropStatement,
1:2f4a1a0:          String badDropState
1:2f4a1a0:          ) throws Exception
1:2f4a1a0:     {
1:2f4a1a0:         goodStatement
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              createStatement
1:2f4a1a0:              );
1:2f4a1a0:         goodStatement
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              createDependentObject
1:2f4a1a0:              );
1:2f4a1a0:         expectExecutionError
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              badDropState,
1:2f4a1a0:              dropStatement
1:2f4a1a0:              );
1:2f4a1a0:         goodStatement
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              dropDependentObject
1:2f4a1a0:              );
1:2f4a1a0:         goodStatement
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              dropStatement
1:2f4a1a0:              );
1:2f4a1a0:     }
1:2f4a1a0: 
1:2f4a1a0:     /**
1:9a9b932:      * <p>
1:9a9b932:      * Fill an ArrayList from an array.
1:9a9b932:      * </p>
1:9a9b932:      */
1:3f5c48a:     protected <T> ArrayList<T> fill( T[] raw )
1:9a9b932:     {
1:3f5c48a:         return new ArrayList<T>(Arrays.asList(raw));
1:9a9b932:     }
1:9a9b932:     
1:9a9b932: 
1:9a9b932: }
1:9a9b932: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b5392db
/////////////////////////////////////////////////////////////////////////
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     protected <T> ArrayList<T> fill( T[] raw )
1:         return new ArrayList<T>(Arrays.asList(raw));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:8c39c1c
/////////////////////////////////////////////////////////////////////////
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1:     protected   static  final   String  NO_GENERIC_PERMISSION = "42504";
1:     protected   static  final   String  NO_SELECT_OR_UPDATE_PERMISSION = "42502";
1:     protected   static  final   String  NO_TABLE_PERMISSION = "42500";
1: 
commit:070d37e
/////////////////////////////////////////////////////////////////////////
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Run a good update statement with an expected row count.
0:      * @throws SQLException 
1:      */
0:     protected void    goodUpdate( Connection conn, String update, int expectedRowCount ) throws SQLException
1:     {
0:         PreparedStatement    ps = chattyPrepare( conn, update );
1: 
0:         int actualRowCount = ps.executeUpdate();
1:         ps.close();
1: 
0:         println( "Expecting to touch " + expectedRowCount + " rows." );
0:         assertEquals( expectedRowCount, actualRowCount );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Assert that the statement text, when executed, raises no warnings.
1:      */
1:     protected void    expectNoWarning( Connection conn, String query )
1:         throws Exception
1:     {
1:         expectExecutionWarnings( conn, new String[] { }, query );
1:     }
1: 
1:     /**
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
1:     protected static final    String NOT_IMPLEMENTED = "0A000";
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  LEXICAL_ERROR = "42X02";
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  MISSING_OBJECT = "X0X81";
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  LOCK_TIMEOUT = "40XL1";
1:     protected static  final   String  TOO_MUCH_CONTENTION = "X0Y84";
commit:2f4a1a0
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  VIEW_DEPENDENCY = "X0Y23";
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  FORBIDDEN_DROP_TRIGGER = "X0Y24";
/////////////////////////////////////////////////////////////////////////
1:      * Test that a restricted drop is blocked by an object.
1:      */
1:     protected void verifyRestrictedDrop
1:         (
1:          Connection conn,
1:          String createDependentObject,
1:          String dropDependentObject,
1:          String createStatement,
1:          String dropStatement,
1:          String badDropState
1:          ) throws Exception
1:     {
1:         goodStatement
1:             (
1:              conn,
1:              createStatement
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              createDependentObject
1:              );
1:         expectExecutionError
1:             (
1:              conn,
1:              badDropState,
1:              dropStatement
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              dropDependentObject
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              dropStatement
1:              );
1:     }
1: 
1:     /**
commit:3b77ab8
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  DUPLICATE_CLAUSE = "42XAJ";
commit:33bfdc0
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
0:      * Prepare a callable statement and report its sql text.
1:      */
0:     protected CallableStatement   chattyPrepareCall( Connection conn, String text )
0:         throws SQLException
1:     {
0:         println( "Preparing callable statement:\n\t" + text );
1:         
0:         return conn.prepareCall( text );
1:     }
1: 
1:     /**
commit:30fa79b
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  ILLEGAL_STORAGE = "42821";
1:     protected static  final   String  BAD_CAST = "42846";
commit:f2a5622
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  ILLEGAL_UDT_CLASS = "42Z10";
1:     protected static  final   String  FORBIDDEN_ORDERING_OPERATION = "X0X67";
1:     protected static  final   String  ILLEGAL_AGG = "42Y22";
1:     protected static  final   String  ILLEGAL_COMPARISON = "42818";
commit:e5114fd
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  JAVA_EXCEPTION = "XJ001";
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1:     protected static final    String OBJECT_DOES_NOT_EXIST = "42X94";
1:     protected static final    String NONEXISTENT_OBJECT = "42Y55";
commit:90f42b4
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  NON_EMPTY_SCHEMA = "X0Y54";
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  LACK_USAGE_PRIV = "42504";
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  GRANT_REVOKE_NOT_ALLOWED = "42509";
1:     protected static  final   String  ROUTINE_DEPENDS_ON_TYPE = "X0Y30";
1:     protected static  final   String  TABLE_DEPENDS_ON_TYPE = "X0Y29";
0:     protected static  final   String  VIEW_DEPENDS_ON_PRIVILEGE = "X0Y23";
/////////////////////////////////////////////////////////////////////////
0:      * Assert that the statement text, when compiled, raises an exception
1:      */
0:     protected void    expectCompilationError( Connection conn, String sqlState, String query )
1:     {
0:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1: 
0:         PreparedStatement ps = null;
1: 
1:         try {
0:             ps = conn.prepareStatement( query );
0:         } catch (SQLException se )
1:         {
1:             assertSQLState( sqlState, se );
1: 
0:             return;
1:         }
1: 
0:         fail( "Expected SQL state: " + sqlState );
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Test that a privilege can't be revoked if an object depends on it.
1:      */
1:     protected void verifyRevokePrivilege
1:         (
1:          Connection grantorConnection,
1:          Connection granteeConnection,
1:          String grantStatement,
1:          String revokeStatement,
1:          String createStatement,
1:          String dropStatement,
1:          String badRevokeSQLState
1:          ) throws Exception
1:     {
1:         expectExecutionError
1:             (
1:              granteeConnection,
1:              LACK_USAGE_PRIV,
1:              createStatement
1:              );
1:         goodStatement
1:             (
1:              grantorConnection,
1:              grantStatement
1:              );
1:         goodStatement
1:             (
1:              granteeConnection,
1:              createStatement
1:              );
1:         expectExecutionError
1:             (
1:              grantorConnection,
1:              badRevokeSQLState,
1:              revokeStatement
1:              );
1:         goodStatement
1:             (
1:              granteeConnection,
1:              dropStatement
1:              );
1:         goodStatement
1:             (
1:              grantorConnection,
1:              revokeStatement
1:              );
1:     }
1: 
1:     /**
commit:b8b524c
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  CANT_CONTAIN_NULLS = "42831";
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  NOT_NULL_NEEDS_DATATYPE = "42XAB";
commit:15b837e
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
commit:45c6691
/////////////////////////////////////////////////////////////////////////
0: 	protected	static	ResultSet	executeQuery( Statement stmt, String text )
0: 		throws SQLException
1: 	{
0: 		println( "Executing '" + text + "'" );
1: 
0:         return stmt.executeQuery( text );
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Assert that the in-place update raises the expected error.
1:      */
1:     protected void    expectUpdateRowError( ResultSet rs, String sqlState )
1:         throws Exception
1:     {
1:         println( "\nExpecting " + sqlState + " when updating row" );
1: 
1:         try {
1:             rs.updateRow();
1:             fail( "Expected error: " + sqlState );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( sqlState, se );
1:         }
1:     }
1: 
1:     /**
1:      * Assert that the in-place insert raises the expected error.
1:      */
1:     protected void    expectInsertRowError( ResultSet rs, String sqlState )
1:         throws Exception
1:     {
1:         println( "\nExpecting " + sqlState + " when inserting row" );
1: 
1:         try {
1:             rs.insertRow();
1:             fail( "Expected error: " + sqlState );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( sqlState, se );
1:         }
1:     }
1: 
1:     /**
commit:e735448
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  BAD_BEFORE_TRIGGER = "42XAA";
commit:97a8b1c
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  CANT_MODIFY_IDENTITY = "42Z23";
commit:fce10ba
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  NEED_EXPLICIT_DATATYPE = "42XA9";
/////////////////////////////////////////////////////////////////////////
0:     protected static  final   String  CANT_ADD_IDENTITY = "42601";
/////////////////////////////////////////////////////////////////////////
1:      * Assert that a table has the correct column types.
1:      */
1:     protected void assertColumnTypes( Connection conn, String tableName, String[][] columnTypes )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare
1:             (
1:              conn,
1:              "select c.columnname, c.columndatatype\n" +
1:              "from sys.syscolumns c, sys.systables t\n" +
1:              "where t.tablename = ?\n" +
1:              "and t.tableid = c.referenceid\n" +
1:              "order by c.columnname\n"
1:              );
1:         ps.setString( 1, tableName );
1:         ResultSet                   rs = ps.executeQuery();
1: 
1:         assertResults( rs, columnTypes, true );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1:         
1:     /**
/////////////////////////////////////////////////////////////////////////
0:                 //println( "(row, column ) ( " + i + ", " +  j + " ) should be " + expectedValue );
commit:9a9b932
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.GeneratedColumnsHelper
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Connection;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.DriverManager;
1: import java.util.ArrayList;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derby.iapi.util.StringUtil;
0: import org.apache.derby.catalog.DefaultInfo;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: 
1: /**
1:  * <p>
1:  * Helper routines for testing generated columns. See DERBY-481.
1:  * </p>
1:  */
1: public class GeneratedColumnsHelper extends BaseJDBCTestCase
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     protected static  final   String  REDUNDANT_CLAUSE = "42613";
1:     protected static  final   String  ILLEGAL_AGGREGATE = "42XA1";
1:     protected static  final   String  UNSTABLE_RESULTS = "42XA2";
1:     protected static  final   String  CANT_OVERRIDE_GENERATION_CLAUSE = "42XA3";
1:     protected static  final   String  CANT_REFERENCE_GENERATED_COLUMN = "42XA4";
1:     protected static  final   String  ROUTINE_CANT_ISSUE_SQL = "42XA5";
1:     protected static  final   String  BAD_FOREIGN_KEY_ACTION = "42XA6";
1:     protected static  final   String  ILLEGAL_ADD_DEFAULT = "42XA7";
1:     protected static  final   String  ILLEGAL_RENAME = "42XA8";
1:     
1:     protected static  final   String  NOT_NULL_VIOLATION = "23502";
1:     protected static  final   String  CONSTRAINT_VIOLATION = "23513";
1:     protected static  final   String  FOREIGN_KEY_VIOLATION = "23503";
1:     protected static  final   String  ILLEGAL_DUPLICATE = "23505";
1:     protected static  final   String  SYNTAX_ERROR = "42X01";
1:     protected static  final   String  COLUMN_OUT_OF_SCOPE = "42X04";
1:     protected static  final   String  OPERATION_FORBIDDEN = "X0Y25";
1: 
1:     protected static  final   String  LACK_TABLE_PRIV = "42500";
1:     protected static  final   String  LACK_COLUMN_PRIV = "42502";
1:     protected static  final   String  LACK_EXECUTE_PRIV = "42504";
1:     
1:     protected static  final   String  CASCADED_COLUMN_DROP_WARNING = "01009";
1:     protected static  final   String  CONSTRAINT_DROPPED_WARNING = "01500";
1:     protected static  final   String  TRIGGER_DROPPED_WARNING = "01502";
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public GeneratedColumnsHelper(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // HELPER METHODS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Run good DDL.
0:      * @throws SQLException 
1:      */
0:     protected void    goodStatement( Connection conn, String ddl ) throws SQLException
1:     {
0:         PreparedStatement    ps = chattyPrepare( conn, ddl );
1: 
1:         ps.execute();
0:         ps.close();
1:     }
1:     
1:     /**
0:      * Prepare a statement and report its sql text.
1:      */
0:     protected PreparedStatement   chattyPrepare( Connection conn, String text )
0:         throws SQLException
1:     {
0:         println( "Preparing statement:\n\t" + text );
1:         
0:         return conn.prepareStatement( text );
1:     }
1: 
1:     /**
0:      * Assert that the statement text, when compiled, raises an exception
1:      */
0:     protected void    expectCompilationError( String sqlState, String query )
1:     {
0:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1: 
0:         assertCompileError( sqlState, query );
1:     }
1: 
1:     /**
0:      * Assert that the statement text, when executed, raises an error.
1:      */
0:     protected void    expectExecutionError( Connection conn, String sqlState, String query )
1:         throws Exception
1:     {
0:         println( "\nExpecting " + sqlState + " when executing:\n\t"  );
1:         PreparedStatement   ps = chattyPrepare( conn, query );
1: 
0:         assertStatementError( sqlState, ps );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when executed, raises a warning.
1:      */
1:     protected void    expectExecutionWarning( Connection conn, String sqlState, String query )
1:         throws Exception
1:     {
1:         expectExecutionWarnings( conn, new String[] { sqlState }, query );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when executed, raises a warning.
1:      */
1:     protected void    expectExecutionWarnings( Connection conn, String[] sqlStates, String query )
1:         throws Exception
1:     {
1:         println( "\nExpecting warnings " + fill( sqlStates ).toString() + " when executing:\n\t"  );
1:         PreparedStatement   ps = chattyPrepare( conn, query );
1: 
1:         ps.execute();
1: 
1:         int idx = 0;
1: 
1:         for ( SQLWarning sqlWarning = ps.getWarnings(); sqlWarning != null; sqlWarning = sqlWarning.getNextWarning() )
1:         {
1:             String          actualSQLState = sqlWarning.getSQLState();
1: 
1:             if ( idx >= sqlStates.length )
1:             {
1:                 fail( "Got more warnings than we expected." );
1:             }
1: 
1:             String  expectedSqlState = sqlStates[ idx++ ];
1: 
1:             assertEquals( expectedSqlState, actualSQLState );
1:         }
1: 
1:         assertEquals( idx, sqlStates.length );
1: 
0:         ps.close();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Assert whether a routine is expected to be DETERMINISTIC.
1:      * </p>
1:      */
1:     public  void    assertDeterministic( Connection conn, String routineName, boolean isDeterministic )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = conn.prepareStatement
1:             (
1:              "select a.aliasinfo\n" +
1:              "from sys.sysaliases a\n" +
1:              "where alias =  ?"
1:              );
1:         ps.setString( 1, routineName );
1:         ResultSet               rs = ps.executeQuery();
1: 
1:         rs.next();
1:         RoutineAliasInfo    rai = (RoutineAliasInfo) rs.getObject( 1 );
1: 
1:         assertEquals( isDeterministic, rai.isDeterministic() );
1: 
1:         rs.close();
0:         ps.close();
1:     }
1: 
1:     /**
0:      * Assert that the statement returns the correct results.
1:      */
0:     protected void assertResults( Connection conn, String query, String[][] rows, boolean trimResults )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare( conn, query );
0:         ResultSet                   rs = ps.executeQuery();
1: 
0:         assertResults( rs, rows, trimResults );
1: 
1:         rs.close();
0:         ps.close();
1:     }
1:         
1:     /**
0:      * Assert that the ResultSet returns the desired rows.
1:      */
0:     protected void assertResults( ResultSet rs, String[][] rows, boolean trimResults )
1:         throws Exception
1:     {
0:         int     rowCount = rows.length;
1: 
0:         for ( int i = 0; i < rowCount; i++ )
1:         {
0:             String[]    row = rows[ i ];
0:             int             columnCount = row.length;
1: 
0:             assertTrue( rs.next() );
1: 
0:             for ( int j = 0; j < columnCount; j++ )
1:             {
0:                 String  expectedValue =  row[ j ];
0:                 String  actualValue = null;
0:                 int         column = j+1;
1: 
0:                 actualValue = rs.getString( column );
0:                 if ( rs.wasNull() ) { actualValue = null; }
1: 
0:                 if ( (actualValue != null) && trimResults ) { actualValue = actualValue.trim(); }
1:                 
0:                 assertEquals( (expectedValue == null), rs.wasNull() );
1:                 
0:                 if ( expectedValue == null )    { assertNull( actualValue ); }
0:                 else { assertEquals(expectedValue, actualValue); }
1:             }
1:         }
1: 
0:         assertFalse( rs.next() );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Fill an ArrayList from an array.
1:      * </p>
1:      */
0:     protected ArrayList   fill( Object[] raw )
1:     {
0:         ArrayList   result = new ArrayList();
0:         int             count = raw.length;
1: 
0:         for ( int i = 0; i < count; i++ ) { result.add( raw[ i ] ); }
1: 
0:         return result;
1:     }
1:     
1: 
1: }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:eff9169
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  STRING_TRUNCATION = "22001";
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
1:     protected static  final   String  LANG_INVALID_USE_OF_DEFAULT = "42Y85";
0: 
============================================================================