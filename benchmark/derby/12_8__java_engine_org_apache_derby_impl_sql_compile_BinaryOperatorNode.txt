1:eac0369: /*
11:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.BinaryOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:e33b8d8: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:24f43da: 
6:eac0369: /**
1:eac0369:  * A BinaryOperatorNode represents a built-in binary operator as defined by
1:dbed020:  * the ANSI/ISO SQL standard.  This covers operators like +, -, *, /, =, &lt;, etc.
1:eac0369:  * Java operators are not represented here: the JSQL language allows Java
1:eac0369:  * methods to be called from expressions, but not Java operators.
10:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class BinaryOperatorNode extends OperatorNode
3:eac0369: {
1:eac0369: 	String	operator;
1:eac0369: 	String	methodName;
1:eac0369: 	ValueNode	receiver; // used in generation
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** These identifiers are used in the grammar.
1:eac0369: 	*/
1:3bb140c:     final static int PLUS   = 1;
1:3bb140c:     final static int MINUS  = 2;
1:3bb140c:     final static int TIMES  = 3;
1:3bb140c:     final static int DIVIDE = 4;
1:3bb140c:     final static int CONCATENATE    = 5;
1:3bb140c:     final static int EQ = 6;
1:3bb140c:     final static int NE = 7;
1:3bb140c:     final static int GT = 8;
1:3bb140c:     final static int GE = 9;
1:3bb140c:     final static int LT = 10;
1:3bb140c:     final static int LE = 11;
1:3bb140c:     final static int AND    = 12;
1:3bb140c:     final static int OR = 13;
1:3bb140c:     final static int LIKE   = 14;
1:eac0369: 
1:eac0369: 	ValueNode	leftOperand;
1:eac0369: 	ValueNode	rightOperand;
1:eac0369: 
1:eac0369: 	String		leftInterfaceType;
1:eac0369: 	String		rightInterfaceType;
1:099e28f: 	String		resultInterfaceType;
1:eac0369: 
1:099e28f: 	// At the time of adding XML support, it was decided that
1:099e28f: 	// we should avoid creating new OperatorNodes where possible.
1:099e28f: 	// So for the XML-related binary operators we just add the
1:099e28f: 	// necessary code to _this_ class, similar to what is done in
1:099e28f: 	// TernarnyOperatorNode. Subsequent binary operators (whether
1:099e28f: 	// XML-related or not) should follow this example when
1:099e28f: 	// possible.
1:eac0369: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_XMLEXISTS = 0;
1:2706d1f:     final static int K_XMLQUERY = 1;
1:2706d1f:     final static int K_BASE = 2; // when BinaryOperatorNode is used
1:2706d1f:                                  // as a base class
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:eac0369: 
1:099e28f: 	// NOTE: in the following 4 arrays, order
1:099e28f: 	// IS important.
1:eac0369: 
1:099e28f: 	static final String[] BinaryOperators = {
1:099e28f: 		"xmlexists",
1:24f43da: 		"xmlquery"
1:099e28f: 	};
1:6e7bbc8: 
1:099e28f: 	static final String[] BinaryMethodNames = {
1:099e28f: 		"XMLExists",
1:24f43da: 		"XMLQuery"
1:099e28f: 	};
1:eac0369: 
1:099e28f: 	static final String[] BinaryResultTypes = {
1:24f43da: 		ClassName.BooleanDataValue,		// XMLExists
1:24f43da: 		ClassName.XMLDataValue			// XMLQuery
1:099e28f: 	};
1:eac0369: 
1:099e28f: 	static final String[][] BinaryArgTypes = {
1:24f43da: 		{ClassName.StringDataValue, ClassName.XMLDataValue},	// XMLExists
1:24f43da: 		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLQuery
1:099e28f: 	};
1:eac0369: 
1:044afae:     /** The query expression if the operator is XMLEXISTS or XMLQUERY. */
1:044afae:     private String xmlQuery;
1:eac0369: 
1:3bb140c:     BinaryOperatorNode(ContextManager cm) {
1:3bb140c:         super(cm);
1:2706d1f:         kind = K_BASE;
1:3bb140c:     }
1:6e7bbc8: 
1:3bb140c:     BinaryOperatorNode(
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             String operator,
1:3bb140c:             String methodName,
1:3bb140c:             String leftInterfaceType,
1:3bb140c:             String rightInterfaceType,
1:3bb140c:             ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.leftOperand = leftOperand;
1:3bb140c:         this.rightOperand = rightOperand;
1:3bb140c:         this.operator = operator;
1:3bb140c:         this.methodName = methodName;
1:3bb140c:         this.leftInterfaceType = leftInterfaceType;
1:3bb140c:         this.rightInterfaceType = rightInterfaceType;
1:2706d1f:         this.kind = K_BASE;
1:24f43da:     }
1:6e7bbc8: 
1:3bb140c:     BinaryOperatorNode(
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             String leftInterfaceType,
1:3bb140c:             String rightInterfaceType,
1:3bb140c:             ContextManager cm)
1:6e7bbc8: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.leftOperand = leftOperand;
1:3bb140c:         this.rightOperand = rightOperand;
1:3bb140c:         this.leftInterfaceType = leftInterfaceType;
1:3bb140c:         this.rightInterfaceType = rightInterfaceType;
1:2706d1f:         this.kind = K_BASE;
1:6e7bbc8: 	}
1:6e7bbc8: 
1:6e7bbc8: 	/**
1:2706d1f:      * Constructor for a concrete BinaryOperatorNode
1:6e7bbc8: 	 *
1:eac0369: 	 * @param leftOperand	The left operand of the node
1:eac0369: 	 * @param rightOperand	The right operand of the node
1:2706d1f:      * @param kind          The kind of operator.
1:6e7bbc8: 	 */
1:3bb140c:     BinaryOperatorNode(
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:2706d1f:             int kind,
1:3bb140c:             ContextManager cm)
1:01217c2: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.leftOperand = leftOperand;
1:3bb140c:         this.rightOperand = rightOperand;
1:2706d1f:         this.kind = kind;
1:2706d1f:         this.operator = BinaryOperators[this.kind];
1:2706d1f:         this.methodName = BinaryMethodNames[this.kind];
1:2706d1f:         this.leftInterfaceType = BinaryArgTypes[this.kind][0];
1:2706d1f:         this.rightInterfaceType = BinaryArgTypes[this.kind][1];
1:2706d1f:         this.resultInterfaceType = BinaryResultTypes[this.kind];
1:3bb140c: 	}
1:01217c2: 
1:2706d1f:     /**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:6e7bbc8: 	 *
1:eac0369: 	 * @return	This object as a String
1:01217c2: 	 */
1:2706d1f:     @Override
1:eac0369: 	public String toString()
1:01217c2: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "operator: " + operator + "\n" +
1:eac0369: 				"methodName: " + methodName + "\n" + 
1:eac0369: 				super.toString();
1:d09782a: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:01217c2: 		}
6:eac0369: 	}
1:eac0369: 
1:01217c2: 	/**
1:eac0369: 	 * Set the operator.
1:eac0369: 	 *
1:eac0369: 	 * @param operator	The operator.
1:eac0369: 	 */
1:eac0369: 	void setOperator(String operator)
1:eac0369: 	{
1:eac0369: 		this.operator = operator;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the methodName.
1:eac0369: 	 *
1:eac0369: 	 * @param methodName	The methodName.
1:eac0369: 	 */
1:eac0369: 	void setMethodName(String methodName)
1:eac0369: 	{
1:eac0369: 		this.methodName = methodName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the interface type for the left and right arguments.
1:eac0369: 	 * Used when we don't know the interface type until
1:eac0369: 	 * later in binding.
1:eac0369: 	 */
1:3bb140c:     void setLeftRightInterfaceType(String iType)
1:eac0369: 	{
1:eac0369: 		leftInterfaceType = iType;
1:eac0369: 		rightInterfaceType = iType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (leftOperand != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "leftOperand: ");
1:eac0369: 				leftOperand.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (rightOperand != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "rightOperand: ");
1:eac0369: 				rightOperand.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList, 
1:09c2697:             aggregates);
1:eac0369: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
1:09c2697:             aggregates);
1:eac0369: 
1:2706d1f:         if ((kind == K_XMLEXISTS) ||
1:2706d1f:             (kind == K_XMLQUERY)) {
1:24f43da: 			return bindXMLQuery();
1:2706d1f:         }
1:eac0369: 
1:eac0369: 		/* Is there a ? parameter on the left? */
1:d5bc20f: 		if (leftOperand.requiresTypeFromContext())
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** It's an error if both operands are ? parameters.
1:eac0369: 			*/
1:d5bc20f: 			if (rightOperand.requiresTypeFromContext())
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
1:eac0369: 																	operator);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Set the left operand to the type of right parameter. */
1:d5bc20f: 			leftOperand.setType(rightOperand.getTypeServices());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Is there a ? parameter on the right? */
1:d5bc20f: 		if (rightOperand.requiresTypeFromContext())
1:eac0369: 		{
1:eac0369: 			/* Set the right operand to the type of the left parameter. */
1:d5bc20f: 			rightOperand.setType(leftOperand.getTypeServices());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return genSQLJavaSQLTree();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:24f43da:      * Bind an XMLEXISTS or XMLQUERY operator.  Makes sure
1:24f43da:      * the operand type and target type are both correct
1:24f43da:      * and sets the result type.
1:eac0369:      *
1:099e28f:      * @exception StandardException Thrown on error
1:eac0369:      */
1:24f43da:     public ValueNode bindXMLQuery()
1:24f43da:         throws StandardException
1:eac0369:     {
1:099e28f:         // Check operand types.
1:099e28f:         TypeId rightOperandType = rightOperand.getTypeId();
1:eac0369: 
1:6e7bbc8:         // Left operand is query expression and must be a string
1:6e7bbc8:         // literal.  SQL/XML spec doesn't allow params nor expressions
1:6e7bbc8:         // 6.17: <XQuery expression> ::= <character string literal> 
1:6e7bbc8:         if (!(leftOperand instanceof CharConstantNode))
1:6e7bbc8:         {
1:6e7bbc8:             throw StandardException.newException(
1:6e7bbc8:                 SQLState.LANG_INVALID_XML_QUERY_EXPRESSION);
1:6e7bbc8:         }
1:6e7bbc8:         else {
1:044afae:             xmlQuery = ((CharConstantNode)leftOperand).getString();
1:eac0369:         }
1:044afae: 
1:24f43da:         // Right operand must be an XML data value.  NOTE: This
1:24f43da:         // is a Derby-specific restriction, not an SQL/XML one.
1:24f43da:         // We have this restriction because the query engine
1:24f43da:         // that we use (currently Xalan) cannot handle non-XML
1:24f43da:         // context items.
1:099e28f:         if ((rightOperandType != null) &&
1:099e28f:             !rightOperandType.isXMLTypeId())
1:eac0369:         {
2:099e28f:             throw StandardException.newException(
1:24f43da:                 SQLState.LANG_INVALID_CONTEXT_ITEM_TYPE,
1:24f43da:                 rightOperandType.getSQLTypeName());
1:eac0369:         }
1:eac0369: 
1:099e28f:         // Is there a ? parameter on the right?
1:d5bc20f:         if (rightOperand.requiresTypeFromContext())
1:eac0369:         {
1:099e28f:             // For now, since JDBC has no type defined for XML, we
1:099e28f:             // don't allow binding to an XML parameter.
1:099e28f:             throw StandardException.newException(
1:099e28f:                 SQLState.LANG_ATTEMPT_TO_BIND_XML);
1:eac0369:         }
1:eac0369: 
1:24f43da:         // Set the result type of this operator.
1:2706d1f:         if (kind == K_XMLEXISTS) {
1:24f43da:             // For XMLEXISTS, the result type is always SQLBoolean.
1:24f43da:             // The "true" in the next line says that the result
1:24f43da:             // can be nullable--which it can be if evaluation of
1:24f43da:             // the expression returns a null (this is per SQL/XML
1:24f43da:             // spec, 8.4)
1:24f43da:             setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
1:24f43da:         }
1:24f43da:         else {
1:24f43da:             // The result of an XMLQUERY operator is always another
1:24f43da:             // XML data value, per SQL/XML spec 6.17: "...yielding a value
1:24f43da:             // X1 of an XML type."
1:24f43da:             setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
1:e33b8d8:                     Types.SQLXML));
1:24f43da:         }
1:24f43da: 
1:099e28f:         return genSQLJavaSQLTree();
1:eac0369:     }
1:eac0369: 
1:dbed020: 	/** generate a SQL-&gt;Java-&gt;SQL conversion tree above the left and right
1:eac0369: 	 * operand of this Binary Operator Node if needed. Subclasses can override
1:eac0369: 	 * the default behavior.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode genSQLJavaSQLTree() throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId leftTypeId = leftOperand.getTypeId();
1:eac0369: 		
1:08d6ce2: 		if (leftTypeId.userType())
1:eac0369: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1:eac0369: 
1:eac0369: 		TypeId rightTypeId = rightOperand.getTypeId();
1:08d6ce2: 		if (rightTypeId.userType())
1:eac0369: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		leftOperand = leftOperand.preprocess(numTables,
1:eac0369: 											 outerFromList, outerSubqueryList,
1:eac0369: 											 outerPredicateList);
1:eac0369: 		rightOperand = rightOperand.preprocess(numTables,
1:eac0369: 											   outerFromList, outerSubqueryList,
1:eac0369: 											   outerPredicateList);
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this binary operator.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the code to place the code
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:cbdc90c: 		/* If this BinaryOperatorNode was created as a part of an IN-list
1:cbdc90c: 		 * "probe predicate" then we do not want to generate the relational
1:cbdc90c: 		 * operator itself; instead we want to generate the underlying
1:cbdc90c: 		 * IN-list for which this operator node was created.
1:eac0369: 		 *
1:cbdc90c: 		 * We'll get here in situations where the optimizer chooses a plan
1:cbdc90c: 		 * for which the probe predicate is *not* a useful start/stop key
1:cbdc90c: 		 * and thus is not being used for execution-time index probing.
1:cbdc90c: 		 * In this case we are effectively "reverting" the probe predicate
1:cbdc90c: 		 * back to the InListOperatorNode from which it was created.  Or put
1:cbdc90c: 		 * another way, we are "giving up" on index multi-probing and simply
1:cbdc90c: 		 * generating the original IN-list as a regular restriction.
1:eac0369: 		 */
1:cbdc90c: 		if (this instanceof BinaryRelationalOperatorNode)
1:eac0369: 		{
1:cbdc90c: 			InListOperatorNode ilon =
1:cbdc90c: 				((BinaryRelationalOperatorNode)this).getInListOp();
1:eac0369: 
1:cbdc90c: 			if (ilon != null)
1:eac0369: 			{
1:cbdc90c: 				ilon.generateExpression(acb, mb);
1:cbdc90c: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		String		resultTypeName;
1:eac0369: 		String		receiverType;
1:eac0369: 
1:eac0369: /*
1:eac0369: ** if i have a operator.getOrderableType() == constant, then just cache 
1:eac0369: ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
1:eac0369: ** cache it in something that is initialized each execution,
1:eac0369: ** but how?
1:eac0369: */
1:eac0369: 
1:d09782a:         // The number of arguments to pass to the method that implements the
1:d09782a:         // operator, depends on the type of the operator.
1:d09782a:         int numArgs;
1:d09782a: 
1:24f43da: 		// If we're dealing with XMLEXISTS or XMLQUERY, there is some
1:6e7bbc8: 		// additional work to be done.
1:24f43da: 		boolean xmlGen =
1:2706d1f:            (kind == K_XMLQUERY) || (kind == K_XMLEXISTS);
1:6e7bbc8: 
1:eac0369: 		/*
1:eac0369: 		** The receiver is the operand with the higher type precedence.
1:eac0369: 		** Like always makes the left the receiver.
2:eac0369: 		**
1:eac0369: 		*/
1:eac0369: 		if (leftOperand.getTypeId().typePrecedence() >
1:eac0369: 			rightOperand.getTypeId().typePrecedence())
1:eac0369: 		{
1:eac0369: 			receiver = leftOperand;
1:eac0369: 			/*
1:eac0369: 			** let the receiver type be determined by an
1:eac0369: 			** overridable method so that if methods are
1:eac0369: 			** not implemented on the lowest interface of
1:eac0369: 			** a class, they can note that in the implementation
1:eac0369: 			** of the node that uses the method.
1:eac0369: 			*/
1:2706d1f:             receiverType = (kind == K_BASE)
1:099e28f: 				? getReceiverInterfaceName()
1:099e28f: 				: leftInterfaceType;
1:eac0369: 
1:eac0369: 			/*
1:1880322: 			** Generate (with <left expression> only being evaluated once)
1:eac0369: 			**
1:1880322: 			**	<left expression>.method(<left expression>, <right expression>...)
1:eac0369: 			*/
1:eac0369: 
1:1880322: 			leftOperand.generateExpression(acb, mb);
1:eac0369: 			mb.cast(receiverType); // cast the method instance
1:1880322: 			// stack: left
1:1880322: 			
1:1880322: 			mb.dup();
1:1880322: 			mb.cast(leftInterfaceType);
1:1880322: 			// stack: left, left
1:1880322: 			
1:1880322: 			rightOperand.generateExpression(acb, mb);
1:1880322: 			mb.cast(rightInterfaceType); // second arg with cast
1:1880322: 			// stack: left, left, right
1:d09782a: 
1:d09782a:             // We've pushed two arguments
1:d09782a:             numArgs = 2;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			receiver = rightOperand;
1:eac0369: 			/*
1:eac0369: 			** let the receiver type be determined by an
1:eac0369: 			** overridable method so that if methods are
1:eac0369: 			** not implemented on the lowest interface of
1:eac0369: 			** a class, they can note that in the implementation
1:eac0369: 			** of the node that uses the method.
1:eac0369: 			*/
1:2706d1f:             receiverType = (kind == K_BASE)
1:099e28f: 				? getReceiverInterfaceName()
1:099e28f: 				: rightInterfaceType;
1:eac0369: 
1:eac0369: 			/*
1:1880322: 			** Generate (with <right expression> only being evaluated once)
1:6e7bbc8: 			**
1:1880322: 			**	<right expression>.method(<left expression>, <right expression>)
1:6e7bbc8: 			**
1:6e7bbc8: 			** UNLESS we're generating an XML operator such as XMLEXISTS.
1:6e7bbc8: 			** In that case we want to generate
1:6e7bbc8: 			** 
1:d09782a: 			**  <right expression>.method(sqlXmlUtil)
1:eac0369: 			*/
1:1880322: 
1:1880322: 			rightOperand.generateExpression(acb, mb);			
1:eac0369: 			mb.cast(receiverType); // cast the method instance
1:1880322: 			// stack: right
1:1880322: 			
1:6e7bbc8:             if (xmlGen) {
1:d09782a:                 // Push one argument (the SqlXmlUtil instance)
1:d09782a:                 numArgs = 1;
1:d09782a:                 pushSqlXmlUtil(acb, mb, xmlQuery, operator);
1:d09782a:                 // stack: right,sqlXmlUtil
1:d09782a:             } else {
1:d09782a:                 // Push two arguments (left, right)
1:d09782a:                 numArgs = 2;
1:d09782a: 
1:6e7bbc8: 				mb.dup();
1:6e7bbc8: 				mb.cast(rightInterfaceType);
1:6e7bbc8: 				// stack: right,right
1:1880322: 			
1:d09782a:                 leftOperand.generateExpression(acb, mb);
1:d09782a:                 mb.cast(leftInterfaceType); // second arg with cast
1:d09782a:                 // stack: right,right,left
1:d09782a: 
1:d09782a:                 mb.swap();
1:d09782a:                 // stack: right,left,right
1:6e7bbc8:             }
1:6e7bbc8: 		}
1:eac0369: 
1:eac0369: 		/* Figure out the result type name */
1:2706d1f:         resultTypeName = (kind == K_BASE)
1:099e28f: 			? getTypeCompiler().interfaceName()
1:099e28f: 			: resultInterfaceType;
1:eac0369: 
1:d09782a:         // Boolean return types don't need a result field. For other types,
1:d09782a:         // allocate an object for re-use to hold the result of the operator.
1:d09782a:         LocalField resultField = getTypeId().isBooleanTypeId() ?
1:d09782a:             null : acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1:eac0369: 
1:d09782a:         // Push the result field onto the stack, if there is a result field.
1:d09782a: 		if (resultField != null) {
1:eac0369: 			/*
1:eac0369: 			** Call the method for this operator.
1:eac0369: 			*/
1:eac0369: 			mb.getField(resultField); // third arg
1:eac0369: 
1:d09782a:             // Adjust number of arguments for the result field
1:d09782a:             numArgs++;
1:d09782a: 
1:eac0369: 			/* pass statically calculated scale to decimal divide method to make
1:eac0369: 			 * result set scale consistent, beetle 3901
1:eac0369: 			 */
1:eac0369: 			int jdbcType;
1:ef158f2: 			if ((getTypeServices() != null) &&
1:ef158f2: 				((jdbcType = getTypeServices().getJDBCTypeId()) == java.sql.Types.DECIMAL ||
1:eac0369: 				 jdbcType == java.sql.Types.NUMERIC) &&
1:eac0369: 				operator.equals("/"))
1:eac0369: 			{
1:ef158f2: 				mb.push(getTypeServices().getScale());		// 4th arg
1:d09782a:                 numArgs++;
1:6e7bbc8: 			}
1:d09782a:         }
1:eac0369: 
1:6e7bbc8:         mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
1:d09782a:                       methodName, resultTypeName, numArgs);
1:d09782a: 
1:d09782a:         // Store the result of the method call, if there is a result field.
1:d09782a:         if (resultField != null) {
1:eac0369: 			//the need for following if was realized while fixing bug 5704 where decimal*decimal was resulting an overflow value but we were not detecting it
1:eac0369: 			if (getTypeId().variableLength())//since result type is numeric variable length, generate setWidth code.
1:eac0369: 			{
1:eac0369: 				if (getTypeId().isNumericTypeId())
1:eac0369: 				{
1:806114c: 					// to leave the DataValueDescriptor value on the stack, since setWidth is void
1:806114c: 					mb.dup();
1:806114c: 
1:eac0369: 					mb.push(getTypeServices().getPrecision());
1:eac0369: 					mb.push(getTypeServices().getScale());
1:eac0369: 					mb.push(true);
1:806114c: 					mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Store the result of the method call in the field, so we can re-use
1:eac0369: 			** the object.
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			mb.putField(resultField);
1:6e7bbc8: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the leftOperand to the specified ValueNode
1:eac0369: 	 *
1:eac0369: 	 * @param newLeftOperand	The new leftOperand
1:eac0369: 	 */
1:3bb140c:     void setLeftOperand(ValueNode newLeftOperand)
1:eac0369: 	{
1:eac0369: 		leftOperand = newLeftOperand;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the leftOperand
1:eac0369: 	 *
1:eac0369: 	 * @return The current leftOperand.
1:eac0369: 	 */
1:3bb140c:     ValueNode getLeftOperand()
1:eac0369: 	{
1:eac0369: 		return leftOperand;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the rightOperand to the specified ValueNode
1:eac0369: 	 *
1:eac0369: 	 * @param newRightOperand	The new rightOperand
1:eac0369: 	 */
1:3bb140c:     void setRightOperand(ValueNode newRightOperand)
1:eac0369: 	{
1:eac0369: 		rightOperand = newRightOperand;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the rightOperand
1:eac0369: 	 *
1:eac0369: 	 * @return The current rightOperand.
1:eac0369: 	 */
1:3bb140c:     ValueNode getRightOperand()
1:eac0369: 	{
1:eac0369: 		return rightOperand;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean pushable;
1:eac0369: 		pushable = leftOperand.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 		pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1:eac0369: 		return pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
1:eac0369: 		rightOperand = rightOperand.remapColumnReferencesToExpressions();
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		return (leftOperand.isConstantExpression() &&
1:eac0369: 				rightOperand.isConstantExpression());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return (leftOperand.constantExpression(whereClause) &&
1:eac0369: 				rightOperand.constantExpression(whereClause));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine the type the binary method is called on.
1:eac0369: 	 * By default, based on the receiver.
1:eac0369: 	 *
1:eac0369: 	 * Override in nodes that use methods on super-interfaces of
1:eac0369: 	 * the receiver's interface, such as comparisons.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     String getReceiverInterfaceName() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(receiver!=null,"can't get receiver interface name until receiver is set");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return receiver.getTypeCompiler().interfaceName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *		CONSTANT			- immutable
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		int leftType = leftOperand.getOrderableVariantType();
1:eac0369: 		int rightType = rightOperand.getOrderableVariantType();
1:eac0369: 
1:eac0369: 		return Math.min(leftType, rightType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (leftOperand != null)
1:eac0369: 		{
1:eac0369: 			leftOperand = (ValueNode)leftOperand.accept(v);
1:eac0369: 		}
1:eac0369: 
1:aebfb28: 		if (rightOperand != null)
1:eac0369: 		{
1:eac0369: 			rightOperand = (ValueNode)rightOperand.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) &&
1:2706d1f:                 ((BinaryOperatorNode)o).kind == this.kind;
1:2706d1f:     }
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * @inheritDoc
1:2706d1f:      */
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:2706d1f:     {
1:2706d1f:         if (isSameNodeKind(o)) {
1:2706d1f:             BinaryOperatorNode other = (BinaryOperatorNode)o;
1:2706d1f:             return methodName.equals(other.methodName)
1:2706d1f:                     && leftOperand.isEquivalent(other.leftOperand)
1:2706d1f:                     && rightOperand.isEquivalent(other.rightOperand);
1:2706d1f:         } else {
1:2706d1f:             return false;
1:2706d1f:         }
1:01217c2:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * the ANSI/ISO SQL standard.  This covers operators like +, -, *, /, =, &lt;, etc.
/////////////////////////////////////////////////////////////////////////
1: 	/** generate a SQL-&gt;Java-&gt;SQL conversion tree above the left and right
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:f67c2ee
/////////////////////////////////////////////////////////////////////////
0:                 ((CharConstantNode)leftOperand).getString(),
0:                 (operatorType == XMLEXISTS_OP ? "XMLEXISTS" : "XMLQUERY"));
commit:24f43da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	public final static int XMLQUERY_OP = 1;
1: 		"xmlquery"
1: 		"XMLQuery"
1: 		ClassName.BooleanDataValue,		// XMLExists
1: 		ClassName.XMLDataValue			// XMLQuery
1: 		{ClassName.StringDataValue, ClassName.XMLDataValue},	// XMLExists
1: 		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLQuery
/////////////////////////////////////////////////////////////////////////
0: 		if ((operatorType == XMLEXISTS_OP) || (operatorType == XMLQUERY_OP))
1: 			return bindXMLQuery();
/////////////////////////////////////////////////////////////////////////
1:      * Bind an XMLEXISTS or XMLQUERY operator.  Makes sure
1:      * the operand type and target type are both correct
1:      * and sets the result type.
1:     public ValueNode bindXMLQuery()
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         // Right operand must be an XML data value.  NOTE: This
1:         // is a Derby-specific restriction, not an SQL/XML one.
1:         // We have this restriction because the query engine
1:         // that we use (currently Xalan) cannot handle non-XML
1:         // context items.
1:                 SQLState.LANG_INVALID_CONTEXT_ITEM_TYPE,
1:                 rightOperandType.getSQLTypeName());
/////////////////////////////////////////////////////////////////////////
1:         // Set the result type of this operator.
0:         if (operatorType == XMLEXISTS_OP) {
1:         // For XMLEXISTS, the result type is always SQLBoolean.
1:         // The "true" in the next line says that the result
1:         // can be nullable--which it can be if evaluation of
1:         // the expression returns a null (this is per SQL/XML
1:         // spec, 8.4)
1:             setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
1:         }
1:         else {
1:         // The result of an XMLQUERY operator is always another
1:         // XML data value, per SQL/XML spec 6.17: "...yielding a value
1:         // X1 of an XML type."
1:             setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
0:                 StoredFormatIds.XML_TYPE_ID));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// If we're dealing with XMLEXISTS or XMLQUERY, there is some
1: 		boolean xmlGen =
0: 			(operatorType == XMLQUERY_OP) || (operatorType == XMLEXISTS_OP);
/////////////////////////////////////////////////////////////////////////
0: 			else if (xmlGen) {
0: 			// This is for an XMLQUERY operation, so invoke the method
0: 			// on our execution-time object.
0: 				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
0: 					methodName, resultTypeName, 3);
1: 			}
commit:6e7bbc8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.SqlXmlUtil;
/////////////////////////////////////////////////////////////////////////
0: 	// Class used to compile an XML query expression and/or load/process
0: 	// XML-specific objects.
0: 	private SqlXmlUtil sqlxUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Left operand is query expression and must be a string
1:         // literal.  SQL/XML spec doesn't allow params nor expressions
1:         // 6.17: <XQuery expression> ::= <character string literal> 
1:         if (!(leftOperand instanceof CharConstantNode))
1:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_INVALID_XML_QUERY_EXPRESSION);
1:         }
1:         else {
0:         // compile the query expression.
0:             sqlxUtil = new SqlXmlUtil();
0:             sqlxUtil.compileXQExpr(
0:                 ((CharConstantNode)leftOperand).getString());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// If we're dealing with XMLEXISTS, there is some
1: 		// additional work to be done.
0: 		boolean xmlGen = (operatorType == XMLEXISTS_OP);
1: 
1: 		if (xmlGen) {
0: 		// We create an execution-time object so that we can retrieve
0: 		// saved objects (esp. our compiled query expression) from
0: 		// the activation.  We do this for two reasons: 1) this level
0: 		// of indirection allows us to separate the XML data type
0: 		// from the required XML implementation classes (esp. JAXP
0: 		// and Xalan classes)--for more on how this works, see the
0: 		// comments in SqlXmlUtil.java; and 2) we can take
0: 		// the XML query expression, which we've already compiled,
0: 		// and pass it to the execution-time object for each row,
0: 		// which means that we only have to compile the query
0: 		// expression once per SQL statement (instead of once per
0: 		// row); see SqlXmlExecutor.java for more.
0: 			mb.pushNewStart(
0: 				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
0: 			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			**
1: 			** UNLESS we're generating an XML operator such as XMLEXISTS.
1: 			** In that case we want to generate
1: 			** 
0: 			**  SqlXmlExecutor.method(left, right)"
1: 			**
0: 			** and we've already pushed the SqlXmlExecutor object to
0: 			** the stack.
0: 			if (!xmlGen) {
1: 				mb.dup();
1: 				mb.cast(rightInterfaceType);
1: 				// stack: right,right
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 			if (xmlGen) {
0: 			// This is for an XMLEXISTS operation, so invoke the method
0: 			// on our execution-time object.
0: 				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
0: 					methodName, resultTypeName, 2);
1: 			}
0: 			else {
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
0: 					methodName, resultTypeName, 2);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Push the fields necessary to generate an instance of
0: 	 * SqlXmlExecutor, which will then be used at execution
0: 	 * time to retrieve the compiled XML query expression,
0: 	 * along with any other XML-specific objects.
1: 	 *
0: 	 * @param acb The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb  The method the code to place the code
1: 	 *
0: 	 * @return The number of items that this method pushed onto
0: 	 *  the mb's stack.
1: 	 */
0: 	private int addXmlOpMethodParams(ExpressionClassBuilder acb,
0: 		MethodBuilder mb) throws StandardException
1: 	{
0: 		// Push activation so that we can get our saved object
0: 		// (which will hold the compiled XML query expression)
0: 		// back at execute time.
0: 		acb.pushThisAsActivation(mb);
1: 
0: 		// Push our saved object (the compiled query and XML-specific
0: 		// objects).
0: 		mb.push(getCompilerContext().addSavedObject(sqlxUtil));
1: 
0: 		// We pushed 2 items to the stack.
0: 		return 2;
1: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_XMLEXISTS = 0;
1:     final static int K_XMLQUERY = 1;
1:     final static int K_BASE = 2; // when BinaryOperatorNode is used
1:                                  // as a base class
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
/////////////////////////////////////////////////////////////////////////
1:         kind = K_BASE;
/////////////////////////////////////////////////////////////////////////
1:         this.kind = K_BASE;
/////////////////////////////////////////////////////////////////////////
1:         this.kind = K_BASE;
1:      * Constructor for a concrete BinaryOperatorNode
1:      * @param kind          The kind of operator.
1:             int kind,
1:         this.kind = kind;
1:         this.operator = BinaryOperators[this.kind];
1:         this.methodName = BinaryMethodNames[this.kind];
1:         this.leftInterfaceType = BinaryArgTypes[this.kind][0];
1:         this.rightInterfaceType = BinaryArgTypes[this.kind][1];
1:         this.resultInterfaceType = BinaryResultTypes[this.kind];
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if ((kind == K_XMLEXISTS) ||
1:             (kind == K_XMLQUERY)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_XMLEXISTS) {
0:             // For XMLEXISTS, the result type is always SQLBoolean.
0:             // The "true" in the next line says that the result
0:             // can be nullable--which it can be if evaluation of
0:             // the expression returns a null (this is per SQL/XML
0:             // spec, 8.4)
0:             // The result of an XMLQUERY operator is always another
0:             // XML data value, per SQL/XML spec 6.17: "...yielding a value
0:             // X1 of an XML type."
/////////////////////////////////////////////////////////////////////////
1:            (kind == K_XMLQUERY) || (kind == K_XMLEXISTS);
/////////////////////////////////////////////////////////////////////////
1:             receiverType = (kind == K_BASE)
/////////////////////////////////////////////////////////////////////////
1:             receiverType = (kind == K_BASE)
/////////////////////////////////////////////////////////////////////////
1:         resultTypeName = (kind == K_BASE)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) &&
1:                 ((BinaryOperatorNode)o).kind == this.kind;
1:     }
1: 
1:     /**
1:      * @inheritDoc
1:      */
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:     {
1:         if (isSameNodeKind(o)) {
1:             BinaryOperatorNode other = (BinaryOperatorNode)o;
1:             return methodName.equals(other.methodName)
1:                     && leftOperand.isEquivalent(other.leftOperand)
1:                     && rightOperand.isEquivalent(other.rightOperand);
1:         } else {
1:             return false;
1:     }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1: class BinaryOperatorNode extends OperatorNode
/////////////////////////////////////////////////////////////////////////
1:     final static int PLUS   = 1;
1:     final static int MINUS  = 2;
1:     final static int TIMES  = 3;
1:     final static int DIVIDE = 4;
1:     final static int CONCATENATE    = 5;
1:     final static int EQ = 6;
1:     final static int NE = 7;
1:     final static int GT = 8;
1:     final static int GE = 9;
1:     final static int LT = 10;
1:     final static int LE = 11;
1:     final static int AND    = 12;
1:     final static int OR = 13;
1:     final static int LIKE   = 14;
/////////////////////////////////////////////////////////////////////////
0:     final static int XMLEXISTS_OP = 0;
0:     final static int XMLQUERY_OP = 1;
/////////////////////////////////////////////////////////////////////////
1:     BinaryOperatorNode(ContextManager cm) {
1:         super(cm);
1:     }
1:     BinaryOperatorNode(
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             String operator,
1:             String methodName,
1:             String leftInterfaceType,
1:             String rightInterfaceType,
1:             ContextManager cm) {
1:         super(cm);
1:         this.leftOperand = leftOperand;
1:         this.rightOperand = rightOperand;
1:         this.operator = operator;
1:         this.methodName = methodName;
1:         this.leftInterfaceType = leftInterfaceType;
1:         this.rightInterfaceType = rightInterfaceType;
0:         this.operatorType = -1;
1:     }
1:     BinaryOperatorNode(
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             String leftInterfaceType,
1:             String rightInterfaceType,
1:             ContextManager cm)
1:         super(cm);
1:         this.leftOperand = leftOperand;
1:         this.rightOperand = rightOperand;
1:         this.leftInterfaceType = leftInterfaceType;
1:         this.rightInterfaceType = rightInterfaceType;
0:      * Constructor for a BinaryOperatorNode
1:     BinaryOperatorNode(
0:             int nodeType,
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
0:             int opType,
1:             ContextManager cm)
1:         super(cm);
0:         setNodeType(nodeType);
1:         this.leftOperand = leftOperand;
1:         this.rightOperand = rightOperand;
0:         this.operatorType = opType;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setLeftRightInterfaceType(String iType)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode genSQLJavaSQLTree() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setLeftOperand(ValueNode newLeftOperand)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getLeftOperand()
/////////////////////////////////////////////////////////////////////////
1:     void setRightOperand(ValueNode newRightOperand)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getRightOperand()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     String getReceiverInterfaceName() throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:                     Types.SQLXML));
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:     ValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
1:             aggregates);
1:             aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:6d90df0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d09782a
/////////////////////////////////////////////////////////////////////////
1:         // The number of arguments to pass to the method that implements the
1:         // operator, depends on the type of the operator.
1:         int numArgs;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             // We've pushed two arguments
1:             numArgs = 2;
/////////////////////////////////////////////////////////////////////////
1: 			**  <right expression>.method(sqlXmlUtil)
0:             if (xmlGen) {
1:                 // Push one argument (the SqlXmlUtil instance)
1:                 numArgs = 1;
1:                 pushSqlXmlUtil(acb, mb, xmlQuery, operator);
1:                 // stack: right,sqlXmlUtil
1:             } else {
1:                 // Push two arguments (left, right)
1:                 numArgs = 2;
1: 
1:                 leftOperand.generateExpression(acb, mb);
1:                 mb.cast(leftInterfaceType); // second arg with cast
1:                 // stack: right,right,left
1: 
1:                 mb.swap();
1:                 // stack: right,left,right
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // Boolean return types don't need a result field. For other types,
1:         // allocate an object for re-use to hold the result of the operator.
1:         LocalField resultField = getTypeId().isBooleanTypeId() ?
1:             null : acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1:         // Push the result field onto the stack, if there is a result field.
1: 		if (resultField != null) {
/////////////////////////////////////////////////////////////////////////
1:             // Adjust number of arguments for the result field
1:             numArgs++;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 numArgs++;
1:         }
0:         mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
1:                       methodName, resultTypeName, numArgs);
1: 
1:         // Store the result of the method call, if there is a result field.
1:         if (resultField != null) {
/////////////////////////////////////////////////////////////////////////
commit:2a09eb5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:044afae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class BinaryOperatorNode extends OperatorNode
/////////////////////////////////////////////////////////////////////////
1:     /** The query expression if the operator is XMLEXISTS or XMLQUERY. */
1:     private String xmlQuery;
/////////////////////////////////////////////////////////////////////////
1:             xmlQuery = ((CharConstantNode)leftOperand).getString();
1: 
0:             // Compile the query expression. The compiled query will not be
0:             // used, as each activation will need to compile its own version.
0:             // But we still do this here to get a compile-time error in case
0:             // the query expression has syntax errors.
0:             new SqlXmlUtil().compileXQExpr(xmlQuery, operator);
/////////////////////////////////////////////////////////////////////////
0:             pushSqlXmlUtil(acb, mb, xmlQuery, operator);
0:             mb.pushNewComplete(1);
/////////////////////////////////////////////////////////////////////////
commit:0af1665
/////////////////////////////////////////////////////////////////////////
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (leftOperand != null)
1: 		if (rightOperand != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:                     JDBC40Translation.SQLXML));
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: 			if ((getTypeServices() != null) &&
1: 				((jdbcType = getTypeServices().getJDBCTypeId()) == java.sql.Types.DECIMAL ||
1: 				mb.push(getTypeServices().getScale());		// 4th arg
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:         /**
0:          * @inheritDoc
1:          */
0:         protected boolean isEquivalent(ValueNode o) throws StandardException
1:         {
0:         	if (!isSameNodeType(o))
1:         	{
0:         		return false;
1:         	}
0:         	BinaryOperatorNode other = (BinaryOperatorNode)o;
0:         	return methodName.equals(other.methodName)
0:         	       && leftOperand.isEquivalent(other.leftOperand)
0:         	       && rightOperand.isEquivalent(other.rightOperand);
1:         }
1: 
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 					// to leave the DataValueDescriptor value on the stack, since setWidth is void
1: 					mb.dup();
1: 
1: 					mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (leftTypeId.userType())
1: 		if (rightTypeId.userType())
commit:0f7310e
/////////////////////////////////////////////////////////////////////////
0: 					mb.cast(resultTypeName);
commit:1880322
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			** Generate (with <left expression> only being evaluated once)
1: 			**	<left expression>.method(<left expression>, <right expression>...)
1: 			// stack: left
1: 			
1: 			mb.dup();
1: 			mb.cast(leftInterfaceType);
1: 			// stack: left, left
1: 			
1: 			rightOperand.generateExpression(acb, mb);
1: 			mb.cast(rightInterfaceType); // second arg with cast
1: 			// stack: left, left, right
/////////////////////////////////////////////////////////////////////////
1: 			** Generate (with <right expression> only being evaluated once)
1: 			**	<right expression>.method(<left expression>, <right expression>)
1: 			rightOperand.generateExpression(acb, mb);			
1: 			// stack: right
1: 			
0: 			mb.dup();
0: 			mb.cast(rightInterfaceType);
0: 			// stack: right,right
1: 			
1: 			leftOperand.generateExpression(acb, mb);
0: 			mb.cast(leftInterfaceType); // second arg with cast
0: 			// stack: right,right,left
1: 			
0: 			mb.swap();
0: 			// stack: right,left,right			
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.BinaryOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: import java.lang.reflect.Modifier;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A BinaryOperatorNode represents a built-in binary operator as defined by
0:  * the ANSI/ISO SQL standard.  This covers operators like +, -, *, /, =, <, etc.
1:  * Java operators are not represented here: the JSQL language allows Java
1:  * methods to be called from expressions, but not Java operators.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class BinaryOperatorNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	String	operator;
1: 	String	methodName;
1: 	ValueNode	receiver; // used in generation
1: 
1: 	/*
1: 	** These identifiers are used in the grammar.
1: 	*/
0: 	public final static int PLUS	= 1;
0: 	public final static int MINUS	= 2;
0: 	public final static int TIMES	= 3;
0: 	public final static int DIVIDE	= 4;
0: 	public final static int CONCATENATE	= 5;
0: 	public final static int EQ	= 6;
0: 	public final static int NE	= 7;
0: 	public final static int GT	= 8;
0: 	public final static int GE	= 9;
0: 	public final static int LT	= 10;
0: 	public final static int LE	= 11;
0: 	public final static int AND	= 12;
0: 	public final static int OR	= 13;
0: 	public final static int LIKE	= 14;
1: 
1: 	ValueNode	leftOperand;
1: 	ValueNode	rightOperand;
1: 
1: 	String		leftInterfaceType;
1: 	String		rightInterfaceType;
1: 
1: 	/**
0: 	 * Initializer for a BinaryOperatorNode
1: 	 *
1: 	 * @param leftOperand	The left operand of the node
1: 	 * @param rightOperand	The right operand of the node
0: 	 * @param operator		The name of the operator
0: 	 * @param methodName	The name of the method to call for this operator
0: 	 * @param leftInterfaceType	The name of the interface for the left operand
0: 	 * @param rightInterfaceType	The name of the interface for the right
0: 	 *								operand
1: 	 */
1: 
0: 	public void init(
0: 			Object leftOperand,
0: 			Object rightOperand,
0: 			Object operator,
0: 			Object methodName,
0: 			Object leftInterfaceType,
0: 			Object rightInterfaceType)
1: 	{
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.operator = (String) operator;
0: 		this.methodName = (String) methodName;
0: 		this.leftInterfaceType = (String) leftInterfaceType;
0: 		this.rightInterfaceType = (String) rightInterfaceType;
1: 	}
1: 
0: 	public void init(
0: 			Object leftOperand,
0: 			Object rightOperand,
0: 			Object leftInterfaceType,
0: 			Object rightInterfaceType)
1: 	{
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.leftInterfaceType = (String) leftInterfaceType;
0: 		this.rightInterfaceType = (String) rightInterfaceType;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "operator: " + operator + "\n" +
1: 				"methodName: " + methodName + "\n" + 
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Set the operator.
1: 	 *
1: 	 * @param operator	The operator.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setOperator(String operator)
1: 	{
1: 		this.operator = operator;
1: 	}
1: 
1: 	/**
1: 	 * Set the methodName.
1: 	 *
1: 	 * @param methodName	The methodName.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setMethodName(String methodName)
1: 	{
1: 		this.methodName = methodName;
1: 	}
1: 
1: 	/**
1: 	 * Set the interface type for the left and right arguments.
1: 	 * Used when we don't know the interface type until
1: 	 * later in binding.
1: 	 *
0: 	 * @return void
1: 	 */
0: 	public void setLeftRightInterfaceType(String iType)
1: 	{
1: 		leftInterfaceType = iType;
1: 		rightInterfaceType = iType;
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		leftOperand.setClause(clause);
0: 		rightOperand.setClause(clause);
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (leftOperand != null)
1: 			{
1: 				printLabel(depth, "leftOperand: ");
1: 				leftOperand.treePrint(depth + 1);
1: 			}
1: 
1: 			if (rightOperand != null)
1: 			{
1: 				printLabel(depth, "rightOperand: ");
1: 				rightOperand.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
1: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
1: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
1: 
1: 
1: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
1: 		{
1: 			/*
1: 			** It's an error if both operands are ? parameters.
1: 			*/
0: 			if (rightOperand.isParameterNode())
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
1: 																	operator);
1: 			}
1: 
1: 			/* Set the left operand to the type of right parameter. */
0: 			((ParameterNode) leftOperand).setDescriptor(rightOperand.getTypeServices());
1: 		}
1: 
1: 		/* Is there a ? parameter on the right? */
0: 		if (rightOperand.isParameterNode())
1: 		{
1: 			/* Set the right operand to the type of the left parameter. */
0: 			((ParameterNode) rightOperand).setDescriptor(leftOperand.getTypeServices());
1: 		}
1: 
1: 		return genSQLJavaSQLTree();
1: 	}
1: 
0: 	/** generate a SQL->Java->SQL conversion tree above the left and right
1: 	 * operand of this Binary Operator Node if needed. Subclasses can override
1: 	 * the default behavior.
1: 	 */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
1: 	{
1: 		TypeId leftTypeId = leftOperand.getTypeId();
1: 		
0: 		if (!(leftTypeId.systemBuiltIn()))
1: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1: 
1: 		TypeId rightTypeId = rightOperand.getTypeId();
0: 		if (!(rightTypeId.systemBuiltIn()))
1: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		leftOperand = leftOperand.preprocess(numTables,
1: 											 outerFromList, outerSubqueryList,
1: 											 outerPredicateList);
1: 		rightOperand = rightOperand.preprocess(numTables,
1: 											   outerFromList, outerSubqueryList,
1: 											   outerPredicateList);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this binary operator.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the code to place the code
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 		throws StandardException
1: 	{
1: 		String		resultTypeName;
0: 		LocalField	receiverField;
1: 		String		receiverType;
1: 
1: /*
1: ** if i have a operator.getOrderableType() == constant, then just cache 
1: ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
1: ** cache it in something that is initialized each execution,
1: ** but how?
1: */
1: 
1: 
1: 		/*
1: 		** The receiver is the operand with the higher type precedence.
1: 		** Like always makes the left the receiver.
1: 		**
0: 		** Allocate an object for re-use to hold the receiver.  This is because
0: 		** the receiver is passed to the method as one of the parameters,
0: 		** and we don't want to evaluate it twice.
1: 		*/
1: 		if (leftOperand.getTypeId().typePrecedence() >
1: 			rightOperand.getTypeId().typePrecedence())
1: 		{
1: 			receiver = leftOperand;
1: 			/*
1: 			** let the receiver type be determined by an
1: 			** overridable method so that if methods are
1: 			** not implemented on the lowest interface of
1: 			** a class, they can note that in the implementation
1: 			** of the node that uses the method.
1: 			*/
0: 		    receiverType = getReceiverInterfaceName();
1: 
1: 			/*
0: 			** Generate (field = <left expression>).  This assignment is
0: 			** used as the receiver of the method call for this operator,
0: 			** and the field is used as the left operand:
1: 			**
0: 			**	(field = <left expression>).method(field, <right expression>...)
1: 			*/
0: 			receiverField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
1: 
0: 			leftOperand.generateExpression(acb, mb);
0: 			mb.putField(receiverField); // method instance
1: 			mb.cast(receiverType); // cast the method instance
0: 			mb.getField(receiverField); mb.cast(leftInterfaceType); // first arg with cast
0: 			rightOperand.generateExpression(acb, mb); mb.cast(rightInterfaceType); // second arg with cast
1: 		}
1: 		else
1: 		{
1: 			receiver = rightOperand;
1: 			/*
1: 			** let the receiver type be determined by an
1: 			** overridable method so that if methods are
1: 			** not implemented on the lowest interface of
1: 			** a class, they can note that in the implementation
1: 			** of the node that uses the method.
1: 			*/
0: 		    receiverType = getReceiverInterfaceName();
1: 
1: 			/*
0: 			** Generate (field = <right expression>).  This assignment is
0: 			** used as the receiver of the method call for this operator,
0: 			** and the field is used as the right operand:
1: 			**
0: 			**	(field = <right expression>).method(<left expression>, field...)
1: 			*/
0: 			receiverField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, rightInterfaceType);
1: 
0: 			rightOperand.generateExpression(acb, mb);
0: 			mb.putField(receiverField); // method instance
1: 			mb.cast(receiverType); // cast the method instance
0: 			leftOperand.generateExpression(acb, mb); mb.cast(leftInterfaceType); // second arg with cast
0: 			mb.getField(receiverField); mb.cast(rightInterfaceType); // first arg with cast
1: 		}
1: 
1: 		/* Figure out the result type name */
0: 		resultTypeName = getTypeCompiler().interfaceName();
1: 
0: 		// Boolean return types don't need a result field
0: 		boolean needField = !getTypeId().isBooleanTypeId();
1: 
0: 		if (needField) {
1: 
0: 			/* Allocate an object for re-use to hold the result of the operator */
0: 			LocalField resultField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1: 
1: 			/*
1: 			** Call the method for this operator.
1: 			*/
1: 			mb.getField(resultField); // third arg
0: 			//following method is special code for concatenation where if field is null, we want it to be initialized to NULL SQLxxx type object
0: 			//before generating code "field = method(p1, p2, field);"
0: 			initializeResultField(acb, mb, resultField);
1: 
1: 			/* pass statically calculated scale to decimal divide method to make
1: 			 * result set scale consistent, beetle 3901
1: 			 */
1: 			int jdbcType;
0: 			if ((dataTypeServices != null) &&
0: 				((jdbcType = dataTypeServices.getJDBCTypeId()) == java.sql.Types.DECIMAL ||
1: 				 jdbcType == java.sql.Types.NUMERIC) &&
1: 				operator.equals("/"))
1: 			{
0: 				mb.push(dataTypeServices.getScale());		// 4th arg
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 4);
1: 			}
1: 			else
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
1: 
1: 			//the need for following if was realized while fixing bug 5704 where decimal*decimal was resulting an overflow value but we were not detecting it
1: 			if (getTypeId().variableLength())//since result type is numeric variable length, generate setWidth code.
1: 			{
1: 				if (getTypeId().isNumericTypeId())
1: 				{
1: 					mb.push(getTypeServices().getPrecision());
1: 					mb.push(getTypeServices().getScale());
1: 					mb.push(true);
0: 					mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
1: 				}
1: 			}
1: 
1: 
1: 			/*
1: 			** Store the result of the method call in the field, so we can re-use
1: 			** the object.
1: 			*/
1: 
1: 			mb.putField(resultField);
0: 		} else {
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 2);
1: 		}
1: 	}
1: 
0: 	//following method is no-op here but in concatenation node, this method is used to check if resultField is null,
0: 	//and if yes, then we want it to be initialized to NULL SQLxxx type object
0: 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Set the leftOperand to the specified ValueNode
1: 	 *
1: 	 * @param newLeftOperand	The new leftOperand
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setLeftOperand(ValueNode newLeftOperand)
1: 	{
1: 		leftOperand = newLeftOperand;
1: 	}
1: 
1: 	/**
1: 	 * Get the leftOperand
1: 	 *
1: 	 * @return The current leftOperand.
1: 	 */
0: 	public ValueNode getLeftOperand()
1: 	{
1: 		return leftOperand;
1: 	}
1: 
1: 	/**
1: 	 * Set the rightOperand to the specified ValueNode
1: 	 *
1: 	 * @param newRightOperand	The new rightOperand
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setRightOperand(ValueNode newRightOperand)
1: 	{
1: 		rightOperand = newRightOperand;
1: 	}
1: 
1: 	/**
1: 	 * Get the rightOperand
1: 	 *
1: 	 * @return The current rightOperand.
1: 	 */
0: 	public ValueNode getRightOperand()
1: 	{
1: 		return rightOperand;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		boolean pushable;
1: 		pushable = leftOperand.categorize(referencedTabs, simplePredsOnly);
1: 		pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
1: 		rightOperand = rightOperand.remapColumnReferencesToExpressions();
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return (leftOperand.isConstantExpression() &&
1: 				rightOperand.isConstantExpression());
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return (leftOperand.constantExpression(whereClause) &&
1: 				rightOperand.constantExpression(whereClause));
1: 	}
1: 
1: 	/**
1: 	 * Determine the type the binary method is called on.
1: 	 * By default, based on the receiver.
1: 	 *
1: 	 * Override in nodes that use methods on super-interfaces of
1: 	 * the receiver's interface, such as comparisons.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public String getReceiverInterfaceName() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(receiver!=null,"can't get receiver interface name until receiver is set");
1: 		}
1: 
1: 		return receiver.getTypeCompiler().interfaceName();
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *		CONSTANT			- immutable
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		int leftType = leftOperand.getOrderableVariantType();
1: 		int rightType = rightOperand.getOrderableVariantType();
1: 
1: 		return Math.min(leftType, rightType);
1: 	}
1: 
1: 	/**
0: 	 * Swap the left and right sides.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void swapOperands()
1: 	{
0: 		String	  tmpInterfaceType = leftInterfaceType;
0: 		ValueNode tmpVN = leftOperand;
1: 
0: 		leftOperand = rightOperand;
0: 		rightOperand = tmpVN;
0: 		leftInterfaceType = rightInterfaceType;
0: 		rightInterfaceType = tmpInterfaceType;
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 	
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (leftOperand != null && !v.stopTraversal())
1: 		{
1: 			leftOperand = (ValueNode)leftOperand.accept(v);
1: 		}
1: 
0: 		if (rightOperand != null && !v.stopTraversal())
1: 		{
1: 			rightOperand = (ValueNode)rightOperand.accept(v);
1: 		}
1: 		
0: 		return returnNode;
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8cf0ef9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			leftOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			rightOperand.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			leftOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema().getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			rightOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			rightOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: 		/* If this BinaryOperatorNode was created as a part of an IN-list
1: 		 * "probe predicate" then we do not want to generate the relational
1: 		 * operator itself; instead we want to generate the underlying
1: 		 * IN-list for which this operator node was created.
0: 		 *
1: 		 * We'll get here in situations where the optimizer chooses a plan
1: 		 * for which the probe predicate is *not* a useful start/stop key
1: 		 * and thus is not being used for execution-time index probing.
1: 		 * In this case we are effectively "reverting" the probe predicate
1: 		 * back to the InListOperatorNode from which it was created.  Or put
1: 		 * another way, we are "giving up" on index multi-probing and simply
1: 		 * generating the original IN-list as a regular restriction.
0: 		 */
1: 		if (this instanceof BinaryRelationalOperatorNode)
0: 		{
1: 			InListOperatorNode ilon =
1: 				((BinaryRelationalOperatorNode)this).getInListOp();
0: 
1: 			if (ilon != null)
0: 			{
1: 				ilon.generateExpression(acb, mb);
1: 				return;
0: 			}
0: 		}
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 		if (leftOperand.requiresTypeFromContext())
1: 			if (rightOperand.requiresTypeFromContext())
1: 			leftOperand.setType(rightOperand.getTypeServices());
1: 		if (rightOperand.requiresTypeFromContext())
1: 			rightOperand.setType(leftOperand.getTypeServices());
/////////////////////////////////////////////////////////////////////////
0:         if (leftOperand.requiresTypeFromContext())
0:             leftOperand.setType(
1:         if (rightOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1: 	String		resultInterfaceType;
0: 	int			operatorType;
0: 
1: 	// At the time of adding XML support, it was decided that
1: 	// we should avoid creating new OperatorNodes where possible.
1: 	// So for the XML-related binary operators we just add the
1: 	// necessary code to _this_ class, similar to what is done in
1: 	// TernarnyOperatorNode. Subsequent binary operators (whether
1: 	// XML-related or not) should follow this example when
1: 	// possible.
0: 
0: 	public final static int XMLEXISTS_OP = 0;
0: 
1: 	// NOTE: in the following 4 arrays, order
1: 	// IS important.
0: 
1: 	static final String[] BinaryOperators = {
1: 		"xmlexists",
1: 	};
0: 
1: 	static final String[] BinaryMethodNames = {
1: 		"XMLExists",
1: 	};
0: 
1: 	static final String[] BinaryResultTypes = {
0: 		ClassName.BooleanDataValue		// XMLExists
1: 	};
0: 
1: 	static final String[][] BinaryArgTypes = {
0: 		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLExists
1: 	};
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a BinaryOperatorNode
0: 	 *
0: 	 * @param leftOperand	The left operand of the node
0: 	 * @param rightOperand	The right operand of the node
0: 	 * @param opType  An Integer holding the operatorType
0: 	 *  for this operator.
0: 	 */
0: 	public void init(
0: 			Object leftOperand,
0: 			Object rightOperand,
0: 			Object opType)
0: 	{
0: 		this.leftOperand = (ValueNode)leftOperand;
0: 		this.rightOperand = (ValueNode)rightOperand;
0: 		this.operatorType = ((Integer)opType).intValue();
0: 		this.operator = BinaryOperators[this.operatorType];
0: 		this.methodName = BinaryMethodNames[this.operatorType];
0: 		this.leftInterfaceType = BinaryArgTypes[this.operatorType][0];
0: 		this.rightInterfaceType = BinaryArgTypes[this.operatorType][1];
0: 		this.resultInterfaceType = BinaryResultTypes[this.operatorType];
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.operatorType = -1;
/////////////////////////////////////////////////////////////////////////
0: 		if (operatorType == XMLEXISTS_OP)
0: 			return bindXMLExists();
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Bind an XMLEXISTS operator.  Makes sure the operand type
0:      * and target type are both correct, and sets the result type.
0:      *
1:      * @exception StandardException Thrown on error
0:      */
0:     public ValueNode bindXMLExists() throws StandardException
0:     {
1:         // Check operand types.
0:         TypeId leftOperandType = leftOperand.getTypeId();
1:         TypeId rightOperandType = rightOperand.getTypeId();
0: 
0:         // Left operand is query expression, and must be a string.
0:         if (leftOperandType != null) {
0:             switch (leftOperandType.getJDBCTypeId())
0:             {
0:                 case Types.CHAR:
0:                 case Types.VARCHAR:
0:                 case Types.LONGVARCHAR:
0:                 case Types.CLOB:
0:                     break;
0:                 default:
0:                 {
1:                     throw StandardException.newException(
0:                         SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
0:                         methodName,
0:                         leftOperandType.getSQLTypeName(),
0:                         rightOperandType.getSQLTypeName());
0:                 }
0:             }
0:         }
0: 
0:         // Right operand is an XML data value.
1:         if ((rightOperandType != null) &&
1:             !rightOperandType.isXMLTypeId())
0:         {
1:             throw StandardException.newException(
0:                 SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
0:                     methodName,
0:                     leftOperandType.getSQLTypeName(),
0:                     rightOperandType.getSQLTypeName());
0:         }
0: 
0:         // Is there a ? parameter on the left?
0:         if (leftOperand.isParameterNode())
0:         {
0:             // Set the left operand to be a VARCHAR, which should be
0:             // long enough to hold the XPath expression.
0:             ((ParameterNode) leftOperand).setDescriptor(
0:                 DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR));
0:         }
0: 
1:         // Is there a ? parameter on the right?
0:         if (rightOperand.isParameterNode())
0:         {
1:             // For now, since JDBC has no type defined for XML, we
1:             // don't allow binding to an XML parameter.
1:             throw StandardException.newException(
1:                 SQLState.LANG_ATTEMPT_TO_BIND_XML);
0:         }
0: 
0:         // Set the result type of this XMLExists operator--it's always
0:         // SQLBoolean.  The "true" in the next line says that the result
0:         // can be nullable--which it can be if evaluation of the expression
0:         // returns a null (this is per SQL/XML spec section 8.4).
0:         setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
1:         return genSQLJavaSQLTree();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 		    receiverType = (operatorType == -1)
1: 				? getReceiverInterfaceName()
1: 				: leftInterfaceType;
/////////////////////////////////////////////////////////////////////////
0: 		    receiverType = (operatorType == -1)
1: 				? getReceiverInterfaceName()
1: 				: rightInterfaceType;
/////////////////////////////////////////////////////////////////////////
0: 		resultTypeName = (operatorType == -1)
1: 			? getTypeCompiler().interfaceName()
1: 			: resultInterfaceType;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A BinaryOperatorNode represents a built-in binary operator as defined by
0:  * the ANSI/ISO SQL standard.  This covers operators like +, -, *, /, =, <, etc.
0:  * Java operators are not represented here: the JSQL language allows Java
0:  * methods to be called from expressions, but not Java operators.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class BinaryOperatorNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	String	operator;
0: 	String	methodName;
0: 	ValueNode	receiver; // used in generation
0: 
0: 	/*
0: 	** These identifiers are used in the grammar.
0: 	*/
0: 	public final static int PLUS	= 1;
0: 	public final static int MINUS	= 2;
0: 	public final static int TIMES	= 3;
0: 	public final static int DIVIDE	= 4;
0: 	public final static int CONCATENATE	= 5;
0: 	public final static int EQ	= 6;
0: 	public final static int NE	= 7;
0: 	public final static int GT	= 8;
0: 	public final static int GE	= 9;
0: 	public final static int LT	= 10;
0: 	public final static int LE	= 11;
0: 	public final static int AND	= 12;
0: 	public final static int OR	= 13;
0: 	public final static int LIKE	= 14;
0: 
0: 	ValueNode	leftOperand;
0: 	ValueNode	rightOperand;
0: 
0: 	String		leftInterfaceType;
0: 	String		rightInterfaceType;
0: 
0: 	/**
0: 	 * Initializer for a BinaryOperatorNode
0: 	 *
0: 	 * @param leftOperand	The left operand of the node
0: 	 * @param rightOperand	The right operand of the node
0: 	 * @param operator		The name of the operator
0: 	 * @param methodName	The name of the method to call for this operator
0: 	 * @param leftInterfaceType	The name of the interface for the left operand
0: 	 * @param rightInterfaceType	The name of the interface for the right
0: 	 *								operand
0: 	 */
0: 
0: 	public void init(
0: 			Object leftOperand,
0: 			Object rightOperand,
0: 			Object operator,
0: 			Object methodName,
0: 			Object leftInterfaceType,
0: 			Object rightInterfaceType)
0: 	{
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.operator = (String) operator;
0: 		this.methodName = (String) methodName;
0: 		this.leftInterfaceType = (String) leftInterfaceType;
0: 		this.rightInterfaceType = (String) rightInterfaceType;
0: 	}
0: 
0: 	public void init(
0: 			Object leftOperand,
0: 			Object rightOperand,
0: 			Object leftInterfaceType,
0: 			Object rightInterfaceType)
0: 	{
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.leftInterfaceType = (String) leftInterfaceType;
0: 		this.rightInterfaceType = (String) rightInterfaceType;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "operator: " + operator + "\n" +
0: 				"methodName: " + methodName + "\n" + 
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the operator.
0: 	 *
0: 	 * @param operator	The operator.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setOperator(String operator)
0: 	{
0: 		this.operator = operator;
0: 	}
0: 
0: 	/**
0: 	 * Set the methodName.
0: 	 *
0: 	 * @param methodName	The methodName.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setMethodName(String methodName)
0: 	{
0: 		this.methodName = methodName;
0: 	}
0: 
0: 	/**
0: 	 * Set the interface type for the left and right arguments.
0: 	 * Used when we don't know the interface type until
0: 	 * later in binding.
0: 	 *
0: 	 * @return void
0: 	 */
0: 	public void setLeftRightInterfaceType(String iType)
0: 	{
0: 		leftInterfaceType = iType;
0: 		rightInterfaceType = iType;
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		leftOperand.setClause(clause);
0: 		rightOperand.setClause(clause);
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (leftOperand != null)
0: 			{
0: 				printLabel(depth, "leftOperand: ");
0: 				leftOperand.treePrint(depth + 1);
0: 			}
0: 
0: 			if (rightOperand != null)
0: 			{
0: 				printLabel(depth, "rightOperand: ");
0: 				rightOperand.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
0: 		rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
0: 
0: 
0: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			/*
0: 			** It's an error if both operands are ? parameters.
0: 			*/
0: 			if (rightOperand.isParameterNode())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
0: 																	operator);
0: 			}
0: 
0: 			/* Set the left operand to the type of right parameter. */
0: 			((ParameterNode) leftOperand).setDescriptor(rightOperand.getTypeServices());
0: 		}
0: 
0: 		/* Is there a ? parameter on the right? */
0: 		if (rightOperand.isParameterNode())
0: 		{
0: 			/* Set the right operand to the type of the left parameter. */
0: 			((ParameterNode) rightOperand).setDescriptor(leftOperand.getTypeServices());
0: 		}
0: 
0: 		return genSQLJavaSQLTree();
0: 	}
0: 
0: 	/** generate a SQL->Java->SQL conversion tree above the left and right
0: 	 * operand of this Binary Operator Node if needed. Subclasses can override
0: 	 * the default behavior.
0: 	 */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
0: 	{
0: 		TypeId leftTypeId = leftOperand.getTypeId();
0: 		
0: 		if (!(leftTypeId.systemBuiltIn()))
0: 			leftOperand = leftOperand.genSQLJavaSQLTree();
0: 
0: 		TypeId rightTypeId = rightOperand.getTypeId();
0: 		if (!(rightTypeId.systemBuiltIn()))
0: 			rightOperand = rightOperand.genSQLJavaSQLTree();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		leftOperand = leftOperand.preprocess(numTables,
0: 											 outerFromList, outerSubqueryList,
0: 											 outerPredicateList);
0: 		rightOperand = rightOperand.preprocess(numTables,
0: 											   outerFromList, outerSubqueryList,
0: 											   outerPredicateList);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this binary operator.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the code to place the code
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		String		resultTypeName;
0: 		LocalField	receiverField;
0: 		String		receiverType;
0: 
0: /*
0: ** if i have a operator.getOrderableType() == constant, then just cache 
0: ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
0: ** cache it in something that is initialized each execution,
0: ** but how?
0: */
0: 
0: 
0: 		/*
0: 		** The receiver is the operand with the higher type precedence.
0: 		** Like always makes the left the receiver.
0: 		**
0: 		** Allocate an object for re-use to hold the receiver.  This is because
0: 		** the receiver is passed to the method as one of the parameters,
0: 		** and we don't want to evaluate it twice.
0: 		*/
0: 		if (leftOperand.getTypeId().typePrecedence() >
0: 			rightOperand.getTypeId().typePrecedence())
0: 		{
0: 			receiver = leftOperand;
0: 			/*
0: 			** let the receiver type be determined by an
0: 			** overridable method so that if methods are
0: 			** not implemented on the lowest interface of
0: 			** a class, they can note that in the implementation
0: 			** of the node that uses the method.
0: 			*/
0: 		    receiverType = getReceiverInterfaceName();
0: 
0: 			/*
0: 			** Generate (field = <left expression>).  This assignment is
0: 			** used as the receiver of the method call for this operator,
0: 			** and the field is used as the left operand:
0: 			**
0: 			**	(field = <left expression>).method(field, <right expression>...)
0: 			*/
0: 			receiverField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
0: 
0: 			leftOperand.generateExpression(acb, mb);
0: 			mb.putField(receiverField); // method instance
0: 			mb.cast(receiverType); // cast the method instance
0: 			mb.getField(receiverField); mb.cast(leftInterfaceType); // first arg with cast
0: 			rightOperand.generateExpression(acb, mb); mb.cast(rightInterfaceType); // second arg with cast
0: 		}
0: 		else
0: 		{
0: 			receiver = rightOperand;
0: 			/*
0: 			** let the receiver type be determined by an
0: 			** overridable method so that if methods are
0: 			** not implemented on the lowest interface of
0: 			** a class, they can note that in the implementation
0: 			** of the node that uses the method.
0: 			*/
0: 		    receiverType = getReceiverInterfaceName();
0: 
0: 			/*
0: 			** Generate (field = <right expression>).  This assignment is
0: 			** used as the receiver of the method call for this operator,
0: 			** and the field is used as the right operand:
0: 			**
0: 			**	(field = <right expression>).method(<left expression>, field...)
0: 			*/
0: 			receiverField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, rightInterfaceType);
0: 
0: 			rightOperand.generateExpression(acb, mb);
0: 			mb.putField(receiverField); // method instance
0: 			mb.cast(receiverType); // cast the method instance
0: 			leftOperand.generateExpression(acb, mb); mb.cast(leftInterfaceType); // second arg with cast
0: 			mb.getField(receiverField); mb.cast(rightInterfaceType); // first arg with cast
0: 		}
0: 
0: 		/* Figure out the result type name */
0: 		resultTypeName = getTypeCompiler().interfaceName();
0: 
0: 		// Boolean return types don't need a result field
0: 		boolean needField = !getTypeId().isBooleanTypeId();
0: 
0: 		if (needField) {
0: 
0: 			/* Allocate an object for re-use to hold the result of the operator */
0: 			LocalField resultField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
0: 
0: 			/*
0: 			** Call the method for this operator.
0: 			*/
0: 			mb.getField(resultField); // third arg
0: 			//following method is special code for concatenation where if field is null, we want it to be initialized to NULL SQLxxx type object
0: 			//before generating code "field = method(p1, p2, field);"
0: 			initializeResultField(acb, mb, resultField);
0: 
0: 			/* pass statically calculated scale to decimal divide method to make
0: 			 * result set scale consistent, beetle 3901
0: 			 */
0: 			int jdbcType;
0: 			if ((dataTypeServices != null) &&
0: 				((jdbcType = dataTypeServices.getJDBCTypeId()) == java.sql.Types.DECIMAL ||
0: 				 jdbcType == java.sql.Types.NUMERIC) &&
0: 				operator.equals("/"))
0: 			{
0: 				mb.push(dataTypeServices.getScale());		// 4th arg
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 4);
0: 			}
0: 			else
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
0: 
0: 			//the need for following if was realized while fixing bug 5704 where decimal*decimal was resulting an overflow value but we were not detecting it
0: 			if (getTypeId().variableLength())//since result type is numeric variable length, generate setWidth code.
0: 			{
0: 				if (getTypeId().isNumericTypeId())
0: 				{
0: 					mb.push(getTypeServices().getPrecision());
0: 					mb.push(getTypeServices().getScale());
0: 					mb.push(true);
0: 					mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
0: 				}
0: 			}
0: 
0: 
0: 			/*
0: 			** Store the result of the method call in the field, so we can re-use
0: 			** the object.
0: 			*/
0: 
0: 			mb.putField(resultField);
0: 		} else {
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 2);
0: 		}
0: 	}
0: 
0: 	//following method is no-op here but in concatenation node, this method is used to check if resultField is null,
0: 	//and if yes, then we want it to be initialized to NULL SQLxxx type object
0: 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Set the leftOperand to the specified ValueNode
0: 	 *
0: 	 * @param newLeftOperand	The new leftOperand
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setLeftOperand(ValueNode newLeftOperand)
0: 	{
0: 		leftOperand = newLeftOperand;
0: 	}
0: 
0: 	/**
0: 	 * Get the leftOperand
0: 	 *
0: 	 * @return The current leftOperand.
0: 	 */
0: 	public ValueNode getLeftOperand()
0: 	{
0: 		return leftOperand;
0: 	}
0: 
0: 	/**
0: 	 * Set the rightOperand to the specified ValueNode
0: 	 *
0: 	 * @param newRightOperand	The new rightOperand
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setRightOperand(ValueNode newRightOperand)
0: 	{
0: 		rightOperand = newRightOperand;
0: 	}
0: 
0: 	/**
0: 	 * Get the rightOperand
0: 	 *
0: 	 * @return The current rightOperand.
0: 	 */
0: 	public ValueNode getRightOperand()
0: 	{
0: 		return rightOperand;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		boolean pushable;
0: 		pushable = leftOperand.categorize(referencedTabs, simplePredsOnly);
0: 		pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
0: 		rightOperand = rightOperand.remapColumnReferencesToExpressions();
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return (leftOperand.isConstantExpression() &&
0: 				rightOperand.isConstantExpression());
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return (leftOperand.constantExpression(whereClause) &&
0: 				rightOperand.constantExpression(whereClause));
0: 	}
0: 
0: 	/**
0: 	 * Determine the type the binary method is called on.
0: 	 * By default, based on the receiver.
0: 	 *
0: 	 * Override in nodes that use methods on super-interfaces of
0: 	 * the receiver's interface, such as comparisons.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getReceiverInterfaceName() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(receiver!=null,"can't get receiver interface name until receiver is set");
0: 		}
0: 
0: 		return receiver.getTypeCompiler().interfaceName();
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *		CONSTANT			- immutable
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		int leftType = leftOperand.getOrderableVariantType();
0: 		int rightType = rightOperand.getOrderableVariantType();
0: 
0: 		return Math.min(leftType, rightType);
0: 	}
0: 
0: 	/**
0: 	 * Swap the left and right sides.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void swapOperands()
0: 	{
0: 		String	  tmpInterfaceType = leftInterfaceType;
0: 		ValueNode tmpVN = leftOperand;
0: 
0: 		leftOperand = rightOperand;
0: 		rightOperand = tmpVN;
0: 		leftInterfaceType = rightInterfaceType;
0: 		rightInterfaceType = tmpInterfaceType;
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 	
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (leftOperand != null && !v.stopTraversal())
0: 		{
0: 			leftOperand = (ValueNode)leftOperand.accept(v);
0: 		}
0: 
0: 		if (rightOperand != null && !v.stopTraversal())
0: 		{
0: 			rightOperand = (ValueNode)rightOperand.accept(v);
0: 		}
0: 		
0: 		return returnNode;
0: 	}
0: }
============================================================================