1:32cefc3: /*
1:32cefc3: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForUpdateTest
8:32cefc3: 
1:32cefc3: Licensed to the Apache Software Foundation (ASF) under one or more
1:32cefc3: contributor license agreements.  See the NOTICE file distributed with
1:32cefc3: this work for additional information regarding copyright ownership.
1:32cefc3: The ASF licenses this file to You under the Apache License, Version 2.0
1:32cefc3: (the "License"); you may not use this file except in compliance with
1:32cefc3: the License.  You may obtain a copy of the License at
1:32cefc3: 
1:32cefc3: http://www.apache.org/licenses/LICENSE-2.0
1:32cefc3: 
1:32cefc3: Unless required by applicable law or agreed to in writing, software
1:32cefc3: distributed under the License is distributed on an "AS IS" BASIS,
1:32cefc3: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:32cefc3: See the License for the specific language governing permissions and
1:32cefc3: limitations under the License.
1:32cefc3: 
1:32cefc3: */
1:32cefc3: 
1:32cefc3: package org.apache.derbyTesting.functionTests.tests.lang;
1:32cefc3: 
1:32cefc3: import java.sql.Connection;
1:32cefc3: import java.sql.PreparedStatement;
1:32cefc3: import java.sql.ResultSet;
1:32cefc3: import java.sql.SQLException;
1:32cefc3: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:32cefc3: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:32cefc3: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:32cefc3: import org.apache.derbyTesting.junit.JDBC;
1:32cefc3: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:32cefc3: import org.apache.derbyTesting.junit.SQLUtilities;
1:32cefc3: import org.apache.derbyTesting.junit.TestConfiguration;
1:32cefc3: 
1:32cefc3: /**
1:32cefc3:  * Tests for forupdate. 
1:32cefc3:  *
1:32cefc3:  */
1:32cefc3: public class ForUpdateTest extends BaseJDBCTestCase {
1:32cefc3: 
1:32cefc3: 	/* Public constructor required for running test as standalone JUnit. */    
1:32cefc3: 	public ForUpdateTest(String name) {
1:32cefc3: 		super(name);
3:32cefc3: 	}
1:fc7482f:     
1:fc7482f:     /**
1:fc7482f:      * Sets the auto commit to false.
1:fc7482f:      */
1:fc7482f:     protected void initializeConnection(Connection conn) throws SQLException {
1:fc7482f:         conn.setAutoCommit(false);
1:fc7482f:     }
1:32cefc3: 
1:32cefc3: 	/**
1:32cefc3:          * Create a suite of tests.
1:32cefc3:          **/
1:32cefc3:         public static Test suite() {
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite("ForUpdateTest");
1:32cefc3:         	suite.addTest(baseSuite("ForUpdateTest:embedded"));
1:32cefc3:         	suite.addTest(TestConfiguration.clientServerDecorator(baseSuite("ForUpdateTest:client")));
1:32cefc3:         	return suite;
1:32cefc3:     	}
1:32cefc3: 
1:32cefc3: 	protected static Test baseSuite(String name) {
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite(name);
1:32cefc3:         	suite.addTestSuite(ForUpdateTest.class);	
1:32cefc3: 		return new CleanDatabaseTestSetup(suite) 
1:32cefc3:         	{
1:32cefc3:             		protected void decorateSQL(Statement s) throws SQLException
1:32cefc3:             		{
1:32cefc3:                 		s.execute("create table t1 ( i int, v varchar(10), d double precision, t time )");
1:32cefc3: 				s.execute("create table t2 ( s smallint, c char(10), r real, ts timestamp )");
1:32cefc3:                                 s.execute("create table t3 (i int not null constraint t3pk primary key, b char(10))");
1:32cefc3: 				s.execute("create table t4 (c1 int)");	
1:8a319fb:                                 s.execute("create index t3bi on t3(b)");
1:8a319fb:                                 s.execute("insert into t3 values (1, 'hhhh'), (2, 'uuuu'), (3, 'yyyy'), (4, 'aaaa'), (5, 'jjjj'), (6, 'rrrr')");
1:8a319fb:                                 s.execute("insert into t3 values (7, 'iiii'), (8, 'wwww'), (9, 'rrrr'), (10, 'cccc'), (11, 'hhhh'), (12, 'rrrr')");
1:8a319fb:                                 s.execute("insert into t4 (c1) values (1),(2),(3)");
1:32cefc3:             		}
1:32cefc3:         	};
1:32cefc3:     	} 
1:32cefc3: 
1:32cefc3:         public void testNegative() throws SQLException {    
1:fc7482f: 		assertCompileError("42X01", "select i, v from t1 for");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 for read");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 for only");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 for update of");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 update");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 only");
1:fc7482f:         assertCompileError("42X01", "select i, v from t1 read");
1:fc7482f:         
1:fc7482f:         Statement stmt = createStatement();
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update"));
1:fc7482f:         stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 	public void testCursor() throws SQLException {	
1:fc7482f:         Statement stmt = createStatement();
1:32cefc3:  		stmt.setCursorName("C");
1:32cefc3: 		stmt.executeQuery("select i, v from t1, t2");
1:32cefc3:                 Statement stmt2 = createStatement();
1:32cefc3: 		try {
1:32cefc3: 			stmt2.executeUpdate("delete from t1 where current of C");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			if (usingEmbedded())
1:32cefc3: 				assertSQLState("42X23", e);
1:32cefc3:                         else
1:32cefc3: 				assertSQLState("42X30", e);
1:32cefc3: 
1:32cefc3: 		}
1:32cefc3:                 
1:32cefc3:                 try {
1:32cefc3:                      stmt2.executeQuery("select i, v from t1, t2");
1:32cefc3:                 } catch (SQLException e ) {
1:32cefc3:                      assertSQLState("X0X60", e);
1:32cefc3:                 }
1:32cefc3:                 stmt2.close();
1:fc7482f:                 stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3:          
1:32cefc3:         public void testCursor1() throws SQLException {	
1:fc7482f:             Statement stmt = createStatement();
1:32cefc3: 		stmt.setCursorName("C1");
1:32cefc3: 		ResultSet rs = stmt.executeQuery("select i, v from t1 where i is not null");
1:32cefc3: 		Statement stmt2 = createStatement();
1:32cefc3: 		try {
1:32cefc3: 			stmt2.executeUpdate("delete from t1 where current of C1");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			if (usingEmbedded())
1:32cefc3: 			    assertSQLState("42X23", e);
1:32cefc3: 			else
1:32cefc3: 			    assertSQLState("42X30", e);
1:32cefc3: 		}
1:32cefc3: 		stmt2.close();
1:32cefc3:                 rs.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3: 
1:32cefc3:         public void testCursor2() throws SQLException {	
1:fc7482f:             Statement stmt = createStatement();
1:32cefc3: 		stmt.setCursorName("C2");
1:32cefc3: 		ResultSet rs = stmt.executeQuery("select i, v from t1, t2 for read only");
1:32cefc3: 		Statement stmt2 = createStatement();
1:32cefc3: 		try {
1:32cefc3: 			stmt2.executeUpdate("delete from t1 where current of C2");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			if (usingEmbedded())
1:32cefc3: 			    assertSQLState("42X23", e);
1:32cefc3: 			else
1:32cefc3: 			    assertSQLState("42X30", e);
1:32cefc3: 		}
1:32cefc3: 		stmt2.close();
1:32cefc3:                 rs.close();
1:fc7482f:                 stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 	public void testCursor3() throws SQLException {	
1:fc7482f:         Statement stmt = createStatement();
1:32cefc3: 		stmt.setCursorName("C3");
1:32cefc3: 		ResultSet rs = stmt.executeQuery("select i, v from t1 where i is not null for read only");
1:32cefc3: 		Statement stmt2 = createStatement();
1:32cefc3: 		try {
1:32cefc3: 			stmt2.executeUpdate("delete from t1 where current of C3");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			if (usingEmbedded())
1:32cefc3: 			    assertSQLState("42X23", e);
1:32cefc3: 			else
1:32cefc3: 			    assertSQLState("42X30", e);
1:32cefc3: 		}
1:32cefc3: 		stmt2.close();
1:32cefc3:                 rs.close();
1:fc7482f:                 stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3:  
1:32cefc3:         
1:32cefc3: 	public void testUpdates() throws SQLException {	
1:fc7482f:         Statement stmt = createStatement();
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update of t"));
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update of i"));
1:32cefc3: 
1:32cefc3: 		assertStatementError("42X04", stmt, "select i, v from t1 for update of g");
1:32cefc3: 		assertStatementError("42X04", stmt, "select i+10 as iPlus10, v from t1 for update of iPlus10");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1, t2 for update");
1:32cefc3: 
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1 where i=(select i from t1) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1 where i in (select i from t1) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select i from t1) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select s from t2) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select s from t2 where i=s) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select (select s from t2) from t1 where exists (select i from t1) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select (select s from t2 where i=s) from t1 where exists (select i from t1) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select * from (select i, d from t1) a for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select * from (select i+10, d from t1) a for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select * from (values (1, 2, 3)) a for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "values (1, 2, 3) for update");
1:32cefc3: 		assertStatementError("42Y90", stmt, "select * from t1 union all select * from t1 for update");
1:fc7482f:         stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3:  
1:32cefc3:         public void testUpdates2() throws SQLException {	
1:fc7482f:             Statement stmt = createStatement();
1:32cefc3: 		stmt.executeUpdate("insert into t1 (i) values (1)");
1:32cefc3: 		stmt.setCursorName("C4");
1:32cefc3: 		ResultSet rs = stmt.executeQuery("select i from t1 s1 for update");
1:32cefc3: 		rs.next();
1:32cefc3:                 assertEquals(rs.getString("I"), "1");
1:32cefc3: 
1:32cefc3: 		Statement stmt2 = createStatement();
1:32cefc3: 		try {
1:32cefc3: 			stmt2.executeUpdate("delete from s1 where current of C4");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			assertSQLState("42X28", e);
1:32cefc3: 		}
1:32cefc3: 
1:32cefc3: 		Statement stmt3 = createStatement();
1:32cefc3: 		stmt3.executeUpdate("delete from t1 where current of C4");
1:32cefc3: 		rs.close();
1:32cefc3: 		
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, v, d, t"));
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of v, i, t, d"));
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, d"));
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of t, v"));
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of d"));
1:32cefc3: 		assertStatementError("42X04", stmt, "select i as z from t1 for update of z");
1:fc7482f:         stmt.close();
1:32cefc3:          }
1:32cefc3: 		
1:32cefc3: 
1:32cefc3: 	 public void testCursor5() throws SQLException {
1:fc7482f:          Statement stmt = createStatement();
1:32cefc3: 		stmt.setCursorName("C5");
1:32cefc3: 		stmt.executeQuery("select i as v from t1 for update of v");
1:32cefc3: 		try {
1:32cefc3: 			stmt.executeUpdate("update t1 set v='hello' where current of C5");
1:32cefc3: 			fail("ForUpdateTest: should have thrown exception");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3: 			assertSQLState("42X30", e);
1:32cefc3: 		}
1:32cefc3:                 
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, v, v, t"));		
1:32cefc3: 		assertStatementError("42X01", stmt, "select i from t1 for update of t1.v, t1.i, t1.d");
1:32cefc3: 		JDBC.assertEmpty(stmt.executeQuery("select a.i+10, d, d from t1 a for update"));
1:fc7482f:         stmt.close();
1:32cefc3:          }
1:32cefc3: 
1:32cefc3:  
1:fc7482f: 	public void testStatistics() throws SQLException {
1:fc7482f:         Statement stmt = createStatement();
1:32cefc3: 
1:32cefc3: 		String [][] expectedValues = { {"1", "hhhh"}, 
1:32cefc3: 				               {"2", "uuuu"}, 
1:32cefc3: 					       {"3", "yyyy"}, 
1:32cefc3: 					       {"4", "aaaa"}, 
1:32cefc3: 				               {"5", "jjjj"},
1:32cefc3: 					       {"6", "rrrr"}, 
1:32cefc3: 				               {"7", "iiii"},
1:32cefc3: 				               {"8", "wwww"}, 
1:32cefc3: 				               {"9", "rrrr"},
1:32cefc3: 			 		       {"10", "cccc"}, 
1:32cefc3: 				               {"11", "hhhh"},
1:32cefc3: 					       {"12", "rrrr"} };			               
1:32cefc3: 		stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");		  
1:32cefc3: 		JDBC.assertFullResultSet(stmt.executeQuery("select i, b from t3 FOR UPDATE"), expectedValues);
1:32cefc3: 		RuntimeStatisticsParser rtsp = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:32cefc3: 		assertTrue(rtsp.usedTableScan());
1:32cefc3: 		assertFalse(rtsp.usedDistinctScan());
1:fc7482f: 		commit();
1:32cefc3: 
1:32cefc3: 		PreparedStatement p = prepareStatement("select i, b from t3  where i = ? FOR UPDATE");
1:32cefc3:                 p.setString(1, "7");
1:32cefc3:                 p.executeQuery();
1:32cefc3: 		String [][] expectedValues1 = { {"7", "iiii" } };
1:32cefc3: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues1);
1:32cefc3: 		RuntimeStatisticsParser rtsp2 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:32cefc3: 		assertFalse(rtsp2.usedTableScan());
1:32cefc3: 		assertFalse(rtsp2.usedDistinctScan());
1:32cefc3: 		p.close();
1:fc7482f: 		commit();
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 		p = prepareStatement("select i, b from t3 where i < ? FOR UPDATE");
1:32cefc3:                 p.setString(1, "7");
1:32cefc3:                 p.executeQuery();
1:32cefc3: 		String[][] expectedValues2 =  { {"1", "hhhh" },
1:32cefc3: 						{"2", "uuuu" },
1:32cefc3: 						{"3", "yyyy" },
1:32cefc3: 						{"4", "aaaa" },
1:32cefc3: 						{"5", "jjjj" },
1:32cefc3: 						{"6", "rrrr" } };
1:32cefc3: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues2);
1:32cefc3: 		RuntimeStatisticsParser rtsp3 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:32cefc3: 		assertFalse(rtsp3.usedTableScan());
1:32cefc3: 		assertFalse(rtsp3.usedDistinctScan());              
1:32cefc3: 		p.close();
1:fc7482f: 		commit();
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 		p = prepareStatement("select i, b from t3  where b = ? FOR UPDATE");
1:32cefc3:                 p.setString(1, "cccc");
1:32cefc3:                 p.executeQuery();
1:32cefc3: 		String[][] expectedValues3 = { {"10", "cccc" } };
1:32cefc3: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues3);
1:32cefc3: 		RuntimeStatisticsParser rtsp4 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:32cefc3: 		assertFalse(rtsp4.usedTableScan());
1:32cefc3: 		assertFalse(rtsp4.usedDistinctScan());
1:32cefc3: 		p.close();
1:fc7482f: 		commit();
1:32cefc3: 
1:32cefc3: 	        stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");	
1:fc7482f:             stmt.close();
1:32cefc3:         }
1:32cefc3: 
1:32cefc3:         public void testCursors() throws SQLException {  
1:32cefc3: 		ResultSet rs;
1:32cefc3: 		String actualValue = null;
1:32cefc3: 
1:32cefc3: 		Statement stmt2 = createStatement();
1:32cefc3: 		stmt2.setCursorName("T3C1");
1:32cefc3: 		rs = stmt2.executeQuery("select i,b from t3 where i = 4 for update");
1:32cefc3:                 rs.next();
1:32cefc3: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "4 aaaa      ");
1:32cefc3: 		try {
1:32cefc3: 			rs.next();
1:32cefc3: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3:       			if (usingEmbedded())
1:32cefc3: 				assertSQLState("24000", e);
1:32cefc3: 			else 
1:32cefc3: 				assertSQLState("XJ121", e);
1:32cefc3: 		}
1:32cefc3: 		rs.close();
1:32cefc3: 		stmt2.close();
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 		stmt2 = createStatement();
1:32cefc3: 		stmt2.setCursorName("T3C2");
1:32cefc3: 		rs = stmt2.executeQuery("select i,b from t3 where i = 4 for update");
1:32cefc3: 		rs.next();
1:32cefc3: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "4 aaaa      ");
1:32cefc3:                 Statement stmt3 = createStatement();
1:32cefc3: 		stmt3.executeUpdate("update t3 set i = 13 where current of T3C2");
1:32cefc3: 		try {
1:32cefc3: 			rs.next();
1:32cefc3: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3:       			if (usingEmbedded())
1:32cefc3: 				assertSQLState("24000", e);
1:32cefc3: 			else 
1:32cefc3: 				assertSQLState("XJ121", e);
1:32cefc3: 		}
1:32cefc3: 		rs.close();
1:32cefc3: 		stmt2.close();
1:32cefc3: 		stmt3.close();
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 		stmt2 = createStatement();
1:32cefc3: 		stmt2.setCursorName("T3C3");
1:32cefc3: 		rs = stmt2.executeQuery("select i,b from t3 where i = 6 for update");
1:32cefc3: 		rs.next();
1:32cefc3: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "6 rrrr      ");
1:32cefc3: 		stmt3 = createStatement();
1:32cefc3: 		stmt3.executeUpdate("update t3 set i = 14 where current of T3C3");
1:32cefc3:                 stmt3.execute("insert into t3 values (6, 'new!')");	
1:32cefc3: 		try {
1:32cefc3: 			rs.next();
1:32cefc3: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1:32cefc3: 		} catch (SQLException e) {
1:32cefc3:       			if (usingEmbedded())
1:32cefc3: 				assertSQLState("24000", e);
1:32cefc3: 			else 
1:32cefc3: 				assertSQLState("XJ121", e);
1:32cefc3: 		}
1:32cefc3:                 rs.close();
1:32cefc3: 		stmt2.close();
1:32cefc3: 		stmt3.close();
1:32cefc3: 
1:32cefc3: 
1:32cefc3: 		stmt2 = createStatement();
1:32cefc3: 		stmt2.execute("insert into t4 (c1) values (1),(2),(3)");
1:32cefc3: 		stmt2.setCursorName("T3C4");
1:32cefc3: 		rs = stmt2.executeQuery("select * from t4 for update of c1");
1:32cefc3:                 rs.next();
1:32cefc3: 		assertEquals(rs.getInt("C1"),1);
1:32cefc3: 		stmt3 = createStatement();
1:32cefc3:                 try { 
1:32cefc3: 		   stmt3.executeUpdate("update t4 set c1=c1 where current of T3C4");
1:32cefc3:                 } catch (SQLException sqle) {
1:32cefc3: 		    assertSQLState("42X30", sqle);
1:32cefc3:                 }
1:32cefc3: 		rs.close();
1:32cefc3:                 stmt2.close(); 
1:32cefc3: 		stmt3.close();
1:32cefc3: 	}              
1:32cefc3: 
1:32cefc3: 	
1:32cefc3: 
1:32cefc3: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = new BaseTestSuite("ForUpdateTest");
1:             BaseTestSuite suite = new BaseTestSuite(name);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8a319fb
/////////////////////////////////////////////////////////////////////////
1:                                 s.execute("create index t3bi on t3(b)");
1:                                 s.execute("insert into t3 values (1, 'hhhh'), (2, 'uuuu'), (3, 'yyyy'), (4, 'aaaa'), (5, 'jjjj'), (6, 'rrrr')");
1:                                 s.execute("insert into t3 values (7, 'iiii'), (8, 'wwww'), (9, 'rrrr'), (10, 'cccc'), (11, 'hhhh'), (12, 'rrrr')");
1:                                 s.execute("insert into t4 (c1) values (1),(2),(3)");
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fc7482f
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Sets the auto commit to false.
1:      */
1:     protected void initializeConnection(Connection conn) throws SQLException {
1:         conn.setAutoCommit(false);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		assertCompileError("42X01", "select i, v from t1 for");
1:         assertCompileError("42X01", "select i, v from t1 for read");
1:         assertCompileError("42X01", "select i, v from t1 for only");
1:         assertCompileError("42X01", "select i, v from t1 for update of");
1:         assertCompileError("42X01", "select i, v from t1 update");
1:         assertCompileError("42X01", "select i, v from t1 only");
1:         assertCompileError("42X01", "select i, v from t1 read");
1:         
1:         Statement stmt = createStatement();
1:         stmt.close();
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                 stmt.close();
1:             Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:             Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                 stmt.close();
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                 stmt.close();
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
1:             Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
1:          Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
1: 	public void testStatistics() throws SQLException {
1:         Statement stmt = createStatement();
1: 		commit();
/////////////////////////////////////////////////////////////////////////
1: 		commit();
/////////////////////////////////////////////////////////////////////////
1: 		commit();
/////////////////////////////////////////////////////////////////////////
1: 		commit();
/////////////////////////////////////////////////////////////////////////
0: 		commit();
1:             stmt.close();
commit:c7f3642
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:32cefc3
/////////////////////////////////////////////////////////////////////////
1: /*
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForUpdateTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.Properties;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Tests for forupdate. 
1:  *
1:  */
1: public class ForUpdateTest extends BaseJDBCTestCase {
1: 
0: 	public Statement stmt = null;
0: 	public Connection c = null;
1: 
1: 	/* Public constructor required for running test as standalone JUnit. */    
1: 	public ForUpdateTest(String name) {
1: 		super(name);
1: 	}
1: 
1: 
0: 	/* Set up fixture */ 
0: 	protected void setUp() throws SQLException {
0: 	    stmt = createStatement();
0: 	    c = getConnection();		
0: 	    c.setAutoCommit(false);
1: 	}
1: 
1: 
0: 	/* Tear down the fixture */
0: 	protected void tearDown() throws Exception {
0:                 stmt.close();
0: 		super.tearDown();
1: 	}
1: 
1: 	/**
1:          * Create a suite of tests.
1:          **/
1:         public static Test suite() {
0:         	TestSuite suite = new TestSuite("ForUpdateTest");
1:         	suite.addTest(baseSuite("ForUpdateTest:embedded"));
1:         	suite.addTest(TestConfiguration.clientServerDecorator(baseSuite("ForUpdateTest:client")));
1:         	return suite;
1:     	}
1: 
1: 	protected static Test baseSuite(String name) {
0:         	TestSuite suite = new TestSuite(name);
1:         	suite.addTestSuite(ForUpdateTest.class);	
1: 		return new CleanDatabaseTestSetup(suite) 
1:         	{
1:             		protected void decorateSQL(Statement s) throws SQLException
1:             		{
1:                 		s.execute("create table t1 ( i int, v varchar(10), d double precision, t time )");
1: 				s.execute("create table t2 ( s smallint, c char(10), r real, ts timestamp )");
1:                                 s.execute("create table t3 (i int not null constraint t3pk primary key, b char(10))");
1: 				s.execute("create table t4 (c1 int)");	
0:                         	s.close();
1:             		}
1:         	};
1:     	} 
1: 
1:         public void testNegative() throws SQLException {    
0: 		assertStatementError("42X01", stmt, "select i, v from t1 for");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 for read");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 for only");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 for update of");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 update");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 only");
0: 		assertStatementError("42X01", stmt, "select i, v from t1 read");
1: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update"));
1:         }
1: 
1: 
1: 	public void testCursor() throws SQLException {	
1:  		stmt.setCursorName("C");
1: 		stmt.executeQuery("select i, v from t1, t2");
1:                 Statement stmt2 = createStatement();
1: 		try {
1: 			stmt2.executeUpdate("delete from t1 where current of C");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			if (usingEmbedded())
1: 				assertSQLState("42X23", e);
1:                         else
1: 				assertSQLState("42X30", e);
1: 
1: 		}
1:                 
1:                 try {
1:                      stmt2.executeQuery("select i, v from t1, t2");
1:                 } catch (SQLException e ) {
1:                      assertSQLState("X0X60", e);
1:                 }
1:                 stmt2.close();
1:         }
1: 
1:          
1:         public void testCursor1() throws SQLException {	
1: 		stmt.setCursorName("C1");
1: 		ResultSet rs = stmt.executeQuery("select i, v from t1 where i is not null");
1: 		Statement stmt2 = createStatement();
1: 		try {
1: 			stmt2.executeUpdate("delete from t1 where current of C1");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			if (usingEmbedded())
1: 			    assertSQLState("42X23", e);
1: 			else
1: 			    assertSQLState("42X30", e);
1: 		}
1: 		stmt2.close();
1:                 rs.close();
1:         }
1: 
1: 
1:         public void testCursor2() throws SQLException {	
1: 		stmt.setCursorName("C2");
1: 		ResultSet rs = stmt.executeQuery("select i, v from t1, t2 for read only");
1: 		Statement stmt2 = createStatement();
1: 		try {
1: 			stmt2.executeUpdate("delete from t1 where current of C2");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			if (usingEmbedded())
1: 			    assertSQLState("42X23", e);
1: 			else
1: 			    assertSQLState("42X30", e);
1: 		}
1: 		stmt2.close();
1:                 rs.close();
1:         }
1: 
1: 
1: 
1: 	public void testCursor3() throws SQLException {	
1: 		stmt.setCursorName("C3");
1: 		ResultSet rs = stmt.executeQuery("select i, v from t1 where i is not null for read only");
1: 		Statement stmt2 = createStatement();
1: 		try {
1: 			stmt2.executeUpdate("delete from t1 where current of C3");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			if (usingEmbedded())
1: 			    assertSQLState("42X23", e);
1: 			else
1: 			    assertSQLState("42X30", e);
1: 		}
1: 		stmt2.close();
1:                 rs.close();
1:         }
1: 
1:  
1:         
1: 	public void testUpdates() throws SQLException {	
1: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update of t"));
1: 		JDBC.assertEmpty(stmt.executeQuery("select i, v from t1 for update of i"));
1: 
1: 		assertStatementError("42X04", stmt, "select i, v from t1 for update of g");
1: 		assertStatementError("42X04", stmt, "select i+10 as iPlus10, v from t1 for update of iPlus10");
1: 		assertStatementError("42Y90", stmt, "select i from t1, t2 for update");
1: 
1: 		assertStatementError("42Y90", stmt, "select i from t1 where i=(select i from t1) for update");
1: 		assertStatementError("42Y90", stmt, "select i from t1 where i in (select i from t1) for update");
1: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select i from t1) for update");
1: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select s from t2) for update");
1: 		assertStatementError("42Y90", stmt, "select i from t1 where exists (select s from t2 where i=s) for update");
1: 		assertStatementError("42Y90", stmt, "select (select s from t2) from t1 where exists (select i from t1) for update");
1: 		assertStatementError("42Y90", stmt, "select (select s from t2 where i=s) from t1 where exists (select i from t1) for update");
1: 		assertStatementError("42Y90", stmt, "select * from (select i, d from t1) a for update");
1: 		assertStatementError("42Y90", stmt, "select * from (select i+10, d from t1) a for update");
1: 		assertStatementError("42Y90", stmt, "select * from (values (1, 2, 3)) a for update");
1: 		assertStatementError("42Y90", stmt, "values (1, 2, 3) for update");
1: 		assertStatementError("42Y90", stmt, "select * from t1 union all select * from t1 for update");
1:         }
1: 
1:  
1:         public void testUpdates2() throws SQLException {	
1: 		stmt.executeUpdate("insert into t1 (i) values (1)");
1: 		stmt.setCursorName("C4");
1: 		ResultSet rs = stmt.executeQuery("select i from t1 s1 for update");
1: 		rs.next();
1:                 assertEquals(rs.getString("I"), "1");
1: 
1: 		Statement stmt2 = createStatement();
1: 		try {
1: 			stmt2.executeUpdate("delete from s1 where current of C4");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			assertSQLState("42X28", e);
1: 		}
1: 
1: 		Statement stmt3 = createStatement();
1: 		stmt3.executeUpdate("delete from t1 where current of C4");
1: 		rs.close();
1: 		
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, v, d, t"));
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of v, i, t, d"));
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, d"));
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of t, v"));
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of d"));
1: 		assertStatementError("42X04", stmt, "select i as z from t1 for update of z");
1:          }
1: 		
1: 
1: 	 public void testCursor5() throws SQLException {
1: 		stmt.setCursorName("C5");
1: 		stmt.executeQuery("select i as v from t1 for update of v");
1: 		try {
1: 			stmt.executeUpdate("update t1 set v='hello' where current of C5");
1: 			fail("ForUpdateTest: should have thrown exception");
1: 		} catch (SQLException e) {
1: 			assertSQLState("42X30", e);
1: 		}
1:                 
1: 		JDBC.assertEmpty(stmt.executeQuery("select i from t1 for update of i, v, v, t"));		
1: 		assertStatementError("42X01", stmt, "select i from t1 for update of t1.v, t1.i, t1.d");
1: 		JDBC.assertEmpty(stmt.executeQuery("select a.i+10, d, d from t1 a for update"));
1:          }
1: 
1:  
0: 	public void testStatistics() throws SQLException {  
0: 		stmt.execute("create index t3bi on t3(b)");
0: 		stmt.execute("insert into t3 values (1, 'hhhh'), (2, 'uuuu'), (3, 'yyyy'), (4, 'aaaa'), (5, 'jjjj'), (6, 'rrrr')");
0: 		stmt.execute("insert into t3 values (7, 'iiii'), (8, 'wwww'), (9, 'rrrr'), (10, 'cccc'), (11, 'hhhh'), (12, 'rrrr')");
0: 		c.commit();
1: 
1: 		String [][] expectedValues = { {"1", "hhhh"}, 
1: 				               {"2", "uuuu"}, 
1: 					       {"3", "yyyy"}, 
1: 					       {"4", "aaaa"}, 
1: 				               {"5", "jjjj"},
1: 					       {"6", "rrrr"}, 
1: 				               {"7", "iiii"},
1: 				               {"8", "wwww"}, 
1: 				               {"9", "rrrr"},
1: 			 		       {"10", "cccc"}, 
1: 				               {"11", "hhhh"},
1: 					       {"12", "rrrr"} };			               
1: 		stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");		  
1: 		JDBC.assertFullResultSet(stmt.executeQuery("select i, b from t3 FOR UPDATE"), expectedValues);
1: 		RuntimeStatisticsParser rtsp = SQLUtilities.getRuntimeStatisticsParser(stmt);
1: 		assertTrue(rtsp.usedTableScan());
1: 		assertFalse(rtsp.usedDistinctScan());
0: 		c.commit();
1: 
1: 		PreparedStatement p = prepareStatement("select i, b from t3  where i = ? FOR UPDATE");
1:                 p.setString(1, "7");
1:                 p.executeQuery();
1: 		String [][] expectedValues1 = { {"7", "iiii" } };
1: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues1);
1: 		RuntimeStatisticsParser rtsp2 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1: 		assertFalse(rtsp2.usedTableScan());
1: 		assertFalse(rtsp2.usedDistinctScan());
1: 		p.close();
0: 		c.commit();
1: 
1: 
1: 		p = prepareStatement("select i, b from t3 where i < ? FOR UPDATE");
1:                 p.setString(1, "7");
1:                 p.executeQuery();
1: 		String[][] expectedValues2 =  { {"1", "hhhh" },
1: 						{"2", "uuuu" },
1: 						{"3", "yyyy" },
1: 						{"4", "aaaa" },
1: 						{"5", "jjjj" },
1: 						{"6", "rrrr" } };
1: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues2);
1: 		RuntimeStatisticsParser rtsp3 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1: 		assertFalse(rtsp3.usedTableScan());
1: 		assertFalse(rtsp3.usedDistinctScan());              
1: 		p.close();
0: 		c.commit();
1: 
1: 
1: 		p = prepareStatement("select i, b from t3  where b = ? FOR UPDATE");
1:                 p.setString(1, "cccc");
1:                 p.executeQuery();
1: 		String[][] expectedValues3 = { {"10", "cccc" } };
1: 		JDBC.assertFullResultSet(p.getResultSet(), expectedValues3);
1: 		RuntimeStatisticsParser rtsp4 = SQLUtilities.getRuntimeStatisticsParser(stmt);
1: 		assertFalse(rtsp4.usedTableScan());
1: 		assertFalse(rtsp4.usedDistinctScan());
1: 		p.close();
0: 		c.commit();
1: 
1: 	        stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");	
1:         }
1: 
1:         public void testCursors() throws SQLException {  
1: 		ResultSet rs;
1: 		String actualValue = null;
1: 
1: 		Statement stmt2 = createStatement();
1: 		stmt2.setCursorName("T3C1");
1: 		rs = stmt2.executeQuery("select i,b from t3 where i = 4 for update");
1:                 rs.next();
1: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "4 aaaa      ");
1: 		try {
1: 			rs.next();
1: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1: 		} catch (SQLException e) {
1:       			if (usingEmbedded())
1: 				assertSQLState("24000", e);
1: 			else 
1: 				assertSQLState("XJ121", e);
1: 		}
1: 		rs.close();
1: 		stmt2.close();
1: 
1: 
1: 		stmt2 = createStatement();
1: 		stmt2.setCursorName("T3C2");
1: 		rs = stmt2.executeQuery("select i,b from t3 where i = 4 for update");
1: 		rs.next();
1: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "4 aaaa      ");
1:                 Statement stmt3 = createStatement();
1: 		stmt3.executeUpdate("update t3 set i = 13 where current of T3C2");
1: 		try {
1: 			rs.next();
1: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1: 		} catch (SQLException e) {
1:       			if (usingEmbedded())
1: 				assertSQLState("24000", e);
1: 			else 
1: 				assertSQLState("XJ121", e);
1: 		}
1: 		rs.close();
1: 		stmt2.close();
1: 		stmt3.close();
1: 
1: 
1: 		stmt2 = createStatement();
1: 		stmt2.setCursorName("T3C3");
1: 		rs = stmt2.executeQuery("select i,b from t3 where i = 6 for update");
1: 		rs.next();
1: 		assertEquals(rs.getInt("I") + " " + rs.getString("B"), "6 rrrr      ");
1: 		stmt3 = createStatement();
1: 		stmt3.executeUpdate("update t3 set i = 14 where current of T3C3");
1:                 stmt3.execute("insert into t3 values (6, 'new!')");	
1: 		try {
1: 			rs.next();
1: 			actualValue = rs.getInt("I") + " " + rs.getString("B");
1: 		} catch (SQLException e) {
1:       			if (usingEmbedded())
1: 				assertSQLState("24000", e);
1: 			else 
1: 				assertSQLState("XJ121", e);
1: 		}
1:                 rs.close();
1: 		stmt2.close();
1: 		stmt3.close();
1: 
1: 
1: 		stmt2 = createStatement();
1: 		stmt2.execute("insert into t4 (c1) values (1),(2),(3)");
1: 		stmt2.setCursorName("T3C4");
1: 		rs = stmt2.executeQuery("select * from t4 for update of c1");
1:                 rs.next();
1: 		assertEquals(rs.getInt("C1"),1);
1: 		stmt3 = createStatement();
1:                 try { 
1: 		   stmt3.executeUpdate("update t4 set c1=c1 where current of T3C4");
1:                 } catch (SQLException sqle) {
1: 		    assertSQLState("42X30", sqle);
1:                 }
1: 		rs.close();
1:                 stmt2.close(); 
1: 		stmt3.close();
1: 	}              
1: 
1: 	
1: 
1: }
============================================================================