1:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.sysinfo.Main
1:6ae3022: 
1:9a7cd7e:    Licensed to the Apache Software Foundation (ASF) under one or more
1:9a7cd7e:    contributor license agreements.  See the NOTICE file distributed with
1:9a7cd7e:    this work for additional information regarding copyright ownership.
1:9a7cd7e:    The ASF licenses this file to you under the Apache License, Version 2.0
1:9a7cd7e:    (the "License"); you may not use this file except in compliance with
1:9a7cd7e:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:985fc85: 
4:fe77ca5:  */
26:fe77ca5: 
1:fe77ca5: package org.apache.derby.impl.tools.sysinfo;
1:fe77ca5: 
1:c7549a5: import java.security.AccessController;
1:c7549a5: import java.security.PrivilegedAction;
1:fe77ca5: import java.util.Locale;
1:fe77ca5: import java.io.IOException;
1:fe77ca5: import java.io.UnsupportedEncodingException;
1:fe77ca5: import java.io.InputStream;
1:fe77ca5: import java.util.Properties;
1:fe77ca5: import java.io.BufferedReader;
1:fe77ca5: import java.io.InputStreamReader;
1:fe77ca5: import java.util.Locale;
1:fe77ca5: import java.util.MissingResourceException;
1:fe77ca5: import java.util.ResourceBundle;
1:fe77ca5: import java.util.StringTokenizer;
1:fe77ca5: import java.io.File;
1:fe77ca5: import java.util.zip.ZipFile;
1:fe77ca5: import java.io.IOException;
1:fe77ca5: import java.util.zip.ZipEntry;
1:fe77ca5: import java.io.FileInputStream;
1:fe77ca5: import java.util.Vector;
1:fe77ca5: import java.io.InputStream;
1:fe77ca5: import java.lang.reflect.Method;
1:aeb4b10: import java.net.URL;
1:e77851a: import java.net.URLDecoder;
1:52d42fe: import java.security.PrivilegedActionException;
1:52d42fe: import java.security.PrivilegedExceptionAction;
1:aeb4b10: import java.security.ProtectionDomain;
1:aeb4b10: import java.security.CodeSource;
1:aeb4b10: import java.security.AccessController;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.services.info.PropertyNames;
1:fe77ca5: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1:fe77ca5: import org.apache.derby.iapi.services.info.ProductGenusNames;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.tools.i18n.*;
1:fe77ca5: 
1:fe77ca5: 
4:fe77ca5: /**
1:379f95f:   <P>
1:379f95f:   Sysinfo reports values relevant to the current Derby configuration.
1:fe77ca5: 
1:fe77ca5:   <P>
1:379f95f:   Sysinfo looks for properties files in org.apache.derby.info named after
1:379f95f:   the genus names in org.apache.derby.tools.sysinfo, and gets their location
1:379f95f:   using getResource. It also searches the classpath and attempts to load
1:379f95f:   the info properties files from the directory or jar locations on the
1:379f95f:   classpath, and eliminates any duplicated information. If no files
1:379f95f:   are found, or some other exception occurs, the
1:62d63f6:   value returned will be "<info unavailable>".
1:fe77ca5: 
1:fe77ca5:   <P>
1:fe77ca5:   This class can be used to print out system information at the
1:fe77ca5:   command line by issuing the command:
1:fe77ca5:   <PRE>
1:3abc7d4:     java org.apache.derby.tools.sysinfo
1:fe77ca5:   </PRE>
1:fe77ca5:   Alternatively, you can use SysInfo within your program to display
1:27ff169:   Derby information; a Derby version string is returned by this Java code:
1:fe77ca5:   <PRE>
1:fe77ca5:     new Main().toString();
1:fe77ca5:   </PRE>
1:fe77ca5: 
1:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: public final class Main {
1:fe77ca5: 
1:9a55084:     /**
1:9a55084:      * Name of file which contains messages for sysinfo.
1:9a55084:      */
1:9a55084:     private final static String MESSAGE_FILE =
1:9a55084:         "org.apache.derby.loc.sysinfoMessages";
1:9a55084: 
1:9a55084:     /**
1:9a55084:      * Resource for localizing the sysinfo messages.
1:9a55084:      *
1:9a55084:      * The default LocalizedResource reads messages from the toolsmessages
1:9a55084:      * bundle. Create this instance to read messages from sysinfoMessages. Use
1:9a55084:      * the locale and codeset specified by derby.ui.locale and derby.ui.codeset
1:9a55084:      * if they are set.
1:9a55084:      *
1:9a55084:      * Note that this variable must be initialized when the class is loaded in
1:9a55084:      * order to work correctly for the API methods that don't call
1:9a55084:      * <code>main()</code>.
1:9a55084:      */
1:9a55084:     private final static LocalizedResource LOCALIZED_RESOURCE =
1:953afd7:         new LocalizedResource(MESSAGE_FILE);
1:9a55084: 
1:fe77ca5:   /**
1:fe77ca5:     Application entry point for SysInfo.   This will print out
1:27ff169:     the Derby product information as well as a snapshot of
1:fe77ca5:     the System properties.
1:fe77ca5:   */
1:fe77ca5:   public static void main(String args[]) {
1:fe77ca5:         // adjust the application in accordance with derby.ui.locale and derby.ui.codeset
1:d1b8db2:         LocalizedResource.getInstance().init();
1:fe77ca5: 
1:fe77ca5: 		LocalizedOutput out;
1:fe77ca5: 
1:fe77ca5:         //using AppStreamReader(extends InputStreamReader) for conversion into specific codeset
1:fe77ca5: 
1:fe77ca5: 		out = LocalizedResource.OutputWriter();
1:fe77ca5: 
1:fe77ca5:        // because we're in a static method, we need to
1:fe77ca5:        // get our own instance variable
1:fe77ca5:     parseArgs (args);
1:fe77ca5: 
1:fe77ca5:     if (cptester == true)
1:fe77ca5: 	getClasspathInfo (args, out);
1:aeb4b10:     else
1:fe77ca5: 	getMainInfo (out, setPause);
1:fe77ca5: 
1:fe77ca5:   } // end of main (String args[])
1:fe77ca5: 
1:fe77ca5: public static void getMainInfo (java.io.PrintWriter aw, boolean pause) {
1:fe77ca5: 
1:fe77ca5:     aw.println (javaSep);
1:fe77ca5:     reportJavaInfo (aw);
1:fe77ca5:     aw.println (jbmsSep);
1:5d3c52a:     reportDerby (aw);
1:fe77ca5:     aw.println (sep);
1:7a7a289: 
1:fe77ca5: 
1:fe77ca5:     // Locales info
4:fe77ca5:     try {
1:fe77ca5:       reportLocales (aw);
17:fe77ca5:     }
1:fe77ca5:     catch (Exception e) {
1:aeb4b10: 
1:fe77ca5:       aw.println (Main.getTextMessage ("SIF01.Q"));
1:fe77ca5:       aw.println (Main.getTextMessage ("SIF01.B"));
1:fe77ca5:     }
1:2790509:     
1:2790509:     // derbyTesting info
1:2790509:     try {
1:2790509:         reportTesting(aw);
1:2790509:     }
1:2790509:     catch (Exception e) {
1:2790509:         // ignore locales for the testing jar
1:2790509:         aw.println("Exception in reporting version of derbyTesting.jar");
1:2790509:         e.printStackTrace();
1:2790509:     }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     if (pause) {
1:fe77ca5:      pause();
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:   } // end of getMainInfo (AppStreamWriter aw, boolean printLicense, boolean pause)
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:   private static boolean setPause = false;
1:fe77ca5: 
1:fe77ca5:   private static boolean setLicense = false;
1:fe77ca5: 
1:fe77ca5:   private static boolean cptester = false;
1:fe77ca5: 
1:fe77ca5:   private static void parseArgs (String args[]) {
1:fe77ca5: 
1:fe77ca5:     if (args == null) {
1:fe77ca5: 
1:fe77ca5:       return;
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     for (int i = 0; i < args.length; i++) {
1:fe77ca5: 
1:fe77ca5:       if (args[i].equals ("-pause")) {
1:fe77ca5: 
1:fe77ca5:         setPause = true;
1:fe77ca5:       }
1:fe77ca5: 
1:fe77ca5:       if (args[i].equals ("-cp")) {
1:fe77ca5: 
1:fe77ca5:         cptester=true;
1:fe77ca5:       }
1:fe77ca5: 
1:fe77ca5:     } // end for
1:fe77ca5: 
1:fe77ca5:   } // end of parseArgs (String args[])
1:fe77ca5: 
1:fe77ca5: 
1:379f95f:   /**
1:fe77ca5:     For the benefit of DOS box users, this method waits for input
1:fe77ca5:     before returning
1:379f95f:   */
1:fe77ca5:   private static void pause () {
1:fe77ca5: 
1:fe77ca5:     try {
1:fe77ca5: 
1:fe77ca5:       System.out.print (Main.getTextMessage ("SIF01.C"));
1:fe77ca5:       BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
1:fe77ca5:       br.readLine ();
1:fe77ca5:     }
1:fe77ca5:     catch (IOException ioe) {
1:fe77ca5: 
1:fe77ca5:       //just return
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:   } // end of pause ()
1:fe77ca5: 
1:aeb4b10:   /**
1:fe77ca5:     prints out the jbms info to the specified AppStreamWriter.
1:f0b0870:     @param localAW the AppStreamWriter to use. If null, System.out is
1:fe77ca5:     used
1:fe77ca5:   */
1:fe77ca5: 
1:5d3c52a:   private static void reportDerby (java.io.PrintWriter localAW) {
1:fe77ca5: 
1:63adae8: 	  String classpath = null;
1:fe77ca5: 
1:63adae8:       try {
1:16d3334:           classpath = AccessController.doPrivileged( new PrivilegedAction<String>()
1:63adae8:               {
1:16d3334:                   public String run()
1:63adae8:                   {
1:63adae8:                       return System.getProperty("java.class.path");
1:63adae8:                   }
1:63adae8:               }
1:63adae8:               );
1:fe77ca5: 	  }
1:fe77ca5: 	  catch (SecurityException se) {
1:aeb4b10:           localAW.println(
1:aeb4b10:               Main.getTextMessage ("SIF01.U", se.getMessage()));
1:fe77ca5: 		  classpath = null;
1:aeb4b10: 	  }
1:aeb4b10: 
1:63adae8:       ZipInfoProperties zip[]= Main.getAllInfo (classpath);
1:fe77ca5: 
1:fe77ca5:     if (zip != null) {
1:fe77ca5: 
1:fe77ca5:       for (int i = 0; i < zip.length; i++) {
1:fe77ca5: 
1:fe77ca5:         String thisInfo = "[" + zip[i].getLocation () + "] " +
1:fe77ca5:                                 zip[i].getVersionBuildInfo ();
1:fe77ca5: 
1:fe77ca5:         localAW.println (thisInfo);
1:fe77ca5:       }
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:     else {
1:fe77ca5: 
1:fe77ca5:       localAW.println (Main.getTextMessage ("SIF01.D"));
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 
1:5d3c52a:   } // end of reportDerby
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:     Writes out the relevant info about the Java environment to
1:fe77ca5:     the specified AppStreamWriter.
1:fe77ca5: 
1:f0b0870:     @param localAW The AppStreamWriter to write info out to. If this is
1:fe77ca5:     null, the info is written to System.out
1:fe77ca5:   */
1:fe77ca5: 
1:fe77ca5:   private static void reportJavaInfo (java.io.PrintWriter localAW) {
1:fe77ca5: 
1:fe77ca5: 	
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.A",
1:fe77ca5:                                                            getJavaProperty ("java.version")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.B",
1:fe77ca5:                                                            getJavaProperty ("java.vendor")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.C",
1:fe77ca5:                                                            getJavaProperty ("java.home")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.D",
1:fe77ca5:                                                            getJavaProperty ("java.class.path")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.E",
1:fe77ca5:                                                            getJavaProperty ("os.name")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.F",
1:fe77ca5:                                                            getJavaProperty ("os.arch")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.G",
1:fe77ca5:                                                            getJavaProperty ("os.version")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.H",
1:fe77ca5:                                                            getJavaProperty ("user.name")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.I",
1:fe77ca5:                                                            getJavaProperty ("user.home")));
1:fe77ca5: 
1:fe77ca5:     localAW.println (Main.getTextMessage ("SIF02.J",
1:fe77ca5:                                                            getJavaProperty ("user.dir")));
1:fe77ca5: 
1:6ae3022: 	localAW.println("java.specification.name: " + getJavaProperty("java.specification.name"));
1:6ae3022: 	localAW.println("java.specification.version: " + getJavaProperty("java.specification.version"));
1:54a04d3: 	printPropertyIfNotNull(localAW, "java.runtime.version");
1:54a04d3: 	printPropertyIfNotNull(localAW, "java.fullversion");
1:6ae3022: 
1:6ae3022: 
1:fe77ca5:   } // end of reportJavaInfo
1:fe77ca5: 
1:fe77ca5:   /**
1:54a04d3:    * Print property only if not null
1:54a04d3:    * 
1:54a04d3:    * @param localAW This is PrintWriter to print to
1:54a04d3:    * @param property This is system property string
1:54a04d3:    */
1:54a04d3:   private static void printPropertyIfNotNull(java.io.PrintWriter localAW, String property) {
1:54a04d3:     String propertyValue = getJavaProperty(property, true);	
1:fe77ca5: 
1:54a04d3:     if (propertyValue != null) {
1:54a04d3:         localAW.println(property + ": " + propertyValue);
1:54a04d3:     }
1:54a04d3: }
1:54a04d3:   
1:54a04d3:   /**
1:54a04d3:    * Return Java properties from java.lang.System. Will catch
1:54a04d3:    * SecurityExceptions and note them for displaying information.
1:54a04d3:    * @param whichProperty This is the name of the property
1:54a04d3:    * 
1:54a04d3:    * @return getJavaProperty(whichProperty, false) 
1:54a04d3:    */
1:63adae8:   private static String getJavaProperty (final String whichProperty) {
1:54a04d3: 	  return getJavaProperty(whichProperty, false);  
1:54a04d3:   }
1:54a04d3:  
1:54a04d3:   /**
1:54a04d3:    * Return Java properties from java.lang.System. Will catch
1:54a04d3:    * SecurityExceptions and note them for displaying information.
1:54a04d3:    * @param whichProperty This is the name of the property
1:54a04d3:    * @param nullUnavailable return nothing if no such java property and nullUnavailable is true
1:54a04d3:    * @return the Java property value or a string capturing a
1:54a04d3:    * security exception.
1:fe77ca5:    */
1:fe77ca5: 
1:54a04d3:   private static String getJavaProperty (final String whichProperty, boolean nullUnavailable) {
1:fe77ca5: 
1:54a04d3:     final   String unavailable = nullUnavailable ? null : Main.getTextMessage ("SIF01.H");
1:fe77ca5: 
1:fe77ca5:     try {
1:16d3334:         String  property = AccessController.doPrivileged( new PrivilegedAction<String>()
1:63adae8:             {
1:16d3334:                 public  String  run()
1:63adae8:                 {
1:63adae8:                     return System.getProperty (whichProperty, unavailable);
1:63adae8:                 }
1:63adae8:             }
1:63adae8:             );
1:63adae8:         return property;
1:fe77ca5:     }
1:fe77ca5:     catch (SecurityException se) {
1:fe77ca5: 
1:fe77ca5:       return Main.getTextMessage ("SIF01.I", se);
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:   } // end of getJavaProperty (String whichProperty)
1:fe77ca5: 
1:fe77ca5: 
1:52d42fe:     /**
1:52d42fe:      * wrapper for getCanonicalPath for sysinfo. For sysinfo we just want to print
1:52d42fe:      * the security exceptions, not throw them if we don't have permmission
1:52d42fe:      * 
1:52d42fe:      * @param f file on which to call getCanonicalPath
1:52d42fe:      * @return f.getCanonicalPath
1:52d42fe:      * @throws IOException
1:52d42fe:      */
1:52d42fe:     private static String getCanonicalPath(final File f) throws IOException {
1:52d42fe: 
1:52d42fe:         try {
1:16d3334:             return AccessController
1:16d3334:                     .doPrivileged(new PrivilegedExceptionAction<String>() {
1:16d3334:                         public String run() throws IOException {
1:52d42fe:                             return f.getCanonicalPath();
1:52d42fe:                         }
1:52d42fe:                     });
1:52d42fe:         } catch (PrivilegedActionException pae) {
1:52d42fe:             throw (IOException) pae.getCause();
1:52d42fe:         } catch (SecurityException se) {
1:52d42fe:             return Main.getTextMessage("SIF01.I", se);
1:52d42fe:         }
1:52d42fe:     }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:     for use by the main () method
1:fe77ca5:    */
1:fe77ca5: 
1:fe77ca5:   private final static String sep     = "------------------------------------------------------";
1:fe77ca5:   private final static String javaSep = Main.getTextMessage ("SIF01.L");
1:fe77ca5: 
1:fe77ca5:   private final static String jbmsSep = Main.getTextMessage ("SIF01.M");
1:fe77ca5: 
1:fe77ca5:   private final static String licSep  = Main.getTextMessage ("SIF01.N");
1:fe77ca5: 
1:fe77ca5:   private final static String locSep  = Main.getTextMessage ("SIF01.P");
1:fe77ca5: 
1:fe77ca5:   private final static String curLoc  = Main.getTextMessage ("SIF01.T");
1:fe77ca5: 
1:fe77ca5:   private static void getClasspathInfo (String args[], java.io.PrintWriter aw) {
1:fe77ca5: 
1:fe77ca5:     Main.useMe (args, aw);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:     Writes out information about the locales with the
1:fe77ca5:     product.
1:fe77ca5: 
1:f0b0870:     @param localAW the AppStreamWriter to which the info is written. If this
1:fe77ca5:     value is null, the info is written to System.out
1:fe77ca5: 
1:fe77ca5:   */
1:613392c:   private static void reportLocales (java.io.PrintWriter localAW) {
1:fe77ca5: 
1:fe77ca5:     boolean cur_loc = true;
1:fe77ca5: 
1:fe77ca5:     localAW.println (locSep);
1:fe77ca5: 
1:fe77ca5:     // Read all the possible locales, and test for each one, if it loads.
1:fe77ca5:     // If so, then read the properties, and print them out.
1:fe77ca5: 
1:fe77ca5: 	Locale[] supportedLocales = Locale.getAvailableLocales();
1:fe77ca5: 	String[] stringLocales = new String[supportedLocales.length];
1:fe77ca5:     for (int i = 0; i < supportedLocales.length; i++)
1:aeb4b10: 	{
1:fe77ca5: 		stringLocales[i] = supportedLocales[i].toString();
1:fe77ca5: 	}
1:fe77ca5: 	java.util.Arrays.sort(stringLocales);
1:fe77ca5: 
1:fe77ca5:     Properties p = new Properties ();
1:fe77ca5:     for (int i = 0; i < stringLocales.length; i++) {
1:fe77ca5: 
1:fe77ca5:       String localeResource =
1:fe77ca5:          "/org/apache/derby/info/locale_" + stringLocales[i] + ".properties";
1:c7549a5:       
1:c7549a5:       final Properties finalp = p;
1:c7549a5:       final String finalLocaleResource = localeResource;
1:c7549a5:      
1:c7549a5:       try {     
1:16d3334:         	InputStream is = AccessController.doPrivileged
1:16d3334:             (new PrivilegedAction<InputStream>() {
1:16d3334:                   public InputStream run() {
1:c7549a5:   		            InputStream locis =
1:c7549a5:   		            	finalp.getClass().getResourceAsStream (finalLocaleResource);
1:c7549a5:   					return locis;
1:c7549a5:                   }
1:c7549a5:               }
1:c7549a5:            );      
1:c7549a5:       	
1:fe77ca5:         if (is == null) {
1:fe77ca5: //           localAW.println("resource is null: " + localeResource);
1:fe77ca5:         }
1:fe77ca5:         else {
1:c7549a5: 
1:fe77ca5:           try {
1:fe77ca5: 			  p.clear();
1:fe77ca5:             p.load (is);
1:fe77ca5:         //Displaying Current Locale
1:fe77ca5: 	    if (cur_loc)
10:fe77ca5: 		{
1:fe77ca5: 	Locale loc = null;
1:fe77ca5: 	loc = Locale.getDefault();
1:fe77ca5:         localAW.println(Main.getTextMessage ("SIF01.T") + "  [" + loc.getDisplayLanguage() + "/" +  loc.getDisplayCountry() + " [" + loc + "]]");
1:fe77ca5: 		cur_loc = false;
1:fe77ca5: 		}
1:c7549a5: 
1:fe77ca5: 	//Beetle 5079: do not print unlocalized locale names to console, only print locale code.
1:fe77ca5: 	String localeName = p.getProperty("derby.locale.external.name");
1:fe77ca5: 	localeName = localeName.substring(localeName.indexOf("[")+1);
1:fe77ca5: 	localeName = localeName.substring(0,localeName.indexOf("]"));
1:fe77ca5: 	
1:fe77ca5:             localAW.println (Main.getTextMessage ("SIF01.R",
1:fe77ca5:                                                                    localeName));
1:fe77ca5: 
1:fe77ca5: 
1:eb7e251: 			int major = Integer.parseInt(p.getProperty ("derby.locale.version.major"));
1:eb7e251: 			int minor = Integer.parseInt(p.getProperty ("derby.locale.version.minor"));
1:eb7e251: 			int maint = Integer.parseInt(p.getProperty ("derby.locale.version.maint"));
1:0a7339d: 			String build = p.getProperty ("derby.locale.build.number");
1:fe77ca5: 
1:fe77ca5: 			String lv = ProductVersionHolder.fullVersionString(major, minor, maint, false, build);
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:             localAW.println (Main.getTextMessage ("SIF01.S", lv));
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:           }
1:fe77ca5:           catch (IOException ioe) {
1:fe77ca5: 
1:fe77ca5:             //This case is a bit ugly. If we get an IOException, we return
1:fe77ca5:             //null. Though this correctly reflects that the product is not
1:fe77ca5:             //available for use, it may be confusing to users that we swallow
1:fe77ca5:             //the IO error here.
1:fe77ca5: 
1:fe77ca5:             localAW.println("Could not get locale properties from : " + is);
1:fe77ca5:           }
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:       }
1:fe77ca5:       catch (Throwable t) {
1:fe77ca5:         localAW.println ("Could not load resource: " + localeResource);
1:fe77ca5:         localAW.println ("Exception: " + t);
1:fe77ca5:       }
1:fe77ca5: 
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     localAW.println (sep);
1:fe77ca5: 
1:fe77ca5:   } // end of reportLocales
1:fe77ca5: 
1:2790509:   /**
1:2790509:   Writes out information about the derbyTesting classes with the product.
1:2790509: 
1:2790509:   @param localAW the AppStreamWriter to which the info is written. If this
1:2790509:   value is null, the info is written to System.out
1:2790509: 
1:2790509:    */
1:2790509:   private static void reportTesting (java.io.PrintWriter localAW) {
1:2790509: 
1:2790509:       String hdr="org.apache.derbyTesting.*:";
1:2790509:       Properties p = new Properties ();
1:2790509:       String tstingResource ="/org/apache/derby/info/tsting.properties";
1:2790509: 
1:2790509:       final Properties finalp = p;
1:2790509:       final String finalTstingResource = tstingResource;
1:2790509:       try {
1:2790509:           InputStream is = AccessController.doPrivileged
1:2790509:                   (new PrivilegedAction<InputStream>() {
1:2790509:                       public InputStream run() {
1:2790509:                           InputStream is =
1:2790509:                                   finalp.getClass().getResourceAsStream (finalTstingResource);
1:2790509:                           return is;
1:2790509:                       }
1:2790509:                   });
1:2790509:           if (is == null) {
1:2790509:               //localAW.println("resource is null: " + tstingResource);
1:2790509:           }
1:2790509:           else {
1:2790509:               try {
1:2790509:                   p.clear();
1:2790509:                   p.load (is);
1:2790509:                   //Displaying Testing info
1:2790509:                   //String tstingName = p.getProperty("derby.tsting.external.name");
1:2790509: 
1:2790509:                   StringBuffer successes = new StringBuffer(Main.getTextMessage(crLf()));
1:2790509:                   StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1:2790509:                   tryTstingClasspath(successes, failures);
1:2790509:                   String successString = successes.toString();
1:2790509: 
1:2790509:                   if (successString.isEmpty() || successString.length()<=2)
1:2790509:                   {
1:2790509:                       // if we don't have the BaseTestCase class, assume we don't have any of the
1:2790509:                       // testing classes, and just print nothing
1:2790509:                       // this would be the situation that end-users would likely see.
1:2790509:                       return;
1:2790509:                   }
1:2790509: 
1:2790509:                   // show the path and add brackets like we do for the core classes
1:2790509:                   localAW.println(hdr);
1:2790509:                   localAW.print("\t ");
1:2790509:                   localAW.print("[");
1:2790509:                   localAW.print(formatURL(new URL(successString)));
1:2790509:                   localAW.println("]");
1:2790509:                   // show the version info
1:2790509:                   int major = Integer.parseInt(p.getProperty ("derby.tsting.version.major"));
1:2790509:                   int minor = Integer.parseInt(p.getProperty ("derby.tsting.version.minor"));
1:2790509:                   int maint = Integer.parseInt(p.getProperty ("derby.tsting.version.maint"));
1:2790509:                   String build = p.getProperty ("derby.tsting.build.number");
1:2790509:                   String lv = ProductVersionHolder.fullVersionString(major, minor, maint, false, build);
1:2790509:                   localAW.println (Main.getTextMessage ("SIF01.S", lv));
1:2790509:               } catch (IOException ioe) {
1:2790509:                   //This case is a bit ugly. If we get an IOException, we return
1:2790509:                   //null. Though this correctly reflects that the product is not
1:2790509:                   //available for use, it may be confusing to users that we swallow
1:2790509:                   //the IO error here.
1:2790509:                   localAW.println("Could not get testing properties from : " + is);
1:2790509:               }
1:2790509:           }
1:2790509:           localAW.println (sep);
1:2790509:       }
1:2790509:       catch (Throwable t) {
1:2790509:           localAW.println ("Could not load resource: " + tstingResource);
1:2790509:           localAW.println ("Exception: " + t);
1:2790509:       }
1:2790509:   } // end of reportTesting
1:2790509:   
1:fe77ca5: 	/* for arguments, choose from one of:*/
1:fe77ca5: 	private static final String EMBEDDED = "embedded";
1:fe77ca5: 
1:fe77ca5: 	/* you can add this if you like*/
1:fe77ca5: 	private static final String TOOLS = "tools";
1:fe77ca5: 
1:fe77ca5: 	private static final String NET = "server";
1:fe77ca5: 	private static final String CLIENT = "client";
1:fe77ca5: 
1:fe77ca5: 	/* you can add this if you like */
1:fe77ca5: 
1:fe77ca5: 	private static final String MAINUSAGESTRING = "java org.apache.derby.tools.sysinfo -cp";
1:fe77ca5: 
1:7a7a289:     private static final String USAGESTRINGPARTA = MAINUSAGESTRING + " [ [ "
1:7a7a289:             + EMBEDDED + " ][ " + NET + " ][ " + CLIENT + "] [ " + TOOLS
1:7a7a289:             + " ] [";
1:fe77ca5:     private static final String USAGESTRINGPARTB = ".class ] ]";
1:fe77ca5: 
1:fe77ca5:   static  void useMe(String[] args, java.io.PrintWriter pw) {
1:fe77ca5: 	  java.io.PrintWriter localPW = pw;
1:fe77ca5: 
1:fe77ca5: 	    if (localPW == null)
1:fe77ca5: 	    {
1:fe77ca5: 	        localPW = new java.io.PrintWriter(System.out);
1:fe77ca5: 	    }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:       int length = args.length;
1:fe77ca5: 	  if (length==1) {
1:fe77ca5: 
1:fe77ca5: 		  try {
1:fe77ca5: 			  tryAllClasspaths(localPW);
1:fe77ca5: 
1:fe77ca5: 		  }
1:fe77ca5: 
1:fe77ca5: 		  catch (Throwable t) {
1:fe77ca5: 
1:fe77ca5: 		  }
1:fe77ca5: 	  }
1:fe77ca5: 	  else {
1:fe77ca5: 		  try {
1:fe77ca5: 			  trySomeClasspaths(args, localPW);
1:fe77ca5: 		  }
1:fe77ca5: 
1:fe77ca5: 		  catch (Throwable t) {
1:fe77ca5: 
1:fe77ca5: 		  }
1:fe77ca5: 	  }
1:fe77ca5: 
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	  private static void tryAllClasspaths(java.io.PrintWriter localPW) throws Throwable {
1:fe77ca5: 		  localPW.println(Main.getTextMessage("SIF08.B"));
1:fe77ca5: 		  localPW.println(Main.getTextMessage("SIF08.C", MAINUSAGESTRING + " args"));
1:fe77ca5: 		  StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
1:fe77ca5: 		  StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1:fe77ca5: 		  tryCoreClasspath(successes, failures);
1:fe77ca5: 		  tryNetClasspath(successes, failures);
1:fe77ca5: 		  tryClientClasspath(successes, failures);
1:fe77ca5: 		  tryUtilsClasspath(successes, failures);
1:fe77ca5: 		  localPW.println(successes.toString());
1:fe77ca5: 		  if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
1:fe77ca5: 			  localPW.println(failures.toString());
1:fe77ca5: 		  }
1:fe77ca5: 		  else {
1:fe77ca5: 
1:fe77ca5: 			  localPW.println(Main.getTextMessage("SIF08.F"));
1:fe77ca5: 		  }
1:fe77ca5: 		  localPW.flush();
1:fe77ca5: 	  }
1:fe77ca5: 
1:fe77ca5: 	private static void trySomeClasspaths(String[] args, java.io.PrintWriter localPW) throws Throwable {
1:fe77ca5: 
1:fe77ca5: 		boolean seenArg = false;
1:fe77ca5: 		StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
1:fe77ca5: 		StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1:fe77ca5: 
1:fe77ca5: 		if (argumentsContain(args, EMBEDDED))
1:fe77ca5: 		{
1:fe77ca5: 
1:fe77ca5: 			tryCoreClasspath(successes, failures);
2:fe77ca5: 			seenArg =true;
1:fe77ca5: 
1:32803bc: 		}
1:fe77ca5: 		if (argumentsContain(args,NET)) {
1:fe77ca5: 		  tryNetClasspath(successes, failures);
1:32803bc: 			seenArg =true;
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 		if (argumentsContain(args,CLIENT)) {
1:fe77ca5: 		  tryClientClasspath(successes, failures);
1:fe77ca5: 			seenArg =true;
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (argumentsContain(args,TOOLS) || argumentsContain(args,"utils")) {
1:fe77ca5: 		  tryUtilsClasspath(successes, failures);
1:fe77ca5: 			seenArg =true;
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 		String userclass = argumentMatches(args, ".class");
1:fe77ca5: 		if (!userclass.equals("")) {
1:fe77ca5: 			tryMyClasspath(argumentMatches(args, ".class"), Main.getTextMessage("SIF08.H", userclass), successes, failures);
1:fe77ca5: 			seenArg =true;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (seenArg)
1:fe77ca5: 		{
1:fe77ca5: 
1:fe77ca5: 			localPW.println(successes.toString());
1:fe77ca5: 			if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
1:fe77ca5: 				localPW.println(failures.toString());
1:fe77ca5: 			}
1:fe77ca5: 			else {
1:fe77ca5: 
1:fe77ca5: 				localPW.println(Main.getTextMessage("SIF08.F"));
1:fe77ca5: 			}
1:fe77ca5: 		}
1:aeb4b10: 		else
1:fe77ca5: 		{
1:fe77ca5: 			localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
1:fe77ca5: 		}
1:fe77ca5: 		localPW.flush();
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static void tryCoreClasspath(StringBuffer successes, StringBuffer failures) {
1:fe77ca5: 		tryMyClasspath("org.apache.derby.database.Database", Main.getTextMessage("SIF08.J","derby.jar" ), successes, failures);
1:fe77ca5: 	}
1:fe77ca5: 	private static void tryNetClasspath(StringBuffer successes, StringBuffer failures) {
1:9760bd4: 		tryMyClasspath("org.apache.derby.database.Database", Main.getTextMessage("SIF08.J","derby.jar" ), successes, failures);
1:fe77ca5: 		tryMyClasspath("org.apache.derby.drda.NetworkServerControl", Main.getTextMessage("SIF08.I", "derbynet.jar"), successes, failures);
1:fe77ca5: 	}
1:fe77ca5: 	private static void tryClientClasspath(StringBuffer successes, StringBuffer failures) {
1:56dc695: 		tryMyClasspath("org.apache.derby.jdbc.ClientDriver", Main.getTextMessage("SIF08.L", "derbyclient.jar"), successes, failures);
1:32803bc: 	}
1:fe77ca5: 
1:fe77ca5: 	private static void tryUtilsClasspath(StringBuffer successes, StringBuffer failures) {
1:fe77ca5: 		tryMyClasspath("org.apache.derby.tools.ij", Main.getTextMessage("SIF08.Q", "derbytools.jar"), successes, failures);
1:fe77ca5: 	}
1:2790509: 	
1:2790509: 	private static void tryTstingClasspath(StringBuffer successes, StringBuffer failures) {
1:2f455bb:         // use a class that is not dependent on junit
1:2f455bb:         tryMyClasspath("org.apache.derbyTesting.junit.XATestUtil", "", successes, failures);
1:2790509:     }
1:fe77ca5: 
1:fe77ca5: 	private static void tryMyClasspath(String cn, String library, StringBuffer successes, StringBuffer failures) {
1:fe77ca5: 
1:fe77ca5: 		try {
1:aeb4b10: 			Class c = Class.forName(cn);
1:aeb4b10:                         String loc = getFileWhichLoadedClass(c);
1:aeb4b10:                         successes.append(found(cn, library, loc));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		catch (Throwable t) {
1:fe77ca5: 
1:fe77ca5: 			failures.append(notFound(cn, library));
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static void tryAsResource(String cn, String library, StringBuffer successes, StringBuffer failures) {
1:fe77ca5: 
1:fe77ca5: 		try {
1:fe77ca5: 			java.io.InputStream in = cn.getClass().getResourceAsStream(cn);
1:fe77ca5: 			in.close();
1:aeb4b10:                         String loc = getFileWhichLoadedClass(cn.getClass());
1:aeb4b10: 			successes.append(found(cn, library, loc));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		catch (Throwable t) {
1:fe77ca5: 			failures.append(notFound(cn, library));
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:aeb4b10: 	private static String found(String cn, String library, String loc) {
1:fe77ca5: 		StringBuffer temp = new StringBuffer(crLf());
1:fe77ca5: 		temp.append("   " + library);
1:fe77ca5: 		temp.append(crLf());
1:aeb4b10:                 if (loc != null)
1:aeb4b10:                     temp.append("   ").append(loc).append(crLf());
1:fe77ca5: 		temp.append(crLf());
1:fe77ca5: 		return temp.toString();
1:fe77ca5: 	}
1:fe77ca5: 	private static String notFound(String cn, String library) {
1:fe77ca5: 
1:fe77ca5: 		StringBuffer temp = new StringBuffer(crLf());
1:fe77ca5: 		temp.append("   " + library);
1:fe77ca5: 		temp.append(crLf());
1:fe77ca5: 		temp.append("    " + Main.getTextMessage("SIF08.U", cn));
1:fe77ca5: 		temp.append(crLf());
1:fe77ca5: 		temp.append(crLf());
1:fe77ca5: 		return temp.toString();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static String crLf() {
1:fe77ca5: 		return System.getProperty("line.separator");
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static String lookForMainArg(String[] args, java.io.PrintWriter localPW)
1:32803bc: 	{
1:fe77ca5: 		int length=args.length;
1:fe77ca5: 		String[] legalargs = new String[1];
1:fe77ca5: 		legalargs[0] = EMBEDDED;
1:fe77ca5: 
1:fe77ca5: 		int argsfound = 0;
1:fe77ca5: 		String whichargument="";
1:fe77ca5: 
1:fe77ca5: 		for (int i = 0; i < length; i++) {
1:fe77ca5: 
1:fe77ca5: 			for (int j=0; j < legalargs.length; j++) {
1:fe77ca5: 				if (args[i].toUpperCase(java.util.Locale.ENGLISH).equals(legalargs[j].toUpperCase(java.util.Locale.ENGLISH))) {
1:fe77ca5: 					argsfound++;
1:fe77ca5: 					whichargument=legalargs[j];
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 		if (argsfound > 1 || argsfound < 1) {
1:fe77ca5:             localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 		return whichargument;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static boolean argumentsContain(String[] args, String s) {
1:fe77ca5: 		for (int i = 0; i < args.length; i++) {
1:fe77ca5: 			if (args[i].equalsIgnoreCase(s))
1:fe77ca5: 				return true;
1:fe77ca5: 		}
1:fe77ca5: 		return false;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static String argumentMatches(String[] args, String ss) {
1:fe77ca5: 	    String userclass = "";
1:fe77ca5: 		int length = args.length;
1:fe77ca5: 		for (int i = 0; i < length; i++) {
1:fe77ca5: 			if (args[i].endsWith(ss)) {
1:fe77ca5: 				userclass = args[i].substring(0,args[i].length()-6) ;
1:fe77ca5: 
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 		return userclass;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Code related to loading info fromjar files.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5:     private static final String infoNames[] = {
1:fe77ca5: 
1:fe77ca5:                                     "org/apache/derby/info/" +
1:fe77ca5:                                     org.apache.derby.iapi.services.info.ProductGenusNames.DBMS +
1:fe77ca5:                                     ".properties",
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:                                     "org/apache/derby/info/" +
1:fe77ca5:                                     org.apache.derby.iapi.services.info.ProductGenusNames.TOOLS +
1:fe77ca5:                                     ".properties",
1:fe77ca5: 
1:fe77ca5:                                     "org/apache/derby/info/" +
1:fe77ca5:                                     org.apache.derby.iapi.services.info.ProductGenusNames.NET +
1:56dc695:                                     ".properties",
1:56dc695: 
1:56dc695:                                    "org/apache/derby/info/" +
1:56dc695:                                     org.apache.derby.iapi.services.info.ProductGenusNames.DNC +
1:7d9c8c7:                                     ".properties",
1:7d9c8c7: 
1:7d9c8c7:                                    "org/apache/derby/optional/" +
1:7d9c8c7:                                     org.apache.derby.iapi.services.info.ProductGenusNames.OPTIONALTOOLS +
1:7d9c8c7:                                     ".properties",
1:fe77ca5:                                 };
1:fe77ca5: 
1:379f95f:     /**
1:379f95f:      *  Get all the info we can obtain from the local execution context
1:379f95f:      *  as to the availability of the Derby classes by attempting to load
1:379f95f:      *  the info files with loadZipFromResource() and checking classpath
1:379f95f:      *  locations with checkForInfo if the classpath is accessible.
1:379f95f:      *
1:379f95f:      *  @param classpath the classpath, or null if not accessible
1:379f95f:      *  @return an array of ZipInfoProperties with the locations of the located
1:379f95f:      *          resources
1:379f95f:      *  @see #loadZipFromResource()
1:379f95f:      *  @see #checkForInfo(String)
1:379f95f:      */
1:fe77ca5:     public static ZipInfoProperties[] getAllInfo(String classpath)
1:fe77ca5:     {
1:379f95f:         ZipInfoProperties zips[] = loadZipFromResource();
1:379f95f: 
1:379f95f:         // No info properties files found, but here we are in sysinfo.
1:379f95f:         // Avoid an NPE in mergeZips by creating a ZipInfoProperties array
1:379f95f:         // with the location of the sysinfo that is currently executing.
1:379f95f:         if (zips == null)
1:379f95f:         {
1:379f95f:             zips = new ZipInfoProperties[1];
1:379f95f:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(org.apache.derby.tools.sysinfo.TOOLS));
1:379f95f:             zip.setLocation(getFileWhichLoadedClass(new Main().getClass()));
1:379f95f:             zips[0] = zip;
1:379f95f:         }
1:379f95f: 
3:fe77ca5:         try
1:fe77ca5:         {
1:fe77ca5: 			if (classpath != null) {
1:fe77ca5: 				String cp [] = parseClasspath(classpath);
1:16d3334: 				Vector<ZipInfoProperties> v = new Vector<ZipInfoProperties>();
1:fe77ca5: 				for (int i = 0; i < cp.length; i++)
1:fe77ca5: 				{
1:f64222c: 					ZipInfoProperties zip = null;
1:f64222c: 					try {
1:f64222c: 						zip = checkForInfo(cp[i]);
1:f64222c: 					}
1:f64222c: 					catch (SecurityException se)
1:f64222c: 					{
1:f64222c: 						zip = new ZipInfoProperties(null);
1:f64222c: 						zip.setLocation(
1:f64222c: 							Main.getTextMessage ("SIF03.C", se.getMessage()));
1:f64222c: 					}
1:fe77ca5: 					if (zip != null)
1:fe77ca5: 					{
1:fe77ca5: 						v.addElement(zip);
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 				if (v.size() > 0)
1:fe77ca5: 				{
1:379f95f: 					ZipInfoProperties cpzips[] = new ZipInfoProperties[v.size()];
1:379f95f: 					v.copyInto(cpzips);
1:379f95f: 					return mergeZips(zips, cpzips);
1:fe77ca5: 				}
1:fe77ca5: 			}
1:379f95f:             return mergeZips(zips, null);
1:fe77ca5: 
1:fe77ca5:         }
1:fe77ca5:         catch (SecurityException se)
1:fe77ca5:         {
1:fe77ca5:             ZipInfoProperties zip[] = new ZipInfoProperties[1];
1:fe77ca5:             zip[0] = new ZipInfoProperties(null);
1:f64222c:             zip[0].setLocation(
1:f64222c: 					Main.getTextMessage ("SIF03.C", se.getMessage()));
4:fe77ca5:             return zip;
1:fe77ca5:         }
1:fe77ca5:     }
1:fe77ca5: 
1:379f95f:     /**
1:379f95f:      *  Attempt to load the info properties files specified in infoNames[i]
1:379f95f:      *  using getResourceAsStream(). If none are able to be loaded, return
1:379f95f:      *  a null array.
1:379f95f:      *
1:379f95f:      *  @return An array of ZipInfoProperties with the locations from which
1:379f95f:      *          the info properties files were loaded.
1:379f95f:      *  @see #infoNames
1:fe77ca5:      */
1:fe77ca5:     private static ZipInfoProperties [] loadZipFromResource()
1:fe77ca5:     {
1:16d3334: 		java.util.ArrayList<ZipInfoProperties> al = new java.util.ArrayList<ZipInfoProperties>();
1:fe77ca5: 
1:fe77ca5:         for (int i = 0; i < infoNames.length; i++)
1:fe77ca5:         {
1:c7549a5:             final String resource = "/".concat(infoNames[i]);
1:fe77ca5: 
1:16d3334:             InputStream is = AccessController.doPrivileged
1:16d3334:             (new PrivilegedAction<InputStream>() {
1:16d3334:                 public InputStream run() {
1:c7549a5: 			        InputStream locis =
1:c7549a5:                         new Main().getClass().getResourceAsStream(resource);
1:c7549a5:                             return locis;
1:c7549a5:                     }
1:c7549a5:                 }
1:c7549a5:             );         
1:c7549a5: 
1:fe77ca5: 			if (is == null)
1:fe77ca5: 				continue;
1:fe77ca5: 
1:fe77ca5: 			ZipInfoProperties ze = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(is));
1:379f95f:  
1:379f95f:                         // get the real location of the info file
1:16d3334:                         URL locUrl = AccessController.doPrivileged
1:16d3334:                         (new PrivilegedAction<URL>() {
1:16d3334:                             public URL run() {
1:379f95f:                                 URL realUrl = new Main().getClass().getResource(resource);
1:379f95f:                                 return realUrl;
1:379f95f:                             }
1:379f95f:                         });
1:379f95f: 
1:379f95f: 			ze.setLocation(formatURL(locUrl));
1:fe77ca5: 
1:fe77ca5: 			al.add(ze);
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         if (al.size() == 0)
1:fe77ca5:         {
4:fe77ca5:             return null;
1:aeb4b10:         }
1:fe77ca5: 
1:fe77ca5:         ZipInfoProperties[] zip = new ZipInfoProperties[al.size()];
1:fe77ca5: 
1:fe77ca5: 		al.toArray(zip);
1:fe77ca5: 
1:fe77ca5:         return zip;
1:fe77ca5:     }
1:fe77ca5: 
1:379f95f:     /**
1:379f95f:      *  Split the classpath into separate elements.
1:379f95f:      *
1:379f95f:      *  @param cp the classpath, if accessible.
1:379f95f:      *  @return a String array with the individual classpath elements.
1:379f95f:      */
1:fe77ca5:     private static String [] parseClasspath(String cp)
1:aeb4b10:     {
1:fe77ca5:         StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);
1:fe77ca5:         int count = st.countTokens();
1:fe77ca5:         if (count == 0)
1:fe77ca5:         {
1:fe77ca5:             return null;
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         String vals[] = new String[count];
1:fe77ca5:         for (int i =0; i < count; i++)
1:fe77ca5:         {
1:fe77ca5:             vals[i] = st.nextToken();
1:fe77ca5:         }
1:fe77ca5:         return vals;
1:fe77ca5:     }
1:fe77ca5: 
1:379f95f:     /**
1:379f95f:      *  Given an individual element of the element of the classpath, call
1:379f95f:      *  checkDirectory() if the element is a directory or checkFile()
1:379f95f:      *  if the element is a file.
1:379f95f:      *
1:379f95f:      *  @param cpEntry the classpath element
1:379f95f:      *  @return a ZipInfoProperties if an info properties file is found.
1:379f95f:      */
1:63adae8:     private static ZipInfoProperties checkForInfo(final String cpEntry)
1:63adae8:     {
1:16d3334:         return AccessController.doPrivileged( new PrivilegedAction<ZipInfoProperties>()
1:63adae8:             {
1:16d3334:                 public ZipInfoProperties run()
1:fe77ca5:                 {
1:63adae8:                     File f = new File(cpEntry);
1:63adae8:                     if ( ! f.exists())
1:63adae8:                     {
1:63adae8:                         return null;
1:63adae8:                     }
1:fe77ca5: 
1:63adae8:                     if (f.isDirectory())
1:63adae8:                     {
1:63adae8:                         ZipInfoProperties zip = checkDirectory(cpEntry);
1:63adae8:                         return zip;
1:63adae8:                     }
1:fe77ca5: 
1:63adae8:                     if (f.isFile())
1:63adae8:                     {
1:63adae8:                         ZipInfoProperties zip = checkFile(cpEntry);
1:63adae8:                         return zip;
1:63adae8:                     }
1:63adae8:                     return null;
1:63adae8:                 }
1:63adae8:             }
1:63adae8:             );
1:63adae8:         
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:     /**
1:379f95f:      *  Check a given directory for the presence of an info properties file in
1:379f95f:      *  org/apache/derby/info inside the directory.
1:379f95f:      *
1:379f95f:      *  @param dirname the directory to check as a String
1:379f95f:      *  @return a ZipInfoProperties if a file is found, otherwise null.
1:379f95f:      */
1:fe77ca5:     private static ZipInfoProperties checkDirectory(String dirname)
1:fe77ca5:     {
1:fe77ca5:         boolean foundOne = false;
1:fe77ca5:         File f = null;
1:fe77ca5:         for (int i = 0; i < infoNames.length; i++)
1:fe77ca5:         {
1:fe77ca5:             String localSysinfo = infoNames[i].replace('/', File.separatorChar);
1:fe77ca5:             f = new File(dirname, localSysinfo);
1:fe77ca5:             if (f.exists())
1:fe77ca5:             {
1:fe77ca5:                 foundOne = true;
1:fe77ca5:                 break;
1:fe77ca5:             }
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         if (!foundOne || (f == null))
1:fe77ca5:         {
1:fe77ca5:             return null;
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         try
1:fe77ca5:         {
1:fe77ca5:             InputStream bis = new FileInputStream(f);
1:fe77ca5: 
1:fe77ca5:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
1:52d42fe:             zip.setLocation(getCanonicalPath(new File(dirname)).replace('/', File.separatorChar));
1:fe77ca5:             return zip;
1:fe77ca5:         }
1:fe77ca5:         catch (IOException ioe)
1:fe77ca5:         {
1:fe77ca5:             return null;
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:     /**
1:7a7a289:      * Check inside a jar file for the presence of a Derby info properties file.
1:7a7a289:      * 
1:7a7a289:      * @param filename
1:7a7a289:      *            the jar file to check
1:7a7a289:      * @return ZipInfoProperties with the jar file set as the location or null
1:7a7a289:      *         if not found.
1:fe77ca5:      */
1:fe77ca5:     private static ZipInfoProperties checkFile(String filename)
1:fe77ca5:     {
1:fe77ca5:         // try to create a ZipFile from it
1:fe77ca5:         try
1:fe77ca5:         {
1:fe77ca5:             ZipFile zf = new ZipFile(filename);
1:fe77ca5:             // try to get a ZipEntry from the ZipFile
1:fe77ca5: 
1:fe77ca5:             ZipEntry thisEntry = null;
1:fe77ca5: 
1:fe77ca5:             for (int i =0; i < infoNames.length; i++)
1:fe77ca5:             {
1:fe77ca5:                 thisEntry = zf.getEntry(infoNames[i]);
1:fe77ca5:                 if (thisEntry != null)
1:fe77ca5:                 {
1:fe77ca5:                     break;
1:fe77ca5:                 }
1:fe77ca5:             }
1:fe77ca5: 
1:fe77ca5:             if (thisEntry == null)
1:fe77ca5:             {
1:fe77ca5:                 return null;
1:fe77ca5:             }
1:fe77ca5: 
1:fe77ca5:             InputStream bis = zf.getInputStream(thisEntry);
1:fe77ca5:             if (bis == null)
1:fe77ca5:             {
1:fe77ca5:                 return null;
1:fe77ca5:             }
1:fe77ca5: 
1:fe77ca5:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
1:52d42fe:             zip.setLocation(getCanonicalPath(new File(filename)).replace('/', File.separatorChar));
1:fe77ca5:             return zip;
1:fe77ca5: 
1:fe77ca5:         }
1:fe77ca5:         catch (IOException ioe)
1:fe77ca5:         {
1:fe77ca5:             //guess not
1:fe77ca5:             return null;
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Message handling
1:fe77ca5: 	*/
1:fe77ca5: 
1:c465481:     public static String getTextMessage(String msgId, Object... arguments) {
1:9a55084:         return LOCALIZED_RESOURCE.getTextMessage(msgId, arguments);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:     /**
1:aeb4b10:      * Given a loaded class, this
1:aeb4b10:      * routine asks the class's class loader for information about where the
1:aeb4b10:      * class was loaded from. Typically, this is a file, which might be
1:aeb4b10:      * either a class file or a jar file. The routine figures that out, and
1:aeb4b10:      * returns the name of the file. If it can't figure it out, it returns null
1:aeb4b10:      */
1:aeb4b10:     private static String getFileWhichLoadedClass(final Class cls)
1:aeb4b10:     {
1:16d3334:          return AccessController.doPrivileged( new PrivilegedAction<String>()
1:aeb4b10:         {
1:16d3334:             public String run()
1:aeb4b10:             {
1:aeb4b10:                 CodeSource cs = null;
1:aeb4b10:                 try {
1:aeb4b10:                     cs = cls.getProtectionDomain().getCodeSource ();
1:aeb4b10:                 }
1:aeb4b10:                 catch (SecurityException se) {
1:87fd55c:                     return Main.getTextMessage(
1:87fd55c:                         "SIF01.V", cls.getName(), se.getMessage());
1:aeb4b10:                 }
1:aeb4b10:  
1:aeb4b10:                 if ( cs == null )
1:aeb4b10:                     return null;        
1:aeb4b10:      
1:aeb4b10:                 URL result = cs.getLocation ();
1:7a7a289: 
1:7a7a289:                 try {
1:7a7a289:                     // DERBY-4806 Should use UTF-8 according to
1:7a7a289:                     // http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars
1:7a7a289:                     // to get the string of the file name
1:7a7a289:                     return URLDecoder.decode(result.toString(), "UTF-8");
1:7a7a289:                 } catch (UnsupportedEncodingException e) {
1:7a7a289:                     // All JVMs are required to support UTF-8.
1:7a7a289:                     return e.getMessage();
1:7a7a289:                 }
1:aeb4b10:             }
1:aeb4b10:         });
1:aeb4b10:     }
1:379f95f: 
1:379f95f:     /**
1:379f95f:      *  <P>
1:379f95f:      *  Merge and flatten two arrays of ZipInfoProperties, removing any 
1:379f95f:      *  duplicates. There may be duplicates in the arrays because
1:379f95f:      *  loadZipFromResource may find all the properties files in the same
1:379f95f:      *  location, such as when loading from compiled source instead of
1:379f95f:      *  packaged jars. Also, a poorly constructed classpath may contain
1:379f95f:      *  duplicate entries that each contain the Derby classes, and we
1:379f95f:      *  need only report the first of each such instances found.
1:379f95f:      *  <P>
1:379f95f:      *  The second array may be null if the classpath was empty, in which
1:379f95f:      *  case we still remove the duplicates from the first array and return 
1:379f95f:      *  the shortened array.
1:379f95f:      *
1:379f95f:      *  @param zip1 the first array from loadZipWithResource
1:379f95f:      *  @param zip2 the second array from analyzing the classpath
1:379f95f:      *  @return the merged array
1:379f95f:      */
1:379f95f:     private static ZipInfoProperties[] mergeZips(ZipInfoProperties[] zip1,
1:379f95f:                                                  ZipInfoProperties[] zip2)
1:379f95f:     {
1:16d3334:         Vector<ZipInfoProperties> v = new Vector<ZipInfoProperties>();
1:379f95f:         boolean foundDup = false;
1:379f95f:   
1:379f95f:         // remove duplicates from first array
1:379f95f:         for (int i = 0; i < zip1.length; i++)
1:379f95f:         {
1:379f95f:             if (zip1[i] != null && zip1.length > 1)
1:379f95f:             {
1:379f95f:                 for (int j = i + 1; j < zip1.length; j++)
1:379f95f:                 {
1:379f95f:                     if (zip1[i].getLocation().equals(zip1[j].getLocation()))
1:379f95f:                     zip1[j] = null;
1:379f95f:                 }
1:379f95f:             }
1:379f95f:             if (zip1[i] != null)
1:379f95f:               v.addElement(zip1[i]);
1:379f95f:         }
1:379f95f:   
1:379f95f:         // if provided a second array, remove any locations in second array
1:379f95f:         // still in first array.
1:379f95f:         if (zip2 != null)
1:379f95f:         {
1:379f95f:           for (int j = 0; j < zip2.length; j++)
1:379f95f:           {
1:379f95f:             for (int k = 0; k < v.size(); k++)
1:379f95f:             {
1:16d3334:                 ZipInfoProperties z = v.get(k);
1:379f95f:                 if (zip2[j].getLocation().equals(z.getLocation()))
1:379f95f:                   foundDup = true;
1:379f95f:             }
1:379f95f:             if (!foundDup)
1:379f95f:             {
1:379f95f:                 v.addElement(zip2[j]);
1:379f95f:             }
1:379f95f:             foundDup = false;
1:379f95f:           }
1:379f95f:         }
1:379f95f:   
1:379f95f:         ZipInfoProperties[] merged = new ZipInfoProperties[v.size()];
1:379f95f:         v.copyInto(merged);
1:379f95f:         return merged;
1:379f95f:     }
1:379f95f: 
1:379f95f:     /**
1:379f95f:      *  Strip a given URL down to the filename. The URL will be a jarfile or
1:379f95f:      *  directory containing a Derby info properties file. Return the canonical
1:379f95f:      *  path for the filename, with the path separators normalized.
1:379f95f:      */
1:379f95f:     private static String formatURL(URL loc)
1:379f95f:     {
1:129b076:         String filename;
1:129b076:         try {
1:129b076:             // Should use UTF-8 according to
1:129b076:             // http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars
1:129b076:             filename = URLDecoder.decode(loc.toString(), "UTF-8");
1:129b076:         } catch (UnsupportedEncodingException e) {
1:129b076:             // All JVMs are required to support UTF-8.
1:129b076:             return null;
1:129b076:         }
1:379f95f: 
1:379f95f:         if (filename.startsWith("jar:")) { filename = filename.substring(4); }
1:379f95f:         if (filename.startsWith("file:")) { filename = filename.substring(5); }
1:379f95f:         if (filename.indexOf("!") > -1) { filename = filename.substring(0, filename.indexOf("!")); }
1:379f95f:         if (filename.indexOf("/org/apache/derby") > -1) { 
1:379f95f:             filename = filename.substring(0, filename.indexOf("/org/apache/derby")); 
1:379f95f:         }
1:379f95f:         if (filename.charAt(0) == '/' && 
1:379f95f:             Character.isLetter(filename.charAt(1)) &&
1:379f95f:             filename.charAt(2) == ':' &&
1:379f95f:             filename.charAt(2) == '/') { filename = filename.substring(1); }
1:379f95f: 
1:379f95f:         String result = ""; 
1:379f95f:         try {
1:52d42fe:             result = getCanonicalPath(new File(filename)).replace('/', File.separatorChar);
1:379f95f:         } catch (IOException e) {
1:7a7a289:             result = e.getMessage();
1:379f95f:         }
1:379f95f:         return result;
1:379f95f:     }
1:379f95f: 
1:fe77ca5: } // end of class Main
1:aeb4b10: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:953afd7
/////////////////////////////////////////////////////////////////////////
1:         new LocalizedResource(MESSAGE_FILE);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2f455bb
/////////////////////////////////////////////////////////////////////////
1:         // use a class that is not dependent on junit
1:         tryMyClasspath("org.apache.derbyTesting.junit.XATestUtil", "", successes, failures);
commit:2790509
/////////////////////////////////////////////////////////////////////////
1:     
1:     // derbyTesting info
1:     try {
1:         reportTesting(aw);
1:     }
1:     catch (Exception e) {
1:         // ignore locales for the testing jar
1:         aw.println("Exception in reporting version of derbyTesting.jar");
1:         e.printStackTrace();
1:     }
/////////////////////////////////////////////////////////////////////////
1:   /**
1:   Writes out information about the derbyTesting classes with the product.
1: 
1:   @param localAW the AppStreamWriter to which the info is written. If this
1:   value is null, the info is written to System.out
1: 
1:    */
1:   private static void reportTesting (java.io.PrintWriter localAW) {
1: 
1:       String hdr="org.apache.derbyTesting.*:";
1:       Properties p = new Properties ();
1:       String tstingResource ="/org/apache/derby/info/tsting.properties";
1: 
1:       final Properties finalp = p;
1:       final String finalTstingResource = tstingResource;
1:       try {
1:           InputStream is = AccessController.doPrivileged
1:                   (new PrivilegedAction<InputStream>() {
1:                       public InputStream run() {
1:                           InputStream is =
1:                                   finalp.getClass().getResourceAsStream (finalTstingResource);
1:                           return is;
1:                       }
1:                   });
1:           if (is == null) {
1:               //localAW.println("resource is null: " + tstingResource);
1:           }
1:           else {
1:               try {
1:                   p.clear();
1:                   p.load (is);
1:                   //Displaying Testing info
1:                   //String tstingName = p.getProperty("derby.tsting.external.name");
1: 
1:                   StringBuffer successes = new StringBuffer(Main.getTextMessage(crLf()));
1:                   StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1:                   tryTstingClasspath(successes, failures);
1:                   String successString = successes.toString();
1: 
1:                   if (successString.isEmpty() || successString.length()<=2)
1:                   {
1:                       // if we don't have the BaseTestCase class, assume we don't have any of the
1:                       // testing classes, and just print nothing
1:                       // this would be the situation that end-users would likely see.
1:                       return;
1:                   }
1: 
1:                   // show the path and add brackets like we do for the core classes
1:                   localAW.println(hdr);
1:                   localAW.print("\t ");
1:                   localAW.print("[");
1:                   localAW.print(formatURL(new URL(successString)));
1:                   localAW.println("]");
1:                   // show the version info
1:                   int major = Integer.parseInt(p.getProperty ("derby.tsting.version.major"));
1:                   int minor = Integer.parseInt(p.getProperty ("derby.tsting.version.minor"));
1:                   int maint = Integer.parseInt(p.getProperty ("derby.tsting.version.maint"));
1:                   String build = p.getProperty ("derby.tsting.build.number");
1:                   String lv = ProductVersionHolder.fullVersionString(major, minor, maint, false, build);
1:                   localAW.println (Main.getTextMessage ("SIF01.S", lv));
1:               } catch (IOException ioe) {
1:                   //This case is a bit ugly. If we get an IOException, we return
1:                   //null. Though this correctly reflects that the product is not
1:                   //available for use, it may be confusing to users that we swallow
1:                   //the IO error here.
1:                   localAW.println("Could not get testing properties from : " + is);
1:               }
1:           }
1:           localAW.println (sep);
1:       }
1:       catch (Throwable t) {
1:           localAW.println ("Could not load resource: " + tstingResource);
1:           localAW.println ("Exception: " + t);
1:       }
1:   } // end of reportTesting
1:   
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private static void tryTstingClasspath(StringBuffer successes, StringBuffer failures) {
0:         tryMyClasspath("org.apache.derbyTesting.junit.BaseTestCase", "", successes, failures);
1:     }
commit:d1b8db2
/////////////////////////////////////////////////////////////////////////
1:         LocalizedResource.getInstance().init();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7d9c8c7
/////////////////////////////////////////////////////////////////////////
1:                                     ".properties",
1: 
1:                                    "org/apache/derby/optional/" +
1:                                     org.apache.derby.iapi.services.info.ProductGenusNames.OPTIONALTOOLS +
1:                                     ".properties",
commit:16d3334
/////////////////////////////////////////////////////////////////////////
1:           classpath = AccessController.doPrivileged( new PrivilegedAction<String>()
1:                   public String run()
/////////////////////////////////////////////////////////////////////////
1:         String  property = AccessController.doPrivileged( new PrivilegedAction<String>()
1:                 public  String  run()
/////////////////////////////////////////////////////////////////////////
1:             return AccessController
1:                     .doPrivileged(new PrivilegedExceptionAction<String>() {
1:                         public String run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         	InputStream is = AccessController.doPrivileged
1:             (new PrivilegedAction<InputStream>() {
1:                   public InputStream run() {
/////////////////////////////////////////////////////////////////////////
1: 				Vector<ZipInfoProperties> v = new Vector<ZipInfoProperties>();
/////////////////////////////////////////////////////////////////////////
1: 		java.util.ArrayList<ZipInfoProperties> al = new java.util.ArrayList<ZipInfoProperties>();
1:             InputStream is = AccessController.doPrivileged
1:             (new PrivilegedAction<InputStream>() {
1:                 public InputStream run() {
/////////////////////////////////////////////////////////////////////////
1:                         URL locUrl = AccessController.doPrivileged
1:                         (new PrivilegedAction<URL>() {
1:                             public URL run() {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged( new PrivilegedAction<ZipInfoProperties>()
1:                 public ZipInfoProperties run()
/////////////////////////////////////////////////////////////////////////
1:          return AccessController.doPrivileged( new PrivilegedAction<String>()
1:             public String run()
/////////////////////////////////////////////////////////////////////////
1:         Vector<ZipInfoProperties> v = new Vector<ZipInfoProperties>();
/////////////////////////////////////////////////////////////////////////
1:                 ZipInfoProperties z = v.get(k);
commit:62d63f6
/////////////////////////////////////////////////////////////////////////
1:   value returned will be "<info unavailable>".
/////////////////////////////////////////////////////////////////////////
commit:63adae8
/////////////////////////////////////////////////////////////////////////
1: 	  String classpath = null;
1:       try {
0:           classpath = (String) AccessController.doPrivileged( new PrivilegedAction()
1:               {
0:                   public Object run()
1:                   {
1:                       return System.getProperty("java.class.path");
1:                   }
1:               }
1:               );
/////////////////////////////////////////////////////////////////////////
1:       ZipInfoProperties zip[]= Main.getAllInfo (classpath);
/////////////////////////////////////////////////////////////////////////
1:   private static String getJavaProperty (final String whichProperty) {
0:     final   String unavailable = Main.getTextMessage ("SIF01.H");
0:         String  property = (String) AccessController.doPrivileged( new PrivilegedAction()
1:             {
0:                 public  Object  run()
1:                 {
1:                     return System.getProperty (whichProperty, unavailable);
1:                 }
1:             }
1:             );
1:         return property;
/////////////////////////////////////////////////////////////////////////
1:     private static ZipInfoProperties checkForInfo(final String cpEntry)
0:         return (ZipInfoProperties) AccessController.doPrivileged( new PrivilegedAction()
1:             {
0:                 public Object run()
1:                 {
1:                     File f = new File(cpEntry);
1:                     if ( ! f.exists())
1:                     {
1:                         return null;
1:                     }
1:                     if (f.isDirectory())
1:                     {
1:                         ZipInfoProperties zip = checkDirectory(cpEntry);
1:                         return zip;
1:                     }
1:                     if (f.isFile())
1:                     {
1:                         ZipInfoProperties zip = checkFile(cpEntry);
1:                         return zip;
1:                     }
1:                     return null;
1:                 }
1:             }
1:             );
1:         
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c465481
/////////////////////////////////////////////////////////////////////////
1:     public static String getTextMessage(String msgId, Object... arguments) {
commit:87fd55c
/////////////////////////////////////////////////////////////////////////
1:                     return Main.getTextMessage(
1:                         "SIF01.V", cls.getName(), se.getMessage());
commit:9a55084
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Name of file which contains messages for sysinfo.
1:      */
1:     private final static String MESSAGE_FILE =
1:         "org.apache.derby.loc.sysinfoMessages";
1: 
1:     /**
1:      * Resource for localizing the sysinfo messages.
1:      *
1:      * The default LocalizedResource reads messages from the toolsmessages
1:      * bundle. Create this instance to read messages from sysinfoMessages. Use
1:      * the locale and codeset specified by derby.ui.locale and derby.ui.codeset
1:      * if they are set.
1:      *
1:      * Note that this variable must be initialized when the class is loaded in
1:      * order to work correctly for the API methods that don't call
1:      * <code>main()</code>.
1:      */
1:     private final static LocalizedResource LOCALIZED_RESOURCE =
0:         new LocalizedResource(null, null, MESSAGE_FILE);
1: 
/////////////////////////////////////////////////////////////////////////
0: 		return getCompleteMessage(msgId, new Object[0]);
/////////////////////////////////////////////////////////////////////////
1:         return LOCALIZED_RESOURCE.getTextMessage(msgId, arguments);
commit:129b076
/////////////////////////////////////////////////////////////////////////
1:         String filename;
1:         try {
1:             // Should use UTF-8 according to
1:             // http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars
1:             filename = URLDecoder.decode(loc.toString(), "UTF-8");
1:         } catch (UnsupportedEncodingException e) {
1:             // All JVMs are required to support UTF-8.
1:             return null;
1:         }
commit:613392c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private static void reportLocales (java.io.PrintWriter localAW) {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:88777c5
/////////////////////////////////////////////////////////////////////////
commit:52d42fe
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * wrapper for getCanonicalPath for sysinfo. For sysinfo we just want to print
1:      * the security exceptions, not throw them if we don't have permmission
1:      * 
1:      * @param f file on which to call getCanonicalPath
1:      * @return f.getCanonicalPath
1:      * @throws IOException
1:      */
1:     private static String getCanonicalPath(final File f) throws IOException {
1: 
1:         try {
0:             return (String) AccessController
0:                     .doPrivileged(new PrivilegedExceptionAction() {
0:                         public Object run() throws IOException {
1:                             return f.getCanonicalPath();
1:                         }
1:                     });
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
1:         } catch (SecurityException se) {
1:             return Main.getTextMessage("SIF01.I", se);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:             zip.setLocation(getCanonicalPath(new File(dirname)).replace('/', File.separatorChar));
/////////////////////////////////////////////////////////////////////////
1:             zip.setLocation(getCanonicalPath(new File(filename)).replace('/', File.separatorChar));
/////////////////////////////////////////////////////////////////////////
1:             result = getCanonicalPath(new File(filename)).replace('/', File.separatorChar);
commit:8f4602d
/////////////////////////////////////////////////////////////////////////
commit:54a04d3
/////////////////////////////////////////////////////////////////////////
1: 	printPropertyIfNotNull(localAW, "java.runtime.version");
1: 	printPropertyIfNotNull(localAW, "java.fullversion");
1:    * Print property only if not null
1:    * 
1:    * @param localAW This is PrintWriter to print to
1:    * @param property This is system property string
1:    */
1:   private static void printPropertyIfNotNull(java.io.PrintWriter localAW, String property) {
1:     String propertyValue = getJavaProperty(property, true);	
1:     if (propertyValue != null) {
1:         localAW.println(property + ": " + propertyValue);
1:     }
1: }
1:   
1:   /**
1:    * Return Java properties from java.lang.System. Will catch
1:    * SecurityExceptions and note them for displaying information.
1:    * @param whichProperty This is the name of the property
1:    * 
1:    * @return getJavaProperty(whichProperty, false) 
1:    */
0:   private static String getJavaProperty (final String whichProperty) {
1: 	  return getJavaProperty(whichProperty, false);  
1:   }
1:  
1:   /**
1:    * Return Java properties from java.lang.System. Will catch
1:    * SecurityExceptions and note them for displaying information.
1:    * @param whichProperty This is the name of the property
1:    * @param nullUnavailable return nothing if no such java property and nullUnavailable is true
1:    * @return the Java property value or a string capturing a
1:    * security exception.
1:   private static String getJavaProperty (final String whichProperty, boolean nullUnavailable) {
1:     final   String unavailable = nullUnavailable ? null : Main.getTextMessage ("SIF01.H");
commit:56dc695
/////////////////////////////////////////////////////////////////////////
1: 		tryMyClasspath("org.apache.derby.jdbc.ClientDriver", Main.getTextMessage("SIF08.L", "derbyclient.jar"), successes, failures);
/////////////////////////////////////////////////////////////////////////
1:                                     ".properties",
1: 
1:                                    "org/apache/derby/info/" +
1:                                     org.apache.derby.iapi.services.info.ProductGenusNames.DNC +
author:Lily Wei
-------------------------------------------------------------------------------
commit:eb7e251
/////////////////////////////////////////////////////////////////////////
1: 			int major = Integer.parseInt(p.getProperty ("derby.locale.version.major"));
1: 			int minor = Integer.parseInt(p.getProperty ("derby.locale.version.minor"));
1: 			int maint = Integer.parseInt(p.getProperty ("derby.locale.version.maint"));
commit:7a7a289
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static final String USAGESTRINGPARTA = MAINUSAGESTRING + " [ [ "
1:             + EMBEDDED + " ][ " + NET + " ][ " + CLIENT + "] [ " + TOOLS
1:             + " ] [";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Check inside a jar file for the presence of a Derby info properties file.
1:      * 
1:      * @param filename
1:      *            the jar file to check
1:      * @return ZipInfoProperties with the jar file set as the location or null
1:      *         if not found.
/////////////////////////////////////////////////////////////////////////
1: 
1:                 try {
1:                     // DERBY-4806 Should use UTF-8 according to
1:                     // http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars
1:                     // to get the string of the file name
1:                     return URLDecoder.decode(result.toString(), "UTF-8");
1:                 } catch (UnsupportedEncodingException e) {
1:                     // All JVMs are required to support UTF-8.
1:                     return e.getMessage();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             result = e.getMessage();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:27ff169
/////////////////////////////////////////////////////////////////////////
1:   Derby information; a Derby version string is returned by this Java code:
/////////////////////////////////////////////////////////////////////////
1:     the Derby product information as well as a snapshot of
commit:e77851a
/////////////////////////////////////////////////////////////////////////
1: import java.net.URLDecoder;
/////////////////////////////////////////////////////////////////////////
0:         String filename = URLDecoder.decode(loc.toString());
commit:379f95f
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1998, 2004, 2006 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   <P>
1:   Sysinfo reports values relevant to the current Derby configuration.
1:   Sysinfo looks for properties files in org.apache.derby.info named after
1:   the genus names in org.apache.derby.tools.sysinfo, and gets their location
1:   using getResource. It also searches the classpath and attempts to load
1:   the info properties files from the directory or jar locations on the
1:   classpath, and eliminates any duplicated information. If no files
1:   are found, or some other exception occurs, the
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Get all the info we can obtain from the local execution context
1:      *  as to the availability of the Derby classes by attempting to load
1:      *  the info files with loadZipFromResource() and checking classpath
1:      *  locations with checkForInfo if the classpath is accessible.
1:      *
1:      *  @param classpath the classpath, or null if not accessible
1:      *  @return an array of ZipInfoProperties with the locations of the located
1:      *          resources
1:      *  @see #loadZipFromResource()
1:      *  @see #checkForInfo(String)
1:      */
1:         ZipInfoProperties zips[] = loadZipFromResource();
1: 
1:         // No info properties files found, but here we are in sysinfo.
1:         // Avoid an NPE in mergeZips by creating a ZipInfoProperties array
1:         // with the location of the sysinfo that is currently executing.
1:         if (zips == null)
1:         {
1:             zips = new ZipInfoProperties[1];
1:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(org.apache.derby.tools.sysinfo.TOOLS));
1:             zip.setLocation(getFileWhichLoadedClass(new Main().getClass()));
1:             zips[0] = zip;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 					ZipInfoProperties cpzips[] = new ZipInfoProperties[v.size()];
1: 					v.copyInto(cpzips);
1: 					return mergeZips(zips, cpzips);
1:             return mergeZips(zips, null);
/////////////////////////////////////////////////////////////////////////
1:      *  Attempt to load the info properties files specified in infoNames[i]
1:      *  using getResourceAsStream(). If none are able to be loaded, return
1:      *  a null array.
1:      *
1:      *  @return An array of ZipInfoProperties with the locations from which
1:      *          the info properties files were loaded.
1:      *  @see #infoNames
/////////////////////////////////////////////////////////////////////////
1:  
1:                         // get the real location of the info file
0:                         URL locUrl = (URL) AccessController.doPrivileged
0:                         (new PrivilegedAction() {
0:                             public Object run() {
1:                                 URL realUrl = new Main().getClass().getResource(resource);
1:                                 return realUrl;
1:                             }
1:                         });
1: 
1: 			ze.setLocation(formatURL(locUrl));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Split the classpath into separate elements.
1:      *
1:      *  @param cp the classpath, if accessible.
1:      *  @return a String array with the individual classpath elements.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Given an individual element of the element of the classpath, call
1:      *  checkDirectory() if the element is a directory or checkFile()
1:      *  if the element is a file.
1:      *
1:      *  @param cpEntry the classpath element
1:      *  @return a ZipInfoProperties if an info properties file is found.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Check a given directory for the presence of an info properties file in
1:      *  org/apache/derby/info inside the directory.
1:      *
1:      *  @param dirname the directory to check as a String
1:      *  @return a ZipInfoProperties if a file is found, otherwise null.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      *  Check inside a jar file for the presence of a Derby info properties
0:      *  file. There is a special case for db2jcc, which does not have a Derby
0:      *  info propeties file. If db2jcc is in the filename, acquire DB2Driver
0:      *  via reflection and get the version number from it.
1:      *
0:      *  @param filename the jar file to check
0:      *  @return ZipInfoProperties with the jar file set as the location
0:      *          or null if not found.
1:      */
/////////////////////////////////////////////////////////////////////////
0:                 return formatURL(result);
1: 
1:     /**
1:      *  <P>
1:      *  Merge and flatten two arrays of ZipInfoProperties, removing any 
1:      *  duplicates. There may be duplicates in the arrays because
1:      *  loadZipFromResource may find all the properties files in the same
1:      *  location, such as when loading from compiled source instead of
1:      *  packaged jars. Also, a poorly constructed classpath may contain
1:      *  duplicate entries that each contain the Derby classes, and we
1:      *  need only report the first of each such instances found.
1:      *  <P>
1:      *  The second array may be null if the classpath was empty, in which
1:      *  case we still remove the duplicates from the first array and return 
1:      *  the shortened array.
0:      *
1:      *  @param zip1 the first array from loadZipWithResource
1:      *  @param zip2 the second array from analyzing the classpath
1:      *  @return the merged array
1:      */
1:     private static ZipInfoProperties[] mergeZips(ZipInfoProperties[] zip1,
1:                                                  ZipInfoProperties[] zip2)
1:     {
0:         Vector v = new Vector();
1:         boolean foundDup = false;
1:   
1:         // remove duplicates from first array
1:         for (int i = 0; i < zip1.length; i++)
1:         {
1:             if (zip1[i] != null && zip1.length > 1)
1:             {
1:                 for (int j = i + 1; j < zip1.length; j++)
1:                 {
1:                     if (zip1[i].getLocation().equals(zip1[j].getLocation()))
1:                     zip1[j] = null;
1:                 }
1:             }
1:             if (zip1[i] != null)
1:               v.addElement(zip1[i]);
1:         }
1:   
1:         // if provided a second array, remove any locations in second array
1:         // still in first array.
1:         if (zip2 != null)
1:         {
1:           for (int j = 0; j < zip2.length; j++)
1:           {
1:             for (int k = 0; k < v.size(); k++)
1:             {
0:                 ZipInfoProperties z = (ZipInfoProperties)v.get(k);
1:                 if (zip2[j].getLocation().equals(z.getLocation()))
1:                   foundDup = true;
1:             }
1:             if (!foundDup)
1:             {
1:                 v.addElement(zip2[j]);
1:             }
1:             foundDup = false;
1:           }
1:         }
1:   
1:         ZipInfoProperties[] merged = new ZipInfoProperties[v.size()];
1:         v.copyInto(merged);
1:         return merged;
1:     }
1: 
1:     /**
1:      *  Strip a given URL down to the filename. The URL will be a jarfile or
1:      *  directory containing a Derby info properties file. Return the canonical
1:      *  path for the filename, with the path separators normalized.
1:      */
1:     private static String formatURL(URL loc)
1:     {
0:         String filename = loc.toString();
1: 
1:         if (filename.startsWith("jar:")) { filename = filename.substring(4); }
1:         if (filename.startsWith("file:")) { filename = filename.substring(5); }
1:         if (filename.indexOf("!") > -1) { filename = filename.substring(0, filename.indexOf("!")); }
1:         if (filename.indexOf("/org/apache/derby") > -1) { 
1:             filename = filename.substring(0, filename.indexOf("/org/apache/derby")); 
1:         }
1:         if (filename.charAt(0) == '/' && 
1:             Character.isLetter(filename.charAt(1)) &&
1:             filename.charAt(2) == ':' &&
1:             filename.charAt(2) == '/') { filename = filename.substring(1); }
1: 
1:         String result = ""; 
1:         try {
0:             result = new File(filename).getCanonicalPath().replace('/', File.separatorChar);
1:         } catch (IOException e) {
0:             result = "IOException";
1:         }
1:         return result;
1:     }
1: 
commit:c7549a5
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:       
1:       final Properties finalp = p;
1:       final String finalLocaleResource = localeResource;
1:      
1:       try {     
0:         	InputStream is = (InputStream) AccessController.doPrivileged
0:             (new PrivilegedAction() {
0:                   public Object run() {
1:   		            InputStream locis =
1:   		            	finalp.getClass().getResourceAsStream (finalLocaleResource);
1:   					return locis;
1:                   }
1:               }
1:            );      
1:       	
1:       	
1:       	
/////////////////////////////////////////////////////////////////////////
1:             final String resource = "/".concat(infoNames[i]);
0:             InputStream is = (InputStream) AccessController.doPrivileged
0:             (new PrivilegedAction() {
0:                 public Object run() {
1: 			        InputStream locis =
1:                         new Main().getClass().getResourceAsStream(resource);
1:                             return locis;
1:                     }
1:                 }
1:             );         
1: 
commit:9760bd4
/////////////////////////////////////////////////////////////////////////
1: 		tryMyClasspath("org.apache.derby.database.Database", Main.getTextMessage("SIF08.J","derby.jar" ), successes, failures);
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
1:     @param localAW the AppStreamWriter to use. If null, System.out is
/////////////////////////////////////////////////////////////////////////
1:     @param localAW The AppStreamWriter to write info out to. If this is
/////////////////////////////////////////////////////////////////////////
1:     @param localAW the AppStreamWriter to which the info is written. If this
commit:3abc7d4
/////////////////////////////////////////////////////////////////////////
1:     java org.apache.derby.tools.sysinfo
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:32803bc
/////////////////////////////////////////////////////////////////////////
0: 	private static final String DB2DRIVER = "db2driver";
0: 	private static final String USAGESTRINGPARTA = MAINUSAGESTRING + " [ [ " + EMBEDDED + " ][ " + NET + " ][ " + CLIENT + "] [ " + DB2DRIVER + " ] [ " + TOOLS + " ] [ ";
/////////////////////////////////////////////////////////////////////////
0: 		  tryDB2DriverClasspath(successes, failures);
/////////////////////////////////////////////////////////////////////////
0: 		if (argumentsContain(args,DB2DRIVER)) {
0: 			tryDB2DriverClasspath(successes, failures);
1: 			seenArg =true;
1: 		}
/////////////////////////////////////////////////////////////////////////
0:     private static void tryDB2DriverClasspath(StringBuffer successes,
0:             StringBuffer failures)
1:     {
0:         tryMyClasspath("com.ibm.db2.jcc.DB2Driver",
0:                 Main.getTextMessage("SIF08.L", "db2jcc.jar"),
0:                 successes, failures);
1:     }
commit:5d3c52a
/////////////////////////////////////////////////////////////////////////
1:     reportDerby (aw);
/////////////////////////////////////////////////////////////////////////
1:   private static void reportDerby (java.io.PrintWriter localAW) {
/////////////////////////////////////////////////////////////////////////
1:   } // end of reportDerby
commit:f64222c
/////////////////////////////////////////////////////////////////////////
1: 					ZipInfoProperties zip = null;
1: 					try {
1: 						zip = checkForInfo(cp[i]);
1: 					}
1: 					catch (SecurityException se)
1: 					{
1: 						zip = new ZipInfoProperties(null);
1: 						zip.setLocation(
1: 							Main.getTextMessage ("SIF03.C", se.getMessage()));
1: 					}
/////////////////////////////////////////////////////////////////////////
1:             zip[0].setLocation(
1: 					Main.getTextMessage ("SIF03.C", se.getMessage()));
commit:aeb4b10
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
1: import java.security.ProtectionDomain;
1: import java.security.CodeSource;
0: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1:           localAW.println(
1:               Main.getTextMessage ("SIF01.U", se.getMessage()));
/////////////////////////////////////////////////////////////////////////
1: 			Class c = Class.forName(cn);
1:                         String loc = getFileWhichLoadedClass(c);
1:                         successes.append(found(cn, library, loc));
/////////////////////////////////////////////////////////////////////////
1:                         String loc = getFileWhichLoadedClass(cn.getClass());
1: 			successes.append(found(cn, library, loc));
/////////////////////////////////////////////////////////////////////////
1: 	private static String found(String cn, String library, String loc) {
1:                 if (loc != null)
1:                     temp.append("   ").append(loc).append(crLf());
/////////////////////////////////////////////////////////////////////////
0:                 String loc = getFileWhichLoadedClass(c);
0:                 // For db2jcc.jar, report the actual file from which DB2Driver
0:                 // was loaded, if we can determine it. For db2jcc_license_c,
0:                 // report the filename from the classpath, and the version 
0:                 // info from the DB2Driver that we loaded. This is slightly
0:                 // misleading, since db2jcc_license_c.jar doesn't really have
0:                 // a "version", but the two jars are usually linked.
0:                 if (loc != null && filename.indexOf("license_c") < 0)
0:                     zip.setLocation(loc);
1:                 else
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Given a loaded class, this
1:      * routine asks the class's class loader for information about where the
1:      * class was loaded from. Typically, this is a file, which might be
1:      * either a class file or a jar file. The routine figures that out, and
1:      * returns the name of the file. If it can't figure it out, it returns null
1:      */
1:     private static String getFileWhichLoadedClass(final Class cls)
1:     {
0:          return (String)AccessController.doPrivileged( new PrivilegedAction()
1:         {
0:             public Object run()
1:             {
1:                 CodeSource cs = null;
1:                 try {
1:                     cs = cls.getProtectionDomain().getCodeSource ();
1:                 }
1:                 catch (SecurityException se) {
0:                     return Main.getTextMessage("SIF01.V", cls, se.getMessage());
1:                 }
1:  
1:                 if ( cs == null )
1:                     return null;        
1:      
1:                 URL result = cs.getLocation ();
1:      
0:                 String loc;
1: 
0:                 // If the class is found directly as a class file, loc has the
0:                 // filename of that classfile. If the class is found in a jar,
0:                 // loc has the format: 
0:                 //   file:[jarName]!className
0:                 // In that case, we fetch the jarName and return it.
0:                 if ("file".equals(result.getProtocol()))
1:                 {
0:                     loc = result.getPath();
0:                     if (loc.indexOf("!") > 0)
0:                         loc = loc.substring(0, loc.indexOf("!"));
1:                 }
1:                 else
1:                 {
0:                     loc = result.toString();
1:                 }
0:                 return loc;
1:             }
1:         });
1:     }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:9a7cd7e
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
0: 	  localAW.println("JRE - JDBC: " + org.apache.derby.iapi.services.info.JVMInfo.derbyVMLevel());
1: 
/////////////////////////////////////////////////////////////////////////
1: 	localAW.println("java.specification.name: " + getJavaProperty("java.specification.name"));
1: 	localAW.println("java.specification.version: " + getJavaProperty("java.specification.version"));
1: 
1: 
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.sysinfo.Main
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:0a7339d
/////////////////////////////////////////////////////////////////////////
1: 			String build = p.getProperty ("derby.locale.build.number");
/////////////////////////////////////////////////////////////////////////
0: 			build.toString(),
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.sysinfo
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.sysinfo;
1: 
1: import java.util.Locale;
1: import java.io.IOException;
1: import java.io.UnsupportedEncodingException;
1: import java.io.InputStream;
1: import java.util.Properties;
1: import java.io.BufferedReader;
1: import java.io.InputStreamReader;
1: import java.util.Locale;
1: import java.util.MissingResourceException;
1: import java.util.ResourceBundle;
1: import java.util.StringTokenizer;
1: import java.io.File;
1: import java.util.zip.ZipFile;
1: import java.io.IOException;
1: import java.util.zip.ZipEntry;
1: import java.io.FileInputStream;
1: import java.util.Vector;
1: import java.io.InputStream;
1: import java.lang.reflect.Method;
1: 
1: import org.apache.derby.iapi.services.info.PropertyNames;
1: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.tools.i18n.*;
1: 
1: 
1: /**
0:   <i>Copyright &#169; 1998, Cloudscape, Inc.   All rights reserved.</i>
1: 
1:   <P>
0:   SysInfo reports values relevant to the Cloudscape product found on
0:   the CLASSPATH.  It looks for a file called sysinfo.properties in
0:   the CLASSPATH using getResourceAsStream. If the file
0:   is not found, or some other exception occurs, the
0:   value returned will be that set for the key
0:   SysInfo.failureTag, or be the value "<info unavailable>".
1: 
1:   <P>
1:   This class can be used to print out system information at the
1:   command line by issuing the command:
1:   <PRE>
0:     java com.ibm.db2j.tools.SysInfo.main
1:   </PRE>
1:   Alternatively, you can use SysInfo within your program to display
0:   Cloudscape information; a Cloudscape version string is returned by this Java code:
1:   <PRE>
1:     new Main().toString();
1:   </PRE>
1: 
1:  */
1: 
1: 
1: public final class Main {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1:   /**
1:     Application entry point for SysInfo.   This will print out
0:     the Cloudscape product information as well as a snapshot of
1:     the System properties.
1:   */
1:   public static void main(String args[]) {
1:         // adjust the application in accordance with derby.ui.locale and derby.ui.codeset
0:         LocalizedResource.getInstance();
1: 
1: 		LocalizedOutput out;
1: 
1:         //using AppStreamReader(extends InputStreamReader) for conversion into specific codeset
1: 
1: 		out = LocalizedResource.OutputWriter();
1: 
1:        // because we're in a static method, we need to
1:        // get our own instance variable
1:     parseArgs (args);
1: 
1:     if (cptester == true)
1: 	getClasspathInfo (args, out);
0:     else
1: 	getMainInfo (out, setPause);
1: 
1:   } // end of main (String args[])
1: 
1: public static void getMainInfo (java.io.PrintWriter aw, boolean pause) {
1: 
1:     aw.println (javaSep);
1:     reportJavaInfo (aw);
1:     aw.println (jbmsSep);
0:     reportCloudscape (aw);
1: 
1:     aw.println (sep);
1: 
1:     // Locales info
1:     try {
1:       reportLocales (aw);
1:     }
1:     catch (Exception e) {
1: 
1:       aw.println (Main.getTextMessage ("SIF01.Q"));
1:       aw.println (Main.getTextMessage ("SIF01.B"));
1:     }
1: 
1: 
1:     if (pause) {
1:      pause();
1:     }
1: 
1:   } // end of getMainInfo (AppStreamWriter aw, boolean printLicense, boolean pause)
1: 
1: 
1:   private static boolean setPause = false;
1: 
1:   private static boolean setLicense = false;
1: 
1:   private static boolean cptester = false;
1: 
1:   private static void parseArgs (String args[]) {
1: 
1:     if (args == null) {
1: 
1:       return;
1:     }
1: 
1: 
1:     for (int i = 0; i < args.length; i++) {
1: 
1:       if (args[i].equals ("-pause")) {
1: 
1:         setPause = true;
1:       }
1: 
1:       if (args[i].equals ("-cp")) {
1: 
1:         cptester=true;
1:       }
1: 
1:     } // end for
1: 
1:   } // end of parseArgs (String args[])
1: 
1: 
1:   /**
1:     For the benefit of DOS box users, this method waits for input
1:     before returning
1:   */
1:   private static void pause () {
1: 
1:     try {
1: 
1:       System.out.print (Main.getTextMessage ("SIF01.C"));
1:       BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
1:       br.readLine ();
1:     }
1:     catch (IOException ioe) {
1: 
1:       //just return
1:     }
1: 
1:   } // end of pause ()
1: 
1:   /**
1:     prints out the jbms info to the specified AppStreamWriter.
0:     @param aw the AppStreamWriter to use. If null, System.out is
1:     used
1:   */
1: 
0:   private static void reportCloudscape (java.io.PrintWriter localAW) {
1: 
0: 	  String classpath;
1: 
1: 	  try {
0: 		  classpath = System.getProperty("java.class.path");
1: 	  }
1: 	  catch (SecurityException se) {
1: 		  classpath = null;
1: 	  }
1: 
0:     ZipInfoProperties zip[]= Main.getAllInfo (classpath);
1: 
1:     if (zip != null) {
1: 
1:       for (int i = 0; i < zip.length; i++) {
1: 
1:         String thisInfo = "[" + zip[i].getLocation () + "] " +
1:                                 zip[i].getVersionBuildInfo ();
1: 
1:         localAW.println (thisInfo);
1:       }
1:     }
1: 
1:     else {
1: 
1:       localAW.println (Main.getTextMessage ("SIF01.D"));
1:     }
1: 
1: 
0:   } // end of reportCloudscape
1: 
1: 
1:   /**
1:     Writes out the relevant info about the Java environment to
1:     the specified AppStreamWriter.
1: 
0:     @param aw The AppStreamWriter to write info out to. If this is
1:     null, the info is written to System.out
1:   */
1: 
1:   private static void reportJavaInfo (java.io.PrintWriter localAW) {
1: 
1: 	
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.A",
1:                                                            getJavaProperty ("java.version")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.B",
1:                                                            getJavaProperty ("java.vendor")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.C",
1:                                                            getJavaProperty ("java.home")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.D",
1:                                                            getJavaProperty ("java.class.path")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.E",
1:                                                            getJavaProperty ("os.name")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.F",
1:                                                            getJavaProperty ("os.arch")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.G",
1:                                                            getJavaProperty ("os.version")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.H",
1:                                                            getJavaProperty ("user.name")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.I",
1:                                                            getJavaProperty ("user.home")));
1: 
1:     localAW.println (Main.getTextMessage ("SIF02.J",
1:                                                            getJavaProperty ("user.dir")));
1: 
1:   } // end of reportJavaInfo
1: 
1: 
1: 
1:   /**
0:     Return Java properties from java.lang.System. Will catch
0:     SecurityExceptions and note them for displaying information.
1: 
0:     @return the Java property value or a string capturing a
0:     security exception.
1:    */
1: 
0:   private static String getJavaProperty (String whichProperty) {
1: 
0:     String property;
0:     String unavailable = Main.getTextMessage ("SIF01.H");
1: 
1:     try {
1: 
0:       property = System.getProperty (whichProperty, unavailable);
0:       return property;
1:     }
1:     catch (SecurityException se) {
1: 
1:       return Main.getTextMessage ("SIF01.I", se);
1:     }
1: 
1:   } // end of getJavaProperty (String whichProperty)
1: 
1: 
1: 
1:   /**
1:     for use by the main () method
1:    */
1: 
1:   private final static String sep     = "------------------------------------------------------";
1:   private final static String javaSep = Main.getTextMessage ("SIF01.L");
1: 
1:   private final static String jbmsSep = Main.getTextMessage ("SIF01.M");
1: 
1:   private final static String licSep  = Main.getTextMessage ("SIF01.N");
1: 
1:   private final static String locSep  = Main.getTextMessage ("SIF01.P");
1: 
1:   private final static String curLoc  = Main.getTextMessage ("SIF01.T");
1: 
1:   /**
0:     The name of the failure tag in the information file.
0:     The failure tag's value provides a default value if
0:     any other properties are missing.
1:    */
0:   private final static String failureTag = Main.getTextMessage ("SIF01.J");
1: 
1:   private static void getClasspathInfo (String args[], java.io.PrintWriter aw) {
1: 
1:     Main.useMe (args, aw);
1:   }
1: 
1: 
1: 
1: 
1:   /**
1:     Writes out information about the locales with the
1:     product.
1: 
0:     @param aw the AppStreamWriter to which the info is written. If this
1:     value is null, the info is written to System.out
1: 
1:   */
0:   private static void reportLocales (java.io.PrintWriter localAW) {          // throws StandardException {
1: 
1:     boolean cur_loc = true;
1: 
1:     localAW.println (locSep);
1: 
1:     // Read all the possible locales, and test for each one, if it loads.
1:     // If so, then read the properties, and print them out.
1: 
1: 	Locale[] supportedLocales = Locale.getAvailableLocales();
1: 	String[] stringLocales = new String[supportedLocales.length];
1:     for (int i = 0; i < supportedLocales.length; i++)
1: 	{
1: 		stringLocales[i] = supportedLocales[i].toString();
1: 	}
1: 	java.util.Arrays.sort(stringLocales);
1: 
1:     Properties p = new Properties ();
1:     for (int i = 0; i < stringLocales.length; i++) {
1: 
1:       String localeResource =
1:          "/org/apache/derby/info/locale_" + stringLocales[i] + ".properties";
1: 
1:       try {
1: 
0:         InputStream is = p.getClass().getResourceAsStream (localeResource);
1: 
1:         if (is == null) {
1: //           localAW.println("resource is null: " + localeResource);
1:         }
1:         else {
1: 
1:           try {
1: 			  p.clear();
1:             p.load (is);
1:         //Displaying Current Locale
1: 	    if (cur_loc)
1: 		{
1: 	Locale loc = null;
1: 	loc = Locale.getDefault();
1:         localAW.println(Main.getTextMessage ("SIF01.T") + "  [" + loc.getDisplayLanguage() + "/" +  loc.getDisplayCountry() + " [" + loc + "]]");
1: 		cur_loc = false;
1: 		}
1: 
1: 	//Beetle 5079: do not print unlocalized locale names to console, only print locale code.
1: 	String localeName = p.getProperty("derby.locale.external.name");
1: 	localeName = localeName.substring(localeName.indexOf("[")+1);
1: 	localeName = localeName.substring(0,localeName.indexOf("]"));
1: 	
1:             localAW.println (Main.getTextMessage ("SIF01.R",
1:                                                                    localeName));
1: 
1: 
0: 			int major = Integer.valueOf(p.getProperty ("derby.locale.version.major")).intValue();
0: 			int minor = Integer.valueOf(p.getProperty ("derby.locale.version.minor")).intValue();
0: 			int maint = Integer.valueOf(p.getProperty ("derby.locale.version.maint")).intValue();
0: 			int build = Integer.valueOf(p.getProperty ("derby.locale.build.number")).intValue();
1: 
1: 			String lv = ProductVersionHolder.fullVersionString(major, minor, maint, false, build);
1: 
1: 
1:             localAW.println (Main.getTextMessage ("SIF01.S", lv));
1: 
1: 
1:           }
1:           catch (IOException ioe) {
1: 
1:             //This case is a bit ugly. If we get an IOException, we return
1:             //null. Though this correctly reflects that the product is not
1:             //available for use, it may be confusing to users that we swallow
1:             //the IO error here.
1: 
1:             localAW.println("Could not get locale properties from : " + is);
1:           }
1:         }
1: 
1:       }
1:       catch (Throwable t) {
1:         localAW.println ("Could not load resource: " + localeResource);
1:         localAW.println ("Exception: " + t);
1:       }
1: 
1:     }
1: 
1: 
1:     localAW.println (sep);
1: 
1:   } // end of reportLocales
1: 
1: 	/* for arguments, choose from one of:*/
1: 	private static final String EMBEDDED = "embedded";
1: 
1: 	/* you can add this if you like*/
1: 	private static final String TOOLS = "tools";
1: 
1: 	private static final String NET = "server";
1: 	private static final String CLIENT = "client";
1: 
1: 	/* you can add this if you like */
1: 
1: 	private static final String MAINUSAGESTRING = "java org.apache.derby.tools.sysinfo -cp";
1: 
0: 	private static final String USAGESTRINGPARTA = MAINUSAGESTRING + " [ [ " + EMBEDDED + " ][ " + NET + " ][ " + CLIENT + "] [ " + TOOLS + " ] [ ";
1:     private static final String USAGESTRINGPARTB = ".class ] ]";
1: 
1:   static  void useMe(String[] args, java.io.PrintWriter pw) {
1: 	  java.io.PrintWriter localPW = pw;
1: 
1: 	    if (localPW == null)
1: 	    {
1: 	        localPW = new java.io.PrintWriter(System.out);
1: 	    }
1: 
1: 
1:       int length = args.length;
1: 	  if (length==1) {
1: 
1: 		  try {
1: 			  tryAllClasspaths(localPW);
1: 
1: 		  }
1: 
1: 		  catch (Throwable t) {
1: 
1: 		  }
1: 	  }
1: 	  else {
1: 		  try {
1: 			  trySomeClasspaths(args, localPW);
1: 		  }
1: 
1: 		  catch (Throwable t) {
1: 
1: 		  }
1: 	  }
1: 
1:   }
1: 
1: 
1: 
1: 
1: 
1: 	  private static void tryAllClasspaths(java.io.PrintWriter localPW) throws Throwable {
1: 		  localPW.println(Main.getTextMessage("SIF08.B"));
1: 		  localPW.println(Main.getTextMessage("SIF08.C", MAINUSAGESTRING + " args"));
1: 		  StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
1: 		  StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1: 		  tryCoreClasspath(successes, failures);
1: 		  tryNetClasspath(successes, failures);
1: 		  tryClientClasspath(successes, failures);
1: 		  tryUtilsClasspath(successes, failures);
1: 		  localPW.println(successes.toString());
1: 		  if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
1: 			  localPW.println(failures.toString());
1: 		  }
1: 		  else {
1: 
1: 			  localPW.println(Main.getTextMessage("SIF08.F"));
1: 		  }
1: 		  localPW.flush();
1: 	  }
1: 
1: 	private static void trySomeClasspaths(String[] args, java.io.PrintWriter localPW) throws Throwable {
1: 
1: 		boolean seenArg = false;
1: 		StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
1: 		StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
1: 
1: 		if (argumentsContain(args, EMBEDDED))
1: 		{
1: 
1: 			tryCoreClasspath(successes, failures);
1: 			seenArg =true;
1: 
1: 		}
1: 		if (argumentsContain(args,NET)) {
1: 		  tryNetClasspath(successes, failures);
1: 			seenArg =true;
1: 
1: 		}
1: 		if (argumentsContain(args,CLIENT)) {
1: 		  tryClientClasspath(successes, failures);
1: 			seenArg =true;
1: 
1: 		}
1: 
1: 		if (argumentsContain(args,TOOLS) || argumentsContain(args,"utils")) {
1: 		  tryUtilsClasspath(successes, failures);
1: 			seenArg =true;
1: 
1: 		}
1: 
1: 
1: 		String userclass = argumentMatches(args, ".class");
1: 		if (!userclass.equals("")) {
1: 			tryMyClasspath(argumentMatches(args, ".class"), Main.getTextMessage("SIF08.H", userclass), successes, failures);
1: 			seenArg =true;
1: 		}
1: 
1: 		if (seenArg)
1: 		{
1: 
1: 			localPW.println(successes.toString());
1: 			if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
1: 				localPW.println(failures.toString());
1: 			}
1: 			else {
1: 
1: 				localPW.println(Main.getTextMessage("SIF08.F"));
1: 			}
1: 		}
0: 		else
1: 		{
1: 			localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
1: 		}
1: 		localPW.flush();
1: 
1: 	}
1: 
1: 	private static void tryCoreClasspath(StringBuffer successes, StringBuffer failures) {
1: 		tryMyClasspath("org.apache.derby.database.Database", Main.getTextMessage("SIF08.J","derby.jar" ), successes, failures);
1: 	}
1: 	private static void tryNetClasspath(StringBuffer successes, StringBuffer failures) {
1: 		tryMyClasspath("org.apache.derby.drda.NetworkServerControl", Main.getTextMessage("SIF08.I", "derbynet.jar"), successes, failures);
1: 	}
1: 	private static void tryClientClasspath(StringBuffer successes, StringBuffer failures) {
0: 		tryMyClasspath("com.ibm.db2.jcc.DB2Driver", Main.getTextMessage("SIF08.L", "db2jcc.jar"), successes, failures);
1: 	}
1: 
1: 	private static void tryUtilsClasspath(StringBuffer successes, StringBuffer failures) {
1: 		tryMyClasspath("org.apache.derby.tools.ij", Main.getTextMessage("SIF08.Q", "derbytools.jar"), successes, failures);
1: 	}
1: 
1: 	private static void tryMyClasspath(String cn, String library, StringBuffer successes, StringBuffer failures) {
1: 
1: 		try {
0: 			Class.forName(cn);
0: 			successes.append(found(cn, library));
1: 		}
1: 
1: 		catch (Throwable t) {
1: 
1: 			failures.append(notFound(cn, library));
1: 
1: 		}
1: 
1: 
1: 	}
1: 
1: 	private static void tryAsResource(String cn, String library, StringBuffer successes, StringBuffer failures) {
1: 
1: 		try {
1: 			java.io.InputStream in = cn.getClass().getResourceAsStream(cn);
1: 			in.close();
0: 			successes.append(found(cn, library));
1: 		}
1: 
1: 		catch (Throwable t) {
1: 			failures.append(notFound(cn, library));
1: 
1: 		}
1: 
1: 	}
1: 
0: 	private static String found(String cn, String library) {
1: 		StringBuffer temp = new StringBuffer(crLf());
1: 		temp.append("   " + library);
1: 		temp.append(crLf());
1: 		temp.append(crLf());
1: 		return temp.toString();
1: 	}
1: 	private static String notFound(String cn, String library) {
1: 
1: 		StringBuffer temp = new StringBuffer(crLf());
1: 		temp.append("   " + library);
1: 		temp.append(crLf());
1: 		temp.append("    " + Main.getTextMessage("SIF08.U", cn));
1: 		temp.append(crLf());
1: 		temp.append(crLf());
1: 		return temp.toString();
1: 	}
1: 
1: 	private static String crLf() {
1: 		return System.getProperty("line.separator");
1: 	}
1: 
1: 	private static String lookForMainArg(String[] args, java.io.PrintWriter localPW)
1: 	{
1: 		int length=args.length;
1: 		String[] legalargs = new String[1];
1: 		legalargs[0] = EMBEDDED;
1: 
1: 		int argsfound = 0;
1: 		String whichargument="";
1: 
1: 		for (int i = 0; i < length; i++) {
1: 
1: 			for (int j=0; j < legalargs.length; j++) {
1: 				if (args[i].toUpperCase(java.util.Locale.ENGLISH).equals(legalargs[j].toUpperCase(java.util.Locale.ENGLISH))) {
1: 					argsfound++;
1: 					whichargument=legalargs[j];
1: 				}
1: 			}
1: 		}
1: 		if (argsfound > 1 || argsfound < 1) {
1:             localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
1: 			return "";
1: 		}
1: 		return whichargument;
1: 	}
1: 
1: 	private static boolean argumentsContain(String[] args, String s) {
1: 		for (int i = 0; i < args.length; i++) {
1: 			if (args[i].equalsIgnoreCase(s))
1: 				return true;
1: 		}
1: 		return false;
1: 
1: 	}
1: 
1: 	private static String argumentMatches(String[] args, String ss) {
1: 	    String userclass = "";
1: 		int length = args.length;
1: 		for (int i = 0; i < length; i++) {
1: 			if (args[i].endsWith(ss)) {
1: 				userclass = args[i].substring(0,args[i].length()-6) ;
1: 
1: 			}
1: 
1: 		}
1: 		return userclass;
1: 	}
1: 
1: 	/*
1: 	** Code related to loading info fromjar files.
1: 	*/
1: 
1:     private static final String infoNames[] = {
1: 
1:                                     "org/apache/derby/info/" +
1:                                     org.apache.derby.iapi.services.info.ProductGenusNames.DBMS +
1:                                     ".properties",
1: 
1: 
1:                                     "org/apache/derby/info/" +
1:                                     org.apache.derby.iapi.services.info.ProductGenusNames.TOOLS +
1:                                     ".properties",
1: 
1:                                     "org/apache/derby/info/" +
1:                                     org.apache.derby.iapi.services.info.ProductGenusNames.NET +
0:                                     ".properties"
1:                                 };
1: 
1:     public static ZipInfoProperties[] getAllInfo(String classpath)
1:     {
1:         try
1:         {
1: 			if (classpath != null) {
1: 				String cp [] = parseClasspath(classpath);
0: 				Vector v = new Vector();
1: 				for (int i = 0; i < cp.length; i++)
1: 				{
0: 					ZipInfoProperties zip = checkForInfo(cp[i]);
1: 					if (zip != null)
1: 					{
1: 						v.addElement(zip);
1: 					}
1: 				}
1: 				if (v.size() > 0)
1: 				{
0: 					ZipInfoProperties zips[] = new ZipInfoProperties[v.size()];
0: 					v.copyInto(zips);
0: 					return zips;
1: 				}
1: 			}
0:             return loadZipFromResource();
1: 
1:         }
1:         catch (SecurityException se)
1:         {
1:             ZipInfoProperties zip[] = new ZipInfoProperties[1];
1:             zip[0] = new ZipInfoProperties(null);
0:             zip[0].setLocation (Main.getTextMessage ("SIF03.C"));
1:             return zip;
1:         }
1:     }
1: 
1:     /**
0:         This method returns exactly one ZipInfoProperty in the array.
0:         If it is able to load the sysinfo file as a resource, it returns
0:         the ZipInfoProperty associated with that. Otherwise, the ZipInfoProperty
0:         will be empty.
1:      */
1:     private static ZipInfoProperties [] loadZipFromResource()
1:     {
0: 		java.util.ArrayList al = new java.util.ArrayList();
1: 
1:         for (int i = 0; i < infoNames.length; i++)
1:         {
0: 			String resource = "/".concat(infoNames[i]);
1: 
0:             InputStream is = new Main().getClass().getResourceAsStream(resource);
1: 			if (is == null)
1: 				continue;
1: 
1: 			ZipInfoProperties ze = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(is));
0: 			ze.setLocation(resource);
1: 
1: 			al.add(ze);
1:         }
1: 
1:         if (al.size() == 0)
1:         {
1:             return null;
1:         }
1: 
1:         ZipInfoProperties[] zip = new ZipInfoProperties[al.size()];
1: 
1: 		al.toArray(zip);
1: 
1:         return zip;
1:     }
1: 
1:     private static String [] parseClasspath(String cp)
1:     {
1:         StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);
1:         int count = st.countTokens();
1:         if (count == 0)
1:         {
1:             return null;
1:         }
1: 
1:         String vals[] = new String[count];
1:         for (int i =0; i < count; i++)
1:         {
1:             vals[i] = st.nextToken();
1:         }
1:         return vals;
1:     }
1: 
0:     private static ZipInfoProperties checkForInfo(String cpEntry)
1:     {
0:         File f = new File(cpEntry);
0:         if ( ! f.exists())
1:         {
1:             return null;
1:         }
1: 
0:         if (f.isDirectory())
1:         {
0:             ZipInfoProperties zip = checkDirectory(cpEntry);
1:             return zip;
1:         }
1: 
0:         if (f.isFile())
1:         {
0:             ZipInfoProperties zip = checkFile(cpEntry);
1:             return zip;
1:         }
1:         return null;
1: 
1: 
1:     }
1: 
1:     private static ZipInfoProperties checkDirectory(String dirname)
1:     {
1:         boolean foundOne = false;
1:         File f = null;
1:         for (int i = 0; i < infoNames.length; i++)
1:         {
1:             String localSysinfo = infoNames[i].replace('/', File.separatorChar);
1:             f = new File(dirname, localSysinfo);
1:             if (f.exists())
1:             {
1:                 foundOne = true;
1:                 break;
1:             }
1:         }
1: 
1:         if (!foundOne || (f == null))
1:         {
1:             return null;
1:         }
1: 
1:         try
1:         {
1:             InputStream bis = new FileInputStream(f);
1: 
1:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
0:             zip.setLocation(new File(dirname).getCanonicalPath().replace('/', File.separatorChar));
1:             return zip;
1:         }
1:         catch (IOException ioe)
1:         {
1:             return null;
1:         }
1: 
1:     }
1: 
1:     private static ZipInfoProperties checkFile(String filename)
1:     {
1:         // try to create a ZipFile from it
1: 
0: 	// Check to see if it's a version of db2jcc.jar and if so, report the version number. 
0: 	if (filename.indexOf("db2jcc") >= 0)
1: 	{
0: 	    Class c = null;
0: 	    Method m = null;
0: 	    Object o = null;
0: 	    Integer build = null;
0: 	    Integer major = null;
0:             Integer minor = null;
1: 	    try 
1: 	    {
1:                 try 
1: 		{
0: 		    c = Class.forName("com.ibm.db2.jcc.DB2Driver");
0: 		    m = c.getMethod("getJCCBuildNumber", null);
0: 		    o = c.newInstance();
0: 		    build = (Integer)m.invoke(o,null);
0: 		} catch (ClassNotFoundException cnfe) {
0: 		    c = Class.forName("com.ibm.db2.jcc.DB2Version");
0: 		    m = c.getMethod("getBuildNumber", null);
0: 		    o = c.newInstance();
0: 		    build = (Integer)m.invoke(o,null);
1: 	        } 
0: 		m = c.getMethod("getMajorVersion", null);
0: 		major = (Integer)m.invoke(o,null);
0: 		m = c.getMethod("getMinorVersion", null);
0: 		minor = (Integer)m.invoke(o,null);
1: 
0: 		ProductVersionHolder jccVersion = ProductVersionHolder.getProductVersionHolder(
0: 			"IBM Corp.",
0: 			"DB2 Java Common Client",
0: 			"DRDA:jcc",
0: 			major.intValue(),
0: 			minor.intValue(),
0: 			0,
0: 			0,
0: 			build.intValue(),
0: 			Boolean.FALSE);
1: 
0: 		ZipInfoProperties zip = new ZipInfoProperties(jccVersion);
1: 
0:         zip.setLocation(new File(filename).getCanonicalPath().replace('/', File.separatorChar));
1: 		return zip;
0:             } catch (Exception e) { return null; }
1: 	}
1: 
1:         try
1:         {
1:             ZipFile zf = new ZipFile(filename);
1:             // try to get a ZipEntry from the ZipFile
1: 
1:             ZipEntry thisEntry = null;
1: 
1:             for (int i =0; i < infoNames.length; i++)
1:             {
1:                 thisEntry = zf.getEntry(infoNames[i]);
1:                 if (thisEntry != null)
1:                 {
1:                     break;
1:                 }
1:             }
1: 
1:             if (thisEntry == null)
1:             {
1:                 return null;
1:             }
1: 
1:             InputStream bis = zf.getInputStream(thisEntry);
1:             if (bis == null)
1:             {
1:                 return null;
1:             }
1: 
1:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
0:             zip.setLocation(new File(filename).getCanonicalPath().replace('/', File.separatorChar));
1:             return zip;
1: 
1:         }
1:         catch (IOException ioe)
1:         {
1:             //guess not
1:             return null;
1:         }
1: 
1:     }
1: 
1: 	/*
1: 	** Message handling
1: 	*/
0: 	private static ResourceBundle getBundle() {
1: 		try {
0: 			return ResourceBundle.getBundle("org.apache.derby.loc.sysinfoMessages");
0: 		} catch (MissingResourceException mre) {
1: 		}
1: 		return null;
1: 	}
1: 
0: 	public static String getTextMessage(String msgId) {
0: 		return getCompleteMessage(msgId, (Object[]) null);
1: 	}
0: 	public static String getTextMessage(String msgId, Object a1) {
1: 
0: 		return getCompleteMessage(msgId, new Object[] {a1});
1: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2});
1: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2, Object a3) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2, a3});
1: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2, Object a3, Object a4) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2, a3, a4});
1: 	}
1: 
1: 	/**
1: 	 */
0: 	public static String getCompleteMessage(String msgId, Object[] arguments) {
1: 
0: 		// we have a base file (sysinfoMessages.properties) so don't give us a last chance.
0: 		return org.apache.derby.iapi.services.i18n.MessageService.formatMessage(getBundle(), msgId, arguments, false);
1: 	}
1: } // end of class Main
1: 
commit:d2a30a0
/////////////////////////////////////////////////////////////////////////
0: 			int build = Integer.valueOf(p.getProperty ("derby.locale.build.number")).intValue();
/////////////////////////////////////////////////////////////////////////
0: 			build.intValue(),
commit:42261f8
/////////////////////////////////////////////////////////////////////////
0: 			String build = p.getProperty ("derby.locale.build.number");
/////////////////////////////////////////////////////////////////////////
0: 			build.toString(),
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.sysinfo
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.tools.sysinfo;
0: 
0: import java.util.Locale;
0: import java.io.IOException;
0: import java.io.UnsupportedEncodingException;
0: import java.io.InputStream;
0: import java.util.Properties;
0: import java.io.BufferedReader;
0: import java.io.InputStreamReader;
0: import java.util.Locale;
0: import java.util.MissingResourceException;
0: import java.util.ResourceBundle;
0: import java.util.StringTokenizer;
0: import java.io.File;
0: import java.util.zip.ZipFile;
0: import java.io.IOException;
0: import java.util.zip.ZipEntry;
0: import java.io.FileInputStream;
0: import java.util.Vector;
0: import java.io.InputStream;
0: import java.lang.reflect.Method;
0: 
0: import org.apache.derby.iapi.services.info.PropertyNames;
0: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.tools.i18n.*;
0: 
0: 
0: /**
0:   <i>Copyright &#169; 1998, Cloudscape, Inc.   All rights reserved.</i>
0: 
0:   <P>
0:   SysInfo reports values relevant to the Cloudscape product found on
0:   the CLASSPATH.  It looks for a file called sysinfo.properties in
0:   the CLASSPATH using getResourceAsStream. If the file
0:   is not found, or some other exception occurs, the
0:   value returned will be that set for the key
0:   SysInfo.failureTag, or be the value "<info unavailable>".
0: 
0:   <P>
0:   This class can be used to print out system information at the
0:   command line by issuing the command:
0:   <PRE>
0:     java com.ibm.db2j.tools.SysInfo.main
0:   </PRE>
0:   Alternatively, you can use SysInfo within your program to display
0:   Cloudscape information; a Cloudscape version string is returned by this Java code:
0:   <PRE>
0:     new Main().toString();
0:   </PRE>
0: 
0:  */
0: 
0: 
0: public final class Main {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:   /**
0:     Application entry point for SysInfo.   This will print out
0:     the Cloudscape product information as well as a snapshot of
0:     the System properties.
0:   */
0:   public static void main(String args[]) {
0:         // adjust the application in accordance with derby.ui.locale and derby.ui.codeset
0:         LocalizedResource.getInstance();
0: 
0: 		LocalizedOutput out;
0: 
0:         //using AppStreamReader(extends InputStreamReader) for conversion into specific codeset
0: 
0: 		out = LocalizedResource.OutputWriter();
0: 
0:        // because we're in a static method, we need to
0:        // get our own instance variable
0:     parseArgs (args);
0: 
0:     if (cptester == true)
0: 	getClasspathInfo (args, out);
0:     else
0: 	getMainInfo (out, setPause);
0: 
0:   } // end of main (String args[])
0: 
0: public static void getMainInfo (java.io.PrintWriter aw, boolean pause) {
0: 
0:     aw.println (javaSep);
0:     reportJavaInfo (aw);
0:     aw.println (jbmsSep);
0:     reportCloudscape (aw);
0: 
0:     aw.println (sep);
0: 
0:     // Locales info
0:     try {
0:       reportLocales (aw);
0:     }
0:     catch (Exception e) {
0: 
0:       aw.println (Main.getTextMessage ("SIF01.Q"));
0:       aw.println (Main.getTextMessage ("SIF01.B"));
0:     }
0: 
0: 
0:     if (pause) {
0:      pause();
0:     }
0: 
0:   } // end of getMainInfo (AppStreamWriter aw, boolean printLicense, boolean pause)
0: 
0: 
0:   private static boolean setPause = false;
0: 
0:   private static boolean setLicense = false;
0: 
0:   private static boolean cptester = false;
0: 
0:   private static void parseArgs (String args[]) {
0: 
0:     if (args == null) {
0: 
0:       return;
0:     }
0: 
0: 
0:     for (int i = 0; i < args.length; i++) {
0: 
0:       if (args[i].equals ("-pause")) {
0: 
0:         setPause = true;
0:       }
0: 
0:       if (args[i].equals ("-cp")) {
0: 
0:         cptester=true;
0:       }
0: 
0:     } // end for
0: 
0:   } // end of parseArgs (String args[])
0: 
0: 
0:   /**
0:     For the benefit of DOS box users, this method waits for input
0:     before returning
0:   */
0:   private static void pause () {
0: 
0:     try {
0: 
0:       System.out.print (Main.getTextMessage ("SIF01.C"));
0:       BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
0:       br.readLine ();
0:     }
0:     catch (IOException ioe) {
0: 
0:       //just return
0:     }
0: 
0:   } // end of pause ()
0: 
0:   /**
0:     prints out the jbms info to the specified AppStreamWriter.
0:     @param aw the AppStreamWriter to use. If null, System.out is
0:     used
0:   */
0: 
0:   private static void reportCloudscape (java.io.PrintWriter localAW) {
0: 
0: 	  String classpath;
0: 
0: 	  try {
0: 		  classpath = System.getProperty("java.class.path");
0: 	  }
0: 	  catch (SecurityException se) {
0: 		  classpath = null;
0: 	  }
0: 
0:     ZipInfoProperties zip[]= Main.getAllInfo (classpath);
0: 
0:     if (zip != null) {
0: 
0:       for (int i = 0; i < zip.length; i++) {
0: 
0:         String thisInfo = "[" + zip[i].getLocation () + "] " +
0:                                 zip[i].getVersionBuildInfo ();
0: 
0:         localAW.println (thisInfo);
0:       }
0:     }
0: 
0:     else {
0: 
0:       localAW.println (Main.getTextMessage ("SIF01.D"));
0:     }
0: 
0: 
0:   } // end of reportCloudscape
0: 
0: 
0:   /**
0:     Writes out the relevant info about the Java environment to
0:     the specified AppStreamWriter.
0: 
0:     @param aw The AppStreamWriter to write info out to. If this is
0:     null, the info is written to System.out
0:   */
0: 
0:   private static void reportJavaInfo (java.io.PrintWriter localAW) {
0: 
0: 	
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.A",
0:                                                            getJavaProperty ("java.version")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.B",
0:                                                            getJavaProperty ("java.vendor")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.C",
0:                                                            getJavaProperty ("java.home")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.D",
0:                                                            getJavaProperty ("java.class.path")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.E",
0:                                                            getJavaProperty ("os.name")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.F",
0:                                                            getJavaProperty ("os.arch")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.G",
0:                                                            getJavaProperty ("os.version")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.H",
0:                                                            getJavaProperty ("user.name")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.I",
0:                                                            getJavaProperty ("user.home")));
0: 
0:     localAW.println (Main.getTextMessage ("SIF02.J",
0:                                                            getJavaProperty ("user.dir")));
0: 
0:   } // end of reportJavaInfo
0: 
0: 
0: 
0:   /**
0:     Return Java properties from java.lang.System. Will catch
0:     SecurityExceptions and note them for displaying information.
0: 
0:     @return the Java property value or a string capturing a
0:     security exception.
0:    */
0: 
0:   private static String getJavaProperty (String whichProperty) {
0: 
0:     String property;
0:     String unavailable = Main.getTextMessage ("SIF01.H");
0: 
0:     try {
0: 
0:       property = System.getProperty (whichProperty, unavailable);
0:       return property;
0:     }
0:     catch (SecurityException se) {
0: 
0:       return Main.getTextMessage ("SIF01.I", se);
0:     }
0: 
0:   } // end of getJavaProperty (String whichProperty)
0: 
0: 
0: 
0:   /**
0:     for use by the main () method
0:    */
0: 
0:   private final static String sep     = "------------------------------------------------------";
0:   private final static String javaSep = Main.getTextMessage ("SIF01.L");
0: 
0:   private final static String jbmsSep = Main.getTextMessage ("SIF01.M");
0: 
0:   private final static String licSep  = Main.getTextMessage ("SIF01.N");
0: 
0:   private final static String locSep  = Main.getTextMessage ("SIF01.P");
0: 
0:   private final static String curLoc  = Main.getTextMessage ("SIF01.T");
0: 
0:   /**
0:     The name of the failure tag in the information file.
0:     The failure tag's value provides a default value if
0:     any other properties are missing.
0:    */
0:   private final static String failureTag = Main.getTextMessage ("SIF01.J");
0: 
0:   private static void getClasspathInfo (String args[], java.io.PrintWriter aw) {
0: 
0:     Main.useMe (args, aw);
0:   }
0: 
0: 
0: 
0: 
0:   /**
0:     Writes out information about the locales with the
0:     product.
0: 
0:     @param aw the AppStreamWriter to which the info is written. If this
0:     value is null, the info is written to System.out
0: 
0:   */
0:   private static void reportLocales (java.io.PrintWriter localAW) {          // throws StandardException {
0: 
0:     boolean cur_loc = true;
0: 
0:     localAW.println (locSep);
0: 
0:     // Read all the possible locales, and test for each one, if it loads.
0:     // If so, then read the properties, and print them out.
0: 
0: 	Locale[] supportedLocales = Locale.getAvailableLocales();
0: 	String[] stringLocales = new String[supportedLocales.length];
0:     for (int i = 0; i < supportedLocales.length; i++)
0: 	{
0: 		stringLocales[i] = supportedLocales[i].toString();
0: 	}
0: 	java.util.Arrays.sort(stringLocales);
0: 
0:     Properties p = new Properties ();
0:     for (int i = 0; i < stringLocales.length; i++) {
0: 
0:       String localeResource =
0:          "/org/apache/derby/info/locale_" + stringLocales[i] + ".properties";
0: 
0:       try {
0: 
0:         InputStream is = p.getClass().getResourceAsStream (localeResource);
0: 
0:         if (is == null) {
0: //           localAW.println("resource is null: " + localeResource);
0:         }
0:         else {
0: 
0:           try {
0: 			  p.clear();
0:             p.load (is);
0:         //Displaying Current Locale
0: 	    if (cur_loc)
0: 		{
0: 	Locale loc = null;
0: 	loc = Locale.getDefault();
0:         localAW.println(Main.getTextMessage ("SIF01.T") + "  [" + loc.getDisplayLanguage() + "/" +  loc.getDisplayCountry() + " [" + loc + "]]");
0: 		cur_loc = false;
0: 		}
0: 
0: 	//Beetle 5079: do not print unlocalized locale names to console, only print locale code.
0: 	String localeName = p.getProperty("derby.locale.external.name");
0: 	localeName = localeName.substring(localeName.indexOf("[")+1);
0: 	localeName = localeName.substring(0,localeName.indexOf("]"));
0: 	
0:             localAW.println (Main.getTextMessage ("SIF01.R",
0:                                                                    localeName));
0: 
0: 
0: 			int major = Integer.valueOf(p.getProperty ("derby.locale.version.major")).intValue();
0: 			int minor = Integer.valueOf(p.getProperty ("derby.locale.version.minor")).intValue();
0: 			int maint = Integer.valueOf(p.getProperty ("derby.locale.version.maint")).intValue();
0: 			int build = Integer.valueOf(p.getProperty ("derby.locale.build.number")).intValue();
0: 
0: 			String lv = ProductVersionHolder.fullVersionString(major, minor, maint, false, build);
0: 
0: 
0:             localAW.println (Main.getTextMessage ("SIF01.S", lv));
0: 
0: 
0:           }
0:           catch (IOException ioe) {
0: 
0:             //This case is a bit ugly. If we get an IOException, we return
0:             //null. Though this correctly reflects that the product is not
0:             //available for use, it may be confusing to users that we swallow
0:             //the IO error here.
0: 
0:             localAW.println("Could not get locale properties from : " + is);
0:           }
0:         }
0: 
0:       }
0:       catch (Throwable t) {
0:         localAW.println ("Could not load resource: " + localeResource);
0:         localAW.println ("Exception: " + t);
0:       }
0: 
0:     }
0: 
0: 
0:     localAW.println (sep);
0: 
0:   } // end of reportLocales
0: 
0: 	/* for arguments, choose from one of:*/
0: 	private static final String EMBEDDED = "embedded";
0: 
0: 	/* you can add this if you like*/
0: 	private static final String TOOLS = "tools";
0: 
0: 	private static final String NET = "server";
0: 	private static final String CLIENT = "client";
0: 
0: 	/* you can add this if you like */
0: 
0: 	private static final String MAINUSAGESTRING = "java org.apache.derby.tools.sysinfo -cp";
0: 
0: 	private static final String USAGESTRINGPARTA = MAINUSAGESTRING + " [ [ " + EMBEDDED + " ][ " + NET + " ][ " + CLIENT + "] [ " + TOOLS + " ] [ ";
0:     private static final String USAGESTRINGPARTB = ".class ] ]";
0: 
0:   static  void useMe(String[] args, java.io.PrintWriter pw) {
0: 	  java.io.PrintWriter localPW = pw;
0: 
0: 	    if (localPW == null)
0: 	    {
0: 	        localPW = new java.io.PrintWriter(System.out);
0: 	    }
0: 
0: 
0:       int length = args.length;
0: 	  if (length==1) {
0: 
0: 		  try {
0: 			  tryAllClasspaths(localPW);
0: 
0: 		  }
0: 
0: 		  catch (Throwable t) {
0: 
0: 		  }
0: 	  }
0: 	  else {
0: 		  try {
0: 			  trySomeClasspaths(args, localPW);
0: 		  }
0: 
0: 		  catch (Throwable t) {
0: 
0: 		  }
0: 	  }
0: 
0:   }
0: 
0: 
0: 
0: 
0: 
0: 	  private static void tryAllClasspaths(java.io.PrintWriter localPW) throws Throwable {
0: 		  localPW.println(Main.getTextMessage("SIF08.B"));
0: 		  localPW.println(Main.getTextMessage("SIF08.C", MAINUSAGESTRING + " args"));
0: 		  StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
0: 		  StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
0: 		  tryCoreClasspath(successes, failures);
0: 		  tryNetClasspath(successes, failures);
0: 		  tryClientClasspath(successes, failures);
0: 		  tryUtilsClasspath(successes, failures);
0: 		  localPW.println(successes.toString());
0: 		  if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
0: 			  localPW.println(failures.toString());
0: 		  }
0: 		  else {
0: 
0: 			  localPW.println(Main.getTextMessage("SIF08.F"));
0: 		  }
0: 		  localPW.flush();
0: 	  }
0: 
0: 	private static void trySomeClasspaths(String[] args, java.io.PrintWriter localPW) throws Throwable {
0: 
0: 		boolean seenArg = false;
0: 		StringBuffer successes = new StringBuffer(Main.getTextMessage("SIF08.D")+ crLf());
0: 		StringBuffer failures = new StringBuffer(crLf() + Main.getTextMessage("SIF08.E") + crLf());
0: 
0: 		if (argumentsContain(args, EMBEDDED))
0: 		{
0: 
0: 			tryCoreClasspath(successes, failures);
0: 			seenArg =true;
0: 
0: 		}
0: 		if (argumentsContain(args,NET)) {
0: 		  tryNetClasspath(successes, failures);
0: 			seenArg =true;
0: 
0: 		}
0: 		if (argumentsContain(args,CLIENT)) {
0: 		  tryClientClasspath(successes, failures);
0: 			seenArg =true;
0: 
0: 		}
0: 
0: 		if (argumentsContain(args,TOOLS) || argumentsContain(args,"utils")) {
0: 		  tryUtilsClasspath(successes, failures);
0: 			seenArg =true;
0: 
0: 		}
0: 
0: 
0: 		String userclass = argumentMatches(args, ".class");
0: 		if (!userclass.equals("")) {
0: 			tryMyClasspath(argumentMatches(args, ".class"), Main.getTextMessage("SIF08.H", userclass), successes, failures);
0: 			seenArg =true;
0: 		}
0: 
0: 		if (seenArg)
0: 		{
0: 
0: 			localPW.println(successes.toString());
0: 			if (!failures.toString().equals(crLf() + Main.getTextMessage("SIF08.E") + crLf())) {
0: 				localPW.println(failures.toString());
0: 			}
0: 			else {
0: 
0: 				localPW.println(Main.getTextMessage("SIF08.F"));
0: 			}
0: 		}
0: 		else
0: 		{
0: 			localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
0: 		}
0: 		localPW.flush();
0: 
0: 	}
0: 
0: 	private static void tryCoreClasspath(StringBuffer successes, StringBuffer failures) {
0: 		tryMyClasspath("org.apache.derby.database.Database", Main.getTextMessage("SIF08.J","derby.jar" ), successes, failures);
0: 	}
0: 	private static void tryNetClasspath(StringBuffer successes, StringBuffer failures) {
0: 		tryMyClasspath("org.apache.derby.drda.NetworkServerControl", Main.getTextMessage("SIF08.I", "derbynet.jar"), successes, failures);
0: 	}
0: 	private static void tryClientClasspath(StringBuffer successes, StringBuffer failures) {
0: 		tryMyClasspath("com.ibm.db2.jcc.DB2Driver", Main.getTextMessage("SIF08.L", "db2jcc.jar"), successes, failures);
0: 	}
0: 
0: 	private static void tryUtilsClasspath(StringBuffer successes, StringBuffer failures) {
0: 		tryMyClasspath("org.apache.derby.tools.ij", Main.getTextMessage("SIF08.Q", "derbytools.jar"), successes, failures);
0: 	}
0: 
0: 	private static void tryMyClasspath(String cn, String library, StringBuffer successes, StringBuffer failures) {
0: 
0: 		try {
0: 			Class.forName(cn);
0: 			successes.append(found(cn, library));
0: 		}
0: 
0: 		catch (Throwable t) {
0: 
0: 			failures.append(notFound(cn, library));
0: 
0: 		}
0: 
0: 
0: 	}
0: 
0: 	private static void tryAsResource(String cn, String library, StringBuffer successes, StringBuffer failures) {
0: 
0: 		try {
0: 			java.io.InputStream in = cn.getClass().getResourceAsStream(cn);
0: 			in.close();
0: 			successes.append(found(cn, library));
0: 		}
0: 
0: 		catch (Throwable t) {
0: 			failures.append(notFound(cn, library));
0: 
0: 		}
0: 
0: 	}
0: 
0: 	private static String found(String cn, String library) {
0: 		StringBuffer temp = new StringBuffer(crLf());
0: 		temp.append("   " + library);
0: 		temp.append(crLf());
0: 		temp.append(crLf());
0: 		return temp.toString();
0: 	}
0: 	private static String notFound(String cn, String library) {
0: 
0: 		StringBuffer temp = new StringBuffer(crLf());
0: 		temp.append("   " + library);
0: 		temp.append(crLf());
0: 		temp.append("    " + Main.getTextMessage("SIF08.U", cn));
0: 		temp.append(crLf());
0: 		temp.append(crLf());
0: 		return temp.toString();
0: 	}
0: 
0: 	private static String crLf() {
0: 		return System.getProperty("line.separator");
0: 	}
0: 
0: 	private static String lookForMainArg(String[] args, java.io.PrintWriter localPW)
0: 	{
0: 		int length=args.length;
0: 		String[] legalargs = new String[1];
0: 		legalargs[0] = EMBEDDED;
0: 
0: 		int argsfound = 0;
0: 		String whichargument="";
0: 
0: 		for (int i = 0; i < length; i++) {
0: 
0: 			for (int j=0; j < legalargs.length; j++) {
0: 				if (args[i].toUpperCase(java.util.Locale.ENGLISH).equals(legalargs[j].toUpperCase(java.util.Locale.ENGLISH))) {
0: 					argsfound++;
0: 					whichargument=legalargs[j];
0: 				}
0: 			}
0: 		}
0: 		if (argsfound > 1 || argsfound < 1) {
0:             localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));
0: 			return "";
0: 		}
0: 		return whichargument;
0: 	}
0: 
0: 	private static boolean argumentsContain(String[] args, String s) {
0: 		for (int i = 0; i < args.length; i++) {
0: 			if (args[i].equalsIgnoreCase(s))
0: 				return true;
0: 		}
0: 		return false;
0: 
0: 	}
0: 
0: 	private static String argumentMatches(String[] args, String ss) {
0: 	    String userclass = "";
0: 		int length = args.length;
0: 		for (int i = 0; i < length; i++) {
0: 			if (args[i].endsWith(ss)) {
0: 				userclass = args[i].substring(0,args[i].length()-6) ;
0: 
0: 			}
0: 
0: 		}
0: 		return userclass;
0: 	}
0: 
0: 	/*
0: 	** Code related to loading info fromjar files.
0: 	*/
0: 
0:     private static final String infoNames[] = {
0: 
0:                                     "org/apache/derby/info/" +
0:                                     org.apache.derby.iapi.services.info.ProductGenusNames.DBMS +
0:                                     ".properties",
0: 
0: 
0:                                     "org/apache/derby/info/" +
0:                                     org.apache.derby.iapi.services.info.ProductGenusNames.TOOLS +
0:                                     ".properties",
0: 
0:                                     "org/apache/derby/info/" +
0:                                     org.apache.derby.iapi.services.info.ProductGenusNames.NET +
0:                                     ".properties"
0:                                 };
0: 
0:     public static ZipInfoProperties[] getAllInfo(String classpath)
0:     {
0:         try
0:         {
0: 			if (classpath != null) {
0: 				String cp [] = parseClasspath(classpath);
0: 				Vector v = new Vector();
0: 				for (int i = 0; i < cp.length; i++)
0: 				{
0: 					ZipInfoProperties zip = checkForInfo(cp[i]);
0: 					if (zip != null)
0: 					{
0: 						v.addElement(zip);
0: 					}
0: 				}
0: 				if (v.size() > 0)
0: 				{
0: 					ZipInfoProperties zips[] = new ZipInfoProperties[v.size()];
0: 					v.copyInto(zips);
0: 					return zips;
0: 				}
0: 			}
0:             return loadZipFromResource();
0: 
0:         }
0:         catch (SecurityException se)
0:         {
0:             ZipInfoProperties zip[] = new ZipInfoProperties[1];
0:             zip[0] = new ZipInfoProperties(null);
0:             zip[0].setLocation (Main.getTextMessage ("SIF03.C"));
0:             return zip;
0:         }
0:     }
0: 
0:     /**
0:         This method returns exactly one ZipInfoProperty in the array.
0:         If it is able to load the sysinfo file as a resource, it returns
0:         the ZipInfoProperty associated with that. Otherwise, the ZipInfoProperty
0:         will be empty.
0:      */
0:     private static ZipInfoProperties [] loadZipFromResource()
0:     {
0: 		java.util.ArrayList al = new java.util.ArrayList();
0: 
0:         for (int i = 0; i < infoNames.length; i++)
0:         {
0: 			String resource = "/".concat(infoNames[i]);
0: 
0:             InputStream is = new Main().getClass().getResourceAsStream(resource);
0: 			if (is == null)
0: 				continue;
0: 
0: 			ZipInfoProperties ze = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(is));
0: 			ze.setLocation(resource);
0: 
0: 			al.add(ze);
0:         }
0: 
0:         if (al.size() == 0)
0:         {
0:             return null;
0:         }
0: 
0:         ZipInfoProperties[] zip = new ZipInfoProperties[al.size()];
0: 
0: 		al.toArray(zip);
0: 
0:         return zip;
0:     }
0: 
0:     private static String [] parseClasspath(String cp)
0:     {
0:         StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);
0:         int count = st.countTokens();
0:         if (count == 0)
0:         {
0:             return null;
0:         }
0: 
0:         String vals[] = new String[count];
0:         for (int i =0; i < count; i++)
0:         {
0:             vals[i] = st.nextToken();
0:         }
0:         return vals;
0:     }
0: 
0:     private static ZipInfoProperties checkForInfo(String cpEntry)
0:     {
0:         File f = new File(cpEntry);
0:         if ( ! f.exists())
0:         {
0:             return null;
0:         }
0: 
0:         if (f.isDirectory())
0:         {
0:             ZipInfoProperties zip = checkDirectory(cpEntry);
0:             return zip;
0:         }
0: 
0:         if (f.isFile())
0:         {
0:             ZipInfoProperties zip = checkFile(cpEntry);
0:             return zip;
0:         }
0:         return null;
0: 
0: 
0:     }
0: 
0:     private static ZipInfoProperties checkDirectory(String dirname)
0:     {
0:         boolean foundOne = false;
0:         File f = null;
0:         for (int i = 0; i < infoNames.length; i++)
0:         {
0:             String localSysinfo = infoNames[i].replace('/', File.separatorChar);
0:             f = new File(dirname, localSysinfo);
0:             if (f.exists())
0:             {
0:                 foundOne = true;
0:                 break;
0:             }
0:         }
0: 
0:         if (!foundOne || (f == null))
0:         {
0:             return null;
0:         }
0: 
0:         try
0:         {
0:             InputStream bis = new FileInputStream(f);
0: 
0:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
0:             zip.setLocation(new File(dirname).getCanonicalPath().replace('/', File.separatorChar));
0:             return zip;
0:         }
0:         catch (IOException ioe)
0:         {
0:             return null;
0:         }
0: 
0:     }
0: 
0:     private static ZipInfoProperties checkFile(String filename)
0:     {
0:         // try to create a ZipFile from it
0: 
0: 	// Check to see if it's a version of db2jcc.jar and if so, report the version number. 
0: 	if (filename.indexOf("db2jcc") >= 0)
0: 	{
0: 	    Class c = null;
0: 	    Method m = null;
0: 	    Object o = null;
0: 	    Integer build = null;
0: 	    Integer major = null;
0:             Integer minor = null;
0: 	    try 
0: 	    {
0:                 try 
0: 		{
0: 		    c = Class.forName("com.ibm.db2.jcc.DB2Driver");
0: 		    m = c.getMethod("getJCCBuildNumber", null);
0: 		    o = c.newInstance();
0: 		    build = (Integer)m.invoke(o,null);
0: 		} catch (ClassNotFoundException cnfe) {
0: 		    c = Class.forName("com.ibm.db2.jcc.DB2Version");
0: 		    m = c.getMethod("getBuildNumber", null);
0: 		    o = c.newInstance();
0: 		    build = (Integer)m.invoke(o,null);
0: 	        } 
0: 		m = c.getMethod("getMajorVersion", null);
0: 		major = (Integer)m.invoke(o,null);
0: 		m = c.getMethod("getMinorVersion", null);
0: 		minor = (Integer)m.invoke(o,null);
0: 
0: 		ProductVersionHolder jccVersion = ProductVersionHolder.getProductVersionHolder(
0: 			"IBM Corp.",
0: 			"DB2 Java Common Client",
0: 			"DRDA:jcc",
0: 			major.intValue(),
0: 			minor.intValue(),
0: 			0,
0: 			0,
0: 			build.intValue(),
0: 			Boolean.FALSE);
0: 
0: 		ZipInfoProperties zip = new ZipInfoProperties(jccVersion);
0: 
0:         zip.setLocation(new File(filename).getCanonicalPath().replace('/', File.separatorChar));
0: 		return zip;
0:             } catch (Exception e) { return null; }
0: 	}
0: 
0:         try
0:         {
0:             ZipFile zf = new ZipFile(filename);
0:             // try to get a ZipEntry from the ZipFile
0: 
0:             ZipEntry thisEntry = null;
0: 
0:             for (int i =0; i < infoNames.length; i++)
0:             {
0:                 thisEntry = zf.getEntry(infoNames[i]);
0:                 if (thisEntry != null)
0:                 {
0:                     break;
0:                 }
0:             }
0: 
0:             if (thisEntry == null)
0:             {
0:                 return null;
0:             }
0: 
0:             InputStream bis = zf.getInputStream(thisEntry);
0:             if (bis == null)
0:             {
0:                 return null;
0:             }
0: 
0:             ZipInfoProperties zip = new ZipInfoProperties(ProductVersionHolder.getProductVersionHolderFromMyEnv(bis));
0:             zip.setLocation(new File(filename).getCanonicalPath().replace('/', File.separatorChar));
0:             return zip;
0: 
0:         }
0:         catch (IOException ioe)
0:         {
0:             //guess not
0:             return null;
0:         }
0: 
0:     }
0: 
0: 	/*
0: 	** Message handling
0: 	*/
0: 	private static ResourceBundle getBundle() {
0: 		try {
0: 			return ResourceBundle.getBundle("org.apache.derby.loc.sysinfoMessages");
0: 		} catch (MissingResourceException mre) {
0: 		}
0: 		return null;
0: 	}
0: 
0: 	public static String getTextMessage(String msgId) {
0: 		return getCompleteMessage(msgId, (Object[]) null);
0: 	}
0: 	public static String getTextMessage(String msgId, Object a1) {
0: 
0: 		return getCompleteMessage(msgId, new Object[] {a1});
0: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2});
0: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2, Object a3) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2, a3});
0: 	}
0: 	public static String getTextMessage(String msgId, Object a1, Object a2, Object a3, Object a4) {
0: 		return getCompleteMessage(msgId, new Object[] {a1, a2, a3, a4});
0: 	}
0: 
0: 	/**
0: 	 */
0: 	public static String getCompleteMessage(String msgId, Object[] arguments) {
0: 
0: 		// we have a base file (sysinfoMessages.properties) so don't give us a last chance.
0: 		return org.apache.derby.iapi.services.i18n.MessageService.formatMessage(getBundle(), msgId, arguments, false);
0: 	}
0: } // end of class Main
0: 
============================================================================