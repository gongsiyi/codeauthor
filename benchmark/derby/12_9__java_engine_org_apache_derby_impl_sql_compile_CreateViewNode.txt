1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CreateViewNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
30:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:600780d: 
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.Limits;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:d2a91c3: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * A CreateViewNode is the root of a QueryTree that represents a CREATE VIEW
1:eac0369:  * statement.
5:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class CreateViewNode extends DDLStatementNode
4:eac0369: {
1:600780d:     private ResultColumnList resultColumns;
1:600780d:     private ResultSetNode    queryExpression;
1:600780d:     private String           qeText;
1:600780d:     private int              checkOption;
1:600780d:     private ProviderInfo[]   providerInfos;
1:600780d:     private ColumnInfo[]     colInfos;
1:2060c4a: 	private OrderByList orderByList;
1:108305b:     private ValueNode   offset;
1:108305b:     private ValueNode   fetchFirst;
1:57c1b5c:     private boolean hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CreateViewNode
1:eac0369: 	 *
1:3bb140c:      * @param viewName          The name of the table to be created
1:eac0369: 	 * @param resultColumns		The column list from the view definition, 
1:eac0369: 	 *							if specified
1:eac0369: 	 * @param queryExpression	The query expression for the view
1:eac0369: 	 * @param checkOption		The type of WITH CHECK OPTION that was specified
1:eac0369: 	 *							(NONE for now)
1:eac0369: 	 * @param qeText			The text for the queryExpression
1:2060c4a: 	 * @param orderCols         ORDER BY list
1:108305b:      * @param offset            OFFSET if any, or null
1:108305b:      * @param fetchFirst        FETCH FIRST if any, or null
1:57c1b5c: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax
1:3bb140c:      * @param cm                Context manager
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     CreateViewNode(TableName viewName,
1:3bb140c:                    ResultColumnList resultColumns,
1:3bb140c:                    ResultSetNode queryExpression,
1:3bb140c:                    int checkOption,
1:3bb140c:                    String qeText,
1:3bb140c:                    OrderByList orderCols,
1:3bb140c:                    ValueNode offset,
1:3bb140c:                    ValueNode fetchFirst,
1:3bb140c:                    boolean hasJDBClimitClause,
1:3bb140c:                    ContextManager cm)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         super(viewName, cm);
1:3bb140c:         this.resultColumns = resultColumns;
1:3bb140c:         this.queryExpression = queryExpression;
1:3bb140c:         this.checkOption = checkOption;
1:3bb140c:         this.qeText = qeText.trim();
1:3bb140c:         this.orderByList = orderCols;
1:3bb140c:         this.offset = offset;
1:3bb140c:         this.fetchFirst = fetchFirst;
1:3bb140c:         this.hasJDBClimitClause = hasJDBClimitClause;
1:3bb140c:         this.implicitCreateSchema = true;
1:600780d: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return super.toString() +
1:eac0369: 				"checkOption: " + checkOption + "\n" +
1:eac0369: 				"qeText: " + qeText + "\n";
6:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "CREATE VIEW";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (resultColumns != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "resultColumns: ");
1:eac0369: 				resultColumns.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			printLabel(depth, "queryExpression: ");
1:eac0369: 			queryExpression.treePrint(depth + 1);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// We inherit the generate() method from DDLStatementNode.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this CreateViewNode.  This means doing any static error
1:eac0369: 	 * checking that can be done before actually creating the table.
1:eac0369: 	 * For example, verifying that the ResultColumnList does not
1:eac0369: 	 * contain any duplicate column names.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:eac0369: 		CompilerContext				cc = getCompilerContext();
1:eac0369: 		DataDictionary				dataDictionary = getDataDictionary();
1:eac0369: 		ResultColumnList			qeRCL;
1:eac0369: 		String						duplicateColName;
1:eac0369: 
1:eac0369: 		// bind the query expression
1:eac0369: 
1:eac0369: 		providerInfos = bindViewDefinition
1:eac0369: 			( dataDictionary, cc, getLanguageConnectionContext(),
1:3bb140c:               getOptimizerFactory(),
1:eac0369: 			  queryExpression,
1:eac0369: 			  getContextManager()
1:eac0369: 			);
1:eac0369: 
1:eac0369: 		qeRCL = queryExpression.getResultColumns();
1:eac0369: 
1:eac0369: 		/* If there is an RCL for the view definition then
1:eac0369: 		 * copy the names to the queryExpression's RCL after verifying
1:eac0369: 		 * that they both have the same size.
1:eac0369: 		 */
1:eac0369: 		if (resultColumns != null)
1:eac0369: 		{
1:d5ef906: 			if (resultColumns.size() != qeRCL.visibleSize())
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_VIEW_DEFINITION_R_C_L_MISMATCH,
1:eac0369: 								getFullName());
1:eac0369: 			}
1:eac0369: 			qeRCL.copyResultColumnNames(resultColumns);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Check to make sure the queryExpression's RCL has unique names. If target column
1:eac0369: 		 * names not specified, raise error if there are any un-named columns to match DB2
1:eac0369: 		 */
1:eac0369: 		duplicateColName = qeRCL.verifyUniqueNames((resultColumns == null) ? true : false);
1:eac0369: 		if (duplicateColName != null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_VIEW, duplicateColName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Only 5000 columns allowed per view */
1:b1f84c1: 		if (queryExpression.getResultColumns().size() > Limits.DB2_MAX_COLUMNS_IN_VIEW)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1:eac0369: 				String.valueOf(queryExpression.getResultColumns().size()),
1:eac0369: 				getRelativeName(),
1:b1f84c1: 				String.valueOf(Limits.DB2_MAX_COLUMNS_IN_VIEW));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// for each column, stuff system.column
1:53cbb53: 		// System columns should only include visible columns DERBY-4230
1:53cbb53: 		colInfos = new ColumnInfo[queryExpression.getResultColumns().visibleSize()];
1:eac0369: 		genColumnInfos(colInfos);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the query expression for a view definition. 
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use to look up
1:eac0369: 	 *				columns, tables, etc.
1:eac0369: 	 *
1:eac0369: 	 * @return	Array of providers that this view depends on.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     private ProviderInfo[] bindViewDefinition(
1:3bb140c:         DataDictionary      dataDictionary,
1:3bb140c:         CompilerContext     compilerContext,
1:3bb140c:         LanguageConnectionContext lcc,
1:3bb140c:         OptimizerFactory    optimizerFactory,
1:3bb140c:         ResultSetNode       queryExpr,
1:3bb140c:         ContextManager      cm) throws StandardException
1:eac0369: 	{
1:3bb140c:         FromList fromList =
1:3bb140c:                 new FromList(optimizerFactory.doJoinOrderOptimization(), cm);
1:eac0369: 
1:eac0369: 		ProviderList 	prevAPL = compilerContext.getCurrentAuxiliaryProviderList();
1:eac0369: 		ProviderList 	apl = new ProviderList();
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			compilerContext.setCurrentAuxiliaryProviderList(apl);
1:d2a91c3: 			compilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);
1:eac0369: 
1:eac0369: 			/* Bind the tables in the queryExpression */
1:eac0369: 			queryExpr = queryExpr.bindNonVTITables(dataDictionary, fromList);
1:eac0369: 			queryExpr = queryExpr.bindVTITables(fromList);
1:eac0369: 
1:eac0369: 			/* Bind the expressions under the resultSet */
1:eac0369: 			queryExpr.bindExpressions(fromList);
1:eac0369: 
1:eac0369: 			//cannot define views on temporary tables
1:eac0369: 			if (queryExpr instanceof SelectNode)
1:eac0369: 			{
1:eac0369: 				//If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception
1:eac0369: 				if (queryExpr.referencesSessionSchema())
1:eac0369: 					throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// bind the query expression
1:eac0369: 			queryExpr.bindResultColumns(fromList);
1:c85f934: 			
1:c85f934: 			// rejects any untyped nulls in the RCL
1:c85f934: 			// e.g.:  CREATE VIEW v1 AS VALUES NULL
1:c85f934: 			queryExpr.bindUntypedNullsToResultColumns(null);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:d2a91c3: 			compilerContext.popCurrentPrivType();
1:eac0369: 			compilerContext.setCurrentAuxiliaryProviderList(prevAPL);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		DependencyManager 		dm = dataDictionary.getDependencyManager();
1:e1f49ca:         ProviderInfo[]          provInfo = dm.getPersistentProviderInfos(apl);
1:eac0369: 		// need to clear the column info in case the same table descriptor
1:eac0369: 		// is reused, eg., in multiple target only view definition
1:eac0369: 		dm.clearColumnInfoInProviders(apl);
1:eac0369: 
1:eac0369: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(fromList.size() == 0,
1:eac0369: 				"fromList.size() is expected to be 0, not " + fromList.size() +
1:eac0369: 				" on return from RS.bindExpressions()");
1:eac0369: 		}
1:eac0369: 
1:e1f49ca:         return provInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//If create view is part of create statement and the view references SESSION schema tables, then it will
1:eac0369: 		//get caught in the bind phase of the view and exception will be thrown by the view bind. 
1:eac0369: 		return (queryExpression.referencesSessionSchema());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		/* RESOLVE - need to build up dependendencies and store them away through
1:eac0369: 		 * the constant action.
1:eac0369: 		 */
1:eac0369: 		return	getGenericConstantActionFactory().getCreateViewConstantAction(getSchemaDescriptor().getSchemaName(),
1:eac0369: 											  getRelativeName(),
1:eac0369: 											  TableDescriptor.VIEW_TYPE,
1:eac0369: 											  qeText,
1:eac0369: 											  checkOption,
1:eac0369: 											  colInfos,
1:eac0369: 											  providerInfos,
1:eac0369: 											  (UUID)null); 	// compilation schema, filled
1:eac0369: 															// in when we create the view
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Fill in the ColumnInfo[] for this create view.
1:eac0369: 	 * 
1:eac0369: 	 * @param colInfos	The ColumnInfo[] to be filled in.
1:eac0369: 	 */
1:eac0369: 	private void genColumnInfos(ColumnInfo[] colInfos)
1:eac0369: 	{
1:eac0369: 		ResultColumnList rcl = 	queryExpression.getResultColumns();
1:eac0369: 
1:ff1932f: 		for (int index = 0; index < colInfos.length; index++)
1:eac0369: 		{
1:e1f49ca:             ResultColumn rc = rcl.elementAt(index);
1:ff1932f: 			// The colInfo array has been initialized to be of length 
1:ff1932f: 			// visibleSize() (DERBY-4230).  This code assumes that all the visible
1:ff1932f: 			// columns are at the beginning of the rcl. Throw an assertion 
1:ff1932f: 			// if we hit a generated column in what we think is the visible
1:ff1932f: 			// range.
1:ff1932f: 			if (SanityManager.DEBUG) {
1:b0456a0: 				if (rc.isGenerated())
1:ff1932f: 					SanityManager.THROWASSERT("Encountered generated column in expected visible range at rcl[" + index +"]");
1:ff1932f: 			}
1:eac0369: 			//RESOLVEAUTOINCREMENT
1:eac0369: 			colInfos[index] = new ColumnInfo(rc.getName(),
1:eac0369: 											 rc.getType(),
1:eac0369: 											 null,
1:3c09be7: 											 null,
1:eac0369: 											 null,
1:eac0369: 											 null,
1:eac0369: 											 null,
1:eac0369: 											 ColumnInfo.CREATE,
1:d055adb: 											 0, 0, 0, 0);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the parsed query expression (the SELECT statement).
1:eac0369: 	  *
1:eac0369: 	  *	@return	the parsed query expression.
1:eac0369: 	  */
1:867a530: 	ResultSetNode	getParsedQueryExpression() { return queryExpression; }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * These methods are used by execution
1:eac0369: 	 * to get information for storing into
1:eac0369: 	 * the system catalogs.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (queryExpression != null)
1:eac0369: 		{
1:eac0369: 			queryExpression = (ResultSetNode)queryExpression.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:108305b:     public OrderByList getOrderByList() {
1:108305b:         return orderByList;
1:108305b:     }
1:108305b: 
1:108305b:     public ValueNode getOffset() {
1:108305b:         return offset;
1:108305b:     }
1:108305b: 
1:108305b:     public ValueNode getFetchFirst() {
1:108305b:         return fetchFirst;
1:108305b:     }
1:57c1b5c:     
1:57c1b5c:     public boolean hasJDBClimitClause() { return hasJDBClimitClause; }
1:57c1b5c: 
1:2060c4a: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1: 											 0, 0, 0, 0);
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:c85f934
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			// rejects any untyped nulls in the RCL
1: 			// e.g.:  CREATE VIEW v1 AS VALUES NULL
1: 			queryExpr.bindUntypedNullsToResultColumns(null);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 				if (rc.isGenerated())
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:     private boolean hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
1: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
0:                    Object fetchFirst,
0:                    Object hasJDBClimitClause)
/////////////////////////////////////////////////////////////////////////
0:         this.hasJDBClimitClause = (hasJDBClimitClause == null) ? false : ((Boolean) hasJDBClimitClause).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean hasJDBClimitClause() { return hasJDBClimitClause; }
1: 
commit:3c09be7
/////////////////////////////////////////////////////////////////////////
1: 											 null,
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:         ProviderInfo[]          provInfo = dm.getPersistentProviderInfos(apl);
/////////////////////////////////////////////////////////////////////////
1:         return provInfo;
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn rc = rcl.elementAt(index);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
/////////////////////////////////////////////////////////////////////////
1: class CreateViewNode extends DDLStatementNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CreateViewNode
1:      * @param viewName          The name of the table to be created
/////////////////////////////////////////////////////////////////////////
1:      * @param cm                Context manager
1:     CreateViewNode(TableName viewName,
1:                    ResultColumnList resultColumns,
1:                    ResultSetNode queryExpression,
1:                    int checkOption,
1:                    String qeText,
1:                    OrderByList orderCols,
1:                    ValueNode offset,
1:                    ValueNode fetchFirst,
1:                    boolean hasJDBClimitClause,
1:                    ContextManager cm)
1:         super(viewName, cm);
0:         setNodeType(C_NodeTypes.CREATE_VIEW_NODE);
1:         this.resultColumns = resultColumns;
1:         this.queryExpression = queryExpression;
1:         this.checkOption = checkOption;
1:         this.qeText = qeText.trim();
1:         this.orderByList = orderCols;
1:         this.offset = offset;
1:         this.fetchFirst = fetchFirst;
1:         this.hasJDBClimitClause = hasJDBClimitClause;
1:         this.implicitCreateSchema = true;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:               getOptimizerFactory(),
/////////////////////////////////////////////////////////////////////////
1:     private ProviderInfo[] bindViewDefinition(
1:         DataDictionary      dataDictionary,
1:         CompilerContext     compilerContext,
1:         LanguageConnectionContext lcc,
1:         OptimizerFactory    optimizerFactory,
1:         ResultSetNode       queryExpr,
1:         ContextManager      cm) throws StandardException
1:         FromList fromList =
1:                 new FromList(optimizerFactory.doJoinOrderOptimization(), cm);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     private ValueNode   offset;
1:     private ValueNode   fetchFirst;
/////////////////////////////////////////////////////////////////////////
1:      * @param offset            OFFSET if any, or null
1:      * @param fetchFirst        FETCH FIRST if any, or null
/////////////////////////////////////////////////////////////////////////
0:                    Object orderCols,
0:                    Object offset,
0:                    Object fetchFirst)
/////////////////////////////////////////////////////////////////////////
0:         this.offset = (ValueNode)offset;
0:         this.fetchFirst = (ValueNode)fetchFirst;
/////////////////////////////////////////////////////////////////////////
1:     public OrderByList getOrderByList() {
1:         return orderByList;
1:     }
1: 
1:     public ValueNode getOffset() {
1:         return offset;
1:     }
1: 
1:     public ValueNode getFetchFirst() {
1:         return fetchFirst;
1:     }
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	private OrderByList orderByList;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param orderCols         ORDER BY list
/////////////////////////////////////////////////////////////////////////
0: 				   Object qeText,
0: 				   Object orderCols)
/////////////////////////////////////////////////////////////////////////
0: 		this.orderByList = (OrderByList)orderCols;
/////////////////////////////////////////////////////////////////////////
0: 	public OrderByList getOrderByList() {
0: 		return orderByList;
1: 	}
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:519bfa7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:600780d
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
1: 
0: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private ResultColumnList resultColumns;
1:     private ResultSetNode    queryExpression;
1:     private String           qeText;
1:     private int              checkOption;
1:     private ProviderInfo[]   providerInfos;
1:     private ColumnInfo[]     colInfos;
/////////////////////////////////////////////////////////////////////////
0:     public final List getProviderInfo() {
0:         return ArrayUtil.asReadOnlyList(colInfos);
1:     }
commit:28f9484
/////////////////////////////////////////////////////////////////////////
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (queryExpression != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ff1932f
/////////////////////////////////////////////////////////////////////////
1: 		for (int index = 0; index < colInfos.length; index++)
1: 			// The colInfo array has been initialized to be of length 
1: 			// visibleSize() (DERBY-4230).  This code assumes that all the visible
1: 			// columns are at the beginning of the rcl. Throw an assertion 
1: 			// if we hit a generated column in what we think is the visible
1: 			// range.
1: 			if (SanityManager.DEBUG) {
0: 				if (rc.isGenerated)
1: 					SanityManager.THROWASSERT("Encountered generated column in expected visible range at rcl[" + index +"]");
1: 			}
commit:53cbb53
/////////////////////////////////////////////////////////////////////////
1: 		// System columns should only include visible columns DERBY-4230
1: 		colInfos = new ColumnInfo[queryExpression.getResultColumns().visibleSize()];
/////////////////////////////////////////////////////////////////////////
0: 			// Don't incorporate generated columns DERBY-4230
0: 			if (rc.isGenerated)
0: 				continue;
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 			if (resultColumns.size() != qeRCL.visibleSize())
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:0061383
/////////////////////////////////////////////////////////////////////////
0: public class CreateViewNode extends DDLStatementNode
commit:d387dac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1: 	ResultSetNode	getParsedQueryExpression() { return queryExpression; }
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CreateViewNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.catalog.UUID;
1: 
1: /**
1:  * A CreateViewNode is the root of a QueryTree that represents a CREATE VIEW
1:  * statement.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class CreateViewNode extends CreateStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	Dependent			currentDependent;
0: 	ResultColumnList	resultColumns;
0: 	ResultSetNode		queryExpression;
0: 	String				qeText;
0: 	int					checkOption;
0: 	ProviderInfo[]		providerInfos;
0: 	ColumnInfo[]		colInfos;
1: 
1: 
1: 	/**
0: 	 * Initializer for a CreateViewNode
1: 	 *
0: 	 * @param newObjectName		The name of the table to be created
1: 	 * @param resultColumns		The column list from the view definition, 
1: 	 *							if specified
1: 	 * @param queryExpression	The query expression for the view
1: 	 * @param checkOption		The type of WITH CHECK OPTION that was specified
1: 	 *							(NONE for now)
1: 	 * @param qeText			The text for the queryExpression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object newObjectName,
0: 				   Object resultColumns,
0: 				   Object	 queryExpression,
0: 				   Object checkOption,
0: 				   Object qeText)
1: 		throws StandardException
1: 	{
0: 		initAndCheck(newObjectName);
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.queryExpression = (ResultSetNode) queryExpression;
0: 		this.checkOption = ((Integer) checkOption).intValue();
0: 		this.qeText = ((String) qeText).trim();
1: 
0: 		implicitCreateSchema = true;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return super.toString() +
1: 				"checkOption: " + checkOption + "\n" +
1: 				"qeText: " + qeText + "\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "CREATE VIEW";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (resultColumns != null)
1: 			{
1: 				printLabel(depth, "resultColumns: ");
1: 				resultColumns.treePrint(depth + 1);
1: 			}
1: 
1: 			printLabel(depth, "queryExpression: ");
1: 			queryExpression.treePrint(depth + 1);
1: 		}
1: 	}
1: 
0: 	// accessors
1: 
0: 	public	int				getCheckOption() { return checkOption; }
1: 
0: 	public	ProviderInfo[]	getProviderInfo() { return providerInfos; }
1: 
0: 	public	ColumnInfo[]	getColumnInfo() { return colInfos; }
1: 
1: 	// We inherit the generate() method from DDLStatementNode.
1: 
1: 	/**
1: 	 * Bind this CreateViewNode.  This means doing any static error
1: 	 * checking that can be done before actually creating the table.
1: 	 * For example, verifying that the ResultColumnList does not
1: 	 * contain any duplicate column names.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
1: 		CompilerContext				cc = getCompilerContext();
1: 		DataDictionary				dataDictionary = getDataDictionary();
1: 		ResultColumnList			qeRCL;
1: 		String						duplicateColName;
1: 
1: 		// bind the query expression
1: 
1: 		providerInfos = bindViewDefinition
1: 			( dataDictionary, cc, getLanguageConnectionContext(),
0: 			  getNodeFactory(), 
1: 			  queryExpression,
1: 			  getContextManager()
1: 			);
1: 
1: 		qeRCL = queryExpression.getResultColumns();
1: 
1: 		/* If there is an RCL for the view definition then
1: 		 * copy the names to the queryExpression's RCL after verifying
1: 		 * that they both have the same size.
1: 		 */
1: 		if (resultColumns != null)
1: 		{
0: 			if (resultColumns.size() != qeRCL.size())
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_VIEW_DEFINITION_R_C_L_MISMATCH,
1: 								getFullName());
1: 			}
1: 			qeRCL.copyResultColumnNames(resultColumns);
1: 		}
1: 
1: 		/* Check to make sure the queryExpression's RCL has unique names. If target column
1: 		 * names not specified, raise error if there are any un-named columns to match DB2
1: 		 */
1: 		duplicateColName = qeRCL.verifyUniqueNames((resultColumns == null) ? true : false);
1: 		if (duplicateColName != null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_VIEW, duplicateColName);
1: 		}
1: 
0: 		/* Remember the current Dependent (the statement) here (since we
0: 		 * already have the CompilerContext).  We will use this info
0: 		 * during generate() to create the dependencies for the view.
1: 		 */
0: 		currentDependent = cc.getCurrentDependent();
1: 
1: 
1: 		/* Only 5000 columns allowed per view */
0: 		if (queryExpression.getResultColumns().size() > DB2Limit.DB2_MAX_COLUMNS_IN_VIEW)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1: 				String.valueOf(queryExpression.getResultColumns().size()),
1: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_VIEW));
1: 		}
1: 
1: 		// for each column, stuff system.column
0: 		colInfos = new ColumnInfo[queryExpression.getResultColumns().size()];
1: 		genColumnInfos(colInfos);
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind the query expression for a view definition. 
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use to look up
1: 	 *				columns, tables, etc.
1: 	 *
1: 	 * @return	Array of providers that this view depends on.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	private ProviderInfo[] bindViewDefinition( DataDictionary 	dataDictionary,
0: 											 CompilerContext	compilerContext,
0: 											 LanguageConnectionContext lcc,
0: 											 NodeFactory		nodeFactory,
0: 											 ResultSetNode		queryExpr,
0: 											 ContextManager		cm)
1: 		throws StandardException
1: 	{
0: 		FromList	fromList = (FromList) nodeFactory.getNode(
0: 										C_NodeTypes.FROM_LIST,
0: 										nodeFactory.doJoinOrderOptimization(),
0: 										cm);
1: 
1: 		ProviderList 	prevAPL = compilerContext.getCurrentAuxiliaryProviderList();
1: 		ProviderList 	apl = new ProviderList();
1: 
1: 		try {
1: 			compilerContext.setCurrentAuxiliaryProviderList(apl);
1: 
1: 			/* Bind the tables in the queryExpression */
1: 			queryExpr = queryExpr.bindNonVTITables(dataDictionary, fromList);
1: 			queryExpr = queryExpr.bindVTITables(fromList);
1: 
1: 			/* Bind the expressions under the resultSet */
1: 			queryExpr.bindExpressions(fromList);
1: 
1: 			//cannot define views on temporary tables
1: 			if (queryExpr instanceof SelectNode)
1: 			{
1: 				//If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception
1: 				if (queryExpr.referencesSessionSchema())
1: 					throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1: 			}
1: 
1: 			// bind the query expression
1: 			queryExpr.bindResultColumns(fromList);
1: 		}
1: 		finally
1: 		{
1: 			compilerContext.setCurrentAuxiliaryProviderList(prevAPL);
1: 		}
1: 
1: 		DependencyManager 		dm = dataDictionary.getDependencyManager();
0: 		ProviderInfo[]			providerInfos = dm.getPersistentProviderInfos(apl);
1: 		// need to clear the column info in case the same table descriptor
1: 		// is reused, eg., in multiple target only view definition
1: 		dm.clearColumnInfoInProviders(apl);
1: 
1: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromList.size() == 0,
1: 				"fromList.size() is expected to be 0, not " + fromList.size() +
1: 				" on return from RS.bindExpressions()");
1: 		}
1: 
0: 		return providerInfos;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		//If create view is part of create statement and the view references SESSION schema tables, then it will
1: 		//get caught in the bind phase of the view and exception will be thrown by the view bind. 
1: 		return (queryExpression.referencesSessionSchema());
1: 	}
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 		/* RESOLVE - need to build up dependendencies and store them away through
1: 		 * the constant action.
1: 		 */
1: 		return	getGenericConstantActionFactory().getCreateViewConstantAction(getSchemaDescriptor().getSchemaName(),
1: 											  getRelativeName(),
1: 											  TableDescriptor.VIEW_TYPE,
1: 											  qeText,
1: 											  checkOption,
1: 											  colInfos,
1: 											  providerInfos,
1: 											  (UUID)null); 	// compilation schema, filled
1: 															// in when we create the view
1: 	}
1: 
1: 	/**
1: 	 * Fill in the ColumnInfo[] for this create view.
1: 	 * 
1: 	 * @param colInfos	The ColumnInfo[] to be filled in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	private void genColumnInfos(ColumnInfo[] colInfos)
1: 	{
1: 		ResultColumnList rcl = 	queryExpression.getResultColumns();
0: 		int			 	 rclSize = rcl.size();
1: 
0: 		for (int index = 0; index < rclSize; index++)
1: 		{
0: 			ResultColumn rc = (ResultColumn) rcl.elementAt(index);
1: 
1: 			//RESOLVEAUTOINCREMENT
1: 			colInfos[index] = new ColumnInfo(rc.getName(),
1: 											 rc.getType(),
1: 											 null,
1: 											 null,
1: 											 null,
1: 											 null,
1: 											 ColumnInfo.CREATE,
0: 											 0, 0);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * class interface
1: 	 */
1: 
1: 	/**
1: 	  *	Get the parsed query expression (the SELECT statement).
1: 	  *
1: 	  *	@return	the parsed query expression.
1: 	  */
0: 	public	ResultSetNode	getParsedQueryExpression() { return queryExpression; }
1: 
1: 	/**
0: 	  *	Get the bound result column list.
1: 	  *
0: 	  *	@return	the bound result column list.
1: 	  */
0: 	public	ResultColumnList	getBoundResultColumnList()
1: 	{
0: 		return queryExpression.getResultColumns();
1: 	}
1: 
1: 
1: 	/*
1: 	 * These methods are used by execution
1: 	 * to get information for storing into
1: 	 * the system catalogs.
1: 	 */
1: 
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (!v.stopTraversal())
1: 		{
0: 			super.accept(v);
1: 		}
1: 
0: 		if (queryExpression != null && !v.stopTraversal())
1: 		{
1: 			queryExpression = (ResultSetNode)queryExpression.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d2a91c3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 			compilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);
/////////////////////////////////////////////////////////////////////////
1: 			compilerContext.popCurrentPrivType();
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
0: 											 0, 0, 0);
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 		if (queryExpression.getResultColumns().size() > Limits.DB2_MAX_COLUMNS_IN_VIEW)
1: 				String.valueOf(Limits.DB2_MAX_COLUMNS_IN_VIEW));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0:  * A CreateViewNode is the root of a QueryTree that represents a CREATE VIEW
0:  * statement.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class CreateViewNode extends CreateStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	Dependent			currentDependent;
0: 	ResultColumnList	resultColumns;
0: 	ResultSetNode		queryExpression;
0: 	String				qeText;
0: 	int					checkOption;
0: 	ProviderInfo[]		providerInfos;
0: 	ColumnInfo[]		colInfos;
0: 
0: 
0: 	/**
0: 	 * Initializer for a CreateViewNode
0: 	 *
0: 	 * @param newObjectName		The name of the table to be created
0: 	 * @param resultColumns		The column list from the view definition, 
0: 	 *							if specified
0: 	 * @param queryExpression	The query expression for the view
0: 	 * @param checkOption		The type of WITH CHECK OPTION that was specified
0: 	 *							(NONE for now)
0: 	 * @param qeText			The text for the queryExpression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object newObjectName,
0: 				   Object resultColumns,
0: 				   Object	 queryExpression,
0: 				   Object checkOption,
0: 				   Object qeText)
0: 		throws StandardException
0: 	{
0: 		initAndCheck(newObjectName);
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.queryExpression = (ResultSetNode) queryExpression;
0: 		this.checkOption = ((Integer) checkOption).intValue();
0: 		this.qeText = ((String) qeText).trim();
0: 
0: 		implicitCreateSchema = true;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return super.toString() +
0: 				"checkOption: " + checkOption + "\n" +
0: 				"qeText: " + qeText + "\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "CREATE VIEW";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (resultColumns != null)
0: 			{
0: 				printLabel(depth, "resultColumns: ");
0: 				resultColumns.treePrint(depth + 1);
0: 			}
0: 
0: 			printLabel(depth, "queryExpression: ");
0: 			queryExpression.treePrint(depth + 1);
0: 		}
0: 	}
0: 
0: 	// accessors
0: 
0: 	public	int				getCheckOption() { return checkOption; }
0: 
0: 	public	ProviderInfo[]	getProviderInfo() { return providerInfos; }
0: 
0: 	public	ColumnInfo[]	getColumnInfo() { return colInfos; }
0: 
0: 	// We inherit the generate() method from DDLStatementNode.
0: 
0: 	/**
0: 	 * Bind this CreateViewNode.  This means doing any static error
0: 	 * checking that can be done before actually creating the table.
0: 	 * For example, verifying that the ResultColumnList does not
0: 	 * contain any duplicate column names.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		CompilerContext				cc = getCompilerContext();
0: 		DataDictionary				dataDictionary = getDataDictionary();
0: 		ResultColumnList			qeRCL;
0: 		String						duplicateColName;
0: 
0: 		// bind the query expression
0: 
0: 		providerInfos = bindViewDefinition
0: 			( dataDictionary, cc, getLanguageConnectionContext(),
0: 			  getNodeFactory(), 
0: 			  queryExpression,
0: 			  getContextManager()
0: 			);
0: 
0: 		qeRCL = queryExpression.getResultColumns();
0: 
0: 		/* If there is an RCL for the view definition then
0: 		 * copy the names to the queryExpression's RCL after verifying
0: 		 * that they both have the same size.
0: 		 */
0: 		if (resultColumns != null)
0: 		{
0: 			if (resultColumns.size() != qeRCL.size())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_VIEW_DEFINITION_R_C_L_MISMATCH,
0: 								getFullName());
0: 			}
0: 			qeRCL.copyResultColumnNames(resultColumns);
0: 		}
0: 
0: 		/* Check to make sure the queryExpression's RCL has unique names. If target column
0: 		 * names not specified, raise error if there are any un-named columns to match DB2
0: 		 */
0: 		duplicateColName = qeRCL.verifyUniqueNames((resultColumns == null) ? true : false);
0: 		if (duplicateColName != null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_VIEW, duplicateColName);
0: 		}
0: 
0: 		/* Remember the current Dependent (the statement) here (since we
0: 		 * already have the CompilerContext).  We will use this info
0: 		 * during generate() to create the dependencies for the view.
0: 		 */
0: 		currentDependent = cc.getCurrentDependent();
0: 
0: 
0: 		/* Only 5000 columns allowed per view */
0: 		if (queryExpression.getResultColumns().size() > DB2Limit.DB2_MAX_COLUMNS_IN_VIEW)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
0: 				String.valueOf(queryExpression.getResultColumns().size()),
0: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_VIEW));
0: 		}
0: 
0: 		// for each column, stuff system.column
0: 		colInfos = new ColumnInfo[queryExpression.getResultColumns().size()];
0: 		genColumnInfos(colInfos);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind the query expression for a view definition. 
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use to look up
0: 	 *				columns, tables, etc.
0: 	 *
0: 	 * @return	Array of providers that this view depends on.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private ProviderInfo[] bindViewDefinition( DataDictionary 	dataDictionary,
0: 											 CompilerContext	compilerContext,
0: 											 LanguageConnectionContext lcc,
0: 											 NodeFactory		nodeFactory,
0: 											 ResultSetNode		queryExpr,
0: 											 ContextManager		cm)
0: 		throws StandardException
0: 	{
0: 		FromList	fromList = (FromList) nodeFactory.getNode(
0: 										C_NodeTypes.FROM_LIST,
0: 										nodeFactory.doJoinOrderOptimization(),
0: 										cm);
0: 
0: 		ProviderList 	prevAPL = compilerContext.getCurrentAuxiliaryProviderList();
0: 		ProviderList 	apl = new ProviderList();
0: 
0: 		try {
0: 			compilerContext.setCurrentAuxiliaryProviderList(apl);
0: 
0: 			/* Bind the tables in the queryExpression */
0: 			queryExpr = queryExpr.bindNonVTITables(dataDictionary, fromList);
0: 			queryExpr = queryExpr.bindVTITables(fromList);
0: 
0: 			/* Bind the expressions under the resultSet */
0: 			queryExpr.bindExpressions(fromList);
0: 
0: 			//cannot define views on temporary tables
0: 			if (queryExpr instanceof SelectNode)
0: 			{
0: 				//If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception
0: 				if (queryExpr.referencesSessionSchema())
0: 					throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
0: 			}
0: 
0: 			// bind the query expression
0: 			queryExpr.bindResultColumns(fromList);
0: 		}
0: 		finally
0: 		{
0: 			compilerContext.setCurrentAuxiliaryProviderList(prevAPL);
0: 		}
0: 
0: 		DependencyManager 		dm = dataDictionary.getDependencyManager();
0: 		ProviderInfo[]			providerInfos = dm.getPersistentProviderInfos(apl);
0: 		// need to clear the column info in case the same table descriptor
0: 		// is reused, eg., in multiple target only view definition
0: 		dm.clearColumnInfoInProviders(apl);
0: 
0: 		/* Verify that all underlying ResultSets reclaimed their FromList */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromList.size() == 0,
0: 				"fromList.size() is expected to be 0, not " + fromList.size() +
0: 				" on return from RS.bindExpressions()");
0: 		}
0: 
0: 		return providerInfos;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If create view is part of create statement and the view references SESSION schema tables, then it will
0: 		//get caught in the bind phase of the view and exception will be thrown by the view bind. 
0: 		return (queryExpression.referencesSessionSchema());
0: 	}
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		/* RESOLVE - need to build up dependendencies and store them away through
0: 		 * the constant action.
0: 		 */
0: 		return	getGenericConstantActionFactory().getCreateViewConstantAction(getSchemaDescriptor().getSchemaName(),
0: 											  getRelativeName(),
0: 											  TableDescriptor.VIEW_TYPE,
0: 											  qeText,
0: 											  checkOption,
0: 											  colInfos,
0: 											  providerInfos,
0: 											  (UUID)null); 	// compilation schema, filled
0: 															// in when we create the view
0: 	}
0: 
0: 	/**
0: 	 * Fill in the ColumnInfo[] for this create view.
0: 	 * 
0: 	 * @param colInfos	The ColumnInfo[] to be filled in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	private void genColumnInfos(ColumnInfo[] colInfos)
0: 	{
0: 		ResultColumnList rcl = 	queryExpression.getResultColumns();
0: 		int			 	 rclSize = rcl.size();
0: 
0: 		for (int index = 0; index < rclSize; index++)
0: 		{
0: 			ResultColumn rc = (ResultColumn) rcl.elementAt(index);
0: 
0: 			//RESOLVEAUTOINCREMENT
0: 			colInfos[index] = new ColumnInfo(rc.getName(),
0: 											 rc.getType(),
0: 											 null,
0: 											 null,
0: 											 null,
0: 											 null,
0: 											 ColumnInfo.CREATE,
0: 											 0, 0);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: 
0: 	/**
0: 	  *	Get the parsed query expression (the SELECT statement).
0: 	  *
0: 	  *	@return	the parsed query expression.
0: 	  */
0: 	public	ResultSetNode	getParsedQueryExpression() { return queryExpression; }
0: 
0: 	/**
0: 	  *	Get the bound result column list.
0: 	  *
0: 	  *	@return	the bound result column list.
0: 	  */
0: 	public	ResultColumnList	getBoundResultColumnList()
0: 	{
0: 		return queryExpression.getResultColumns();
0: 	}
0: 
0: 
0: 	/*
0: 	 * These methods are used by execution
0: 	 * to get information for storing into
0: 	 * the system catalogs.
0: 	 */
0: 
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (!v.stopTraversal())
0: 		{
0: 			super.accept(v);
0: 		}
0: 
0: 		if (queryExpression != null && !v.stopTraversal())
0: 		{
0: 			queryExpression = (ResultSetNode)queryExpression.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: 
0: }
============================================================================