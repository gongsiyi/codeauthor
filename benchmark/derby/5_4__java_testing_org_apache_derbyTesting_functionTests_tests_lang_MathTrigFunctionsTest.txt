1:7a2df4c: /* Licensed to the Apache Software Foundation (ASF) under one or more
1:7a2df4c:  contributor license agreements.  See the NOTICE file distributed with
1:7a2df4c:  this work for additional information regarding copyright ownership.
1:7a2df4c:  The ASF licenses this file to You under the Apache License, Version 2.0
1:7a2df4c:  (the "License"); you may not use this file except in compliance with
1:7a2df4c:  the License.  You may obtain a copy of the License at
2:7a2df4c: 
1:7a2df4c:  http://www.apache.org/licenses/LICENSE-2.0
1:7a2df4c: 
1:7a2df4c:  Unless required by applicable law or agreed to in writing, software
1:7a2df4c:  distributed under the License is distributed on an "AS IS" BASIS,
1:7a2df4c:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7a2df4c:  See the License for the specific language governing permissions and
1:7a2df4c:  limitations under the License.
1:7a2df4c:  */
1:7a2df4c: 
1:7a2df4c: package org.apache.derbyTesting.functionTests.tests.lang;
1:7a2df4c: 
1:b9989a8: import java.sql.PreparedStatement;
1:7a2df4c: import java.sql.ResultSet;
1:7a2df4c: import java.sql.SQLException;
1:7a2df4c: import java.sql.Statement;
1:7a2df4c: import java.util.Random;
1:7a2df4c: 
1:7a2df4c: import junit.framework.Test;
1:7a2df4c: 
1:7a2df4c: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:7a2df4c: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:584c0fb: import org.apache.derbyTesting.junit.JDBC;
1:eba07fc: import org.apache.derbyTesting.junit.TestConfiguration;
1:7a2df4c: 
1:7a2df4c: public class MathTrigFunctionsTest extends BaseJDBCTestCase {
1:7a2df4c: 
1:c0a5ce1:    private static final double
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE = -1.79769E+308;
1:7a2df4c: 
1:c0a5ce1:    private static final double
1:c0a5ce1:             SMALL_NEG_DOUBLE = -1.79768E+308;
1:7a2df4c: 
1:c0a5ce1:    private static final double
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE = 2.225E-307;
1:7a2df4c: 
1:c0a5ce1:    private static final double
1:c0a5ce1:             PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE = 1.79769E+308;
1:7a2df4c: 
1:c0a5ce1:    private static final double
1:c0a5ce1:             PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE = -2.225E-307;
1:7a2df4c: 
1:7a2df4c: 	private static final double[] testRadians = { -0.000000001, -0.25,
1:7a2df4c: 			0.000000001, 0.25, 0.5, 0.0, 1.0, 2.0, java.lang.StrictMath.PI,
1:7a2df4c: 			java.lang.StrictMath.PI };
1:7a2df4c: 
1:7a2df4c: 	private static final double[] testArcValues = { 0.000000001, -0.000000001,
1:7a2df4c: 			0.25, -0.25, 0.5, 0.0, -0.0, 1.0, -1.0 };
1:7a2df4c: 
1:7a2df4c: 	private static final double[] logValues = { 0.000000001, 0.25, 0.5, 1.0,
1:c0a5ce1:            45.0, 90.0, 135.0, 180.0, 270, PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
1:584c0fb:            PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE, 10, 100, 1000, 10000,
1:584c0fb:            100000, 1000000, 10000000, 100000000, 1000000000};
1:7a2df4c: 
1:c0a5ce1:    private static final double[] testValues = {
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE,
1:c0a5ce1:             SMALL_NEG_DOUBLE,
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
1:c0a5ce1:             PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE,
1:c0a5ce1:             PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE,
1:c0a5ce1:             0.000000001,
1:7a2df4c: 			-0.000000001, 0.25, -0.25, 0.5, 0.0, -0.0, 1.0, -1.0, 2.0, 3.0,
1:7a2df4c: 			java.lang.StrictMath.PI, 2 * java.lang.StrictMath.PI, 4.0, 45.0,
1:7a2df4c: 			90.0, 135.0, 180.0, 270 };
1:7a2df4c: 
1:c0a5ce1:    private static final double[] testValuesTwo = {
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE,
1:c0a5ce1:            SMALL_NEG_DOUBLE,
1:c0a5ce1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
1:c0a5ce1:            PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE,
1:c0a5ce1:             0.000000001, -0.000000001, 0.25, -0.25,
1:7a2df4c: 			0.5, 0.0, -0.0, 1.0, -1.0, 2.0, 3.0, java.lang.StrictMath.PI,
1:7a2df4c: 			2 * java.lang.StrictMath.PI, 4.0, 45.0, 90.0, 135.0, 180.0, 270 };
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the ACOS function which returns the arc cosine of a specified
1:7a2df4c: 	 * number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * Acceptable input values to the ACOS function are DOUBLE PRECISION values
1:7a2df4c: 	 * from -1 to 1. NULL returns NULL and if the absolute value of the input is
1:7a2df4c: 	 * greater than 1 an SQL state of 22003 is returned.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value from the ACOS function is a DOUBLE PRECISION number in
1:7a2df4c: 	 * radians with a range of zero to PI.
1:7a2df4c: 	 * 
1:7a2df4c: 	 */
1:7a2df4c: 	public void testAcos() throws SQLException {
1:7a2df4c: 		// test the case where the input value is null
1:7a2df4c: 		executeNullValues("ACOS");
1:7a2df4c: 		executeNullFn("ACOS");
1:7a2df4c: 		debug();
1:b9989a8:         
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES ACOS(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn ACOS(?)}");
1:b9989a8:          
1:7a2df4c: 		for (int i = 0; i < testArcValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.acos(testArcValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testArcValues[i]);
1:7a2df4c: 			debug("ACOS: input value: " + testArcValues[i]
1:7a2df4c: 					+ " expected value: " + expected + " return value: "
1:7a2df4c: 					+ rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testArcValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 
7:7a2df4c: 		}
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.acos(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		/* test the case where the input value is out of range */
3:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, 2.0);
1:7a2df4c: 			fail("ACOS: Out of range test failed, input value is: " + 2.0);
3:7a2df4c: 		} catch (SQLException sqlE) {
3:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
3:7a2df4c: 			// data type DOUBLE.";
3:7a2df4c: 			assertSQLState(
3:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
3:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:b9989a8: 
1:7a2df4c: 		/* test the case where the input value is out of range */
1:7a2df4c: 		try {
1:b9989a8: 			getValue(psFN, 2.0);
1:7a2df4c: 			fail("ACOS: Out of range test failed, input value is: " + 2.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:b9989a8: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the ASIN function which returns the arc sine of a specified number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * Acceptable input values to the ASIN function are DOUBLE PRECISION values
1:7a2df4c: 	 * from -1 to 1.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the specified number is zero (0), the result of this function is zero.
1:7a2df4c: 	 * Note: Derby does not support negative zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * An input value of NULL returns NULL.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the absolute value of the input is greater than 1 an SQL state of
1:7a2df4c: 	 * 22003 is returned.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value from the ASIN function is a DOUBLE PRECISION number in
1:7a2df4c: 	 * radians with a range of -PI/2 to PI/2.
1:7a2df4c: 	 * 
1:7a2df4c: 	 */
1:7a2df4c: 	public void testAsin() throws SQLException {
1:7a2df4c: 		executeNullValues("ASIN");
1:7a2df4c: 		executeNullFn("ASIN");
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES ASIN(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn ASIN(?)}");
1:b9989a8: 
1:7a2df4c: 		for (int i = 0; i < testArcValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.asin(testArcValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testArcValues[i]);
1:7a2df4c: 			debug("ASIN: input value: " + testArcValues[i]
1:7a2df4c: 					+ " expected value: " + expected + " return value: "
1:7a2df4c: 					+ rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testArcValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.asin(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, 2.0);
1:7a2df4c: 			fail("ASIN: Out of range test failed, input value is: " + 2.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:b9989a8: 			getValue(psFN, 2.0);
1:7a2df4c: 			fail("ASIN: Out of range test failed, input value is: " + 2.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the ATAN function which returns the arc tangent of a specified
1:7a2df4c: 	 * number. Acceptable input values to the ATAN function are DOUBLE PRECISION
1:7a2df4c: 	 * values.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the specified number is zero (0), the result of this function is zero.
1:7a2df4c: 	 * An input value of NULL returns NULL.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value from the ATAN function is a DOUBLE PRECISION number in
1:7a2df4c: 	 * radians with a range of -PI/2 to PI/2.
1:7a2df4c: 	 * 
1:7a2df4c: 	 */
1:7a2df4c: 	public void testAtan() throws SQLException {
1:7a2df4c: 		executeNullValues("ATAN");
1:7a2df4c: 		executeNullFn("ATAN");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES ATAN(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn ATAN(?)}");
1:b9989a8: 
1:b9989a8:         for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.atan(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("ATAN: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.atan(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:b9989a8: 
1:7a2df4c: 		}
1:7a2df4c:         
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the COS function which returns the cosine of a specified number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * Acceptable input values to the COS function are DOUBLE PRECISION values.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * An input value of NULL returns NULL.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testCos() throws SQLException {
1:7a2df4c: 		executeNullValues("COS");
1:7a2df4c: 		executeNullFn("COS");
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES COS(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn COS(?)}");
1:b9989a8:         
2:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.cos(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("COS: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.cos(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the SIN function which returns the sine of a specified number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * Acceptable input values to the SIN function are DOUBLE PRECISION values.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * An input value of NULL returns NULL.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the argument is zero, then the result is zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testSin() throws SQLException {
1:7a2df4c: 		executeNullValues("SIN");
1:7a2df4c: 		executeNullFn("SIN");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES SIN(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn SIN(?)}");
1:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.sin(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("SIN: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.sin(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the TAN function which returns the tangent of a specified number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * Acceptable input values to the TAN function are DOUBLE PRECISION values.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * An input value of NULL returns NULL.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the argument is zero, then the result is zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testTan() throws SQLException {
1:7a2df4c: 		executeNullValues("TAN");
1:7a2df4c: 
1:7a2df4c: 		executeNullFn("TAN");
1:b9989a8: 
1:7a2df4c: 		debug();
1:7a2df4c:         
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES TAN(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn TAN(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.tan(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("TAN: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.tan(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:584c0fb:     public void testCot() throws SQLException {
1:584c0fb:         executeNullValues("COT");
1:584c0fb:         executeNullFn("COT");
1:584c0fb:         debug();
1:584c0fb: 
1:584c0fb:         PreparedStatement ps = prepareStatement("VALUES COT(?)");
1:584c0fb:         PreparedStatement psFN = prepareStatement("VALUES {fn COT(?)}");
1:584c0fb: 
1:584c0fb:         for (double value : testValues) {
1:584c0fb:             checkResult(ps, value, 1.0d / StrictMath.tan(value));
1:584c0fb:         }
1:584c0fb: 
1:584c0fb:         Random rand = new Random();
1:584c0fb:         for (int i = 0; i < 100; i++) {
1:584c0fb:             double randD = rand.nextDouble();
1:584c0fb:             double expected = 1.0d / StrictMath.tan(randD);
1:584c0fb:             checkResult(ps, randD, expected);
1:584c0fb:             checkResult(psFN, randD, expected);
1:584c0fb:         }
1:584c0fb:     }
1:584c0fb: 
1:584c0fb:     private void checkResult(PreparedStatement ps,
1:584c0fb:                              double input, double expected)
1:584c0fb:             throws SQLException {
1:584c0fb: 
1:584c0fb:         // Derby doesn't distinguish between positive and negative zero.
1:584c0fb:         if (expected == -0.0d) {
1:584c0fb:             expected = 0.0d;
1:584c0fb:         }
1:584c0fb: 
1:584c0fb:         ps.setDouble(1, input);
1:584c0fb:         if (Double.isNaN(expected) || Double.isInfinite(expected)) {
1:584c0fb:             debug("input value: " + input + " expected value: " + expected
1:584c0fb:                     + " : OUT OF RANGE");
1:584c0fb:             assertStatementError("22003", ps);
1:584c0fb:         } else {
1:584c0fb:             debug("input value: " + input + " expected value: " + expected);
1:584c0fb:             JDBC.assertSingleValueResultSet(
1:584c0fb:                     ps.executeQuery(), String.valueOf(expected));
1:584c0fb:         }
1:584c0fb:     }
1:584c0fb: 
1:584c0fb:     public void testCosh() throws SQLException {
1:584c0fb:         executeNullValues("COSH");
1:584c0fb:         debug();
1:584c0fb: 
1:584c0fb:         PreparedStatement ps = prepareStatement("VALUES COSH(?)");
1:584c0fb: 
1:584c0fb:         // COSH is not a JDBC escape function. Expect syntax error when
1:584c0fb:         // called as one.
1:584c0fb:         assertCompileError("42X01", "VALUES {fn COSH(?)}");
1:584c0fb: 
1:584c0fb:         for (double value : testValues) {
1:584c0fb:             checkResult(ps, value, StrictMath.cosh(value));
1:584c0fb:         }
1:584c0fb: 
1:584c0fb:         Random rand = new Random();
1:584c0fb:         for (int i = 0; i < 100; i++) {
1:584c0fb:             double randD = rand.nextDouble();
1:584c0fb:             double expect = StrictMath.cosh(randD);
1:584c0fb:             checkResult(ps, randD, expect);
1:584c0fb:         }
1:584c0fb:     }
1:584c0fb: 
1:584c0fb:     public void testSinh() throws SQLException {
1:584c0fb:         executeNullValues("SINH");
1:584c0fb:         debug();
1:584c0fb: 
1:584c0fb:         PreparedStatement ps = prepareStatement("VALUES SINH(?)");
1:584c0fb: 
1:584c0fb:         // SINH is not a JDBC escape function. Expect syntax error when
1:584c0fb:         // called as one.
1:584c0fb:         assertCompileError("42X01", "VALUES {fn SINH(?)}");
1:584c0fb: 
1:584c0fb:         for (double value : testValues) {
1:584c0fb:             checkResult(ps, value, StrictMath.sinh(value));
1:584c0fb:         }
1:584c0fb: 
1:584c0fb:         Random rand = new Random();
1:584c0fb:         for (int i = 0; i < 100; i++) {
1:584c0fb:             double randD = rand.nextDouble();
1:584c0fb:             double expect = StrictMath.sinh(randD);
1:584c0fb:             checkResult(ps, randD, expect);
1:584c0fb:         }
1:584c0fb:     }
1:584c0fb: 
1:584c0fb:     public void testTanh() throws SQLException {
1:584c0fb:         executeNullValues("TANH");
1:584c0fb:         debug();
1:584c0fb: 
1:584c0fb:         PreparedStatement ps = prepareStatement("VALUES TANH(?)");
1:584c0fb: 
1:584c0fb:         // TANH is not a JDBC escape function. Expect syntax error when
1:584c0fb:         // called as one.
1:584c0fb:         assertCompileError("42X01", "VALUES {fn TANH(?)}");
1:584c0fb: 
1:584c0fb:         for (double value : testValues) {
1:584c0fb:             checkResult(ps, value, StrictMath.tanh(value));
1:584c0fb:         }
1:584c0fb: 
1:584c0fb:         Random rand = new Random();
1:584c0fb:         for (int i = 0; i < 100; i++) {
1:584c0fb:             double randD = rand.nextDouble();
1:584c0fb:             double expect = StrictMath.tanh(randD);
1:584c0fb:             checkResult(ps, randD, expect);
1:584c0fb:         }
1:584c0fb:     }
1:584c0fb: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the PI function which returns a value that is closer than any other
1:7a2df4c: 	 * value to pi.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The constant pi is the ratio of the circumference of a circle to the
1:7a2df4c: 	 * diameter of a circle.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * No input values are allowed for the PI function.
1:7a2df4c: 	 */
1:7a2df4c: 
1:7a2df4c: 	public void testPI() throws SQLException {
1:7a2df4c: 		double value = executeValues("PI");
1:7a2df4c: 		assertEquals(java.lang.StrictMath.PI, value, 0.0);
1:7a2df4c: 		double fValue = executeFn("PI");
1:7a2df4c: 		assertEquals(java.lang.StrictMath.PI, fValue, 0.0);
1:7a2df4c: 
1:7a2df4c: 		try {
1:7a2df4c: 			executeValues("PI", 2.0);
1:7a2df4c: 			fail("PI: Out of range test failed, input value is: " + 2.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// '<statement>' is not recognized as a function or procedure.
1:7a2df4c: 			assertSQLState("42Y03", sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:7a2df4c: 			executeFn("PI", 2.0);
1:7a2df4c: 			fail("PI: Out of range test failed, input value is: " + 2.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// '<statement>' is not recognized as a function or procedure.
1:7a2df4c: 			assertSQLState("42Y03", sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the DEGREES function which converts a DOUBLE PRECISION number from
1:7a2df4c: 	 * radians to degrees.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The input is an angle measured in radians, which is converted to an
1:7a2df4c: 	 * approximately equivalent angle measured in degrees.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The conversion from radians to degrees is not exact. You should not
1:7a2df4c: 	 * expect that the COS(DEGREES(PI/2)) to exactly equal 0.0.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testDegrees() throws SQLException {
1:7a2df4c: 		executeNullValues("DEGREES");
1:7a2df4c: 		executeNullFn("DEGREES");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES DEGREES(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn DEGREES(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testRadians.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.toDegrees(testRadians[i]);
1:b9989a8: 			double rValue = getValue(ps, testRadians[i]);
1:7a2df4c: 			// rValue = executeValues("DEGREES", SMALL_NEG_DOUBLE);
1:7a2df4c: 			debug("DEGREES: input value: " + testRadians[i]
1:7a2df4c: 					+ " expected value: " + expected + " return value: "
1:7a2df4c: 					+ rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testRadians[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.toDegrees(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:c0a5ce1:             // Yields -Infinity, so thould throw.
1:c0a5ce1:             getValue(ps, PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:7a2df4c: 			fail("DEGREES: Out of range test failed, input value is: "
1:c0a5ce1:                    + PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:c0a5ce1:             // Yields -Infinity, so thould throw.
1:c0a5ce1:             getValue(psFN, PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:7a2df4c: 			fail("DEGREES: Out of range test failed, input value is: "
1:c0a5ce1:                    + PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c:         
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:c0a5ce1:     // 2.2250738585072014E-308 remove when we move to compile with source level
1:c0a5ce1:     // Java 6. Cf Double.MIN_NORMAL.
1:c0a5ce1:     final static double DOUBLE_MIN_NORMAL = 2.2250738585072014E-308; 
1:c0a5ce1:     
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the RADIANS function which converts a DOUBLE PRECISION number from
1:7a2df4c: 	 * degrees to radians.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The input is an angle measured in degrees, which is converted to an
1:7a2df4c: 	 * approximately equivalent angle measured in radians.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The conversion from radians to degrees is not exact. You should not
1:7a2df4c: 	 * expect that the COS(RADIANS(90.0)) to exactly equal 0.0.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testRadians() throws SQLException {
1:7a2df4c: 		executeNullValues("RADIANS");
1:7a2df4c: 
1:7a2df4c: 		executeNullFn("RADIANS");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES RADIANS(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn RADIANS(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testArcValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.toRadians(testArcValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testArcValues[i]);
1:7a2df4c: 			debug("RADIANS: input value: " + testArcValues[i]
1:7a2df4c: 					+ " expected value: " + expected + " return value: "
1:7a2df4c: 					+ rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testArcValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.toRadians(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:c0a5ce1:         // Numbers below verified by using lava.lang.StrictMath.toRadians
1:c0a5ce1:         // outside Derby context. First number: argument to ps and psFN, second
1:cf8e7ff:         // number: expected result. Actual results vary by JVM level. See DERBY-6755.
1:c0a5ce1:         double[][] inOut = new double[][] {
1:c0a5ce1:             {180.0d, java.lang.StrictMath.PI},
1:c0a5ce1:             {PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE, -3.1375609430176863E306},
1:c0a5ce1:             {DOUBLE_MIN_NORMAL, 3.8834864931005E-310},
1:c0a5ce1:             {Double.MIN_VALUE, 0.0d},
1:c0a5ce1:             {Double.MAX_VALUE, 3.1375664143845866E306},
1:cf8e7ff:             {PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE, vmAtLeast( 1, 9 ) ? 3.883357585687384E-309 : 3.88335758568738E-309},
1:cf8e7ff:             {PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE, vmAtLeast( 1, 9 ) ? -3.883357585687384E-309 : -3.88335758568738E-309},
1:c0a5ce1:         };
1:c0a5ce1: 
1:c0a5ce1:         for (int i=0; i < inOut.length; i++) {
1:c0a5ce1:             double dv = getValue(ps, inOut[i][0]);
1:c0a5ce1:             assertEquals(inOut[i][1], dv, 0.0d);
1:c0a5ce1:             dv = getValue(psFN, inOut[i][0]);
1:c0a5ce1:             assertEquals(inOut[i][1], dv, 0.0d);
1:c0a5ce1:         }
1:c0a5ce1: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the EXP function which returns e raised to the power of the input
1:7a2df4c: 	 * DOUBLE PRECISION number. The input number is the exponent to raise e to.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The constant e is the base of the natural logarithms.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return value is a DOUBLE PRECISION number.
1:7a2df4c: 	 * 
1:7a2df4c: 	 * @throws SQLException
1:7a2df4c: 	 */
1:7a2df4c: 	public void testExp() throws SQLException {
1:7a2df4c: 		executeNullValues("EXP");
1:7a2df4c: 		executeNullFn("EXP");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES EXP(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn EXP(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testValuesTwo.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.exp(testValuesTwo[i]);
1:b9989a8: 			double rValue = getValue(ps, testValuesTwo[i]);
1:7a2df4c: 			debug("EXP: input value: " + testValuesTwo[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValuesTwo[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.exp(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:c0a5ce1:             getValue(ps, PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:7a2df4c: 			fail("EXP: Out of range test failed, input value is: "
1:c0a5ce1:                    + PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:c0a5ce1:             getValue(psFN, PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:7a2df4c: 			fail("EXP: Out of range test failed, input value is: "
1:c0a5ce1:                    + PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the LOG10 function which returns the base-10 logarithm of a DOUBLE
1:7a2df4c: 	 * PRECISION number that is greater than zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the input value is NULL, the result of this function is NULL.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the input value is zero or a negative number, an exception is returned
1:7a2df4c: 	 * that indicates that the value is out of range (SQL state 22003).
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The return type is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 
1:7a2df4c: 	public void testLog10() throws SQLException {
1:7a2df4c: 		executeNullValues("LOG10");
1:7a2df4c: 		executeNullFn("LOG10");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES LOG10(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn LOG10(?)}");
1:7a2df4c: 		for (int i = 0; i < logValues.length; i++) {
1:584c0fb:             double expected = StrictMath.log10(logValues[i]);
1:b9989a8: 			double rValue = getValue(ps, logValues[i]);
1:7a2df4c: 			debug("LOG10: input value: " + logValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, logValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:584c0fb:             double expect = StrictMath.log10(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, 0.0);
1:7a2df4c: 			fail("LOG10: Out of range test failed, input value is: " + 0.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, -1.0);
1:7a2df4c: 			fail("LOG10: Out of range test failed, input value is: " + -1.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:b9989a8: 			getValue(psFN, 0.0);
1:7a2df4c: 			fail("LOG10: Out of range test failed, input value is: " + 0.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:b9989a8: 			getValue(psFN, -1.0);
1:7a2df4c: 			fail("LOG10: Out of range test failed, input value is: " + -1.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the LOG function which returns the natural logarithm (base e) of a
1:7a2df4c: 	 * DOUBLE PRECISION number that is greater than zero (0).
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the specified number is NULL, the result of these functions is NULL.
1:7a2df4c: 	 * If the specified number is zero or a negative number, an exception is
1:7a2df4c: 	 * returned that indicates that the value is out of range (SQL state 22003).
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testLog() throws SQLException {
1:7a2df4c: 		executeNullValues("LOG");
1:7a2df4c: 		executeNullFn("LOG");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES LOG(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn LOG(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < logValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.log(logValues[i]);
1:b9989a8: 			double rValue = getValue(ps, logValues[i]);
1:7a2df4c: 			debug("LOG: input value: " + logValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, logValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.log(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, 0.0);
1:7a2df4c: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 		try {
1:b9989a8: 			getValue(psFN, 0.0);
1:7a2df4c: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c:         
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the LN function which returns the natural logarithm (base e) of a
1:7a2df4c: 	 * DOUBLE PRECISION number that is greater than zero (0).
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the specified number is NULL, the result of these functions is NULL.
1:7a2df4c: 	 * If the specified number is zero or a negative number, an exception is
1:7a2df4c: 	 * returned that indicates that the value is out of range (SQL state 22003).
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testLn() throws SQLException {
1:7a2df4c: 		executeNullValues("LN");
1:7a2df4c: 		// Note: the syntax 'values {fn ln(value)}' is not supported
1:b9989a8:         // because it is not defined by JDBC.
1:7a2df4c: 		// Object fnVal = executeNullFn("LN");
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES LN(?)");
1:7a2df4c: 		for (int i = 0; i < logValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.log(logValues[i]);
1:b9989a8: 			double rValue = getValue(ps, logValues[i]);
1:7a2df4c: 			debug("LOG: input value: " + logValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.log(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		try {
1:b9989a8: 			getValue(ps, 0.0);
1:7a2df4c: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1:7a2df4c: 		} catch (SQLException sqlE) {
1:7a2df4c: 			// "ERROR 22003: The resulting value is outside the range for the
1:7a2df4c: 			// data type DOUBLE.";
1:7a2df4c: 			assertSQLState(
1:7a2df4c: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1:7a2df4c: 					sqlE);
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the CEIL function which rounds a DOUBLE PRECISION number up, and
1:7a2df4c: 	 * return the smallest number that is greater than or equal to the input
1:7a2df4c: 	 * number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the input number is NULL, the result of these functions is NULL. If
1:7a2df4c: 	 * the input number is equal to a mathematical integer, the result of these
1:7a2df4c: 	 * functions is the same as the input number. If the input number is zero
1:7a2df4c: 	 * (0), the result of these functions is zero. If the input number is less
1:7a2df4c: 	 * than zero but greater than -1.0, then the result of these functions is
1:7a2df4c: 	 * zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The returned value is the smallest (closest to negative infinity) double
1:7a2df4c: 	 * floating point value that is greater than or equal to the specified
1:7a2df4c: 	 * number. The returned value is equal to a mathematical integer.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 
1:7a2df4c: 	public void testCeil() throws SQLException {
1:7a2df4c: 		executeNullValues("CEIL");
1:7a2df4c: 
1:7a2df4c: 		// Note: the syntax 'values {fn CEIL(value)}' is not supported
1:b9989a8:         // because it is not specified by JDBC
1:7a2df4c: 		// Object fnVal = executeNullFn("CEIL");
1:b9989a8: 
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES CEIL(?)");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.ceil(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("CEIL: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.ceil(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the CEILING function which rounds a DOUBLE PRECISION number up, and
1:7a2df4c: 	 * return the smallest number that is greater than or equal to the input
1:7a2df4c: 	 * number.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the input number is NULL, the result of these functions is NULL. If
1:7a2df4c: 	 * the input number is equal to a mathematical integer, the result of these
1:7a2df4c: 	 * functions is the same as the input number. If the input number is zero
1:7a2df4c: 	 * (0), the result of these functions is zero. If the input number is less
1:7a2df4c: 	 * than zero but greater than -1.0, then the result of these functions is
1:7a2df4c: 	 * zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The returned value is the smallest (closest to negative infinity) double
1:7a2df4c: 	 * floating point value that is greater than or equal to the specified
1:7a2df4c: 	 * number. The returned value is equal to a mathematical integer.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 */
1:7a2df4c: 	public void testCeiling() throws SQLException {
1:7a2df4c: 		executeNullValues("CEILING");
1:7a2df4c: 
1:7a2df4c: 		executeNullFn("CEILING");
1:b9989a8:         
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES CEILING(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn CEILING(?)}");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.ceil(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("CEILING: input value: " + testValues[i]
1:7a2df4c: 					+ " expected value: " + expected + " return value: "
1:7a2df4c: 					+ rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.ceil(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:7a2df4c: 
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	/**
1:7a2df4c: 	 * Tests the FLOOR function which rounds the input value which must be a
1:7a2df4c: 	 * DOUBLE PRECISION number down, and returns the largest number that is less
1:7a2df4c: 	 * than or equal to the input value.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * If the input value is NULL, the result of this function is NULL. If the
1:7a2df4c: 	 * input value is equal to a mathematical integer, the result of this
1:7a2df4c: 	 * function is the same as the input number. If the input value is zero (0),
1:7a2df4c: 	 * the result of this function is zero.
1:7a2df4c: 	 * <p>
1:7a2df4c: 	 * The returned value is the largest (closest to positive infinity) double
1:7a2df4c: 	 * floating point value that is less than or equal to the input value. The
1:7a2df4c: 	 * returned value is equal to a mathematical integer. The data type of the
1:7a2df4c: 	 * returned value is a DOUBLE PRECISION number.
1:7a2df4c: 	 * 
1:7a2df4c: 	 * @throws SQLException
1:7a2df4c: 	 */
1:7a2df4c: 
1:7a2df4c: 	public void testFloor() throws SQLException {
1:7a2df4c: 		executeNullValues("FLOOR");
1:7a2df4c: 
1:7a2df4c: 		executeNullFn("FLOOR");
1:7a2df4c: 
1:7a2df4c: 		debug();
1:b9989a8:         PreparedStatement ps =
1:b9989a8:             prepareStatement("VALUES FLOOR(?)");
1:b9989a8:         PreparedStatement psFN =
1:b9989a8:             prepareStatement("VALUES {fn FLOOR(?)}");
1:b9989a8:         
1:7a2df4c: 		for (int i = 0; i < testValues.length; i++) {
1:7a2df4c: 			double expected = java.lang.StrictMath.floor(testValues[i]);
1:b9989a8: 			double rValue = getValue(ps, testValues[i]);
1:7a2df4c: 			debug("FLOOR: input value: " + testValues[i] + " expected value: "
1:7a2df4c: 					+ expected + " return value: " + rValue);
1:7a2df4c: 			assertEquals(expected, rValue, 0.0);
1:b9989a8: 			double fValue = getValue(psFN, testValues[i]);
1:7a2df4c: 			assertEquals(expected, fValue, 0.0);
1:7a2df4c: 		}
1:7a2df4c: 
1:7a2df4c: 		Random rand = new java.util.Random();
1:7a2df4c: 		for (int i = 0; i < 100; i++) {
1:7a2df4c: 			double randD = rand.nextDouble();
1:7a2df4c: 			double expect = java.lang.StrictMath.floor(randD);
1:b9989a8: 			double rVal = getValue(ps, randD);
1:7a2df4c: 			assertEquals(expect, rVal, 0.0);
1:b9989a8: 			double fVal = getValue(psFN, randD);
1:7a2df4c: 			assertEquals(expect, fVal, 0.0);
1:7a2df4c: 
1:7a2df4c: 		}
1:b9989a8:         ps.close();
1:b9989a8:         psFN.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private double executeValues(String functionName) throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values " + functionName + "()");
1:7a2df4c: 		double rValue = 0.0;
3:7a2df4c: 		while (rs.next()) {
1:7a2df4c: 			rValue = rs.getDouble(1);
1:7a2df4c: 		}
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 		return rValue;
1:7a2df4c: 	}
1:b9989a8: 
1:7a2df4c: 	private double executeValues(String functionName, double value)
1:7a2df4c: 			throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values " + functionName + "(" + value
1:7a2df4c: 				+ ")");
1:7a2df4c: 		double rValue = 0.0;
1:7a2df4c: 		while (rs.next()) {
1:7a2df4c: 			rValue = rs.getDouble(1);
1:7a2df4c: 		}
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 		return rValue;
1:7a2df4c: 	}
1:7a2df4c:     
1:b9989a8:     /**
1:b9989a8:      * Execute a prepared statement with a single double argument
1:b9989a8:      * and return the double value from the single row returned.
1:b9989a8:      */
1:b9989a8:     private double getValue(PreparedStatement ps, double value)
1:b9989a8:             throws SQLException {
1:b9989a8:         ps.setDouble(1, value);
1:b9989a8:         ResultSet rs = ps.executeQuery();
1:b9989a8:         rs.next(); // we know a single value will be returned.
1:b9989a8:         double rValue = rs.getDouble(1);
1:b9989a8:         rs.close();
1:b9989a8:         return rValue;
1:b9989a8:     }
1:7a2df4c: 
1:7a2df4c: 	private void executeNullValues(String functionName) throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values " + functionName + "(null)");
1:b9989a8: 		rs.next(); // we know a single value will be returned.
1:b9989a8: 		assertNull(rs.getObject(1));
1:b9989a8: 		assertTrue(rs.wasNull());
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private double executeFn(String functionName) throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values {fn " + functionName + "()}");
1:7a2df4c: 		double rValue = 0.0;
1:7a2df4c: 		while (rs.next()) {
1:7a2df4c: 			rValue = rs.getDouble(1);
1:7a2df4c: 		}
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 		return rValue;
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private double executeFn(String functionName, double value)
1:7a2df4c: 			throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values {fn  " + functionName + "("
1:7a2df4c: 				+ value + ")}");
1:7a2df4c: 		double rValue = 0.0;
1:7a2df4c: 		while (rs.next()) {
1:7a2df4c: 			rValue = rs.getDouble(1);
1:7a2df4c: 		}
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 		return rValue;
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private void executeNullFn(String functionName) throws SQLException {
1:7a2df4c: 		Statement stmt = createStatement();
1:7a2df4c: 		ResultSet rs = stmt.executeQuery("values {fn  " + functionName
1:7a2df4c: 				+ "(null)}");
1:b9989a8:         rs.next(); // we know a single value will be returned.
1:b9989a8:         assertNull(rs.getObject(1));
1:b9989a8:         assertTrue(rs.wasNull());
1:7a2df4c: 		rs.close();
1:7a2df4c: 		stmt.close();
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private void debug(String message) {
1:584c0fb:         println(message);
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	private void debug() {
1:584c0fb:         println("");
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: 	public MathTrigFunctionsTest(String name) {
1:7a2df4c: 		super(name);
1:7a2df4c: 	}
1:7a2df4c: 
1:eba07fc:     /**
1:eba07fc:      * Runs the tests in the embedded and client server configuration
1:eba07fc:      * as the JDBC escape function testing is relevant for both drivers.
1:eba07fc:      */
1:7a2df4c: 	public static Test suite() {
1:eba07fc:         return TestConfiguration.defaultSuite(MathTrigFunctionsTest.class);
1:7a2df4c: 	}
1:7a2df4c: 
1:7a2df4c: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:cf8e7ff
/////////////////////////////////////////////////////////////////////////
1:         // number: expected result. Actual results vary by JVM level. See DERBY-6755.
1:             {PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE, vmAtLeast( 1, 9 ) ? 3.883357585687384E-309 : 3.88335758568738E-309},
1:             {PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE, vmAtLeast( 1, 9 ) ? -3.883357585687384E-309 : -3.88335758568738E-309},
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:584c0fb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:            PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE, 10, 100, 1000, 10000,
1:            100000, 1000000, 10000000, 100000000, 1000000000};
/////////////////////////////////////////////////////////////////////////
1:     public void testCot() throws SQLException {
1:         executeNullValues("COT");
1:         executeNullFn("COT");
1:         debug();
1: 
1:         PreparedStatement ps = prepareStatement("VALUES COT(?)");
1:         PreparedStatement psFN = prepareStatement("VALUES {fn COT(?)}");
1: 
1:         for (double value : testValues) {
1:             checkResult(ps, value, 1.0d / StrictMath.tan(value));
1:         }
1: 
1:         Random rand = new Random();
1:         for (int i = 0; i < 100; i++) {
1:             double randD = rand.nextDouble();
1:             double expected = 1.0d / StrictMath.tan(randD);
1:             checkResult(ps, randD, expected);
1:             checkResult(psFN, randD, expected);
1:         }
1:     }
1: 
1:     private void checkResult(PreparedStatement ps,
1:                              double input, double expected)
1:             throws SQLException {
1: 
1:         // Derby doesn't distinguish between positive and negative zero.
1:         if (expected == -0.0d) {
1:             expected = 0.0d;
1:         }
1: 
1:         ps.setDouble(1, input);
1:         if (Double.isNaN(expected) || Double.isInfinite(expected)) {
1:             debug("input value: " + input + " expected value: " + expected
1:                     + " : OUT OF RANGE");
1:             assertStatementError("22003", ps);
1:         } else {
1:             debug("input value: " + input + " expected value: " + expected);
1:             JDBC.assertSingleValueResultSet(
1:                     ps.executeQuery(), String.valueOf(expected));
1:         }
1:     }
1: 
1:     public void testCosh() throws SQLException {
1:         executeNullValues("COSH");
1:         debug();
1: 
1:         PreparedStatement ps = prepareStatement("VALUES COSH(?)");
1: 
1:         // COSH is not a JDBC escape function. Expect syntax error when
1:         // called as one.
1:         assertCompileError("42X01", "VALUES {fn COSH(?)}");
1: 
1:         for (double value : testValues) {
1:             checkResult(ps, value, StrictMath.cosh(value));
1:         }
1: 
1:         Random rand = new Random();
1:         for (int i = 0; i < 100; i++) {
1:             double randD = rand.nextDouble();
1:             double expect = StrictMath.cosh(randD);
1:             checkResult(ps, randD, expect);
1:         }
1:     }
1: 
1:     public void testSinh() throws SQLException {
1:         executeNullValues("SINH");
1:         debug();
1: 
1:         PreparedStatement ps = prepareStatement("VALUES SINH(?)");
1: 
1:         // SINH is not a JDBC escape function. Expect syntax error when
1:         // called as one.
1:         assertCompileError("42X01", "VALUES {fn SINH(?)}");
1: 
1:         for (double value : testValues) {
1:             checkResult(ps, value, StrictMath.sinh(value));
1:         }
1: 
1:         Random rand = new Random();
1:         for (int i = 0; i < 100; i++) {
1:             double randD = rand.nextDouble();
1:             double expect = StrictMath.sinh(randD);
1:             checkResult(ps, randD, expect);
1:         }
1:     }
1: 
1:     public void testTanh() throws SQLException {
1:         executeNullValues("TANH");
1:         debug();
1: 
1:         PreparedStatement ps = prepareStatement("VALUES TANH(?)");
1: 
1:         // TANH is not a JDBC escape function. Expect syntax error when
1:         // called as one.
1:         assertCompileError("42X01", "VALUES {fn TANH(?)}");
1: 
1:         for (double value : testValues) {
1:             checkResult(ps, value, StrictMath.tanh(value));
1:         }
1: 
1:         Random rand = new Random();
1:         for (int i = 0; i < 100; i++) {
1:             double randD = rand.nextDouble();
1:             double expect = StrictMath.tanh(randD);
1:             checkResult(ps, randD, expect);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             double expected = StrictMath.log10(logValues[i]);
/////////////////////////////////////////////////////////////////////////
1:             double expect = StrictMath.log10(randD);
/////////////////////////////////////////////////////////////////////////
1:         println(message);
1:         println("");
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:c0a5ce1
/////////////////////////////////////////////////////////////////////////
1:    private static final double
1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE = -1.79769E+308;
1:    private static final double
1:             SMALL_NEG_DOUBLE = -1.79768E+308;
1:    private static final double
1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE = 2.225E-307;
1:    private static final double
1:             PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE = 1.79769E+308;
1:    private static final double
1:             PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE = -2.225E-307;
/////////////////////////////////////////////////////////////////////////
1:            45.0, 90.0, 135.0, 180.0, 270, PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
0:            PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE };
1:    private static final double[] testValues = {
1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE,
1:             SMALL_NEG_DOUBLE,
1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
1:             PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE,
1:             PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE,
1:             0.000000001,
1:    private static final double[] testValuesTwo = {
1:             PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE,
1:            SMALL_NEG_DOUBLE,
1:             PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE,
1:            PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE,
1:             0.000000001, -0.000000001, 0.25, -0.25,
/////////////////////////////////////////////////////////////////////////
1:             // Yields -Infinity, so thould throw.
1:             getValue(ps, PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:                    + PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:             // Yields -Infinity, so thould throw.
1:             getValue(psFN, PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
1:                    + PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:     // 2.2250738585072014E-308 remove when we move to compile with source level
1:     // Java 6. Cf Double.MIN_NORMAL.
1:     final static double DOUBLE_MIN_NORMAL = 2.2250738585072014E-308; 
1:     
/////////////////////////////////////////////////////////////////////////
1:         // Numbers below verified by using lava.lang.StrictMath.toRadians
1:         // outside Derby context. First number: argument to ps and psFN, second
0:         // number: expected result.
1:         double[][] inOut = new double[][] {
1:             {180.0d, java.lang.StrictMath.PI},
1:             {PRE_DERBY_3398_SMALLEST_NEG_DERBY_DOUBLE, -3.1375609430176863E306},
1:             {DOUBLE_MIN_NORMAL, 3.8834864931005E-310},
1:             {Double.MIN_VALUE, 0.0d},
1:             {Double.MAX_VALUE, 3.1375664143845866E306},
0:             {PRE_DERBY_3398_SMALLEST_POS_DERBY_DOUBLE, 3.88335758568738E-309},
0:             {PRE_DERBY_3398_LARGEST_NEG_DERBY_DOUBLE, -3.88335758568738E-309},
1:         };
1: 
1:         for (int i=0; i < inOut.length; i++) {
1:             double dv = getValue(ps, inOut[i][0]);
1:             assertEquals(inOut[i][1], dv, 0.0d);
1:             dv = getValue(psFN, inOut[i][0]);
1:             assertEquals(inOut[i][1], dv, 0.0d);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             getValue(ps, PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:                    + PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:             getValue(psFN, PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
1:                    + PRE_DERBY_3398_LARGEST_POS_DERBY_DOUBLE);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b9989a8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:         
1:         PreparedStatement ps =
1:             prepareStatement("VALUES ACOS(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn ACOS(?)}");
1:          
1: 			double rValue = getValue(ps, testArcValues[i]);
1: 			double fValue = getValue(psFN, testArcValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1: 			getValue(ps, 2.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(psFN, 2.0);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES ASIN(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn ASIN(?)}");
1: 
1: 			double rValue = getValue(ps, testArcValues[i]);
1: 			double fValue = getValue(psFN, testArcValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1: 			getValue(ps, 2.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(psFN, 2.0);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES ATAN(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn ATAN(?)}");
1: 
1:         for (int i = 0; i < testValues.length; i++) {
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES COS(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn COS(?)}");
1:         
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES SIN(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn SIN(?)}");
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         
1:         PreparedStatement ps =
1:             prepareStatement("VALUES TAN(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn TAN(?)}");
1:         
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES DEGREES(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn DEGREES(?)}");
1:         
1: 			double rValue = getValue(ps, testRadians[i]);
1: 			double fValue = getValue(psFN, testRadians[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
0: 			getValue(ps, SMALLEST_NEG_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
0: 			getValue(psFN, SMALLEST_NEG_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:         
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES RADIANS(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn RADIANS(?)}");
1:         
1: 			double rValue = getValue(ps, testArcValues[i]);
1: 			double fValue = getValue(psFN, testArcValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
0: 			getValue(ps, SMALLEST_POS_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
0: 			getValue(psFN, SMALLEST_POS_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES EXP(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn EXP(?)}");
1:         
1: 			double rValue = getValue(ps, testValuesTwo[i]);
1: 			double fValue = getValue(psFN, testValuesTwo[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
0: 			getValue(ps, LARGEST_POS_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
0: 			getValue(psFN, LARGEST_POS_DERBY_DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES LOG10(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn LOG10(?)}");
1: 			double rValue = getValue(ps, logValues[i]);
1: 			double fValue = getValue(psFN, logValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1: 			getValue(ps, 0.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(ps, -1.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(psFN, 0.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(psFN, -1.0);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES LOG(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn LOG(?)}");
1:         
1: 			double rValue = getValue(ps, logValues[i]);
1: 			double fValue = getValue(psFN, logValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1: 			getValue(ps, 0.0);
/////////////////////////////////////////////////////////////////////////
1: 			getValue(psFN, 0.0);
/////////////////////////////////////////////////////////////////////////
1:         
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         // because it is not defined by JDBC.
1:         PreparedStatement ps =
1:             prepareStatement("VALUES LN(?)");
1: 			double rValue = getValue(ps, logValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			getValue(ps, 0.0);
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         // because it is not specified by JDBC
1: 
1:         PreparedStatement ps =
1:             prepareStatement("VALUES CEIL(?)");
1:         
1: 			double rValue = getValue(ps, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         
1:         PreparedStatement ps =
1:             prepareStatement("VALUES CEILING(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn CEILING(?)}");
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             prepareStatement("VALUES FLOOR(?)");
1:         PreparedStatement psFN =
1:             prepareStatement("VALUES {fn FLOOR(?)}");
1:         
1: 			double rValue = getValue(ps, testValues[i]);
1: 			double fValue = getValue(psFN, testValues[i]);
/////////////////////////////////////////////////////////////////////////
1: 			double rVal = getValue(ps, randD);
1: 			double fVal = getValue(psFN, randD);
1:         ps.close();
1:         psFN.close();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Execute a prepared statement with a single double argument
1:      * and return the double value from the single row returned.
1:      */
1:     private double getValue(PreparedStatement ps, double value)
1:             throws SQLException {
1:         ps.setDouble(1, value);
1:         ResultSet rs = ps.executeQuery();
1:         rs.next(); // we know a single value will be returned.
1:         double rValue = rs.getDouble(1);
1:         rs.close();
1:         return rValue;
1:     }
1: 		rs.next(); // we know a single value will be returned.
1: 		assertNull(rs.getObject(1));
1: 		assertTrue(rs.wasNull());
/////////////////////////////////////////////////////////////////////////
1:         rs.next(); // we know a single value will be returned.
1:         assertNull(rs.getObject(1));
1:         assertTrue(rs.wasNull());
commit:eba07fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Runs the tests in the embedded and client server configuration
1:      * as the JDBC escape function testing is relevant for both drivers.
0:      * @return
1:      */
1:         return TestConfiguration.defaultSuite(MathTrigFunctionsTest.class);
commit:7a2df4c
/////////////////////////////////////////////////////////////////////////
1: /* Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Random;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
1: public class MathTrigFunctionsTest extends BaseJDBCTestCase {
1: 
0: 	private static final boolean debugFlag = false;
1: 
0: 	private static final double SMALLEST_NEG_DERBY_DOUBLE = -1.79769E+308;
1: 
0: 	private static final double SMALL_NEG_DOUBLE = -1.79768E+308;
1: 
0: 	private static final double SMALLEST_POS_DERBY_DOUBLE = 2.225E-307;
1: 
0: 	private static final double LARGEST_POS_DERBY_DOUBLE = 1.79769E+308;
1: 
0: 	private static final double LARGEST_NEG_DERBY_DOUBLE = -2.225E-307;
1: 
1: 	private static final double[] testRadians = { -0.000000001, -0.25,
1: 			0.000000001, 0.25, 0.5, 0.0, 1.0, 2.0, java.lang.StrictMath.PI,
1: 			java.lang.StrictMath.PI };
1: 
1: 	private static final double[] testArcValues = { 0.000000001, -0.000000001,
1: 			0.25, -0.25, 0.5, 0.0, -0.0, 1.0, -1.0 };
1: 
1: 	private static final double[] logValues = { 0.000000001, 0.25, 0.5, 1.0,
0: 			45.0, 90.0, 135.0, 180.0, 270, SMALLEST_POS_DERBY_DOUBLE,
0: 			LARGEST_POS_DERBY_DOUBLE };
1: 
0: 	private static final double[] testValues = { SMALLEST_NEG_DERBY_DOUBLE,
0: 			SMALL_NEG_DOUBLE, SMALLEST_POS_DERBY_DOUBLE,
0: 			LARGEST_POS_DERBY_DOUBLE, LARGEST_NEG_DERBY_DOUBLE, 0.000000001,
1: 			-0.000000001, 0.25, -0.25, 0.5, 0.0, -0.0, 1.0, -1.0, 2.0, 3.0,
1: 			java.lang.StrictMath.PI, 2 * java.lang.StrictMath.PI, 4.0, 45.0,
1: 			90.0, 135.0, 180.0, 270 };
1: 
0: 	private static final double[] testValuesTwo = { SMALLEST_NEG_DERBY_DOUBLE,
0: 			SMALL_NEG_DOUBLE, SMALLEST_POS_DERBY_DOUBLE,
0: 			LARGEST_NEG_DERBY_DOUBLE, 0.000000001, -0.000000001, 0.25, -0.25,
1: 			0.5, 0.0, -0.0, 1.0, -1.0, 2.0, 3.0, java.lang.StrictMath.PI,
1: 			2 * java.lang.StrictMath.PI, 4.0, 45.0, 90.0, 135.0, 180.0, 270 };
1: 
1: 	/**
1: 	 * Tests the ACOS function which returns the arc cosine of a specified
1: 	 * number.
1: 	 * <p>
1: 	 * Acceptable input values to the ACOS function are DOUBLE PRECISION values
1: 	 * from -1 to 1. NULL returns NULL and if the absolute value of the input is
1: 	 * greater than 1 an SQL state of 22003 is returned.
1: 	 * <p>
1: 	 * The return value from the ACOS function is a DOUBLE PRECISION number in
1: 	 * radians with a range of zero to PI.
1: 	 * 
1: 	 */
1: 	public void testAcos() throws SQLException {
1: 		// test the case where the input value is null
1: 		executeNullValues("ACOS");
1: 		executeNullFn("ACOS");
1: 		debug();
1: 		for (int i = 0; i < testArcValues.length; i++) {
1: 			double expected = java.lang.StrictMath.acos(testArcValues[i]);
0: 			double rValue = executeValues("ACOS", testArcValues[i]);
1: 			debug("ACOS: input value: " + testArcValues[i]
1: 					+ " expected value: " + expected + " return value: "
1: 					+ rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("ACOS", testArcValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 
1: 		}
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.acos(randD);
0: 			double rVal = executeValues("ACOS", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("ACOS", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		/* test the case where the input value is out of range */
1: 		try {
0: 			executeValues("ACOS", 2.0);
1: 			fail("ACOS: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 		/* test the case where the input value is out of range */
1: 		try {
0: 			executeFn("ACOS", 2.0);
1: 			fail("ACOS: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the ASIN function which returns the arc sine of a specified number.
1: 	 * <p>
1: 	 * Acceptable input values to the ASIN function are DOUBLE PRECISION values
1: 	 * from -1 to 1.
1: 	 * <p>
1: 	 * If the specified number is zero (0), the result of this function is zero.
1: 	 * Note: Derby does not support negative zero.
1: 	 * <p>
1: 	 * An input value of NULL returns NULL.
1: 	 * <p>
1: 	 * If the absolute value of the input is greater than 1 an SQL state of
1: 	 * 22003 is returned.
1: 	 * <p>
1: 	 * The return value from the ASIN function is a DOUBLE PRECISION number in
1: 	 * radians with a range of -PI/2 to PI/2.
1: 	 * 
1: 	 */
1: 	public void testAsin() throws SQLException {
1: 		executeNullValues("ASIN");
1: 		executeNullFn("ASIN");
1: 		debug();
1: 		for (int i = 0; i < testArcValues.length; i++) {
1: 			double expected = java.lang.StrictMath.asin(testArcValues[i]);
0: 			double rValue = executeValues("ASIN", testArcValues[i]);
1: 			debug("ASIN: input value: " + testArcValues[i]
1: 					+ " expected value: " + expected + " return value: "
1: 					+ rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("ASIN", testArcValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.asin(randD);
0: 			double rVal = executeValues("ASIN", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("ASIN", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("ASIN", 2.0);
1: 			fail("ASIN: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("ASIN", 2.0);
1: 			fail("ASIN: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the ATAN function which returns the arc tangent of a specified
1: 	 * number. Acceptable input values to the ATAN function are DOUBLE PRECISION
1: 	 * values.
1: 	 * <p>
1: 	 * If the specified number is zero (0), the result of this function is zero.
1: 	 * An input value of NULL returns NULL.
1: 	 * <p>
1: 	 * The return value from the ATAN function is a DOUBLE PRECISION number in
1: 	 * radians with a range of -PI/2 to PI/2.
1: 	 * 
1: 	 */
1: 	public void testAtan() throws SQLException {
1: 		executeNullValues("ATAN");
1: 		executeNullFn("ATAN");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.atan(testValues[i]);
0: 			double rValue = executeValues("ATAN", testValues[i]);
1: 			debug("ATAN: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("ATAN", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.atan(randD);
0: 			double rVal = executeValues("ATAN", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("ATAN", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the COS function which returns the cosine of a specified number.
1: 	 * <p>
1: 	 * Acceptable input values to the COS function are DOUBLE PRECISION values.
1: 	 * <p>
1: 	 * An input value of NULL returns NULL.
1: 	 */
1: 	public void testCos() throws SQLException {
1: 		executeNullValues("COS");
1: 		executeNullFn("COS");
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.cos(testValues[i]);
0: 			double rValue = executeValues("COS", testValues[i]);
1: 			debug("COS: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("COS", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.cos(randD);
0: 			double rVal = executeValues("COS", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("COS", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the SIN function which returns the sine of a specified number.
1: 	 * <p>
1: 	 * Acceptable input values to the SIN function are DOUBLE PRECISION values.
1: 	 * <p>
1: 	 * An input value of NULL returns NULL.
1: 	 * <p>
1: 	 * If the argument is zero, then the result is zero.
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testSin() throws SQLException {
1: 		executeNullValues("SIN");
1: 		executeNullFn("SIN");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.sin(testValues[i]);
0: 			double rValue = executeValues("SIN", testValues[i]);
1: 			debug("SIN: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("SIN", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.sin(randD);
0: 			double rVal = executeValues("SIN", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("SIN", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the TAN function which returns the tangent of a specified number.
1: 	 * <p>
1: 	 * Acceptable input values to the TAN function are DOUBLE PRECISION values.
1: 	 * <p>
1: 	 * An input value of NULL returns NULL.
1: 	 * <p>
1: 	 * If the argument is zero, then the result is zero.
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testTan() throws SQLException {
1: 		executeNullValues("TAN");
1: 
1: 		executeNullFn("TAN");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.tan(testValues[i]);
0: 			double rValue = executeValues("TAN", testValues[i]);
1: 			debug("TAN: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("TAN", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.tan(randD);
0: 			double rVal = executeValues("TAN", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("TAN", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the PI function which returns a value that is closer than any other
1: 	 * value to pi.
1: 	 * <p>
1: 	 * The constant pi is the ratio of the circumference of a circle to the
1: 	 * diameter of a circle.
1: 	 * <p>
1: 	 * No input values are allowed for the PI function.
1: 	 */
1: 
1: 	public void testPI() throws SQLException {
1: 		double value = executeValues("PI");
1: 		assertEquals(java.lang.StrictMath.PI, value, 0.0);
1: 		double fValue = executeFn("PI");
1: 		assertEquals(java.lang.StrictMath.PI, fValue, 0.0);
1: 
1: 		try {
1: 			executeValues("PI", 2.0);
1: 			fail("PI: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// '<statement>' is not recognized as a function or procedure.
1: 			assertSQLState("42Y03", sqlE);
1: 		}
1: 
1: 		try {
1: 			executeFn("PI", 2.0);
1: 			fail("PI: Out of range test failed, input value is: " + 2.0);
1: 		} catch (SQLException sqlE) {
1: 			// '<statement>' is not recognized as a function or procedure.
1: 			assertSQLState("42Y03", sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the DEGREES function which converts a DOUBLE PRECISION number from
1: 	 * radians to degrees.
1: 	 * <p>
1: 	 * The input is an angle measured in radians, which is converted to an
1: 	 * approximately equivalent angle measured in degrees.
1: 	 * <p>
1: 	 * The conversion from radians to degrees is not exact. You should not
1: 	 * expect that the COS(DEGREES(PI/2)) to exactly equal 0.0.
1: 	 * <p>
1: 	 * The return value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testDegrees() throws SQLException {
1: 		executeNullValues("DEGREES");
1: 		executeNullFn("DEGREES");
1: 
1: 		debug();
1: 		for (int i = 0; i < testRadians.length; i++) {
1: 			double expected = java.lang.StrictMath.toDegrees(testRadians[i]);
0: 			double rValue = executeValues("DEGREES", testRadians[i]);
1: 			// rValue = executeValues("DEGREES", SMALL_NEG_DOUBLE);
1: 			debug("DEGREES: input value: " + testRadians[i]
1: 					+ " expected value: " + expected + " return value: "
1: 					+ rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("DEGREES", testRadians[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.toDegrees(randD);
0: 			double rVal = executeValues("DEGREES", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("DEGREES", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("DEGREES", SMALLEST_NEG_DERBY_DOUBLE);
1: 			fail("DEGREES: Out of range test failed, input value is: "
0: 					+ SMALLEST_NEG_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("DEGREES", SMALLEST_NEG_DERBY_DOUBLE);
1: 			fail("DEGREES: Out of range test failed, input value is: "
0: 					+ SMALLEST_NEG_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Tests the RADIANS function which converts a DOUBLE PRECISION number from
1: 	 * degrees to radians.
1: 	 * <p>
1: 	 * The input is an angle measured in degrees, which is converted to an
1: 	 * approximately equivalent angle measured in radians.
1: 	 * <p>
1: 	 * The conversion from radians to degrees is not exact. You should not
1: 	 * expect that the COS(RADIANS(90.0)) to exactly equal 0.0.
1: 	 * <p>
1: 	 * The return value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testRadians() throws SQLException {
1: 		executeNullValues("RADIANS");
1: 
1: 		executeNullFn("RADIANS");
1: 
1: 		debug();
1: 		for (int i = 0; i < testArcValues.length; i++) {
1: 			double expected = java.lang.StrictMath.toRadians(testArcValues[i]);
0: 			double rValue = executeValues("RADIANS", testArcValues[i]);
1: 			debug("RADIANS: input value: " + testArcValues[i]
1: 					+ " expected value: " + expected + " return value: "
1: 					+ rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("RADIANS", testArcValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.toRadians(randD);
0: 			double rVal = executeValues("RADIANS", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("RADIANS", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("RADIANS", SMALLEST_POS_DERBY_DOUBLE);
0: 			fail("RADIANS: Out of range test failed, input value is: "
0: 					+ SMALLEST_NEG_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("RADIANS", SMALLEST_POS_DERBY_DOUBLE);
0: 			fail("RADIANS: Out of range test failed, input value is: "
0: 					+ SMALLEST_NEG_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Tests the EXP function which returns e raised to the power of the input
1: 	 * DOUBLE PRECISION number. The input number is the exponent to raise e to.
1: 	 * <p>
1: 	 * The constant e is the base of the natural logarithms.
1: 	 * <p>
1: 	 * The return value is a DOUBLE PRECISION number.
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void testExp() throws SQLException {
1: 		executeNullValues("EXP");
1: 		executeNullFn("EXP");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValuesTwo.length; i++) {
1: 			double expected = java.lang.StrictMath.exp(testValuesTwo[i]);
0: 			double rValue = executeValues("EXP", testValuesTwo[i]);
1: 			debug("EXP: input value: " + testValuesTwo[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("EXP", testValuesTwo[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.exp(randD);
0: 			double rVal = executeValues("EXP", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("EXP", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("EXP", LARGEST_POS_DERBY_DOUBLE);
1: 			fail("EXP: Out of range test failed, input value is: "
0: 					+ LARGEST_POS_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("EXP", LARGEST_POS_DERBY_DOUBLE);
1: 			fail("EXP: Out of range test failed, input value is: "
0: 					+ LARGEST_POS_DERBY_DOUBLE);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the LOG10 function which returns the base-10 logarithm of a DOUBLE
1: 	 * PRECISION number that is greater than zero.
1: 	 * <p>
1: 	 * If the input value is NULL, the result of this function is NULL.
1: 	 * <p>
1: 	 * If the input value is zero or a negative number, an exception is returned
1: 	 * that indicates that the value is out of range (SQL state 22003).
1: 	 * <p>
1: 	 * The return type is a DOUBLE PRECISION number.
1: 	 */
1: 
1: 	public void testLog10() throws SQLException {
1: 		executeNullValues("LOG10");
1: 		executeNullFn("LOG10");
1: 
1: 		debug();
1: 		for (int i = 0; i < logValues.length; i++) {
0: 			// ln 10 = y * (log base 10 (10))
0: 			// 2.3025850929940456840179914546844 = y * 1
0: 			double expected = java.lang.StrictMath.log(logValues[i]) / 2.3025850929940456840179914546844;
0: 			double rValue = executeValues("LOG10", logValues[i]);
1: 			debug("LOG10: input value: " + logValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("LOG10", logValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
0: 			double expect = java.lang.StrictMath.log(randD) / 2.3025850929940456840179914546844;
0: 			double rVal = executeValues("LOG10", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("LOG10", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("LOG10", 0.0);
1: 			fail("LOG10: Out of range test failed, input value is: " + 0.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeValues("LOG10", -1.0);
1: 			fail("LOG10: Out of range test failed, input value is: " + -1.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 		try {
0: 			executeFn("LOG10", 0.0);
1: 			fail("LOG10: Out of range test failed, input value is: " + 0.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("LOG10", -1.0);
1: 			fail("LOG10: Out of range test failed, input value is: " + -1.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the LOG function which returns the natural logarithm (base e) of a
1: 	 * DOUBLE PRECISION number that is greater than zero (0).
1: 	 * <p>
1: 	 * If the specified number is NULL, the result of these functions is NULL.
1: 	 * If the specified number is zero or a negative number, an exception is
1: 	 * returned that indicates that the value is out of range (SQL state 22003).
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testLog() throws SQLException {
1: 		executeNullValues("LOG");
1: 		executeNullFn("LOG");
1: 
1: 		debug();
1: 		for (int i = 0; i < logValues.length; i++) {
1: 			double expected = java.lang.StrictMath.log(logValues[i]);
0: 			double rValue = executeValues("LOG", logValues[i]);
1: 			debug("LOG: input value: " + logValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("LOG", logValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.log(randD);
0: 			double rVal = executeValues("LOG", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("LOG", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 		try {
0: 			executeValues("LOG", 0.0);
1: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 		try {
0: 			executeFn("LOG", 0.0);
1: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the LN function which returns the natural logarithm (base e) of a
1: 	 * DOUBLE PRECISION number that is greater than zero (0).
1: 	 * <p>
1: 	 * If the specified number is NULL, the result of these functions is NULL.
1: 	 * If the specified number is zero or a negative number, an exception is
1: 	 * returned that indicates that the value is out of range (SQL state 22003).
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testLn() throws SQLException {
1: 		executeNullValues("LN");
1: 		// Note: the syntax 'values {fn ln(value)}' is not supported
1: 		// Object fnVal = executeNullFn("LN");
1: 		debug();
1: 		for (int i = 0; i < logValues.length; i++) {
1: 			double expected = java.lang.StrictMath.log(logValues[i]);
0: 			double rValue = executeValues("LN", logValues[i]);
1: 			debug("LOG: input value: " + logValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.log(randD);
0: 			double rVal = executeValues("LN", randD);
1: 			assertEquals(expect, rVal, 0.0);
1: 		}
1: 
1: 		try {
0: 			executeValues("LN", 0.0);
1: 			fail("LOG: Out of range test failed, input value is: " + 0.0);
1: 		} catch (SQLException sqlE) {
1: 			// "ERROR 22003: The resulting value is outside the range for the
1: 			// data type DOUBLE.";
1: 			assertSQLState(
1: 					SQLStateConstants.DATA_EXCEPTION_NUMERIC_VALUE_OUT_OF_RANGE,
1: 					sqlE);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the CEIL function which rounds a DOUBLE PRECISION number up, and
1: 	 * return the smallest number that is greater than or equal to the input
1: 	 * number.
1: 	 * <p>
1: 	 * If the input number is NULL, the result of these functions is NULL. If
1: 	 * the input number is equal to a mathematical integer, the result of these
1: 	 * functions is the same as the input number. If the input number is zero
1: 	 * (0), the result of these functions is zero. If the input number is less
1: 	 * than zero but greater than -1.0, then the result of these functions is
1: 	 * zero.
1: 	 * <p>
1: 	 * The returned value is the smallest (closest to negative infinity) double
1: 	 * floating point value that is greater than or equal to the specified
1: 	 * number. The returned value is equal to a mathematical integer.
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 
1: 	public void testCeil() throws SQLException {
1: 		executeNullValues("CEIL");
1: 
1: 		// Note: the syntax 'values {fn CEIL(value)}' is not supported
1: 		// Object fnVal = executeNullFn("CEIL");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.ceil(testValues[i]);
0: 			double rValue = executeValues("CEIL", testValues[i]);
1: 			debug("CEIL: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.ceil(randD);
0: 			double rVal = executeValues("CEIL", randD);
1: 			assertEquals(expect, rVal, 0.0);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the CEILING function which rounds a DOUBLE PRECISION number up, and
1: 	 * return the smallest number that is greater than or equal to the input
1: 	 * number.
1: 	 * <p>
1: 	 * If the input number is NULL, the result of these functions is NULL. If
1: 	 * the input number is equal to a mathematical integer, the result of these
1: 	 * functions is the same as the input number. If the input number is zero
1: 	 * (0), the result of these functions is zero. If the input number is less
1: 	 * than zero but greater than -1.0, then the result of these functions is
1: 	 * zero.
1: 	 * <p>
1: 	 * The returned value is the smallest (closest to negative infinity) double
1: 	 * floating point value that is greater than or equal to the specified
1: 	 * number. The returned value is equal to a mathematical integer.
1: 	 * <p>
1: 	 * The data type of the returned value is a DOUBLE PRECISION number.
1: 	 */
1: 	public void testCeiling() throws SQLException {
1: 		executeNullValues("CEILING");
1: 
1: 		executeNullFn("CEILING");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.ceil(testValues[i]);
0: 			double rValue = executeValues("CEILING", testValues[i]);
1: 			debug("CEILING: input value: " + testValues[i]
1: 					+ " expected value: " + expected + " return value: "
1: 					+ rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("CEILING", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.ceil(randD);
0: 			double rVal = executeValues("CEILING", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("CEILING", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tests the FLOOR function which rounds the input value which must be a
1: 	 * DOUBLE PRECISION number down, and returns the largest number that is less
1: 	 * than or equal to the input value.
1: 	 * <p>
1: 	 * If the input value is NULL, the result of this function is NULL. If the
1: 	 * input value is equal to a mathematical integer, the result of this
1: 	 * function is the same as the input number. If the input value is zero (0),
1: 	 * the result of this function is zero.
1: 	 * <p>
1: 	 * The returned value is the largest (closest to positive infinity) double
1: 	 * floating point value that is less than or equal to the input value. The
1: 	 * returned value is equal to a mathematical integer. The data type of the
1: 	 * returned value is a DOUBLE PRECISION number.
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 
1: 	public void testFloor() throws SQLException {
1: 		executeNullValues("FLOOR");
1: 
1: 		executeNullFn("FLOOR");
1: 
1: 		debug();
1: 		for (int i = 0; i < testValues.length; i++) {
1: 			double expected = java.lang.StrictMath.floor(testValues[i]);
0: 			double rValue = executeValues("FLOOR", testValues[i]);
1: 			debug("FLOOR: input value: " + testValues[i] + " expected value: "
1: 					+ expected + " return value: " + rValue);
1: 			assertEquals(expected, rValue, 0.0);
0: 			double fValue = executeFn("FLOOR", testValues[i]);
1: 			assertEquals(expected, fValue, 0.0);
1: 		}
1: 
1: 		Random rand = new java.util.Random();
1: 		for (int i = 0; i < 100; i++) {
1: 			double randD = rand.nextDouble();
1: 			double expect = java.lang.StrictMath.floor(randD);
0: 			double rVal = executeValues("FLOOR", randD);
1: 			assertEquals(expect, rVal, 0.0);
0: 			double fVal = executeFn("FLOOR", randD);
1: 			assertEquals(expect, fVal, 0.0);
1: 
1: 		}
1: 	}
1: 
1: 	private double executeValues(String functionName) throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values " + functionName + "()");
1: 		double rValue = 0.0;
1: 		while (rs.next()) {
1: 			rValue = rs.getDouble(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
1: 		return rValue;
1: 	}
1: 
1: 	private double executeValues(String functionName, double value)
1: 			throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values " + functionName + "(" + value
1: 				+ ")");
1: 		double rValue = 0.0;
1: 		while (rs.next()) {
1: 			rValue = rs.getDouble(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
1: 		return rValue;
1: 	}
1: 
1: 	private void executeNullValues(String functionName) throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values " + functionName + "(null)");
0: 		Object rValue = new Object();
1: 		while (rs.next()) {
0: 			rValue = rs.getObject(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
0: 		assertNull(rValue);
1: 	}
1: 
1: 	private double executeFn(String functionName) throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values {fn " + functionName + "()}");
1: 		double rValue = 0.0;
1: 		while (rs.next()) {
1: 			rValue = rs.getDouble(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
1: 		return rValue;
1: 	}
1: 
1: 	private double executeFn(String functionName, double value)
1: 			throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values {fn  " + functionName + "("
1: 				+ value + ")}");
1: 		double rValue = 0.0;
1: 		while (rs.next()) {
1: 			rValue = rs.getDouble(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
1: 		return rValue;
1: 	}
1: 
1: 	private void executeNullFn(String functionName) throws SQLException {
1: 		Statement stmt = createStatement();
1: 		ResultSet rs = stmt.executeQuery("values {fn  " + functionName
1: 				+ "(null)}");
0: 		Object rValue = new Object();
1: 		while (rs.next()) {
0: 			rValue = rs.getObject(1);
1: 		}
1: 		rs.close();
1: 		stmt.close();
0: 		assertNull(rValue);
1: 	}
1: 
1: 	private void debug(String message) {
0: 		if (debugFlag) {
0: 			System.out.println(message);
1: 		}
1: 	}
1: 
1: 	private void debug() {
0: 		if (debugFlag) {
0: 			System.out.println();
1: 		}
1: 	}
1: 
1: 	public MathTrigFunctionsTest(String name) {
1: 		super(name);
1: 	}
1: 
1: 	public static Test suite() {
0: 		TestSuite suite = new TestSuite();
0: 		suite.addTestSuite(MathTrigFunctionsTest.class);
0: 		return suite;
1: 	}
1: 
1: }
============================================================================