1:af3ca91: 
1:0e38470: /*
23:0e38470: 
1:0e38470:    Derby - Class org.apache.derby.jdbc.InternalDriver
1:0e38470: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:0e38470: 
1:0e38470:       http://www.apache.org/licenses/LICENSE-2.0
1:0e38470: 
1:0e38470:    Unless required by applicable law or agreed to in writing, software
1:0e38470:    distributed under the License is distributed on an "AS IS" BASIS,
1:0e38470:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0e38470:    See the License for the specific language governing permissions and
1:0e38470:    limitations under the License.
1:0e38470: 
3:0e38470:  */
1:3bfb5f0: 
1:0e38470: package org.apache.derby.jdbc;
1:af3ca91: 
1:a0dbbd7: import java.security.AccessController;
1:595307e: import java.security.AccessControlException;
1:1ae0d7d: import java.security.PrivilegedExceptionAction;
1:1ae0d7d: import java.security.PrivilegedActionException;
1:595307e: import java.security.Permission;
1:a0dbbd7: import java.security.PrivilegedAction;
1:595307e: import java.sql.CallableStatement;
1:0e38470: import java.sql.Connection;
1:0e38470: import java.sql.DatabaseMetaData;
1:595307e: import java.sql.Driver;
1:595307e: import java.sql.DriverManager;
1:595307e: import java.sql.DriverPropertyInfo;
1:595307e: import java.sql.PreparedStatement;
1:0e38470: import java.sql.SQLException;
1:595307e: import java.sql.SQLFeatureNotSupportedException;
1:595307e: import java.sql.Statement;
1:0e38470: import java.util.Properties;
1:0e38470: import java.util.StringTokenizer;
1:595307e: import java.util.concurrent.Callable;
1:595307e: import java.util.concurrent.ExecutionException;
1:daaa046: import java.util.concurrent.ExecutorService;
1:595307e: import java.util.concurrent.Future;
1:f40e25a: import java.util.concurrent.SynchronousQueue;
1:595307e: import java.util.concurrent.ThreadFactory;
1:f40e25a: import java.util.concurrent.ThreadPoolExecutor;
1:595307e: import java.util.concurrent.TimeUnit;
1:595307e: import java.util.concurrent.TimeoutException;
1:595307e: import java.util.logging.Logger;
1:595307e: import javax.sql.PooledConnection;
1:595307e: import javax.sql.XAConnection;
1:595307e: import org.apache.derby.iapi.error.StandardException;
1:595307e: import org.apache.derby.iapi.jdbc.AuthenticationService;
1:595307e: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1:595307e: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1:595307e: import org.apache.derby.iapi.jdbc.ConnectionContext;
1:595307e: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1:595307e: import org.apache.derby.iapi.reference.Attribute;
1:595307e: import org.apache.derby.iapi.reference.MessageId;
1:595307e: import org.apache.derby.iapi.reference.Module;
1:595307e: import org.apache.derby.iapi.reference.Property;
1:595307e: import org.apache.derby.iapi.reference.SQLState;
1:595307e: import org.apache.derby.iapi.security.SecurityUtil;
1:595307e: import org.apache.derby.iapi.services.context.ContextManager;
1:595307e: import org.apache.derby.iapi.services.context.ContextService;
1:595307e: import org.apache.derby.iapi.services.i18n.MessageService;
1:595307e: import org.apache.derby.iapi.services.io.FormatableProperties;
1:595307e: import org.apache.derby.iapi.services.jmx.ManagementService;
1:595307e: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:595307e: import org.apache.derby.iapi.services.monitor.Monitor;
1:3bfb5f0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:595307e: import org.apache.derby.iapi.sql.ResultSet;
1:595307e: import org.apache.derby.iapi.util.InterruptStatus;
1:595307e: import org.apache.derby.impl.jdbc.*;
1:595307e: import org.apache.derby.mbeans.JDBCMBean;
1:595307e: import org.apache.derby.security.SystemPermission;
1:5a9d458: 
1:3bfb5f0: /**
1:595307e:  * Factory class and API for JDBC objects.
1:595307e:  */
1:595307e: public class InternalDriver implements ModuleControl, Driver {
1:5a9d458:     
1:0e38470: 	private static final Object syncMe = new Object();
1:0e38470: 	private static InternalDriver activeDriver;
1:5a9d458:     
1:5c4e302:     private Object mbean;
1:5c4e302: 
1:0e38470: 	protected boolean active;
1:0e38470: 	private ContextService contextServiceFactory;
1:0e38470: 	private AuthenticationService	authenticationService;
1:0e38470: 
1:a6532d0:     /**
1:a6532d0:      * Tells whether or not {@code AutoloadedDriver} should deregister itself
1:a6532d0:      * on shutdown. This flag is true unless the deregister attribute has been
1:a6532d0:      * set to false by the user (DERBY-2905).
1:a6532d0:      */
1:a6532d0:     private static boolean deregister = true;
1:595307e: 
1:f40e25a:     /**
1:f40e25a:      * <p>
1:f40e25a:      * An executor service used for executing connection attempts when a
1:f40e25a:      * login timeout has been specified.
1:f40e25a:      * </p>
1:f40e25a:      *
1:f40e25a:      * <p>
1:f40e25a:      * DERBY-6107: Core pool size and keep alive timeout should be zero so
1:f40e25a:      * that no threads are cached. By creating a fresh thread each time a
1:f40e25a:      * task is submitted, we make sure that the task will run in a thread
1:f40e25a:      * with the same context class loader as the thread that submitted the
1:f40e25a:      * task. This is important for example when connecting to a database
1:f40e25a:      * using the classpath subsubprotocol, and the database lives in the
1:f40e25a:      * context class loader. If threads are cached, a task may execute in
1:f40e25a:      * a thread that has a different context class loader.
1:f40e25a:      * </p>
1:f40e25a:      */
1:daaa046:     private static final ExecutorService _executorPool =
1:f40e25a:             new ThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS,
1:f40e25a:                 new SynchronousQueue<Runnable>(), new DaemonThreadFactory());
1:a6532d0: 
1:0e38470: 	public static final InternalDriver activeDriver()
6:0e38470: 	{
1:0e38470: 		return activeDriver;
1:595307e: 	}
1:a0dbbd7: 
1:0e38470: 	public InternalDriver() {
1:a0dbbd7: 		contextServiceFactory = getContextService();
1:a0dbbd7: 	}
1:0e38470: 
1:0e38470: 	/*
1:0e38470: 	**	Methods from ModuleControl
1:0e38470: 	*/
1:0e38470: 
1:0e38470: 	public void boot(boolean create, Properties properties) throws StandardException {
1:0e38470: 
1:0e38470: 		synchronized (InternalDriver.syncMe)
1:a0dbbd7: 		{
1:0e38470: 			InternalDriver.activeDriver = this;
1:a6532d0: 		}
1:0e38470: 
1:0e38470: 		active = true;
1:5c4e302:         
1:5c4e302:         mbean = ((ManagementService)
1:56c1dc2:            getSystemModule(Module.JMX)).registerMBean(
1:5c4e302:                    new JDBC(this),
1:5c4e302:                    JDBCMBean.class,
1:5c4e302:                    "type=JDBC");
1:595307e: 
1:595307e:         // Register with the driver manager
1:595307e:         AutoloadedDriver.registerDriverModule(this);
9:0e38470: 	}
1:0e38470: 
1:0e38470: 	public void stop() {
1:0e38470: 
1:0e38470: 		synchronized (InternalDriver.syncMe)
1:a0dbbd7: 		{
1:0e38470: 			InternalDriver.activeDriver = null;
1:0e38470: 		}
1:5c4e302:         
1:5c4e302:         ((ManagementService)
1:56c1dc2:                 getSystemModule(Module.JMX)).unregisterMBean(
1:5c4e302:                         mbean);
1:0e38470: 
1:0e38470: 		active = false;
1:0e38470: 
1:0e38470: 		contextServiceFactory = null;
1:595307e: 
1:595307e:         AutoloadedDriver.unregisterDriverModule();
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	/*
1:0e38470: 	** Methods from java.sql.Driver
1:0e38470: 	*/
1:01c7f83: 	public boolean acceptsURL(String url) throws SQLException
1:01c7f83:     {
1:e3e3ca3: 		return active && embeddedDriverAcceptsURL( url );
1:e3e3ca3: 	}
1:e3e3ca3: 
1:e3e3ca3: 	/*
1:e3e3ca3: 	** This method can be called by AutoloadedDriver so that we
1:e3e3ca3: 	** don't accidentally boot Derby while answering the question "Can
1:e3e3ca3: 	** you handle this URL?"
1:e3e3ca3: 	*/
1:01c7f83: 	public static	boolean embeddedDriverAcceptsURL(String url) throws SQLException
1:01c7f83:     {
1:01c7f83:         if ( url == null )
1:01c7f83:         {
1:01c7f83:             throw Util.generateCsSQLException( SQLState.MALFORMED_URL, "null" );
1:01c7f83:         }
1:01c7f83:         
1:e3e3ca3: 		return
1:aaea357: 		//	need to reject network driver's URL's
1:aaea357: 		!url.startsWith(Attribute.JCC_PROTOCOL) && !url.startsWith(Attribute.DNC_PROTOCOL) &&
1:aaea357: 		(url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
1:0e38470: 				
1:0e38470: 	}
1:0e38470: 
1:25c1e7b: 	public Connection connect( String url, Properties info, int loginTimeoutSeconds )
1:0e38470: 		 throws SQLException 
1:595307e: 	{
1:0e38470: 		if (!acceptsURL(url)) { return null; }
1:af3ca91: 		
1:a0dbbd7:         /**
1:af3ca91:          * If we are below the low memory watermark for obtaining
1:af3ca91:          * a connection, then don't even try. Just throw an exception.
1:af3ca91:          */
1:af3ca91: 		if (EmbedConnection.memoryState.isLowMemory())
1:af3ca91: 		{
1:af3ca91: 			throw EmbedConnection.NO_MEM;
1:af3ca91: 		}
1:af3ca91:         			
1:0e38470: 		/*
1:0e38470: 		** A url "jdbc:default:connection" means get the current
1:0e38470: 		** connection.  From within a method called from JSQL, the
1:0e38470: 		** "current" connection is the one that is running the
1:0e38470: 		** JSQL statement containing the method call.
1:0e38470: 		*/
1:0e38470: 		boolean current = url.equals(Attribute.SQLJ_NESTED);
1:0e38470: 		
1:0e38470: 		/* If jdbc:default:connection, see if user already has a
1:0e38470: 		 * connection. All connection attributes are ignored.
1:0e38470: 		 */
1:0e38470: 		if (current) {
1:0e38470: 
1:0e38470: 			ConnectionContext connContext = getConnectionContext();
1:0e38470: 
1:0e38470: 			if (connContext != null) {
1:0e38470: 						
1:0e38470: 				return connContext.getNestedConnection(false);
1:0e38470: 				
1:0e38470: 			}
1:2c21843: 			// there is no Derby connection, so
1:0e38470: 			// return null, as we are not the driver to handle this
1:0e38470: 			return null;
1:0e38470: 		}
1:0e38470: 
1:0e38470: 		// convert the ;name=value attributes in the URL into
1:0e38470: 		// properties.
1:af3ca91: 		FormatableProperties finfo = null;
1:af3ca91:         
1:0e38470: 		try {
1:595307e:             
1:af3ca91:             finfo = getAttributes(url, info);
1:af3ca91:             info = null; // ensure we don't use this reference directly again.
1:af3ca91: 
1:0e38470: 			/*
1:0e38470: 			** A property "shutdown=true" means shut the system or database down
1:0e38470: 			*/
1:0e38470: 			boolean shutdown = Boolean.valueOf(finfo.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue();
1:0e38470: 			
1:5a9d458: 			if (shutdown) {				
1:0e38470: 				// If we are shutting down the system don't attempt to create
1:0e38470: 				// a connection; but we validate users credentials if we have to.
1:0e38470: 				// In case of datbase shutdown, we ask the database authentication
1:0e38470: 				// service to authenticate the user. If it is a system shutdown,
1:0e38470: 				// then we ask the Driver to do the authentication.
2:0e38470: 				//
1:0e38470: 				if (InternalDriver.getDatabaseName(url, finfo).length() == 0) {
1:0e38470: 					//
1:0e38470: 					// We need to authenticate the user if authentication is
1:0e38470: 					// ON. Note that this is a system shutdown.
1:0e38470: 					// check that we do have a authentication service
1:0e38470: 					// it is _always_ expected.
1:0e38470: 					if (this.getAuthenticationService() == null)
1:0e38470: 						throw Util.generateCsSQLException(
1:0e38470:                         SQLState.LOGIN_FAILED, 
1:0e38470: 						MessageService.getTextMessage(MessageId.AUTH_NO_SERVICE_FOR_SYSTEM));
1:0e38470: 					
1:0e38470: 						
1:0e38470: 					if (!this.getAuthenticationService().authenticate((String) null, finfo)) {
1:0e38470: 
1:0e38470: 						// not a valid user
1:0e38470: 						throw Util.generateCsSQLException(
1:99422a7:                                     SQLState.NET_CONNECT_AUTH_FAILED,
1:99422a7:                                     MessageService.
1:99422a7:                                     getTextMessage(MessageId.AUTH_INVALID));
1:0e38470: 					}
1:0e38470: 
1:57af2a5:                     // DERBY-2905, allow users to provide deregister attribute to 
1:c341df0:                     // leave AutoloadedDriver registered in DriverManager, default
1:c341df0:                     // value is true
1:57af2a5:                     if (finfo.getProperty(Attribute.DEREGISTER_ATTR) != null) {
1:57af2a5:                         boolean deregister = Boolean.valueOf(
1:57af2a5:                                 finfo.getProperty(Attribute.DEREGISTER_ATTR))
1:57af2a5:                                 .booleanValue();
1:a6532d0:                         InternalDriver.setDeregister(deregister);
1:57af2a5:                     }
1:57af2a5: 
1:5a9d458: 					// check for shutdown privileges
1:09c890c: 					// DERBY-3495: uncomment to enable system privileges checks
1:5a9d458: 					//final String user = IdUtil.getUserNameFromURLProps(finfo);
1:09c890c: 					//checkShutdownPrivileges(user);
1:5a9d458: 
1:56c1dc2: 					getMonitor().shutdown();
1:5a9d458: 
1:0e38470: 					throw Util.generateCsSQLException(
1:0e38470:                                          SQLState.CLOUDSCAPE_SYSTEM_SHUTDOWN);
1:0e38470: 				}
1:0e38470: 			}
1:0e38470: 
1:25c1e7b:             EmbedConnection conn;
1:25c1e7b: 			
1:25c1e7b:             if ( loginTimeoutSeconds <= 0 ) { conn = getNewEmbedConnection( url, finfo ); }
1:25c1e7b:             else { conn = timeLogin( url, finfo, loginTimeoutSeconds ); }
1:25c1e7b:             
1:0e38470: 			// if this is not the correct driver a EmbedConnection
1:0e38470: 			// object is returned in the closed state.
1:0e38470: 			if (conn.isClosed()) {
1:0e38470: 				return null;
1:0e38470: 			}
1:0e38470: 
1:0e38470: 			return conn;
1:0e38470: 		}
1:af3ca91: 		catch (OutOfMemoryError noMemory)
1:af3ca91: 		{
1:af3ca91: 			EmbedConnection.memoryState.setLowMemory();
1:af3ca91: 			throw EmbedConnection.NO_MEM;
1:af3ca91: 		}
1:0e38470: 		finally {
1:0e38470: 			// break any link with the user's Properties set.
1:af3ca91:             if (finfo != null)
1:af3ca91: 			    finfo.clearDefaults();
1:0e38470: 		}
1:0e38470: 	}
1:0e38470: 
1:595307e:     /**
1:25c1e7b:      * Enforce the login timeout.
1:25c1e7b:      */
1:e1c9e2b:     private EmbedConnection timeLogin(
1:595307e:             String url, Properties info, int loginTimeoutSeconds)
1:595307e:         throws SQLException
1:595307e:     {
1:595307e:         try {
1:595307e:             LoginCallable callable = new LoginCallable(this, url, info);
1:595307e:             Future<EmbedConnection> task = _executorPool.submit(callable);
1:e1c9e2b:             long now = System.currentTimeMillis();
1:e1c9e2b:             long giveUp = now + loginTimeoutSeconds * 1000L;
1:25c1e7b: 
1:e1c9e2b:             while (now < giveUp) {
1:595307e:                 try {
1:e1c9e2b:                     return task.get(giveUp - now, TimeUnit.MILLISECONDS);
1:595307e:                 } catch (InterruptedException ie) {
1:595307e:                     InterruptStatus.setInterrupted();
1:e1c9e2b:                     now = System.currentTimeMillis();
1:595307e:                     continue;
1:595307e:                 } catch (ExecutionException ee) {
1:595307e:                     throw processException(ee);
1:595307e:                 } catch (TimeoutException te) {
1:595307e:                     throw Util.generateCsSQLException(SQLState.LOGIN_TIMEOUT);
1:595307e:                 }
1:595307e:             }
1:595307e: 
1:595307e:             // Timed out due to interrupts, throw.
1:595307e:             throw Util.generateCsSQLException(SQLState.LOGIN_TIMEOUT);
1:595307e:         } finally {
1:595307e:             InterruptStatus.restoreIntrFlagIfSeen();
1:595307e:         }
1:595307e:     }
1:595307e: 
1:595307e:     /** Process exceptions raised while running a timed login. */
1:595307e:     private SQLException processException(Throwable t) {
1:595307e:         Throwable cause = t.getCause();
1:595307e:         if (cause instanceof SQLException) {
1:595307e:             return (SQLException) cause;
1:595307e:         } else {
1:595307e:             return Util.javaException(t);
1:595307e:         }
1:595307e:     }
1:595307e: 
1:25c1e7b:     /**
1:595307e:      * Thread factory to produce daemon threads which don't block VM shutdown.
1:595307e:      */
1:595307e:     private static final class DaemonThreadFactory implements ThreadFactory {
1:595307e:         public Thread newThread(Runnable r) {
1:595307e:             Thread result = new Thread(r);
1:595307e:             result.setDaemon(true);
1:595307e:             return result;
1:595307e:         }
1:595307e:     }
1:595307e: 
1:595307e:     /**
1:595307e:      * This code is called in a thread which puts time limits on it.
1:595307e:      */
1:595307e:     public static final class LoginCallable implements
1:595307e:             Callable<EmbedConnection> {
1:595307e: 
1:595307e:         private InternalDriver _driver;
1:595307e:         private String _url;
1:595307e:         private Properties _info;
1:595307e: 
1:595307e:         public LoginCallable(InternalDriver driver, String url, Properties info) {
1:595307e:             _driver = driver;
1:595307e:             _url = url;
1:595307e:             _info = info;
1:595307e:         }
1:595307e: 
1:595307e:         public EmbedConnection call() throws SQLException {
1:595307e:             // Erase the state variables after we use them.
1:595307e:             // Might be paranoid but there could be security-sensitive info
1:595307e:             // in here.
1:595307e:             String url = _url;
1:595307e:             Properties info = _info;
1:595307e:             InternalDriver driver = _driver;
1:595307e:             _url = null;
1:595307e:             _info = null;
1:595307e:             _driver = null;
1:595307e: 
1:595307e:             return driver.getNewEmbedConnection(url, info);
1:595307e:         }
1:595307e:     }
1:595307e: 
1:5a9d458:     /**
1:5a9d458:      * Checks for System Privileges.
1:595307e:      *
1:5a9d458:      * @param user The user to be checked for having the permission
1:5a9d458:      * @param perm The permission to be checked
1:5a9d458:      * @throws AccessControlException if permissions are missing
1:5a9d458:      */
1:595307e:     public void checkSystemPrivileges(String user, Permission perm) {
1:595307e:         SecurityUtil.checkUserHasPermission(user, perm);
1:595307e:     }
1:5a9d458: 
1:5a9d458:     /**
1:5a9d458:      * Checks for shutdown System Privileges.
1:5a9d458:      *
1:5a9d458:      * To perform this check the following policy grant is required
1:5a9d458:      * <ul>
1:5a9d458:      * <li> to run the encapsulated test:
1:5a9d458:      *      permission javax.security.auth.AuthPermission "doAsPrivileged";
1:5a9d458:      * </ul>
1:5a9d458:      * or a SQLException will be raised detailing the cause.
1:5a9d458:      * <p>
1:5a9d458:      * In addition, for the test to succeed
1:5a9d458:      * <ul>
1:5a9d458:      * <li> the given user needs to be covered by a grant:
1:5a9d458:      *      principal org.apache.derby.authentication.SystemPrincipal "..." {}
1:5a9d458:      * <li> that lists a shutdown permission:
1:5a9d458:      *      permission org.apache.derby.security.SystemPermission "shutdown";
1:5a9d458:      * </ul>
1:5a9d458:      * or it will fail with a SQLException detailing the cause.
1:5a9d458:      *
1:5a9d458:      * @param user The user to be checked for shutdown privileges
1:5a9d458:      * @throws SQLException if the privileges check fails
1:5a9d458:      */
1:587dfe1:     private void checkShutdownPrivileges(String user) throws SQLException {
1:5a9d458:         // approve action if not running under a security manager
1:5a9d458:         if (System.getSecurityManager() == null) {
1:5a9d458:             return;
1:5a9d458:         }
1:5a9d458: 
1:5a9d458:         // the check
1:5a9d458:         try {
1:5917694:             final Permission sp = new SystemPermission(
1:5917694:                 SystemPermission.ENGINE, SystemPermission.SHUTDOWN);
1:5a9d458:             checkSystemPrivileges(user, sp);
1:5a9d458:         } catch (AccessControlException ace) {
1:5a9d458:             throw Util.generateCsSQLException(
1:5a9d458: 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,
1:5a9d458: 				user, (Object)ace); // overloaded method
1:5a9d458:         } catch (Exception e) {
1:5a9d458:             throw Util.generateCsSQLException(
1:5a9d458: 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,
1:5a9d458: 				user, (Object)e); // overloaded method
1:5a9d458:         }
1:5a9d458:     }
1:5a9d458: 
1:0e38470: 	public int getMajorVersion() {
1:56c1dc2: 		return getMonitor().getEngineVersion().getMajorVersion();
1:0e38470: 	}
1:0e38470: 	
1:0e38470: 	public int getMinorVersion() {
1:56c1dc2: 		return getMonitor().getEngineVersion().getMinorVersion();
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	public boolean jdbcCompliant() {
1:aaea357: 		return true;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	/*
1:0e38470: 	** URL manipulation
1:0e38470: 	*/
1:0e38470: 
1:af3ca91: 	/**
1:0e38470: 		Convert all the attributes in the url into properties and
1:0e38470: 		combine them with the set provided. 
1:0e38470: 		<BR>
1:0e38470: 		If the caller passed in a set of attributes (info != null)
1:0e38470: 		then we set that up as the default of the returned property
1:0e38470: 		set as the user's set. This means we can easily break the link
1:0e38470: 		with the user's set, ensuring that we don't hang onto the users object.
1:0e38470: 		It also means that we don't add our attributes into the user's
1:0e38470: 		own property object.
1:0e38470: 
1:0e38470: 		@exception SQLException thrown if URL form bad
1:0e38470: 	*/
1:0e38470: 	protected FormatableProperties getAttributes(String url, Properties info) 
1:595307e: 		throws SQLException {
1:0e38470: 
1:0e38470: 		// We use FormatableProperties here to take advantage
1:0e38470: 		// of the clearDefaults, method.
1:0e38470: 		FormatableProperties finfo = new FormatableProperties(info);
2:0e38470: 		info = null; // ensure we don't use this reference directly again.
1:0e38470: 
1:0e38470: 
1:0e38470: 		StringTokenizer st = new StringTokenizer(url, ";");
1:0e38470: 		st.nextToken(); // skip the first part of the url
1:0e38470: 
1:0e38470: 		while (st.hasMoreTokens()) {
1:0e38470: 
1:0e38470: 			String v = st.nextToken();
1:0e38470: 
1:0e38470: 			int eqPos = v.indexOf('=');
1:0e38470: 			if (eqPos == -1)
1:0e38470: 				throw Util.generateCsSQLException(
1:0e38470:                                             SQLState.MALFORMED_URL, url);
1:0e38470: 
1:0e38470: 			//if (eqPos != v.lastIndexOf('='))
1:0e38470: 			//	throw Util.malformedURL(url);
1:0e38470: 
1:0e38470: 			finfo.put((v.substring(0, eqPos)).trim(),
1:0e38470: 					 (v.substring(eqPos + 1)).trim()
2:0e38470: 					);
1:595307e: 		}
1:0e38470: 
1:0e38470: 		// now validate any attributes we can
1:0e38470: 		//
1:0e38470: 		// Boolean attributes -
1:0e38470: 		//  dataEncryption,create,createSource,convertToSource,shutdown,upgrade,current
1:0e38470: 
1:0e38470: 
1:0e38470: 		checkBoolean(finfo, Attribute.DATA_ENCRYPTION);
1:0e38470: 		checkBoolean(finfo, Attribute.CREATE_ATTR);
1:0e38470: 		checkBoolean(finfo, Attribute.SHUTDOWN_ATTR);
1:57af2a5:         checkBoolean(finfo, Attribute.DEREGISTER_ATTR);
1:0e38470: 		checkBoolean(finfo, Attribute.UPGRADE_ATTR);
1:0e38470: 
1:0e38470: 		return finfo;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	private static void checkBoolean(Properties set, String attribute) throws SQLException
1:0e38470:     {
1:0e38470:         final String[] booleanChoices = {"true", "false"};
1:0e38470:         checkEnumeration( set, attribute, booleanChoices);
1:0e38470: 	}
1:0e38470: 
1:0e38470: 
1:0e38470: 	private static void checkEnumeration(Properties set, String attribute, String[] choices) throws SQLException
1:0e38470:     {
1:0e38470: 		String value = set.getProperty(attribute);
1:0e38470: 		if (value == null)
1:0e38470: 			return;
1:0e38470: 
1:0e38470:         for( int i = 0; i < choices.length; i++)
1:0e38470:         {
1:0e38470:             if( value.toUpperCase(java.util.Locale.ENGLISH).equals( choices[i].toUpperCase(java.util.Locale.ENGLISH)))
1:0e38470:                 return;
1:0e38470:         }
1:0e38470: 
1:0e38470:         // The attribute value is invalid. Construct a string giving the choices for
1:0e38470:         // display in the error message.
1:0e38470:         String choicesStr = "{";
1:0e38470:         for( int i = 0; i < choices.length; i++)
1:0e38470:         {
1:0e38470:             if( i > 0)
1:0e38470:                 choicesStr += "|";
1:0e38470:             choicesStr += choices[i];
1:0e38470:         }
1:0e38470:         
1:0e38470: 		throw Util.generateCsSQLException(
1:0e38470:                 SQLState.INVALID_ATTRIBUTE, attribute, value, choicesStr + "}");
1:0e38470: 	}
1:0e38470: 
1:0e38470: 
2:0e38470: 	/**
1:0e38470: 		Get the database name from the url.
1:0e38470: 		Copes with three forms
1:0e38470: 
1:0e38470: 		jdbc:derby:dbname
1:0e38470: 		jdbc:derby:dbname;...
1:0e38470: 		jdbc:derby:;subname=dbname
1:0e38470: 
1:0e38470: 		@param url The url being used for the connection
1:0e38470: 		@param info The properties set being used for the connection, must include
1:0e38470: 		the properties derived from the attributes in the url
1:0e38470: 
1:0e38470: 		@return a String containing the database name or an empty string ("") if
1:0e38470: 		no database name is present in the URL.
1:0e38470: 	*/
1:0e38470: 	public static String getDatabaseName(String url, Properties info) {
1:0e38470: 
1:0e38470: 		if (url.equals(Attribute.SQLJ_NESTED))
1:0e38470: 		{
1:0e38470: 			return "";
1:0e38470: 		}	
1:0e38470: 		
1:0e38470: 		// skip the jdbc:derby:
1:0e38470: 		int attributeStart = url.indexOf(';');
1:0e38470: 		String dbname;
1:0e38470: 		if (attributeStart == -1)
1:0e38470: 			dbname = url.substring(Attribute.PROTOCOL.length());
1:a0dbbd7: 		else
1:0e38470: 			dbname = url.substring(Attribute.PROTOCOL.length(), attributeStart);
1:0e38470: 
1:0e38470: 		// For security reasons we rely on here an non-null string being
1:0e38470: 		// taken as the database name, before the databaseName connection
1:0e38470: 		// attribute. Specifically, even if dbname is blank we still we
1:0e38470: 		// to use it rather than the connection attribute, even though
1:0e38470: 		// it will end up, after the trim, as a zero-length string.
1:0e38470: 		// See EmbeddedDataSource.update()
1:0e38470: 
1:0e38470: 		if (dbname.length() == 0) {
1:0e38470: 		    if (info != null)
1:0e38470: 				dbname = info.getProperty(Attribute.DBNAME_ATTR, dbname);
1:0e38470: 		}
1:0e38470: 		// Beetle 4653 - trim database name to remove blanks that might make a difference on finding the database
1:0e38470: 		// on unix platforms
1:0e38470: 		dbname = dbname.trim();
1:0e38470: 
1:0e38470: 		return dbname;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	public final ContextService getContextServiceFactory() {
1:0e38470: 		return contextServiceFactory;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	// returns the authenticationService handle
1:0e38470: 	public AuthenticationService getAuthenticationService() {
1:0e38470: 		//
1:0e38470: 		// If authenticationService handle not cached in yet, then
1:0e38470: 		// ask the monitor to find it for us and set it here in its
1:0e38470: 		// attribute.
1:0e38470: 		//
1:0e38470: 		if (this.authenticationService == null) {
1:0e38470: 			this.authenticationService = (AuthenticationService)
1:56c1dc2: 				findService(AuthenticationService.MODULE,
1:0e38470: 									"authentication"
1:a0dbbd7: 								   );
1:0e38470: 		}
1:0e38470: 
1:0e38470: 		return this.authenticationService;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	/*
1:0e38470: 		Methods to be overloaded in sub-implementations such as
1:0e38470: 		a tracing driver.
1:0e38470: 	 */
1:1ae0d7d:     EmbedConnection getNewEmbedConnection( final String url, final Properties info)
1:1ae0d7d:         throws SQLException
1:1ae0d7d:     {
1:1ae0d7d:         final   InternalDriver  myself = this;
1:1ae0d7d: 
1:1ae0d7d:         try {
1:1ae0d7d:             return AccessController.doPrivileged
1:1ae0d7d:                 (
1:1ae0d7d:                  new PrivilegedExceptionAction<EmbedConnection>()
1:1ae0d7d:                  {
1:1ae0d7d:                      public EmbedConnection run()
1:1ae0d7d:                          throws SQLException
1:1ae0d7d:                      {
1:1ae0d7d:                          return new EmbedConnection(myself, url, info);
1:1ae0d7d:                      }
1:1ae0d7d:                  }
1:1ae0d7d:                  );
1:1ae0d7d:         } catch (PrivilegedActionException pae)
1:1ae0d7d:         {
1:1ae0d7d:             Throwable   cause = pae.getCause();
1:1ae0d7d:             if ( (cause != null) && (cause instanceof SQLException) )
1:1ae0d7d:             {
1:1ae0d7d:                 throw (SQLException) cause;
1:1ae0d7d:             }
1:1ae0d7d:             else
1:1ae0d7d:             {
1:1ae0d7d:                 throw Util.javaException( pae );
1:1ae0d7d:             }
1:1ae0d7d:         }
1:595307e:     }
1:0e38470: 
1:0e38470: 	private ConnectionContext getConnectionContext() {
1:0e38470: 
1:0e38470: 		/*
1:0e38470: 		** The current connection is the one in the current
1:0e38470: 		** connection context, so get the context.
1:0e38470: 		*/
1:0e38470: 		ContextManager	cm = getCurrentContextManager();
1:0e38470: 
1:0e38470: 		ConnectionContext localCC = null;
1:0e38470: 
1:0e38470: 		/*
1:0e38470: 			cm is null the very first time, and whenever
1:0e38470: 			we aren't actually nested.
1:0e38470: 		 */
1:0e38470: 		if (cm != null) {
1:0e38470: 			localCC = (ConnectionContext)
1:0e38470: 				(cm.getContext(ConnectionContext.CONTEXT_ID));
1:0e38470: 		}
1:0e38470: 
1:0e38470: 		return localCC;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	private ContextManager getCurrentContextManager() {
1:0e38470: 		return getContextServiceFactory().getCurrentContextManager();
1:0e38470: 	}
1:0e38470: 
1:0e38470: 
1:0e38470: 	/**
1:0e38470: 		Return true if this driver is active. Package private method.
1:0e38470: 	*/
1:0e38470: 	public boolean isActive() {
1:0e38470: 		return active;
1:0e38470: 	}
1:0e38470: 
1:0e38470: 	/**
1:0e38470:  	 * Get a new nested connection.
1:5a9d458: 	 *
1:0e38470: 	 * @param conn	The EmbedConnection.
1:5a9d458: 	 *
1:0e38470: 	 * @return A nested connection object.
3:0e38470: 	 *
1:0e38470: 	 */
1:595307e:     public Connection getNewNestedConnection(EmbedConnection conn) {
1:595307e:         return new EmbedConnection(conn);
1:595307e:     }
1:0e38470: 
1:0e38470: 	/*
1:0e38470: 	** methods to be overridden by subimplementations wishing to insert
1:0e38470: 	** their classes into the mix.
1:0e38470: 	*/
1:0e38470: 
1:595307e:     public Statement newEmbedStatement(
1:0e38470: 				EmbedConnection conn,
1:0e38470: 				boolean forMetaData,
1:0e38470: 				int resultSetType,
1:0e38470: 				int resultSetConcurrency,
1:595307e:                 int resultSetHoldability)
1:a0dbbd7:     {
1:595307e:         return new EmbedStatement(conn, forMetaData, resultSetType,
1:595307e:                 resultSetConcurrency, resultSetHoldability);
1:595307e:     }
1:595307e: 
1:0e38470: 	/**
1:0e38470: 	 	@exception SQLException if fails to create statement
1:0e38470: 	 */
1:595307e:     public PreparedStatement newEmbedPreparedStatement(
1:0e38470: 				EmbedConnection conn,
1:0e38470: 				String stmt, 
1:0e38470: 				boolean forMetaData, 
1:0e38470: 				int resultSetType,
1:0e38470: 				int resultSetConcurrency,
1:0e38470: 				int resultSetHoldability,
1:0e38470: 				int autoGeneratedKeys,
1:0e38470: 				int[] columnIndexes,
1:0e38470: 				String[] columnNames)
1:595307e:         throws SQLException
1:595307e:     {
1:595307e:         return new EmbedPreparedStatement(conn,
1:595307e:                 stmt, forMetaData, resultSetType, resultSetConcurrency,
1:595307e:                 resultSetHoldability, autoGeneratedKeys, columnIndexes,
1:595307e:                 columnNames);
1:595307e:     }
1:0e38470: 
1:0e38470: 	/**
1:0e38470: 	 	@exception SQLException if fails to create statement
1:0e38470: 	 */
1:595307e:     public CallableStatement newEmbedCallableStatement(
1:0e38470: 				EmbedConnection conn,
1:0e38470: 				String stmt, 
1:0e38470: 				int resultSetType,
1:0e38470: 				int resultSetConcurrency,
2:0e38470: 				int resultSetHoldability)
1:595307e:         throws SQLException
1:595307e:     {
1:595307e:         return new EmbedCallableStatement(conn, stmt, resultSetType,
1:595307e:                 resultSetConcurrency, resultSetHoldability);
1:595307e:     }
1:0e38470: 
1:0e38470: 	/**
1:0e38470: 	 * Return a new java.sql.DatabaseMetaData instance for this implementation.
1:0e38470: 	 	@exception SQLException on failure to create.
1:0e38470: 	 */
1:595307e:     public DatabaseMetaData newEmbedDatabaseMetaData(
1:595307e:             EmbedConnection conn, String dbname) throws SQLException {
1:595307e:         return new EmbedDatabaseMetaData(conn, dbname);
1:595307e:     }
1:0e38470: 
1:0e38470: 	/**
1:0e38470: 	 * Return a new java.sql.ResultSet instance for this implementation.
1:0e38470: 	 * @param conn Owning connection
1:0e38470: 	 * @param results Top level of language result set tree
1:0e38470: 	 * @param forMetaData Is this for meta-data
1:0e38470: 	 * @param statement The statement that is creating the SQL ResultSet
1:0e38470: 	 * @param isAtomic 
1:0e38470: 	 * @return a new java.sql.ResultSet
1:0e38470: 	 * @throws SQLException
1:595307e: 	 */
1:595307e:     public EmbedResultSet newEmbedResultSet(EmbedConnection conn,
1:595307e:             ResultSet results, boolean forMetaData, EmbedStatement statement,
1:595307e:             boolean isAtomic) throws SQLException {
1:595307e:         return new EmbedResultSet(conn, results, forMetaData, statement,
1:595307e:                 isAtomic);
1:595307e:     }
1:0e38470:         
1:595307e:     /**
1:3bfb5f0:      * Returns a new java.sql.ResultSetMetaData for this implementation
1:3bfb5f0:      *
1:3bfb5f0:      * @param columnInfo a ResultColumnDescriptor that stores information
1:3bfb5f0:      *        about the columns in a ResultSet
1:3bfb5f0:      */
1:595307e:     public EmbedResultSetMetaData newEmbedResultSetMetaData(
1:595307e:             ResultColumnDescriptor[] columnInfo) {
1:3bfb5f0:         return new EmbedResultSetMetaData(columnInfo);
1:3bfb5f0:     }
1:595307e: 
1:595307e:     /**
1:595307e:      * Return a new BrokeredConnection for this implementation.
1:595307e:      */
1:595307e:     BrokeredConnection newBrokeredConnection(
1:595307e:             BrokeredConnectionControl control) throws SQLException {
1:595307e:         return new BrokeredConnection(control);
1:595307e:     }
1:595307e: 
1:595307e:     /**
1:595307e:      * Create and return an EmbedPooledConnection from the received instance of
1:595307e:      * EmbeddedDataSource.
1:595307e:      */
1:595307e:     protected PooledConnection getNewPooledConnection(
1:a086620:             BasicEmbeddedDataSource40 eds, String user, String password,
1:595307e:             boolean requestPassword) throws SQLException {
1:99ae840:         return new EmbedPooledConnection(eds, user, password, requestPassword);
1:595307e:     }
1:595307e: 
1:595307e:     /**
1:595307e:      * Create and return an EmbedXAConnection from the received instance of
1:a086620:      * BasicEmbeddedDataSource40.
1:595307e:      */
1:595307e:     protected XAConnection getNewXAConnection(
1:a086620:             BasicEmbeddedDataSource40 eds, ResourceAdapter ra,
1:595307e:             String user, String password, boolean requestPassword)
1:595307e:             throws SQLException {
1:99ae840:         return new EmbedXAConnection(eds, ra, user, password, requestPassword);
1:595307e:     }
1:595307e: 
1:595307e:     private static final String[] BOOLEAN_CHOICES = {"false", "true"};
1:595307e: 
1:595307e:     /**
1:595307e:      * <p>The getPropertyInfo method is intended to allow a generic GUI tool to
1:595307e:      * discover what properties it should prompt a human for in order to get
1:595307e:      * enough information to connect to a database.  Note that depending on
1:595307e:      * the values the human has supplied so far, additional values may become
1:595307e:      * necessary, so it may be necessary to iterate though several calls
1:595307e:      * to getPropertyInfo.
1:595307e:      *
1:595307e:      * @param url The URL of the database to connect to.
1:595307e:      * @param info A proposed list of tag/value pairs that will be sent on
1:595307e:      *          connect open.
1:595307e:      * @return An array of DriverPropertyInfo objects describing possible
1:595307e:      *          properties.  This array may be an empty array if no properties
1:595307e:      *          are required.
1:595307e:      * @exception SQLException if a database-access error occurs.
1:595307e:      */
1:595307e:     public DriverPropertyInfo[] getPropertyInfo(String url, Properties info)
1:595307e:             throws SQLException {
1:595307e: 
1:595307e:         // RESOLVE other properties should be added into this method in the future ...
1:595307e: 
1:595307e:         if (info != null) {
1:595307e:             if (Boolean.valueOf(info.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue()) {
1:595307e: 
1:595307e:                 // no other options possible when shutdown is set to be true
1:595307e:                 return new DriverPropertyInfo[0];
1:595307e:             }
1:595307e:         }
1:595307e: 
1:595307e:         // at this point we have databaseName,
1:595307e: 
1:595307e:         String dbname = InternalDriver.getDatabaseName(url, info);
1:595307e: 
1:595307e:         // convert the ;name=value attributes in the URL into
1:595307e:         // properties.
1:595307e:         FormatableProperties finfo = getAttributes(url, info);
1:595307e:         info = null; // ensure we don't use this reference directly again.
1:595307e:         boolean encryptDB = Boolean.valueOf(finfo.getProperty(Attribute.DATA_ENCRYPTION)).booleanValue();
1:595307e:         String encryptpassword = finfo.getProperty(Attribute.BOOT_PASSWORD);
1:595307e: 
1:595307e:         if (dbname.length() == 0 || (encryptDB && encryptpassword == null)) {
1:595307e: 
1:595307e:             // with no database name we can have shutdown or a database name
1:595307e: 
1:595307e:             // In future, if any new attribute info needs to be included in this
1:595307e:             // method, it just has to be added to either string or boolean or secret array
1:595307e:             // depending on whether it accepts string or boolean or secret(ie passwords) value.
1:595307e: 
1:595307e:             String[][] connStringAttributes = {
1:595307e:                 {Attribute.DBNAME_ATTR, MessageId.CONN_DATABASE_IDENTITY},
1:595307e:                 {Attribute.CRYPTO_PROVIDER, MessageId.CONN_CRYPTO_PROVIDER},
1:595307e:                 {Attribute.CRYPTO_ALGORITHM, MessageId.CONN_CRYPTO_ALGORITHM},
1:595307e:                 {Attribute.CRYPTO_KEY_LENGTH, MessageId.CONN_CRYPTO_KEY_LENGTH},
1:595307e:                 {Attribute.CRYPTO_EXTERNAL_KEY, MessageId.CONN_CRYPTO_EXTERNAL_KEY},
1:595307e:                 {Attribute.TERRITORY, MessageId.CONN_LOCALE},
1:595307e:                 {Attribute.COLLATION, MessageId.CONN_COLLATION},
1:595307e:                 {Attribute.USERNAME_ATTR, MessageId.CONN_USERNAME_ATTR},
1:595307e:                 {Attribute.LOG_DEVICE, MessageId.CONN_LOG_DEVICE},
1:595307e:                 {Attribute.ROLL_FORWARD_RECOVERY_FROM, MessageId.CONN_ROLL_FORWARD_RECOVERY_FROM},
1:595307e:                 {Attribute.CREATE_FROM, MessageId.CONN_CREATE_FROM},
1:595307e:                 {Attribute.RESTORE_FROM, MessageId.CONN_RESTORE_FROM},
1:595307e:             };
1:595307e: 
1:595307e:             String[][] connBooleanAttributes = {
1:595307e:                 {Attribute.SHUTDOWN_ATTR, MessageId.CONN_SHUT_DOWN_CLOUDSCAPE},
1:595307e:                 {Attribute.DEREGISTER_ATTR, MessageId.CONN_DEREGISTER_AUTOLOADEDDRIVER},
1:595307e:                 {Attribute.CREATE_ATTR, MessageId.CONN_CREATE_DATABASE},
1:595307e:                 {Attribute.DATA_ENCRYPTION, MessageId.CONN_DATA_ENCRYPTION},
1:595307e:                 {Attribute.UPGRADE_ATTR, MessageId.CONN_UPGRADE_DATABASE},
1:595307e:                 };
1:595307e: 
1:595307e:             String[][] connStringSecretAttributes = {
1:595307e:                 {Attribute.BOOT_PASSWORD, MessageId.CONN_BOOT_PASSWORD},
1:595307e:                 {Attribute.PASSWORD_ATTR, MessageId.CONN_PASSWORD_ATTR},
1:595307e:                 };
1:595307e: 
1:595307e: 
1:595307e:             DriverPropertyInfo[] optionsNoDB = new  DriverPropertyInfo[connStringAttributes.length+
1:595307e:                                                                       connBooleanAttributes.length+
1:595307e:                                                                       connStringSecretAttributes.length];
1:595307e: 
1:595307e:             int attrIndex = 0;
1:595307e:             for( int i = 0; i < connStringAttributes.length; i++, attrIndex++ )
1:595307e:             {
1:595307e:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringAttributes[i][0],
1:595307e:                                       finfo.getProperty(connStringAttributes[i][0]));
1:595307e:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringAttributes[i][1]);
1:595307e:             }
1:595307e: 
1:56c1dc2:             optionsNoDB[0].choices = getMonitor().getServiceList(Property.DATABASE_MODULE);
1:595307e:             // since database name is not stored in FormatableProperties, we
1:595307e:             // assign here explicitly
1:595307e:             optionsNoDB[0].value = dbname;
1:595307e: 
1:595307e:             for( int i = 0; i < connStringSecretAttributes.length; i++, attrIndex++ )
1:595307e:             {
1:595307e:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringSecretAttributes[i][0],
1:595307e:                                       (finfo.getProperty(connStringSecretAttributes[i][0]) == null? "" : "****"));
1:595307e:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringSecretAttributes[i][1]);
1:595307e:             }
1:595307e: 
1:595307e:             for( int i = 0; i < connBooleanAttributes.length; i++, attrIndex++ )
1:595307e:             {
1:595307e:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connBooleanAttributes[i][0],
1:595307e:                     Boolean.valueOf(finfo == null? "" : finfo.getProperty(connBooleanAttributes[i][0])).toString());
1:595307e:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connBooleanAttributes[i][1]);
1:595307e:                 optionsNoDB[attrIndex].choices = BOOLEAN_CHOICES;
1:595307e:             }
1:595307e: 
1:595307e:             return optionsNoDB;
1:595307e:         }
1:595307e: 
1:595307e:         return new DriverPropertyInfo[0];
1:595307e:     }
1:595307e: 
1:595307e:     public Connection connect(String url, Properties info) throws SQLException {
1:595307e:         return connect(url, info, DriverManager.getLoginTimeout());
1:595307e:     }
1:595307e: 
1:595307e:     ////////////////////////////////////////////////////////////////////
1:595307e:     //
1:595307e:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:595307e:     //
1:595307e:     ////////////////////////////////////////////////////////////////////
1:595307e: 
1:595307e:     public Logger getParentLogger()
1:595307e:             throws SQLFeatureNotSupportedException {
1:595307e:         throw (SQLFeatureNotSupportedException)
1:595307e:                 Util.notImplemented("getParentLogger()");
1:595307e:     }
1:a6532d0: 
1:a6532d0:     /**
1:a6532d0:      * Indicate to {@code AutoloadedDriver} whether it should deregister
1:a6532d0:      * itself on shutdown.
1:a6532d0:      *
1:a6532d0:      * @param deregister whether or not {@code AutoloadedDriver} should
1:a6532d0:      * deregister itself
1:a6532d0:      */
1:a6532d0:     static void setDeregister(boolean deregister) {
1:a6532d0:         InternalDriver.deregister = deregister;
1:a6532d0:     }
1:a6532d0: 
1:a6532d0:     /**
1:a6532d0:      * Check whether {@code AutoloadedDriver} should deregister itself on
1:a6532d0:      * shutdown.
1:a6532d0:      *
1:a6532d0:      * @return the deregister value
1:a6532d0:      */
1:a6532d0:     static boolean getDeregister() {
1:a6532d0:         return InternalDriver.deregister;
1:a0dbbd7:     }
1:25c1e7b: 
1:25c1e7b:     
1:0e38470:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:a0dbbd7:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:56c1dc2: 
1:a0dbbd7:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:0e38470:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged module lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object getSystemModule( final String factoryInterface )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getSystemModule( factoryInterface );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object findService( final String factoryInterface, final String serviceName )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:a0dbbd7:                  {
1:56c1dc2:                      return Monitor.findService( factoryInterface, serviceName );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2:     
1:a0dbbd7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1ae0d7d
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedExceptionAction;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1:     EmbedConnection getNewEmbedConnection( final String url, final Properties info)
1:         throws SQLException
1:     {
1:         final   InternalDriver  myself = this;
1: 
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<EmbedConnection>()
1:                  {
1:                      public EmbedConnection run()
1:                          throws SQLException
1:                      {
1:                          return new EmbedConnection(myself, url, info);
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             Throwable   cause = pae.getCause();
1:             if ( (cause != null) && (cause instanceof SQLException) )
1:             {
1:                 throw (SQLException) cause;
1:             }
1:             else
1:             {
1:                 throw Util.javaException( pae );
1:             }
1:         }
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1:            getSystemModule(Module.JMX)).registerMBean(
/////////////////////////////////////////////////////////////////////////
1:                 getSystemModule(Module.JMX)).unregisterMBean(
/////////////////////////////////////////////////////////////////////////
1: 					getMonitor().shutdown();
/////////////////////////////////////////////////////////////////////////
1: 		return getMonitor().getEngineVersion().getMajorVersion();
1: 		return getMonitor().getEngineVersion().getMinorVersion();
/////////////////////////////////////////////////////////////////////////
1: 				findService(AuthenticationService.MODULE,
/////////////////////////////////////////////////////////////////////////
1:             optionsNoDB[0].choices = getMonitor().getServiceList(Property.DATABASE_MODULE);
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                      return ContextService.getFactory();
1:              }
1:              );
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1:     
1:     /**
1:      * Privileged module lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object getSystemModule( final String factoryInterface )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.getSystemModule( factoryInterface );
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged service lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object findService( final String factoryInterface, final String serviceName )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.findService( factoryInterface, serviceName );
1:                  }
1:              }
1:              );
1:     }
1:     
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 		contextServiceFactory = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
1:         else
1:         {
0:             return AccessController.doPrivileged
0:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: 	public abstract java.sql.Statement newEmbedStatement(
0: 				int resultSetHoldability);
/////////////////////////////////////////////////////////////////////////
0: 	public abstract DatabaseMetaData newEmbedDatabaseMetaData
0:         (EmbedConnection conn, String dbname) throws SQLException;
/////////////////////////////////////////////////////////////////////////
0:         public abstract EmbedResultSetMetaData newEmbedResultSetMetaData
0:             (ResultColumnDescriptor[] columnInfo);
commit:25c1e7b
/////////////////////////////////////////////////////////////////////////
1: 	public Connection connect( String url, Properties info, int loginTimeoutSeconds )
/////////////////////////////////////////////////////////////////////////
1:             EmbedConnection conn;
1: 			
1:             if ( loginTimeoutSeconds <= 0 ) { conn = getNewEmbedConnection( url, finfo ); }
1:             else { conn = timeLogin( url, finfo, loginTimeoutSeconds ); }
1:             
/////////////////////////////////////////////////////////////////////////
1:      * Enforce the login timeout.
1:      */
0:     protected abstract EmbedConnection  timeLogin( String url, Properties info, int loginTimeoutSeconds )
0:         throws SQLException;
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
1: 	public boolean acceptsURL(String url) throws SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 	public static	boolean embeddedDriverAcceptsURL(String url) throws SQLException
1:     {
1:         if ( url == null )
1:         {
1:             throw Util.generateCsSQLException( SQLState.MALFORMED_URL, "null" );
1:         }
1:         
commit:213d360
/////////////////////////////////////////////////////////////////////////
commit:09c890c
/////////////////////////////////////////////////////////////////////////
1: 					// DERBY-3495: uncomment to enable system privileges checks
1: 					//checkShutdownPrivileges(user);
/////////////////////////////////////////////////////////////////////////
0:     abstract public void checkSystemPrivileges(String user,
commit:e3e3ca3
/////////////////////////////////////////////////////////////////////////
1: 		return active && embeddedDriverAcceptsURL( url );
1: 	}
1: 
1: 	/*
1: 	** This method can be called by AutoloadedDriver so that we
1: 	** don't accidentally boot Derby while answering the question "Can
1: 	** you handle this URL?"
1: 	*/
0: 	public static	boolean embeddedDriverAcceptsURL(String url) {
1: 		return
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Returns a new java.sql.ResultSetMetaData for this implementation
1:          *
1:          * @param columnInfo a ResultColumnDescriptor that stores information 
1:          *        about the columns in a ResultSet
1:          */
0:         public EmbedResultSetMetaData newEmbedResultSetMetaData
0:                            (ResultColumnDescriptor[] columnInfo) {
1:             return new EmbedResultSetMetaData(columnInfo);
1:         }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a086620
/////////////////////////////////////////////////////////////////////////
1:             BasicEmbeddedDataSource40 eds, String user, String password,
1:      * BasicEmbeddedDataSource40.
1:             BasicEmbeddedDataSource40 eds, ResourceAdapter ra,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f40e25a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.ThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * An executor service used for executing connection attempts when a
1:      * login timeout has been specified.
1:      * </p>
1:      *
1:      * <p>
1:      * DERBY-6107: Core pool size and keep alive timeout should be zero so
1:      * that no threads are cached. By creating a fresh thread each time a
1:      * task is submitted, we make sure that the task will run in a thread
1:      * with the same context class loader as the thread that submitted the
1:      * task. This is important for example when connecting to a database
1:      * using the classpath subsubprotocol, and the database lives in the
1:      * context class loader. If threads are cached, a task may execute in
1:      * a thread that has a different context class loader.
1:      * </p>
1:      */
1:             new ThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS,
1:                 new SynchronousQueue<Runnable>(), new DaemonThreadFactory());
commit:e1c9e2b
/////////////////////////////////////////////////////////////////////////
1:     private EmbedConnection timeLogin(
1:             long now = System.currentTimeMillis();
1:             long giveUp = now + loginTimeoutSeconds * 1000L;
1:             while (now < giveUp) {
1:                     return task.get(giveUp - now, TimeUnit.MILLISECONDS);
1:                     now = System.currentTimeMillis();
commit:daaa046
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
/////////////////////////////////////////////////////////////////////////
1:     private static final ExecutorService _executorPool =
0:             Executors.newCachedThreadPool(new DaemonThreadFactory());
commit:99ae840
/////////////////////////////////////////////////////////////////////////
1:         return new EmbedPooledConnection(eds, user, password, requestPassword);
/////////////////////////////////////////////////////////////////////////
1:         return new EmbedXAConnection(eds, ra, user, password, requestPassword);
commit:595307e
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessControlException;
1: import java.security.Permission;
1: import java.sql.CallableStatement;
1: import java.sql.Driver;
1: import java.sql.DriverManager;
1: import java.sql.DriverPropertyInfo;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.Statement;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.Future;
0: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
1: import java.util.logging.Logger;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.reference.Module;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.security.SecurityUtil;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.FormatableProperties;
1: import org.apache.derby.iapi.services.jmx.ManagementService;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.util.InterruptStatus;
1: import org.apache.derby.impl.jdbc.*;
1: import org.apache.derby.mbeans.JDBCMBean;
1: import org.apache.derby.security.SystemPermission;
1:  * Factory class and API for JDBC objects.
1:  */
1: public class InternalDriver implements ModuleControl, Driver {
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadPoolExecutor _executorPool =
0:             new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
0:                                    new SynchronousQueue<Runnable>());
0:     static {
0:         _executorPool.setThreadFactory(new DaemonThreadFactory());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Register with the driver manager
1:         AutoloadedDriver.registerDriverModule(this);
/////////////////////////////////////////////////////////////////////////
1: 
1:         AutoloadedDriver.unregisterDriverModule();
/////////////////////////////////////////////////////////////////////////
0:     EmbedConnection timeLogin(
1:             String url, Properties info, int loginTimeoutSeconds)
1:         throws SQLException
1:     {
1:         try {
1:             LoginCallable callable = new LoginCallable(this, url, info);
1:             Future<EmbedConnection> task = _executorPool.submit(callable);
0:             long startTime = System.currentTimeMillis();
0:             long interruptedTime = startTime;
1: 
0:             while ((startTime - interruptedTime) / 1000.0
0:                         < loginTimeoutSeconds) {
1:                 try {
0:                     return task.get(loginTimeoutSeconds, TimeUnit.SECONDS);
1:                 } catch (InterruptedException ie) {
0:                     interruptedTime = System.currentTimeMillis();
1:                     InterruptStatus.setInterrupted();
1:                     continue;
1:                 } catch (ExecutionException ee) {
1:                     throw processException(ee);
1:                 } catch (TimeoutException te) {
1:                     throw Util.generateCsSQLException(SQLState.LOGIN_TIMEOUT);
1:                 }
1:             }
1: 
1:             // Timed out due to interrupts, throw.
1:             throw Util.generateCsSQLException(SQLState.LOGIN_TIMEOUT);
1:         } finally {
1:             InterruptStatus.restoreIntrFlagIfSeen();
1:         }
1:     }
1: 
1:     /** Process exceptions raised while running a timed login. */
1:     private SQLException processException(Throwable t) {
1:         Throwable cause = t.getCause();
1:         if (cause instanceof SQLException) {
1:             return (SQLException) cause;
1:         } else {
1:             return Util.javaException(t);
1:         }
1:     }
1: 
1:     /**
1:      * Thread factory to produce daemon threads which don't block VM shutdown.
1:      */
1:     private static final class DaemonThreadFactory implements ThreadFactory {
1:         public Thread newThread(Runnable r) {
1:             Thread result = new Thread(r);
1:             result.setDaemon(true);
1:             return result;
1:         }
1:     }
1: 
1:     /**
1:      * This code is called in a thread which puts time limits on it.
1:      */
1:     public static final class LoginCallable implements
1:             Callable<EmbedConnection> {
1: 
1:         private InternalDriver _driver;
1:         private String _url;
1:         private Properties _info;
1: 
1:         public LoginCallable(InternalDriver driver, String url, Properties info) {
1:             _driver = driver;
1:             _url = url;
1:             _info = info;
1:         }
1: 
1:         public EmbedConnection call() throws SQLException {
1:             // Erase the state variables after we use them.
1:             // Might be paranoid but there could be security-sensitive info
1:             // in here.
1:             String url = _url;
1:             Properties info = _info;
1:             InternalDriver driver = _driver;
1:             _url = null;
1:             _info = null;
1:             _driver = null;
1: 
1:             return driver.getNewEmbedConnection(url, info);
1:         }
1:     }
1: 
1:     public void checkSystemPrivileges(String user, Permission perm) {
1:         SecurityUtil.checkUserHasPermission(user, perm);
1:     }
/////////////////////////////////////////////////////////////////////////
0:     EmbedConnection getNewEmbedConnection(String url, Properties info)
1:             throws SQLException {
0:         return new EmbedConnection(this, url, info);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public Connection getNewNestedConnection(EmbedConnection conn) {
1:         return new EmbedConnection(conn);
1:     }
1:     public Statement newEmbedStatement(
1:                 int resultSetHoldability)
1:     {
1:         return new EmbedStatement(conn, forMetaData, resultSetType,
1:                 resultSetConcurrency, resultSetHoldability);
1:     }
1: 
1:     public PreparedStatement newEmbedPreparedStatement(
/////////////////////////////////////////////////////////////////////////
1:         throws SQLException
1:     {
1:         return new EmbedPreparedStatement(conn,
1:                 stmt, forMetaData, resultSetType, resultSetConcurrency,
1:                 resultSetHoldability, autoGeneratedKeys, columnIndexes,
1:                 columnNames);
1:     }
1:     public CallableStatement newEmbedCallableStatement(
1:         throws SQLException
1:     {
1:         return new EmbedCallableStatement(conn, stmt, resultSetType,
1:                 resultSetConcurrency, resultSetHoldability);
1:     }
1:     public DatabaseMetaData newEmbedDatabaseMetaData(
1:             EmbedConnection conn, String dbname) throws SQLException {
1:         return new EmbedDatabaseMetaData(conn, dbname);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public EmbedResultSet newEmbedResultSet(EmbedConnection conn,
1:             ResultSet results, boolean forMetaData, EmbedStatement statement,
1:             boolean isAtomic) throws SQLException {
1:         return new EmbedResultSet(conn, results, forMetaData, statement,
1:                 isAtomic);
1:     }
1:     /**
0:      * Returns a new java.sql.ResultSetMetaData for this implementation
1:      *
0:      * @param columnInfo a ResultColumnDescriptor that stores information
0:      *        about the columns in a ResultSet
1:      */
1:     public EmbedResultSetMetaData newEmbedResultSetMetaData(
1:             ResultColumnDescriptor[] columnInfo) {
0:         return new EmbedResultSetMetaData(columnInfo);
1:     }
1: 
1:     /**
1:      * Return a new BrokeredConnection for this implementation.
1:      */
1:     BrokeredConnection newBrokeredConnection(
1:             BrokeredConnectionControl control) throws SQLException {
1:         return new BrokeredConnection(control);
1:     }
1: 
1:     /**
1:      * Create and return an EmbedPooledConnection from the received instance of
1:      * EmbeddedDataSource.
1:      */
1:     protected PooledConnection getNewPooledConnection(
0:             EmbeddedBaseDataSource eds, String user, String password,
1:             boolean requestPassword) throws SQLException {
0:         return new EmbedPooledConnection40(
0:                 eds, user, password, requestPassword);
1:     }
1: 
1:     /**
1:      * Create and return an EmbedXAConnection from the received instance of
0:      * EmbeddedBaseDataSource.
1:      */
1:     protected XAConnection getNewXAConnection(
0:             EmbeddedBaseDataSource eds, ResourceAdapter ra,
1:             String user, String password, boolean requestPassword)
1:             throws SQLException {
0:         return new EmbedXAConnection40(
0:                 eds, ra, user, password, requestPassword);
1:     }
1: 
1:     private static final String[] BOOLEAN_CHOICES = {"false", "true"};
1: 
1:     /**
1:      * <p>The getPropertyInfo method is intended to allow a generic GUI tool to
1:      * discover what properties it should prompt a human for in order to get
1:      * enough information to connect to a database.  Note that depending on
1:      * the values the human has supplied so far, additional values may become
1:      * necessary, so it may be necessary to iterate though several calls
1:      * to getPropertyInfo.
1:      *
1:      * @param url The URL of the database to connect to.
1:      * @param info A proposed list of tag/value pairs that will be sent on
1:      *          connect open.
1:      * @return An array of DriverPropertyInfo objects describing possible
1:      *          properties.  This array may be an empty array if no properties
1:      *          are required.
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public DriverPropertyInfo[] getPropertyInfo(String url, Properties info)
1:             throws SQLException {
1: 
1:         // RESOLVE other properties should be added into this method in the future ...
1: 
1:         if (info != null) {
1:             if (Boolean.valueOf(info.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue()) {
1: 
1:                 // no other options possible when shutdown is set to be true
1:                 return new DriverPropertyInfo[0];
1:             }
1:         }
1: 
1:         // at this point we have databaseName,
1: 
1:         String dbname = InternalDriver.getDatabaseName(url, info);
1: 
1:         // convert the ;name=value attributes in the URL into
1:         // properties.
1:         FormatableProperties finfo = getAttributes(url, info);
1:         info = null; // ensure we don't use this reference directly again.
1:         boolean encryptDB = Boolean.valueOf(finfo.getProperty(Attribute.DATA_ENCRYPTION)).booleanValue();
1:         String encryptpassword = finfo.getProperty(Attribute.BOOT_PASSWORD);
1: 
1:         if (dbname.length() == 0 || (encryptDB && encryptpassword == null)) {
1: 
1:             // with no database name we can have shutdown or a database name
1: 
1:             // In future, if any new attribute info needs to be included in this
1:             // method, it just has to be added to either string or boolean or secret array
1:             // depending on whether it accepts string or boolean or secret(ie passwords) value.
1: 
1:             String[][] connStringAttributes = {
1:                 {Attribute.DBNAME_ATTR, MessageId.CONN_DATABASE_IDENTITY},
1:                 {Attribute.CRYPTO_PROVIDER, MessageId.CONN_CRYPTO_PROVIDER},
1:                 {Attribute.CRYPTO_ALGORITHM, MessageId.CONN_CRYPTO_ALGORITHM},
1:                 {Attribute.CRYPTO_KEY_LENGTH, MessageId.CONN_CRYPTO_KEY_LENGTH},
1:                 {Attribute.CRYPTO_EXTERNAL_KEY, MessageId.CONN_CRYPTO_EXTERNAL_KEY},
1:                 {Attribute.TERRITORY, MessageId.CONN_LOCALE},
1:                 {Attribute.COLLATION, MessageId.CONN_COLLATION},
1:                 {Attribute.USERNAME_ATTR, MessageId.CONN_USERNAME_ATTR},
1:                 {Attribute.LOG_DEVICE, MessageId.CONN_LOG_DEVICE},
1:                 {Attribute.ROLL_FORWARD_RECOVERY_FROM, MessageId.CONN_ROLL_FORWARD_RECOVERY_FROM},
1:                 {Attribute.CREATE_FROM, MessageId.CONN_CREATE_FROM},
1:                 {Attribute.RESTORE_FROM, MessageId.CONN_RESTORE_FROM},
1:             };
1: 
1:             String[][] connBooleanAttributes = {
1:                 {Attribute.SHUTDOWN_ATTR, MessageId.CONN_SHUT_DOWN_CLOUDSCAPE},
1:                 {Attribute.DEREGISTER_ATTR, MessageId.CONN_DEREGISTER_AUTOLOADEDDRIVER},
1:                 {Attribute.CREATE_ATTR, MessageId.CONN_CREATE_DATABASE},
1:                 {Attribute.DATA_ENCRYPTION, MessageId.CONN_DATA_ENCRYPTION},
1:                 {Attribute.UPGRADE_ATTR, MessageId.CONN_UPGRADE_DATABASE},
1:                 };
1: 
1:             String[][] connStringSecretAttributes = {
1:                 {Attribute.BOOT_PASSWORD, MessageId.CONN_BOOT_PASSWORD},
1:                 {Attribute.PASSWORD_ATTR, MessageId.CONN_PASSWORD_ATTR},
1:                 };
1: 
1: 
1:             DriverPropertyInfo[] optionsNoDB = new  DriverPropertyInfo[connStringAttributes.length+
1:                                                                       connBooleanAttributes.length+
1:                                                                       connStringSecretAttributes.length];
1: 
1:             int attrIndex = 0;
1:             for( int i = 0; i < connStringAttributes.length; i++, attrIndex++ )
1:             {
1:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringAttributes[i][0],
1:                                       finfo.getProperty(connStringAttributes[i][0]));
1:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringAttributes[i][1]);
1:             }
1: 
0:             optionsNoDB[0].choices = Monitor.getMonitor().getServiceList(Property.DATABASE_MODULE);
1:             // since database name is not stored in FormatableProperties, we
1:             // assign here explicitly
1:             optionsNoDB[0].value = dbname;
1: 
1:             for( int i = 0; i < connStringSecretAttributes.length; i++, attrIndex++ )
1:             {
1:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connStringSecretAttributes[i][0],
1:                                       (finfo.getProperty(connStringSecretAttributes[i][0]) == null? "" : "****"));
1:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connStringSecretAttributes[i][1]);
1:             }
1: 
1:             for( int i = 0; i < connBooleanAttributes.length; i++, attrIndex++ )
1:             {
1:                 optionsNoDB[attrIndex] = new DriverPropertyInfo(connBooleanAttributes[i][0],
1:                     Boolean.valueOf(finfo == null? "" : finfo.getProperty(connBooleanAttributes[i][0])).toString());
1:                 optionsNoDB[attrIndex].description = MessageService.getTextMessage(connBooleanAttributes[i][1]);
1:                 optionsNoDB[attrIndex].choices = BOOLEAN_CHOICES;
1:             }
1: 
1:             return optionsNoDB;
1:         }
1: 
1:         return new DriverPropertyInfo[0];
1:     }
1: 
1:     public Connection connect(String url, Properties info) throws SQLException {
1:         return connect(url, info, DriverManager.getLoginTimeout());
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public Logger getParentLogger()
1:             throws SQLFeatureNotSupportedException {
1:         throw (SQLFeatureNotSupportedException)
1:                 Util.notImplemented("getParentLogger()");
1:     }
commit:a6532d0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells whether or not {@code AutoloadedDriver} should deregister itself
1:      * on shutdown. This flag is true unless the deregister attribute has been
1:      * set to false by the user (DERBY-2905).
1:      */
1:     private static boolean deregister = true;
1: 
/////////////////////////////////////////////////////////////////////////
1:                         InternalDriver.setDeregister(deregister);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Indicate to {@code AutoloadedDriver} whether it should deregister
1:      * itself on shutdown.
1:      *
1:      * @param deregister whether or not {@code AutoloadedDriver} should
1:      * deregister itself
1:      */
1:     static void setDeregister(boolean deregister) {
1:         InternalDriver.deregister = deregister;
1:     }
1: 
1:     /**
1:      * Check whether {@code AutoloadedDriver} should deregister itself on
1:      * shutdown.
1:      *
1:      * @return the deregister value
1:      */
1:     static boolean getDeregister() {
1:         return InternalDriver.deregister;
1:     }
author:Lily Wei
-------------------------------------------------------------------------------
commit:c341df0
/////////////////////////////////////////////////////////////////////////
1:                     // leave AutoloadedDriver registered in DriverManager, default
1:                     // value is true
commit:57af2a5
/////////////////////////////////////////////////////////////////////////
1:                     // DERBY-2905, allow users to provide deregister attribute to 
0:                     // left AutoloadedDriver in DriverManager, default value is true
1:                     if (finfo.getProperty(Attribute.DEREGISTER_ATTR) != null) {
1:                         boolean deregister = Boolean.valueOf(
1:                                 finfo.getProperty(Attribute.DEREGISTER_ATTR))
1:                                 .booleanValue();
0:                         AutoloadedDriver.setDeregister(deregister);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         checkBoolean(finfo, Attribute.DEREGISTER_ATTR);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:5917694
/////////////////////////////////////////////////////////////////////////
1:             final Permission sp = new SystemPermission(
1:                 SystemPermission.ENGINE, SystemPermission.SHUTDOWN);
commit:587dfe1
/////////////////////////////////////////////////////////////////////////
0:     abstract void checkSystemPrivileges(String user,
/////////////////////////////////////////////////////////////////////////
1:     private void checkShutdownPrivileges(String user) throws SQLException {
commit:5a9d458
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.security.SystemPermission;
1: 
/////////////////////////////////////////////////////////////////////////
0: import java.security.Permission;
0: import java.security.AccessControlException;
1: 
0: import org.apache.derby.iapi.util.IdUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			if (shutdown) {				
/////////////////////////////////////////////////////////////////////////
1: 					// check for shutdown privileges
0:                     // Disabled until more of the patch can be applied.
1: 					//final String user = IdUtil.getUserNameFromURLProps(finfo);
0:                     //checkShutdownPrivileges(user);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks for System Privileges.
1:      *
0:      * Abstract since some of the javax security classes are not available
0:      * on all platforms.
1:      *
1:      * @param user The user to be checked for having the permission
1:      * @param perm The permission to be checked
1:      * @throws AccessControlException if permissions are missing
0:      * @throws Exception if the privileges check fails for some other reason
1:      */
0:     abstract public void checkSystemPrivileges(String user,
0:                                                Permission perm)
0:         throws Exception;
1: 
1:     /**
1:      * Checks for shutdown System Privileges.
1:      *
1:      * To perform this check the following policy grant is required
1:      * <ul>
1:      * <li> to run the encapsulated test:
1:      *      permission javax.security.auth.AuthPermission "doAsPrivileged";
1:      * </ul>
1:      * or a SQLException will be raised detailing the cause.
1:      * <p>
1:      * In addition, for the test to succeed
1:      * <ul>
1:      * <li> the given user needs to be covered by a grant:
1:      *      principal org.apache.derby.authentication.SystemPrincipal "..." {}
1:      * <li> that lists a shutdown permission:
1:      *      permission org.apache.derby.security.SystemPermission "shutdown";
1:      * </ul>
1:      * or it will fail with a SQLException detailing the cause.
1:      *
1:      * @param user The user to be checked for shutdown privileges
1:      * @throws SQLException if the privileges check fails
1:      */
0:     public void checkShutdownPrivileges(String user) throws SQLException {
1:         // approve action if not running under a security manager
1:         if (System.getSecurityManager() == null) {
1:             return;
1:         }
1: 
1:         // the check
1:         try {
0:             final Permission sp
0:                 = new SystemPermission(SystemPermission.SHUTDOWN);
1:             checkSystemPrivileges(user, sp);
1:         } catch (AccessControlException ace) {
1:             throw Util.generateCsSQLException(
1: 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,
1: 				user, (Object)ace); // overloaded method
1:         } catch (Exception e) {
1:             throw Util.generateCsSQLException(
1: 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,
1: 				user, (Object)e); // overloaded method
1:         }
1:     }
1: 
commit:f8bc019
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Module;
/////////////////////////////////////////////////////////////////////////
0:            Monitor.getSystemModule(Module.JMX)).registerMBean(
/////////////////////////////////////////////////////////////////////////
0:                 Monitor.getSystemModule(Module.JMX)).unregisterMBean(
commit:5c4e302
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.jmx.ManagementService;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.mbeans.JDBCMBean;
/////////////////////////////////////////////////////////////////////////
1:     
1:     private Object mbean;
/////////////////////////////////////////////////////////////////////////
1:         
1:         mbean = ((ManagementService)
0:            Monitor.getSystemModule(ManagementService.MODULE)).registerMBean(
1:                    new JDBC(this),
1:                    JDBCMBean.class,
1:                    "type=JDBC");
/////////////////////////////////////////////////////////////////////////
1:         
1:         ((ManagementService)
0:                 Monitor.getSystemModule(ManagementService.MODULE)).unregisterMBean(
1:                         mbean);
commit:af3ca91
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 		
1:         /**
1:          * If we are below the low memory watermark for obtaining
1:          * a connection, then don't even try. Just throw an exception.
1:          */
1: 		if (EmbedConnection.memoryState.isLowMemory())
1: 		{
1: 			throw EmbedConnection.NO_MEM;
1: 		}
1:         			
/////////////////////////////////////////////////////////////////////////
1: 		FormatableProperties finfo = null;
1:         
1:             
1:             finfo = getAttributes(url, info);
1:             info = null; // ensure we don't use this reference directly again.
/////////////////////////////////////////////////////////////////////////
1: 		catch (OutOfMemoryError noMemory)
1: 		{
1: 			EmbedConnection.memoryState.setLowMemory();
1: 			throw EmbedConnection.NO_MEM;
1: 		}
1:             if (finfo != null)
1: 			    finfo.clearDefaults();
commit:0e38470
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.jdbc.InternalDriver
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.jdbc;
1: 
0: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
1: 
0: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: 
0: import org.apache.derby.impl.jdbc.*;
1: 
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.SQLException;
1: 
1: import java.util.Properties;
1: import java.util.StringTokenizer;
1: 
1: 
1: /**
0: 	Abstract factory class and api for JDBC objects.
0: 	@author djd
1: */
1: 
0: public abstract class InternalDriver implements ModuleControl {
1: 
1: 	private static final Object syncMe = new Object();
1: 	private static InternalDriver activeDriver;
1: 
1: 	protected boolean active;
1: 	private ContextService contextServiceFactory;
1: 	private AuthenticationService	authenticationService;
1: 
1: 	public static final InternalDriver activeDriver()
1: 	{
1: 		return activeDriver;
1: 	}
1: 
1: 	public InternalDriver() {
0: 		contextServiceFactory = ContextService.getFactory();
1: 	}
1: 
1: 	/*
1: 	**	Methods from ModuleControl
1: 	*/
1: 
1: 	public void boot(boolean create, Properties properties) throws StandardException {
1: 
1: 		synchronized (InternalDriver.syncMe)
1: 		{
1: 			InternalDriver.activeDriver = this;
1: 		}
1: 
1: 		active = true;
1: 	}
1: 
1: 	public void stop() {
1: 
1: 		synchronized (InternalDriver.syncMe)
1: 		{
1: 			InternalDriver.activeDriver = null;
1: 		}
1: 
1: 		active = false;
1: 
1: 		contextServiceFactory = null;
1: 	}
1: 
1: 	/*
1: 	** Methods from java.sql.Driver
1: 	*/
0: 	public boolean acceptsURL(String url) {
0: 		return active && (url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
1: 	}
1: 
0: 	public Connection connect(String url, Properties info)
1: 		 throws SQLException 
1: 	{
1: 		if (!acceptsURL(url)) { return null; }
1: 
1: 			
1: 		/*
1: 		** A url "jdbc:default:connection" means get the current
1: 		** connection.  From within a method called from JSQL, the
1: 		** "current" connection is the one that is running the
1: 		** JSQL statement containing the method call.
1: 		*/
1: 		boolean current = url.equals(Attribute.SQLJ_NESTED);
1: 		
1: 		/* If jdbc:default:connection, see if user already has a
1: 		 * connection. All connection attributes are ignored.
1: 		 */
1: 		if (current) {
1: 
1: 			ConnectionContext connContext = getConnectionContext();
1: 
1: 			if (connContext != null) {
1: 						
1: 				return connContext.getNestedConnection(false);
1: 				
1: 			}
0: 			// there is no cloudscape connection, so
1: 			// return null, as we are not the driver to handle this
1: 			return null;
1: 		}
1: 
1: 		// convert the ;name=value attributes in the URL into
1: 		// properties.
0: 		FormatableProperties finfo = getAttributes(url, info);
1: 		info = null; // ensure we don't use this reference directly again.
1: 		try {
1: 
1: 			/*
1: 			** A property "shutdown=true" means shut the system or database down
1: 			*/
1: 			boolean shutdown = Boolean.valueOf(finfo.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue();
1: 			
0: 			if (shutdown) {
1: 				
1: 				// If we are shutting down the system don't attempt to create
1: 				// a connection; but we validate users credentials if we have to.
1: 				// In case of datbase shutdown, we ask the database authentication
1: 				// service to authenticate the user. If it is a system shutdown,
1: 				// then we ask the Driver to do the authentication.
1: 				//
1: 				if (InternalDriver.getDatabaseName(url, finfo).length() == 0) {
1: 					//
1: 					// We need to authenticate the user if authentication is
1: 					// ON. Note that this is a system shutdown.
1: 					// check that we do have a authentication service
1: 					// it is _always_ expected.
1: 					if (this.getAuthenticationService() == null)
1: 						throw Util.generateCsSQLException(
1:                         SQLState.LOGIN_FAILED, 
1: 						MessageService.getTextMessage(MessageId.AUTH_NO_SERVICE_FOR_SYSTEM));
1: 					
1: 						
1: 					if (!this.getAuthenticationService().authenticate((String) null, finfo)) {
1: 
1: 						// not a valid user
1: 						throw Util.generateCsSQLException(
0:                                   SQLState.LOGIN_FAILED, MessageService.getTextMessage(MessageId.AUTH_INVALID));
1: 					}
1: 
0: 					Monitor.getMonitor().shutdown();
1: 					throw Util.generateCsSQLException(
1:                                          SQLState.CLOUDSCAPE_SYSTEM_SHUTDOWN);
1: 				}
1: 			}
1: 			
0: 			EmbedConnection conn = getNewEmbedConnection(url, finfo);
1: 
1: 			// if this is not the correct driver a EmbedConnection
1: 			// object is returned in the closed state.
1: 			if (conn.isClosed()) {
1: 				return null;
1: 			}
1: 
1: 			return conn;
1: 		}
1: 		finally {
1: 			// break any link with the user's Properties set.
0: 			finfo.clearDefaults();
1: 		}
1: 	}
1: 
1: 	public int getMajorVersion() {
0: 		return Monitor.getMonitor().getEngineVersion().getMajorVersion();
1: 	}
1: 	
1: 	public int getMinorVersion() {
0: 		return Monitor.getMonitor().getEngineVersion().getMinorVersion();
1: 	}
1: 
1: 	public boolean jdbcCompliant() {
0: 		return false;
1: 	}
1: 
1: 	/*
1: 	** URL manipulation
1: 	*/
1: 
1: 	/**
1: 		Convert all the attributes in the url into properties and
1: 		combine them with the set provided. 
1: 		<BR>
1: 		If the caller passed in a set of attributes (info != null)
1: 		then we set that up as the default of the returned property
1: 		set as the user's set. This means we can easily break the link
1: 		with the user's set, ensuring that we don't hang onto the users object.
1: 		It also means that we don't add our attributes into the user's
1: 		own property object.
1: 
1: 		@exception SQLException thrown if URL form bad
1: 	*/
1: 	protected FormatableProperties getAttributes(String url, Properties info) 
0: 		throws SQLException {
1: 
1: 		// We use FormatableProperties here to take advantage
1: 		// of the clearDefaults, method.
1: 		FormatableProperties finfo = new FormatableProperties(info);
1: 		info = null; // ensure we don't use this reference directly again.
1: 
1: 
1: 		StringTokenizer st = new StringTokenizer(url, ";");
1: 		st.nextToken(); // skip the first part of the url
1: 
1: 		while (st.hasMoreTokens()) {
1: 
1: 			String v = st.nextToken();
1: 
1: 			int eqPos = v.indexOf('=');
1: 			if (eqPos == -1)
1: 				throw Util.generateCsSQLException(
1:                                             SQLState.MALFORMED_URL, url);
1: 
1: 			//if (eqPos != v.lastIndexOf('='))
1: 			//	throw Util.malformedURL(url);
1: 
1: 			finfo.put((v.substring(0, eqPos)).trim(),
1: 					 (v.substring(eqPos + 1)).trim()
1: 					);
1: 		}
1: 
1: 		// now validate any attributes we can
1: 		//
1: 		// Boolean attributes -
1: 		//  dataEncryption,create,createSource,convertToSource,shutdown,upgrade,current
1: 
1: 
1: 		checkBoolean(finfo, Attribute.DATA_ENCRYPTION);
1: 		checkBoolean(finfo, Attribute.CREATE_ATTR);
1: 		checkBoolean(finfo, Attribute.SHUTDOWN_ATTR);
1: 		checkBoolean(finfo, Attribute.UPGRADE_ATTR);
1: 
1: 		return finfo;
1: 	}
1: 
1: 	private static void checkBoolean(Properties set, String attribute) throws SQLException
1:     {
1:         final String[] booleanChoices = {"true", "false"};
1:         checkEnumeration( set, attribute, booleanChoices);
1: 	}
1: 
1: 
1: 	private static void checkEnumeration(Properties set, String attribute, String[] choices) throws SQLException
1:     {
1: 		String value = set.getProperty(attribute);
1: 		if (value == null)
1: 			return;
1: 
1:         for( int i = 0; i < choices.length; i++)
1:         {
1:             if( value.toUpperCase(java.util.Locale.ENGLISH).equals( choices[i].toUpperCase(java.util.Locale.ENGLISH)))
1:                 return;
1:         }
1: 
1:         // The attribute value is invalid. Construct a string giving the choices for
1:         // display in the error message.
1:         String choicesStr = "{";
1:         for( int i = 0; i < choices.length; i++)
1:         {
1:             if( i > 0)
1:                 choicesStr += "|";
1:             choicesStr += choices[i];
1:         }
1:         
1: 		throw Util.generateCsSQLException(
1:                 SQLState.INVALID_ATTRIBUTE, attribute, value, choicesStr + "}");
1: 	}
1: 
1: 
1: 	/**
1: 		Get the database name from the url.
1: 		Copes with three forms
1: 
1: 		jdbc:derby:dbname
1: 		jdbc:derby:dbname;...
1: 		jdbc:derby:;subname=dbname
1: 
1: 		@param url The url being used for the connection
1: 		@param info The properties set being used for the connection, must include
1: 		the properties derived from the attributes in the url
1: 
1: 		@return a String containing the database name or an empty string ("") if
1: 		no database name is present in the URL.
1: 	*/
1: 	public static String getDatabaseName(String url, Properties info) {
1: 
1: 		if (url.equals(Attribute.SQLJ_NESTED))
1: 		{
1: 			return "";
1: 		}	
1: 		
1: 		// skip the jdbc:derby:
1: 		int attributeStart = url.indexOf(';');
1: 		String dbname;
1: 		if (attributeStart == -1)
1: 			dbname = url.substring(Attribute.PROTOCOL.length());
0: 		else
1: 			dbname = url.substring(Attribute.PROTOCOL.length(), attributeStart);
1: 
1: 		// For security reasons we rely on here an non-null string being
1: 		// taken as the database name, before the databaseName connection
1: 		// attribute. Specifically, even if dbname is blank we still we
1: 		// to use it rather than the connection attribute, even though
1: 		// it will end up, after the trim, as a zero-length string.
1: 		// See EmbeddedDataSource.update()
1: 
1: 		if (dbname.length() == 0) {
1: 		    if (info != null)
1: 				dbname = info.getProperty(Attribute.DBNAME_ATTR, dbname);
1: 		}
1: 		// Beetle 4653 - trim database name to remove blanks that might make a difference on finding the database
1: 		// on unix platforms
1: 		dbname = dbname.trim();
1: 
1: 		return dbname;
1: 	}
1: 
1: 	public final ContextService getContextServiceFactory() {
1: 		return contextServiceFactory;
1: 	}
1: 
1: 	// returns the authenticationService handle
1: 	public AuthenticationService getAuthenticationService() {
1: 		//
1: 		// If authenticationService handle not cached in yet, then
1: 		// ask the monitor to find it for us and set it here in its
1: 		// attribute.
1: 		//
1: 		if (this.authenticationService == null) {
1: 			this.authenticationService = (AuthenticationService)
0: 				Monitor.findService(AuthenticationService.MODULE,
1: 									"authentication"
1: 								   );
1: 		}
1: 
0: 		// We should have a Authentication Service (always)
1: 		//
0: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(this.authenticationService != null, 
0: 				"Unexpected - There is no valid authentication service!");
1: 		}
1: 		return this.authenticationService;
1: 	}
1: 
1: 	/*
1: 		Methods to be overloaded in sub-implementations such as
1: 		a tracing driver.
1: 	 */
0: 	protected abstract EmbedConnection getNewEmbedConnection(String url, Properties info) 
0: 		 throws SQLException ;
1: 
1: 
1: 	private ConnectionContext getConnectionContext() {
1: 
1: 		/*
1: 		** The current connection is the one in the current
1: 		** connection context, so get the context.
1: 		*/
1: 		ContextManager	cm = getCurrentContextManager();
1: 
1: 		ConnectionContext localCC = null;
1: 
1: 		/*
1: 			cm is null the very first time, and whenever
1: 			we aren't actually nested.
1: 		 */
1: 		if (cm != null) {
1: 			localCC = (ConnectionContext)
1: 				(cm.getContext(ConnectionContext.CONTEXT_ID));
1: 		}
1: 
1: 		return localCC;
1: 	}
1: 
1: 	private ContextManager getCurrentContextManager() {
1: 		return getContextServiceFactory().getCurrentContextManager();
1: 	}
1: 
1: 
1: 	/**
1: 		Return true if this driver is active. Package private method.
1: 	*/
1: 	public boolean isActive() {
1: 		return active;
1: 	}
1: 
1: 	/**
1:  	 * Get a new nested connection.
1: 	 *
1: 	 * @param conn	The EmbedConnection.
1: 	 *
1: 	 * @return A nested connection object.
1: 	 *
1: 	 */
0: 	public abstract Connection getNewNestedConnection(EmbedConnection conn);
1: 
1: 	/*
1: 	** methods to be overridden by subimplementations wishing to insert
1: 	** their classes into the mix.
1: 	*/
1: 
0: 	public java.sql.Statement newEmbedStatement(
1: 				EmbedConnection conn,
1: 				boolean forMetaData,
1: 				int resultSetType,
1: 				int resultSetConcurrency,
1: 				int resultSetHoldability)
1: 	{
0: 		return new EmbedStatement(conn, forMetaData, resultSetType, resultSetConcurrency,
0: 		resultSetHoldability);
1: 	}
1: 	/**
1: 	 	@exception SQLException if fails to create statement
1: 	 */
0: 	public abstract java.sql.PreparedStatement newEmbedPreparedStatement(
1: 				EmbedConnection conn,
1: 				String stmt, 
1: 				boolean forMetaData, 
1: 				int resultSetType,
1: 				int resultSetConcurrency,
1: 				int resultSetHoldability,
1: 				int autoGeneratedKeys,
1: 				int[] columnIndexes,
1: 				String[] columnNames)
0: 		throws SQLException;
1: 
1: 	/**
1: 	 	@exception SQLException if fails to create statement
1: 	 */
0: 	public abstract java.sql.CallableStatement newEmbedCallableStatement(
1: 				EmbedConnection conn,
1: 				String stmt, 
1: 				int resultSetType,
1: 				int resultSetConcurrency,
1: 				int resultSetHoldability)
0: 		throws SQLException;
1: 
1: 	/**
1: 	 * Return a new java.sql.DatabaseMetaData instance for this implementation.
1: 	 	@exception SQLException on failure to create.
1: 	 */
0: 	public DatabaseMetaData newEmbedDatabaseMetaData(EmbedConnection conn,
0: 		String dbname) throws SQLException {
0: 		return new EmbedDatabaseMetaData(conn,dbname);
1: 	}
1: 
1: 	/**
1: 	 * Return a new java.sql.ResultSet instance for this implementation.
1: 	 * @param conn Owning connection
1: 	 * @param results Top level of language result set tree
1: 	 * @param forMetaData Is this for meta-data
1: 	 * @param statement The statement that is creating the SQL ResultSet
1: 	 * @param isAtomic 
1: 	 * @return a new java.sql.ResultSet
1: 	 * @throws SQLException
1: 	 */
0: 	public abstract EmbedResultSet
0: 		newEmbedResultSet(EmbedConnection conn, ResultSet results, boolean forMetaData, EmbedStatement statement, boolean isAtomic) throws SQLException;
1: }
1: 
1: 
1: 
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:99422a7
/////////////////////////////////////////////////////////////////////////
1:                                     SQLState.NET_CONNECT_AUTH_FAILED,
1:                                     MessageService.
1:                                     getTextMessage(MessageId.AUTH_INVALID));
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2c21843
/////////////////////////////////////////////////////////////////////////
1: 			// there is no Derby connection, so
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.jdbc.InternalDriver
0: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derby.jdbc;
0: 
0: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
0: 
0: import org.apache.derby.iapi.jdbc.ConnectionContext;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
0: 
0: import org.apache.derby.impl.jdbc.*;
0: 
0: import java.sql.Connection;
0: import java.sql.DatabaseMetaData;
0: import java.sql.SQLException;
0: 
0: import java.util.Properties;
0: import java.util.StringTokenizer;
0: 
0: 
0: /**
0: 	Abstract factory class and api for JDBC objects.
0: 	@author djd
0: */
0: 
0: public abstract class InternalDriver implements ModuleControl {
0: 
0: 	private static final Object syncMe = new Object();
0: 	private static InternalDriver activeDriver;
0: 
0: 	protected boolean active;
0: 	private ContextService contextServiceFactory;
0: 	private AuthenticationService	authenticationService;
0: 
0: 	public static final InternalDriver activeDriver()
0: 	{
0: 		return activeDriver;
0: 	}
0: 
0: 	public InternalDriver() {
0: 		contextServiceFactory = ContextService.getFactory();
0: 	}
0: 
0: 	/*
0: 	**	Methods from ModuleControl
0: 	*/
0: 
0: 	public void boot(boolean create, Properties properties) throws StandardException {
0: 
0: 		synchronized (InternalDriver.syncMe)
0: 		{
0: 			InternalDriver.activeDriver = this;
0: 		}
0: 
0: 		active = true;
0: 	}
0: 
0: 	public void stop() {
0: 
0: 		synchronized (InternalDriver.syncMe)
0: 		{
0: 			InternalDriver.activeDriver = null;
0: 		}
0: 
0: 		active = false;
0: 
0: 		contextServiceFactory = null;
0: 	}
0: 
0: 	/*
0: 	** Methods from java.sql.Driver
0: 	*/
0: 	public boolean acceptsURL(String url) {
0: 		return active &&
1: 		//	need to reject network driver's URL's
1: 		!url.startsWith(Attribute.JCC_PROTOCOL) && !url.startsWith(Attribute.DNC_PROTOCOL) &&
1: 		(url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
0: 				
0: 	}
0: 
0: 	public Connection connect(String url, Properties info)
0: 		 throws SQLException 
0: 	{
0: 		if (!acceptsURL(url)) { return null; }
0: 
0: 			
0: 		/*
0: 		** A url "jdbc:default:connection" means get the current
0: 		** connection.  From within a method called from JSQL, the
0: 		** "current" connection is the one that is running the
0: 		** JSQL statement containing the method call.
0: 		*/
0: 		boolean current = url.equals(Attribute.SQLJ_NESTED);
0: 		
0: 		/* If jdbc:default:connection, see if user already has a
0: 		 * connection. All connection attributes are ignored.
0: 		 */
0: 		if (current) {
0: 
0: 			ConnectionContext connContext = getConnectionContext();
0: 
0: 			if (connContext != null) {
0: 						
0: 				return connContext.getNestedConnection(false);
0: 				
0: 			}
0: 			// there is no cloudscape connection, so
0: 			// return null, as we are not the driver to handle this
0: 			return null;
0: 		}
0: 
0: 		// convert the ;name=value attributes in the URL into
0: 		// properties.
0: 		FormatableProperties finfo = getAttributes(url, info);
0: 		info = null; // ensure we don't use this reference directly again.
0: 		try {
0: 
0: 			/*
0: 			** A property "shutdown=true" means shut the system or database down
0: 			*/
0: 			boolean shutdown = Boolean.valueOf(finfo.getProperty(Attribute.SHUTDOWN_ATTR)).booleanValue();
0: 			
0: 			if (shutdown) {
0: 				
0: 				// If we are shutting down the system don't attempt to create
0: 				// a connection; but we validate users credentials if we have to.
0: 				// In case of datbase shutdown, we ask the database authentication
0: 				// service to authenticate the user. If it is a system shutdown,
0: 				// then we ask the Driver to do the authentication.
0: 				//
0: 				if (InternalDriver.getDatabaseName(url, finfo).length() == 0) {
0: 					//
0: 					// We need to authenticate the user if authentication is
0: 					// ON. Note that this is a system shutdown.
0: 					// check that we do have a authentication service
0: 					// it is _always_ expected.
0: 					if (this.getAuthenticationService() == null)
0: 						throw Util.generateCsSQLException(
0:                         SQLState.LOGIN_FAILED, 
0: 						MessageService.getTextMessage(MessageId.AUTH_NO_SERVICE_FOR_SYSTEM));
0: 					
0: 						
0: 					if (!this.getAuthenticationService().authenticate((String) null, finfo)) {
0: 
0: 						// not a valid user
0: 						throw Util.generateCsSQLException(
0:                                   SQLState.LOGIN_FAILED, MessageService.getTextMessage(MessageId.AUTH_INVALID));
0: 					}
0: 
0: 					Monitor.getMonitor().shutdown();
0: 					throw Util.generateCsSQLException(
0:                                          SQLState.CLOUDSCAPE_SYSTEM_SHUTDOWN);
0: 				}
0: 			}
0: 			
0: 			EmbedConnection conn = getNewEmbedConnection(url, finfo);
0: 
0: 			// if this is not the correct driver a EmbedConnection
0: 			// object is returned in the closed state.
0: 			if (conn.isClosed()) {
0: 				return null;
0: 			}
0: 
0: 			return conn;
0: 		}
0: 		finally {
0: 			// break any link with the user's Properties set.
0: 			finfo.clearDefaults();
0: 		}
0: 	}
0: 
0: 	public int getMajorVersion() {
0: 		return Monitor.getMonitor().getEngineVersion().getMajorVersion();
0: 	}
0: 	
0: 	public int getMinorVersion() {
0: 		return Monitor.getMonitor().getEngineVersion().getMinorVersion();
0: 	}
0: 
0: 	public boolean jdbcCompliant() {
1: 		return true;
0: 	}
0: 
0: 	/*
0: 	** URL manipulation
0: 	*/
0: 
0: 	/**
0: 		Convert all the attributes in the url into properties and
0: 		combine them with the set provided. 
0: 		<BR>
0: 		If the caller passed in a set of attributes (info != null)
0: 		then we set that up as the default of the returned property
0: 		set as the user's set. This means we can easily break the link
0: 		with the user's set, ensuring that we don't hang onto the users object.
0: 		It also means that we don't add our attributes into the user's
0: 		own property object.
0: 
0: 		@exception SQLException thrown if URL form bad
0: 	*/
0: 	protected FormatableProperties getAttributes(String url, Properties info) 
0: 		throws SQLException {
0: 
0: 		// We use FormatableProperties here to take advantage
0: 		// of the clearDefaults, method.
0: 		FormatableProperties finfo = new FormatableProperties(info);
0: 		info = null; // ensure we don't use this reference directly again.
0: 
0: 
0: 		StringTokenizer st = new StringTokenizer(url, ";");
0: 		st.nextToken(); // skip the first part of the url
0: 
0: 		while (st.hasMoreTokens()) {
0: 
0: 			String v = st.nextToken();
0: 
0: 			int eqPos = v.indexOf('=');
0: 			if (eqPos == -1)
0: 				throw Util.generateCsSQLException(
0:                                             SQLState.MALFORMED_URL, url);
0: 
0: 			//if (eqPos != v.lastIndexOf('='))
0: 			//	throw Util.malformedURL(url);
0: 
0: 			finfo.put((v.substring(0, eqPos)).trim(),
0: 					 (v.substring(eqPos + 1)).trim()
0: 					);
0: 		}
0: 
0: 		// now validate any attributes we can
0: 		//
0: 		// Boolean attributes -
0: 		//  dataEncryption,create,createSource,convertToSource,shutdown,upgrade,current
0: 
0: 
0: 		checkBoolean(finfo, Attribute.DATA_ENCRYPTION);
0: 		checkBoolean(finfo, Attribute.CREATE_ATTR);
0: 		checkBoolean(finfo, Attribute.SHUTDOWN_ATTR);
0: 		checkBoolean(finfo, Attribute.UPGRADE_ATTR);
0: 
0: 		return finfo;
0: 	}
0: 
0: 	private static void checkBoolean(Properties set, String attribute) throws SQLException
0:     {
0:         final String[] booleanChoices = {"true", "false"};
0:         checkEnumeration( set, attribute, booleanChoices);
0: 	}
0: 
0: 
0: 	private static void checkEnumeration(Properties set, String attribute, String[] choices) throws SQLException
0:     {
0: 		String value = set.getProperty(attribute);
0: 		if (value == null)
0: 			return;
0: 
0:         for( int i = 0; i < choices.length; i++)
0:         {
0:             if( value.toUpperCase(java.util.Locale.ENGLISH).equals( choices[i].toUpperCase(java.util.Locale.ENGLISH)))
0:                 return;
0:         }
0: 
0:         // The attribute value is invalid. Construct a string giving the choices for
0:         // display in the error message.
0:         String choicesStr = "{";
0:         for( int i = 0; i < choices.length; i++)
0:         {
0:             if( i > 0)
0:                 choicesStr += "|";
0:             choicesStr += choices[i];
0:         }
0:         
0: 		throw Util.generateCsSQLException(
0:                 SQLState.INVALID_ATTRIBUTE, attribute, value, choicesStr + "}");
0: 	}
0: 
0: 
0: 	/**
0: 		Get the database name from the url.
0: 		Copes with three forms
0: 
0: 		jdbc:derby:dbname
0: 		jdbc:derby:dbname;...
0: 		jdbc:derby:;subname=dbname
0: 
0: 		@param url The url being used for the connection
0: 		@param info The properties set being used for the connection, must include
0: 		the properties derived from the attributes in the url
0: 
0: 		@return a String containing the database name or an empty string ("") if
0: 		no database name is present in the URL.
0: 	*/
0: 	public static String getDatabaseName(String url, Properties info) {
0: 
0: 		if (url.equals(Attribute.SQLJ_NESTED))
0: 		{
0: 			return "";
0: 		}	
0: 		
0: 		// skip the jdbc:derby:
0: 		int attributeStart = url.indexOf(';');
0: 		String dbname;
0: 		if (attributeStart == -1)
0: 			dbname = url.substring(Attribute.PROTOCOL.length());
0: 		else
0: 			dbname = url.substring(Attribute.PROTOCOL.length(), attributeStart);
0: 
0: 		// For security reasons we rely on here an non-null string being
0: 		// taken as the database name, before the databaseName connection
0: 		// attribute. Specifically, even if dbname is blank we still we
0: 		// to use it rather than the connection attribute, even though
0: 		// it will end up, after the trim, as a zero-length string.
0: 		// See EmbeddedDataSource.update()
0: 
0: 		if (dbname.length() == 0) {
0: 		    if (info != null)
0: 				dbname = info.getProperty(Attribute.DBNAME_ATTR, dbname);
0: 		}
0: 		// Beetle 4653 - trim database name to remove blanks that might make a difference on finding the database
0: 		// on unix platforms
0: 		dbname = dbname.trim();
0: 
0: 		return dbname;
0: 	}
0: 
0: 	public final ContextService getContextServiceFactory() {
0: 		return contextServiceFactory;
0: 	}
0: 
0: 	// returns the authenticationService handle
0: 	public AuthenticationService getAuthenticationService() {
0: 		//
0: 		// If authenticationService handle not cached in yet, then
0: 		// ask the monitor to find it for us and set it here in its
0: 		// attribute.
0: 		//
0: 		if (this.authenticationService == null) {
0: 			this.authenticationService = (AuthenticationService)
0: 				Monitor.findService(AuthenticationService.MODULE,
0: 									"authentication"
0: 								   );
0: 		}
0: 
0: 		// We should have a Authentication Service (always)
0: 		//
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(this.authenticationService != null, 
0: 				"Unexpected - There is no valid authentication service!");
0: 		}
0: 		return this.authenticationService;
0: 	}
0: 
0: 	/*
0: 		Methods to be overloaded in sub-implementations such as
0: 		a tracing driver.
0: 	 */
0: 	protected abstract EmbedConnection getNewEmbedConnection(String url, Properties info) 
0: 		 throws SQLException ;
0: 
0: 
0: 	private ConnectionContext getConnectionContext() {
0: 
0: 		/*
0: 		** The current connection is the one in the current
0: 		** connection context, so get the context.
0: 		*/
0: 		ContextManager	cm = getCurrentContextManager();
0: 
0: 		ConnectionContext localCC = null;
0: 
0: 		/*
0: 			cm is null the very first time, and whenever
0: 			we aren't actually nested.
0: 		 */
0: 		if (cm != null) {
0: 			localCC = (ConnectionContext)
0: 				(cm.getContext(ConnectionContext.CONTEXT_ID));
0: 		}
0: 
0: 		return localCC;
0: 	}
0: 
0: 	private ContextManager getCurrentContextManager() {
0: 		return getContextServiceFactory().getCurrentContextManager();
0: 	}
0: 
0: 
0: 	/**
0: 		Return true if this driver is active. Package private method.
0: 	*/
0: 	public boolean isActive() {
0: 		return active;
0: 	}
0: 
0: 	/**
0:  	 * Get a new nested connection.
0: 	 *
0: 	 * @param conn	The EmbedConnection.
0: 	 *
0: 	 * @return A nested connection object.
0: 	 *
0: 	 */
0: 	public abstract Connection getNewNestedConnection(EmbedConnection conn);
0: 
0: 	/*
0: 	** methods to be overridden by subimplementations wishing to insert
0: 	** their classes into the mix.
0: 	*/
0: 
0: 	public java.sql.Statement newEmbedStatement(
0: 				EmbedConnection conn,
0: 				boolean forMetaData,
0: 				int resultSetType,
0: 				int resultSetConcurrency,
0: 				int resultSetHoldability)
0: 	{
0: 		return new EmbedStatement(conn, forMetaData, resultSetType, resultSetConcurrency,
0: 		resultSetHoldability);
0: 	}
0: 	/**
0: 	 	@exception SQLException if fails to create statement
0: 	 */
0: 	public abstract java.sql.PreparedStatement newEmbedPreparedStatement(
0: 				EmbedConnection conn,
0: 				String stmt, 
0: 				boolean forMetaData, 
0: 				int resultSetType,
0: 				int resultSetConcurrency,
0: 				int resultSetHoldability,
0: 				int autoGeneratedKeys,
0: 				int[] columnIndexes,
0: 				String[] columnNames)
0: 		throws SQLException;
0: 
0: 	/**
0: 	 	@exception SQLException if fails to create statement
0: 	 */
0: 	public abstract java.sql.CallableStatement newEmbedCallableStatement(
0: 				EmbedConnection conn,
0: 				String stmt, 
0: 				int resultSetType,
0: 				int resultSetConcurrency,
0: 				int resultSetHoldability)
0: 		throws SQLException;
0: 
0: 	/**
0: 	 * Return a new java.sql.DatabaseMetaData instance for this implementation.
0: 	 	@exception SQLException on failure to create.
0: 	 */
0: 	public DatabaseMetaData newEmbedDatabaseMetaData(EmbedConnection conn,
0: 		String dbname) throws SQLException {
0: 		return new EmbedDatabaseMetaData(conn,dbname);
0: 	}
0: 
0: 	/**
0: 	 * Return a new java.sql.ResultSet instance for this implementation.
0: 	 * @param conn Owning connection
0: 	 * @param results Top level of language result set tree
0: 	 * @param forMetaData Is this for meta-data
0: 	 * @param statement The statement that is creating the SQL ResultSet
0: 	 * @param isAtomic 
0: 	 * @return a new java.sql.ResultSet
0: 	 * @throws SQLException
0: 	 */
0: 	public abstract EmbedResultSet
0: 		newEmbedResultSet(EmbedConnection conn, ResultSet results, boolean forMetaData, EmbedStatement statement, boolean isAtomic) throws SQLException;
0: }
0: 
0: 
0: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:09a7325
/////////////////////////////////////////////////////////////////////////
0: 		return true;
commit:9a32c46
/////////////////////////////////////////////////////////////////////////
0: 		return active &&
0: 		//	need to reject network driver's URL's
0: 		!url.startsWith(Attribute.JCC_PROTOCOL) && !url.startsWith(Attribute.DNC_PROTOCOL) &&
0: 		(url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
0: 				
============================================================================