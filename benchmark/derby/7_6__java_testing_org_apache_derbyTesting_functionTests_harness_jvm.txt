1:f68f62f: /*
4:f68f62f: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.harness.jvm
1:f68f62f: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
1:f68f62f:  */
1:f68f62f: 
1:f68f62f: package org.apache.derbyTesting.functionTests.harness;
1:f68f62f: 
1:4469400: import java.lang.reflect.InvocationTargetException;
1:424cdbd: import java.util.Enumeration;
1:424cdbd: import java.util.Properties;
1:f68f62f: import java.util.Vector;
1:f68f62f: import java.util.StringTokenizer;
1:f68f62f: import java.io.File;
1:f32e51e: import java.io.IOException;
1:f32e51e: 
1:f68f62f: import org.apache.derby.impl.tools.sysinfo.ZipInfoProperties;
1:424cdbd: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:f68f62f: 
1:f68f62f: 
1:f68f62f: /**
1:f68f62f:   <p>This class provides the interface and mechanism
1:f68f62f:   for plugging VMs into the system.  Typically
1:f68f62f:   you only need to add a new implementation if your
1:f68f62f:   supported attributes or command line building are
1:f68f62f:   different from those that exist.
1:f68f62f: 
1:f68f62f:   <p>this class has fields for all options that a JDK VM can take,
1:f68f62f:   that is the reference point for all others.  Note some VMs (like jview)
1:f68f62f:   don't take all options and will ignore them (like -mx).  Defining
1:f68f62f:   the system property "verbose" to 1 will give you warnings for ignored
1:f68f62f:   properties in a properly implemented subclass.
1:f68f62f: 
1:f68f62f:   <p> here is the canonical output from java -help for options we take:
1:f68f62f:   <pre>
1:f68f62f:     -noasyncgc        don't allow asynchronous garbage collection
1:f68f62f:     -verbosegc        print a message when garbage collection occurs
1:f68f62f:     -noclassgc        disable class garbage collection
1:f68f62f:     -ss<number>       set the maximum native stack size for any thread
1:f68f62f:     -oss<number>      set the maximum Java stack size for any thread
1:f68f62f:     -ms<number>       set the initial Java heap size
1:f68f62f:     -mx<number>       set the maximum Java heap size
1:f68f62f:     -classpath <directories separated by semicolons>
1:f68f62f:                       list directories in which to look for classes
1:f68f62f:     -prof[:<file>]    output profiling data to .\java.prof or .\<file>
1:f68f62f:     -verify           verify all classes when read in
1:f68f62f:     -noverify         do not verify any class
1:f68f62f:     -nojit            turn off the jit
1:f68f62f:     -Dprop=name       define property; can be specified more than once
1:f68f62f:   </pre>
1:f68f62f: 
1:f68f62f:  */
1:f68f62f: 
1:f68f62f: 
1:f68f62f: public abstract class jvm {
1:f68f62f: 
1:f68f62f:     // they all take their defaults as the initial value.
1:f68f62f:     // -1, null, and false all will mean we won't include them
1:f68f62f:     // in the command line.
1:f68f62f: 
1:f68f62f:     // flags             just take the whole string of flags as is
1:f68f62f:     public String flags = null;
1:f68f62f:     // -noasyncgc        don't allow asynchronous garbage collection
1:f68f62f:     public boolean noasyncgc = false;
1:f68f62f:     // -verbosegc        print a message when garbage collection occurs
1:f68f62f:     public boolean verbosegc = false;
1:f68f62f:     // -noclassgc        disable class garbage collection
1:f68f62f:     public boolean noclassgc = false;
1:f68f62f:     // -ss<number>       set the maximum native stack size for any thread
1:f68f62f:     public long ss = -1;
1:f68f62f:     // -oss<number>      set the maximum Java stack size for any thread
1:f68f62f:     public long oss = -1;
1:f68f62f:     // -ms<number>       set the initial Java heap size
1:f68f62f:     public long ms = -1;
1:f68f62f:     // -mx<number>       set the maximum Java heap size
1:f68f62f:     public long mx = -1;
1:f68f62f:     // -classpath <directories separated by semicolons>
1:f68f62f:     //                   list directories in which to look for classes
1:f68f62f:     public String classpath = null;
1:f68f62f:     // -prof[:<file>]    output profiling data to .\java.prof or .\<file>
1:f68f62f:     public String prof = null;
1:f68f62f:     // -verify           verify all classes when read in
1:f68f62f:     //                   (remote verification is the default)
1:f68f62f:     public boolean verify = false;
1:f68f62f:     // -noverify         do not verify any class
1:f68f62f:     //                   (remote verification is the default)
1:f68f62f:     public boolean noverify = false;
1:f68f62f:     // -nojit            turn off the jit
1:f68f62f:     public boolean nojit = false;
1:f68f62f:     // -Dprop=name       define property; can be specified more than once
1:3f5c48a:     public Vector<String> D = null;
1:f68f62f:     // java cmd (java, java_g)
1:f68f62f:     public String javaCmd = "java";
1:f68f62f:     // major and minor version
1:f68f62f:     public String majorVersion = "";
1:f68f62f:     public String minorVersion = "";
1:f68f62f:     public int imajor = 0;
1:f68f62f:     public int iminor = 0;
1:5ff5941:     String hostName;
1:f68f62f: 
1:f68f62f: 	// security defaults relative to WS
1:2f9391c: 	// not used if jvmargs serverCodeBase are set
1:cac35ca: 	private static String DEFAULT_POLICY="util/derby_tests.policy";
1:f68f62f: 	private static String DEFAULT_CODEBASE="/classes";
1:f68f62f: 
1:f68f62f:     // constructors
1:f68f62f:     public jvm() { }
1:f68f62f: 
1:f68f62f:     public jvm(boolean noasyncgc, boolean verbosegc, boolean noclassgc,
1:f68f62f:     long ss, long oss, long ms, long mx, String classpath, String prof,
1:3f5c48a:     boolean verify, boolean noverify, boolean nojit, Vector<String> D) {
1:f68f62f:         this.noasyncgc=noasyncgc;
1:f68f62f:         this.noclassgc=noclassgc;
1:f68f62f:         this.verbosegc=verbosegc;
1:f68f62f:         this.ss=ss;
1:f68f62f:         this.oss=oss;
1:f68f62f:         this.ms=ms;
1:f68f62f:         this.mx=mx;
1:f68f62f:         this.classpath=classpath;
1:f68f62f:         this.prof=prof;
1:f68f62f:         this.verify=verify;
1:f68f62f:         this.noverify=noverify;
1:f68f62f:         this.nojit=nojit;
1:f68f62f:         this.D=D;
2:f68f62f:     }
1:f68f62f:     // more typical use:
1:3f5c48a:     public jvm(String classpath, Vector<String> D) {
1:f68f62f:         this.classpath=classpath;
1:f68f62f:         this.D=D;
1:f68f62f:     }
1:f68f62f:     // more typical use:
1:3f5c48a:     public jvm(long ms, long mx, String classpath, Vector<String> D) {
1:f68f62f:         this.ms=ms;
1:f68f62f:         this.mx=mx;
1:f68f62f:         this.classpath=classpath;
1:f68f62f:         this.D=D;
1:f68f62f:     }
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f:        return the property definition introducer, with a space if a
1:f68f62f:        separator is needed.
1:f68f62f:      */
1:f68f62f:     public abstract String getDintro();
1:f68f62f: 	public abstract String getName();
1:f68f62f:     public void setNoasyncgc(boolean noasyncgc) { this.noasyncgc=noasyncgc; }
1:f68f62f:     public void setNoclassgc(boolean noclassgc) { this.noclassgc=noclassgc; }
1:f68f62f:     public void setVerbosegc(boolean verbosegc) { this.verbosegc=verbosegc; }
1:f68f62f:     public void setSs(long ss) { this.ss=ss; }
1:f68f62f:     public void setOss(long oss) { this.oss=oss; }
1:f68f62f:     public void setMs(long ms) { this.ms = ms; }
1:f68f62f:     public void setMx(long mx) { this.mx = mx; }
1:f68f62f:     public void setClasspath(String classpath) { this.classpath = classpath; }
1:f68f62f:     public void setProf(String prof) { this.prof=prof; }
1:f68f62f:     public void setVerify(boolean verify) { this.verify=verify; }
1:f68f62f:     public void setNoverify(boolean noverify) { this.noverify=noverify; }
1:f68f62f:     public void setNojit(boolean nojit) { this.nojit=nojit; }
1:3f5c48a:     public void setD(Vector<String> D) { this.D = D; }
1:f68f62f:     public void setFlags(String flags) { this.flags = flags; }
1:f68f62f:     public void setJavaCmd(String jcmd) { this.javaCmd = jcmd; }
1:f68f62f: 
1:f68f62f: 	
1:3f5c48a:     public Vector<String> getCommandLine()
2:f68f62f:     {
1:3f5c48a:         Vector<String> v = new Vector<String>();
1:f68f62f:         v.addElement(javaCmd);
1:a4aa5a7:         v.addElement("-Duser.language=en");
1:a4aa5a7:         v.addElement("-Duser.country=US");
1:f68f62f:         if ( (flags != null) && (flags.length()>0) )
1:f68f62f:         {
1:f68f62f:             StringTokenizer st = new StringTokenizer(flags);
1:f68f62f:             while (st.hasMoreTokens())
1:f68f62f:             {
1:f68f62f:                 v.addElement(st.nextToken());
1:f68f62f:             }
1:f68f62f:         }
1:f68f62f:         return v;
1:f68f62f:     }
1:f68f62f: 
1:f68f62f:     // implementation, used by subclasses only
1:f68f62f:     int verboselevel = -1;
1:f68f62f:     public void warn(String msg) {
1:f68f62f:       if (verboselevel == -1) {
1:f68f62f:          try {
1:f68f62f:            verboselevel = Integer.parseInt((String)(System.getProperty("verbose")));
1:f68f62f:          } catch (Exception e) {
1:f68f62f:            verboselevel = 0;
1:f68f62f:          }
1:f68f62f:       }
1:f68f62f:       if (verboselevel >0)
1:f68f62f:           System.out.println("jvm: "+msg);
1:f68f62f:     }
1:f68f62f: 
1:f68f62f:     // utility for locating a jvm.
1:f68f62f:     /**
1:f68f62f:         pass in class name for JVM.  If we can't find it, try
1:f68f62f: 	also org.apache.derbyTesting.functionTests.harness.<jvmName>
1:f68f62f:      */
1:4469400:     public static jvm getJvm(String jvmName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException
1:4469400:     {
1:4469400: 	    jvm result = null;
1:4469400:         Class<?> clazz;
1:f68f62f:         try {
1:4469400:             clazz = Class.forName(jvmName);
1:4469400:             result = (jvm) clazz.getConstructor().newInstance();
1:4469400:         } catch (ClassNotFoundException e)
1:4469400:         {
1:4469400:             clazz = Class.forName("org.apache.derbyTesting.functionTests.harness."+jvmName);
1:4469400:             result = (jvm) clazz.getConstructor().newInstance();
1:f68f62f:         }
1:f68f62f:         return result;
1:f68f62f:     }
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 	  Get the current JVM using the normal test harness rules for finding
1:f68f62f: 	  a JVM.
1:f68f62f: 	  <OL>
1:f68f62f: 	  <LI> If the sytem property 'jvm' use this name.
1:f68f62f: 	  <LI> else if the java version starts with 1.2 use
1:f68f62f: 	       "jdk12".
1:f68f62f: 	  <LI> else use "currentjvm".	
1:f68f62f: 	  */
1:f68f62f: 	public static jvm getCurrentJvm() throws Exception
1:f68f62f: 	{
1:f68f62f: 		String jvmName = System.getProperty("jvm");
1:f68f62f: 		if ( (jvmName == null) || (jvmName.length()==0) )
1:f68f62f: 		{
1:f68f62f: 			String javaVersion = System.getProperty("java.version");
1:f68f62f: 		    if (javaVersion.startsWith("1.2"))
1:f68f62f: 		        jvmName = "jdk12";
1:f68f62f: 		    else
1:f68f62f: 		        jvmName = "currentjvm";
1:f68f62f: 		}
1:f68f62f: 		return getJvm(jvmName);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f:     /**
1:f68f62f:       Return the major version number
1:f68f62f:     */
1:f68f62f:     public int getMajorVersion()
1:f68f62f:     {
1:f68f62f:         return imajor;
1:f68f62f:     }
1:f68f62f:     
1:f68f62f:     /**
1:f68f62f:       Return the major version number
1:f68f62f:     */
1:f68f62f:     public int getMinorVersion()
1:f68f62f:     {
1:f68f62f:         return iminor;
1:f68f62f:     }
1:f68f62f:     
1:f68f62f: 	/**
1:f68f62f: 	  Get the current JVM using the normal test harness rules for finding
1:f68f62f: 	  a JVM.
1:f68f62f: 	  */
1:f68f62f: 	public void setVersion() throws Exception
1:f68f62f: 	{
1:f68f62f: 		// check for jdk12 or higher
1:f68f62f: 	    String javaVersion = System.getProperty("java.version");
1:f68f62f: 		int i = javaVersion.indexOf('.');
1:f68f62f: 		int j = javaVersion.indexOf('.', i+1);
1:f68f62f: 		majorVersion = javaVersion.substring(0, i);
1:f68f62f: 		minorVersion = javaVersion.substring(i+1, j);
1:39b3237: 		Integer minor = Integer.valueOf(minorVersion);
1:f68f62f: 		iminor = minor.intValue();
1:39b3237: 		Integer major = Integer.valueOf(majorVersion);
1:f68f62f: 		imajor = major.intValue();
1:f68f62f: 		
1:f68f62f: 		String jvmName = System.getProperty("jvm");
1:f68f62f: 		
1:f68f62f: 		if ( (jvmName == null) || (jvmName.length()==0) )
1:f68f62f: 		{
1:f68f62f: 		    if (iminor < 2)
1:f68f62f: 		        jvmName = "currentjvm";
1:f68f62f: 		    else
1:f68f62f: 		        jvmName = "jdk" + majorVersion + minorVersion;
1:f68f62f: 		}
1:f68f62f: 	}
1:f68f62f: 	
1:f68f62f: 	/** Find $WS based on the assumption that JAVA_HOME is $WS/<jvm_name>
1:f68f62f: 	 * or $WS/<jvm_name>/jre
1:f68f62f: 	 * @return path of $WS
1:f68f62f: 	 */
1:f68f62f: 	protected static String guessWSHome()
1:f68f62f: 	{
1:f68f62f: 		String wshome=""; 
1:f68f62f: 		String jhome = System.getProperty("java.home");
1:f68f62f: 		String sep = System.getProperty("file.separator");
1:f68f62f: 		// need to strip off the java directory  assuming it's something
1:f68f62f: 		// like ibm14/jre or ibm14
1:dc66b56: 		int havejre=jhome.indexOf(sep + "jre");
1:dc66b56: 		if (havejre > 0)
1:dc66b56: 		{
1:dc66b56: 			wshome = jhome.substring(0,jhome.indexOf(sep + "jre"));
1:dc66b56: 			if (wshome.lastIndexOf(sep) >= 0)
1:dc66b56: 				wshome = wshome.substring(0,wshome.lastIndexOf(sep));
1:dc66b56: 		}
1:dc66b56: 		{
1:dc66b56: 			if (jhome.lastIndexOf(sep) >= 0)
1:dc66b56: 				wshome = jhome.substring(0,jhome.lastIndexOf(sep));	
1:dc66b56: 		}
1:f68f62f: 		return wshome;
1:f68f62f: 	}
1:f68f62f: 
1:7095131: 	public static String findCodeBase(boolean[] isJar)
1:f68f62f: 	{
1:f68f62f: 		String classpath = System.getProperty("java.class.path");
1:f68f62f: 		char sep = '/';
1:f68f62f: 		ZipInfoProperties zip[]= 
1:f68f62f: 			org.apache.derby.impl.tools.sysinfo.Main.getAllInfo (classpath);
1:f68f62f: 		for (int i = 0; i < zip.length; i++)
1:f68f62f: 		{
1:f68f62f: 			// it's a url so should just have forward slashes
1:f68f62f: 			String location = zip[i].getLocation().replace('\\','/');
1:f68f62f: 			if (location.indexOf("derbynet.jar") != -1)
1:f68f62f: 			{
1:cac35ca: 				isJar[0] = true;
1:f68f62f: 				return location.substring(0,location.lastIndexOf(sep));
1:f68f62f: 			}
1:f68f62f: 			else if ((location.indexOf("classes") != -1) &&
1:f68f62f: 					 location.indexOf(".jar") == -1)
1:cac35ca: 			{
1:cac35ca: 				isJar[0] = false;
1:f68f62f: 				return location;
1:cac35ca: 			}
1:f68f62f: 		}
1:f68f62f: 		return null;
1:f68f62f: 	}
1:f68f62f: 	
1:f68f62f: 	/**
1:f68f62f: 	 * set up security properties for server command line.
1:f68f62f: 	 */
1:f68f62f: 	protected void setSecurityProps() throws java.io.IOException, ClassNotFoundException
1:f32e51e: 	{		
1:f32e51e: 		D = jvm.getSecurityProps(D);
1:f32e51e: 		
1:f32e51e: 	}
1:f32e51e: 	
1:3f5c48a:     static Vector<String> getSecurityProps(Vector<String> D)
1:3f5c48a:             throws ClassNotFoundException, IOException
1:f68f62f: 	{
1:f32e51e: 		if (D == null)
1:3f5c48a: 			D = new Vector<String>();
1:f68f62f: 		
1:f68f62f: 		String userDir = System.getProperty("user.dir");
1:2f9391c: 		String policyFile = userDir + baseName(DEFAULT_POLICY);
1:f68f62f: 
1:f68f62f: 		String serverCodeBase = System.getProperty("serverCodeBase");
1:cac35ca: 		boolean[] isJar = new boolean[1];
1:f68f62f: 		if (serverCodeBase == null)
1:cac35ca: 			serverCodeBase = findCodeBase(isJar);
1:424cdbd:    
1:f68f62f:         
1:f68f62f: 		if (serverCodeBase == null)
1:f68f62f: 		{
1:f68f62f: 			String ws = guessWSHome();
1:f68f62f: 			serverCodeBase = ws + DEFAULT_CODEBASE;
1:424cdbd:                  
1:f68f62f: 		}
1:cac35ca: 		
1:cac35ca: 		File pf = new File(policyFile);
1:cac35ca: 		File cb = new File(serverCodeBase);
1:f68f62f: 
1:2f9391c: 		if (!pf.exists())
1:f68f62f: 		{
1:f68f62f: 			System.out.println("WARNING: Running without Security manager." +
1:2f9391c: 							   "policy File (" + policyFile + 
1:f68f62f: 							   ") or serverCodeBase(" +  serverCodeBase + 
1:f68f62f: 							   ") not available");
1:f32e51e: 		return D;
1:f68f62f: 		}
1:cac35ca: 		
1:f32e51e: 		D.addElement("java.security.manager");
1:f32e51e: 		D.addElement("java.security.policy=" + pf.getAbsolutePath());
1:424cdbd:  
1:424cdbd:         Properties jusetup =
1:424cdbd:             SecurityManagerSetup.getPolicyFilePropertiesForOldHarness();
1:424cdbd:         // Take the definitions from the way JUnit tests
1:424cdbd:         // set them up. This then supports the jar files being
1:424cdbd:         // in different locations.
1:424cdbd:         for (Enumeration p = jusetup.keys(); p.hasMoreElements(); )
1:424cdbd:         {
1:424cdbd:             String key = (String) p.nextElement();
1:424cdbd:             D.addElement(key + "=" + jusetup.getProperty(key));
1:424cdbd:         }
1:cac35ca: 		
1:cac35ca: 
1:cac35ca: 		// file path to the codebase
1:afb141e: 		D.addElement("derbyTesting.codedir=" + cb.getAbsolutePath());
1:5ff5941: 		String hostName = (System.getProperty("hostName"));
1:5ff5941: 		if (hostName == null)
1:5ff5941: 			hostName="localhost";
1:afb141e: 		D.addElement("derbyTesting.serverhost=" + hostName);
1:afb141e: 		// in the case of testing with a remote host, this is irrelevant, 
1:afb141e: 		// when testing 'normal' it is also localhost:
1:424cdbd: 		D.addElement("derbyTesting.clienthost=" + hostName);	 	
1:f32e51e: 		
1:f32e51e: 		return D;
1:cac35ca: 		
1:f68f62f: 	}
1:cac35ca: 
1:f68f62f: 	/** Get the base file name from a resource name string
1:2f9391c: 	 * @param resourceName (e.g. /org/apache/derbyTesting/functionTests/util/derby_tests.policy)
1:2f9391c: 	 * @return short name (e.g. derby_tests.policy)
1:f68f62f: 	 */
1:f32e51e: 	private static String baseName(String resourceName)
1:f68f62f: 	{
1:f68f62f: 	  
1:f68f62f: 		return resourceName.substring(resourceName.lastIndexOf("/"),resourceName.length());
1:f68f62f: 	}
1:f68f62f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1:     public static jvm getJvm(String jvmName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException
1:     {
1: 	    jvm result = null;
1:         Class<?> clazz;
1:             clazz = Class.forName(jvmName);
1:             result = (jvm) clazz.getConstructor().newInstance();
1:         } catch (ClassNotFoundException e)
1:         {
1:             clazz = Class.forName("org.apache.derbyTesting.functionTests.harness."+jvmName);
1:             result = (jvm) clazz.getConstructor().newInstance();
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 		Integer minor = Integer.valueOf(minorVersion);
1: 		Integer major = Integer.valueOf(majorVersion);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:     public Vector<String> D = null;
/////////////////////////////////////////////////////////////////////////
1:     boolean verify, boolean noverify, boolean nojit, Vector<String> D) {
/////////////////////////////////////////////////////////////////////////
1:     public jvm(String classpath, Vector<String> D) {
1:     public jvm(long ms, long mx, String classpath, Vector<String> D) {
/////////////////////////////////////////////////////////////////////////
1:     public void setD(Vector<String> D) { this.D = D; }
1:     public Vector<String> getCommandLine()
1:         Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:     static Vector<String> getSecurityProps(Vector<String> D)
1:             throws ClassNotFoundException, IOException
1: 			D = new Vector<String>();
commit:a4aa5a7
/////////////////////////////////////////////////////////////////////////
1:         v.addElement("-Duser.language=en");
1:         v.addElement("-Duser.country=US");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:dc66b56
/////////////////////////////////////////////////////////////////////////
1: 		int havejre=jhome.indexOf(sep + "jre");
1: 		if (havejre > 0)
1: 		{
1: 			wshome = jhome.substring(0,jhome.indexOf(sep + "jre"));
1: 			if (wshome.lastIndexOf(sep) >= 0)
1: 				wshome = wshome.substring(0,wshome.lastIndexOf(sep));
1: 		}
1: 		{
1: 			if (jhome.lastIndexOf(sep) >= 0)
1: 				wshome = jhome.substring(0,jhome.lastIndexOf(sep));	
1: 		}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:424cdbd
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
1: import java.util.Properties;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
/////////////////////////////////////////////////////////////////////////
1:         
1:                  
/////////////////////////////////////////////////////////////////////////
1:  
1:         Properties jusetup =
1:             SecurityManagerSetup.getPolicyFilePropertiesForOldHarness();
1:         // Take the definitions from the way JUnit tests
1:         // set them up. This then supports the jar files being
1:         // in different locations.
1:         for (Enumeration p = jusetup.keys(); p.hasMoreElements(); )
1:         {
1:             String key = (String) p.nextElement();
1:             D.addElement(key + "=" + jusetup.getProperty(key));
1:         }
/////////////////////////////////////////////////////////////////////////
1: 		D.addElement("derbyTesting.clienthost=" + hostName);	 	
commit:afb141e
/////////////////////////////////////////////////////////////////////////
0: 		String codebaseType = isJar[0] ? "derbyTesting.codejar" : "derbyTesting.codeclasses";
0: 		String unusedType = isJar[0] ? "derbyTesting.codeclasses" : "derbyTesting.codejar";
1: 		D.addElement("derbyTesting.codedir=" + cb.getAbsolutePath());
1: 		D.addElement("derbyTesting.serverhost=" + hostName);
1: 		// in the case of testing with a remote host, this is irrelevant, 
1: 		// when testing 'normal' it is also localhost:
0: 		D.addElement("derbyTesting.clienthost=" + hostName);	 
commit:f32e51e
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	{		
1: 		D = jvm.getSecurityProps(D);
1: 		
1: 	}
1: 	
0: 	static Vector getSecurityProps(Vector D) throws ClassNotFoundException, IOException
1: 		if (D == null)
0: 			D = new Vector();
/////////////////////////////////////////////////////////////////////////
1: 		return D;
1: 		D.addElement("java.security.manager");
1: 		D.addElement("java.security.policy=" + pf.getAbsolutePath());
0: 		D.addElement(codebaseType + "=" + cb.toURL());
0: 		D.addElement("csinfo.codedir=" + cb.getAbsolutePath());
0: 		D.addElement("csinfo.serverhost=" + hostName);
0: 		D.addElement("csinfo.trustedhost=" + hostName);	 
0: 		D.addElement(unusedType + "=file://unused/");
1: 		
1: 		return D;
/////////////////////////////////////////////////////////////////////////
1: 	private static String baseName(String resourceName)
commit:cac35ca
/////////////////////////////////////////////////////////////////////////
1: 	private static String DEFAULT_POLICY="util/derby_tests.policy";
/////////////////////////////////////////////////////////////////////////
0: 	protected static String findCodeBase(boolean[] isJar)
/////////////////////////////////////////////////////////////////////////
1: 				isJar[0] = true;
1: 			{
1: 				isJar[0] = false;
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		boolean[] isJar = new boolean[1];
1: 			serverCodeBase = findCodeBase(isJar);
1: 		
1: 		File pf = new File(policyFile);
1: 		File cb = new File(serverCodeBase);
0: 			(!pf.exists()))
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		
0: 		String codebaseType = isJar[0] ? "csinfo.codejar" : "csinfo.codeclasses";
0: 		String unusedType = isJar[0] ? "csinfo.codeclasses" : "csinfo.codejar";
1: 
0: 		// URL of the codebase
0: 		this.D.addElement(codebaseType + "=" + cb.toURL());
1: 		// file path to the codebase
0: 		this.D.addElement("csinfo.codedir=" + cb.getAbsolutePath());
1: 		
0: 		// add an invalid path to the unused type 
0: 		this.D.addElement(unusedType + "=file://unused/");
1: 		
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.jvm
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.harness;
1: 
1: import java.util.Vector;
1: import java.util.StringTokenizer;
1: import java.io.File;
1: import org.apache.derby.impl.tools.sysinfo.ZipInfoProperties;
1: 
1: 
1: /**
1:   <p>This class provides the interface and mechanism
1:   for plugging VMs into the system.  Typically
1:   you only need to add a new implementation if your
1:   supported attributes or command line building are
1:   different from those that exist.
1: 
1:   <p>this class has fields for all options that a JDK VM can take,
1:   that is the reference point for all others.  Note some VMs (like jview)
1:   don't take all options and will ignore them (like -mx).  Defining
1:   the system property "verbose" to 1 will give you warnings for ignored
1:   properties in a properly implemented subclass.
1: 
1:   <p> here is the canonical output from java -help for options we take:
1:   <pre>
1:     -noasyncgc        don't allow asynchronous garbage collection
1:     -verbosegc        print a message when garbage collection occurs
1:     -noclassgc        disable class garbage collection
1:     -ss<number>       set the maximum native stack size for any thread
1:     -oss<number>      set the maximum Java stack size for any thread
1:     -ms<number>       set the initial Java heap size
1:     -mx<number>       set the maximum Java heap size
1:     -classpath <directories separated by semicolons>
1:                       list directories in which to look for classes
1:     -prof[:<file>]    output profiling data to .\java.prof or .\<file>
1:     -verify           verify all classes when read in
1:     -noverify         do not verify any class
1:     -nojit            turn off the jit
1:     -Dprop=name       define property; can be specified more than once
1:   </pre>
1: 
0:   @author ames
1:  */
1: 
1: 
1: public abstract class jvm {
1: 
1:     // they all take their defaults as the initial value.
1:     // -1, null, and false all will mean we won't include them
1:     // in the command line.
1: 
1:     // flags             just take the whole string of flags as is
1:     public String flags = null;
1:     // -noasyncgc        don't allow asynchronous garbage collection
1:     public boolean noasyncgc = false;
1:     // -verbosegc        print a message when garbage collection occurs
1:     public boolean verbosegc = false;
1:     // -noclassgc        disable class garbage collection
1:     public boolean noclassgc = false;
1:     // -ss<number>       set the maximum native stack size for any thread
1:     public long ss = -1;
1:     // -oss<number>      set the maximum Java stack size for any thread
1:     public long oss = -1;
1:     // -ms<number>       set the initial Java heap size
1:     public long ms = -1;
1:     // -mx<number>       set the maximum Java heap size
1:     public long mx = -1;
1:     // -classpath <directories separated by semicolons>
1:     //                   list directories in which to look for classes
1:     public String classpath = null;
1:     // -prof[:<file>]    output profiling data to .\java.prof or .\<file>
1:     public String prof = null;
1:     // -verify           verify all classes when read in
1:     //                   (remote verification is the default)
1:     public boolean verify = false;
1:     // -noverify         do not verify any class
1:     //                   (remote verification is the default)
1:     public boolean noverify = false;
1:     // -nojit            turn off the jit
1:     public boolean nojit = false;
1:     // -Dprop=name       define property; can be specified more than once
0:     public Vector D = null;
1:     // java cmd (java, java_g)
1:     public String javaCmd = "java";
1:     // major and minor version
1:     public String majorVersion = "";
1:     public String minorVersion = "";
1:     public int imajor = 0;
1:     public int iminor = 0;
1: 
1: 	// security defaults relative to WS
0: 	// not used if jvmargs serverPolicyFile or serverCodeBase are set
0: 	private static String DEFAULT_POLICY="util/nwsvr.policy";
1: 	private static String DEFAULT_CODEBASE="/classes";
1: 
1:     // constructors
1:     public jvm() { }
1: 
1:     public jvm(boolean noasyncgc, boolean verbosegc, boolean noclassgc,
1:     long ss, long oss, long ms, long mx, String classpath, String prof,
0:     boolean verify, boolean noverify, boolean nojit, Vector D) {
1:         this.noasyncgc=noasyncgc;
1:         this.noclassgc=noclassgc;
1:         this.verbosegc=verbosegc;
1:         this.ss=ss;
1:         this.oss=oss;
1:         this.ms=ms;
1:         this.mx=mx;
1:         this.classpath=classpath;
1:         this.prof=prof;
1:         this.verify=verify;
1:         this.noverify=noverify;
1:         this.nojit=nojit;
1:         this.D=D;
1:     }
1:     // more typical use:
0:     public jvm(String classpath, Vector D) {
1:         this.classpath=classpath;
1:         this.D=D;
1:     }
1:     // more typical use:
0:     public jvm(long ms, long mx, String classpath, Vector D) {
1:         this.ms=ms;
1:         this.mx=mx;
1:         this.classpath=classpath;
1:         this.D=D;
1:     }
1: 
1: 	/**
1:        return the property definition introducer, with a space if a
1:        separator is needed.
1:      */
1:     public abstract String getDintro();
1: 	public abstract String getName();
1:     public void setNoasyncgc(boolean noasyncgc) { this.noasyncgc=noasyncgc; }
1:     public void setNoclassgc(boolean noclassgc) { this.noclassgc=noclassgc; }
1:     public void setVerbosegc(boolean verbosegc) { this.verbosegc=verbosegc; }
1:     public void setSs(long ss) { this.ss=ss; }
1:     public void setOss(long oss) { this.oss=oss; }
1:     public void setMs(long ms) { this.ms = ms; }
1:     public void setMx(long mx) { this.mx = mx; }
1:     public void setClasspath(String classpath) { this.classpath = classpath; }
1:     public void setProf(String prof) { this.prof=prof; }
1:     public void setVerify(boolean verify) { this.verify=verify; }
1:     public void setNoverify(boolean noverify) { this.noverify=noverify; }
1:     public void setNojit(boolean nojit) { this.nojit=nojit; }
0:     public void setD(Vector D) { this.D = D; }
1:     public void setFlags(String flags) { this.flags = flags; }
1:     public void setJavaCmd(String jcmd) { this.javaCmd = jcmd; }
1: 
1: 	
0:     public Vector getCommandLine()
1:     {
0:         Vector v = new Vector();
1:         v.addElement(javaCmd);
1:         if ( (flags != null) && (flags.length()>0) )
1:         {
1:             StringTokenizer st = new StringTokenizer(flags);
1:             while (st.hasMoreTokens())
1:             {
1:                 v.addElement(st.nextToken());
1:             }
1:         }
1:         return v;
1:     }
1: 
1:     // implementation, used by subclasses only
1:     int verboselevel = -1;
1:     public void warn(String msg) {
1:       if (verboselevel == -1) {
1:          try {
1:            verboselevel = Integer.parseInt((String)(System.getProperty("verbose")));
1:          } catch (Exception e) {
1:            verboselevel = 0;
1:          }
1:       }
1:       if (verboselevel >0)
1:           System.out.println("jvm: "+msg);
1:     }
1: 
1:     // utility for locating a jvm.
1:     /**
1:         pass in class name for JVM.  If we can't find it, try
1: 	also org.apache.derbyTesting.functionTests.harness.<jvmName>
1:      */
0:     public static jvm getJvm(String jvmName) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
0: 	jvm result = null;
1:         try {
0: 		result = (jvm)Class.forName(jvmName).newInstance();
0:         } catch (ClassNotFoundException e) {
0: 		result = (jvm)Class.forName("org.apache.derbyTesting.functionTests.harness."+jvmName).newInstance();
1:         }
1:         return result;
1:     }
1: 
1: 	/**
1: 	  Get the current JVM using the normal test harness rules for finding
1: 	  a JVM.
1: 	  <OL>
1: 	  <LI> If the sytem property 'jvm' use this name.
1: 	  <LI> else if the java version starts with 1.2 use
1: 	       "jdk12".
1: 	  <LI> else use "currentjvm".	
1: 	  */
1: 	public static jvm getCurrentJvm() throws Exception
1: 	{
1: 		String jvmName = System.getProperty("jvm");
1: 		if ( (jvmName == null) || (jvmName.length()==0) )
1: 		{
1: 			String javaVersion = System.getProperty("java.version");
1: 		    if (javaVersion.startsWith("1.2"))
1: 		        jvmName = "jdk12";
1: 		    else
1: 		        jvmName = "currentjvm";
1: 		}
1: 		return getJvm(jvmName);
1: 	}
1: 
1:     /**
1:       Return the major version number
1:     */
1:     public int getMajorVersion()
1:     {
1:         return imajor;
1:     }
1:     
1:     /**
1:       Return the major version number
1:     */
1:     public int getMinorVersion()
1:     {
1:         return iminor;
1:     }
1:     
1: 	/**
1: 	  Get the current JVM using the normal test harness rules for finding
1: 	  a JVM.
1: 	  */
1: 	public void setVersion() throws Exception
1: 	{
1: 		// check for jdk12 or higher
1: 	    String javaVersion = System.getProperty("java.version");
1: 		int i = javaVersion.indexOf('.');
1: 		int j = javaVersion.indexOf('.', i+1);
1: 		majorVersion = javaVersion.substring(0, i);
1: 		minorVersion = javaVersion.substring(i+1, j);
0: 		Integer minor = new Integer(minorVersion);
1: 		iminor = minor.intValue();
0: 		Integer major = new Integer(majorVersion);
1: 		imajor = major.intValue();
1: 		
1: 		String jvmName = System.getProperty("jvm");
1: 		
1: 		if ( (jvmName == null) || (jvmName.length()==0) )
1: 		{
1: 		    if (iminor < 2)
1: 		        jvmName = "currentjvm";
1: 		    else
1: 		        jvmName = "jdk" + majorVersion + minorVersion;
1: 		}
1: 	}
1: 	
1: 	/** Find $WS based on the assumption that JAVA_HOME is $WS/<jvm_name>
1: 	 * or $WS/<jvm_name>/jre
1: 	 * @return path of $WS
1: 	 */
1: 	protected static String guessWSHome()
1: 	{
1: 		String wshome=""; 
1: 		String jhome = System.getProperty("java.home");
1: 		String sep = System.getProperty("file.separator");
1: 		// need to strip off the java directory  assuming it's something
1: 		// like ibm14/jre or ibm14
0: 		wshome = jhome.substring(0,jhome.indexOf(sep + "jre"));
0: 		wshome = wshome.substring(0,wshome.lastIndexOf(sep));
1: 		return wshome;
1: 	}
1: 
0: 	protected static String findCodeBase()
1: 	{
1: 		String classpath = System.getProperty("java.class.path");
1: 		char sep = '/';
1: 		ZipInfoProperties zip[]= 
1: 			org.apache.derby.impl.tools.sysinfo.Main.getAllInfo (classpath);
1: 		for (int i = 0; i < zip.length; i++)
1: 		{
1: 			// it's a url so should just have forward slashes
1: 			String location = zip[i].getLocation().replace('\\','/');
1: 			if (location.indexOf("derbynet.jar") != -1)
1: 			{
1: 				return location.substring(0,location.lastIndexOf(sep));
1: 			}
1: 			else if ((location.indexOf("classes") != -1) &&
1: 					 location.indexOf(".jar") == -1)
1: 				return location;
1: 		}
1: 		return null;
1: 	}
1: 	
1: 	/**
1: 	 * set up security properties for server command line.
1: 	 */
1: 	protected void setSecurityProps() throws java.io.IOException, ClassNotFoundException
1: 	{
0: 		if (this.D == null)
0: 			this.D = new Vector();
1: 		
1: 		String userDir = System.getProperty("user.dir");
0: 		String policyFile = System.getProperty("serverPolicyFile");
0: 		if (policyFile == null)
1: 		{
0: 				File userDirHandle = new File(userDir);
0: 				CopySuppFiles.copyFiles(userDirHandle,DEFAULT_POLICY);
0: 				policyFile = userDir + baseName(DEFAULT_POLICY);
1: 		}
1: 
1: 		String serverCodeBase = System.getProperty("serverCodeBase");
1: 		if (serverCodeBase == null)
0: 			serverCodeBase = findCodeBase();
1:    
1: 		if (serverCodeBase == null)
1: 		{
1: 			String ws = guessWSHome();
1: 			serverCodeBase = ws + DEFAULT_CODEBASE;
1: 		}
1: 
0: 		if (policyFile.toLowerCase().equals("none") || 
0: 			(!(new File(policyFile)).exists()) ||
0: 			!(new File(policyFile)).exists())
1: 		{
1: 			System.out.println("WARNING: Running without Security manager." +
0: 							   "serverPolicy(" + policyFile + 
1: 							   ") or serverCodeBase(" +  serverCodeBase + 
1: 							   ") not available");
0: 		return;
1: 		}
0: 		this.D.addElement("java.security.manager");
0: 		this.D.addElement("java.security.policy=" + policyFile);
0: 		this.D.addElement("csinfo.codebase=" + serverCodeBase);
0: 		this.D.addElement("csinfo.serverhost=localhost");
0: 		this.D.addElement("csinfo.trustedhost=localhost");	 
1: 
1: 	}
1: 
1: 	/** Get the base file name from a resource name string
0: 	 * @param resourceName (e.g. /org/apache/derbyTesting/functionTests/util/nwsvr.policy)
0: 	 * @return short name (e.g. nwsvr.policy)
1: 	 */
0: 	private String baseName(String resourceName)
1: 	{
1: 	  
1: 		return resourceName.substring(resourceName.lastIndexOf("/"),resourceName.length());
1: 	}
1: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.jvm
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2f9391c
/////////////////////////////////////////////////////////////////////////
1: 	// not used if jvmargs serverCodeBase are set
/////////////////////////////////////////////////////////////////////////
1: 		String policyFile = userDir + baseName(DEFAULT_POLICY);
/////////////////////////////////////////////////////////////////////////
1: 		if (!pf.exists())
1: 							   "policy File (" + policyFile + 
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resourceName (e.g. /org/apache/derbyTesting/functionTests/util/derby_tests.policy)
1: 	 * @return short name (e.g. derby_tests.policy)
commit:ee43510
/////////////////////////////////////////////////////////////////////////
commit:5ff5941
/////////////////////////////////////////////////////////////////////////
1:     String hostName;
/////////////////////////////////////////////////////////////////////////
1: 		String hostName = (System.getProperty("hostName"));
1: 		if (hostName == null)
1: 			hostName="localhost";
0: 		this.D.addElement("csinfo.serverhost=" + hostName);
0: 		this.D.addElement("csinfo.trustedhost=" + hostName);	 
commit:67614ad
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.harness
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.harness;
0: 
0: import java.util.Vector;
0: import java.util.StringTokenizer;
0: import java.io.File;
0: import org.apache.derby.impl.tools.sysinfo.ZipInfoProperties;
0: 
0: 
0: /**
0:   <p>This class provides the interface and mechanism
0:   for plugging VMs into the system.  Typically
0:   you only need to add a new implementation if your
0:   supported attributes or command line building are
0:   different from those that exist.
0: 
0:   <p>this class has fields for all options that a JDK VM can take,
0:   that is the reference point for all others.  Note some VMs (like jview)
0:   don't take all options and will ignore them (like -mx).  Defining
0:   the system property "verbose" to 1 will give you warnings for ignored
0:   properties in a properly implemented subclass.
0: 
0:   <p> here is the canonical output from java -help for options we take:
0:   <pre>
0:     -noasyncgc        don't allow asynchronous garbage collection
0:     -verbosegc        print a message when garbage collection occurs
0:     -noclassgc        disable class garbage collection
0:     -ss<number>       set the maximum native stack size for any thread
0:     -oss<number>      set the maximum Java stack size for any thread
0:     -ms<number>       set the initial Java heap size
0:     -mx<number>       set the maximum Java heap size
0:     -classpath <directories separated by semicolons>
0:                       list directories in which to look for classes
0:     -prof[:<file>]    output profiling data to .\java.prof or .\<file>
0:     -verify           verify all classes when read in
0:     -noverify         do not verify any class
0:     -nojit            turn off the jit
0:     -Dprop=name       define property; can be specified more than once
0:   </pre>
0: 
0:   @author ames
0:  */
0: 
0: 
0: public abstract class jvm {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0:     // they all take their defaults as the initial value.
0:     // -1, null, and false all will mean we won't include them
0:     // in the command line.
0: 
0:     // flags             just take the whole string of flags as is
0:     public String flags = null;
0:     // -noasyncgc        don't allow asynchronous garbage collection
0:     public boolean noasyncgc = false;
0:     // -verbosegc        print a message when garbage collection occurs
0:     public boolean verbosegc = false;
0:     // -noclassgc        disable class garbage collection
0:     public boolean noclassgc = false;
0:     // -ss<number>       set the maximum native stack size for any thread
0:     public long ss = -1;
0:     // -oss<number>      set the maximum Java stack size for any thread
0:     public long oss = -1;
0:     // -ms<number>       set the initial Java heap size
0:     public long ms = -1;
0:     // -mx<number>       set the maximum Java heap size
0:     public long mx = -1;
0:     // -classpath <directories separated by semicolons>
0:     //                   list directories in which to look for classes
0:     public String classpath = null;
0:     // -prof[:<file>]    output profiling data to .\java.prof or .\<file>
0:     public String prof = null;
0:     // -verify           verify all classes when read in
0:     //                   (remote verification is the default)
0:     public boolean verify = false;
0:     // -noverify         do not verify any class
0:     //                   (remote verification is the default)
0:     public boolean noverify = false;
0:     // -nojit            turn off the jit
0:     public boolean nojit = false;
0:     // -Dprop=name       define property; can be specified more than once
0:     public Vector D = null;
0:     // java cmd (java, java_g)
0:     public String javaCmd = "java";
0:     // major and minor version
0:     public String majorVersion = "";
0:     public String minorVersion = "";
0:     public int imajor = 0;
0:     public int iminor = 0;
0: 
0: 	// security defaults relative to WS
0: 	// not used if jvmargs serverPolicyFile or serverCodeBase are set
0: 	private static String DEFAULT_POLICY="util/nwsvr.policy";
0: 	private static String DEFAULT_CODEBASE="/classes";
0: 
0:     // constructors
0:     public jvm() { }
0: 
0:     public jvm(boolean noasyncgc, boolean verbosegc, boolean noclassgc,
0:     long ss, long oss, long ms, long mx, String classpath, String prof,
0:     boolean verify, boolean noverify, boolean nojit, Vector D) {
0:         this.noasyncgc=noasyncgc;
0:         this.noclassgc=noclassgc;
0:         this.verbosegc=verbosegc;
0:         this.ss=ss;
0:         this.oss=oss;
0:         this.ms=ms;
0:         this.mx=mx;
0:         this.classpath=classpath;
0:         this.prof=prof;
0:         this.verify=verify;
0:         this.noverify=noverify;
0:         this.nojit=nojit;
0:         this.D=D;
0:     }
0:     // more typical use:
0:     public jvm(String classpath, Vector D) {
0:         this.classpath=classpath;
0:         this.D=D;
0:     }
0:     // more typical use:
0:     public jvm(long ms, long mx, String classpath, Vector D) {
0:         this.ms=ms;
0:         this.mx=mx;
0:         this.classpath=classpath;
0:         this.D=D;
0:     }
0: 
0: 	/**
0:        return the property definition introducer, with a space if a
0:        separator is needed.
0:      */
0:     public abstract String getDintro();
0: 	public abstract String getName();
0:     public void setNoasyncgc(boolean noasyncgc) { this.noasyncgc=noasyncgc; }
0:     public void setNoclassgc(boolean noclassgc) { this.noclassgc=noclassgc; }
0:     public void setVerbosegc(boolean verbosegc) { this.verbosegc=verbosegc; }
0:     public void setSs(long ss) { this.ss=ss; }
0:     public void setOss(long oss) { this.oss=oss; }
0:     public void setMs(long ms) { this.ms = ms; }
0:     public void setMx(long mx) { this.mx = mx; }
0:     public void setClasspath(String classpath) { this.classpath = classpath; }
0:     public void setProf(String prof) { this.prof=prof; }
0:     public void setVerify(boolean verify) { this.verify=verify; }
0:     public void setNoverify(boolean noverify) { this.noverify=noverify; }
0:     public void setNojit(boolean nojit) { this.nojit=nojit; }
0:     public void setD(Vector D) { this.D = D; }
0:     public void setFlags(String flags) { this.flags = flags; }
0:     public void setJavaCmd(String jcmd) { this.javaCmd = jcmd; }
0: 
0: 	
0:     public Vector getCommandLine()
0:     {
0:         Vector v = new Vector();
0:         v.addElement(javaCmd);
0:         if ( (flags != null) && (flags.length()>0) )
0:         {
0:             StringTokenizer st = new StringTokenizer(flags);
0:             while (st.hasMoreTokens())
0:             {
0:                 v.addElement(st.nextToken());
0:             }
0:         }
0:         return v;
0:     }
0: 
0:     // implementation, used by subclasses only
0:     int verboselevel = -1;
0:     public void warn(String msg) {
0:       if (verboselevel == -1) {
0:          try {
0:            verboselevel = Integer.parseInt((String)(System.getProperty("verbose")));
0:          } catch (Exception e) {
0:            verboselevel = 0;
0:          }
0:       }
0:       if (verboselevel >0)
0:           System.out.println("jvm: "+msg);
0:     }
0: 
0:     // utility for locating a jvm.
0:     /**
0:         pass in class name for JVM.  If we can't find it, try
0: 	also org.apache.derbyTesting.functionTests.harness.<jvmName>
0:      */
0:     public static jvm getJvm(String jvmName) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
0: 	jvm result = null;
0:         try {
0: 		result = (jvm)Class.forName(jvmName).newInstance();
0:         } catch (ClassNotFoundException e) {
0: 		result = (jvm)Class.forName("org.apache.derbyTesting.functionTests.harness."+jvmName).newInstance();
0:         }
0:         return result;
0:     }
0: 
0: 	/**
0: 	  Get the current JVM using the normal test harness rules for finding
0: 	  a JVM.
0: 	  <OL>
0: 	  <LI> If the sytem property 'jvm' use this name.
0: 	  <LI> else if the java version starts with 1.2 use
0: 	       "jdk12".
0: 	  <LI> else use "currentjvm".	
0: 	  */
0: 	public static jvm getCurrentJvm() throws Exception
0: 	{
0: 		String jvmName = System.getProperty("jvm");
0: 		if ( (jvmName == null) || (jvmName.length()==0) )
0: 		{
0: 			String javaVersion = System.getProperty("java.version");
0: 		    if (javaVersion.startsWith("1.2"))
0: 		        jvmName = "jdk12";
0: 		    else
0: 		        jvmName = "currentjvm";
0: 		}
0: 		return getJvm(jvmName);
0: 	}
0: 
0:     /**
0:       Return the major version number
0:     */
0:     public int getMajorVersion()
0:     {
0:         return imajor;
0:     }
0:     
0:     /**
0:       Return the major version number
0:     */
0:     public int getMinorVersion()
0:     {
0:         return iminor;
0:     }
0:     
0: 	/**
0: 	  Get the current JVM using the normal test harness rules for finding
0: 	  a JVM.
0: 	  */
0: 	public void setVersion() throws Exception
0: 	{
0: 		// check for jdk12 or higher
0: 	    String javaVersion = System.getProperty("java.version");
0: 		int i = javaVersion.indexOf('.');
0: 		int j = javaVersion.indexOf('.', i+1);
0: 		majorVersion = javaVersion.substring(0, i);
0: 		minorVersion = javaVersion.substring(i+1, j);
0: 		Integer minor = new Integer(minorVersion);
0: 		iminor = minor.intValue();
0: 		Integer major = new Integer(majorVersion);
0: 		imajor = major.intValue();
0: 		
0: 		String jvmName = System.getProperty("jvm");
0: 		
0: 		if ( (jvmName == null) || (jvmName.length()==0) )
0: 		{
0: 		    if (iminor < 2)
0: 		        jvmName = "currentjvm";
0: 		    else
0: 		        jvmName = "jdk" + majorVersion + minorVersion;
0: 		}
0: 	}
0: 	
0: 	/** Find $WS based on the assumption that JAVA_HOME is $WS/<jvm_name>
0: 	 * or $WS/<jvm_name>/jre
0: 	 * @return path of $WS
0: 	 */
0: 	protected static String guessWSHome()
0: 	{
0: 		String wshome=""; 
0: 		String jhome = System.getProperty("java.home");
0: 		String sep = System.getProperty("file.separator");
0: 		// need to strip off the java directory  assuming it's something
0: 		// like ibm14/jre or ibm14
0: 		wshome = jhome.substring(0,jhome.indexOf(sep + "jre"));
0: 		wshome = wshome.substring(0,wshome.lastIndexOf(sep));
0: 		return wshome;
0: 	}
0: 
0: 	protected static String findCodeBase()
0: 	{
0: 		String classpath = System.getProperty("java.class.path");
0: 		char sep = '/';
0: 		ZipInfoProperties zip[]= 
0: 			org.apache.derby.impl.tools.sysinfo.Main.getAllInfo (classpath);
0: 		for (int i = 0; i < zip.length; i++)
0: 		{
0: 			// it's a url so should just have forward slashes
0: 			String location = zip[i].getLocation().replace('\\','/');
0: 			if (location.indexOf("derbynet.jar") != -1)
0: 			{
0: 				return location.substring(0,location.lastIndexOf(sep));
0: 			}
0: 			else if ((location.indexOf("classes") != -1) &&
0: 					 location.indexOf(".jar") == -1)
0: 				return location;
0: 		}
0: 		return null;
0: 	}
0: 	
0: 	/**
0: 	 * set up security properties for server command line.
0: 	 */
0: 	protected void setSecurityProps() throws java.io.IOException, ClassNotFoundException
0: 	{
0: 		if (this.D == null)
0: 			this.D = new Vector();
0: 		
0: 		String userDir = System.getProperty("user.dir");
0: 		String policyFile = System.getProperty("serverPolicyFile");
0: 		if (policyFile == null)
0: 		{
0: 				File userDirHandle = new File(userDir);
0: 				CopySuppFiles.copyFiles(userDirHandle,DEFAULT_POLICY);
0: 				policyFile = userDir + baseName(DEFAULT_POLICY);
0: 		}
0: 
0: 		String serverCodeBase = System.getProperty("serverCodeBase");
0: 		if (serverCodeBase == null)
0: 			serverCodeBase = findCodeBase();
0:    
0: 		if (serverCodeBase == null)
0: 		{
0: 			String ws = guessWSHome();
0: 			serverCodeBase = ws + DEFAULT_CODEBASE;
0: 		}
0: 
0: 		if (policyFile.toLowerCase().equals("none") || 
0: 			(!(new File(policyFile)).exists()) ||
0: 			!(new File(policyFile)).exists())
0: 		{
0: 			System.out.println("WARNING: Running without Security manager." +
0: 							   "serverPolicy(" + policyFile + 
0: 							   ") or serverCodeBase(" +  serverCodeBase + 
0: 							   ") not available");
0: 		return;
0: 		}
0: 		this.D.addElement("java.security.manager");
0: 		this.D.addElement("java.security.policy=" + policyFile);
0: 		this.D.addElement("csinfo.codebase=" + serverCodeBase);
0: 		this.D.addElement("csinfo.serverhost=localhost");
0: 		this.D.addElement("csinfo.trustedhost=localhost");	 
0: 
0: 	}
0: 
0: 	/** Get the base file name from a resource name string
0: 	 * @param resourceName (e.g. /org/apache/derbyTesting/functionTests/util/nwsvr.policy)
0: 	 * @return short name (e.g. nwsvr.policy)
0: 	 */
0: 	private String baseName(String resourceName)
0: 	{
0: 	  
0: 		return resourceName.substring(resourceName.lastIndexOf("/"),resourceName.length());
0: 	}
0: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:7095131
/////////////////////////////////////////////////////////////////////////
1: 	public static String findCodeBase(boolean[] isJar)
============================================================================