1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.diag.LockTable
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.diag;
1:eac0369: 
1:eac0369: // temp
1:eac0369: import org.apache.derby.impl.services.locks.TableNameInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: import org.apache.derby.iapi.services.locks.Latch;
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.VirtualLockTable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.error.PublicAPI;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1:eac0369: 
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:eac0369: import org.apache.derby.vti.VTITemplate;
1:eac0369: import org.apache.derby.vti.VTICosting;
1:eac0369: import org.apache.derby.vti.VTIEnvironment;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	LockTable is a virtual table that shows all locks currently held in
1:eac0369: 	the database.
1:eac0369: 	
1:eac0369: 	This virtual table can be invoked by calling it directly
1:5a95e6b: 	<PRE> select * from SYSCS_DIAG.LOCK_TABLE </PRE>
1:eac0369: 	
1:eac0369: 	<P>The LockTable virtual table takes a snap shot of the lock table while
1:eac0369: 	the system is in flux, so it is possible that some locks may be in
1:eac0369: 	transition state while the snap shot is taken. We choose to do this rather
1:eac0369: 	then impose extranous timing restrictions so that the use of this tool will
1:eac0369: 	not alter the normal timing and flow of execution in the application.
1:eac0369: 
1:eac0369: 	<P>The LockTable virtual table has the following columns:
1:eac0369: 	<UL><LI>XID varchar(15) - not nullable.  The transaction id, this can be joined with the
1:eac0369: 	TransactionTable virtual table's XID.</LI>
1:eac0369: 	<LI>TYPE varchar(5) - nullable.  The type of lock, ROW, TABLE, or LATCH</LI>
1:eac0369: 	<LI>MODE varchar(4) - not nullable.  The mode of the lock, "S", "U", "X", "IS", "IX".</LI>
1:eac0369: 		<UL><LI>S is shared lock (N/A to Latch) </LI>
1:eac0369: 			<LI>U is update lock (N/A to Latch) </LI>
1:eac0369: 			<LI>X is exclusive lock </LI>
1:eac0369: 			<LI>IS is intent shared lock (N/A to Latch or Row lock) </LI>
1:eac0369: 			<LI>IX is intent exclusive lock (N/A to Latch or Row lock) </LI>
1:eac0369: 		</UL>
1:eac0369: 	<LI>TABLENAME varchar(128) - not nullable. The name of the base table the lock is for </LI>
1:eac0369: 	<LI>LOCKNAME varchar(20) - not nullable.  The name of the lock </LI>
1:eac0369: 	<LI>STATE varchar(5) - nullable.  GRANT or WAIT </LI>
1:eac0369: 	<LI>TABLETYPE varchar(9) - not nullable.  'T' for user table, 'S' for system table </LI>
1:eac0369: 	<LI>LOCKCOUNT varchar(5) - not nullable.  Internal lock count.</LI>
1:eac0369: 	<LI>INDEXNAME varchar(128) - normally null.  If non-null, a lock is held on 
1:0570534: 	the index.</LI>
1:eac0369: 	</UL>
1:eac0369: 
1:eac0369:  */
1:4dede3b: public class LockTable extends VTITemplate implements VTICosting  {
1:eac0369: 
1:eac0369: 	/** return only latches */
1:eac0369: 	public static final int LATCH = VirtualLockTable.LATCH;
1:eac0369: 
1:eac0369: 	/** return only table and row locks */
1:eac0369: 	public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
1:eac0369: 
1:eac0369: 	/** return all locks and latches */
1:eac0369: 	public static final int ALL = VirtualLockTable.ALL;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** private 
1:eac0369: 	*/
1:eac0369: 	private TransactionController tc;
1:eac0369: 	private Hashtable currentRow;		// an entry in the lock table
1:eac0369: 	private Enumeration lockTable;	
1:eac0369: 	private boolean wasNull;
1:eac0369: 	private boolean initialized;
1:eac0369: 	private final int flag;
1:eac0369: 	private TableNameInfo tabInfo;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The normal way of instantiating a LockTable, equivalent to
1:dbed020: 		LockTable(org.apache.derby.diag.LockTable-&gt;TABLE_AND_ROWLOCK).
1:eac0369: 		Only shows row and table lock and not latches.  Latches are generally
1:2c21843: 		held for very short duration and are not of interest to Derby 
1:eac0369: 		users.  Only under abnormal circumstances will one be interested in
1:eac0369: 		looking at latches.
1:eac0369: 	 */
1:eac0369: 	public LockTable()
1:eac0369: 	{
1:eac0369: 		flag = TABLE_AND_ROWLOCK;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This call is intrusive and should only be used under the supervision of
1:eac0369: 		technical support.  Create an instance of the lock table which
1:eac0369: 		has transient latches as well as locks.
1:eac0369: 	 */
1:eac0369: 	public LockTable(int flag)
1:eac0369: 	{
1:eac0369: 		this.flag = flag;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#getMetaData
1:eac0369: 	 */
1:eac0369: 	public ResultSetMetaData getMetaData()
1:eac0369: 	{
1:eac0369: 		return metadata;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#next
1:eac0369: 		@exception SQLException if no transaction context can be found, or other
1:2c21843: 		Derby internal errors are encountered.
1:eac0369: 	 */
1:eac0369: 	public boolean next() throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (!initialized)
1:eac0369: 			{
1:eac0369: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1:eac0369: 
1:eac0369: 				tc = lcc.getTransactionExecute();
1:1985a18: 				LockFactory lf = tc.getAccessManager().getLockFactory();
1:eac0369: 				lockTable = lf.makeVirtualLockTable();
1:eac0369: 				initialized = true;
1:eac0369: 				tabInfo = new TableNameInfo(lcc, true);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			currentRow = null;
1:eac0369: 			if (lockTable != null) {
1:eac0369: 				while (lockTable.hasMoreElements() && (currentRow == null)) {
1:eac0369: 					currentRow = dumpLock((Latch) lockTable.nextElement());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return (currentRow != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#close
1:eac0369: 	 */
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		lockTable = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		All columns in TransactionTable VTI are of String type.
1:eac0369: 		@see java.sql.ResultSet#getString
1:eac0369: 	 */
1:eac0369: 	public String getString(int columnNumber)
1:eac0369: 	{		
1:eac0369: 		String val = (String)currentRow.get(columnInfo[columnNumber-1].getName());
1:eac0369: 		wasNull = (val == null);
1:eac0369: 
1:eac0369: 		return  val;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#wasNull
1:eac0369: 	 */
1:eac0369: 	public boolean wasNull()
1:eac0369: 	{
1:eac0369: 		return wasNull;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**  VTI costing interface */
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		@see VTICosting#getEstimatedRowCount
1:eac0369: 	 */
1:eac0369: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return VTICosting.defaultEstimatedRowCount;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		@see VTICosting#getEstimatedCostPerInstantiation
1:eac0369: 	 */
1:eac0369: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return VTICosting.defaultEstimatedCost;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		@return false
1:eac0369: 		@see VTICosting#supportsMultipleInstantiations
1:eac0369: 	 */
1:eac0369: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Private methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Convert the lock information into a hashtable.
1:eac0369: 	*/
1:0758fb6:     private Hashtable<String,Object> dumpLock(
1:eac0369:     Latch                   lock)
1:eac0369:         throws StandardException
1:eac0369:     {
1:0758fb6: 		Hashtable<String,Object>	attributes = new Hashtable<String,Object>(17);
1:eac0369:         Object      lock_type =  lock.getQualifier();
1:eac0369: 
1:eac0369: 
1:eac0369: 		// 4 things we are interested in from the lockable:
1:eac0369: 		// containerId, segmentId, pageNum, recId
1:eac0369: 
1:eac0369: 		Lockable lockable = lock.getLockable();
1:eac0369: 
1:eac0369: 		// see if this lockable object wants to participate
1:eac0369: 		if (!lockable.lockAttributes(flag, attributes))
1:eac0369: 			return null;				
1:eac0369: 
1:eac0369: 		// if it does, the lockable object must have filled in the following
1:eac0369: 		// fields
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null,
1:eac0369: 			 "lock table can only represent locks that have a LOCKNAME");
1:eac0369: 
1:eac0369: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null,
1:eac0369: 			 "lock table can only represent locks that have a LOCKTYPE");
1:eac0369: 
1:eac0369: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null &&
1:eac0369: 				attributes.get(VirtualLockTable.CONGLOMID) == null)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 			 "lock table can only represent locks that are associated with a container or conglomerate");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (attributes.get(VirtualLockTable.LOCKNAME) == null ||
1:eac0369: 			attributes.get(VirtualLockTable.LOCKTYPE) == null)
1:eac0369: 			return null;				// can't deal with this for now
1:eac0369: 
1:eac0369: 		// if the lock has zero count and is an instance of Lock then it
1:eac0369: 		// is a lock that has just been released. Therefore do put it into
1:eac0369: 		// the lock table. This occurs because the Lock object is the real
1:eac0369: 		// live object in the LockTable. Thus when we copied the lock table
1:eac0369: 		// it had a non-zero count, but since then it has been released
1:eac0369: 		// (after we dropped the sync). Note if it is of type ActiveLock
1:eac0369: 		// with zero count there is stil the chance it has been released.
1:eac0369: 		// Less likely, but we still need to fix that at some time.
1:eac0369: 		int lockCount = lock.getCount();
1:eac0369: 		String state;
1:eac0369: 		if (lockCount != 0)
1:eac0369: 			state = "GRANT";
1:eac0369: 		else if (!(lock instanceof org.apache.derby.impl.services.locks.ActiveLock))
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			state = "WAIT";
1:eac0369: 
1:eac0369: 		Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
1:eac0369: 
1:eac0369: 		if (conglomId == null)
1:eac0369: 		{
1:eac0369: 			// we need to figure this out
1:eac0369: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null)
1:eac0369: 				return null; // can't deal with this for now
1:eac0369: 
1:eac0369: 			Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
1:ce40a31: 			conglomId = tc.findConglomid(value.longValue());
1:eac0369: 			attributes.put(VirtualLockTable.CONGLOMID, conglomId);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attributes.put(VirtualLockTable.LOCKOBJ, lock);
1:3c1f634: 		Object owner = lock.getCompatabilitySpace().getOwner();
1:3c1f634: 		attributes.put(VirtualLockTable.XACTID,
1:3c1f634: 					   (owner == null) ? "<null>" : owner.toString());
1:eac0369: 		attributes.put(VirtualLockTable.LOCKMODE, lock_type.toString());
1:eac0369: 
1:eac0369: 		attributes.put(VirtualLockTable.LOCKCOUNT, Integer.toString(lockCount));
1:eac0369: 
1:eac0369: 		attributes.put(VirtualLockTable.STATE, state);
1:eac0369: 
1:eac0369: 		String tableName = tabInfo.getTableName(conglomId);
1:eac0369: 
1:eac0369: 		attributes.put(VirtualLockTable.TABLENAME, tableName);
1:eac0369: 
1:eac0369: 		String indexName = tabInfo.getIndexName(conglomId);
1:eac0369: 
1:eac0369: 		if (indexName != null)
1:eac0369: 			attributes.put(VirtualLockTable.INDEXNAME, indexName);
1:eac0369: 
1:eac0369: 		String tableType = tabInfo.getTableType(conglomId);
1:eac0369: 		attributes.put(VirtualLockTable.TABLETYPE, tableType);
1:eac0369: 		return attributes;
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Metadata
1:eac0369: 	*/
1:eac0369: 	private static final ResultColumnDescriptor[] columnInfo = {
1:eac0369: 
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.XACTID,    Types.VARCHAR, false, 15),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKTYPE,  Types.VARCHAR, true, 5),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKMODE,  Types.VARCHAR, false, 4),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLENAME, Types.VARCHAR, false, 128),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKNAME,  Types.VARCHAR, false, 20),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.STATE,     Types.VARCHAR, true, 5),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLETYPE, Types.VARCHAR, false, 9),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKCOUNT, Types.VARCHAR, false, 5),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.INDEXNAME, Types.VARCHAR, true,  128)
1:eac0369: 	};
1:eac0369: 	
1:8514aa2:     private static final ResultSetMetaData metadata =
1:8514aa2:         new EmbedResultSetMetaData(columnInfo);
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		LockTable(org.apache.derby.diag.LockTable-&gt;TABLE_AND_ROWLOCK).
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			conglomId = tc.findConglomid(value.longValue());
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData40;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData40(columnInfo);
commit:0758fb6
/////////////////////////////////////////////////////////////////////////
1:     private Hashtable<String,Object> dumpLock(
1: 		Hashtable<String,Object>	attributes = new Hashtable<String,Object>(17);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final ResultSetMetaData metadata =
1:         new EmbedResultSetMetaData(columnInfo);
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: 		Object owner = lock.getCompatabilitySpace().getOwner();
1: 		attributes.put(VirtualLockTable.XACTID,
1: 					   (owner == null) ? "<null>" : owner.toString());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:0570534
/////////////////////////////////////////////////////////////////////////
1: 	the index.</LI>
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2c21843
/////////////////////////////////////////////////////////////////////////
1: 		held for very short duration and are not of interest to Derby 
/////////////////////////////////////////////////////////////////////////
1: 		Derby internal errors are encountered.
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1985a18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				LockFactory lf = tc.getAccessManager().getLockFactory();
commit:5a95e6b
/////////////////////////////////////////////////////////////////////////
1: 	<PRE> select * from SYSCS_DIAG.LOCK_TABLE </PRE>
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.diag.LockTable
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
1: public class LockTable extends VTITemplate implements VTICosting  {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.diag;
1: 
1: // temp
1: import org.apache.derby.impl.services.locks.TableNameInfo;
1: 
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.locks.Latch;
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.error.PublicAPI;
1: 
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1: 
1: import java.util.Hashtable;
1: import java.util.Enumeration;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: import org.apache.derby.vti.VTITemplate;
1: import org.apache.derby.vti.VTICosting;
1: import org.apache.derby.vti.VTIEnvironment;
1: 
1: /**
1: 	LockTable is a virtual table that shows all locks currently held in
1: 	the database.
1: 	
1: 	This virtual table can be invoked by calling it directly
0: 	<PRE> select * from new org.apache.derby.diag.LockTable() t; </PRE>
0: 	or through the system alias LOCKTABLE
0: 	<PRE> select * from new LOCKTABLE() t; </PRE> 
1: 	
1: 	<P>The LockTable virtual table takes a snap shot of the lock table while
1: 	the system is in flux, so it is possible that some locks may be in
1: 	transition state while the snap shot is taken. We choose to do this rather
1: 	then impose extranous timing restrictions so that the use of this tool will
1: 	not alter the normal timing and flow of execution in the application.
1: 
1: 	<P>The LockTable virtual table has the following columns:
1: 	<UL><LI>XID varchar(15) - not nullable.  The transaction id, this can be joined with the
1: 	TransactionTable virtual table's XID.</LI>
1: 	<LI>TYPE varchar(5) - nullable.  The type of lock, ROW, TABLE, or LATCH</LI>
1: 	<LI>MODE varchar(4) - not nullable.  The mode of the lock, "S", "U", "X", "IS", "IX".</LI>
1: 		<UL><LI>S is shared lock (N/A to Latch) </LI>
1: 			<LI>U is update lock (N/A to Latch) </LI>
1: 			<LI>X is exclusive lock </LI>
1: 			<LI>IS is intent shared lock (N/A to Latch or Row lock) </LI>
1: 			<LI>IX is intent exclusive lock (N/A to Latch or Row lock) </LI>
1: 		</UL>
1: 	<LI>TABLENAME varchar(128) - not nullable. The name of the base table the lock is for </LI>
1: 	<LI>LOCKNAME varchar(20) - not nullable.  The name of the lock </LI>
1: 	<LI>STATE varchar(5) - nullable.  GRANT or WAIT </LI>
1: 	<LI>TABLETYPE varchar(9) - not nullable.  'T' for user table, 'S' for system table </LI>
1: 	<LI>LOCKCOUNT varchar(5) - not nullable.  Internal lock count.</LI>
1: 	<LI>INDEXNAME varchar(128) - normally null.  If non-null, a lock is held on 
0: 	the index, this can only happen if this is not a user transaction.</LI>
1: 	</UL>
1: 
1:  */
0: public class LockTable extends VTITemplate implements VTICosting  { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1: 	/** return only latches */
1: 	public static final int LATCH = VirtualLockTable.LATCH;
1: 
1: 	/** return only table and row locks */
1: 	public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
1: 
1: 	/** return all locks and latches */
1: 	public static final int ALL = VirtualLockTable.ALL;
1: 
1: 	/*
1: 	** private 
1: 	*/
1: 	private TransactionController tc;
0: 	private LanguageConnectionFactory lcf;
1: 	private Hashtable currentRow;		// an entry in the lock table
1: 	private Enumeration lockTable;	
1: 	private boolean wasNull;
1: 	private boolean initialized;
1: 	private final int flag;
1: 	private TableNameInfo tabInfo;
1: 
1: 	/**
1: 		The normal way of instantiating a LockTable, equivalent to
0: 		LockTable(org.apache.derby.diag.LockTable->TABLE_AND_ROWLOCK).
1: 		Only shows row and table lock and not latches.  Latches are generally
0: 		held for very short duration and are not of interest to Cloudscape
1: 		users.  Only under abnormal circumstances will one be interested in
1: 		looking at latches.
1: 	 */
1: 	public LockTable()
1: 	{
1: 		flag = TABLE_AND_ROWLOCK;
1: 	}
1: 
1: 	/**
1: 		This call is intrusive and should only be used under the supervision of
1: 		technical support.  Create an instance of the lock table which
1: 		has transient latches as well as locks.
1: 	 */
1: 	public LockTable(int flag)
1: 	{
1: 		this.flag = flag;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#getMetaData
1: 	 */
1: 	public ResultSetMetaData getMetaData()
1: 	{
1: 		return metadata;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#next
1: 		@exception SQLException if no transaction context can be found, or other
0: 		Cloudscape internal errors are encountered.
1: 	 */
1: 	public boolean next() throws SQLException
1: 	{
1: 		try
1: 		{
1: 			if (!initialized)
1: 			{
1: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1: 
1: 				tc = lcc.getTransactionExecute();
0: 				LanguageConnectionFactory lcf = lcc.getLanguageConnectionFactory();
0: 				LockFactory lf = lcf.getAccessFactory().getLockFactory();
1: 				lockTable = lf.makeVirtualLockTable();
1: 				initialized = true;
1: 				tabInfo = new TableNameInfo(lcc, true);
1: 			}
1: 
1: 			currentRow = null;
1: 			if (lockTable != null) {
1: 				while (lockTable.hasMoreElements() && (currentRow == null)) {
1: 					currentRow = dumpLock((Latch) lockTable.nextElement());
1: 				}
1: 			}
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 
1: 		return (currentRow != null);
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#close
1: 	 */
1: 	public void close()
1: 	{
1: 		lockTable = null;
1: 	}
1: 
1: 	/**
1: 		All columns in TransactionTable VTI are of String type.
1: 		@see java.sql.ResultSet#getString
1: 	 */
1: 	public String getString(int columnNumber)
1: 	{		
1: 		String val = (String)currentRow.get(columnInfo[columnNumber-1].getName());
1: 		wasNull = (val == null);
1: 
1: 		return  val;
1: 	}
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#wasNull
1: 	 */
1: 	public boolean wasNull()
1: 	{
1: 		return wasNull;
1: 	}
1: 
1: 	/**  VTI costing interface */
1: 	
1: 	/**
1: 		@see VTICosting#getEstimatedRowCount
1: 	 */
1: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return VTICosting.defaultEstimatedRowCount;
1: 	}
1: 	
1: 	/**
1: 		@see VTICosting#getEstimatedCostPerInstantiation
1: 	 */
1: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return VTICosting.defaultEstimatedCost;
1: 	}
1: 	/**
1: 		@return false
1: 		@see VTICosting#supportsMultipleInstantiations
1: 	 */
1: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/*
1: 	** Private methods
1: 	*/
1: 
1: 	/**
1: 		Convert the lock information into a hashtable.
1: 	*/
0:     private Hashtable dumpLock(
1:     Latch                   lock)
1:         throws StandardException
1:     {
0: 		Hashtable	attributes = new Hashtable(17);
1:         Object      lock_type =  lock.getQualifier();
1: 
1: 
1: 		// 4 things we are interested in from the lockable:
1: 		// containerId, segmentId, pageNum, recId
1: 
1: 		Lockable lockable = lock.getLockable();
1: 
1: 		// see if this lockable object wants to participate
1: 		if (!lockable.lockAttributes(flag, attributes))
1: 			return null;				
1: 
1: 		// if it does, the lockable object must have filled in the following
1: 		// fields
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null,
1: 			 "lock table can only represent locks that have a LOCKNAME");
1: 
1: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null,
1: 			 "lock table can only represent locks that have a LOCKTYPE");
1: 
1: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null &&
1: 				attributes.get(VirtualLockTable.CONGLOMID) == null)
1: 				SanityManager.THROWASSERT(
1: 			 "lock table can only represent locks that are associated with a container or conglomerate");
1: 		}
1: 
1: 		if (attributes.get(VirtualLockTable.LOCKNAME) == null ||
1: 			attributes.get(VirtualLockTable.LOCKTYPE) == null)
1: 			return null;				// can't deal with this for now
1: 
1: 		// if the lock has zero count and is an instance of Lock then it
1: 		// is a lock that has just been released. Therefore do put it into
1: 		// the lock table. This occurs because the Lock object is the real
1: 		// live object in the LockTable. Thus when we copied the lock table
1: 		// it had a non-zero count, but since then it has been released
1: 		// (after we dropped the sync). Note if it is of type ActiveLock
1: 		// with zero count there is stil the chance it has been released.
1: 		// Less likely, but we still need to fix that at some time.
1: 		int lockCount = lock.getCount();
1: 		String state;
1: 		if (lockCount != 0)
1: 			state = "GRANT";
1: 		else if (!(lock instanceof org.apache.derby.impl.services.locks.ActiveLock))
1: 			return null;
1: 		else
1: 			state = "WAIT";
1: 
1: 		Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
1: 
1: 		if (conglomId == null)
1: 		{
1: 			// we need to figure this out
1: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null)
1: 				return null; // can't deal with this for now
1: 
1: 			Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
0: 			conglomId = new Long(tc.findConglomid(value.longValue()));
1: 			attributes.put(VirtualLockTable.CONGLOMID, conglomId);
1: 		}
1: 
1: 		attributes.put(VirtualLockTable.LOCKOBJ, lock);
0: 		attributes.put(VirtualLockTable.XACTID, lock.getCompatabilitySpace().toString());
1: 		attributes.put(VirtualLockTable.LOCKMODE, lock_type.toString());
1: 
1: 		attributes.put(VirtualLockTable.LOCKCOUNT, Integer.toString(lockCount));
1: 
1: 		attributes.put(VirtualLockTable.STATE, state);
1: 
1: 		String tableName = tabInfo.getTableName(conglomId);
1: 
1: 		attributes.put(VirtualLockTable.TABLENAME, tableName);
1: 
1: 		String indexName = tabInfo.getIndexName(conglomId);
1: 
1: 		if (indexName != null)
1: 			attributes.put(VirtualLockTable.INDEXNAME, indexName);
1: 
1: 		String tableType = tabInfo.getTableType(conglomId);
1: 		attributes.put(VirtualLockTable.TABLETYPE, tableType);
1: 		return attributes;
1: 
1:     }
1: 
1: 	/*
1: 	** Metadata
1: 	*/
1: 	private static final ResultColumnDescriptor[] columnInfo = {
1: 
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.XACTID,    Types.VARCHAR, false, 15),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKTYPE,  Types.VARCHAR, true, 5),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKMODE,  Types.VARCHAR, false, 4),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLENAME, Types.VARCHAR, false, 128),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKNAME,  Types.VARCHAR, false, 20),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.STATE,     Types.VARCHAR, true, 5),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLETYPE, Types.VARCHAR, false, 9),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKCOUNT, Types.VARCHAR, false, 5),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.INDEXNAME, Types.VARCHAR, true,  128)
1: 	};
1: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.diag;
0: 
0: // temp
0: import org.apache.derby.impl.services.locks.TableNameInfo;
0: 
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.locks.Latch;
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.error.PublicAPI;
0: 
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Types;
0: import org.apache.derby.vti.VTITemplate;
0: import org.apache.derby.vti.VTICosting;
0: import org.apache.derby.vti.VTIEnvironment;
0: 
0: /**
0: 	LockTable is a virtual table that shows all locks currently held in
0: 	the database.
0: 	
0: 	This virtual table can be invoked by calling it directly
0: 	<PRE> select * from new org.apache.derby.diag.LockTable() t; </PRE>
0: 	or through the system alias LOCKTABLE
0: 	<PRE> select * from new LOCKTABLE() t; </PRE> 
0: 	
0: 	<P>The LockTable virtual table takes a snap shot of the lock table while
0: 	the system is in flux, so it is possible that some locks may be in
0: 	transition state while the snap shot is taken. We choose to do this rather
0: 	then impose extranous timing restrictions so that the use of this tool will
0: 	not alter the normal timing and flow of execution in the application.
0: 
0: 	<P>The LockTable virtual table has the following columns:
0: 	<UL><LI>XID varchar(15) - not nullable.  The transaction id, this can be joined with the
0: 	TransactionTable virtual table's XID.</LI>
0: 	<LI>TYPE varchar(5) - nullable.  The type of lock, ROW, TABLE, or LATCH</LI>
0: 	<LI>MODE varchar(4) - not nullable.  The mode of the lock, "S", "U", "X", "IS", "IX".</LI>
0: 		<UL><LI>S is shared lock (N/A to Latch) </LI>
0: 			<LI>U is update lock (N/A to Latch) </LI>
0: 			<LI>X is exclusive lock </LI>
0: 			<LI>IS is intent shared lock (N/A to Latch or Row lock) </LI>
0: 			<LI>IX is intent exclusive lock (N/A to Latch or Row lock) </LI>
0: 		</UL>
0: 	<LI>TABLENAME varchar(128) - not nullable. The name of the base table the lock is for </LI>
0: 	<LI>LOCKNAME varchar(20) - not nullable.  The name of the lock </LI>
0: 	<LI>STATE varchar(5) - nullable.  GRANT or WAIT </LI>
0: 	<LI>TABLETYPE varchar(9) - not nullable.  'T' for user table, 'S' for system table </LI>
0: 	<LI>LOCKCOUNT varchar(5) - not nullable.  Internal lock count.</LI>
0: 	<LI>INDEXNAME varchar(128) - normally null.  If non-null, a lock is held on 
0: 	the index, this can only happen if this is not a user transaction.</LI>
0: 	</UL>
0: 
0:  */
0: public class LockTable extends VTITemplate implements VTICosting  { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	/** return only latches */
0: 	public static final int LATCH = VirtualLockTable.LATCH;
0: 
0: 	/** return only table and row locks */
0: 	public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
0: 
0: 	/** return all locks and latches */
0: 	public static final int ALL = VirtualLockTable.ALL;
0: 
0: 	/*
0: 	** private 
0: 	*/
0: 	private TransactionController tc;
0: 	private LanguageConnectionFactory lcf;
0: 	private Hashtable currentRow;		// an entry in the lock table
0: 	private Enumeration lockTable;	
0: 	private boolean wasNull;
0: 	private boolean initialized;
0: 	private final int flag;
0: 	private TableNameInfo tabInfo;
0: 
0: 	/**
0: 		The normal way of instantiating a LockTable, equivalent to
0: 		LockTable(org.apache.derby.diag.LockTable->TABLE_AND_ROWLOCK).
0: 		Only shows row and table lock and not latches.  Latches are generally
0: 		held for very short duration and are not of interest to Cloudscape
0: 		users.  Only under abnormal circumstances will one be interested in
0: 		looking at latches.
0: 	 */
0: 	public LockTable()
0: 	{
0: 		flag = TABLE_AND_ROWLOCK;
0: 	}
0: 
0: 	/**
0: 		This call is intrusive and should only be used under the supervision of
0: 		technical support.  Create an instance of the lock table which
0: 		has transient latches as well as locks.
0: 	 */
0: 	public LockTable(int flag)
0: 	{
0: 		this.flag = flag;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#getMetaData
0: 	 */
0: 	public ResultSetMetaData getMetaData()
0: 	{
0: 		return metadata;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#next
0: 		@exception SQLException if no transaction context can be found, or other
0: 		Cloudscape internal errors are encountered.
0: 	 */
0: 	public boolean next() throws SQLException
0: 	{
0: 		try
0: 		{
0: 			if (!initialized)
0: 			{
0: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
0: 
0: 				tc = lcc.getTransactionExecute();
0: 				LanguageConnectionFactory lcf = lcc.getLanguageConnectionFactory();
0: 				LockFactory lf = lcf.getAccessFactory().getLockFactory();
0: 				lockTable = lf.makeVirtualLockTable();
0: 				initialized = true;
0: 				tabInfo = new TableNameInfo(lcc, true);
0: 			}
0: 
0: 			currentRow = null;
0: 			if (lockTable != null) {
0: 				while (lockTable.hasMoreElements() && (currentRow == null)) {
0: 					currentRow = dumpLock((Latch) lockTable.nextElement());
0: 				}
0: 			}
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 
0: 		return (currentRow != null);
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#close
0: 	 */
0: 	public void close()
0: 	{
0: 		lockTable = null;
0: 	}
0: 
0: 	/**
0: 		All columns in TransactionTable VTI are of String type.
0: 		@see java.sql.ResultSet#getString
0: 	 */
0: 	public String getString(int columnNumber)
0: 	{		
0: 		String val = (String)currentRow.get(columnInfo[columnNumber-1].getName());
0: 		wasNull = (val == null);
0: 
0: 		return  val;
0: 	}
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#wasNull
0: 	 */
0: 	public boolean wasNull()
0: 	{
0: 		return wasNull;
0: 	}
0: 
0: 	/**  VTI costing interface */
0: 	
0: 	/**
0: 		@see VTICosting#getEstimatedRowCount
0: 	 */
0: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return VTICosting.defaultEstimatedRowCount;
0: 	}
0: 	
0: 	/**
0: 		@see VTICosting#getEstimatedCostPerInstantiation
0: 	 */
0: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return VTICosting.defaultEstimatedCost;
0: 	}
0: 	/**
0: 		@return false
0: 		@see VTICosting#supportsMultipleInstantiations
0: 	 */
0: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/*
0: 	** Private methods
0: 	*/
0: 
0: 	/**
0: 		Convert the lock information into a hashtable.
0: 	*/
0:     private Hashtable dumpLock(
0:     Latch                   lock)
0:         throws StandardException
0:     {
0: 		Hashtable	attributes = new Hashtable(17);
0:         Object      lock_type =  lock.getQualifier();
0: 
0: 
0: 		// 4 things we are interested in from the lockable:
0: 		// containerId, segmentId, pageNum, recId
0: 
0: 		Lockable lockable = lock.getLockable();
0: 
0: 		// see if this lockable object wants to participate
0: 		if (!lockable.lockAttributes(flag, attributes))
0: 			return null;				
0: 
0: 		// if it does, the lockable object must have filled in the following
0: 		// fields
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null,
0: 			 "lock table can only represent locks that have a LOCKNAME");
0: 
0: 			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null,
0: 			 "lock table can only represent locks that have a LOCKTYPE");
0: 
0: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null &&
0: 				attributes.get(VirtualLockTable.CONGLOMID) == null)
0: 				SanityManager.THROWASSERT(
0: 			 "lock table can only represent locks that are associated with a container or conglomerate");
0: 		}
0: 
0: 		if (attributes.get(VirtualLockTable.LOCKNAME) == null ||
0: 			attributes.get(VirtualLockTable.LOCKTYPE) == null)
0: 			return null;				// can't deal with this for now
0: 
0: 		// if the lock has zero count and is an instance of Lock then it
0: 		// is a lock that has just been released. Therefore do put it into
0: 		// the lock table. This occurs because the Lock object is the real
0: 		// live object in the LockTable. Thus when we copied the lock table
0: 		// it had a non-zero count, but since then it has been released
0: 		// (after we dropped the sync). Note if it is of type ActiveLock
0: 		// with zero count there is stil the chance it has been released.
0: 		// Less likely, but we still need to fix that at some time.
0: 		int lockCount = lock.getCount();
0: 		String state;
0: 		if (lockCount != 0)
0: 			state = "GRANT";
0: 		else if (!(lock instanceof org.apache.derby.impl.services.locks.ActiveLock))
0: 			return null;
0: 		else
0: 			state = "WAIT";
0: 
0: 		Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
0: 
0: 		if (conglomId == null)
0: 		{
0: 			// we need to figure this out
0: 			if (attributes.get(VirtualLockTable.CONTAINERID) == null)
0: 				return null; // can't deal with this for now
0: 
0: 			Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
0: 			conglomId = new Long(tc.findConglomid(value.longValue()));
0: 			attributes.put(VirtualLockTable.CONGLOMID, conglomId);
0: 		}
0: 
0: 		attributes.put(VirtualLockTable.LOCKOBJ, lock);
0: 		attributes.put(VirtualLockTable.XACTID, lock.getCompatabilitySpace().toString());
0: 		attributes.put(VirtualLockTable.LOCKMODE, lock_type.toString());
0: 
0: 		attributes.put(VirtualLockTable.LOCKCOUNT, Integer.toString(lockCount));
0: 
0: 		attributes.put(VirtualLockTable.STATE, state);
0: 
0: 		String tableName = tabInfo.getTableName(conglomId);
0: 
0: 		attributes.put(VirtualLockTable.TABLENAME, tableName);
0: 
0: 		String indexName = tabInfo.getIndexName(conglomId);
0: 
0: 		if (indexName != null)
0: 			attributes.put(VirtualLockTable.INDEXNAME, indexName);
0: 
0: 		String tableType = tabInfo.getTableType(conglomId);
0: 		attributes.put(VirtualLockTable.TABLETYPE, tableType);
0: 		return attributes;
0: 
0:     }
0: 
0: 	/*
0: 	** Metadata
0: 	*/
0: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.XACTID,    Types.VARCHAR, false, 15),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKTYPE,  Types.VARCHAR, true, 5),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKMODE,  Types.VARCHAR, false, 4),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLENAME, Types.VARCHAR, false, 128),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKNAME,  Types.VARCHAR, false, 20),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.STATE,     Types.VARCHAR, true, 5),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.TABLETYPE, Types.VARCHAR, false, 9),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.LOCKCOUNT, Types.VARCHAR, false, 5),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor(VirtualLockTable.INDEXNAME, Types.VARCHAR, true,  128)
0: 	};
0: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
0: }
0: 
============================================================================