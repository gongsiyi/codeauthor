2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.NormalizeResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
16:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:b31849d: import org.apache.derby.iapi.sql.ResultDescription;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:b31849d: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:b31849d: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b31849d: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Cast the rows from the source result set to match the format of the
1:eac0369:  * result set for the entire statement.
1:eac0369:  */
1:eac0369: 
1:f77f36d: class NormalizeResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet
4:eac0369: {
1:eac0369: 	/*
1:eac0369:     ** Set in constructor and not altered during life of object.
1:eac0369: 	*/
1:ec4aa98: 
1:eac0369:     public NoPutResultSet	source;
1:eac0369: 	private	ExecRow			normalizedRow;
1:eac0369: 	private	int				numCols;
1:eac0369: 	private int				startCol;
1:ec4aa98: 
1:0b97566:     /**
1:0b97566:      * This array contains data value descriptors that can be used (and reused)
1:0b97566:      * by normalizeRow() to hold the normalized column values.
1:0b97566:      */
1:0b97566:     private final DataValueDescriptor[] cachedDestinations;
1:0b97566: 
1:eac0369: 	/* RESOLVE - We need to pass the ResultDescription for this ResultSet
1:eac0369: 	 * as a parameter to the constructor and use it instead of the one from
1:eac0369: 	 * the activation
1:eac0369: 	 */
1:eac0369: 	private ResultDescription resultDescription;
1:eac0369: 
1:eac0369: 	/* info for caching DTSs */
1:eac0369: 	private DataTypeDescriptor[] desiredTypes;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a NormalizeResultSet
3:eac0369: 	 *
1:eac0369: 	 * @param source					The NoPutResultSet from which to get rows
1:eac0369: 	 *									to be normalized
1:eac0369: 	 * @param activation				The activation for this execution
1:eac0369: 	 * @param resultSetNumber			The resultSetNumber
1:eac0369: 	 * @param erdNumber					The integer for the ResultDescription
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NormalizeResultSet(NoPutResultSet source,
1:eac0369: 							  Activation activation, int resultSetNumber,
1:eac0369: 							  int erdNumber,
1:eac0369: 	 					      double optimizerEstimatedRowCount,
1:eac0369: 							  double optimizerEstimatedCost,
1:f77f36d: 							  boolean forUpdate) throws StandardException
1:eac0369: 	{
1:eac0369: 		super(activation, resultSetNumber, optimizerEstimatedRowCount, 
1:eac0369: 			  optimizerEstimatedCost);
1:eac0369: 		this.source = source;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (! (activation.getPreparedStatement().getSavedObject(erdNumber)
1:eac0369: 							 instanceof ResultDescription))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"activation.getPreparedStatement().getSavedObject(erdNumber) " +
1:eac0369: 					"expected to be instanceof ResultDescription");
6:eac0369: 			}
1:eac0369: 
1:eac0369: 			// source expected to be non-null, mystery stress test bug
1:eac0369: 			// - sometimes get NullPointerException in openCore().
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"NRS(), source expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.resultDescription = 
1:eac0369: 			(ResultDescription) activation.getPreparedStatement().getSavedObject(erdNumber);
1:eac0369: 
1:eac0369: 		numCols = resultDescription.getColumnCount();
1:eac0369: 		
1:ec4aa98: 		startCol = computeStartColumn( forUpdate, resultDescription );
1:eac0369: 		normalizedRow = activation.getExecutionFactory().getValueRow(numCols);
1:0b97566:         cachedDestinations = new DataValueDescriptor[numCols];
1:7008b63: 		recordConstructorTime();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the source. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "NormalizeResultSet already open");
1:eac0369: 
1:eac0369: 		// source expected to be non-null, mystery stress test bug
1:eac0369: 		// - sometimes get NullPointerException in openCore().
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"NRS().openCore(), source expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369:         source.openCore();
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * reopen a scan on the table. scan parameters are evaluated
1:eac0369: 	 * at each open, so there is probably some way of altering
1:eac0369: 	 * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public void	reopenCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT(isOpen, "NormalizeResultSet already open");
1:eac0369: 
1:eac0369: 		source.reopenCore();
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		ExecRow		sourceRow = null;
1:eac0369: 		ExecRow		result = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (!isOpen)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1:eac0369: 
1:eac0369: 		sourceRow = source.getNextRowCore();
1:eac0369: 		if (sourceRow != null)
1:eac0369: 		{
1:eac0369: 			result = normalizeRow(sourceRow);
1:eac0369: 			rowsSeen++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			currentRow = null;
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of NormalizeResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:ec4aa98: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from its source. We might want
1:eac0369: 	 * to have this take a CursorResultSet in its constructor some day,
1:eac0369: 	 * instead of doing a cast here?
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not a cursorresultset");
1:eac0369: 		return ( (CursorResultSet)source ).getRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from last getNextRow call.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() 
1:eac0369: 	{
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:ec4aa98:     /**
1:ec4aa98:      * <p>
1:ec4aa98:      * Compute the start column for an update/insert.
1:4e6df7a:      *
1:4e6df7a:      * @param isUpdate  True if we are executing an UPDATE statement
1:4e6df7a:      * @param desc Metadata describing a result row
1:ec4aa98:      * </p>
1:ec4aa98:      */
1:ec4aa98:     public  static  int computeStartColumn( boolean isUpdate, ResultDescription desc )
1:ec4aa98:     {
1:ec4aa98: 		int count = desc.getColumnCount();
1:ec4aa98:         
1:ec4aa98: 		/*
1:ec4aa98: 		  An update row, for an update statement which sets n columns; i.e
1:ec4aa98: 		     UPDATE tab set x,y,z=.... where ...;
1:ec4aa98: 		  has,
1:ec4aa98: 		  before values of x,y,z after values of x,y,z and rowlocation.
1:ec4aa98: 		  need only normalize after values of x,y,z.
1:ec4aa98: 		  i.e insead of starting at index = 1, I need to start at index = 4.
1:ec4aa98: 		  also I needn't normalize the last value in the row.
1:ec4aa98:         */
1:ec4aa98: 		return (isUpdate) ? ((count - 1)/ 2) + 1 : 1;
1:ec4aa98:     }
1:ec4aa98: 
1:ec4aa98:     
1:ec4aa98: 	/**
1:4e6df7a: 	 * Normalize a column.  For now, this means calling constructors through
1:ec4aa98: 	 * the type services to normalize a type to itself.  For example,
1:ec4aa98: 	 * if you're putting a char(30) value into a char(15) column, it
1:ec4aa98: 	 * calls a SQLChar constructor with the char(30) value, and the
1:ec4aa98: 	 * constructor truncates the value and makes sure that no non-blank
1:ec4aa98: 	 * characters are truncated.
1:4e6df7a: 	 *
1:ec4aa98:      *
1:4e6df7a:      * @param dtd Data type to coerce to
1:4e6df7a:      * @param sourceRow row holding the source column
1:4e6df7a:      * @param sourceColumnPosition position of column in row
1:4e6df7a:      * @param resultCol where to stuff the coerced value
1:4e6df7a:      * @param desc Additional metadata for error reporting if necessary
1:4e6df7a:      *
1:ec4aa98:  	 * @exception StandardException thrown on failure 
1:ec4aa98: 	 */
1:ec4aa98: 	public  static  DataValueDescriptor normalizeColumn
1:ec4aa98:         (DataTypeDescriptor dtd, ExecRow sourceRow, int sourceColumnPosition, DataValueDescriptor resultCol, ResultDescription desc )
1:ec4aa98:         throws StandardException
1:ec4aa98: 	{
1:ec4aa98:         DataValueDescriptor sourceCol = sourceRow.getColumn( sourceColumnPosition );
1:ec4aa98: 
1:ec4aa98:         try {
1:ec4aa98:             DataValueDescriptor returnValue = dtd.normalize( sourceCol, resultCol );
1:ec4aa98: 
1:ec4aa98:             return returnValue;
1:ec4aa98:         } catch (StandardException se) {
1:ec4aa98:             // Catch illegal null insert and add column info
1:ec4aa98:             if (se.getMessageId().startsWith(SQLState.LANG_NULL_INTO_NON_NULL))
1:ec4aa98:             {
1:ec4aa98:                 ResultColumnDescriptor columnDescriptor = desc.getColumnDescriptor( sourceColumnPosition );
1:ec4aa98:                 throw StandardException.newException
1:ec4aa98:                     (SQLState.LANG_NULL_INTO_NON_NULL, columnDescriptor.getName());
1:ec4aa98:             }
1:ec4aa98:             //just rethrow if not LANG_NULL_INTO_NON_NULL
1:ec4aa98:             throw se;
1:ec4aa98:         }
1:ec4aa98:     }
1:ec4aa98:     
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:4e6df7a:     
1:eac0369: 	/**
1:4e6df7a: 	 * Normalize a row.
1:ec4aa98: 	 *
1:eac0369: 	 * @param sourceRow		The row to normalize
1:eac0369: 	 *
1:eac0369: 	 * @return	The normalized row
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	private ExecRow normalizeRow(ExecRow sourceRow) throws StandardException
1:eac0369: 	{
1:ec4aa98:         int                     count = resultDescription.getColumnCount();
1:eac0369: 
1:ec4aa98: 		for (int i = 1; i <= count; i++)
1:eac0369: 		{
1:ec4aa98: 			DataValueDescriptor sourceCol = sourceRow.getColumn( i );
1:eac0369: 			if (sourceCol != null)
1:eac0369: 			{
1:eac0369: 				DataValueDescriptor	normalizedCol;
1:eac0369: 				// skip the before values in case of update
1:ec4aa98: 				if (i < startCol)
1:ec4aa98:                 { normalizedCol = sourceCol; }
1:eac0369: 				else
1:ec4aa98:                 {
1:0b97566:                     normalizedCol = normalizeColumn(
1:0b97566:                             getDesiredType(i), sourceRow, i,
1:0b97566:                             getCachedDestination(i), resultDescription);
1:ec4aa98:                 }
1:eac0369: 
1:ec4aa98: 				normalizedRow.setColumn(i, normalizedCol);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return normalizedRow;
1:eac0369: 	}
1:2700e3d: 
1:2700e3d:     /**
1:0b97566:      * Get a cached data value descriptor that can receive the normalized
1:0b97566:      * value of the specified column.
1:0b97566:      *
1:0b97566:      * @param col the column number (1-based)
1:0b97566:      * @return a data value descriptor of the correct type for the column
1:0b97566:      * @throws StandardException if a new data value descriptor cannot be
1:0b97566:      * created
1:0b97566:      */
1:0b97566:     private DataValueDescriptor getCachedDestination(int col)
1:0b97566:             throws StandardException {
1:0b97566:         int index = col - 1;
1:0b97566:         if (cachedDestinations[index] == null) {
1:0b97566:             cachedDestinations[index] = getDesiredType(col).getNull();
1:0b97566:         }
1:0b97566:         return cachedDestinations[index];
1:0b97566:     }
1:0b97566: 
1:0b97566:     /**
1:0b97566:      * Get a data type descriptor that describes the desired type for the
1:0b97566:      * specified column.
1:0b97566:      *
1:0b97566:      * @param col the column number (1-based)
1:0b97566:      * @return a data type descriptor for the column
1:0b97566:      */
1:0b97566:     private DataTypeDescriptor getDesiredType(int col) {
1:0b97566:         if (desiredTypes == null) {
1:0b97566:             desiredTypes = fetchResultTypes(resultDescription);
1:0b97566:         }
1:0b97566:         return desiredTypes[col - 1];
1:0b97566:     }
1:0b97566: 
1:0b97566:     /**
1:ec4aa98:      * <p>
1:ec4aa98:      * Fetch the result datatypes out of the activation.
1:ec4aa98:      * </p>
1:ec4aa98:      */
1:0b97566:     private DataTypeDescriptor[] fetchResultTypes(ResultDescription desc)
1:ec4aa98:     {
1:ec4aa98:         int     count = desc.getColumnCount();
1:ec4aa98: 
1:ec4aa98:         DataTypeDescriptor[]    result = new DataTypeDescriptor[ count ];
1:ec4aa98:         
1:ec4aa98:         for ( int i = 1; i <= count; i++)
1:ec4aa98:         {
1:ec4aa98:             ResultColumnDescriptor  colDesc = desc.getColumnDescriptor(  i );
1:ec4aa98:             DataTypeDescriptor dtd = colDesc.getType();
1:ec4aa98: 
1:ec4aa98:             result[i - 1] = dtd;
1:ec4aa98:         }
1:ec4aa98: 
1:ec4aa98:         return result;
1:ec4aa98:     }
1:ec4aa98: 
1:eac0369: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 */
1:7d0f620: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:7d0f620: 		source.updateRow(row, rowChanger);
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException {
1:2700e3d: 		source.markRowAsDeleted();
1:2700e3d: 	}
1:2700e3d: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0b97566
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This array contains data value descriptors that can be used (and reused)
1:      * by normalizeRow() to hold the normalized column values.
1:      */
1:     private final DataValueDescriptor[] cachedDestinations;
1: 
/////////////////////////////////////////////////////////////////////////
1:         cachedDestinations = new DataValueDescriptor[numCols];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     normalizedCol = normalizeColumn(
1:                             getDesiredType(i), sourceRow, i,
1:                             getCachedDestination(i), resultDescription);
/////////////////////////////////////////////////////////////////////////
1:      * Get a cached data value descriptor that can receive the normalized
1:      * value of the specified column.
1:      *
1:      * @param col the column number (1-based)
1:      * @return a data value descriptor of the correct type for the column
1:      * @throws StandardException if a new data value descriptor cannot be
1:      * created
1:      */
1:     private DataValueDescriptor getCachedDestination(int col)
1:             throws StandardException {
1:         int index = col - 1;
1:         if (cachedDestinations[index] == null) {
1:             cachedDestinations[index] = getDesiredType(col).getNull();
1:         }
1:         return cachedDestinations[index];
1:     }
1: 
1:     /**
1:      * Get a data type descriptor that describes the desired type for the
1:      * specified column.
1:      *
1:      * @param col the column number (1-based)
1:      * @return a data type descriptor for the column
1:      */
1:     private DataTypeDescriptor getDesiredType(int col) {
1:         if (desiredTypes == null) {
1:             desiredTypes = fetchResultTypes(resultDescription);
1:         }
1:         return desiredTypes[col - 1];
1:     }
1: 
1:     /**
1:     private DataTypeDescriptor[] fetchResultTypes(ResultDescription desc)
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * @see NoPutResultSet#updateRow
1: 	 */
0: 	public void updateRow (ExecRow row) throws StandardException {
0: 		source.updateRow(row);
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException {
1: 		source.markRowAsDeleted();
1: 	}
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
1: 		source.updateRow(row, rowChanger);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4e6df7a
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param isUpdate  True if we are executing an UPDATE statement
1:      * @param desc Metadata describing a result row
/////////////////////////////////////////////////////////////////////////
1: 	 * Normalize a column.  For now, this means calling constructors through
1:      *
1:      * @param dtd Data type to coerce to
1:      * @param sourceRow row holding the source column
1:      * @param sourceColumnPosition position of column in row
1:      * @param resultCol where to stuff the coerced value
1:      * @param desc Additional metadata for error reporting if necessary
1:      *
/////////////////////////////////////////////////////////////////////////
1:     
1: 	 * Normalize a row.
commit:ec4aa98
/////////////////////////////////////////////////////////////////////////
1: 		startCol = computeStartColumn( forUpdate, resultDescription );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Compute the start column for an update/insert.
1:      * </p>
1:      */
1:     public  static  int computeStartColumn( boolean isUpdate, ResultDescription desc )
1:     {
1: 		int count = desc.getColumnCount();
1:         
1: 		/*
1: 		  An update row, for an update statement which sets n columns; i.e
1: 		     UPDATE tab set x,y,z=.... where ...;
1: 		  has,
1: 		  before values of x,y,z after values of x,y,z and rowlocation.
1: 		  need only normalize after values of x,y,z.
1: 		  i.e insead of starting at index = 1, I need to start at index = 4.
1: 		  also I needn't normalize the last value in the row.
1:         */
1: 		return (isUpdate) ? ((count - 1)/ 2) + 1 : 1;
1:     }
1: 
1:     
1: 	/**
0: 	 * Normalize a row.  For now, this means calling constructors through
1: 	 * the type services to normalize a type to itself.  For example,
1: 	 * if you're putting a char(30) value into a char(15) column, it
1: 	 * calls a SQLChar constructor with the char(30) value, and the
1: 	 * constructor truncates the value and makes sure that no non-blank
1: 	 * characters are truncated.
1: 	 *
0: 	 * In the future, this mechanism will be extended to do type conversions,
0: 	 * as well.  I didn't implement type conversions yet because it looks
0: 	 * like a lot of work, and we needed char and varchar right away.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public  static  DataValueDescriptor normalizeColumn
1:         (DataTypeDescriptor dtd, ExecRow sourceRow, int sourceColumnPosition, DataValueDescriptor resultCol, ResultDescription desc )
1:         throws StandardException
1: 	{
1:         DataValueDescriptor sourceCol = sourceRow.getColumn( sourceColumnPosition );
1: 
1:         try {
1:             DataValueDescriptor returnValue = dtd.normalize( sourceCol, resultCol );
1: 
1:             return returnValue;
1:         } catch (StandardException se) {
1:             // Catch illegal null insert and add column info
1:             if (se.getMessageId().startsWith(SQLState.LANG_NULL_INTO_NON_NULL))
1:             {
1:                 ResultColumnDescriptor columnDescriptor = desc.getColumnDescriptor( sourceColumnPosition );
1:                 throw StandardException.newException
1:                     (SQLState.LANG_NULL_INTO_NON_NULL, columnDescriptor.getName());
1:             }
1:             //just rethrow if not LANG_NULL_INTO_NON_NULL
1:             throw se;
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0: 		if (desiredTypes == null) { desiredTypes = fetchResultTypes( resultDescription ); }
1: 
1:         int                     count = resultDescription.getColumnCount();
1: 
1: 		for (int i = 1; i <= count; i++)
1: 			DataValueDescriptor sourceCol = sourceRow.getColumn( i );
1: 				if (i < startCol)
1:                 { normalizedCol = sourceCol; }
1:                 {
0:                     normalizedCol = normalizeColumn
0:                         ( desiredTypes[i - 1], sourceRow, i, normalizedRow.getColumn(i), resultDescription );
1:                 }
1: 				normalizedRow.setColumn(i, normalizedCol);
1:     /**
1:      * <p>
1:      * Fetch the result datatypes out of the activation.
1:      * </p>
1:      */
0:     private  DataTypeDescriptor[]    fetchResultTypes( ResultDescription desc )
0:         throws StandardException
1:     {
1:         int     count = desc.getColumnCount();
1: 
1:         DataTypeDescriptor[]    result = new DataTypeDescriptor[ count ];
1:         
1:         for ( int i = 1; i <= count; i++)
1:         {
1:             ResultColumnDescriptor  colDesc = desc.getColumnDescriptor(  i );
1:             DataTypeDescriptor dtd = colDesc.getType();
1: 
1:             result[i - 1] = dtd;
1:         }
1: 
1:         return result;
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:b31849d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class NormalizeResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							  boolean forUpdate) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.NormalizeResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * Cast the rows from the source result set to match the format of the
1:  * result set for the entire statement.
1:  */
1: 
0: public class NormalizeResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1:     ** Set in constructor and not altered during life of object.
1: 	*/
1: 
1:     public NoPutResultSet	source;
1: 	private	ExecRow			normalizedRow;
1: 	private	int				numCols;
1: 	private int				startCol;
1: 
1: 	/* RESOLVE - We need to pass the ResultDescription for this ResultSet
1: 	 * as a parameter to the constructor and use it instead of the one from
1: 	 * the activation
1: 	 */
1: 	private ResultDescription resultDescription;
1: 
0:     private GeneratedMethod closeCleanup;
1: 
1: 	/* info for caching DTSs */
1: 	private DataTypeDescriptor[] desiredTypes;
1: 
1: 	/**
1: 	 * Constructor for a NormalizeResultSet
1: 	 *
1: 	 * @param source					The NoPutResultSet from which to get rows
1: 	 *									to be normalized
1: 	 * @param activation				The activation for this execution
1: 	 * @param resultSetNumber			The resultSetNumber
1: 	 * @param erdNumber					The integer for the ResultDescription
1: 	 *
1: 	 * @exception StandardException	on error
1: 	 */
1: 
1: 	public NormalizeResultSet(NoPutResultSet source,
1: 							  Activation activation, int resultSetNumber,
1: 							  int erdNumber,
1: 	 					      double optimizerEstimatedRowCount,
1: 							  double optimizerEstimatedCost,
0: 							  boolean forUpdate,
0: 							  GeneratedMethod c) throws StandardException
1: 	{
1: 		super(activation, resultSetNumber, optimizerEstimatedRowCount, 
1: 			  optimizerEstimatedCost);
1: 		this.source = source;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (! (activation.getPreparedStatement().getSavedObject(erdNumber)
1: 							 instanceof ResultDescription))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"activation.getPreparedStatement().getSavedObject(erdNumber) " +
1: 					"expected to be instanceof ResultDescription");
1: 			}
1: 
1: 			// source expected to be non-null, mystery stress test bug
1: 			// - sometimes get NullPointerException in openCore().
1: 			SanityManager.ASSERT(source != null,
1: 				"NRS(), source expected to be non-null");
1: 		}
1: 
1: 		this.resultDescription = 
1: 			(ResultDescription) activation.getPreparedStatement().getSavedObject(erdNumber);
1: 
1: 		numCols = resultDescription.getColumnCount();
1: 		
1: 		/*
0: 		  An update row, for an update statement which sets n columns; i.e
0: 		     UPDATE tab set x,y,z=.... where ...;
0: 		  has,
0: 		  before values of x,y,z after values of x,y,z and rowlocation.
0: 		  need only normalize after values of x,y,z.
0: 		  i.e insead of starting at index = 1, I need to start at index = 4.
0: 		  also I needn't normalize the last value in the row.
1: 	*/
0: 		startCol = (forUpdate) ? ((numCols - 1)/ 2) + 1 : 1;
1: 		normalizedRow = activation.getExecutionFactory().getValueRow(numCols);
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open a scan on the source. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1:      */
1: 	public void	openCore() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "NormalizeResultSet already open");
1: 
1: 		// source expected to be non-null, mystery stress test bug
1: 		// - sometimes get NullPointerException in openCore().
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(source != null,
1: 				"NRS().openCore(), source expected to be non-null");
1: 		}
1: 
1:         source.openCore();
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * reopen a scan on the table. scan parameters are evaluated
1: 	 * at each open, so there is probably some way of altering
1: 	 * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public void	reopenCore() throws StandardException 
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT(isOpen, "NormalizeResultSet already open");
1: 
1: 		source.reopenCore();
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException
1: 	{
1: 		ExecRow		sourceRow = null;
1: 		ExecRow		result = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 		if (!isOpen)
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 
1: 		sourceRow = source.getNextRowCore();
1: 		if (sourceRow != null)
1: 		{
1: 			result = normalizeRow(sourceRow);
1: 			rowsSeen++;
1: 		}
1: 
0: 		currentRow = result;
1: 		setCurrentRow(result);
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen )
1: 	    {
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
1: 			currentRow = null;
1: 	        source.close();
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of NormalizeResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * Gets information from its source. We might want
1: 	 * to have this take a CursorResultSet in its constructor some day,
1: 	 * instead of doing a cast here?
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not a cursorresultset");
1: 		return ( (CursorResultSet)source ).getRowLocation();
1: 	}
1: 
1: 	/**
1: 	 * Gets information from last getNextRow call.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() 
1: 	{
1: 		return currentRow;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 	/**
0: 	 * Normalize a row.  For now, this means calling constructors through
0: 	 * the type services to normalize a type to itself.  For example,
0: 	 * if you're putting a char(30) value into a char(15) column, it
0: 	 * calls a SQLChar constructor with the char(30) value, and the
0: 	 * constructor truncates the value and makes sure that no non-blank
0: 	 * characters are truncated.
1: 	 *
0: 	 * In the future, this mechanism will be extended to do type conversions,
0: 	 * as well.  I didn't implement type conversions yet because it looks
0: 	 * like a lot of work, and we needed char and varchar right away.
1: 	 *
1: 	 * @param sourceRow		The row to normalize
1: 	 *
1: 	 * @return	The normalized row
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	private ExecRow normalizeRow(ExecRow sourceRow) throws StandardException
1: 	{
0: 		int					whichCol;
1: 
0: 		if (desiredTypes == null)
1: 		{
0: 			desiredTypes = new DataTypeDescriptor[numCols];
0: 			for (whichCol = 1; whichCol <= numCols; whichCol++)
1: 			{
0: 				DataTypeDescriptor dtd = resultDescription.getColumnDescriptor(whichCol).getType();
1: 
0: 				desiredTypes[whichCol - 1] = dtd;
1: 			}
1: 
1: 		}
1: 
0: 		for (whichCol = 1; whichCol <= numCols; whichCol++)
1: 		{
0: 			DataValueDescriptor sourceCol = sourceRow.getColumn(whichCol);
1: 			if (sourceCol != null)
1: 			{
1: 				DataValueDescriptor	normalizedCol;
1: 				// skip the before values in case of update
0: 				if (whichCol < startCol)
0: 					normalizedCol = sourceCol;
1: 				else
0: 					try {
0: 						normalizedCol = 
0: 						desiredTypes[whichCol - 1].normalize(sourceCol, 
0: 									normalizedRow.getColumn(whichCol));
0: 					} catch (StandardException se) {
0: 						// Catch illegal null insert and add column info
0: 						if (se.getMessageId().startsWith(SQLState.LANG_NULL_INTO_NON_NULL))
1: 						{
0: 							ResultColumnDescriptor columnDescriptor =
0: 								resultDescription.getColumnDescriptor(whichCol);
0: 							throw
0: 								StandardException.newException(SQLState.LANG_NULL_INTO_NON_NULL, 
0: 															   columnDescriptor.getName());
1: 						}
0: 						//just rethrow if not LANG_NULL_INTO_NON_NULL
0: 						throw se;
1: 					}
1: 
0: 				normalizedRow.setColumn(whichCol, normalizedCol);
1: 			}
1: 		}
1: 
1: 		return normalizedRow;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: /**
0:  * Cast the rows from the source result set to match the format of the
0:  * result set for the entire statement.
0:  */
0: 
0: public class NormalizeResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0:     ** Set in constructor and not altered during life of object.
0: 	*/
0: 
0:     public NoPutResultSet	source;
0: 	private	ExecRow			normalizedRow;
0: 	private	int				numCols;
0: 	private int				startCol;
0: 
0: 	/* RESOLVE - We need to pass the ResultDescription for this ResultSet
0: 	 * as a parameter to the constructor and use it instead of the one from
0: 	 * the activation
0: 	 */
0: 	private ResultDescription resultDescription;
0: 
0:     private GeneratedMethod closeCleanup;
0: 
0: 	/* info for caching DTSs */
0: 	private DataTypeDescriptor[] desiredTypes;
0: 
0: 	/**
0: 	 * Constructor for a NormalizeResultSet
0: 	 *
0: 	 * @param source					The NoPutResultSet from which to get rows
0: 	 *									to be normalized
0: 	 * @param activation				The activation for this execution
0: 	 * @param resultSetNumber			The resultSetNumber
0: 	 * @param erdNumber					The integer for the ResultDescription
0: 	 *
0: 	 * @exception StandardException	on error
0: 	 */
0: 
0: 	public NormalizeResultSet(NoPutResultSet source,
0: 							  Activation activation, int resultSetNumber,
0: 							  int erdNumber,
0: 	 					      double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  boolean forUpdate,
0: 							  GeneratedMethod c) throws StandardException
0: 	{
0: 		super(activation, resultSetNumber, optimizerEstimatedRowCount, 
0: 			  optimizerEstimatedCost);
0: 		this.source = source;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (! (activation.getPreparedStatement().getSavedObject(erdNumber)
0: 							 instanceof ResultDescription))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"activation.getPreparedStatement().getSavedObject(erdNumber) " +
0: 					"expected to be instanceof ResultDescription");
0: 			}
0: 
0: 			// source expected to be non-null, mystery stress test bug
0: 			// - sometimes get NullPointerException in openCore().
0: 			SanityManager.ASSERT(source != null,
0: 				"NRS(), source expected to be non-null");
0: 		}
0: 
0: 		this.resultDescription = 
0: 			(ResultDescription) activation.getPreparedStatement().getSavedObject(erdNumber);
0: 
0: 		numCols = resultDescription.getColumnCount();
0: 		
0: 		/*
0: 		  An update row, for an update statement which sets n columns; i.e
0: 		     UPDATE tab set x,y,z=.... where ...;
0: 		  has,
0: 		  before values of x,y,z after values of x,y,z and rowlocation.
0: 		  need only normalize after values of x,y,z.
0: 		  i.e insead of starting at index = 1, I need to start at index = 4.
0: 		  also I needn't normalize the last value in the row.
0: 	*/
0: 		startCol = (forUpdate) ? ((numCols - 1)/ 2) + 1 : 1;
0: 		normalizedRow = activation.getExecutionFactory().getValueRow(numCols);
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open a scan on the source. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0:      */
0: 	public void	openCore() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "NormalizeResultSet already open");
0: 
0: 		// source expected to be non-null, mystery stress test bug
0: 		// - sometimes get NullPointerException in openCore().
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(source != null,
0: 				"NRS().openCore(), source expected to be non-null");
0: 		}
0: 
0:         source.openCore();
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * reopen a scan on the table. scan parameters are evaluated
0: 	 * at each open, so there is probably some way of altering
0: 	 * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public void	reopenCore() throws StandardException 
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT(isOpen, "NormalizeResultSet already open");
0: 
0: 		source.reopenCore();
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException
0: 	{
0: 		ExecRow		sourceRow = null;
0: 		ExecRow		result = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 		if (!isOpen)
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 
0: 		sourceRow = source.getNextRowCore();
0: 		if (sourceRow != null)
0: 		{
0: 			result = normalizeRow(sourceRow);
0: 			rowsSeen++;
0: 		}
0: 
0: 		currentRow = result;
0: 		setCurrentRow(result);
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen )
0: 	    {
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 			currentRow = null;
0: 	        source.close();
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of NormalizeResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * Gets information from its source. We might want
0: 	 * to have this take a CursorResultSet in its constructor some day,
0: 	 * instead of doing a cast here?
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not a cursorresultset");
0: 		return ( (CursorResultSet)source ).getRowLocation();
0: 	}
0: 
0: 	/**
0: 	 * Gets information from last getNextRow call.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() 
0: 	{
0: 		return currentRow;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 	/**
0: 	 * Normalize a row.  For now, this means calling constructors through
0: 	 * the type services to normalize a type to itself.  For example,
0: 	 * if you're putting a char(30) value into a char(15) column, it
0: 	 * calls a SQLChar constructor with the char(30) value, and the
0: 	 * constructor truncates the value and makes sure that no non-blank
0: 	 * characters are truncated.
0: 	 *
0: 	 * In the future, this mechanism will be extended to do type conversions,
0: 	 * as well.  I didn't implement type conversions yet because it looks
0: 	 * like a lot of work, and we needed char and varchar right away.
0: 	 *
0: 	 * @param sourceRow		The row to normalize
0: 	 *
0: 	 * @return	The normalized row
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	private ExecRow normalizeRow(ExecRow sourceRow) throws StandardException
0: 	{
0: 		int					whichCol;
0: 
0: 		if (desiredTypes == null)
0: 		{
0: 			desiredTypes = new DataTypeDescriptor[numCols];
0: 			for (whichCol = 1; whichCol <= numCols; whichCol++)
0: 			{
0: 				DataTypeDescriptor dtd = resultDescription.getColumnDescriptor(whichCol).getType();
0: 
0: 				desiredTypes[whichCol - 1] = dtd;
0: 			}
0: 
0: 		}
0: 
0: 		for (whichCol = 1; whichCol <= numCols; whichCol++)
0: 		{
0: 			DataValueDescriptor sourceCol = sourceRow.getColumn(whichCol);
0: 			if (sourceCol != null)
0: 			{
0: 				DataValueDescriptor	normalizedCol;
0: 				// skip the before values in case of update
0: 				if (whichCol < startCol)
0: 					normalizedCol = sourceCol;
0: 				else
0: 					try {
0: 						normalizedCol = 
0: 						desiredTypes[whichCol - 1].normalize(sourceCol, 
0: 									normalizedRow.getColumn(whichCol));
0: 					} catch (StandardException se) {
0: 						// Catch illegal null insert and add column info
0: 						if (se.getMessageId().startsWith(SQLState.LANG_NULL_INTO_NON_NULL))
0: 						{
0: 							ResultColumnDescriptor columnDescriptor =
0: 								resultDescription.getColumnDescriptor(whichCol);
0: 							throw
0: 								StandardException.newException(SQLState.LANG_NULL_INTO_NON_NULL, 
0: 															   columnDescriptor.getName());
0: 						}
0: 						//just rethrow if not LANG_NULL_INTO_NON_NULL
0: 						throw se;
0: 					}
0: 
0: 				normalizedRow.setColumn(whichCol, normalizedCol);
0: 			}
0: 		}
0: 
0: 		return normalizedRow;
0: 	}
0: }
============================================================================