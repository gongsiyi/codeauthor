1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.log.FileLogger
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.log;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.MessageId;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.log.LogCounter;
1:eac0369: import org.apache.derby.impl.store.raw.log.LogRecord;
1:eac0369: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.raw.log.Logger;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogScan;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.Compensation;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Loggable;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RePreparable;
1:eac0369: import org.apache.derby.iapi.store.raw.Undoable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdOutputStream;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: import org.apache.derby.iapi.services.io.ArrayOutputStream;
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.LimitObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.data.InitPageOperation;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	Write log records to a log file as a stream
1:eac0369: 	(ie. log records added to the end of the file, no concept of pages).
1:eac0369: <P>
1:eac0369: 	The format of a log record that is not a compensation operation is
1:eac0369: 	<PRE>
1:787ceb4: 	@derby.formatId	no formatId, format is implied by the log file format and the
1:eac0369: 		log record content.
1:787ceb4: 	@derby.purpose	the log record and optional data
1:787ceb4: 	@derby.upgrade
1:787ceb4: 	@derby.diskLayout
1:eac0369: 		Log Record
1:eac0369: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
1:eac0369: 		length(int)	length of optional data
1:eac0369: 		optionalData(byte[length]) optional data written by the log record
1:787ceb4: 	@derby.endFormat
1:eac0369: 	</PRE> <HR WIDTH="100%"> 
1:eac0369: 
1:eac0369: 	<P>	The form of a log record that is a compensation operation is
1:eac0369: 	<PRE>
1:787ceb4: 	@derby.formatId	no formatId, format is implied by the log file format and the
1:eac0369: 	log record content.
1:787ceb4: 	@derby.purpose	undo a previous log record
1:787ceb4: 	@derby.upgrade
1:787ceb4: 	@derby.diskLayout
1:eac0369: 		Log Record that contains the compenstation operation
1:eac0369: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
1:eac0369: 		undoInstant(long) the log instant of the operation that is to be rolled back
1:eac0369: 			The undo instant is logically part of the LogRecord but is written
1:eac0369: 			by the logger because it is used and controlled by the rollback
1:eac0369: 			code but not by the log operation.
1:eac0369: 		There is no optional data in a compensation operation, all data
1:eac0369: 		necessary for the rollback must be stored in the operation being
1:eac0369: 		undone.
1:787ceb4: 	@derby.endFormat
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369:     <BR>
1:eac0369: 
1:eac0369: 	<P>Multithreading considerations:<BR>
1:eac0369: 	Logger must be MT-safe.	Each RawTransaction has its own private
1:eac0369: 	FileLogger object. Each logger has a logOutputBuffer and a log input
1:eac0369: 	buffer which are used to read and write to the log.  Since multiple
1:eac0369: 	threads can be in the same transaction, fileLogger must be synchronized.
1:eac0369: 
1:eac0369: 	@see LogRecord
1:eac0369: */
1:eac0369: 
1:eac0369: public class FileLogger implements Logger {
1:eac0369: 
1:eac0369: 	private LogRecord		 logRecord;
1:eac0369: 
1:eac0369: 	protected byte[] encryptionBuffer;
1:eac0369: 	private DynamicByteArrayOutputStream logOutputBuffer;
1:eac0369: 	private FormatIdOutputStream logicalOut;
1:eac0369: 
1:eac0369: 	private ArrayInputStream logIn;
1:eac0369: 
1:eac0369: 	private LogToFile logFactory;	// actually writes the log records.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Make a new Logger with its own log record buffers
1:eac0369: 		MT - not needed for constructor
1:eac0369: 	*/
1:eac0369: 	public FileLogger(LogToFile logFactory) {
1:eac0369: 
1:eac0369: 		this.logFactory = logFactory;
1:eac0369: 		logOutputBuffer = new DynamicByteArrayOutputStream(1024); // init size 1K
1:eac0369: 		logicalOut = new FormatIdOutputStream(logOutputBuffer);
1:eac0369: 
1:eac0369: 		// logIn and logOutputBuffer must share the same buffer because they
1:eac0369: 		// combined to form an IO stream to access the same log record.
1:eac0369: 		// 
1:eac0369: 		// Before each use of logIn, you must reset logIn's data to the
1:eac0369: 		// byte array you want to read from.
1:eac0369: 		//
1:eac0369: 		// To log a record, set logIn's data to point to logOutputBuffer's
1:eac0369: 		// byte array when you know you have everything you need in the output
1:eac0369: 		// buffer, then set limit on logIn and send it to the log operation's
1:eac0369: 		// doMe.
1:eac0369: 		//
1:eac0369: 		// Keep in mind the dynamic nature of the logOutputBuffer which means
1:eac0369: 		// it could switch buffer from underneath the logOutputBuffer on every
1:eac0369: 		// write.
1:eac0369: 		logIn = new ArrayInputStream();
1:eac0369:  
1:eac0369: 		logRecord = new LogRecord();
1:eac0369: 
2:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close the logger.
1:eac0369: 		MT - caller provide synchronization
1:eac0369: 		(RESOLVE: not called by anyone ??)
1:eac0369: 	*/
1:eac0369: 	public void close() throws IOException
1:eac0369: 	{
1:eac0369: 		if (logOutputBuffer != null)
1:eac0369: 		{
1:eac0369: 			logOutputBuffer.close();
1:eac0369: 			logOutputBuffer = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		logIn = null;
1:eac0369: 		logFactory = null;
1:eac0369: 
1:eac0369: 		logicalOut = null;
1:eac0369: 
1:eac0369: 		logRecord = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Logger
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Writes out a log record to the log stream, and call its doMe method to
1:eac0369: 		apply the change to the rawStore.
1:eac0369: 		<BR>Any optional data the doMe method need is first written to the log
1:eac0369: 		stream using operation.writeOptionalData, then whatever is written to
1:eac0369: 		the log stream is passed back to the operation for the doMe method.
1:eac0369: 
1:eac0369: 		<P>MT - there could be multiple threads running in the same raw
1:eac0369: 		transactions and they can be calling the same logger to log different
1:eac0369: 		log operations.  This whole method is synchronized to make sure log
1:eac0369: 		records are logged one at a time.
1:eac0369: 
1:eac0369: 		@param xact the transaction logging the change
1:eac0369: 		@param operation the log operation
1:eac0369: 		@return the instant in the log that can be used to identify the log
1:eac0369: 		record
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	*/
1:eac0369: 	public synchronized LogInstant logAndDo(RawTransaction xact, Loggable operation) 
1:eac0369: 		 throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean isLogPrepared = false;
1:eac0369: 
1:eac0369: 		boolean inUserCode = false;
1:eac0369: 		byte[] preparedLog;
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			logOutputBuffer.reset();
1:eac0369: 
1:eac0369: 			// always use the short Id, only the BeginXact log record contains
1:eac0369: 			// the XactId (long form)
1:eac0369: 			TransactionId transactionId = xact.getId();
1:eac0369: 
1:eac0369: 			// write out the log header with the operation embedded
1:eac0369: 			// this is by definition not a compensation log record,
1:eac0369: 			// those are called thru the logAndUndo interface
1:eac0369: 			logRecord.setValue(transactionId, operation);
1:eac0369: 
1:eac0369: 			inUserCode = true;
1:eac0369: 			logicalOut.writeObject(logRecord);
1:eac0369: 			inUserCode = false;
1:eac0369: 
1:eac0369: 			int optionalDataLength = 0;
1:eac0369: 			int optionalDataOffset = 0;
1:eac0369: 			int completeLength = 0;
1:eac0369: 
1:eac0369: 			ByteArray preparedLogArray = operation.getPreparedLog();
1:eac0369: 			if (preparedLogArray != null) {
1:eac0369: 
1:eac0369: 				preparedLog = preparedLogArray.getArray();
1:eac0369: 				optionalDataLength = preparedLogArray.getLength();
1:eac0369: 				optionalDataOffset = preparedLogArray.getOffset();
1:eac0369: 
1:eac0369: 				// There is a race condition if the operation is a begin tran in
1:eac0369: 				// that between the time the beginXact log record is written to
1:eac0369: 				// disk and the time the transaction object is updated in the
1:eac0369: 				// beginXact.doMe method, other log records may be written.
1:eac0369: 				// This will render the transaction table in an inconsistent state
1:eac0369: 				// since it may think a later transaction is the earliest
1:eac0369: 				// transaction or it may think that there is no active transactions
1:eac0369: 				// where there is a bunch of them sitting on the log.
1:eac0369: 				//
1:eac0369: 				// Similarly, there is a race condition for endXact, i.e.,
1:eac0369: 				// 1) endXact is written to the log, 
1:eac0369: 				// 2) checkpoint gets that (committed) transaction as the
1:eac0369: 				//		firstUpdateTransaction
1:eac0369: 				// 3) the transaction calls postComplete, nulling out itself
1:eac0369: 				// 4) checkpoint tries to access a closed transaction object
1:eac0369: 				//
1:eac0369: 				// The solution is to sync between the time a begin tran or end
1:eac0369: 				// tran log record is sent to the log stream and its doMe method is
1:eac0369: 				// called to update the transaction table and in memory state
1:eac0369: 				//
1:eac0369: 				// We only need to serialized the begin and end Xact log records
1:eac0369: 				// because once a transaction has been started and in the
1:eac0369: 				// transaction table, its order and transaction state does not
1:eac0369: 				// change.
1:eac0369: 				//
1:eac0369: 				// Use the logFactory as the sync object so that a checkpoint can
1:eac0369: 				// take its snap shot of the undoLWM before or after a transaction
1:eac0369: 				// is started, but not in the middle. (see LogToFile.checkpoint)
1:eac0369: 				//
1:eac0369: 
1:eac0369: 				// now set the input limit to be the optional data.  
1:eac0369: 				// This limits amount of data availiable to logIn that doMe can
1:eac0369: 				// use
1:eac0369: 				logIn.setData(preparedLog);
1:eac0369: 				logIn.setPosition(optionalDataOffset);
1:eac0369: 				logIn.setLimit(optionalDataLength);
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if ((optionalDataLength) != logIn.available())
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							" stream not set correctly " +
1:eac0369: 							optionalDataLength + " != " +
1:eac0369: 							 logIn.available());
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			} else {
1:eac0369: 				preparedLog = null;
1:eac0369: 				optionalDataLength = 0;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			logicalOut.writeInt(optionalDataLength);
1:eac0369: 			completeLength = logOutputBuffer.getPosition() + optionalDataLength;
1:eac0369: 
1:eac0369: 
1:eac0369: 			LogInstant logInstant = null;
1:eac0369: 			int encryptedLength = 0; // in case of encryption, we need to pad
1:eac0369: 
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				if (logFactory.databaseEncrypted())
1:eac0369: 				{
1:eac0369: 					// we must pad the encryption data to be multiple of block
1:eac0369: 					// size, which is logFactory.getEncryptionBlockSize()
1:eac0369: 					encryptedLength = completeLength;
1:eac0369: 					if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
1:eac0369: 						encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
1:eac0369: 
1:eac0369: 					if (encryptionBuffer == null || 
1:eac0369: 						encryptionBuffer.length < encryptedLength)
1:eac0369: 						encryptionBuffer = new byte[encryptedLength];
1:eac0369: 
1:eac0369: 					System.arraycopy(logOutputBuffer.getByteArray(), 0, 
1:eac0369: 									 encryptionBuffer, 0, completeLength-optionalDataLength);
1:eac0369: 
1:eac0369: 					if (optionalDataLength > 0)
1:eac0369: 						System.arraycopy(preparedLog, optionalDataOffset, 
1:eac0369: 									 encryptionBuffer,
1:eac0369: 									 completeLength-optionalDataLength, optionalDataLength);
1:eac0369: 
1:eac0369: 					// do not bother to clear out the padding area 
1:eac0369: 					int len = 
1:eac0369: 						logFactory.encrypt(encryptionBuffer, 0, encryptedLength, 
1:eac0369: 										   encryptionBuffer, 0);
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(len == encryptedLength, 
1:eac0369: 							"encrypted log buffer length != log buffer len");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if ((operation.group() & (Loggable.FIRST | Loggable.LAST)) != 0)
1:eac0369: 				{
1:eac0369: 					synchronized (logFactory)
1:eac0369: 					{
1:eac0369: 						long instant = 0;
1:eac0369: 
1:eac0369: 						if (logFactory.databaseEncrypted())
1:eac0369: 						{
1:eac0369: 							// encryption has completely drained both the the
1:eac0369: 							// logOuputBuffer array and the preparedLog array
1:eac0369: 							instant = logFactory.
1:eac0369: 								appendLogRecord(encryptionBuffer, 0, 
1:eac0369: 												encryptedLength, null, 
1:eac0369: 												-1, 0);
1:eac0369: 						}
1:eac0369: 						else
1:eac0369: 						{
1:eac0369: 							instant = logFactory.
1:eac0369: 								appendLogRecord(logOutputBuffer.getByteArray(),
1:eac0369: 												0, completeLength, preparedLog,
1:eac0369: 												optionalDataOffset,
1:eac0369: 												optionalDataLength);
1:eac0369: 						}
1:eac0369: 						logInstant = new LogCounter(instant);
1:eac0369: 
1:eac0369: 						operation.doMe(xact, logInstant, logIn);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					long instant = 0;
1:eac0369: 
1:eac0369: 					if (logFactory.databaseEncrypted())
1:eac0369: 					{
1:eac0369: 						// encryption has completely drained both the the
1:eac0369: 						// logOuputBuffer array and the preparedLog array
1:eac0369: 						instant = logFactory.
1:eac0369: 							appendLogRecord(encryptionBuffer, 0, 
1:eac0369: 											encryptedLength, null, -1, 0);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						instant = logFactory.
1:eac0369: 							appendLogRecord(logOutputBuffer.getByteArray(), 0,
1:eac0369: 											completeLength, preparedLog,
1:eac0369: 											optionalDataOffset,
1:eac0369: 											optionalDataLength); 
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					logInstant = new LogCounter(instant);
1:eac0369: 
1:eac0369: 					operation.doMe(xact, logInstant, logIn);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 			catch (StandardException se)
1:eac0369: 			{
1:eac0369: 				throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_DO_ME_FAIL, se, operation));
1:eac0369: 			}
1:eac0369: 			catch (IOException ioe)
1:eac0369: 			{
1:eac0369: 				throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_DO_ME_FAIL, ioe, operation));
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				logIn.clearLimit();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                         LogToFile.DBG_FLAG, 
1:eac0369:                         "Write log record: tranId=" + transactionId.toString() +
1:eac0369:                         " instant: " + logInstant.toString() + " length: " +
1:eac0369:                         completeLength + "\n" + operation + "\n");
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 			return logInstant;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe) 
1:eac0369: 		{
1:eac0369: 			// error writing to the log buffer
1:eac0369: 			if (inUserCode)
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, operation);
1:eac0369:             }
1:eac0369: 			else
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.LOG_BUFFER_FULL, ioe, operation);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Writes out a compensation log record to the log stream, and call its
1:eac0369: 		doMe method to undo the change of a previous log operation.
1:eac0369: 
1:eac0369: 		<P>MT - Not needed. A transaction must be single threaded thru undo, each
1:eac0369: 		RawTransaction has its own logger, therefore no need to synchronize.
1:eac0369: 		The RawTransaction must handle synchronizing with multiple threads
1:eac0369: 		during rollback.
1:eac0369: 
1:eac0369: 		@param xact the transaction logging the change
1:eac0369: 		@param compensation the compensation log operation
1:eac0369: 		@param undoInstant the log instant of the operation that is to be
1:eac0369: 		rolled back
1:eac0369: 		@param in optional data input for the compenastion doMe method
1:eac0369: 
1:eac0369: 		@return the instant in the log that can be used to identify the log
1:eac0369: 		record
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	 */
1:eac0369: 	public LogInstant logAndUndo(RawTransaction xact, 
1:eac0369: 								 Compensation compensation,
1:eac0369: 								 LogInstant undoInstant,
1:eac0369: 								 LimitObjectInput in)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean inUserCode = false;
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			logOutputBuffer.reset();
1:eac0369: 
1:eac0369: 			TransactionId transactionId = xact.getId();
1:eac0369: 
1:eac0369: 			// write out the log header with the operation embedded
1:eac0369: 			logRecord.setValue(transactionId, compensation);
1:eac0369: 
1:eac0369: 			inUserCode = true;
1:eac0369: 			logicalOut.writeObject(logRecord);
1:eac0369: 			inUserCode = false;
1:eac0369: 
1:eac0369: 			// write out the undoInstant
1:eac0369: 			logicalOut.writeLong(((LogCounter)undoInstant).getValueAsLong());
1:eac0369: 
1:eac0369: 			// in this implemetaion, there is no optional data for the
1:eac0369: 			// compensation operation.  Optional data for the rollback comes
1:eac0369: 			// from the undoable operation - and is passed into this call.
1:eac0369: 			int completeLength = logOutputBuffer.getPosition();
1:eac0369: 			long instant = 0;
1:eac0369: 			
1:eac0369: 			if (logFactory.databaseEncrypted())
1:eac0369: 			{
1:eac0369: 				// we must pad the encryption data to be multiple of block
1:eac0369: 				// size, which is logFactory.getEncryptionBlockSize()
1:eac0369: 				int encryptedLength = completeLength;
1:eac0369: 				if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
1:eac0369: 					encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
1:eac0369: 
1:eac0369: 				if (encryptionBuffer == null || 
1:eac0369: 					encryptionBuffer.length < encryptedLength)
1:eac0369: 					encryptionBuffer = new byte[encryptedLength];
1:eac0369: 
1:eac0369: 				System.arraycopy(logOutputBuffer.getByteArray(), 0, 
1:eac0369: 								 encryptionBuffer, 0, completeLength);
1:eac0369: 
1:eac0369: 				// do not bother to clear out the padding area 
1:eac0369: 				int len = 
1:eac0369: 					logFactory.encrypt(encryptionBuffer, 0, encryptedLength,
1:eac0369: 									   encryptionBuffer, 0);
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(len == encryptedLength, 
1:eac0369: 						"encrypted log buffer length != log buffer len");
1:eac0369: 
1:eac0369: 				instant = logFactory.
1:eac0369: 					appendLogRecord(encryptionBuffer,
1:eac0369: 									0, encryptedLength, null, 0, 0);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				instant = logFactory.
1:eac0369: 					appendLogRecord(logOutputBuffer.getByteArray(), 
1:eac0369: 									0, completeLength, null, 0, 0);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			LogInstant logInstant = new LogCounter(instant);
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                         LogToFile.DBG_FLAG, 
1:eac0369:                         "Write CLR: Xact: " + transactionId.toString() +
1:eac0369:                         "clrinstant: " + logInstant.toString() + 
1:eac0369:                         " undoinstant " + undoInstant + "\n");
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				// in and dataLength contains optional data that was written 
1:eac0369: 				// to the log during a previous call to logAndDo.
1:eac0369: 				compensation.doMe(xact, logInstant, in);
1:eac0369: 			}
1:eac0369: 			catch (StandardException se)
1:eac0369: 			{
1:eac0369: 				throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_DO_ME_FAIL, se, compensation));
1:eac0369: 			}
1:eac0369: 			catch (IOException ioe)
1:eac0369: 			{
1:eac0369: 				throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_DO_ME_FAIL, ioe, compensation));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return logInstant;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			if (inUserCode)
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, compensation);
1:eac0369:             }
1:eac0369: 			else
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.LOG_BUFFER_FULL, ioe, compensation);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Flush the log up to the given log instant.
1:eac0369: 
1:eac0369: 		<P>MT - not needed, wrapper method
1:eac0369: 
1:eac0369: 		@exception StandardException cannot sync log file
1:eac0369: 	*/
1:eac0369: 	public void flush(LogInstant where) 
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, "Flush log to " + where.toString());
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		logFactory.flush(where);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Flush all outstanding log to disk.
1:eac0369: 
1:eac0369: 		<P>MT - not needed, wrapper method
1:eac0369: 
1:eac0369: 		@exception StandardException cannot sync log file
1:eac0369: 	*/
1:eac0369: 	public void flushAll () throws StandardException
1:eac0369: 	{
1:eac0369: 		logFactory.flushAll();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * During recovery re-prepare a transaction.
1:eac0369:      * <p>
1:eac0369:      * After redo() and undo(), this routine is called on all outstanding 
1:eac0369:      * in-doubt (prepared) transactions.  This routine re-acquires all 
1:eac0369:      * logical write locks for operations in the xact, and then modifies
1:eac0369:      * the transaction table entry to make the transaction look as if it
1:eac0369:      * had just been prepared following startup after recovery.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param t                 is the transaction performing the re-prepare
1:eac0369:      * @param prepareId         is the transaction ID to be re-prepared
1:eac0369:      * @param prepareStopAt     is where the log instant (inclusive) where the 
1:eac0369:      *                          re-prepare should stop.
1:eac0369:      * @param prepareStartAt    is the log instant (inclusive) where re-prepare 
1:eac0369:      *                          should begin, this is normally the log instant 
1:eac0369:      *                          of the last log record of the transaction that 
1:eac0369:      *                          is to be re-prepare.  If null, then re-prepare 
1:eac0369:      *                          starts from the end of the log.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void reprepare(
1:eac0369:     RawTransaction  t,
1:eac0369:     TransactionId   prepareId,
1:eac0369:     LogInstant      prepareStopAt,
1:eac0369:     LogInstant      prepareStartAt) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 if (prepareStartAt != null)
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                     "----------------------------------------------------\n" +
1:eac0369:                     "\nBegin of RePrepare : " + prepareId.toString() + 
1:eac0369:                         "start at " + prepareStartAt.toString() + 
1:eac0369:                         " stop at " + prepareStopAt.toString()  +
1:eac0369:                     "\n----------------------------------------------------\n");
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                     "----------------------------------------------------\n" +
1:eac0369:                     "\nBegin of Reprepare: " + prepareId.toString() + 
1:eac0369:                         "start at end of log stop at " + 
1:eac0369:                         prepareStopAt.toString() +
1:eac0369:                     "\n----------------------------------------------------\n");
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// statistics
1:eac0369: 		int clrskipped      = 0;
1:eac0369: 		int logrecordseen   = 0;
1:eac0369: 
1:eac0369: 		RePreparable lop          = null;
1:eac0369: 
1:eac0369: 		// stream to read the log record - initial size 4096, scanLog needs
1:eac0369: 		// to resize if the log record is larger than that.
1:eac0369: 		ArrayInputStream    rawInput    = null;
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369:             StreamLogScan scanLog;
1:eac0369: 
1:eac0369: 			if (prepareStartAt == null)
1:eac0369:             {
1:eac0369:                 // don't know where to start, scan from end of log
1:eac0369: 				scanLog = 
1:eac0369:                     (StreamLogScan) logFactory.openBackwardsScan(prepareStopAt);
1:eac0369:             }
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (prepareStartAt.lessThan(prepareStopAt)) 
1:eac0369:                 {
1:eac0369:                     // nothing to prepare!
1:eac0369: 					return;
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				scanLog = (StreamLogScan)
1:eac0369: 					logFactory.openBackwardsScan(
1:eac0369:                         ((LogCounter) prepareStartAt).getValueAsLong(),
1:eac0369:                         prepareStopAt);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     scanLog != null, "cannot open log for prepare");
1:eac0369: 
1:eac0369: 			rawInput    = new ArrayInputStream(new byte[4096]);
1:eac0369: 
1:eac0369: 			LogRecord record;
1:eac0369: 
1:eac0369: 			while ((record = 
1:eac0369:                     scanLog.getNextRecord(rawInput, prepareId, 0)) 
1:eac0369:                        != null) 
1:eac0369: 			{ 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(
1:eac0369:                         record.getTransactionId().equals(prepareId),
1:eac0369: 					    "getNextRecord return unqualified log rec for prepare");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				logrecordseen++;
1:eac0369: 
1:eac0369: 				if (record.isCLR())
1:eac0369: 				{
1:eac0369: 					clrskipped++;
1:eac0369: 
1:eac0369:                     // the loggable is still in the input stream, get rid of it
1:eac0369: 					record.skipLoggable(); 
1:eac0369: 
1:eac0369: 					// read the prepareInstant
1:eac0369: 					long prepareInstant = rawInput.readLong();
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                     "Skipping over CLRs, reset scan to " + 
1:eac0369:                                     LogCounter.toDebugString(prepareInstant));
1:eac0369:                         }
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					scanLog.resetPosition(new LogCounter(prepareInstant));
1:eac0369: 					// scanLog now positioned at the beginning of the log
1:eac0369: 					// record that was rolled back by this CLR.
1:eac0369: 					// The scan is a backward one so getNextRecord will skip
1:eac0369: 					// over the record that was rolled back and go to the one
1:eac0369: 					// previous to it
1:eac0369: 
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369:                 if (record.requiresPrepareLocks())
1:eac0369:                 {
1:eac0369:                     lop = record.getRePreparable();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     continue;
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				if (lop != null)
1:eac0369: 				{
1:eac0369:                     // Reget locks based on log record.  reclaim all locks with
1:eac0369:                     // a serializable locking policy, since we are only 
1:eac0369:                     // reclaiming write locks, isolation level does not matter
1:eac0369:                     // much.
1:eac0369: 
1:eac0369:                     lop.reclaimPrepareLocks(
1:eac0369:                         t,
1:eac0369:                         t.newLockingPolicy(
1:eac0369:                             LockingPolicy.MODE_RECORD, 
1:eac0369:                             TransactionController.ISOLATION_REPEATABLE_READ, 
1:eac0369:                             true));
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "Reprepare log record at instant " +
1:eac0369:                                 scanLog.getInstant() + " : " + lop);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1:eac0369: 		}
1:eac0369: 	    catch (IOException ioe) 
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			throw 
1:eac0369:                 logFactory.markCorrupt(
1:eac0369:                     StandardException.newException(
1:eac0369:                         SQLState.LOG_UNDO_FAILED, se,  
1:eac0369:                         prepareId, lop, (Object) null));
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (rawInput != null)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					rawInput.close();
1:eac0369: 				}
1:eac0369: 				catch (IOException ioe)
1:eac0369: 				{
1:eac0369: 					throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, prepareId));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(LogToFile.DBG_FLAG, "Finish prepare" +
1:eac0369:                                     ", clr skipped = " + clrskipped + 
1:eac0369:                                     ", record seen = " + logrecordseen + "\n");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                     "----------------------------------------------------\n" +
1:eac0369:                     "End of recovery rePrepare\n" + 
1:eac0369:                     ", clr skipped = " + clrskipped + 
1:eac0369:                     ", record seen = " + logrecordseen + 
1:eac0369:                     "\n----------------------------------------------------\n");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Undo a part of or the entire transaction.  Begin rolling back the log
1:eac0369: 		record at undoStartAt and stopping at (inclusive) the log record at
1:eac0369: 		undoStopAt.
1:eac0369: 
1:eac0369: 		<P>MT - Not needed. A transaction must be single threaded thru undo, 
1:eac0369:         each RawTransaction has its own logger, therefore no need to 
1:eac0369:         synchronize.  The RawTransaction must handle synchronizing with 
1:eac0369:         multiple threads during rollback.
1:eac0369: 
1:eac0369: 		@param t 			the transaction that needs to be rolled back
1:eac0369: 		@param undoId 		the transaction ID
1:eac0369: 		@param undoStopAt	the last log record that should be rolled back
1:eac0369: 		@param undoStartAt	the first log record that should be rolled back
1:eac0369: 
1:94f158a: 		@exception StandardException	Standard Derby error policy
1:eac0369: 
1:eac0369: 		@see Logger#undo
1:eac0369: 	  */
1:eac0369: 	public void undo(
1:eac0369:     RawTransaction  t, 
1:eac0369:     TransactionId   undoId, 
1:eac0369:     LogInstant      undoStopAt, 
1:eac0369:     LogInstant      undoStartAt)
1:eac0369: 		throws StandardException 
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 if (undoStartAt != null)
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                         LogToFile.DBG_FLAG, 
1:eac0369:                         "\nUndo transaction: " + undoId.toString() + 
1:eac0369:                         "start at " + undoStartAt.toString() + 
1:eac0369:                         " stop at " + undoStopAt.toString() );
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                         LogToFile.DBG_FLAG, 
1:eac0369:                         "\nUndo transaction: " + undoId.toString() + 
1:eac0369:                         "start at end of log stop at " + undoStopAt.toString());
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// statistics
1:eac0369: 		int clrgenerated  = 0;
1:eac0369: 		int clrskipped    = 0;
1:eac0369: 		int logrecordseen = 0;
1:eac0369: 
1:eac0369: 		StreamLogScan scanLog;
1:eac0369: 		Compensation  compensation = null;
1:eac0369: 		Undoable      lop          = null;
1:eac0369: 
1:eac0369: 		// stream to read the log record - initial size 4096, scanLog needs
1:eac0369: 		// to resize if the log record is larget than that.
1:eac0369: 		ArrayInputStream    rawInput   = null;
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (undoStartAt == null)	
1:eac0369:             {
1:eac0369:                 // don't know where to start, rollback from end of log
1:eac0369: 
1:eac0369: 				scanLog = (StreamLogScan)
1:eac0369: 					logFactory.openBackwardsScan(undoStopAt);
1:eac0369:             }
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (undoStartAt.lessThan(undoStopAt))
1:eac0369:                 {
1:eac0369:                     // nothing to undo!
1:eac0369: 					return;
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				long undoStartInstant = 
1:eac0369:                     ((LogCounter) undoStartAt).getValueAsLong();
1:eac0369: 
1:eac0369: 				scanLog = (StreamLogScan)
1:eac0369: 					logFactory.openBackwardsScan(undoStartInstant, undoStopAt);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     scanLog != null, "cannot open log for undo");
1:eac0369: 
1:eac0369: 			rawInput   = new ArrayInputStream(new byte[4096]);
1:eac0369: 
1:eac0369: 			LogRecord record;
1:eac0369: 
1:eac0369: 			while ((record = 
1:eac0369:                     scanLog.getNextRecord(rawInput, undoId, 0)) 
1:eac0369:                         != null) 
1:eac0369: 			{ 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(
1:eac0369:                         record.getTransactionId().equals(undoId),
1:eac0369:                         "getNextRecord return unqualified log record for undo");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				logrecordseen++;
1:eac0369: 
1:eac0369: 				if (record.isCLR())
1:eac0369: 				{
1:eac0369: 					clrskipped++;
1:eac0369: 
1:eac0369:                     // the loggable is still in the input stream, get rid of it
1:eac0369: 					record.skipLoggable(); 
1:eac0369: 
1:eac0369: 					// read the undoInstant
1:eac0369: 					long undoInstant = rawInput.readLong();
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "Skipping over CLRs, reset scan to " + 
1:eac0369:                                 LogCounter.toDebugString(undoInstant));
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 
1:eac0369: 					scanLog.resetPosition(new LogCounter(undoInstant));
1:eac0369: 
1:eac0369: 					// scanLog now positioned at the beginning of the log
1:eac0369: 					// record that was rolled back by this CLR.
1:eac0369: 					// The scan is a backward one so getNextRecord will skip
1:eac0369: 					// over the record that was rolled back and go to the one
1:eac0369: 					// previous to it
1:eac0369: 
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				lop = record.getUndoable();
1:eac0369: 
1:eac0369: 				if (lop != null)
1:eac0369: 				{
1:eac0369: 					int optionalDataLength = rawInput.readInt();
1:eac0369: 					int savePosition = rawInput.getPosition();
1:8360656: 					rawInput.setLimit(optionalDataLength);
1:eac0369: 	
1:eac0369: 					compensation = lop.generateUndo(t, rawInput);
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "Rollback log record at instant " +
1:eac0369:                                 LogCounter.toDebugString(scanLog.getInstant()) +
1:eac0369:                                 " : " + lop);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					clrgenerated++;
1:eac0369: 
1:eac0369: 					if (compensation != null)
1:eac0369: 					{
1:eac0369: 						// generateUndo may have read stuff off the
1:eac0369: 						// stream, reset it for the undo operation.
2:eac0369: 						rawInput.setLimit(savePosition, optionalDataLength);
1:eac0369: 
1:eac0369: 						// log the compensation op that rolls back the 
1:eac0369:                         // operation at this instant 
1:eac0369: 						t.logAndUndo(
1:eac0369:                             compensation, new LogCounter(scanLog.getInstant()),
1:eac0369:                             rawInput);
1:eac0369: 
1:eac0369: 						compensation.releaseResource(t);
1:eac0369: 						compensation = null;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// if compensation is null, log operation is redo only
1:eac0369: 				}
1:eac0369: 				// if this is not an undoable operation, continue with next log
1:eac0369: 				// record
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1:eac0369: 		}
1:eac0369: 	    catch (IOException ioe) 
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369:             // TODO (4327) - exceptions caught here are nested in the exception
1:eac0369:             // below but for some reason the nested exceptions are not logged 
1:eac0369:             // or reported in any way.
1:eac0369: 
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(
1:eac0369:                     SQLState.LOG_UNDO_FAILED, se, undoId, lop, compensation));
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (compensation != null) 
1:eac0369:             {
1:eac0369:                 // errored out
1:eac0369: 				compensation.releaseResource(t);
1:eac0369:             }
1:eac0369: 
1:eac0369: 			if (rawInput != null)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					rawInput.close();
1:eac0369: 				}
1:eac0369: 				catch (IOException ioe)
1:eac0369: 				{
1:eac0369: 					throw logFactory.markCorrupt(
1:eac0369:                         StandardException.newException(
1:eac0369:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, undoId));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                         "Finish undo" +
1:eac0369:                         ", clr generated = " + clrgenerated +
1:eac0369:                         ", clr skipped = " + clrskipped + 
1:eac0369:                         ", record seen = " + logrecordseen + "\n");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Recovery Redo loop.
1:eac0369: 
1:eac0369: 		<P> The log stream is scanned from the beginning (or
1:eac0369: 		from the undo low water mark of a checkpoint) forward until the end.
1:eac0369: 		The purpose of the redo pass is to repeat history, i.e, to repeat
1:eac0369: 		exactly the same set of changes the rawStore went thru right before it
1:eac0369: 		stopped.   With each log record that is encountered in the redo pass:
1:eac0369: 		<OL>
1:eac0369: 		<LI>if it isFirst(), then the transaction factory is called upon to
1:eac0369: 		    create a new transaction object.
1:eac0369: 		<LI>if it needsRedo(), its doMe() is called (if it is a compensation
1:eac0369: 		    operation, then the undoable operation needs to be created first
1:eac0369:             before the doMe is called).
1:eac0369: 		<LI>if it isComplete(), then the transaction object is closed.
1:eac0369: 		</OL>
1:eac0369: 
1:eac0369: 		<P> MT - caller provides synchronization
1:eac0369: 
1:eac0369: 		@param transFactory     - the transaction factory
1:eac0369: 		@param redoLWM          - if checkpoint seen, starting from this point
1:eac0369:                                   on, apply redo if necessary
1:eac0369: 
1:eac0369: 		@return the log instant of the next log record (or the instant just
1:eac0369: 		after the last log record).  This is used to determine where the log
1:eac0369: 		truly ends
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 		@exception IOException error reading log file
1:eac0369: 		@exception ClassNotFoundException log file corrupted
1:eac0369: 
1:eac0369: 		@see LogToFile#recover
1:eac0369: 	 */
1:eac0369: 	protected long redo(
1:eac0369:     RawTransaction      recoveryTransaction,
1:eac0369:     TransactionFactory  transFactory,
1:eac0369:     StreamLogScan       redoScan,
1:eac0369:     long                redoLWM,
1:eac0369:     long                ttabInstant)
1:eac0369: 		 throws IOException, StandardException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		// begin debug info
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                     "In recovery redo, redoLWM = " + redoLWM);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		int scanCount    = 0;
1:eac0369:         int redoCount    = 0;
1:eac0369:         int prepareCount = 0; 
1:eac0369:         int clrCount     = 0;
1:eac0369:         int btranCount   = 0;
1:eac0369:         int etranCount   = 0;
1:eac0369: 
1:eac0369: 		// end debug info
1:eac0369: 
1:eac0369: 		TransactionId tranId = null;
1:eac0369: 
1:eac0369:         // the current log instant
1:eac0369: 		long instant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 
1:eac0369: 		//////////////////////////////////////////////////////////////////////
1:eac0369: 		// During redo time, the byte array in the logOutputBuffer is not used.
1:eac0369: 		// Use it to read the log record - if it is not big enough, scan
1:eac0369: 		// will resize it.  We could create a brand new log input stream that
1:eac0369: 		// has nothing to do with logIn or logOutputBuffer but that seem like
1:eac0369: 		// a waste of memory.
1:eac0369: 		//////////////////////////////////////////////////////////////////////
1:eac0369: 		logIn.setData(logOutputBuffer.getByteArray());
1:eac0369: 
1:eac0369: 		// use this scan to reconstitute operation to be undone
1:eac0369: 		// when we see a CLR in the redo scan
1:eac0369: 		StreamLogScan undoScan  = null;
1:eac0369: 		Loggable      op        = null;
1:eac0369: 		long          logEnd    = 0;  // we need to determine the log's true end
1:eac0369: 
1:eac0369: 		try 
1:eac0369:         {
1:eac0369: 
1:eac0369: 			// scan the log forward in redo pass and go to the end
1:eac0369: 			LogRecord record;
1:eac0369: 			while((record = 
1:eac0369:                     redoScan.getNextRecord(logIn, null, 0)) 
1:eac0369:                         != null)
1:eac0369: 			{
1:eac0369: 				scanCount++;
1:eac0369: 				long undoInstant = 0;
1:eac0369: 
1:eac0369: 				// last known good instant
1:eac0369: 				instant = redoScan.getInstant();
1:eac0369: 
1:eac0369: 				// last known good log end
1:eac0369: 				logEnd = redoScan.getLogRecordEnd();
1:eac0369: 
1:eac0369: 
1:eac0369: 				// NOTE NOTE -- be very careful about the undoInstant, it is
1:eac0369: 				// read off the input stream in this debug section.
1:eac0369: 				// if we change the log format we will need to change the way
1:eac0369: 				// the undo instant is gotten.  Also, once it is read off, it
1:eac0369: 				// should not be read from the stream any more
1:eac0369: 				// NOTE NOTE
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
1:eac0369:                         SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369: 
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
1:eac0369:                             SanityManager.DEBUG_SET(LogToFile.DBG_FLAG);
1:eac0369: 
1:eac0369:                         op = record.getLoggable();
1:eac0369:                         tranId = record.getTransactionId();
1:eac0369:                         if (record.isCLR())	
1:eac0369:                         {
1:eac0369:                             // !!!!!!! this moves the file pointer
1:eac0369:                             undoInstant = logIn.readLong();
1:eac0369: 
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "scanned " + tranId + " : " + op + 
1:eac0369:                                 " instant = " + 
1:eac0369:                                     LogCounter.toDebugString(instant) + 
1:eac0369:                                 " undoInstant : " + 
1:eac0369:                                     LogCounter.toDebugString(undoInstant));
1:eac0369:                         }
1:eac0369:                         else
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "scanned " + tranId + " : " + op + 
1:eac0369:                                 " instant = " + 
1:eac0369:                                     LogCounter.toDebugString(instant)
1:eac0369:                                 + " logEnd = " + 
1:eac0369:                                     LogCounter.toDebugString(logEnd) 
1:eac0369:                                 + " logIn at " + logIn.getPosition() 
1:eac0369:                                 + " available " + logIn.available());
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         // we only want to dump the log, don't touch it
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
1:eac0369:                             continue;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				// if the redo scan is between the undoLWM and redoLWM, we only
1:eac0369: 				// need to redo begin and end tran.  Everything else has
1:eac0369: 				// already been flushed by checkpoint
1:eac0369: 				if (redoLWM != 
1:eac0369:                         LogCounter.INVALID_LOG_INSTANT && instant < redoLWM)
1:eac0369: 				{
1:eac0369: 					if (!(record.isFirst()      || 
1:eac0369:                           record.isComplete()   || 
1:eac0369:                           record.isPrepare()))
1:eac0369:                     {
1:eac0369: 						continue;
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// get the transaction
1:eac0369: 				tranId = record.getTransactionId();
1:eac0369: 
1:eac0369: 				// if this transaction is known to the transaction factory, make
1:eac0369:                 // the recoveryTransaction assume its identitiy and properties
1:eac0369:                 // otherwise, make it known to the transaction factory
1:eac0369: 				if (!transFactory.findTransaction(tranId, recoveryTransaction))
1:eac0369: 				{
1:eac0369: 					// transaction not found
1:eac0369: 
1:eac0369: 					if (redoLWM != LogCounter.INVALID_LOG_INSTANT && 
1:eac0369: 						instant < redoLWM &&
1:eac0369:                         (record.isPrepare() || record.isComplete()))
1:eac0369: 					{
1:eac0369: 						// What is happening here is that a transaction that
1:eac0369: 						// started before the undoLWM has commited by the time
1:eac0369: 						// the checkpoint undoLWM was taken.  Hence, we only
1:eac0369: 						// see the tail end of its log record and its endXact
1:eac0369:                         // record. 
1:eac0369: 						// 
1:eac0369: 						// NOTE:
1:eac0369: 						// Since we didn't see its beginXact, we cannot do the
1:eac0369: 						// endXact's doMe either.  Also if the endXact, is
1:eac0369:                         // actually just a prepare, we don't need to do
1:eac0369:                         // anything as the transaction will commit or abort
1:eac0369:                         // prior to point we are recovering to.
1:eac0369: 						// If it is deemed necessary to do the endXact's doMe, 
1:eac0369:                         // then we should start the transaction right here. 
1:eac0369:                         // For now, just completely ignore this transaction
1:eac0369: 						// 
1:eac0369: 						etranCount++;
1:eac0369: 
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
1:eac0369:                         !record.isFirst())
1:eac0369:                     {
1:eac0369: 						throw StandardException.newException(
1:eac0369:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
1:eac0369:                             MessageService.getTextMessage(MessageId.LOG_RECORD_NOT_FIRST,tranId));
1:eac0369: 
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						// if we dumped the transaction table but see a non 
1:eac0369:                         // BeginXact record after the transaction table dump 
1:eac0369:                         // instant, error.
1:eac0369: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT)
1:eac0369: 						{
1:eac0369: 							if (instant > ttabInstant && !record.isFirst())
1:eac0369:                             {
1:eac0369: 								SanityManager.THROWASSERT(
1:eac0369: 								"log record is Not first but transaction " + 
1:eac0369:                                 "is not in transaction table (2) : " + tranId);
1:eac0369:                             }
1:eac0369: 
1:eac0369: 							// If we dump the transaction table and the table
1:eac0369: 							// does not have the transaction, and we see this
1:eac0369: 							// beginXact before the ttab instant, we could have
1:eac0369: 							// igored it because we "know" that we should see
1:eac0369: 							// the endXact before the ttab instant also.
1:eac0369: 							// Leave it in just in case.
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					btranCount++;
1:eac0369: 
1:eac0369: 					// the long transaction ID is embedded in the beginXact log
1:eac0369: 					// record.  The short ID is stored in the log record.
1:eac0369: 					recoveryTransaction.setTransactionId(
1:eac0369:                         record.getLoggable(), tranId);
1:eac0369: 
1:eac0369: 				}
1:eac0369: 				else				
1:eac0369: 				{
1:eac0369:                     // recoveryTransaction found
1:eac0369:                     
1:eac0369: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
1:eac0369:                          record.isFirst())
1:eac0369:                     {
1:eac0369: 						throw StandardException.newException(
1:eac0369:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
1:eac0369:                             MessageService.getTextMessage(MessageId.LOG_RECORD_FIRST,
1:eac0369:                                 tranId));
1:eac0369: 
1:eac0369:  
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT &&
1:eac0369: 							instant > ttabInstant &&
1:eac0369: 							record.isFirst())
1:eac0369:                         {
1:eac0369: 							SanityManager.THROWASSERT(
1:eac0369: 								"log record is first but transaction is " + 
1:eac0369:                                 "already in transaction table (3): " + tranId);
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         if (record.isPrepare())
1:eac0369:                             prepareCount++;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// if we have a transaction table dumped with the
1:eac0369: 					// checkpoint log record, then during the redo scan we may
1:eac0369: 					// see the beginXact of a transaction which is already in
1:eac0369:                     // the transaction table, just ignore it if it is after the
1:eac0369: 					// redoLWM but before the transaction table instant.  We
1:eac0369: 					// still need to redo any database changes but since the
1:eac0369: 					// transaction is already recorded in the transaction
1:eac0369: 					// table, ignore it.
1:eac0369: 					//
1:eac0369: 					if (record.isFirst())
1:eac0369: 					{
1:eac0369: 						btranCount++;
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				op = record.getLoggable();
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (!record.isCLR())
1:eac0369:                     {
1:eac0369:                         if (logIn.available() < 4)
1:eac0369:                         {
1:eac0369:                             SanityManager.THROWASSERT(
1:eac0369:                               "not enough bytes read in : " + 
1:eac0369:                                   logIn.available() + 
1:eac0369:                               " for " + op + " instant " + 
1:eac0369:                                   LogCounter.toDebugString(instant));
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369: 					SanityManager.ASSERT(
1:eac0369:                         !recoveryTransaction.handlesPostTerminationWork(),
1:eac0369: 					 	"recovery transaction handles post termination work");
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				if (op.needsRedo(recoveryTransaction))
1:eac0369: 				{
1:eac0369: 					redoCount++;
1:eac0369: 
1:eac0369: 					if (record.isCLR())	
1:eac0369: 					{
1:eac0369: 						clrCount++;
1:eac0369: 
1:eac0369: 						// the log operation is not complete, the operation to
1:eac0369: 						// undo is stashed away at the undoInstant.
1:eac0369: 						// Reconstitute that first.
1:eac0369: 
1:eac0369: 						if (SanityManager.DEBUG)
1:eac0369: 							SanityManager.ASSERT(op instanceof Compensation);
1:eac0369: 
1:eac0369: 
1:eac0369:                         // this value may be set by sanity xxxx
1:eac0369: 						if (undoInstant == 0) 
1:eac0369: 							undoInstant = logIn.readLong();
1:eac0369: 
1:eac0369: 						if (undoScan == null)
1:eac0369: 						{
1:eac0369: 							undoScan = (StreamLogScan)
1:eac0369: 								logFactory.openForwardsScan(
1:eac0369:                                     undoInstant,(LogInstant)null);
1:eac0369: 						}
1:eac0369: 						else
1:eac0369: 						{
1:eac0369: 							undoScan.resetPosition(new LogCounter(undoInstant));
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						// undoScan now positioned at the beginning of the log
1:eac0369: 						// record was rolled back by this CLR.  
1:eac0369: 						// The scan is a forward one so getNextRecord will get 
1:eac0369:                         // the log record that needs to be rolled back.
1:eac0369: 
1:eac0369: 						// reuse the buffer in logIn and logIn since CLR 
1:eac0369:                         // has no optional data and has no use for them anymore 
1:eac0369: 						logIn.clearLimit();
1:eac0369: 						LogRecord undoRecord =
1:eac0369: 							undoScan.getNextRecord(logIn, null, 0);
1:eac0369: 
1:eac0369: 						Undoable undoOp = undoRecord.getUndoable();
1:eac0369: 
1:eac0369: 						if (SanityManager.DEBUG)
1:eac0369: 						{
1:eac0369: 							SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "Redoing CLR: undoInstant = " + 
1:eac0369:                                     LogCounter.toDebugString(undoInstant) +
1:eac0369:                                 " clrinstant = " + 
1:eac0369:                                     LogCounter.toDebugString(instant));
1:eac0369: 
1:eac0369: 							SanityManager.ASSERT(
1:eac0369:                                 undoRecord.getTransactionId().equals(tranId));
1:eac0369: 
1:eac0369: 							SanityManager.ASSERT(undoOp != null);
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						((Compensation)op).setUndoOp(undoOp);
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// at this point, logIn points to the optional
1:eac0369: 					// data of the loggable that is to be redone or to be
1:eac0369: 					// rolled back
1:eac0369: 					
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:                         {
1:eac0369:                             SanityManager.DEBUG(
1:eac0369:                                 LogToFile.DBG_FLAG, 
1:eac0369:                                 "redoing " + op + 
1:eac0369:                                 " instant = " + 
1:eac0369:                                 LogCounter.toDebugString(instant));
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369: 					int dataLength = logIn.readInt();
1:8360656: 					logIn.setLimit(dataLength);
1:eac0369: 										
1:eac0369: 					// even though the log has already been written, we need to
1:eac0369: 					// tie the page to the log stream so that if redo failed
1:eac0369: 					// for some reasons, the log factory's corruption will stop
1:eac0369: 					// the corrupt page from flushing to disk.
1:eac0369: 
1:eac0369: 					op.doMe(
1:eac0369:                         recoveryTransaction, 
1:eac0369:                         new LogCounter(instant), logIn);
1:eac0369: 
1:eac0369: 					op.releaseResource(recoveryTransaction);
1:eac0369: 
1:eac0369: 					op = null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// RESOLVE: to speed up undo, may want to update the 
1:eac0369: 				// LastLogInstant in the transaction table.  
1:eac0369: 				// Right now, undo always start from the end of the log.
1:eac0369: 
1:eac0369: 				// one last thing, if this is the last log record of the
1:eac0369: 				// transaction, then commit the transaction and clean up
1:eac0369: 				//
1:eac0369: 				// 'commit' even though the transaction maybe a rollback
1:eac0369: 				// because we already did all the rollback work when redoing
1:eac0369: 				// the CLRs.  Commit will only flush the log if this session
1:eac0369: 				// has written any transaction, so in this case, it is a noop.
1:eac0369: 				if (record.isComplete())
1:eac0369: 				{
1:eac0369: 					etranCount++;
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(
1:eac0369:                             !recoveryTransaction.handlesPostTerminationWork(),
1:eac0369:                             "recovery xact handles post termination work");
1:eac0369: 
1:eac0369: 					recoveryTransaction.commit();
1:eac0369: 				}
1:2fb9556: 			} // while redoScan.getNextRecord() != null
1:2fb9556: 
1:2fb9556:             // If the scan ended in an empty file, update logEnd to reflect that
1:2fb9556:             // in order to avoid to continue logging to an older file
1:2fb9556:             long end = redoScan.getLogRecordEnd(); 
1:2fb9556:             if (end != LogCounter.INVALID_LOG_INSTANT
1:2fb9556:                 && (LogCounter.getLogFileNumber(logEnd) 
1:2fb9556:                     < LogCounter.getLogFileNumber(end))) {
1:2fb9556:                 logEnd = end;
1:2fb9556:             }
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.LOG_REDO_FAILED, se, op);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			// close all the io streams
1:eac0369: 			redoScan.close();
1:eac0369: 			redoScan = null;
1:eac0369: 
1:eac0369: 			if (undoScan != null)
1:eac0369: 			{
1:eac0369: 				undoScan.close();
1:eac0369: 				undoScan = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (op != null)
1:eac0369: 				op.releaseResource(recoveryTransaction);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     LogToFile.DBG_FLAG, 
1:eac0369:                     "----------------------------------------------------\n" +
1:eac0369:                     "End of recovery redo\n" + 
1:eac0369:                     "Scanned = " + scanCount + " log records" +
1:eac0369:                     ", redid = " + redoCount +
1:eac0369:                     " ( clr = " + clrCount + " )" +
1:eac0369:                     " begintran = " + btranCount +
1:eac0369:                     " endtran = " + etranCount + 
1:eac0369:                     " preparetran = " + prepareCount + 
1:eac0369:                     "\n log ends at " + LogCounter.toDebugString(logEnd) +
1:eac0369:                     "\n----------------------------------------------------\n");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			// make sure logEnd and instant is consistent
1:eac0369: 			if (instant != LogCounter.INVALID_LOG_INSTANT)	
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(
1:2fb9556:                     LogCounter.getLogFileNumber(instant) <
1:2fb9556:                          LogCounter.getLogFileNumber(logEnd) ||
1:2fb9556:                     (LogCounter.getLogFileNumber(instant) ==
1:eac0369:                          LogCounter.getLogFileNumber(logEnd) &&
1:eac0369:                      LogCounter.getLogFilePosition(instant) <=
1:2fb9556:                          LogCounter.getLogFilePosition(logEnd)));
1:eac0369:             }
1:eac0369: 			else
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(logEnd == LogCounter.INVALID_LOG_INSTANT);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // logEnd is the last good log record position in the log
1:eac0369: 		return logEnd;			
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read the next log record from the scan.
1:eac0369: 
1:eac0369: 		<P>MT - caller must provide synchronization (right now, it is only
1:eac0369: 		called in recovery to find the checkpoint log record.  When this method
1:eac0369: 		is called by a more general audience, MT must be revisited).
1:eac0369: 
1:eac0369: 		@param scan an opened log scan
1:eac0369: 		@param size estimated size of the log record
1:eac0369: 
1:eac0369: 		@return the log operation that is the next in the scan, or null if no
1:eac0369: 		more log operation in the log scan
1:eac0369: 
1:eac0369: 		@exception IOException	Error reading the log file
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 		@exception ClassNotFoundException log corrupted
1:eac0369: 	 */
1:eac0369: 	protected Loggable readLogRecord(StreamLogScan scan, int size)
1:eac0369: 		 throws IOException, StandardException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		Loggable lop = null;
1:eac0369: 
1:eac0369: 		ArrayInputStream logInputBuffer = new ArrayInputStream(new byte[size]);
1:eac0369: 
1:eac0369: 		LogRecord record = scan.getNextRecord(logInputBuffer, null, 0);
1:eac0369: 		if (record != null)
1:eac0369: 			lop = record.getLoggable();
1:eac0369: 		return lop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1: 	@derby.formatId	no formatId, format is implied by the log file format and the
1: 	@derby.purpose	the log record and optional data
1: 	@derby.upgrade
1: 	@derby.diskLayout
1: 	@derby.endFormat
1: 	@derby.formatId	no formatId, format is implied by the log file format and the
1: 	@derby.purpose	undo a previous log record
1: 	@derby.upgrade
1: 	@derby.diskLayout
/////////////////////////////////////////////////////////////////////////
1: 	@derby.endFormat
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8360656
/////////////////////////////////////////////////////////////////////////
1: 					rawInput.setLimit(optionalDataLength);
/////////////////////////////////////////////////////////////////////////
1: 					logIn.setLimit(dataLength);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2fb9556
/////////////////////////////////////////////////////////////////////////
1: 			} // while redoScan.getNextRecord() != null
1: 
1:             // If the scan ended in an empty file, update logEnd to reflect that
1:             // in order to avoid to continue logging to an older file
1:             long end = redoScan.getLogRecordEnd(); 
1:             if (end != LogCounter.INVALID_LOG_INSTANT
1:                 && (LogCounter.getLogFileNumber(logEnd) 
1:                     < LogCounter.getLogFileNumber(end))) {
1:                 logEnd = end;
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     LogCounter.getLogFileNumber(instant) <
1:                          LogCounter.getLogFileNumber(logEnd) ||
1:                     (LogCounter.getLogFileNumber(instant) ==
1:                          LogCounter.getLogFilePosition(logEnd)));
commit:75b112d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.log.FileLogger
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.log;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.MessageId;
1: 
1: import org.apache.derby.impl.store.raw.log.LogCounter;
1: import org.apache.derby.impl.store.raw.log.LogRecord;
1: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.raw.log.Logger;
1: import org.apache.derby.iapi.store.raw.log.LogScan;
1: 
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: 
1: import org.apache.derby.iapi.store.raw.Compensation;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Loggable;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RePreparable;
1: import org.apache.derby.iapi.store.raw.Undoable;
1: 
1: import org.apache.derby.iapi.services.io.FormatIdOutputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.ArrayOutputStream;
1: import org.apache.derby.iapi.util.ByteArray;
1: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
1: 
1: import org.apache.derby.iapi.services.io.LimitObjectInput;
1: import java.io.IOException;
1: 
1: import org.apache.derby.impl.store.raw.data.InitPageOperation;
1: 
1: /**
1: 	Write log records to a log file as a stream
1: 	(ie. log records added to the end of the file, no concept of pages).
1: <P>
1: 	The format of a log record that is not a compensation operation is
1: 	<PRE>
0: 	@format_id	no formatId, format is implied by the log file format and the
1: 		log record content.
0: 	@purpose	the log record and optional data
0: 	@upgrade
0: 	@disk_layout
1: 		Log Record
1: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
1: 		length(int)	length of optional data
1: 		optionalData(byte[length]) optional data written by the log record
0: 	@end_format
1: 	</PRE> <HR WIDTH="100%"> 
1: 
1: 	<P>	The form of a log record that is a compensation operation is
1: 	<PRE>
0: 	@format_id	no formatId, format is implied by the log file format and the
1: 	log record content.
0: 	@purpose	undo a previous log record
0: 	@upgrade
0: 	@disk_layout
1: 		Log Record that contains the compenstation operation
1: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
1: 		undoInstant(long) the log instant of the operation that is to be rolled back
1: 			The undo instant is logically part of the LogRecord but is written
1: 			by the logger because it is used and controlled by the rollback
1: 			code but not by the log operation.
1: 		There is no optional data in a compensation operation, all data
1: 		necessary for the rollback must be stored in the operation being
1: 		undone.
0: 	@end_format
1: 	</PRE>
1: 
1:     <BR>
1: 
1: 	<P>Multithreading considerations:<BR>
1: 	Logger must be MT-safe.	Each RawTransaction has its own private
1: 	FileLogger object. Each logger has a logOutputBuffer and a log input
1: 	buffer which are used to read and write to the log.  Since multiple
1: 	threads can be in the same transaction, fileLogger must be synchronized.
1: 
1: 	@see LogRecord
1: */
1: 
1: public class FileLogger implements Logger {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private LogRecord		 logRecord;
1: 
1: 	protected byte[] encryptionBuffer;
1: 	private DynamicByteArrayOutputStream logOutputBuffer;
1: 	private FormatIdOutputStream logicalOut;
1: 
1: 	private ArrayInputStream logIn;
1: 
1: 	private LogToFile logFactory;	// actually writes the log records.
1: 
1: 	/**
1: 		Make a new Logger with its own log record buffers
1: 		MT - not needed for constructor
1: 	*/
1: 	public FileLogger(LogToFile logFactory) {
1: 
1: 		this.logFactory = logFactory;
1: 		logOutputBuffer = new DynamicByteArrayOutputStream(1024); // init size 1K
1: 		logicalOut = new FormatIdOutputStream(logOutputBuffer);
1: 
1: 		// logIn and logOutputBuffer must share the same buffer because they
1: 		// combined to form an IO stream to access the same log record.
1: 		// 
1: 		// Before each use of logIn, you must reset logIn's data to the
1: 		// byte array you want to read from.
1: 		//
1: 		// To log a record, set logIn's data to point to logOutputBuffer's
1: 		// byte array when you know you have everything you need in the output
1: 		// buffer, then set limit on logIn and send it to the log operation's
1: 		// doMe.
1: 		//
1: 		// Keep in mind the dynamic nature of the logOutputBuffer which means
1: 		// it could switch buffer from underneath the logOutputBuffer on every
1: 		// write.
1: 		logIn = new ArrayInputStream();
1:  
1: 		logRecord = new LogRecord();
1: 
1: 	}
1: 
1: 	/**
1: 		Close the logger.
1: 		MT - caller provide synchronization
1: 		(RESOLVE: not called by anyone ??)
1: 	*/
1: 	public void close() throws IOException
1: 	{
1: 		if (logOutputBuffer != null)
1: 		{
1: 			logOutputBuffer.close();
1: 			logOutputBuffer = null;
1: 		}
1: 
1: 		logIn = null;
1: 		logFactory = null;
1: 
1: 		logicalOut = null;
1: 
1: 		logRecord = null;
1: 	}
1: 
1: 	/*
1: 	** Methods of Logger
1: 	*/
1: 
1: 	/**
1: 		Writes out a log record to the log stream, and call its doMe method to
1: 		apply the change to the rawStore.
1: 		<BR>Any optional data the doMe method need is first written to the log
1: 		stream using operation.writeOptionalData, then whatever is written to
1: 		the log stream is passed back to the operation for the doMe method.
1: 
1: 		<P>MT - there could be multiple threads running in the same raw
1: 		transactions and they can be calling the same logger to log different
1: 		log operations.  This whole method is synchronized to make sure log
1: 		records are logged one at a time.
1: 
1: 		@param xact the transaction logging the change
1: 		@param operation the log operation
1: 		@return the instant in the log that can be used to identify the log
1: 		record
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	*/
1: 	public synchronized LogInstant logAndDo(RawTransaction xact, Loggable operation) 
1: 		 throws StandardException 
1: 	{
1: 		boolean isLogPrepared = false;
1: 
1: 		boolean inUserCode = false;
1: 		byte[] preparedLog;
1: 
1: 		try {
1: 
1: 			logOutputBuffer.reset();
1: 
1: 			// always use the short Id, only the BeginXact log record contains
1: 			// the XactId (long form)
1: 			TransactionId transactionId = xact.getId();
1: 
1: 			// write out the log header with the operation embedded
1: 			// this is by definition not a compensation log record,
1: 			// those are called thru the logAndUndo interface
1: 			logRecord.setValue(transactionId, operation);
1: 
1: 			inUserCode = true;
1: 			logicalOut.writeObject(logRecord);
1: 			inUserCode = false;
1: 
1: 			int optionalDataLength = 0;
1: 			int optionalDataOffset = 0;
1: 			int completeLength = 0;
1: 
1: 			ByteArray preparedLogArray = operation.getPreparedLog();
1: 			if (preparedLogArray != null) {
1: 
1: 				preparedLog = preparedLogArray.getArray();
1: 				optionalDataLength = preparedLogArray.getLength();
1: 				optionalDataOffset = preparedLogArray.getOffset();
1: 
1: 				// There is a race condition if the operation is a begin tran in
1: 				// that between the time the beginXact log record is written to
1: 				// disk and the time the transaction object is updated in the
1: 				// beginXact.doMe method, other log records may be written.
1: 				// This will render the transaction table in an inconsistent state
1: 				// since it may think a later transaction is the earliest
1: 				// transaction or it may think that there is no active transactions
1: 				// where there is a bunch of them sitting on the log.
1: 				//
1: 				// Similarly, there is a race condition for endXact, i.e.,
1: 				// 1) endXact is written to the log, 
1: 				// 2) checkpoint gets that (committed) transaction as the
1: 				//		firstUpdateTransaction
1: 				// 3) the transaction calls postComplete, nulling out itself
1: 				// 4) checkpoint tries to access a closed transaction object
1: 				//
1: 				// The solution is to sync between the time a begin tran or end
1: 				// tran log record is sent to the log stream and its doMe method is
1: 				// called to update the transaction table and in memory state
1: 				//
1: 				// We only need to serialized the begin and end Xact log records
1: 				// because once a transaction has been started and in the
1: 				// transaction table, its order and transaction state does not
1: 				// change.
1: 				//
1: 				// Use the logFactory as the sync object so that a checkpoint can
1: 				// take its snap shot of the undoLWM before or after a transaction
1: 				// is started, but not in the middle. (see LogToFile.checkpoint)
1: 				//
1: 
1: 				// now set the input limit to be the optional data.  
1: 				// This limits amount of data availiable to logIn that doMe can
1: 				// use
1: 				logIn.setData(preparedLog);
1: 				logIn.setPosition(optionalDataOffset);
1: 				logIn.setLimit(optionalDataLength);
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if ((optionalDataLength) != logIn.available())
1: 						SanityManager.THROWASSERT(
1: 							" stream not set correctly " +
1: 							optionalDataLength + " != " +
1: 							 logIn.available());
1: 				}
1: 
1: 			} else {
1: 				preparedLog = null;
1: 				optionalDataLength = 0;
1: 			}
1: 
1: 			logicalOut.writeInt(optionalDataLength);
1: 			completeLength = logOutputBuffer.getPosition() + optionalDataLength;
1: 
1: 
1: 			LogInstant logInstant = null;
1: 			int encryptedLength = 0; // in case of encryption, we need to pad
1: 
1: 			try
1: 			{
1: 				if (logFactory.databaseEncrypted())
1: 				{
1: 					// we must pad the encryption data to be multiple of block
1: 					// size, which is logFactory.getEncryptionBlockSize()
1: 					encryptedLength = completeLength;
1: 					if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
1: 						encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
1: 
1: 					if (encryptionBuffer == null || 
1: 						encryptionBuffer.length < encryptedLength)
1: 						encryptionBuffer = new byte[encryptedLength];
1: 
1: 					System.arraycopy(logOutputBuffer.getByteArray(), 0, 
1: 									 encryptionBuffer, 0, completeLength-optionalDataLength);
1: 
1: 					if (optionalDataLength > 0)
1: 						System.arraycopy(preparedLog, optionalDataOffset, 
1: 									 encryptionBuffer,
1: 									 completeLength-optionalDataLength, optionalDataLength);
1: 
1: 					// do not bother to clear out the padding area 
1: 					int len = 
1: 						logFactory.encrypt(encryptionBuffer, 0, encryptedLength, 
1: 										   encryptionBuffer, 0);
1: 
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(len == encryptedLength, 
1: 							"encrypted log buffer length != log buffer len");
1: 				}
1: 
1: 				if ((operation.group() & (Loggable.FIRST | Loggable.LAST)) != 0)
1: 				{
1: 					synchronized (logFactory)
1: 					{
1: 						long instant = 0;
1: 
1: 						if (logFactory.databaseEncrypted())
1: 						{
1: 							// encryption has completely drained both the the
1: 							// logOuputBuffer array and the preparedLog array
1: 							instant = logFactory.
1: 								appendLogRecord(encryptionBuffer, 0, 
1: 												encryptedLength, null, 
1: 												-1, 0);
1: 						}
1: 						else
1: 						{
1: 							instant = logFactory.
1: 								appendLogRecord(logOutputBuffer.getByteArray(),
1: 												0, completeLength, preparedLog,
1: 												optionalDataOffset,
1: 												optionalDataLength);
1: 						}
1: 						logInstant = new LogCounter(instant);
1: 
1: 						operation.doMe(xact, logInstant, logIn);
1: 					}
1: 				}
1: 				else
1: 				{
1: 					long instant = 0;
1: 
1: 					if (logFactory.databaseEncrypted())
1: 					{
1: 						// encryption has completely drained both the the
1: 						// logOuputBuffer array and the preparedLog array
1: 						instant = logFactory.
1: 							appendLogRecord(encryptionBuffer, 0, 
1: 											encryptedLength, null, -1, 0);
1: 					}
1: 					else
1: 					{
1: 						instant = logFactory.
1: 							appendLogRecord(logOutputBuffer.getByteArray(), 0,
1: 											completeLength, preparedLog,
1: 											optionalDataOffset,
1: 											optionalDataLength); 
1: 					}
1: 
1: 					logInstant = new LogCounter(instant);
1: 
1: 					operation.doMe(xact, logInstant, logIn);
1: 				}
1: 
1: 			}
1: 			catch (StandardException se)
1: 			{
1: 				throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_DO_ME_FAIL, se, operation));
1: 			}
1: 			catch (IOException ioe)
1: 			{
1: 				throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_DO_ME_FAIL, ioe, operation));
1: 			}
1: 			finally
1: 			{
1: 				logIn.clearLimit();
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                 {
1:                     SanityManager.DEBUG(
1:                         LogToFile.DBG_FLAG, 
1:                         "Write log record: tranId=" + transactionId.toString() +
1:                         " instant: " + logInstant.toString() + " length: " +
1:                         completeLength + "\n" + operation + "\n");
1:                 }
1: 			}
1: 			return logInstant;
1: 		}
1: 
1: 		catch (IOException ioe) 
1: 		{
1: 			// error writing to the log buffer
1: 			if (inUserCode)
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, operation);
1:             }
1: 			else
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.LOG_BUFFER_FULL, ioe, operation);
1:             }
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Writes out a compensation log record to the log stream, and call its
1: 		doMe method to undo the change of a previous log operation.
1: 
1: 		<P>MT - Not needed. A transaction must be single threaded thru undo, each
1: 		RawTransaction has its own logger, therefore no need to synchronize.
1: 		The RawTransaction must handle synchronizing with multiple threads
1: 		during rollback.
1: 
1: 		@param xact the transaction logging the change
1: 		@param compensation the compensation log operation
1: 		@param undoInstant the log instant of the operation that is to be
1: 		rolled back
1: 		@param in optional data input for the compenastion doMe method
0: 		@param dataLength optional data length
1: 
1: 		@return the instant in the log that can be used to identify the log
1: 		record
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	 */
1: 	public LogInstant logAndUndo(RawTransaction xact, 
1: 								 Compensation compensation,
1: 								 LogInstant undoInstant,
1: 								 LimitObjectInput in)
1: 		 throws StandardException
1: 	{
1: 		boolean inUserCode = false;
1: 
1: 		try {
1: 			logOutputBuffer.reset();
1: 
1: 			TransactionId transactionId = xact.getId();
1: 
1: 			// write out the log header with the operation embedded
1: 			logRecord.setValue(transactionId, compensation);
1: 
1: 			inUserCode = true;
1: 			logicalOut.writeObject(logRecord);
1: 			inUserCode = false;
1: 
1: 			// write out the undoInstant
1: 			logicalOut.writeLong(((LogCounter)undoInstant).getValueAsLong());
1: 
1: 			// in this implemetaion, there is no optional data for the
1: 			// compensation operation.  Optional data for the rollback comes
1: 			// from the undoable operation - and is passed into this call.
1: 			int completeLength = logOutputBuffer.getPosition();
1: 			long instant = 0;
1: 			
1: 			if (logFactory.databaseEncrypted())
1: 			{
1: 				// we must pad the encryption data to be multiple of block
1: 				// size, which is logFactory.getEncryptionBlockSize()
1: 				int encryptedLength = completeLength;
1: 				if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
1: 					encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
1: 
1: 				if (encryptionBuffer == null || 
1: 					encryptionBuffer.length < encryptedLength)
1: 					encryptionBuffer = new byte[encryptedLength];
1: 
1: 				System.arraycopy(logOutputBuffer.getByteArray(), 0, 
1: 								 encryptionBuffer, 0, completeLength);
1: 
1: 				// do not bother to clear out the padding area 
1: 				int len = 
1: 					logFactory.encrypt(encryptionBuffer, 0, encryptedLength,
1: 									   encryptionBuffer, 0);
1: 
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(len == encryptedLength, 
1: 						"encrypted log buffer length != log buffer len");
1: 
1: 				instant = logFactory.
1: 					appendLogRecord(encryptionBuffer,
1: 									0, encryptedLength, null, 0, 0);
1: 			}
1: 			else
1: 			{
1: 				instant = logFactory.
1: 					appendLogRecord(logOutputBuffer.getByteArray(), 
1: 									0, completeLength, null, 0, 0);
1: 			}
1: 
1: 			LogInstant logInstant = new LogCounter(instant);
1: 
1: 			if (SanityManager.DEBUG)
1:             {
1:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                 {
1:                     SanityManager.DEBUG(
1:                         LogToFile.DBG_FLAG, 
1:                         "Write CLR: Xact: " + transactionId.toString() +
1:                         "clrinstant: " + logInstant.toString() + 
1:                         " undoinstant " + undoInstant + "\n");
1:                 }
1: 			}
1: 
1: 			try
1: 			{
1: 				// in and dataLength contains optional data that was written 
1: 				// to the log during a previous call to logAndDo.
1: 				compensation.doMe(xact, logInstant, in);
1: 			}
1: 			catch (StandardException se)
1: 			{
1: 				throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_DO_ME_FAIL, se, compensation));
1: 			}
1: 			catch (IOException ioe)
1: 			{
1: 				throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_DO_ME_FAIL, ioe, compensation));
1: 			}
1: 
1: 			return logInstant;
1: 
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			if (inUserCode)
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, compensation);
1:             }
1: 			else
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.LOG_BUFFER_FULL, ioe, compensation);
1:             }
1: 		}
1: 	}
1: 
1: 	/**
1: 		Flush the log up to the given log instant.
1: 
1: 		<P>MT - not needed, wrapper method
1: 
1: 		@exception StandardException cannot sync log file
1: 	*/
1: 	public void flush(LogInstant where) 
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, "Flush log to " + where.toString());
1:             }
1: 		}
1: 
1: 		logFactory.flush(where);
1: 	}
1: 
1: 	/**
1: 		Flush all outstanding log to disk.
1: 
1: 		<P>MT - not needed, wrapper method
1: 
1: 		@exception StandardException cannot sync log file
1: 	*/
1: 	public void flushAll () throws StandardException
1: 	{
1: 		logFactory.flushAll();
1: 	}
1: 
1:     /**
1:      * During recovery re-prepare a transaction.
1:      * <p>
1:      * After redo() and undo(), this routine is called on all outstanding 
1:      * in-doubt (prepared) transactions.  This routine re-acquires all 
1:      * logical write locks for operations in the xact, and then modifies
1:      * the transaction table entry to make the transaction look as if it
1:      * had just been prepared following startup after recovery.
1:      * <p>
1:      *
1:      * @param t                 is the transaction performing the re-prepare
1:      * @param prepareId         is the transaction ID to be re-prepared
1:      * @param prepareStopAt     is where the log instant (inclusive) where the 
1:      *                          re-prepare should stop.
1:      * @param prepareStartAt    is the log instant (inclusive) where re-prepare 
1:      *                          should begin, this is normally the log instant 
1:      *                          of the last log record of the transaction that 
1:      *                          is to be re-prepare.  If null, then re-prepare 
1:      *                          starts from the end of the log.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void reprepare(
1:     RawTransaction  t,
1:     TransactionId   prepareId,
1:     LogInstant      prepareStopAt,
1:     LogInstant      prepareStartAt) 
1:         throws StandardException
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 if (prepareStartAt != null)
1:                 {
1:                     SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                     "----------------------------------------------------\n" +
1:                     "\nBegin of RePrepare : " + prepareId.toString() + 
1:                         "start at " + prepareStartAt.toString() + 
1:                         " stop at " + prepareStopAt.toString()  +
1:                     "\n----------------------------------------------------\n");
1:                 }
1:                 else
1:                 {
1:                     SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                     "----------------------------------------------------\n" +
1:                     "\nBegin of Reprepare: " + prepareId.toString() + 
1:                         "start at end of log stop at " + 
1:                         prepareStopAt.toString() +
1:                     "\n----------------------------------------------------\n");
1:                 }
1:             }
1: 		}
1: 
1: 		// statistics
1: 		int clrskipped      = 0;
1: 		int logrecordseen   = 0;
1: 
1: 		RePreparable lop          = null;
1: 
1: 		// stream to read the log record - initial size 4096, scanLog needs
1: 		// to resize if the log record is larger than that.
1: 		ArrayInputStream    rawInput    = null;
1: 
1: 		try
1: 		{
1:             StreamLogScan scanLog;
1: 
1: 			if (prepareStartAt == null)
1:             {
1:                 // don't know where to start, scan from end of log
1: 				scanLog = 
1:                     (StreamLogScan) logFactory.openBackwardsScan(prepareStopAt);
1:             }
1: 			else
1: 			{
1: 				if (prepareStartAt.lessThan(prepareStopAt)) 
1:                 {
1:                     // nothing to prepare!
1: 					return;
1:                 }
1: 
1: 				scanLog = (StreamLogScan)
1: 					logFactory.openBackwardsScan(
1:                         ((LogCounter) prepareStartAt).getValueAsLong(),
1:                         prepareStopAt);
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(
1:                     scanLog != null, "cannot open log for prepare");
1: 
1: 			rawInput    = new ArrayInputStream(new byte[4096]);
1: 
1: 			LogRecord record;
1: 
1: 			while ((record = 
1:                     scanLog.getNextRecord(rawInput, prepareId, 0)) 
1:                        != null) 
1: 			{ 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(
1:                         record.getTransactionId().equals(prepareId),
1: 					    "getNextRecord return unqualified log rec for prepare");
1: 				}
1: 
1: 				logrecordseen++;
1: 
1: 				if (record.isCLR())
1: 				{
1: 					clrskipped++;
1: 
1:                     // the loggable is still in the input stream, get rid of it
1: 					record.skipLoggable(); 
1: 
1: 					// read the prepareInstant
1: 					long prepareInstant = rawInput.readLong();
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                     "Skipping over CLRs, reset scan to " + 
1:                                     LogCounter.toDebugString(prepareInstant));
1:                         }
1: 					}
1: 
1: 					scanLog.resetPosition(new LogCounter(prepareInstant));
1: 					// scanLog now positioned at the beginning of the log
1: 					// record that was rolled back by this CLR.
1: 					// The scan is a backward one so getNextRecord will skip
1: 					// over the record that was rolled back and go to the one
1: 					// previous to it
1: 
1: 					continue;
1: 				}
1: 
1:                 if (record.requiresPrepareLocks())
1:                 {
1:                     lop = record.getRePreparable();
1:                 }
1:                 else
1:                 {
1:                     continue;
1:                 }
1: 
1: 				if (lop != null)
1: 				{
1:                     // Reget locks based on log record.  reclaim all locks with
1:                     // a serializable locking policy, since we are only 
1:                     // reclaiming write locks, isolation level does not matter
1:                     // much.
1: 
1:                     lop.reclaimPrepareLocks(
1:                         t,
1:                         t.newLockingPolicy(
1:                             LockingPolicy.MODE_RECORD, 
1:                             TransactionController.ISOLATION_REPEATABLE_READ, 
1:                             true));
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "Reprepare log record at instant " +
1:                                 scanLog.getInstant() + " : " + lop);
1:                         }
1:                     }
1: 
1: 				}
1: 			}
1: 
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1: 		}
1: 	    catch (IOException ioe) 
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			throw 
1:                 logFactory.markCorrupt(
1:                     StandardException.newException(
1:                         SQLState.LOG_UNDO_FAILED, se,  
1:                         prepareId, lop, (Object) null));
1: 		}
1: 		finally
1: 		{
1: 			if (rawInput != null)
1: 			{
1: 				try
1: 				{
1: 					rawInput.close();
1: 				}
1: 				catch (IOException ioe)
1: 				{
1: 					throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, prepareId));
1: 				}
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(LogToFile.DBG_FLAG, "Finish prepare" +
1:                                     ", clr skipped = " + clrskipped + 
1:                                     ", record seen = " + logrecordseen + "\n");
1:             }
1:         }
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                     "----------------------------------------------------\n" +
1:                     "End of recovery rePrepare\n" + 
1:                     ", clr skipped = " + clrskipped + 
1:                     ", record seen = " + logrecordseen + 
1:                     "\n----------------------------------------------------\n");
1:             }
1:         }
1: 	}
1: 
1: 
1: 	/**
1: 		Undo a part of or the entire transaction.  Begin rolling back the log
1: 		record at undoStartAt and stopping at (inclusive) the log record at
1: 		undoStopAt.
1: 
1: 		<P>MT - Not needed. A transaction must be single threaded thru undo, 
1:         each RawTransaction has its own logger, therefore no need to 
1:         synchronize.  The RawTransaction must handle synchronizing with 
1:         multiple threads during rollback.
1: 
1: 		@param t 			the transaction that needs to be rolled back
1: 		@param undoId 		the transaction ID
1: 		@param undoStopAt	the last log record that should be rolled back
1: 		@param undoStartAt	the first log record that should be rolled back
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 
1: 		@see Logger#undo
1: 	  */
1: 	public void undo(
1:     RawTransaction  t, 
1:     TransactionId   undoId, 
1:     LogInstant      undoStopAt, 
1:     LogInstant      undoStartAt)
1: 		throws StandardException 
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 if (undoStartAt != null)
1:                 {
1:                     SanityManager.DEBUG(
1:                         LogToFile.DBG_FLAG, 
1:                         "\nUndo transaction: " + undoId.toString() + 
1:                         "start at " + undoStartAt.toString() + 
1:                         " stop at " + undoStopAt.toString() );
1:                 }
1:                 else
1:                 {
1:                     SanityManager.DEBUG(
1:                         LogToFile.DBG_FLAG, 
1:                         "\nUndo transaction: " + undoId.toString() + 
1:                         "start at end of log stop at " + undoStopAt.toString());
1:                 }
1:             }
1:         }
1: 
1: 		// statistics
1: 		int clrgenerated  = 0;
1: 		int clrskipped    = 0;
1: 		int logrecordseen = 0;
1: 
1: 		StreamLogScan scanLog;
1: 		Compensation  compensation = null;
1: 		Undoable      lop          = null;
1: 
1: 		// stream to read the log record - initial size 4096, scanLog needs
1: 		// to resize if the log record is larget than that.
1: 		ArrayInputStream    rawInput   = null;
1: 
1: 		try
1: 		{
1: 			if (undoStartAt == null)	
1:             {
1:                 // don't know where to start, rollback from end of log
1: 
1: 				scanLog = (StreamLogScan)
1: 					logFactory.openBackwardsScan(undoStopAt);
1:             }
1: 			else
1: 			{
1: 				if (undoStartAt.lessThan(undoStopAt))
1:                 {
1:                     // nothing to undo!
1: 					return;
1:                 }
1: 
1: 				long undoStartInstant = 
1:                     ((LogCounter) undoStartAt).getValueAsLong();
1: 
1: 				scanLog = (StreamLogScan)
1: 					logFactory.openBackwardsScan(undoStartInstant, undoStopAt);
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(
1:                     scanLog != null, "cannot open log for undo");
1: 
1: 			rawInput   = new ArrayInputStream(new byte[4096]);
1: 
1: 			LogRecord record;
1: 
1: 			while ((record = 
1:                     scanLog.getNextRecord(rawInput, undoId, 0)) 
1:                         != null) 
1: 			{ 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(
1:                         record.getTransactionId().equals(undoId),
1:                         "getNextRecord return unqualified log record for undo");
1: 				}
1: 
1: 				logrecordseen++;
1: 
1: 				if (record.isCLR())
1: 				{
1: 					clrskipped++;
1: 
1:                     // the loggable is still in the input stream, get rid of it
1: 					record.skipLoggable(); 
1: 
1: 					// read the undoInstant
1: 					long undoInstant = rawInput.readLong();
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "Skipping over CLRs, reset scan to " + 
1:                                 LogCounter.toDebugString(undoInstant));
1:                         }
1:                     }
1: 
1: 
1: 					scanLog.resetPosition(new LogCounter(undoInstant));
1: 
1: 					// scanLog now positioned at the beginning of the log
1: 					// record that was rolled back by this CLR.
1: 					// The scan is a backward one so getNextRecord will skip
1: 					// over the record that was rolled back and go to the one
1: 					// previous to it
1: 
1: 					continue;
1: 				}
1: 
1: 				lop = record.getUndoable();
1: 
1: 				if (lop != null)
1: 				{
1: 					int optionalDataLength = rawInput.readInt();
1: 					int savePosition = rawInput.getPosition();
1: 					rawInput.setLimit(savePosition, optionalDataLength);
1: 	
1: 					compensation = lop.generateUndo(t, rawInput);
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "Rollback log record at instant " +
1:                                 LogCounter.toDebugString(scanLog.getInstant()) +
1:                                 " : " + lop);
1:                         }
1:                     }
1: 
1: 					clrgenerated++;
1: 
1: 					if (compensation != null)
1: 					{
1: 						// generateUndo may have read stuff off the
1: 						// stream, reset it for the undo operation.
1: 						rawInput.setLimit(savePosition, optionalDataLength);
1: 
1: 						// log the compensation op that rolls back the 
1:                         // operation at this instant 
1: 						t.logAndUndo(
1:                             compensation, new LogCounter(scanLog.getInstant()),
1:                             rawInput);
1: 
1: 						compensation.releaseResource(t);
1: 						compensation = null;
1: 					}
1: 
1: 					// if compensation is null, log operation is redo only
1: 				}
1: 				// if this is not an undoable operation, continue with next log
1: 				// record
1: 			}
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1: 		}
1: 	    catch (IOException ioe) 
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
1: 		}
1: 		catch (StandardException se)
1: 		{
1:             // TODO (4327) - exceptions caught here are nested in the exception
1:             // below but for some reason the nested exceptions are not logged 
1:             // or reported in any way.
1: 
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(
1:                     SQLState.LOG_UNDO_FAILED, se, undoId, lop, compensation));
1: 		}
1: 		finally
1: 		{
1: 			if (compensation != null) 
1:             {
1:                 // errored out
1: 				compensation.releaseResource(t);
1:             }
1: 
1: 			if (rawInput != null)
1: 			{
1: 				try
1: 				{
1: 					rawInput.close();
1: 				}
1: 				catch (IOException ioe)
1: 				{
1: 					throw logFactory.markCorrupt(
1:                         StandardException.newException(
1:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, undoId));
1: 				}
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                         "Finish undo" +
1:                         ", clr generated = " + clrgenerated +
1:                         ", clr skipped = " + clrskipped + 
1:                         ", record seen = " + logrecordseen + "\n");
1:             }
1:         }
1: 	}
1: 
1: 
1: 	/**
1: 		Recovery Redo loop.
1: 
1: 		<P> The log stream is scanned from the beginning (or
1: 		from the undo low water mark of a checkpoint) forward until the end.
1: 		The purpose of the redo pass is to repeat history, i.e, to repeat
1: 		exactly the same set of changes the rawStore went thru right before it
1: 		stopped.   With each log record that is encountered in the redo pass:
1: 		<OL>
1: 		<LI>if it isFirst(), then the transaction factory is called upon to
1: 		    create a new transaction object.
1: 		<LI>if it needsRedo(), its doMe() is called (if it is a compensation
1: 		    operation, then the undoable operation needs to be created first
1:             before the doMe is called).
1: 		<LI>if it isComplete(), then the transaction object is closed.
1: 		</OL>
1: 
1: 		<P> MT - caller provides synchronization
1: 
0: 		@param logData          - a scratch area to put the log record in
0: 		@param rawStoreFactory  - the raw store factory
1: 		@param transFactory     - the transaction factory
0: 		@param redoStart        - if > 0, a checkpoint was found.
0: 		                          Start the log scan from here to rebuild 
0:                                   transaction table.
1: 		@param redoLWM          - if checkpoint seen, starting from this point
1:                                   on, apply redo if necessary
1: 
1: 		@return the log instant of the next log record (or the instant just
1: 		after the last log record).  This is used to determine where the log
1: 		truly ends
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 		@exception IOException error reading log file
1: 		@exception ClassNotFoundException log file corrupted
1: 
1: 		@see LogToFile#recover
1: 	 */
1: 	protected long redo(
1:     RawTransaction      recoveryTransaction,
1:     TransactionFactory  transFactory,
1:     StreamLogScan       redoScan,
1:     long                redoLWM,
1:     long                ttabInstant)
1: 		 throws IOException, StandardException, ClassNotFoundException
1: 	{
1: 		// begin debug info
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                     "In recovery redo, redoLWM = " + redoLWM);
1:             }
1:         }
1: 
1: 		int scanCount    = 0;
1:         int redoCount    = 0;
1:         int prepareCount = 0; 
1:         int clrCount     = 0;
1:         int btranCount   = 0;
1:         int etranCount   = 0;
1: 
1: 		// end debug info
1: 
1: 		TransactionId tranId = null;
1: 
1:         // the current log instant
1: 		long instant = LogCounter.INVALID_LOG_INSTANT;
1: 
1: 		//////////////////////////////////////////////////////////////////////
1: 		// During redo time, the byte array in the logOutputBuffer is not used.
1: 		// Use it to read the log record - if it is not big enough, scan
1: 		// will resize it.  We could create a brand new log input stream that
1: 		// has nothing to do with logIn or logOutputBuffer but that seem like
1: 		// a waste of memory.
1: 		//////////////////////////////////////////////////////////////////////
1: 		logIn.setData(logOutputBuffer.getByteArray());
1: 
1: 		// use this scan to reconstitute operation to be undone
1: 		// when we see a CLR in the redo scan
1: 		StreamLogScan undoScan  = null;
1: 		Loggable      op        = null;
1: 		long          logEnd    = 0;  // we need to determine the log's true end
1: 
1: 		try 
1:         {
1: 
1: 			// scan the log forward in redo pass and go to the end
1: 			LogRecord record;
1: 			while((record = 
1:                     redoScan.getNextRecord(logIn, null, 0)) 
1:                         != null)
1: 			{
1: 				scanCount++;
1: 				long undoInstant = 0;
1: 
1: 				// last known good instant
1: 				instant = redoScan.getInstant();
1: 
1: 				// last known good log end
1: 				logEnd = redoScan.getLogRecordEnd();
1: 
1: 
1: 				// NOTE NOTE -- be very careful about the undoInstant, it is
1: 				// read off the input stream in this debug section.
1: 				// if we change the log format we will need to change the way
1: 				// the undo instant is gotten.  Also, once it is read off, it
1: 				// should not be read from the stream any more
1: 				// NOTE NOTE
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
1:                         SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1: 
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
1:                             SanityManager.DEBUG_SET(LogToFile.DBG_FLAG);
1: 
1:                         op = record.getLoggable();
1:                         tranId = record.getTransactionId();
1:                         if (record.isCLR())	
1:                         {
1:                             // !!!!!!! this moves the file pointer
1:                             undoInstant = logIn.readLong();
1: 
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "scanned " + tranId + " : " + op + 
1:                                 " instant = " + 
1:                                     LogCounter.toDebugString(instant) + 
1:                                 " undoInstant : " + 
1:                                     LogCounter.toDebugString(undoInstant));
1:                         }
1:                         else
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "scanned " + tranId + " : " + op + 
1:                                 " instant = " + 
1:                                     LogCounter.toDebugString(instant)
1:                                 + " logEnd = " + 
1:                                     LogCounter.toDebugString(logEnd) 
1:                                 + " logIn at " + logIn.getPosition() 
1:                                 + " available " + logIn.available());
1:                         }
1: 
1:                         // we only want to dump the log, don't touch it
1:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
1:                             continue;
1:                     }
1:                 }
1: 
1: 				// if the redo scan is between the undoLWM and redoLWM, we only
1: 				// need to redo begin and end tran.  Everything else has
1: 				// already been flushed by checkpoint
1: 				if (redoLWM != 
1:                         LogCounter.INVALID_LOG_INSTANT && instant < redoLWM)
1: 				{
1: 					if (!(record.isFirst()      || 
1:                           record.isComplete()   || 
1:                           record.isPrepare()))
1:                     {
1: 						continue;
1:                     }
1: 				}
1: 
1: 				// get the transaction
1: 				tranId = record.getTransactionId();
1: 
1: 				// if this transaction is known to the transaction factory, make
1:                 // the recoveryTransaction assume its identitiy and properties
1:                 // otherwise, make it known to the transaction factory
1: 				if (!transFactory.findTransaction(tranId, recoveryTransaction))
1: 				{
1: 					// transaction not found
1: 
1: 					if (redoLWM != LogCounter.INVALID_LOG_INSTANT && 
1: 						instant < redoLWM &&
1:                         (record.isPrepare() || record.isComplete()))
1: 					{
1: 						// What is happening here is that a transaction that
1: 						// started before the undoLWM has commited by the time
1: 						// the checkpoint undoLWM was taken.  Hence, we only
1: 						// see the tail end of its log record and its endXact
1:                         // record. 
1: 						// 
1: 						// NOTE:
1: 						// Since we didn't see its beginXact, we cannot do the
1: 						// endXact's doMe either.  Also if the endXact, is
1:                         // actually just a prepare, we don't need to do
1:                         // anything as the transaction will commit or abort
1:                         // prior to point we are recovering to.
1: 						// If it is deemed necessary to do the endXact's doMe, 
1:                         // then we should start the transaction right here. 
1:                         // For now, just completely ignore this transaction
1: 						// 
1: 						etranCount++;
1: 
1: 						continue;
1: 					}
1: 
1: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
1:                         !record.isFirst())
1:                     {
1: 						throw StandardException.newException(
1:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
1:                             MessageService.getTextMessage(MessageId.LOG_RECORD_NOT_FIRST,tranId));
1: 
1:                     }
1: 
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						// if we dumped the transaction table but see a non 
1:                         // BeginXact record after the transaction table dump 
1:                         // instant, error.
1: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT)
1: 						{
1: 							if (instant > ttabInstant && !record.isFirst())
1:                             {
1: 								SanityManager.THROWASSERT(
1: 								"log record is Not first but transaction " + 
1:                                 "is not in transaction table (2) : " + tranId);
1:                             }
1: 
1: 							// If we dump the transaction table and the table
1: 							// does not have the transaction, and we see this
1: 							// beginXact before the ttab instant, we could have
1: 							// igored it because we "know" that we should see
1: 							// the endXact before the ttab instant also.
1: 							// Leave it in just in case.
1: 						}
1: 					}
1: 					btranCount++;
1: 
1: 					// the long transaction ID is embedded in the beginXact log
1: 					// record.  The short ID is stored in the log record.
1: 					recoveryTransaction.setTransactionId(
1:                         record.getLoggable(), tranId);
1: 
1: 				}
1: 				else				
1: 				{
1:                     // recoveryTransaction found
1:                     
1: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
1:                          record.isFirst())
1:                     {
1: 						throw StandardException.newException(
1:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
1:                             MessageService.getTextMessage(MessageId.LOG_RECORD_FIRST,
1:                                 tranId));
1: 
1:  
1:                     }
1: 
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT &&
1: 							instant > ttabInstant &&
1: 							record.isFirst())
1:                         {
1: 							SanityManager.THROWASSERT(
1: 								"log record is first but transaction is " + 
1:                                 "already in transaction table (3): " + tranId);
1:                         }
1: 
1:                         if (record.isPrepare())
1:                             prepareCount++;
1: 					}
1: 
1: 					// if we have a transaction table dumped with the
1: 					// checkpoint log record, then during the redo scan we may
1: 					// see the beginXact of a transaction which is already in
1:                     // the transaction table, just ignore it if it is after the
1: 					// redoLWM but before the transaction table instant.  We
1: 					// still need to redo any database changes but since the
1: 					// transaction is already recorded in the transaction
1: 					// table, ignore it.
1: 					//
1: 					if (record.isFirst())
1: 					{
1: 						btranCount++;
1: 						continue;
1: 					}
1: 				}
1: 				
1: 				op = record.getLoggable();
1: 
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (!record.isCLR())
1:                     {
1:                         if (logIn.available() < 4)
1:                         {
1:                             SanityManager.THROWASSERT(
1:                               "not enough bytes read in : " + 
1:                                   logIn.available() + 
1:                               " for " + op + " instant " + 
1:                                   LogCounter.toDebugString(instant));
1:                         }
1:                     }
1:                 }
1: 
1: 				if (SanityManager.DEBUG)
1:                 {
1: 					SanityManager.ASSERT(
1:                         !recoveryTransaction.handlesPostTerminationWork(),
1: 					 	"recovery transaction handles post termination work");
1:                 }
1: 
1: 				if (op.needsRedo(recoveryTransaction))
1: 				{
1: 					redoCount++;
1: 
1: 					if (record.isCLR())	
1: 					{
1: 						clrCount++;
1: 
1: 						// the log operation is not complete, the operation to
1: 						// undo is stashed away at the undoInstant.
1: 						// Reconstitute that first.
1: 
1: 						if (SanityManager.DEBUG)
1: 							SanityManager.ASSERT(op instanceof Compensation);
1: 
1: 
1:                         // this value may be set by sanity xxxx
1: 						if (undoInstant == 0) 
1: 							undoInstant = logIn.readLong();
1: 
1: 						if (undoScan == null)
1: 						{
1: 							undoScan = (StreamLogScan)
1: 								logFactory.openForwardsScan(
1:                                     undoInstant,(LogInstant)null);
1: 						}
1: 						else
1: 						{
1: 							undoScan.resetPosition(new LogCounter(undoInstant));
1: 						}
1: 
1: 						// undoScan now positioned at the beginning of the log
1: 						// record was rolled back by this CLR.  
1: 						// The scan is a forward one so getNextRecord will get 
1:                         // the log record that needs to be rolled back.
1: 
1: 						// reuse the buffer in logIn and logIn since CLR 
1:                         // has no optional data and has no use for them anymore 
1: 						logIn.clearLimit();
1: 						LogRecord undoRecord =
1: 							undoScan.getNextRecord(logIn, null, 0);
1: 
1: 						Undoable undoOp = undoRecord.getUndoable();
1: 
1: 						if (SanityManager.DEBUG)
1: 						{
1: 							SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "Redoing CLR: undoInstant = " + 
1:                                     LogCounter.toDebugString(undoInstant) +
1:                                 " clrinstant = " + 
1:                                     LogCounter.toDebugString(instant));
1: 
1: 							SanityManager.ASSERT(
1:                                 undoRecord.getTransactionId().equals(tranId));
1: 
1: 							SanityManager.ASSERT(undoOp != null);
1: 						}
1: 
1: 						((Compensation)op).setUndoOp(undoOp);
1: 					}
1: 
1: 					// at this point, logIn points to the optional
1: 					// data of the loggable that is to be redone or to be
1: 					// rolled back
1: 					
1: 					if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:                         {
1:                             SanityManager.DEBUG(
1:                                 LogToFile.DBG_FLAG, 
1:                                 "redoing " + op + 
1:                                 " instant = " + 
1:                                 LogCounter.toDebugString(instant));
1:                         }
1:                     }
1: 
1: 					int dataLength = logIn.readInt();
0: 					logIn.setLimit(logIn.getPosition(), dataLength);
1: 										
1: 					// even though the log has already been written, we need to
1: 					// tie the page to the log stream so that if redo failed
1: 					// for some reasons, the log factory's corruption will stop
1: 					// the corrupt page from flushing to disk.
1: 
1: 					op.doMe(
1:                         recoveryTransaction, 
1:                         new LogCounter(instant), logIn);
1: 
1: 					op.releaseResource(recoveryTransaction);
1: 
1: 					op = null;
1: 				}
1: 
1: 				// RESOLVE: to speed up undo, may want to update the 
1: 				// LastLogInstant in the transaction table.  
1: 				// Right now, undo always start from the end of the log.
1: 
1: 				// one last thing, if this is the last log record of the
1: 				// transaction, then commit the transaction and clean up
1: 				//
1: 				// 'commit' even though the transaction maybe a rollback
1: 				// because we already did all the rollback work when redoing
1: 				// the CLRs.  Commit will only flush the log if this session
1: 				// has written any transaction, so in this case, it is a noop.
1: 				if (record.isComplete())
1: 				{
1: 					etranCount++;
1: 
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(
1:                             !recoveryTransaction.handlesPostTerminationWork(),
1:                             "recovery xact handles post termination work");
1: 
1: 					recoveryTransaction.commit();
1: 				}
1: 			}
1: 		}
1: 		catch (StandardException se)
1: 		{
1:             throw StandardException.newException(
1:                     SQLState.LOG_REDO_FAILED, se, op);
1: 		}
1: 		finally
1: 		{
1: 			// close all the io streams
1: 			redoScan.close();
1: 			redoScan = null;
1: 
1: 			if (undoScan != null)
1: 			{
1: 				undoScan.close();
1: 				undoScan = null;
1: 			}
1: 
1: 			if (op != null)
1: 				op.releaseResource(recoveryTransaction);
1: 
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
1:             {
1:                 SanityManager.DEBUG(
1:                     LogToFile.DBG_FLAG, 
1:                     "----------------------------------------------------\n" +
1:                     "End of recovery redo\n" + 
1:                     "Scanned = " + scanCount + " log records" +
1:                     ", redid = " + redoCount +
1:                     " ( clr = " + clrCount + " )" +
1:                     " begintran = " + btranCount +
1:                     " endtran = " + etranCount + 
1:                     " preparetran = " + prepareCount + 
1:                     "\n log ends at " + LogCounter.toDebugString(logEnd) +
1:                     "\n----------------------------------------------------\n");
1:             }
1:         }
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			// make sure logEnd and instant is consistent
1: 			if (instant != LogCounter.INVALID_LOG_INSTANT)	
1:             {
1: 				SanityManager.ASSERT(
0:                     LogCounter.getLogFileNumber(instant) ==
1:                          LogCounter.getLogFileNumber(logEnd) &&
1:                      LogCounter.getLogFilePosition(instant) <=
0:                          LogCounter.getLogFilePosition(logEnd));
1:             }
1: 			else
1:             {
1: 				SanityManager.ASSERT(logEnd == LogCounter.INVALID_LOG_INSTANT);
1:             }
1: 		}
1: 
1:         // logEnd is the last good log record position in the log
1: 		return logEnd;			
1: 	}
1: 
1: 
1: 	/**
1: 		Read the next log record from the scan.
1: 
1: 		<P>MT - caller must provide synchronization (right now, it is only
1: 		called in recovery to find the checkpoint log record.  When this method
1: 		is called by a more general audience, MT must be revisited).
1: 
1: 		@param scan an opened log scan
1: 		@param size estimated size of the log record
1: 
1: 		@return the log operation that is the next in the scan, or null if no
1: 		more log operation in the log scan
1: 
1: 		@exception IOException	Error reading the log file
0: 		@exception StandardException Standard Cloudscape error policy
1: 		@exception ClassNotFoundException log corrupted
1: 	 */
1: 	protected Loggable readLogRecord(StreamLogScan scan, int size)
1: 		 throws IOException, StandardException, ClassNotFoundException
1: 	{
1: 		Loggable lop = null;
1: 
1: 		ArrayInputStream logInputBuffer = new ArrayInputStream(new byte[size]);
1: 
1: 		LogRecord record = scan.getNextRecord(logInputBuffer, null, 0);
1: 		if (record != null)
1: 			lop = record.getLoggable();
1: 		return lop;
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.log;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: 
0: import org.apache.derby.impl.store.raw.log.LogCounter;
0: import org.apache.derby.impl.store.raw.log.LogRecord;
0: import org.apache.derby.impl.store.raw.log.StreamLogScan;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.log.Logger;
0: import org.apache.derby.iapi.store.raw.log.LogScan;
0: 
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: 
0: import org.apache.derby.iapi.store.raw.Compensation;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Loggable;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RePreparable;
0: import org.apache.derby.iapi.store.raw.Undoable;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdOutputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.ArrayOutputStream;
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
0: 
0: import org.apache.derby.iapi.services.io.LimitObjectInput;
0: import java.io.IOException;
0: 
0: import org.apache.derby.impl.store.raw.data.InitPageOperation;
0: 
0: /**
0: 	Write log records to a log file as a stream
0: 	(ie. log records added to the end of the file, no concept of pages).
0: <P>
0: 	The format of a log record that is not a compensation operation is
0: 	<PRE>
0: 	@format_id	no formatId, format is implied by the log file format and the
0: 		log record content.
0: 	@purpose	the log record and optional data
0: 	@upgrade
0: 	@disk_layout
0: 		Log Record
0: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
0: 		length(int)	length of optional data
0: 		optionalData(byte[length]) optional data written by the log record
0: 	@end_format
0: 	</PRE> <HR WIDTH="100%"> 
0: 
0: 	<P>	The form of a log record that is a compensation operation is
0: 	<PRE>
0: 	@format_id	no formatId, format is implied by the log file format and the
0: 	log record content.
0: 	@purpose	undo a previous log record
0: 	@upgrade
0: 	@disk_layout
0: 		Log Record that contains the compenstation operation
0: 			(see org.apache.derby.impl.store.raw.log.LogRecord)
0: 		undoInstant(long) the log instant of the operation that is to be rolled back
0: 			The undo instant is logically part of the LogRecord but is written
0: 			by the logger because it is used and controlled by the rollback
0: 			code but not by the log operation.
0: 		There is no optional data in a compensation operation, all data
0: 		necessary for the rollback must be stored in the operation being
0: 		undone.
0: 	@end_format
0: 	</PRE>
0: 
0:     <BR>
0: 
0: 	<P>Multithreading considerations:<BR>
0: 	Logger must be MT-safe.	Each RawTransaction has its own private
0: 	FileLogger object. Each logger has a logOutputBuffer and a log input
0: 	buffer which are used to read and write to the log.  Since multiple
0: 	threads can be in the same transaction, fileLogger must be synchronized.
0: 
0: 	@see LogRecord
0: */
0: 
0: public class FileLogger implements Logger {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private LogRecord		 logRecord;
0: 
0: 	protected byte[] encryptionBuffer;
0: 	private DynamicByteArrayOutputStream logOutputBuffer;
0: 	private FormatIdOutputStream logicalOut;
0: 
0: 	private ArrayInputStream logIn;
0: 
0: 	private LogToFile logFactory;	// actually writes the log records.
0: 
0: 	/**
0: 		Make a new Logger with its own log record buffers
0: 		MT - not needed for constructor
0: 	*/
0: 	public FileLogger(LogToFile logFactory) {
0: 
0: 		this.logFactory = logFactory;
0: 		logOutputBuffer = new DynamicByteArrayOutputStream(1024); // init size 1K
0: 		logicalOut = new FormatIdOutputStream(logOutputBuffer);
0: 
0: 		// logIn and logOutputBuffer must share the same buffer because they
0: 		// combined to form an IO stream to access the same log record.
0: 		// 
0: 		// Before each use of logIn, you must reset logIn's data to the
0: 		// byte array you want to read from.
0: 		//
0: 		// To log a record, set logIn's data to point to logOutputBuffer's
0: 		// byte array when you know you have everything you need in the output
0: 		// buffer, then set limit on logIn and send it to the log operation's
0: 		// doMe.
0: 		//
0: 		// Keep in mind the dynamic nature of the logOutputBuffer which means
0: 		// it could switch buffer from underneath the logOutputBuffer on every
0: 		// write.
0: 		logIn = new ArrayInputStream();
0:  
0: 		logRecord = new LogRecord();
0: 
0: 	}
0: 
0: 	/**
0: 		Close the logger.
0: 		MT - caller provide synchronization
0: 		(RESOLVE: not called by anyone ??)
0: 	*/
0: 	public void close() throws IOException
0: 	{
0: 		if (logOutputBuffer != null)
0: 		{
0: 			logOutputBuffer.close();
0: 			logOutputBuffer = null;
0: 		}
0: 
0: 		logIn = null;
0: 		logFactory = null;
0: 
0: 		logicalOut = null;
0: 
0: 		logRecord = null;
0: 	}
0: 
0: 	/*
0: 	** Methods of Logger
0: 	*/
0: 
0: 	/**
0: 		Writes out a log record to the log stream, and call its doMe method to
0: 		apply the change to the rawStore.
0: 		<BR>Any optional data the doMe method need is first written to the log
0: 		stream using operation.writeOptionalData, then whatever is written to
0: 		the log stream is passed back to the operation for the doMe method.
0: 
0: 		<P>MT - there could be multiple threads running in the same raw
0: 		transactions and they can be calling the same logger to log different
0: 		log operations.  This whole method is synchronized to make sure log
0: 		records are logged one at a time.
0: 
0: 		@param xact the transaction logging the change
0: 		@param operation the log operation
0: 		@return the instant in the log that can be used to identify the log
0: 		record
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	*/
0: 	public synchronized LogInstant logAndDo(RawTransaction xact, Loggable operation) 
0: 		 throws StandardException 
0: 	{
0: 		boolean isLogPrepared = false;
0: 
0: 		boolean inUserCode = false;
0: 		byte[] preparedLog;
0: 
0: 		try {
0: 
0: 			logOutputBuffer.reset();
0: 
0: 			// always use the short Id, only the BeginXact log record contains
0: 			// the XactId (long form)
0: 			TransactionId transactionId = xact.getId();
0: 
0: 			// write out the log header with the operation embedded
0: 			// this is by definition not a compensation log record,
0: 			// those are called thru the logAndUndo interface
0: 			logRecord.setValue(transactionId, operation);
0: 
0: 			inUserCode = true;
0: 			logicalOut.writeObject(logRecord);
0: 			inUserCode = false;
0: 
0: 			int optionalDataLength = 0;
0: 			int optionalDataOffset = 0;
0: 			int completeLength = 0;
0: 
0: 			ByteArray preparedLogArray = operation.getPreparedLog();
0: 			if (preparedLogArray != null) {
0: 
0: 				preparedLog = preparedLogArray.getArray();
0: 				optionalDataLength = preparedLogArray.getLength();
0: 				optionalDataOffset = preparedLogArray.getOffset();
0: 
0: 				// There is a race condition if the operation is a begin tran in
0: 				// that between the time the beginXact log record is written to
0: 				// disk and the time the transaction object is updated in the
0: 				// beginXact.doMe method, other log records may be written.
0: 				// This will render the transaction table in an inconsistent state
0: 				// since it may think a later transaction is the earliest
0: 				// transaction or it may think that there is no active transactions
0: 				// where there is a bunch of them sitting on the log.
0: 				//
0: 				// Similarly, there is a race condition for endXact, i.e.,
0: 				// 1) endXact is written to the log, 
0: 				// 2) checkpoint gets that (committed) transaction as the
0: 				//		firstUpdateTransaction
0: 				// 3) the transaction calls postComplete, nulling out itself
0: 				// 4) checkpoint tries to access a closed transaction object
0: 				//
0: 				// The solution is to sync between the time a begin tran or end
0: 				// tran log record is sent to the log stream and its doMe method is
0: 				// called to update the transaction table and in memory state
0: 				//
0: 				// We only need to serialized the begin and end Xact log records
0: 				// because once a transaction has been started and in the
0: 				// transaction table, its order and transaction state does not
0: 				// change.
0: 				//
0: 				// Use the logFactory as the sync object so that a checkpoint can
0: 				// take its snap shot of the undoLWM before or after a transaction
0: 				// is started, but not in the middle. (see LogToFile.checkpoint)
0: 				//
0: 
0: 				// now set the input limit to be the optional data.  
0: 				// This limits amount of data availiable to logIn that doMe can
0: 				// use
0: 				logIn.setData(preparedLog);
0: 				logIn.setPosition(optionalDataOffset);
0: 				logIn.setLimit(optionalDataLength);
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if ((optionalDataLength) != logIn.available())
0: 						SanityManager.THROWASSERT(
0: 							" stream not set correctly " +
0: 							optionalDataLength + " != " +
0: 							 logIn.available());
0: 				}
0: 
0: 			} else {
0: 				preparedLog = null;
0: 				optionalDataLength = 0;
0: 			}
0: 
0: 			logicalOut.writeInt(optionalDataLength);
0: 			completeLength = logOutputBuffer.getPosition() + optionalDataLength;
0: 
0: 
0: 			LogInstant logInstant = null;
0: 			int encryptedLength = 0; // in case of encryption, we need to pad
0: 
0: 			try
0: 			{
0: 				if (logFactory.databaseEncrypted())
0: 				{
0: 					// we must pad the encryption data to be multiple of block
0: 					// size, which is logFactory.getEncryptionBlockSize()
0: 					encryptedLength = completeLength;
0: 					if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
0: 						encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
0: 
0: 					if (encryptionBuffer == null || 
0: 						encryptionBuffer.length < encryptedLength)
0: 						encryptionBuffer = new byte[encryptedLength];
0: 
0: 					System.arraycopy(logOutputBuffer.getByteArray(), 0, 
0: 									 encryptionBuffer, 0, completeLength-optionalDataLength);
0: 
0: 					if (optionalDataLength > 0)
0: 						System.arraycopy(preparedLog, optionalDataOffset, 
0: 									 encryptionBuffer,
0: 									 completeLength-optionalDataLength, optionalDataLength);
0: 
0: 					// do not bother to clear out the padding area 
0: 					int len = 
0: 						logFactory.encrypt(encryptionBuffer, 0, encryptedLength, 
0: 										   encryptionBuffer, 0);
0: 
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(len == encryptedLength, 
0: 							"encrypted log buffer length != log buffer len");
0: 				}
0: 
0: 				if ((operation.group() & (Loggable.FIRST | Loggable.LAST)) != 0)
0: 				{
0: 					synchronized (logFactory)
0: 					{
0: 						long instant = 0;
0: 
0: 						if (logFactory.databaseEncrypted())
0: 						{
0: 							// encryption has completely drained both the the
0: 							// logOuputBuffer array and the preparedLog array
0: 							instant = logFactory.
0: 								appendLogRecord(encryptionBuffer, 0, 
0: 												encryptedLength, null, 
0: 												-1, 0);
0: 						}
0: 						else
0: 						{
0: 							instant = logFactory.
0: 								appendLogRecord(logOutputBuffer.getByteArray(),
0: 												0, completeLength, preparedLog,
0: 												optionalDataOffset,
0: 												optionalDataLength);
0: 						}
0: 						logInstant = new LogCounter(instant);
0: 
0: 						operation.doMe(xact, logInstant, logIn);
0: 					}
0: 				}
0: 				else
0: 				{
0: 					long instant = 0;
0: 
0: 					if (logFactory.databaseEncrypted())
0: 					{
0: 						// encryption has completely drained both the the
0: 						// logOuputBuffer array and the preparedLog array
0: 						instant = logFactory.
0: 							appendLogRecord(encryptionBuffer, 0, 
0: 											encryptedLength, null, -1, 0);
0: 					}
0: 					else
0: 					{
0: 						instant = logFactory.
0: 							appendLogRecord(logOutputBuffer.getByteArray(), 0,
0: 											completeLength, preparedLog,
0: 											optionalDataOffset,
0: 											optionalDataLength); 
0: 					}
0: 
0: 					logInstant = new LogCounter(instant);
0: 
0: 					operation.doMe(xact, logInstant, logIn);
0: 				}
0: 
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_DO_ME_FAIL, se, operation));
0: 			}
0: 			catch (IOException ioe)
0: 			{
0: 				throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_DO_ME_FAIL, ioe, operation));
0: 			}
0: 			finally
0: 			{
0: 				logIn.clearLimit();
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                 {
0:                     SanityManager.DEBUG(
0:                         LogToFile.DBG_FLAG, 
0:                         "Write log record: tranId=" + transactionId.toString() +
0:                         " instant: " + logInstant.toString() + " length: " +
0:                         completeLength + "\n" + operation + "\n");
0:                 }
0: 			}
0: 			return logInstant;
0: 		}
0: 
0: 		catch (IOException ioe) 
0: 		{
0: 			// error writing to the log buffer
0: 			if (inUserCode)
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, operation);
0:             }
0: 			else
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.LOG_BUFFER_FULL, ioe, operation);
0:             }
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 		Writes out a compensation log record to the log stream, and call its
0: 		doMe method to undo the change of a previous log operation.
0: 
0: 		<P>MT - Not needed. A transaction must be single threaded thru undo, each
0: 		RawTransaction has its own logger, therefore no need to synchronize.
0: 		The RawTransaction must handle synchronizing with multiple threads
0: 		during rollback.
0: 
0: 		@param xact the transaction logging the change
0: 		@param compensation the compensation log operation
0: 		@param undoInstant the log instant of the operation that is to be
0: 		rolled back
0: 		@param in optional data input for the compenastion doMe method
0: 		@param dataLength optional data length
0: 
0: 		@return the instant in the log that can be used to identify the log
0: 		record
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	 */
0: 	public LogInstant logAndUndo(RawTransaction xact, 
0: 								 Compensation compensation,
0: 								 LogInstant undoInstant,
0: 								 LimitObjectInput in)
0: 		 throws StandardException
0: 	{
0: 		boolean inUserCode = false;
0: 
0: 		try {
0: 			logOutputBuffer.reset();
0: 
0: 			TransactionId transactionId = xact.getId();
0: 
0: 			// write out the log header with the operation embedded
0: 			logRecord.setValue(transactionId, compensation);
0: 
0: 			inUserCode = true;
0: 			logicalOut.writeObject(logRecord);
0: 			inUserCode = false;
0: 
0: 			// write out the undoInstant
0: 			logicalOut.writeLong(((LogCounter)undoInstant).getValueAsLong());
0: 
0: 			// in this implemetaion, there is no optional data for the
0: 			// compensation operation.  Optional data for the rollback comes
0: 			// from the undoable operation - and is passed into this call.
0: 			int completeLength = logOutputBuffer.getPosition();
0: 			long instant = 0;
0: 			
0: 			if (logFactory.databaseEncrypted())
0: 			{
0: 				// we must pad the encryption data to be multiple of block
0: 				// size, which is logFactory.getEncryptionBlockSize()
0: 				int encryptedLength = completeLength;
0: 				if ((encryptedLength % logFactory.getEncryptionBlockSize()) != 0)
0: 					encryptedLength = encryptedLength + logFactory.getEncryptionBlockSize() - (encryptedLength % logFactory.getEncryptionBlockSize());
0: 
0: 				if (encryptionBuffer == null || 
0: 					encryptionBuffer.length < encryptedLength)
0: 					encryptionBuffer = new byte[encryptedLength];
0: 
0: 				System.arraycopy(logOutputBuffer.getByteArray(), 0, 
0: 								 encryptionBuffer, 0, completeLength);
0: 
0: 				// do not bother to clear out the padding area 
0: 				int len = 
0: 					logFactory.encrypt(encryptionBuffer, 0, encryptedLength,
0: 									   encryptionBuffer, 0);
0: 
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(len == encryptedLength, 
0: 						"encrypted log buffer length != log buffer len");
0: 
0: 				instant = logFactory.
0: 					appendLogRecord(encryptionBuffer,
0: 									0, encryptedLength, null, 0, 0);
0: 			}
0: 			else
0: 			{
0: 				instant = logFactory.
0: 					appendLogRecord(logOutputBuffer.getByteArray(), 
0: 									0, completeLength, null, 0, 0);
0: 			}
0: 
0: 			LogInstant logInstant = new LogCounter(instant);
0: 
0: 			if (SanityManager.DEBUG)
0:             {
0:                 if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                 {
0:                     SanityManager.DEBUG(
0:                         LogToFile.DBG_FLAG, 
0:                         "Write CLR: Xact: " + transactionId.toString() +
0:                         "clrinstant: " + logInstant.toString() + 
0:                         " undoinstant " + undoInstant + "\n");
0:                 }
0: 			}
0: 
0: 			try
0: 			{
0: 				// in and dataLength contains optional data that was written 
0: 				// to the log during a previous call to logAndDo.
0: 				compensation.doMe(xact, logInstant, in);
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_DO_ME_FAIL, se, compensation));
0: 			}
0: 			catch (IOException ioe)
0: 			{
0: 				throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_DO_ME_FAIL, ioe, compensation));
0: 			}
0: 
0: 			return logInstant;
0: 
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			if (inUserCode)
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.LOG_WRITE_LOG_RECORD, ioe, compensation);
0:             }
0: 			else
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.LOG_BUFFER_FULL, ioe, compensation);
0:             }
0: 		}
0: 	}
0: 
0: 	/**
0: 		Flush the log up to the given log instant.
0: 
0: 		<P>MT - not needed, wrapper method
0: 
0: 		@exception StandardException cannot sync log file
0: 	*/
0: 	public void flush(LogInstant where) 
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, "Flush log to " + where.toString());
0:             }
0: 		}
0: 
0: 		logFactory.flush(where);
0: 	}
0: 
0: 	/**
0: 		Flush all outstanding log to disk.
0: 
0: 		<P>MT - not needed, wrapper method
0: 
0: 		@exception StandardException cannot sync log file
0: 	*/
0: 	public void flushAll () throws StandardException
0: 	{
0: 		logFactory.flushAll();
0: 	}
0: 
0:     /**
0:      * During recovery re-prepare a transaction.
0:      * <p>
0:      * After redo() and undo(), this routine is called on all outstanding 
0:      * in-doubt (prepared) transactions.  This routine re-acquires all 
0:      * logical write locks for operations in the xact, and then modifies
0:      * the transaction table entry to make the transaction look as if it
0:      * had just been prepared following startup after recovery.
0:      * <p>
0:      *
0:      * @param t                 is the transaction performing the re-prepare
0:      * @param prepareId         is the transaction ID to be re-prepared
0:      * @param prepareStopAt     is where the log instant (inclusive) where the 
0:      *                          re-prepare should stop.
0:      * @param prepareStartAt    is the log instant (inclusive) where re-prepare 
0:      *                          should begin, this is normally the log instant 
0:      *                          of the last log record of the transaction that 
0:      *                          is to be re-prepare.  If null, then re-prepare 
0:      *                          starts from the end of the log.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void reprepare(
0:     RawTransaction  t,
0:     TransactionId   prepareId,
0:     LogInstant      prepareStopAt,
0:     LogInstant      prepareStartAt) 
0:         throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 if (prepareStartAt != null)
0:                 {
0:                     SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                     "----------------------------------------------------\n" +
0:                     "\nBegin of RePrepare : " + prepareId.toString() + 
0:                         "start at " + prepareStartAt.toString() + 
0:                         " stop at " + prepareStopAt.toString()  +
0:                     "\n----------------------------------------------------\n");
0:                 }
0:                 else
0:                 {
0:                     SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                     "----------------------------------------------------\n" +
0:                     "\nBegin of Reprepare: " + prepareId.toString() + 
0:                         "start at end of log stop at " + 
0:                         prepareStopAt.toString() +
0:                     "\n----------------------------------------------------\n");
0:                 }
0:             }
0: 		}
0: 
0: 		// statistics
0: 		int clrskipped      = 0;
0: 		int logrecordseen   = 0;
0: 
0: 		RePreparable lop          = null;
0: 
0: 		// stream to read the log record - initial size 4096, scanLog needs
0: 		// to resize if the log record is larger than that.
0: 		ArrayInputStream    rawInput    = null;
0: 
0: 		try
0: 		{
0:             StreamLogScan scanLog;
0: 
0: 			if (prepareStartAt == null)
0:             {
0:                 // don't know where to start, scan from end of log
0: 				scanLog = 
0:                     (StreamLogScan) logFactory.openBackwardsScan(prepareStopAt);
0:             }
0: 			else
0: 			{
0: 				if (prepareStartAt.lessThan(prepareStopAt)) 
0:                 {
0:                     // nothing to prepare!
0: 					return;
0:                 }
0: 
0: 				scanLog = (StreamLogScan)
0: 					logFactory.openBackwardsScan(
0:                         ((LogCounter) prepareStartAt).getValueAsLong(),
0:                         prepareStopAt);
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(
0:                     scanLog != null, "cannot open log for prepare");
0: 
0: 			rawInput    = new ArrayInputStream(new byte[4096]);
0: 
0: 			LogRecord record;
0: 
0: 			while ((record = 
0:                     scanLog.getNextRecord(rawInput, prepareId, 0)) 
0:                        != null) 
0: 			{ 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(
0:                         record.getTransactionId().equals(prepareId),
0: 					    "getNextRecord return unqualified log rec for prepare");
0: 				}
0: 
0: 				logrecordseen++;
0: 
0: 				if (record.isCLR())
0: 				{
0: 					clrskipped++;
0: 
0:                     // the loggable is still in the input stream, get rid of it
0: 					record.skipLoggable(); 
0: 
0: 					// read the prepareInstant
0: 					long prepareInstant = rawInput.readLong();
0: 
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                     "Skipping over CLRs, reset scan to " + 
0:                                     LogCounter.toDebugString(prepareInstant));
0:                         }
0: 					}
0: 
0: 					scanLog.resetPosition(new LogCounter(prepareInstant));
0: 					// scanLog now positioned at the beginning of the log
0: 					// record that was rolled back by this CLR.
0: 					// The scan is a backward one so getNextRecord will skip
0: 					// over the record that was rolled back and go to the one
0: 					// previous to it
0: 
0: 					continue;
0: 				}
0: 
0:                 if (record.requiresPrepareLocks())
0:                 {
0:                     lop = record.getRePreparable();
0:                 }
0:                 else
0:                 {
0:                     continue;
0:                 }
0: 
0: 				if (lop != null)
0: 				{
0:                     // Reget locks based on log record.  reclaim all locks with
0:                     // a serializable locking policy, since we are only 
0:                     // reclaiming write locks, isolation level does not matter
0:                     // much.
0: 
0:                     lop.reclaimPrepareLocks(
0:                         t,
0:                         t.newLockingPolicy(
0:                             LockingPolicy.MODE_RECORD, 
0:                             TransactionController.ISOLATION_REPEATABLE_READ, 
0:                             true));
0: 
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "Reprepare log record at instant " +
0:                                 scanLog.getInstant() + " : " + lop);
0:                         }
0:                     }
0: 
0: 				}
0: 			}
0: 
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
0: 		}
0: 	    catch (IOException ioe) 
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			throw 
0:                 logFactory.markCorrupt(
0:                     StandardException.newException(
0:                         SQLState.LOG_UNDO_FAILED, se,  
0:                         prepareId, lop, (Object) null));
0: 		}
0: 		finally
0: 		{
0: 			if (rawInput != null)
0: 			{
0: 				try
0: 				{
0: 					rawInput.close();
0: 				}
0: 				catch (IOException ioe)
0: 				{
0: 					throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, prepareId));
0: 				}
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(LogToFile.DBG_FLAG, "Finish prepare" +
0:                                     ", clr skipped = " + clrskipped + 
0:                                     ", record seen = " + logrecordseen + "\n");
0:             }
0:         }
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                     "----------------------------------------------------\n" +
0:                     "End of recovery rePrepare\n" + 
0:                     ", clr skipped = " + clrskipped + 
0:                     ", record seen = " + logrecordseen + 
0:                     "\n----------------------------------------------------\n");
0:             }
0:         }
0: 	}
0: 
0: 
0: 	/**
0: 		Undo a part of or the entire transaction.  Begin rolling back the log
0: 		record at undoStartAt and stopping at (inclusive) the log record at
0: 		undoStopAt.
0: 
0: 		<P>MT - Not needed. A transaction must be single threaded thru undo, 
0:         each RawTransaction has its own logger, therefore no need to 
0:         synchronize.  The RawTransaction must handle synchronizing with 
0:         multiple threads during rollback.
0: 
0: 		@param t 			the transaction that needs to be rolled back
0: 		@param undoId 		the transaction ID
0: 		@param undoStopAt	the last log record that should be rolled back
0: 		@param undoStartAt	the first log record that should be rolled back
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 
0: 		@see Logger#undo
0: 	  */
0: 	public void undo(
0:     RawTransaction  t, 
0:     TransactionId   undoId, 
0:     LogInstant      undoStopAt, 
0:     LogInstant      undoStartAt)
0: 		throws StandardException 
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 if (undoStartAt != null)
0:                 {
0:                     SanityManager.DEBUG(
0:                         LogToFile.DBG_FLAG, 
0:                         "\nUndo transaction: " + undoId.toString() + 
0:                         "start at " + undoStartAt.toString() + 
0:                         " stop at " + undoStopAt.toString() );
0:                 }
0:                 else
0:                 {
0:                     SanityManager.DEBUG(
0:                         LogToFile.DBG_FLAG, 
0:                         "\nUndo transaction: " + undoId.toString() + 
0:                         "start at end of log stop at " + undoStopAt.toString());
0:                 }
0:             }
0:         }
0: 
0: 		// statistics
0: 		int clrgenerated  = 0;
0: 		int clrskipped    = 0;
0: 		int logrecordseen = 0;
0: 
0: 		StreamLogScan scanLog;
0: 		Compensation  compensation = null;
0: 		Undoable      lop          = null;
0: 
0: 		// stream to read the log record - initial size 4096, scanLog needs
0: 		// to resize if the log record is larget than that.
0: 		ArrayInputStream    rawInput   = null;
0: 
0: 		try
0: 		{
0: 			if (undoStartAt == null)	
0:             {
0:                 // don't know where to start, rollback from end of log
0: 
0: 				scanLog = (StreamLogScan)
0: 					logFactory.openBackwardsScan(undoStopAt);
0:             }
0: 			else
0: 			{
0: 				if (undoStartAt.lessThan(undoStopAt))
0:                 {
0:                     // nothing to undo!
0: 					return;
0:                 }
0: 
0: 				long undoStartInstant = 
0:                     ((LogCounter) undoStartAt).getValueAsLong();
0: 
0: 				scanLog = (StreamLogScan)
0: 					logFactory.openBackwardsScan(undoStartInstant, undoStopAt);
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(
0:                     scanLog != null, "cannot open log for undo");
0: 
0: 			rawInput   = new ArrayInputStream(new byte[4096]);
0: 
0: 			LogRecord record;
0: 
0: 			while ((record = 
0:                     scanLog.getNextRecord(rawInput, undoId, 0)) 
0:                         != null) 
0: 			{ 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(
0:                         record.getTransactionId().equals(undoId),
0:                         "getNextRecord return unqualified log record for undo");
0: 				}
0: 
0: 				logrecordseen++;
0: 
0: 				if (record.isCLR())
0: 				{
0: 					clrskipped++;
0: 
0:                     // the loggable is still in the input stream, get rid of it
0: 					record.skipLoggable(); 
0: 
0: 					// read the undoInstant
0: 					long undoInstant = rawInput.readLong();
0: 
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "Skipping over CLRs, reset scan to " + 
0:                                 LogCounter.toDebugString(undoInstant));
0:                         }
0:                     }
0: 
0: 
0: 					scanLog.resetPosition(new LogCounter(undoInstant));
0: 
0: 					// scanLog now positioned at the beginning of the log
0: 					// record that was rolled back by this CLR.
0: 					// The scan is a backward one so getNextRecord will skip
0: 					// over the record that was rolled back and go to the one
0: 					// previous to it
0: 
0: 					continue;
0: 				}
0: 
0: 				lop = record.getUndoable();
0: 
0: 				if (lop != null)
0: 				{
0: 					int optionalDataLength = rawInput.readInt();
0: 					int savePosition = rawInput.getPosition();
0: 					rawInput.setLimit(savePosition, optionalDataLength);
0: 	
0: 					compensation = lop.generateUndo(t, rawInput);
0: 
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "Rollback log record at instant " +
0:                                 LogCounter.toDebugString(scanLog.getInstant()) +
0:                                 " : " + lop);
0:                         }
0:                     }
0: 
0: 					clrgenerated++;
0: 
0: 					if (compensation != null)
0: 					{
0: 						// generateUndo may have read stuff off the
0: 						// stream, reset it for the undo operation.
0: 						rawInput.setLimit(savePosition, optionalDataLength);
0: 
0: 						// log the compensation op that rolls back the 
0:                         // operation at this instant 
0: 						t.logAndUndo(
0:                             compensation, new LogCounter(scanLog.getInstant()),
0:                             rawInput);
0: 
0: 						compensation.releaseResource(t);
0: 						compensation = null;
0: 					}
0: 
0: 					// if compensation is null, log operation is redo only
0: 				}
0: 				// if this is not an undoable operation, continue with next log
0: 				// record
0: 			}
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
0: 		}
0: 	    catch (IOException ioe) 
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.LOG_READ_LOG_FOR_UNDO, ioe));
0: 		}
0: 		catch (StandardException se)
0: 		{
0:             // TODO (4327) - exceptions caught here are nested in the exception
0:             // below but for some reason the nested exceptions are not logged 
0:             // or reported in any way.
0: 
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.LOG_UNDO_FAILED, se, undoId, lop, compensation));
0: 		}
0: 		finally
0: 		{
0: 			if (compensation != null) 
0:             {
0:                 // errored out
0: 				compensation.releaseResource(t);
0:             }
0: 
0: 			if (rawInput != null)
0: 			{
0: 				try
0: 				{
0: 					rawInput.close();
0: 				}
0: 				catch (IOException ioe)
0: 				{
0: 					throw logFactory.markCorrupt(
0:                         StandardException.newException(
0:                             SQLState.LOG_READ_LOG_FOR_UNDO, ioe, undoId));
0: 				}
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                         "Finish undo" +
0:                         ", clr generated = " + clrgenerated +
0:                         ", clr skipped = " + clrskipped + 
0:                         ", record seen = " + logrecordseen + "\n");
0:             }
0:         }
0: 	}
0: 
0: 
0: 	/**
0: 		Recovery Redo loop.
0: 
0: 		<P> The log stream is scanned from the beginning (or
0: 		from the undo low water mark of a checkpoint) forward until the end.
0: 		The purpose of the redo pass is to repeat history, i.e, to repeat
0: 		exactly the same set of changes the rawStore went thru right before it
0: 		stopped.   With each log record that is encountered in the redo pass:
0: 		<OL>
0: 		<LI>if it isFirst(), then the transaction factory is called upon to
0: 		    create a new transaction object.
0: 		<LI>if it needsRedo(), its doMe() is called (if it is a compensation
0: 		    operation, then the undoable operation needs to be created first
0:             before the doMe is called).
0: 		<LI>if it isComplete(), then the transaction object is closed.
0: 		</OL>
0: 
0: 		<P> MT - caller provides synchronization
0: 
0: 		@param logData          - a scratch area to put the log record in
0: 		@param rawStoreFactory  - the raw store factory
0: 		@param transFactory     - the transaction factory
0: 		@param redoStart        - if > 0, a checkpoint was found.
0: 		                          Start the log scan from here to rebuild 
0:                                   transaction table.
0: 		@param redoLWM          - if checkpoint seen, starting from this point
0:                                   on, apply redo if necessary
0: 
0: 		@return the log instant of the next log record (or the instant just
0: 		after the last log record).  This is used to determine where the log
0: 		truly ends
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 		@exception IOException error reading log file
0: 		@exception ClassNotFoundException log file corrupted
0: 
0: 		@see LogToFile#recover
0: 	 */
0: 	protected long redo(
0:     RawTransaction      recoveryTransaction,
0:     TransactionFactory  transFactory,
0:     StreamLogScan       redoScan,
0:     long                redoLWM,
0:     long                ttabInstant)
0: 		 throws IOException, StandardException, ClassNotFoundException
0: 	{
0: 		// begin debug info
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                     "In recovery redo, redoLWM = " + redoLWM);
0:             }
0:         }
0: 
0: 		int scanCount    = 0;
0:         int redoCount    = 0;
0:         int prepareCount = 0; 
0:         int clrCount     = 0;
0:         int btranCount   = 0;
0:         int etranCount   = 0;
0: 
0: 		// end debug info
0: 
0: 		TransactionId tranId = null;
0: 
0:         // the current log instant
0: 		long instant = LogCounter.INVALID_LOG_INSTANT;
0: 
0: 		//////////////////////////////////////////////////////////////////////
0: 		// During redo time, the byte array in the logOutputBuffer is not used.
0: 		// Use it to read the log record - if it is not big enough, scan
0: 		// will resize it.  We could create a brand new log input stream that
0: 		// has nothing to do with logIn or logOutputBuffer but that seem like
0: 		// a waste of memory.
0: 		//////////////////////////////////////////////////////////////////////
0: 		logIn.setData(logOutputBuffer.getByteArray());
0: 
0: 		// use this scan to reconstitute operation to be undone
0: 		// when we see a CLR in the redo scan
0: 		StreamLogScan undoScan  = null;
0: 		Loggable      op        = null;
0: 		long          logEnd    = 0;  // we need to determine the log's true end
0: 
0: 		try 
0:         {
0: 
0: 			// scan the log forward in redo pass and go to the end
0: 			LogRecord record;
0: 			while((record = 
0:                     redoScan.getNextRecord(logIn, null, 0)) 
0:                         != null)
0: 			{
0: 				scanCount++;
0: 				long undoInstant = 0;
0: 
0: 				// last known good instant
0: 				instant = redoScan.getInstant();
0: 
0: 				// last known good log end
0: 				logEnd = redoScan.getLogRecordEnd();
0: 
0: 
0: 				// NOTE NOTE -- be very careful about the undoInstant, it is
0: 				// read off the input stream in this debug section.
0: 				// if we change the log format we will need to change the way
0: 				// the undo instant is gotten.  Also, once it is read off, it
0: 				// should not be read from the stream any more
0: 				// NOTE NOTE
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
0:                         SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0: 
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
0:                             SanityManager.DEBUG_SET(LogToFile.DBG_FLAG);
0: 
0:                         op = record.getLoggable();
0:                         tranId = record.getTransactionId();
0:                         if (record.isCLR())	
0:                         {
0:                             // !!!!!!! this moves the file pointer
0:                             undoInstant = logIn.readLong();
0: 
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "scanned " + tranId + " : " + op + 
0:                                 " instant = " + 
0:                                     LogCounter.toDebugString(instant) + 
0:                                 " undoInstant : " + 
0:                                     LogCounter.toDebugString(undoInstant));
0:                         }
0:                         else
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "scanned " + tranId + " : " + op + 
0:                                 " instant = " + 
0:                                     LogCounter.toDebugString(instant)
0:                                 + " logEnd = " + 
0:                                     LogCounter.toDebugString(logEnd) 
0:                                 + " logIn at " + logIn.getPosition() 
0:                                 + " available " + logIn.available());
0:                         }
0: 
0:                         // we only want to dump the log, don't touch it
0:                         if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
0:                             continue;
0:                     }
0:                 }
0: 
0: 				// if the redo scan is between the undoLWM and redoLWM, we only
0: 				// need to redo begin and end tran.  Everything else has
0: 				// already been flushed by checkpoint
0: 				if (redoLWM != 
0:                         LogCounter.INVALID_LOG_INSTANT && instant < redoLWM)
0: 				{
0: 					if (!(record.isFirst()      || 
0:                           record.isComplete()   || 
0:                           record.isPrepare()))
0:                     {
0: 						continue;
0:                     }
0: 				}
0: 
0: 				// get the transaction
0: 				tranId = record.getTransactionId();
0: 
0: 				// if this transaction is known to the transaction factory, make
0:                 // the recoveryTransaction assume its identitiy and properties
0:                 // otherwise, make it known to the transaction factory
0: 				if (!transFactory.findTransaction(tranId, recoveryTransaction))
0: 				{
0: 					// transaction not found
0: 
0: 					if (redoLWM != LogCounter.INVALID_LOG_INSTANT && 
0: 						instant < redoLWM &&
0:                         (record.isPrepare() || record.isComplete()))
0: 					{
0: 						// What is happening here is that a transaction that
0: 						// started before the undoLWM has commited by the time
0: 						// the checkpoint undoLWM was taken.  Hence, we only
0: 						// see the tail end of its log record and its endXact
0:                         // record. 
0: 						// 
0: 						// NOTE:
0: 						// Since we didn't see its beginXact, we cannot do the
0: 						// endXact's doMe either.  Also if the endXact, is
0:                         // actually just a prepare, we don't need to do
0:                         // anything as the transaction will commit or abort
0:                         // prior to point we are recovering to.
0: 						// If it is deemed necessary to do the endXact's doMe, 
0:                         // then we should start the transaction right here. 
0:                         // For now, just completely ignore this transaction
0: 						// 
0: 						etranCount++;
0: 
0: 						continue;
0: 					}
0: 
0: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
0:                         !record.isFirst())
0:                     {
0: 						throw StandardException.newException(
0:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
0:                             MessageService.getTextMessage(MessageId.LOG_RECORD_NOT_FIRST,tranId));
0: 
0:                     }
0: 
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						// if we dumped the transaction table but see a non 
0:                         // BeginXact record after the transaction table dump 
0:                         // instant, error.
0: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT)
0: 						{
0: 							if (instant > ttabInstant && !record.isFirst())
0:                             {
0: 								SanityManager.THROWASSERT(
0: 								"log record is Not first but transaction " + 
0:                                 "is not in transaction table (2) : " + tranId);
0:                             }
0: 
0: 							// If we dump the transaction table and the table
0: 							// does not have the transaction, and we see this
0: 							// beginXact before the ttab instant, we could have
0: 							// igored it because we "know" that we should see
0: 							// the endXact before the ttab instant also.
0: 							// Leave it in just in case.
0: 						}
0: 					}
0: 					btranCount++;
0: 
0: 					// the long transaction ID is embedded in the beginXact log
0: 					// record.  The short ID is stored in the log record.
0: 					recoveryTransaction.setTransactionId(
0:                         record.getLoggable(), tranId);
0: 
0: 				}
0: 				else				
0: 				{
0:                     // recoveryTransaction found
0:                     
0: 					if ((ttabInstant == LogCounter.INVALID_LOG_INSTANT) && 
0:                          record.isFirst())
0:                     {
0: 						throw StandardException.newException(
0:                             SQLState.LOG_UNEXPECTED_RECOVERY_PROBLEM,
0:                             MessageService.getTextMessage(MessageId.LOG_RECORD_FIRST,
0:                                 tranId));
0: 
0:  
0:                     }
0: 
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (ttabInstant != LogCounter.INVALID_LOG_INSTANT &&
0: 							instant > ttabInstant &&
0: 							record.isFirst())
0:                         {
0: 							SanityManager.THROWASSERT(
0: 								"log record is first but transaction is " + 
0:                                 "already in transaction table (3): " + tranId);
0:                         }
0: 
0:                         if (record.isPrepare())
0:                             prepareCount++;
0: 					}
0: 
0: 					// if we have a transaction table dumped with the
0: 					// checkpoint log record, then during the redo scan we may
0: 					// see the beginXact of a transaction which is already in
0:                     // the transaction table, just ignore it if it is after the
0: 					// redoLWM but before the transaction table instant.  We
0: 					// still need to redo any database changes but since the
0: 					// transaction is already recorded in the transaction
0: 					// table, ignore it.
0: 					//
0: 					if (record.isFirst())
0: 					{
0: 						btranCount++;
0: 						continue;
0: 					}
0: 				}
0: 				
0: 				op = record.getLoggable();
0: 
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (!record.isCLR())
0:                     {
0:                         if (logIn.available() < 4)
0:                         {
0:                             SanityManager.THROWASSERT(
0:                               "not enough bytes read in : " + 
0:                                   logIn.available() + 
0:                               " for " + op + " instant " + 
0:                                   LogCounter.toDebugString(instant));
0:                         }
0:                     }
0:                 }
0: 
0: 				if (SanityManager.DEBUG)
0:                 {
0: 					SanityManager.ASSERT(
0:                         !recoveryTransaction.handlesPostTerminationWork(),
0: 					 	"recovery transaction handles post termination work");
0:                 }
0: 
0: 				if (op.needsRedo(recoveryTransaction))
0: 				{
0: 					redoCount++;
0: 
0: 					if (record.isCLR())	
0: 					{
0: 						clrCount++;
0: 
0: 						// the log operation is not complete, the operation to
0: 						// undo is stashed away at the undoInstant.
0: 						// Reconstitute that first.
0: 
0: 						if (SanityManager.DEBUG)
0: 							SanityManager.ASSERT(op instanceof Compensation);
0: 
0: 
0:                         // this value may be set by sanity xxxx
0: 						if (undoInstant == 0) 
0: 							undoInstant = logIn.readLong();
0: 
0: 						if (undoScan == null)
0: 						{
0: 							undoScan = (StreamLogScan)
0: 								logFactory.openForwardsScan(
0:                                     undoInstant,(LogInstant)null);
0: 						}
0: 						else
0: 						{
0: 							undoScan.resetPosition(new LogCounter(undoInstant));
0: 						}
0: 
0: 						// undoScan now positioned at the beginning of the log
0: 						// record was rolled back by this CLR.  
0: 						// The scan is a forward one so getNextRecord will get 
0:                         // the log record that needs to be rolled back.
0: 
0: 						// reuse the buffer in logIn and logIn since CLR 
0:                         // has no optional data and has no use for them anymore 
0: 						logIn.clearLimit();
0: 						LogRecord undoRecord =
0: 							undoScan.getNextRecord(logIn, null, 0);
0: 
0: 						Undoable undoOp = undoRecord.getUndoable();
0: 
0: 						if (SanityManager.DEBUG)
0: 						{
0: 							SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "Redoing CLR: undoInstant = " + 
0:                                     LogCounter.toDebugString(undoInstant) +
0:                                 " clrinstant = " + 
0:                                     LogCounter.toDebugString(instant));
0: 
0: 							SanityManager.ASSERT(
0:                                 undoRecord.getTransactionId().equals(tranId));
0: 
0: 							SanityManager.ASSERT(undoOp != null);
0: 						}
0: 
0: 						((Compensation)op).setUndoOp(undoOp);
0: 					}
0: 
0: 					// at this point, logIn points to the optional
0: 					// data of the loggable that is to be redone or to be
0: 					// rolled back
0: 					
0: 					if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:                         {
0:                             SanityManager.DEBUG(
0:                                 LogToFile.DBG_FLAG, 
0:                                 "redoing " + op + 
0:                                 " instant = " + 
0:                                 LogCounter.toDebugString(instant));
0:                         }
0:                     }
0: 
0: 					int dataLength = logIn.readInt();
0: 					logIn.setLimit(logIn.getPosition(), dataLength);
0: 										
0: 					// even though the log has already been written, we need to
0: 					// tie the page to the log stream so that if redo failed
0: 					// for some reasons, the log factory's corruption will stop
0: 					// the corrupt page from flushing to disk.
0: 
0: 					op.doMe(
0:                         recoveryTransaction, 
0:                         new LogCounter(instant), logIn);
0: 
0: 					op.releaseResource(recoveryTransaction);
0: 
0: 					op = null;
0: 				}
0: 
0: 				// RESOLVE: to speed up undo, may want to update the 
0: 				// LastLogInstant in the transaction table.  
0: 				// Right now, undo always start from the end of the log.
0: 
0: 				// one last thing, if this is the last log record of the
0: 				// transaction, then commit the transaction and clean up
0: 				//
0: 				// 'commit' even though the transaction maybe a rollback
0: 				// because we already did all the rollback work when redoing
0: 				// the CLRs.  Commit will only flush the log if this session
0: 				// has written any transaction, so in this case, it is a noop.
0: 				if (record.isComplete())
0: 				{
0: 					etranCount++;
0: 
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(
0:                             !recoveryTransaction.handlesPostTerminationWork(),
0:                             "recovery xact handles post termination work");
0: 
0: 					recoveryTransaction.commit();
0: 				}
0: 			}
0: 		}
0: 		catch (StandardException se)
0: 		{
0:             throw StandardException.newException(
0:                     SQLState.LOG_REDO_FAILED, se, op);
0: 		}
0: 		finally
0: 		{
0: 			// close all the io streams
0: 			redoScan.close();
0: 			redoScan = null;
0: 
0: 			if (undoScan != null)
0: 			{
0: 				undoScan.close();
0: 				undoScan = null;
0: 			}
0: 
0: 			if (op != null)
0: 				op.releaseResource(recoveryTransaction);
0: 
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
0:             {
0:                 SanityManager.DEBUG(
0:                     LogToFile.DBG_FLAG, 
0:                     "----------------------------------------------------\n" +
0:                     "End of recovery redo\n" + 
0:                     "Scanned = " + scanCount + " log records" +
0:                     ", redid = " + redoCount +
0:                     " ( clr = " + clrCount + " )" +
0:                     " begintran = " + btranCount +
0:                     " endtran = " + etranCount + 
0:                     " preparetran = " + prepareCount + 
0:                     "\n log ends at " + LogCounter.toDebugString(logEnd) +
0:                     "\n----------------------------------------------------\n");
0:             }
0:         }
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			// make sure logEnd and instant is consistent
0: 			if (instant != LogCounter.INVALID_LOG_INSTANT)	
0:             {
0: 				SanityManager.ASSERT(
0:                     LogCounter.getLogFileNumber(instant) ==
0:                          LogCounter.getLogFileNumber(logEnd) &&
0:                      LogCounter.getLogFilePosition(instant) <=
0:                          LogCounter.getLogFilePosition(logEnd));
0:             }
0: 			else
0:             {
0: 				SanityManager.ASSERT(logEnd == LogCounter.INVALID_LOG_INSTANT);
0:             }
0: 		}
0: 
0:         // logEnd is the last good log record position in the log
0: 		return logEnd;			
0: 	}
0: 
0: 
0: 	/**
0: 		Read the next log record from the scan.
0: 
0: 		<P>MT - caller must provide synchronization (right now, it is only
0: 		called in recovery to find the checkpoint log record.  When this method
0: 		is called by a more general audience, MT must be revisited).
0: 
0: 		@param scan an opened log scan
0: 		@param size estimated size of the log record
0: 
0: 		@return the log operation that is the next in the scan, or null if no
0: 		more log operation in the log scan
0: 
0: 		@exception IOException	Error reading the log file
0: 		@exception StandardException Standard Cloudscape error policy
0: 		@exception ClassNotFoundException log corrupted
0: 	 */
0: 	protected Loggable readLogRecord(StreamLogScan scan, int size)
0: 		 throws IOException, StandardException, ClassNotFoundException
0: 	{
0: 		Loggable lop = null;
0: 
0: 		ArrayInputStream logInputBuffer = new ArrayInputStream(new byte[size]);
0: 
0: 		LogRecord record = scan.getNextRecord(logInputBuffer, null, 0);
0: 		if (record != null)
0: 			lop = record.getLoggable();
0: 		return lop;
0: 	}
0: 
0: }
============================================================================