1:b350a56: /*
1:e65a7e8:  *
1:b350a56:  * Derby - Class BaseJDBCTestCase
1:e65a7e8:  *
1:15651f5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:  * contributor license agreements.  See the NOTICE file distributed with
1:15651f5:  * this work for additional information regarding copyright ownership.
1:15651f5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:  * (the "License"); you may not use this file except in compliance with
1:15651f5:  * the License.  You may obtain a copy of the License at
1:0c4649d:  *
1:b350a56:  *    http://www.apache.org/licenses/LICENSE-2.0
1:01217c2:  *
1:b350a56:  * Unless required by applicable law or agreed to in writing, 
1:b350a56:  * software distributed under the License is distributed on an 
1:b350a56:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:b350a56:  * either express or implied. See the License for the specific 
1:b350a56:  * language governing permissions and limitations under the License.
1:ffe3f66:  */
1:3bd1dd8: package org.apache.derbyTesting.junit;
1:c61e6e8: 
1:95011a0: import java.io.ByteArrayInputStream;
1:e9f346c: import java.io.InputStream;
1:e9f346c: import java.io.IOException;
1:95011a0: import java.io.OutputStream;
1:ffdaf1e: import java.io.BufferedInputStream;
1:ffdaf1e: import java.io.BufferedReader;
1:b4cda60: import java.io.PrintStream;
1:e9f346c: import java.io.Reader;
1:95011a0: import java.io.UnsupportedEncodingException;
1:58588dd: import java.lang.reflect.Method;
1:1ae0d7d: import java.security.AccessController;
1:1ae0d7d: import java.security.PrivilegedAction;
1:aa8a764: import java.security.PrivilegedActionException;
1:aa8a764: import java.net.URL;
1:b350a56: import java.sql.*;
1:442f696: import java.util.ArrayList;
1:7eb8268: import java.util.Arrays;
1:442f696: import java.util.List;
1:392f303: 
1:01217c2: import junit.framework.AssertionFailedError;
1:2510115: import junit.framework.Test;
1:b878080: 
1:1ae0d7d: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:02f8e49: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:02f8e49: import org.apache.derby.impl.jdbc.EmbedConnection;
1:95011a0: import org.apache.derby.tools.ij;
1:148a1f0: import org.apache.derbyTesting.functionTests.util.TestNullOutputStream;
1:01217c2: 
1:01217c2: 
1:c61e6e8: /**
1:b350a56:  * Base class for JDBC JUnit tests.
1:b350a56:  * A method for getting a default connection is provided, along with methods
1:b350a56:  * for telling if a specific JDBC client is used.
1:c61e6e8:  */
1:576a49f: public abstract class BaseJDBCTestCase
1:b350a56:     extends BaseTestCase {
1:2346370: 
1:7eb8268:     private static final boolean ORDERED = true;
1:7eb8268:     private static final boolean UNORDERED = false;
1:7eb8268: 
1:392f303:     /**
1:ffe3f66:      * Maintain a single connection to the default
1:ffe3f66:      * database, opened at the first call to getConnection.
1:ffe3f66:      * Typical setup will just require a single connection.
1:80b6a78:      * @see BaseJDBCTestCase#getConnection()
1:7ebfefe:      */
1:ffe3f66:     private Connection conn;
1:01217c2:     
1:b878080:     /**
1:442f696:      * Maintain a list of statement objects that
1:442f696:      * were returned by utility methods and close
1:442f696:      * them at teardown.
1:442f696:      */
1:2510115:     private List<Statement> statements;
1:c61e6e8: 
1:c61e6e8:     /**
1:c61e6e8:      * Maintain a list of connection objects that
1:c61e6e8:      * were returned by utility methods and close
1:c61e6e8:      * them at teardown.
1:c61e6e8:      */
1:2510115:     private List<Connection> connections;
1:442f696:     
1:442f696:     /**
1:b350a56:      * Create a test case with the given name.
1:3df869c:      *
1:b350a56:      * @param name of the test case.
1:7ebfefe:      */
1:b350a56:     public BaseJDBCTestCase(String name) {
1:b350a56:         super(name);
1:7eb8268:     }
1:00c7a20:     
1:00c7a20:     /**
1:ffe3f66:      * Obtain the connection to the default database.
1:ffe3f66:      * This class maintains a single connection returned
1:ffe3f66:      * by this class, it is opened on the first call to
1:ffe3f66:      * this method. Subsequent calls will return the same
1:ffe3f66:      * connection object unless it has been closed. In that
1:ffe3f66:      * case a new connection object will be returned.
1:ffe3f66:      * <P>
1:ffe3f66:      * The tearDown method will close the connection if
1:ffe3f66:      * it is open.
1:e65a7e8:      * <BR>
1:e65a7e8:      * The connection will be initialized by calling initializeConnection.
1:e65a7e8:      * A sub-class may provide an implementation of initializeConnection
1:e65a7e8:      * to ensure its connections are in a consistent state that is different
1:e65a7e8:      * to the default.
1:df4020d:      * @see #openDefaultConnection()
1:28162f6:      */
1:03a99e2:     public Connection getConnection() throws SQLException
1:b2c1772:     {
1:ffe3f66:         if (conn != null)
1:28162f6:         {
1:ffe3f66:             if (!conn.isClosed())
1:2346370:                 return conn;
1:ffe3f66:             conn = null;
1:e9f346c:         }
1:03a99e2:         return conn = openDefaultConnection();
1:e9f346c:     }
1:28162f6:     
1:b2c1772:     /**
1:fb2bfd5:      * Allow a sub-class to initialize a connection to provide
1:03a99e2:      * consistent connection state for its tests. Called once
1:03a99e2:      * for each time these method calls open a connection:
1:03a99e2:      * <UL>
1:03a99e2:      * <LI> getConnection()
1:03a99e2:      * <LI> openDefaultConnection()
1:03a99e2:      * <LI> openConnection(database)
1:a997e8f:      * <LI> getDefaultConnection(String connAttrs)
1:03a99e2:      * </UL>
1:e65a7e8:      * Default action is to not modify the connection's state from
1:fb2bfd5:      * the initialization provided by the data source.
1:fb2bfd5:      * @param conn Connection to be intialized
1:fb2bfd5:      * @throws SQLException Error setting the initial state.
1:28162f6:      */
1:fb2bfd5:     protected void initializeConnection(Connection conn) throws SQLException
1:c61e6e8:     {
1:28162f6:     }
1:28162f6:     
1:28162f6:     /**
1:7ebfefe:      * Utility method to create a Statement using the connection
1:7ebfefe:      * returned by getConnection.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:7ebfefe:      * @return Statement object from getConnection.createStatement()
1:a997e8f:      * @throws SQLException
1:28162f6:      */
1:7ebfefe:     public Statement createStatement() throws SQLException
1:48154b2:     {
1:442f696:         Statement s = getConnection().createStatement();
1:442f696:         addStatement(s);
1:442f696:         return s;
1:28162f6:     }
1:28162f6:     
1:28162f6:     /**
1:442f696:      * Add a statement into the list we will close
1:442f696:      * at tearDown.
1:28162f6:      */
1:442f696:     private void addStatement(Statement s)
1:24b23a8:     {
1:442f696:         if (statements == null)
1:2510115:             statements = new ArrayList<Statement>();
1:442f696:         statements.add(s);
1:28162f6:     }
1:28162f6:     
1:28162f6:     /**
1:c61e6e8:      * Add connection to the list. We will close at tearDown
1:c61e6e8:      * @param c
1:28162f6:      */
1:c61e6e8:     private void addConnection(Connection c)
1:c61e6e8:     {
1:c61e6e8:         if (connections == null)
1:2510115:             connections = new ArrayList<Connection>();
1:c61e6e8:         connections.add(c);     
1:28162f6:     }
1:28162f6:     
1:28162f6:     /**
1:7840c51:      * Close a statement and remove it from the list of statements to close
1:7840c51:      * at tearDown(). Useful for test cases that create a large number of
1:7840c51:      * statements that are only used for a short time, as the memory footprint
1:7840c51:      * may become big if all the statements are held until tearDown().
1:7840c51:      *
1:7840c51:      * @param s the statement to close and forget
1:7840c51:      * @throws SQLException if closing the statement fails
1:7840c51:      */
1:7840c51:     public void closeStatement(Statement s) throws SQLException {
1:7840c51:         s.close();
1:7840c51:         if (statements != null) {
1:7840c51:             statements.remove(s);
1:7840c51:         }
1:7840c51:     }
1:7840c51: 
1:7840c51:     /**
1:392f303:      * Utility method to create a Statement using the connection
1:392f303:      * returned by getConnection.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:392f303:      * @return Statement object from
2:7ebfefe:      * getConnection.createStatement(resultSetType, resultSetConcurrency)
1:95011a0:      * @throws SQLException
1:28162f6:      */
1:7ebfefe:     public Statement createStatement(int resultSetType,
1:7ebfefe:             int resultSetConcurrency) throws SQLException
1:ddeb000:     {
1:442f696:         Statement s =
1:442f696:             getConnection().createStatement(resultSetType, resultSetConcurrency);
1:442f696:         addStatement(s);
1:442f696:         return s;
1:28162f6:     }
1:28162f6: 
1:28162f6:     /**
1:7ebfefe:      * Utility method to create a Statement using the connection
1:7ebfefe:      * returned by getConnection.
1:7ebfefe:      * @return Statement object from
1:392f303:      * getConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
1:392f303:      * @throws SQLException
1:28162f6:      */
1:392f303:     public Statement createStatement(int resultSetType,
1:392f303:             			int resultSetConcurrency,
1:392f303: 	    			int resultSetHoldability) throws SQLException
1:392f303:     {
1:392f303:         return getConnection().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:28162f6:     }
1:28162f6: 
1:28162f6:     /**
1:7ebfefe:      * Utility method to create a PreparedStatement using the connection
1:7ebfefe:      * returned by getConnection.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:7ebfefe:      * @return Statement object from
1:13e9e78:      * getConnection.prepareStatement(sql)
1:7ebfefe:      * @throws SQLException
1:392f303:      */
1:7ebfefe:     public PreparedStatement prepareStatement(String sql) throws SQLException
1:442f696:     {
1:442f696:         PreparedStatement ps = getConnection().prepareStatement(sql);
1:442f696:         addStatement(ps);
1:442f696:         return ps;
1:28162f6:     }
1:c61e6e8:     
1:28162f6:     /**
1:b878080:      * Utility method to create a PreparedStatement using the connection
1:b878080:      * returned by getConnection with result set type and concurrency.
1:b878080:      * The returned statement object will be closed automatically
1:b878080:      * at tearDown() but may be closed earlier by the test if required.
1:b878080:      * @return Statement object from
1:b878080:      * getConnection.prepareStatement(sql)
1:b878080:      * @throws SQLException
1:b878080:      */
1:b878080:     public PreparedStatement prepareStatement(String sql,
1:b878080:             int resultSetType, int resultSetConcurrency) throws SQLException
1:b878080:     {
1:b878080:         PreparedStatement ps = getConnection().prepareStatement(sql,
1:b878080:                 resultSetType, resultSetConcurrency);
1:b878080:         addStatement(ps);
1:b878080:         return ps;
1:28162f6:     }
1:89c399d:     /**
1:b878080:      * Utility method to create a PreparedStatement using the connection
1:b878080:      * returned by getConnection with result set type and concurrency.
1:b878080:      * The returned statement object will be closed automatically
1:b878080:      * at tearDown() but may be closed earlier by the test if required.
1:b878080:      * @return Statement object from
1:b878080:      * getConnection.prepareStatement(sql)
1:b878080:      * @throws SQLException
1:b878080:      */
1:b878080:     public PreparedStatement prepareStatement(String sql,
1:b878080:             int resultSetType, int resultSetConcurrency,
1:b878080:             int resultSetHoldability) throws SQLException
1:b878080:     {
1:b878080:         PreparedStatement ps = getConnection().prepareStatement(sql,
1:b878080:                 resultSetType, resultSetConcurrency, resultSetHoldability);
1:b878080:         addStatement(ps);
1:b878080:         return ps;
1:c61e6e8:     }
1:fdb0ac3:     /**
1:e3bd4bb:      * Utility method to create a PreparedStatement using the connection
1:c7fdf72:      * returned by getConnection and a flag that signals the driver whether
1:c7fdf72:      * the auto-generated keys produced by this Statement object should be
1:c7fdf72:      * made available for retrieval.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:c7fdf72:      * @return Statement object from
1:c7fdf72:      * prepareStatement(sql, autoGeneratedKeys)
1:7ebfefe:      * @throws SQLException
1:442f696:      */
1:c7fdf72:     public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
1:2346370:         throws SQLException
1:c48e69a:     {
1:442f696:         PreparedStatement ps =
1:442f696:             getConnection().prepareStatement(sql, autoGeneratedKeys);
1:392f303:         
1:442f696:         addStatement(ps);
1:442f696:         return ps;
1:392f303:     }    
1:48154b2: 
1:24b23a8:     /**
1:c7fdf72:      * Utility method to create a PreparedStatement using the connection
1:e3bd4bb:      * returned by getConnection and an array of column indexes that
1:e3bd4bb:      * indicates which auto-generated keys produced by this Statement
1:e3bd4bb:      * object should be made available for retrieval.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:a997e8f:      *
1:e3bd4bb:      * @return Statement object from:
1:e3bd4bb:      *     prepareStatement(sql, columnIndexes)
1:ed0e114:      *
1:7ebfefe:      * @throws SQLException
1:2346370:      */
1:e3bd4bb:     public PreparedStatement prepareStatement(String sql,
1:e3bd4bb:         int [] columnIndexes) throws SQLException
1:2346370:     {
1:442f696:         PreparedStatement ps =
1:442f696:             getConnection().prepareStatement(sql, columnIndexes);
1:442f696:         addStatement(ps);
1:442f696:         return ps;
1:8a319fb:     }
1:fdb0ac3: 
1:b878080:     /**
1:e3bd4bb:      * Utility method to create a PreparedStatement using the connection
1:e3bd4bb:      * returned by getConnection and an array of column names that
1:e3bd4bb:      * indicates which auto-generated keys produced by this Statement
1:e3bd4bb:      * object should be made available for retrieval.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:ed0e114:      *
1:e3bd4bb:      * @return Statement object from:
1:e3bd4bb:      *     prepareStatement(sql, columnNames)
1:28162f6:      *
2:e3bd4bb:      * @throws SQLException
1:0c4649d:      */
1:e3bd4bb:     public PreparedStatement prepareStatement(String sql,
1:e3bd4bb:         String [] columnNames) throws SQLException
1:0c4649d:     {
1:442f696:         PreparedStatement ps =
1:442f696:             getConnection().prepareStatement(sql, columnNames);
1:442f696:         addStatement(ps);
1:442f696:         return ps;
1:b878080:      }
1:442f696: 
1:442f696:     /**
1:13e9e78:      * Utility method to create a CallableStatement using the connection
1:13e9e78:      * returned by getConnection.
1:b878080:      * The returned statement object will be closed automatically
1:b878080:      * at tearDown() but may be closed earlier by the test if required.
1:13e9e78:      * @return Statement object from
1:13e9e78:      * getConnection().prepareCall(sql)
1:13e9e78:      * @throws SQLException
1:13e9e78:      */
1:13e9e78:     public CallableStatement prepareCall(String sql) throws SQLException
1:0c4649d:     {
1:442f696:         CallableStatement cs =
1:442f696:             getConnection().prepareCall(sql);
1:442f696:         addStatement(cs);
1:442f696:         return cs;
1:392f303:  
1:b878080:     }
1:442f696: 
1:392f303:     /**
1:392f303:      * Utility method to create a CallableStatement using the connection
1:392f303:      * returned by getConnection.
1:442f696:      * The returned statement object will be closed automatically
1:442f696:      * at tearDown() but may be closed earlier by the test if required.
1:392f303:      * @return Statement object from
1:392f303:      * getConnection().prepareCall(sql, resultSetType, resultSetConcurrency)
1:392f303:      * @throws SQLException
1:392f303:      */
1:392f303:     public CallableStatement prepareCall(String sql,
1:392f303: 					int resultSetType, 
1:392f303: 					int resultSetConcurrency) throws SQLException
1:392f303:     {
1:b878080:         CallableStatement cs = getConnection().prepareCall(sql, resultSetType,
1:b878080:                 resultSetConcurrency);
1:b878080:         addStatement(cs);
1:b878080:         return cs;
1:392f303:     }
1:392f303: 
1:392f303:     /**
1:392f303:      * Utility method to create a CallableStatement using the connection
1:392f303:      * returned by getConnection.
1:b878080:      * The returned statement object will be closed automatically
1:b878080:      * at tearDown() but may be closed earlier by the test if required.
1:392f303:      * @return Statement object from
1:392f303:      * getConnection().prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
1:392f303:      * @throws SQLException
1:392f303:      */
1:392f303:     public CallableStatement prepareCall(String sql,
1:392f303:                                         int resultSetType,
1:392f303:                                         int resultSetConcurrency,
1:392f303: 					 int resultSetHoldability) throws SQLException
1:392f303:     {
1:b878080:         CallableStatement cs = getConnection().prepareCall(sql,
1:b878080:                 resultSetType, resultSetConcurrency, resultSetHoldability);
1:b878080:         addStatement(cs);
1:b878080:         return cs;
1:392f303:     }
1:442f696:     
1:e65a7e8:     /**
1:c58f84b:      * Utility method to set auto commit behaviour.
1:c58f84b:      * @param commit false if autoCommit should be disabled.
1:c58f84b:      */
1:c58f84b:     public void setAutoCommit(boolean commit) throws SQLException {
1:c58f84b:     	getConnection().setAutoCommit(commit);
1:c58f84b:     }
1:c58f84b:     /**
1:7ebfefe:      * Utility method to commit using the connection
1:7ebfefe:      * returned by getConnection.
1:7ebfefe:      * @throws SQLException
1:7ebfefe:      */
1:7ebfefe:     public void commit() throws SQLException
1:0c4649d:     {
1:03a99e2:         getConnection().commit();
1:b878080:     }  
1:c58f84b:     
1:e65a7e8:     /**
1:7ebfefe:      * Utility method to rollback using the connection
1:7ebfefe:      * returned by getConnection.
1:7ebfefe:      * @throws SQLException
1:7ebfefe:      */
1:7ebfefe:     public void rollback() throws SQLException
2:0c4649d:     {
1:03a99e2:         getConnection().rollback();
1:ddeb000:     } 
1:ade6fcf: 
1:ade6fcf:     /**
1:ade6fcf:      * <p>
1:ade6fcf:      * Run the bare test, including {@code setUp()} and {@code tearDown()}.
1:ade6fcf:      * </p>
1:ade6fcf:      *
1:ade6fcf:      * <p>
1:ade6fcf:      * Subclasses that want to override {@code runBare()}, should override
1:ade6fcf:      * this method instead. Overriding this method shouldn't be necessary
1:ade6fcf:      * except in very special cases. Override {@code setUp()} and
1:ade6fcf:      * {@code tearDown()} instead if possible.
1:ade6fcf:      * </p>
1:ade6fcf:      *
1:ade6fcf:      * <p>
1:ade6fcf:      * The overridden method would typically want to call
1:ade6fcf:      * {@code super.runBareOverridable()} to actually run the test.
1:ade6fcf:      * </p>
1:ade6fcf:      */
1:ade6fcf:     protected void runBareOverridable() throws Throwable {
1:ade6fcf:         super.runBare();
1:ade6fcf:     }
1:ade6fcf: 
1:ade6fcf:     /**
1:ade6fcf:      * <p>
1:ade6fcf:      * Run the bare test, including {@code setUp()} and {@code tearDown()},
1:ade6fcf:      * and finally verify that the cached connection has been released.
1:ade6fcf:      * </p>
1:ade6fcf:      *
1:ade6fcf:      * <p>
1:ade6fcf:      * This method is final to prevent subclasses from accidentally bypassing
1:ade6fcf:      * the assert that checks if the cached connection has been released.
1:ade6fcf:      * Subclasses that want to override the method, should override
1:ade6fcf:      * {@link #runBareOverridable()} instead.
1:ade6fcf:      * </p>
1:ade6fcf:      */
1:ade6fcf:     public final void runBare() throws Throwable {
1:ade6fcf:         runBareOverridable();
1:ade6fcf:         // It's quite common to forget to call super.tearDown() when
1:ade6fcf:         // overriding tearDown() in sub-classes.
1:ade6fcf:         assertNull(
1:ade6fcf:             "Connection should be null by now. " +
1:ade6fcf:             "Missing call to super.tearDown()?", conn);
1:ade6fcf:     }
1:ade6fcf: 
1:2346370:     /**
1:ffe3f66:      * Tear down this fixture, sub-classes should call
1:dbed020:      * super.tearDown(). This cleans up and closes the connection
1:442f696:      * if it is open and any statement objects returned through
1:442f696:      * the utility methods.
1:7ebfefe:      */
1:ffe3f66:     protected void tearDown()
1:ffe3f66:     throws java.lang.Exception
1:442f696:     {
1:442f696:         if (statements != null) {
1:2510115:             for (Statement s : statements) {
1:442f696:                 s.close();
1:ddeb000:             }
1:442f696:             // Allow gc'ing of all those statements.
1:442f696:             statements = null;
1:ddeb000:         }
1:c61e6e8:         if (connections != null) {
1:2510115:             for (Connection c : connections) {
1:c61e6e8:                 JDBC.cleanup(c);
1:c61e6e8:             }
1:c61e6e8:             // Allow gc'ing of all those connections.
1:c61e6e8:             connections = null;
1:c61e6e8:         }
1:ffe3f66:         conn = null;
1:ddeb000:     }
1:442f696: 
1:01217c2:     /**
1:df2b52c:      * Open a connection to the default database.
1:b350a56:      * If the database does not exist, it will be created.
1:b350a56:      * A default username and password will be used for the connection.
1:28162f6:      * 
1:e65a7e8:      * The connection will be initialized by calling initializeConnection.
1:e65a7e8:      * A sub-class may provide an implementation of initializeConnection
1:e65a7e8:      * to ensure its connections are in a consistent state that is different
1:e65a7e8:      * to the default.
1:28162f6:      *
1:a997e8f:      * @return connection to default database.
1:ffe3f66:      * @see TestConfiguration#openDefaultConnection()
1:e65a7e8:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:a997e8f:      */
1:03a99e2:     public Connection openDefaultConnection()
1:a997e8f:         throws SQLException {
1:03a99e2:         Connection conn =  getTestConfiguration().openDefaultConnection();
1:c61e6e8:         addConnection(conn);
1:a997e8f:         initializeConnection(conn);
1:a997e8f:         return conn;
1:bb7eb4d:     }
1:616c0d0: 
1:616c0d0: 
1:616c0d0:     /**
1:616c0d0:      * Open a connection to the default database for the given configuration.
1:616c0d0:      * If the database does not exist, it will be created.  A default username
1:616c0d0:      * and password will be used for the connection.
1:616c0d0:      *
1:616c0d0:      * The connection will be initialized by calling initializeConnection.
1:616c0d0:      * A sub-class may provide an implementation of initializeConnection
1:616c0d0:      * to ensure its connections are in a consistent state that is different
1:616c0d0:      * to the default.
1:64a963d:      * @param tc test configuration to use
1:616c0d0:      * @return connection to default database for the configuration
1:616c0d0:      * @see TestConfiguration#openDefaultConnection()
1:616c0d0:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:616c0d0:      */
1:616c0d0:     public Connection openDefaultConnection(TestConfiguration tc)
1:616c0d0:         throws SQLException {
1:616c0d0:         Connection conn =  tc.openDefaultConnection();
1:c61e6e8:         addConnection(conn);
1:616c0d0:         initializeConnection(conn);
1:616c0d0:         return conn;
1:bb7eb4d:     }
1:616c0d0: 
1:a997e8f:     /**
1:2346370:      * Open a connection to the current default database using the
1:2346370:      * specified user name and password.
1:2346370:      * <BR>
1:2346370:      * This connection is not
1:a2ecbd3:      * automatically closed on tearDown, the test fixture must
1:2346370:      * ensure the connection is closed.
1:a997e8f:      * 
1:e65a7e8:      * The connection will be initialized by calling initializeConnection.
1:e65a7e8:      * A sub-class may provide an implementation of initializeConnection
1:e65a7e8:      * to ensure its connections are in a consistent state that is different
1:e65a7e8:      * to the default.
1:e65a7e8:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:a997e8f:      */
1:2346370:     public Connection openDefaultConnection(String user, String password)
1:a997e8f:     throws SQLException
1:a997e8f:     {
1:2346370:         Connection conn =  getTestConfiguration().openDefaultConnection(user,
1:2346370:                 password);
1:c61e6e8:         addConnection(conn);
1:a997e8f:         initializeConnection(conn);
1:a997e8f:         return conn;        
1:616c0d0:     }
1:a997e8f:     
1:a997e8f:     /**
1:2346370:      * Open a connection to the current default database using the
1:2346370:      * specified user name. The password is a function of
1:2346370:      * the user name and the password token setup by the
1:2346370:      * builtin authentication decorators.
1:e65a7e8:      * <BR>
1:2346370:      * If the fixture is not wrapped in one of the decorators
1:2346370:      * that setup BUILTIN authentication then the password
1:2346370:      * is a function of the user name and the empty string
1:2346370:      * as the password token. This mode is not recommended.
1:28162f6:      * 
1:2346370:      * <BR>
1:2346370:      * This connection is not
1:954af77:      * automaticaly closed on tearDown, the test fixture must
1:2346370:      * ensure the connection is closed.
1:2346370:      * <BR>
1:e65a7e8:      * The connection will be initialized by calling initializeConnection.
1:e65a7e8:      * A sub-class may provide an implementation of initializeConnection
1:e65a7e8:      * to ensure its connections are in a consistent state that is different
1:e65a7e8:      * to the default.
1:28162f6:      * 
1:2346370:      * @see DatabasePropertyTestSetup#builtinAuthentication(Test, String[], String)
1:2346370:      * @see TestConfiguration#sqlAuthorizationDecorator(Test, String[], String)
1:e65a7e8:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:2346370:      */
1:2346370:     public Connection openUserConnection(String user) throws SQLException
1:2346370:     {
1:2346370:         return openDefaultConnection(user,
1:2346370:                 getTestConfiguration().getPassword(user));
1:a997e8f:     }
1:a997e8f:     
1:2346370:     /**
1:3df869c:      * Open a connection to the specified database.
1:3df869c:      * If the database does not exist, it will be created.
1:3df869c:      * A default username and password will be used for the connection.
1:3df869c:      * Requires that the test has been decorated with a
1:e5c9e58:      * additionalDatabaseDecorator with the matching name.
1:e65a7e8:      * <BR>
1:e65a7e8:      * The connection will be initialized by calling initializeConnection.
1:e65a7e8:      * A sub-class may provide an implementation of initializeConnection
1:e65a7e8:      * to ensure its connections are in a consistent state that is different
1:e65a7e8:      * to the default.
1:3df869c:      * @return connection to default database.
1:e5c9e58:      * @see TestConfiguration#additionalDatabaseDecorator(Test, String)
1:e65a7e8:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:3df869c:      */
1:3df869c:     public Connection openConnection(String databaseName)
1:3df869c:         throws SQLException {
1:3df869c:         Connection conn =  getTestConfiguration().openConnection(databaseName);
1:c61e6e8:         addConnection(conn);
1:2346370:         initializeConnection(conn);
1:3df869c:         return conn;
1:a997e8f:     }
1:4b16d4c:     
1:3df869c:     /**
1:aa8a764:      * Run a SQL script through ij discarding the output
1:aa8a764:      * using this object's default connection. Intended for
1:aa8a764:      * setup scripts.
1:95011a0:      * @throws UnsupportedEncodingException 
1:a997e8f:      * @throws SQLException 
1:95011a0:      */
1:95011a0:     public int runScript(InputStream script, String encoding)
1:95011a0:         throws UnsupportedEncodingException, SQLException
1:0c4649d:     {
1:95011a0:         // Sink output.
1:148a1f0:         OutputStream sink = new TestNullOutputStream();
1:e65a7e8:         
1:95011a0:         // Use the same encoding as the input for the output.    
1:03a99e2:         return ij.runScript(getConnection(), script, encoding,
1:95011a0:                 sink, encoding);       
1:442f696:     }
1:2346370:     
1:13e9e78:     /**
1:95011a0:      * Run a SQL script through ij discarding the output
1:95011a0:      * using this object's default connection. Intended for
1:95011a0:      * setup scripts.
1:aa8a764:      * @return Number of errors executing the script
1:aa8a764:      * @throws UnsupportedEncodingException 
1:aa8a764:      * @throws PrivilegedActionException
1:aa8a764:      * @throws SQLException 
1:aa8a764:      */
1:aa8a764:     public int runScript(String resource,String encoding)
1:aa8a764:         throws UnsupportedEncodingException, SQLException,
1:aa8a764:         PrivilegedActionException,IOException
1:aa8a764:     {
1:3df869c:         
1:aa8a764:         URL sql = getTestResource(resource);
1:aa8a764:         assertNotNull("SQL script missing: " + resource, sql);
1:aa8a764:         InputStream sqlIn = openTestResource(sql);
1:aa8a764:         Connection conn = getConnection();
1:aa8a764:         int numErrors = runScript(sqlIn,encoding);
1:aa8a764:         sqlIn.close();
1:aa8a764:         
1:aa8a764:         if (!conn.isClosed() && !conn.getAutoCommit())
1:aa8a764:             conn.commit();
1:b4cda60:         
1:aa8a764:         return numErrors;
1:c7b3589:     }
1:c7b3589:     
1:c7b3589:     /**
1:442f696:      * Run a set of SQL commands from a String discarding the output.
1:95011a0:      * Commands are separated by a semi-colon. Connection used
1:442f696:      * is this objects default connection.
1:95011a0:      * @param sqlCommands
1:95011a0:      * @return Number of errors executing the script.
1:95011a0:      * @throws UnsupportedEncodingException
1:95011a0:      * @throws SQLException
1:c7b3589:      */
1:95011a0:     public int runSQLCommands(String sqlCommands)
1:95011a0:         throws UnsupportedEncodingException, SQLException
1:0c4649d:     {
1:95011a0:         byte[] raw = sqlCommands.getBytes("UTF-8");
1:95011a0:         ByteArrayInputStream in = new ByteArrayInputStream(raw);
1:aa8a764:         
1:95011a0:         return runScript(in, "UTF-8");
1:442f696:     }
1:aa8a764:     
1:aa8a764:     /**
1:57efc3c:      * Tell if the client is embedded.
1:57efc3c:      *
1:57efc3c:      * @return <code>true</code> if using the embedded client
1:57efc3c:      *         <code>false</code> otherwise.
1:57efc3c:      */
1:57efc3c:      public static boolean usingEmbedded() {
1:e0104e8:          return TestConfiguration.getCurrent().getJDBCClient().isEmbedded();
1:57efc3c:      }
1:57efc3c:     
1:57efc3c:     /**
1:b350a56:     * Tell if the client is DerbyNetClient.
1:c7b3589:     *
1:b350a56:     * @return <code>true</code> if using the DerbyNetClient client
2:b350a56:     *         <code>false</code> otherwise.
1:95011a0:     */
1:b350a56:     public static boolean usingDerbyNetClient() {
1:e0104e8:         return TestConfiguration.getCurrent().getJDBCClient().isDerbyNetClient();
1:442f696:     }
1:aa8a764:     
1:95011a0:     /**
1:cd1bd2a:     * Tell if the client is DB2Client.
1:2346370:     *
1:cd1bd2a:     * @return <code>true</code> if using the DB2 client driver,
1:b350a56:     *         <code>false</code> otherwise.
1:fb2bfd5:     */
1:cd1bd2a:     public static boolean usingDB2Client() {
1:e0104e8:         return TestConfiguration.getCurrent().getJDBCClient().isDB2Client();
1:442f696:     }
1:c943ab3:     
1:c943ab3:     /**
1:c943ab3:      * Get the value of a database property using the default connection 
1:c943ab3:      * @param propertyName Property key
1:c943ab3:      * @return null if the property is not set at the database level,
1:c943ab3:      * otherwise the value of the property.
1:c943ab3:      * @throws SQLException
1:c943ab3:      */
1:c943ab3:     public String getDatabaseProperty(String propertyName) throws SQLException
1:c943ab3:     {
1:c943ab3:         PreparedStatement ps =  prepareStatement(
1:c943ab3:              "VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY(?)");
1:c943ab3:         
1:c943ab3:         ps.setString(1, propertyName);
1:c943ab3:         ResultSet rs = ps.executeQuery();
1:c943ab3:         
1:c943ab3:         rs.next();
1:7840c51: 
1:7840c51:         String val = rs.getString(1);
1:7840c51: 
1:7840c51:         rs.close();
1:7840c51:         closeStatement(ps);
1:7840c51: 
1:7840c51:         return val;
1:c943ab3:     }
1:c943ab3: 
1:95011a0:     /**
1:e9f346c:      * Assert equality between two <code>Blob</code> objects.
1:e9f346c:      * If both input references are <code>null</code>, they are considered
1:e9f346c:      * equal. The same is true if both blobs have <code>null</code>-streams.
1:e9f346c:      *
1:e9f346c:      * @param b1 first <code>Blob</code>.
1:e9f346c:      * @param b2 second <code>Blob</code>.
1:e9f346c:      * @throws AssertionFailedError if blobs are not equal.
1:fff1a02:      * @throws IOException if reading or closing a stream fails
1:fff1a02:      * @throws SQLException if obtaining a stream fails
1:e9f346c:      */
1:fff1a02:     public static void assertEquals(Blob b1, Blob b2)
1:fff1a02:             throws IOException, SQLException {
1:e9f346c:         if (b1 == null || b2 == null) {
1:e9f346c:             assertNull("Blob b2 is null, b1 is not", b1);
1:e9f346c:             assertNull("Blob b1 is null, b2 is not", b2);
1:e9f346c:             return;
1:e9f346c:         }
1:fff1a02:         assertEquals("Blobs have different lengths",
1:fff1a02:                      b1.length(), b2.length());
1:fff1a02:         InputStream is1 = b1.getBinaryStream();
1:fff1a02:         InputStream is2 = b2.getBinaryStream();
1:01217c2: 
1:fff1a02:         if (is1 == null || is2 == null) {
1:fff1a02:             assertNull("Blob b2 has null-stream, blob b1 doesn't", is1);
1:fff1a02:             assertNull("Blob b1 has null-stream, blob b2 doesn't", is2);
1:fff1a02:             return;
1:e9f346c:         }
1:13e9e78:         
1:ffdaf1e:         // wrap buffered stream around the binary stream
1:ffdaf1e:         is1 = new BufferedInputStream(is1);
1:ffdaf1e:         is2 = new BufferedInputStream(is2);
1:95011a0:  
1:fff1a02:         long index = 1;
1:fff1a02:         int by1 = is1.read();
1:fff1a02:         int by2 = is2.read();
1:fff1a02:         do {
1:fff1a02:             // Avoid string concatenation for every byte in the stream.
1:fff1a02:             if (by1 != by2) {
1:e9f346c:                 assertEquals("Blobs differ at index " + index,
1:e9f346c:                         by1, by2);
1:fff1a02:             }
1:fff1a02:             index++;
1:fff1a02:             by1 = is1.read();
1:fff1a02:             by2 = is2.read();
1:fff1a02:         } while ( by1 != -1 || by2 != -1);
1:fff1a02:         is1.close();
1:fff1a02:         is2.close();
1:e9f346c:     }
1:e9f346c: 
1:e9f346c:     /**
1:e9f346c:      * Assert equality between two <code>Clob</code> objects.
1:e9f346c:      * If both input references are <code>null</code>, they are considered
1:e9f346c:      * equal. The same is true if both clobs have <code>null</code>-streams.
1:e9f346c:      *
1:e9f346c:      * @param c1 first <code>Clob</code>.
1:e9f346c:      * @param c2 second <code>Clob</code>.
1:e9f346c:      * @throws AssertionFailedError if clobs are not equal.
1:fff1a02:      * @throws IOException if reading or closing a stream fails
1:fff1a02:      * @throws SQLException if obtaining a stream fails
1:e9f346c:      */
1:fff1a02:     public static void assertEquals(Clob c1, Clob c2)
1:fff1a02:             throws IOException, SQLException {
1:e9f346c:         if (c1 == null || c2 == null) {
1:e9f346c:             assertNull("Clob c2 is null, c1 is not", c1);
1:e9f346c:             assertNull("Clob c1 is null, c2 is not", c2);
1:fff1a02:             return;
1:e9f346c:         }
1:fff1a02:         assertEquals("Clobs have different lengths",
1:fff1a02:                      c1.length(), c2.length());
1:fff1a02:         Reader r1 = c1.getCharacterStream();
1:3a781d5:         assertNotNull(r1); // java.sql.Blob object cannot represent NULL
1:fff1a02:         Reader r2 = c2.getCharacterStream();
1:3a781d5:         assertNotNull(r2); // java.sql.Blob object cannot represent NULL
1:3a781d5: 
1:ffdaf1e:         // wrap buffered reader around the character stream
1:ffdaf1e:         r1 = new BufferedReader(r1);
1:ffdaf1e:         r2 = new BufferedReader(r2);
3:95011a0: 
1:fff1a02:         long index = 1;
1:fff1a02:         int ch1 = r1.read();
1:fff1a02:         int ch2 = r2.read();
1:fff1a02:         do {
1:fff1a02:             // Avoid string concatenation for every char in the stream.
1:fff1a02:             if (ch1 != ch2) {
1:e9f346c:                 assertEquals("Clobs differ at index " + index,
1:e9f346c:                         ch1, ch2);
1:fff1a02:             }
1:fff1a02:             index++;
1:fff1a02:             ch1 = r1.read();
1:fff1a02:             ch2 = r2.read();
1:fff1a02:         } while (ch1 != -1 || ch2 != -1);
1:fff1a02:         r1.close();
1:fff1a02:         r2.close();
1:02f8e49:     }
1:95011a0: 
1:fb2bfd5:     /**
1:8a319fb:      * Assert equality between two <code>java.sql.Time</code> objects.
1:8a319fb:      * If both input references are <code>null</code>, they are considered
1:8a319fb:      * equal.
1:8a319fb:      *
1:8a319fb:      * @param msg String with message to supply with AssertionFailedError
1:8a319fb:      * @param t1 first java.sql.Time object.
1:8a319fb:      * @param t2 second java.sql.Time object.
1:8a319fb:      * @throws AssertionFailedError if Time objects are not equal.
1:8a319fb:      */
1:8a319fb:     public static void assertEquals(String msg, Time t1, Time t2) {
1:8a319fb:         if(null == t1 && null == t2) {
1:e9f346c:             return;
1:24b23a8:         }
1:8a319fb:         assertNotNull(msg, t1);
1:8a319fb:         assertNotNull(msg, t2);
1:8a319fb:         assertEquals(msg, t1.toString(), t2.toString());
1:8a319fb:     }
1:8a319fb:     
1:8a319fb:     /**
1:0c4649d:      * Assert that SQLState is as expected.  If the SQLState for
1:0c4649d:      * the top-level exception doesn't match, look for nested
1:0c4649d:      * exceptions and, if there are any, see if they have the
1:0c4649d:      * desired SQLState.
1:2346370:      *
1:ed0e114:      * @param message message to print on failure.
1:ed0e114:      * @param expected the expected SQLState.
1:ed0e114:      * @param exception the exception to check the SQLState of.
1:ed0e114:      */
1:ed0e114:     public static void assertSQLState(String message, 
1:ed0e114:                                       String expected, 
1:ed0e114:                                       SQLException exception) {
1:ed0e114:         // Make sure exception is not null. We want to separate between a
1:ed0e114:         // null-exception object, and a null-SQLState.
1:9634cd2:         assertNotNull("Exception cannot be null when asserting on SQLState", 
1:9634cd2:                       exception);
1:01217c2:         
1:e9f346c:         try {
1:01217c2:             String state = exception.getSQLState();
1:e9f346c:             
1:01217c2:             if ( state != null )
1:01217c2:                 assertTrue("The exception's SQL state must be five characters long",
1:01217c2:                         state.length() == 5);
1:c7b3589:             
1:01217c2:             if ( expected != null )
1:01217c2:                 assertTrue("The expected SQL state must be five characters long",
1:01217c2:                     expected.length() == 5);
1:0c4649d:             
1:01217c2:             assertEquals(message, expected, state);
1:48154b2:         } catch (AssertionFailedError e) {
1:4183d60:             
1:b2c1772:             // Save the SQLException
1:379e4cc:             e.initCause(exception);
1:01217c2: 
1:cd1bd2a:             if (usingDB2Client())
1:b2c1772:             {
1:0c4649d:                 /* For JCC the error message is a series of tokens representing
1:0c4649d:                  * different things like SQLSTATE, SQLCODE, nested SQL error
1:0c4649d:                  * message, and nested SQL state.  Based on observation it
1:0c4649d:                  * appears that the last token in the message is the SQLSTATE
1:0c4649d:                  * of the nested exception, and it's preceded by a colon.
1:0c4649d:                  * So using that (hopefully consistent?) rule, try to find
1:0c4649d:                  * the target SQLSTATE.
1:0c4649d:                  */
1:0c4649d:                 String msg = exception.getMessage();
1:0c4649d:                 if (!msg.substring(msg.lastIndexOf(":")+1)
1:0c4649d:                     .trim().equals(expected))
1:b2c1772:                 {
2:0c4649d:                     throw e;
1:58588dd:                 }
1:e9f346c:             }
1:0c4649d:             else
1:0c4649d:             {
1:0c4649d:                 // Check nested exceptions to see if any of them is
1:0c4649d:                 // the one we're looking for.
1:48154b2:                 exception = exception.getNextException();
1:0c4649d:                 if (exception != null)
1:0c4649d:                     assertSQLState(message, expected, exception);
1:0c4649d:                 else
1:0c4649d:                     throw e;
1:e9f346c:             }
1:e9f346c:         }
1:e9f346c:     }
1:01217c2: 
1:4183d60:     /**
1:e744e84:      * Assert that a warning is chained to the connection.
1:e744e84:      *
1:e744e84:      * @param conn  the connection
1:e744e84:      * @param expected the expected SQLState of the warning
1:e744e84:      */
1:e744e84:     public static void assertWarning( Connection conn, String expected )
1:e744e84:         throws SQLException
1:e744e84:     {
1:e744e84:         SQLWarning  firstWarning = conn.getWarnings();
1:e744e84:         assertNotNull( firstWarning );
1:e744e84: 
1:e744e84:         for ( SQLWarning warning = firstWarning; warning != null; warning = warning.getNextWarning() )
1:e744e84:         {
1:e744e84:             if ( expected.equals( warning.getSQLState() ) ) { return; }
1:e744e84:         }
1:e744e84: 
1:e744e84:         fail( "Expected to see a SQLWarning with the SQLState " + expected );
1:e744e84:     }
1:e744e84: 
1:e744e84: 
1:e744e84:     /**
1:4183d60:      * Assert that SQLState is as expected.
1:4183d60:      *
1:4183d60:      * @param expected the expected SQLState.
1:4183d60:      * @param exception the exception to check the SQLState of.
1:4183d60:      */
1:4183d60:     public static void assertSQLState(String expected, SQLException exception) {
1:4183d60:         assertSQLState("Unexpected SQL state.", expected, exception);
1:4183d60:     }
1:b54db0f: 
1:b54db0f:     /**
1:b54db0f:      * Assert that the error code is as expected.
1:b54db0f:      *
1:b54db0f:      * @param expected the expected error code
1:b54db0f:      * @param exception the exception to check
1:b54db0f:      * @throws AssertionFailedError if the error code is wrong
1:b54db0f:      */
1:b54db0f:     public static void assertErrorCode(int expected, SQLException exception) {
1:b54db0f:         assertNotNull("Exception should not be null", exception);
1:b54db0f:         int actual = exception.getErrorCode();
1:b54db0f:         if (actual != expected) {
1:b54db0f:             fail("Expected error code " + expected + ", got " + actual,
1:b54db0f:                  exception);
1:b54db0f:         }
1:b54db0f:     }
1:b54db0f: 
1:e9f346c:     /**
1:442f696:      * Assert that the SQL statement does not compile and throws
1:01217c2:      * a SQLException with the expected state.
1:0c4649d:      * 
1:df4020d:      * @param sqlState expected sql state.
1:442f696:      * @param sql the SQL to compile.
1:01217c2:      */
1:442f696:     public void assertCompileError(String sqlState, String sql) {
1:ed0e114: 
1:58588dd:         try {
1:442f696:             PreparedStatement pSt = prepareStatement(sql);
1:cd1bd2a:             if (usingDB2Client())
1:48154b2:             {
1:0c4649d:                 /* For JCC the prepares are deferred until execution,
1:0c4649d:                  * so we have to actually execute in order to see the
1:0c4649d:                  * expected error.  Note that we don't need to worry
1:0c4649d:                  * about binding the parameters (if any); the compile
1:0c4649d:                  * error should occur before the execution-time error
1:0c4649d:                  * about unbound parameters.
1:0c4649d:                  */
1:e9f346c:                 try {
1:e604a71:                     pSt.execute();
1:e604a71:                 } finally {
1:e604a71:                     pSt.close();
1:ed0e114:                 }
1:ed0e114:             }
1:01217c2:             fail("expected compile error: " + sqlState);
1:01217c2:         } catch (SQLException se) {
1:0c4649d:             assertSQLState(sqlState, se);
1:ed0e114:         }
1:89c399d:     }
1:48154b2:     
1:ed0e114:     /**
1:4b16d4c:      * Check the table using SYSCS_UTIL.SYSCS_CHECK_TABLE.
1:4b16d4c:      */
1:4b16d4c:     public void assertCheckTable(String table) throws SQLException
1:4b16d4c:     {
1:4b16d4c:         PreparedStatement ps = prepareStatement(
1:4b16d4c:                 "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE(?, ?)");
1:48154b2:         
1:4b16d4c:         ps.setString(1, getTestConfiguration().getUserName());
1:4b16d4c:         ps.setString(2, table);
1:4b16d4c:         
1:4b16d4c:         ResultSet rs = ps.executeQuery();
1:4b16d4c:         JDBC.assertSingleValueResultSet(rs, "1");
1:4b16d4c:         ps.close();
1:48154b2:     }
1:4b16d4c:     
1:1ae0d7d:     /**
1:e65a7e8:      * Assert that the number of rows in a table is an expected value.
1:e65a7e8:      * Query uses a SELECT COUNT(*) FROM "table".
1:e65a7e8:      * 
1:e65a7e8:      * @param table Name of table in current schema, will be quoted
1:e65a7e8:      * @param rowCount Number of rows expected in the table
1:e65a7e8:      * @throws SQLException Error accessing the database.
1:e65a7e8:      */
1:e65a7e8:     protected void assertTableRowCount(String table, int rowCount) throws SQLException
1:e65a7e8:     {
1:e65a7e8:         assertEscapedTableRowCount(JDBC.escape(table), rowCount);
1:48154b2:     }
1:e65a7e8: 
1:48154b2:     /**
1:e65a7e8:      * Assert that the number of rows in a table is an expected value.
1:e65a7e8:      * Query uses a SELECT COUNT(*) FROM table.
1:e65a7e8:      * 
1:df4020d:      * @param escapedTableName Escaped name of table, will be used as-is.
1:e65a7e8:      * @param rowCount Number of rows expected in the table
1:e65a7e8:      * @throws SQLException Error accessing the database.
1:e65a7e8:      */
1:e65a7e8:     private void assertEscapedTableRowCount(String escapedTableName, int rowCount)
1:e65a7e8:        throws SQLException
1:e65a7e8:     {
1:e65a7e8:     
1:e65a7e8:         Statement s = createStatement();
1:e65a7e8:         ResultSet rs = s.executeQuery(
1:e65a7e8:                 "SELECT COUNT(*) FROM " + escapedTableName);
1:e65a7e8:         rs.next();
1:e65a7e8:         assertEquals(escapedTableName + " row count:",
1:e65a7e8:             rowCount, rs.getInt(1));
1:e65a7e8:         rs.close();
1:e65a7e8:         s.close();
1:c48e69a:     }
1:0c4649d: 
1:4b16d4c:     /**
1:9850fb9:      * Clear the contents of the statement cache. Useful if a test case
1:9850fb9:      * needs to make sure that a statement is actually compiled and not
1:9850fb9:      * just fetched from the statement cache.
1:9850fb9:      *
1:9850fb9:      * @throws SQLException if a database error happens
1:9850fb9:      */
1:9850fb9:     protected final void emptyStatementCache() throws SQLException {
1:9850fb9:         Statement s = createStatement();
1:9850fb9:         s.execute("CALL SYSCS_UTIL.SYSCS_EMPTY_STATEMENT_CACHE()");
1:9850fb9:         closeStatement(s);
1:9850fb9:     }
1:9850fb9: 
1:9850fb9:     /**
1:ddeb000:      * Execute a DROP TABLE command using the passed in tableName as-is
1:ddeb000:      * and the default connection.
1:ddeb000:      * If the DROP TABLE fails because the table does not exist then
1:ddeb000:      * the exception is ignored.
1:ddeb000:      * @param tableName Table to be dropped.
1:ddeb000:      * @throws SQLException
1:ddeb000:      */
1:ddeb000:     public final void dropTable(String tableName) throws SQLException
1:c48e69a:     {
1:ddeb000:        dropTable(getConnection(), tableName);
1:c48e69a:     }
1:ddeb000:     
1:ddeb000:     /**
1:ddeb000:      * Execute a DROP TABLE command using the passed in tableName as-is.
1:ddeb000:      * If the DROP TABLE fails because the table does not exist then
1:ddeb000:      * the exception is ignored.
1:ddeb000:      * @param conn Connection to execute the DROP TABLE
1:ddeb000:      * @param tableName Table to be dropped.
1:ddeb000:      * @throws SQLException
1:ddeb000:      */
1:ddeb000:     public static void dropTable(Connection conn, String tableName) throws SQLException
1:c48e69a:     {
1:ddeb000:         Statement statement = conn.createStatement();
1:ddeb000:         String dropSQL = "DROP TABLE " + tableName;
1:e9f346c:         try { 
1:ddeb000:             
1:ddeb000:             statement.executeUpdate(dropSQL); 
1:ddeb000:         } catch (SQLException e) {
1:ddeb000:             assertSQLState("42Y55", e);
1:c48e69a:         }
1:ddeb000:         finally {
1:ddeb000:             statement.close();
1:48154b2:         }
1:48154b2:     }
1:ddeb000: 
1:ddeb000:     /**
1:232f5ef:      * Execute a DROP VIEW command using the passed in viewName as-is
1:232f5ef:      * and the default connection.
1:232f5ef:      * If the DROP VIEW fails because the view does not exist then
1:232f5ef:      * the exception is ignored.
1:232f5ef:      * @param viewName Table to be dropped.
1:232f5ef:      * @throws SQLException
1:232f5ef:      */
1:232f5ef:     public final void dropView(String viewName) throws SQLException
1:232f5ef:     {
1:232f5ef:        dropView(getConnection(), viewName);
1:232f5ef:     }
1:232f5ef:     
1:232f5ef:     /**
1:232f5ef:      * Execute a DROP VIEW command using the passed in viewName as-is.
1:232f5ef:      * If the DROP VIEW fails because the view does not exist then
1:232f5ef:      * the exception is ignored.
1:232f5ef:      * @param conn Connection to execute the DROP VIEW
1:232f5ef:      * @param viewName Table to be dropped.
1:232f5ef:      * @throws SQLException
1:232f5ef:      */
1:232f5ef:     public static void dropView(Connection conn, String viewName) throws SQLException
1:232f5ef:     {
1:232f5ef:         Statement statement = conn.createStatement();
1:232f5ef:         String dropSQL = "DROP VIEW " + viewName;
1:e9f346c:         try { 
1:232f5ef:             
1:232f5ef:             statement.executeUpdate(dropSQL); 
1:232f5ef:         } catch (SQLException e) {
1:232f5ef:             assertSQLState("42Y55", e);
1:232f5ef:         }
1:232f5ef:         finally {
1:232f5ef:             statement.close();
1:232f5ef:         }
1:232f5ef:     }
1:232f5ef: 
1:232f5ef:     /**
1:48154b2:      * Assert that the query fails (either in compilation,
1:48154b2:      * execution, or retrieval of results--doesn't matter)
1:86be795:      * and throws a SQLException with the expected states.
1:48154b2:      *
2:0c4649d:      * Assumption is that 'query' does *not* have parameters
1:0c4649d:      * that need binding and thus can be executed using a
1:0c4649d:      * simple Statement.execute() call.
1:86be795:      *
1:86be795:      * If there are extra chained SQLExceptions that are 
1:86be795:      * not in sqlStates, this method will not fail.
1:48154b2:      * 
1:a977a87:      * @param sqlStates  expected sql states.
1:0c4649d:      * @param st Statement object on which to execute.
1:0c4649d:      * @param query the query to compile and execute.
1:0c4649d:      */
1:86be795:     public static void assertStatementError(String[] sqlStates,
1:7eb8268:             Statement st, String query) {
1:7eb8268:         assertStatementErrorMinion(sqlStates, ORDERED, st, query);
1:f0f442f:     }
1:7eb8268: 
1:7eb8268:     /**
1:7eb8268:      * Assert that the query fails (either in compilation,
1:7eb8268:      * execution, or retrieval of results--doesn't matter)
1:7eb8268:      * and throws a SQLException with the expected states.
1:7eb8268:      *
1:7eb8268:      * Assumption is that 'query' does *not* have parameters
1:7eb8268:      * that need binding and thus can be executed using a
1:7eb8268:      * simple Statement.execute() call.
1:7eb8268:      *
1:7eb8268:      * If there are extra chained SQLExceptions that are
1:7eb8268:      * not in sqlStates, this method will not fail.
1:7eb8268:      *
1:7eb8268:      * @param sqlStates  expected sql states.
1:7eb8268:      * @param st Statement object on which to execute.
1:7eb8268:      * @param query the query to compile and execute.
1:7eb8268:      */
1:7eb8268:     public static void assertStatementErrorUnordered(String[] sqlStates,
1:7eb8268:             Statement st, String query) {
1:7eb8268:         assertStatementErrorMinion(sqlStates, UNORDERED, st, query);
1:ba553fa:     }
1:7eb8268: 
1:7eb8268:     /**
1:7eb8268:      * Asserts that the given statement fails (compilation, execution or
1:7eb8268:      * retrieval of results) and throws an {@code SQLException} with the
1:7eb8268:      * expected (chained) states.
1:7eb8268:      *
1:7eb8268:      * @param sqlStates the expected states
1:7eb8268:      * @param orderedStates whether or not the states are expected in the
1:7eb8268:      *      specified order or not
1:7eb8268:      * @param st the statement used to execute the query
1:7eb8268:      * @param query the query to execute
1:7eb8268:      */
1:7eb8268:     private static void assertStatementErrorMinion(
1:7eb8268:             String[] sqlStates, boolean orderedStates,
1:7eb8268:             Statement st, String query) {
1:2510115:         ArrayList<String> statesBag = null;
1:7eb8268:         if (!orderedStates) {
1:2510115:             statesBag = new ArrayList<String>(Arrays.asList(sqlStates));
1:7eb8268:         }
1:48154b2:         try {
1:0c4649d:             boolean haveRS = st.execute(query);
1:0c4649d:             fetchAndDiscardAllResults(st, haveRS);
1:86be795:             String errorMsg = "Expected error(s) '" ;
1:86be795:             for (int i = 0; i < sqlStates.length;i++)
1:86be795:                 errorMsg += " " + sqlStates[i];
1:86be795:             errorMsg += "' but no error was thrown.";            
1:86be795:             fail(errorMsg);            
1:0c4649d:         } catch (SQLException se) {
1:86be795:             int count = 0;
2:e9f346c:             do {
1:7eb8268:                 if (orderedStates) {
1:86be795:                     assertSQLState(sqlStates[count], se);
1:7aa3f88:                 } else {
1:7eb8268:                     String state = se.getSQLState();
1:7eb8268:                     assertTrue("Unexpected state: " + state,
1:7eb8268:                             statesBag.remove(state));
1:7eb8268:                     // Run through assertSQLStates too, to catch invalid states.
1:7eb8268:                     assertSQLState(state, se);
1:7aa3f88:                 }
1:86be795:                 count++;
1:86be795:                 se = se.getNextException();
1:86be795:             } while (se != null && count < sqlStates.length);
1:86be795:             // We must have at least as many exceptions as 
1:86be795:             // we expected.
1:86be795:             assertEquals("Got " +
1:86be795:                     count + " exceptions. Expected at least"+
1:86be795:                     sqlStates.length,count,sqlStates.length);
1:86be795:             
1:ba553fa:         }
1:ba553fa:     }
1:86be795: 
1:86be795:     /**
1:86be795:      * Assert that the query fails with a single error
1:28162f6:      *  
1:86be795:      * @param sqlState  Expected SQLState of exception
1:86be795:      * @param st         
1:86be795:      * @param query
1:86be795:      * @see #assertStatementError(String[], Statement, String)
1:86be795:      */
1:86be795:     public static void assertStatementError(String sqlState, Statement st, String query) {
1:86be795:         assertStatementError(new String[] {sqlState},st,query);
1:86be795:     }
1:86be795:         
1:4cc0287:     /**
1:4cc0287:      * Assert that that a commit fails with the given error
1:4cc0287:      * @param sqlState state
1:4cc0287:      * @param c        the connection
1:4cc0287:      */
1:4cc0287:     public static void assertCommitError(String sqlState, Connection c) {
1:4cc0287:         try {
1:4cc0287:             c.commit();
1:4cc0287:             fail();
1:4cc0287:         } catch (SQLException e) {
1:4cc0287:             assertSQLState(sqlState, e);
1:4cc0287:         }
1:4cc0287:     }
1:86be795:    
1:0c4649d:     /**
1:0c4649d:      * Assert that the query fails (either in compilation,
1:0c4649d:      * execution, or retrieval of results--doesn't matter)
1:48154b2:      * and throws a SQLException with the expected state
1:48154b2:      * and error code
1:28162f6:      *
1:48154b2:      * Assumption is that 'query' does *not* have parameters
1:48154b2:      * that need binding and thus can be executed using a
1:48154b2:      * simple Statement.execute() call.
1:86be795:      * 
1:48154b2:      * @param sqlState expected sql state.
1:48154b2:      * @param errorCode expected error code.
1:48154b2:      * @param st Statement object on which to execute.
1:48154b2:      * @param query the query to compile and execute.
1:48154b2:      */
1:48154b2:     public static void assertStatementError(String sqlState, int errorCode, Statement st, String query) {
1:48154b2:         try {
1:48154b2:             boolean haveRS = st.execute(query);
1:48154b2:             fetchAndDiscardAllResults(st, haveRS);
1:48154b2:             fail("Expected error '" + sqlState +
1:48154b2:                 "' but no error was thrown.");
1:48154b2:         } catch (SQLException se) {
1:48154b2:             assertSQLState(sqlState, se);
1:b54db0f:             assertErrorCode(errorCode, se);
1:48154b2:         }
1:86be795:         
1:48154b2:     }
1:48154b2: 
1:0c4649d:     /**
1:00c7a20:      * Assert that the query fails (either in execution, or retrieval of
1:00c7a20:      * results--doesn't matter) and throws a SQLException with the expected
1:00c7a20:      * state and error code
1:00c7a20:      *
1:00c7a20:      * Parameters must have been already bound, if any.
1:00c7a20:      *
1:00c7a20:      * @param sqlState expected sql state.
1:00c7a20:      * @param ps PreparedStatement query object to execute.
1:00c7a20:      */
1:00c7a20:     public static void assertPreparedStatementError(String sqlState,
1:00c7a20:                                                     PreparedStatement ps) {
1:00c7a20:         try {
1:00c7a20:             boolean haveRS = ps.execute();
1:00c7a20:             fetchAndDiscardAllResults(ps, haveRS);
1:00c7a20:             fail("Expected error '" + sqlState +
1:00c7a20:                 "' but no error was thrown.");
1:00c7a20:         } catch (SQLException se) {
1:00c7a20:             assertSQLState(sqlState, se);
1:00c7a20:         }
1:00c7a20:     }
1:00c7a20: 
1:7ebfefe:     /**
1:0c4649d:      * Assert that execution of the received PreparedStatement
1:0c4649d:      * object fails (either in execution or when retrieving
1:0c4649d:      * results) and throws a SQLException with the expected
1:0c4649d:      * state.
1:0c4649d:      * 
1:0c4649d:      * Assumption is that "pSt" is either a PreparedStatement
1:0c4649d:      * or a CallableStatement that has already been prepared
1:0c4649d:      * and whose parameters (if any) have already been bound.
1:0c4649d:      * Thus the only thing left to do is to call "execute()"
1:0c4649d:      * and look for the expected SQLException.
1:0c4649d:      * 
1:df4020d:      * @param sqlState expected sql state.
1:0c4649d:      * @param pSt A PreparedStatement or CallableStatement on
1:0c4649d:      *  which to call "execute()".
1:0c4649d:      */
2:0c4649d:     public static void assertStatementError(String sqlState,
1:0c4649d:         PreparedStatement pSt)
1:ddeb000:     {
1:232f5ef:         try {
1:0c4649d:             boolean haveRS = pSt.execute();
1:0c4649d:             fetchAndDiscardAllResults(pSt, haveRS);
2:0c4649d:             fail("Expected error '" + sqlState +
2:0c4649d:                 "' but no error was thrown.");
1:0c4649d:         } catch (SQLException se) {
1:0c4649d:             assertSQLState(sqlState, se);
1:ba553fa:         }
1:7eb8268:     }
1:48154b2: 
1:0c4649d: 
1:0c4649d:     /**
1:fdb0ac3:      * Executes the Callable statement that is expected to fail and verifies
1:fdb0ac3:      * that it throws the expected SQL exception.
1:fdb0ac3:      * @param expectedSE The expected SQL exception
1:ccce12c:      * @param callSQL The SQL to execute
1:fdb0ac3:      * @throws SQLException
1:fdb0ac3:      */
1:20a900f:     public void assertCallError(String expectedSE, String callSQL)
1:fdb0ac3:     throws SQLException
1:fdb0ac3:     {
1:fdb0ac3:         try {
1:20a900f:             CallableStatement cs = prepareCall(callSQL);
1:fdb0ac3:             cs.execute();
1:fdb0ac3:             fail("FAIL - SQL expected to throw exception");
1:fdb0ac3:         } catch (SQLException se) {
1:20a900f:             assertSQLState(expectedSE, se);
1:fdb0ac3:         }
1:fdb0ac3:     }
1:7ebfefe:     /**
1:c872753:      * Perform a fetch on the ResultSet with an expected failure
1:c872753:      * 
1:c872753:      * @param sqlState Expected SQLState
1:c872753:      * @param rs   ResultSet upon which next() will be called
1:c872753:      */
1:c872753:     public static void assertNextError(String sqlState,ResultSet rs)
1:c872753:     {
1:c872753:     	try {
1:c872753:     		rs.next();
1:c872753:     		fail("Expected error on next()");
1:c872753:     	}catch (SQLException se){
1:c872753:     		assertSQLState(sqlState,se);
1:c872753:     	}
1:c872753:     }
1:c872753:     
1:c872753:     /**
1:c872753:      * Perform getInt(position) with expected error
1:c872753:      * @param position  position argument to pass to getInt
1:c872753:      * @param sqlState  sqlState of expected error
1:c872753:      * @param rs ResultSet upon which to call getInt(position)
1:c872753:      */
1:c872753:     public static void assertGetIntError(int position, String sqlState, ResultSet rs)
1:c872753:     {
1:c872753:     	try {
1:c872753:     		rs.getInt(position);
1:c872753:     		fail("Expected exception " + sqlState);
1:c872753:     	} catch (SQLException se){
1:c872753:     		assertSQLState(sqlState,se);
1:c872753:     	}
1:c872753:     			
1:c872753:     	
1:c872753:     }
1:c872753:     /**
1:442f696:      * Take a Statement object and a SQL statement, execute it
1:0c4649d:      * via the "executeUpdate()" method, and assert that the
1:0c4649d:      * resultant row count matches the received row count.
1:0c4649d:      *
1:442f696:      * Assumption is that 'sql' does *not* have parameters
1:0c4649d:      * that need binding and that it can be executed using a
1:0c4649d:      * simple Statement.executeUpdate() call.
1:0c4649d:      * 
1:0c4649d:      * @param st Statement object on which to execute.
1:0c4649d:      * @param expectedRC Expected row count.
1:442f696:      * @param sql SQL to execute.
1:0c4649d:      */
1:0c4649d:     public static void assertUpdateCount(Statement st,
1:442f696:         int expectedRC, String sql) throws SQLException
1:0c4649d:     {
1:0c4649d:         assertEquals("Update count does not match:",
1:442f696:             expectedRC, st.executeUpdate(sql));
1:7eb8268:     }
1:0c4649d: 
1:0c4649d:     /**
1:0c4649d:      * Assert that a call to "executeUpdate()" on the received
1:0c4649d:      * PreparedStatement object returns a row count that matches
1:0c4649d:      * the received row count.
1:0c4649d:      *
1:0c4649d:      * Assumption is that "pSt" is either a PreparedStatement
1:0c4649d:      * or a CallableStatement that has already been prepared
1:0c4649d:      * and whose parameters (if any) have already been bound.
1:0c4649d:      * Also assumes the statement's SQL is such that a call
1:0c4649d:      * executeUpdate() is allowed.  Thus the only thing left
1:0c4649d:      * to do is to call the "executeUpdate" method.
1:0c4649d:      * 
1:0c4649d:      * @param pSt The PreparedStatement on which to execute.
1:0c4649d:      * @param expectedRC The expected row count.
1:0c4649d:      */
1:0c4649d:     public static void assertUpdateCount(PreparedStatement pSt,
1:0c4649d:         int expectedRC) throws SQLException
1:0c4649d:     {
1:0c4649d:         assertEquals("Update count does not match:",
1:0c4649d:             expectedRC, pSt.executeUpdate());
1:c7b3589:     }
1:0c4649d: 
1:0c4649d:     /**
1:48154b2:      * Get the last SQLException in chain.
1:e162ad6:      * @param sqle <code>SQLException</code>
1:48154b2:      * @return the last exception in the chain.
1:48154b2:      */
1:48154b2:     public SQLException getLastSQLException(SQLException sqle) {
1:48154b2:         SQLException current = sqle;
1:48154b2:         SQLException next = sqle.getNextException();
1:48154b2:         while (next != null) {
1:48154b2:             current = next;
1:48154b2:             next = next.getNextException();
1:48154b2:         }
1:48154b2:         return current;
1:48154b2:     }
1:48154b2: 
1:48154b2:     /**
1:0c4649d:      * Take the received Statement--on which a query has been
1:0c4649d:      * executed--and fetch all rows of all result sets (if any)
1:0c4649d:      * returned from execution.  The rows themselves are
1:0c4649d:      * discarded.  This is useful when we expect there to be
1:0c4649d:      * an error when processing the results but do not know
1:0c4649d:      * (or care) at what point the error occurs.
1:0c4649d:      *
1:0c4649d:      * @param st An already-executed statement from which
1:0c4649d:      *  we get the result set to process (if there is one).
1:0c4649d:      * @param haveRS Whether or not the the statement's
1:0c4649d:      *  first result is a result set (as opposed to an
1:0c4649d:      *  update count).
1:0c4649d:      */
1:0c4649d:     private static void fetchAndDiscardAllResults(Statement st,
1:0c4649d:         boolean haveRS) throws SQLException
1:0c4649d:     {
1:0c4649d:         ResultSet rs = null;
1:0c4649d:         while (haveRS || (st.getUpdateCount() != -1))
1:0c4649d:         {
1:0c4649d:             // If we have a result set, iterate through all
1:0c4649d:             // of the rows.
1:0c4649d:             if (haveRS)
1:0c4649d:                 JDBC.assertDrainResults(st.getResultSet(), -1);
1:0c4649d:             haveRS = st.getMoreResults();
1:c7b3589:         }
1:c7b3589:     }
1:0c4649d: 
1:7ebfefe:     /**
1:b2c1772:      * Assert that the two (2) passed-in SQLException's are equals and
1:b2c1772:      * not just '=='.
1:b2c1772:      *
1:b2c1772:      * @param se1 first SQLException to compare
1:b2c1772:      * @param se2 second SQLException to compare
1:b2c1772:      */
1:b2c1772:     public static void assertSQLExceptionEquals(SQLException se1,
1:b2c1772:                                                 SQLException se2) {
1:b2c1772:         // Ensure non-null SQLException's are being passed.
1:b2c1772:         assertNotNull(
1:b2c1772:             "Passed-in SQLException se1 cannot be null",
1:b2c1772:             se1);
1:b2c1772:         assertNotNull(
1:b2c1772:             "Passed-in SQLException se2 cannot be null",
1:b2c1772:             se2);
1:b2c1772: 
1:b2c1772:         // Now verify that the passed-in SQLException's are of the same type
1:b2c1772:         assertEquals("SQLException class types are different",
1:b2c1772:                      se1.getClass().getName(), se2.getClass().getName());
1:b2c1772: 
2:b2c1772:         // Here we check that the detailed message of both
1:b2c1772:         // SQLException's is the same
1:b2c1772:         assertEquals(
1:b2c1772:                 "Detailed messages of the SQLException's are different",
1:b2c1772:                  se1.getMessage(), se2.getMessage());
1:b2c1772: 
1:379e4cc:         // Check that getCause() returns the same value on the two exceptions.
1:379e4cc:         Throwable se1Cause = se1.getCause();
1:379e4cc:         Throwable se2Cause = se2.getCause();
1:379e4cc:         if (se1Cause == null) {
1:379e4cc:             assertNull(se2Cause);
1:379e4cc:         } else {
1:379e4cc:             assertThrowableEquals(se1Cause, se2Cause);
1:379e4cc:         }
1:b2c1772: 
1:379e4cc:         // Check that the two exceptions have the same next exception.
1:379e4cc:         if (se1.getNextException() == null) {
1:379e4cc:             assertNull(se2.getNextException());
1:379e4cc:         } else {
1:379e4cc:             assertSQLExceptionEquals(se1.getNextException(),
1:379e4cc:                                      se2.getNextException());
1:b2c1772:         }
1:b2c1772:     }
1:b2c1772: 
1:7ebfefe:     /**
1:24b23a8:      * Compares two JDBC types to see if they are equivalent.
1:24b23a8:      * DECIMAL and NUMERIC and DOUBLE and FLOAT are considered
1:24b23a8:      * equivalent.
1:24b23a8:      * @param expectedType Expected jdbctype from java.sql.Types
1:24b23a8:      * @param type         Actual type from metadata
1:24b23a8:      */
1:24b23a8:     public static void assertEquivalentDataType(int expectedType, int type)
1:b2c1772:     {
1:24b23a8:      if (expectedType == type)
1:e9f346c:          return;
1:24b23a8:      if (expectedType == java.sql.Types.DECIMAL && 
1:24b23a8:                  type == java.sql.Types.NUMERIC)
1:e9f346c:          return;
1:24b23a8:      if (expectedType == java.sql.Types.NUMERIC && 
1:24b23a8:              type == java.sql.Types.DECIMAL)
1:02f8e49:          return;
1:24b23a8:      if (expectedType == java.sql.Types.DOUBLE && 
1:24b23a8:                  type == java.sql.Types.FLOAT)
4:24b23a8:          return;
1:24b23a8:      if (expectedType == java.sql.Types.FLOAT && 
1:24b23a8:              type == java.sql.Types.DOUBLE)
1:24b23a8:      return;
1:24b23a8:      fail("types:" + expectedType + " and " + type + " are not equivalent");
1:c48e69a:      
1:b2c1772:     }
1:c48e69a:   
1:c48e69a:     /**
1:89c399d:      * Attempts to obtain the client-side transaction counter from the given
1:89c399d:      * connection, which is internal state information.
1:89c399d:      * <p>
1:89c399d:      * <em>NOTE:</em> Use with care, accesses internal state.
1:89c399d:      *
1:89c399d:      * @param conn the connection
1:89c399d:      * @return Internal client transaction id.
1:89c399d:      * @throws SQLException if the given connection is an embedded connection,
1:89c399d:      *      or if invoking the required method fails
1:89c399d:      **/
1:89c399d:     public static int getClientTransactionID(Connection conn)
1:89c399d:             throws SQLException {
1:89c399d:         try {
1:89c399d:             Method m = conn.getClass().getMethod(
1:89c399d:                     "getTransactionID", new Class[] {});
1:89c399d:             return ((Integer) m.invoke(conn, new Object[] {} )).intValue();
1:89c399d:         } catch (Exception e) {
1:89c399d:             SQLException se = new SQLException(e.getMessage());
1:89c399d:             se.initCause(e);
1:89c399d:             throw se;
1:b2c1772:         }
1:b2c1772:     }
1:24b23a8: 
1:7ebfefe:     /**
1:02f8e49:      * Return estimated row count for runtime statistics.  
1:02f8e49:      * Requires caller first turned on RuntimeStatistics, executed a query and closed the ResultSet.
1:02f8e49:      * 
1:02f8e49:      * For client calls we just return as we can't find out this information.
1:02f8e49:      * @param conn
1:02f8e49:      * @param expectedCount
1:02f8e49:      * @throws SQLException
1:02f8e49:      */
1:02f8e49:     public static void checkEstimatedRowCount(Connection conn, double expectedCount) throws SQLException {
1:1ae0d7d:         if (! (conn instanceof EmbedConnection))
1:1ae0d7d: 	    { return; }
1:02f8e49: 	
1:1ae0d7d:         EmbedConnection econn = (EmbedConnection) conn;
1:1ae0d7d:         LanguageConnectionContext   lcc = (LanguageConnectionContext) getLanguageConnectionContext( econn );
1:1ae0d7d:         RunTimeStatistics rts = lcc.getRunTimeStatisticsObject();
1:1ae0d7d:         assertNotNull(" RuntimeStatistics is null. Did you call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)?",rts);
1:1ae0d7d:         assertEquals((long) expectedCount, (long) rts.getEstimatedRowCount());
1:b2c1772: 	}
1:02f8e49: 
1:02f8e49:     /**
1:c48e69a:      * Check consistency of all tables
1:c48e69a:      * 
1:c48e69a:      * @param conn
1:c48e69a:      * @throws SQLException
1:c48e69a:      */
1:c48e69a:     protected void  checkAllConsistency(
1:c48e69a:             Connection  conn)
1:c48e69a:     throws SQLException
1:b2c1772:     {
1:c48e69a:         Statement s = createStatement();
1:c48e69a: 
1:c48e69a:         ResultSet rs = 
1:c48e69a:             s.executeQuery(
1:c48e69a:                     "select schemaname, tablename, SYSCS_UTIL.SYSCS_CHECK_TABLE(schemaname, tablename) " + 
1:c48e69a:             "from sys.systables a,  sys.sysschemas b where a.schemaid = b.schemaid");
1:c48e69a: 
1:c48e69a:         int table_count = 0;
1:c48e69a: 
1:c48e69a:         while (rs.next())
1:b2c1772:         {
1:c48e69a:             table_count++;
1:c48e69a: 
1:c48e69a:             if (rs.getInt(3) != 1)
1:b2c1772:             {
1:c48e69a:                 assertEquals("Bad return from consistency check of " +
1:c48e69a:                         rs.getString(1) + "." + rs.getString(2),1,rs.getInt(3));
1:c48e69a: 
1:b2c1772:             }
1:b2c1772:         }
1:c48e69a:         assertTrue("Something wrong with consistency check query, found only " +
1:c48e69a:                 table_count + " tables.",table_count >= 5);
1:c48e69a: 
1:c48e69a:         rs.close();
1:c48e69a:         s.close();
1:c48e69a: 
1:c48e69a:         conn.commit();
1:89c399d:     }
1:24b23a8: 
1:b4cda60:     protected static void dumpRs(ResultSet s, PrintStream out)
1:b4cda60:             throws SQLException
1:b4cda60:     {
1:b4cda60:         if (s == null) {
1:b4cda60:             out.println("<NULL>");
1:b4cda60:             return;
1:b4cda60:         }
1:b4cda60: 
1:b4cda60:         ResultSetMetaData rsmd = s.getMetaData();
1:b4cda60: 
1:b4cda60:         // Get the number of columns in the result set
1:b4cda60:         int numCols = rsmd.getColumnCount();
1:b4cda60: 
1:b4cda60:         if (numCols <= 0) {
1:b4cda60:             out.println("(no columns!)");
1:b4cda60:             return;
1:b4cda60:         }
1:b4cda60: 
1:b4cda60:         StringBuilder heading = new StringBuilder("\t ");
1:b4cda60:         StringBuilder underline = new StringBuilder("\t ");
1:b4cda60: 
1:b4cda60:         int len;
1:b4cda60:         // Display column headings
1:b4cda60:         for (int i=1; i<=numCols; i++) {
1:b4cda60:             if (i > 1) {
1:b4cda60:                 heading.append(",");
1:b4cda60:                 underline.append(" ");
1:b4cda60:             }
1:b4cda60: 
1:b4cda60:             len = heading.length();
1:b4cda60:             heading.append(rsmd.getColumnLabel(i));
1:b4cda60:             len = heading.length() - len;
1:b4cda60: 
1:b4cda60:             for (int j = len; j > 0; j--) {
1:b4cda60:                 underline.append("-");
1:b4cda60:             }
1:b4cda60:         }
1:b4cda60: 
1:b4cda60:         out.println(heading.toString());
1:b4cda60:         out.println(underline.toString());
1:b4cda60: 
1:b4cda60: 
1:b4cda60:         StringBuilder row = new StringBuilder();
1:b4cda60:         // Display data, fetching until end of the result set
1:b4cda60:         while (s.next()) {
1:b4cda60:             row.append("\t{");
1:b4cda60:             // Loop through each column, getting the
1:b4cda60:             // column data and displaying
1:b4cda60:             for (int i=1; i<=numCols; i++) {
1:b4cda60:                 if (i > 1) row.append(",");
1:b4cda60:                 row.append(s.getString(i));
1:b4cda60:             }
1:b4cda60: 
1:b4cda60:             row.append("}\n");
1:b4cda60:         }
1:b4cda60: 
1:b4cda60:         out.println(row.toString());
1:b4cda60:         s.close();
1:b4cda60:     }
1:b4cda60: 
1:4cc0287:     public static void dumpRs(ResultSet s) throws SQLException {
1:b4cda60:         dumpRs(s, System.out);
1:b4cda60:     }
1:070d37e: 
1:070d37e:     // helper methods moved from GeneratedColumnsHelper
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Run good DDL.
1:070d37e:      * @throws SQLException 
1:070d37e:      */
1:070d37e:     protected void    goodStatement( Connection conn, String command ) throws SQLException
1:070d37e:     {
1:070d37e:         PreparedStatement    ps = chattyPrepare( conn, command );
1:070d37e: 
1:070d37e:         ps.execute();
1:070d37e:         ps.close();
1:070d37e:     }
1:070d37e:     
1:070d37e:     /**
1:070d37e:      * Run a good update statement with an expected row count.
1:070d37e:      * @throws SQLException 
1:070d37e:      */
1:070d37e:     protected void    goodUpdate( Connection conn, String update, int expectedRowCount ) throws SQLException
1:070d37e:     {
1:070d37e:         PreparedStatement    ps = chattyPrepare( conn, update );
1:070d37e: 
1:070d37e:         int actualRowCount = ps.executeUpdate();
1:070d37e:         ps.close();
1:070d37e: 
1:070d37e:         println( "Expecting to touch " + expectedRowCount + " rows." );
1:070d37e:         assertEquals( expectedRowCount, actualRowCount );
1:070d37e:     }
1:070d37e:     
1:8c39c1c:     /**
1:8c39c1c:      * Assert that the statement returns the correct results.
1:8c39c1c:      */
1:8c39c1c:     protected void assertResults( Connection conn, String query, String[][] rows, boolean trimResults )
1:4cc0287:         throws SQLException
1:8c39c1c:     {
1:8c39c1c:         PreparedStatement   ps = chattyPrepare( conn, query );
1:8c39c1c:         ResultSet                   rs = ps.executeQuery();
1:8c39c1c: 
1:8c39c1c:         assertResults( rs, rows, trimResults );
1:8c39c1c: 
1:8c39c1c:         rs.close();
1:8c39c1c:         ps.close();
1:8c39c1c:     }
1:8c39c1c:         
1:8c39c1c:     /**
1:8c39c1c:      * Assert that the ResultSet returns the desired rows.
1:8c39c1c:      */
1:8c39c1c:     protected void assertResults( ResultSet rs, String[][] rows, boolean trimResults )
1:4cc0287:         throws SQLException
1:8c39c1c:     {
1:8c39c1c:         int     rowCount = rows.length;
1:8c39c1c: 
1:8c39c1c:         for ( int i = 0; i < rowCount; i++ )
1:8c39c1c:         {
1:8c39c1c:             String[]    row = rows[ i ];
1:8c39c1c:             int             columnCount = row.length;
1:8c39c1c: 
1:8c39c1c:             assertTrue( rs.next() );
1:8c39c1c: 
1:8c39c1c:             for ( int j = 0; j < columnCount; j++ )
1:8c39c1c:             {
1:8c39c1c:                 String  expectedValue =  row[ j ];
1:8c39c1c:                 //println( "(row, column ) ( " + i + ", " +  j + " ) should be " + expectedValue );
1:8c39c1c:                 String  actualValue = null;
1:8c39c1c:                 int         column = j+1;
1:8c39c1c: 
1:8c39c1c:                 actualValue = rs.getString( column );
1:8c39c1c:                 if ( rs.wasNull() ) { actualValue = null; }
1:8c39c1c: 
1:8c39c1c:                 if ( (actualValue != null) && trimResults ) { actualValue = actualValue.trim(); }
1:8c39c1c:                 
1:8c39c1c:                 assertEquals( (expectedValue == null), rs.wasNull() );
1:8c39c1c:                 
1:8c39c1c:                 if ( expectedValue == null )    { assertNull( actualValue ); }
1:8c39c1c:                 else { assertEquals(expectedValue, actualValue); }
1:8c39c1c:             }
1:8c39c1c:         }
1:8c39c1c: 
1:8c39c1c:         assertFalse( rs.next() );
1:8c39c1c:     }
1:8c39c1c: 
1:070d37e: 	protected	static	ResultSet	executeQuery( Statement stmt, String text )
1:070d37e: 		throws SQLException
1:070d37e: 	{
1:070d37e: 		println( "Executing '" + text + "'" );
1:070d37e: 
1:070d37e:         return stmt.executeQuery( text );
1:070d37e: 	}
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Prepare a statement and report its sql text.
1:070d37e:      */
1:070d37e:     protected PreparedStatement   chattyPrepare( Connection conn, String text )
1:070d37e:         throws SQLException
1:070d37e:     {
1:070d37e:         println( "Preparing statement:\n\t" + text );
1:070d37e:         
1:070d37e:         return conn.prepareStatement( text );
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Prepare a callable statement and report its sql text.
1:070d37e:      */
1:070d37e:     protected CallableStatement   chattyPrepareCall( Connection conn, String text )
1:070d37e:         throws SQLException
1:070d37e:     {
1:070d37e:         println( "Preparing callable statement:\n\t" + text );
1:070d37e:         
1:070d37e:         return conn.prepareCall( text );
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Assert that the statement text, when compiled, raises an exception
1:070d37e:      */
1:070d37e:     protected void    expectCompilationError( String sqlState, String query )
1:070d37e:     {
1:070d37e:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1:070d37e: 
1:070d37e:         assertCompileError( sqlState, query );
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Assert that the statement text, when compiled, raises an exception
1:070d37e:      */
1:070d37e:     protected void    expectCompilationError( Connection conn, String sqlState, String query )
1:070d37e:     {
1:070d37e:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1:070d37e: 
1:070d37e:         PreparedStatement ps = null;
1:070d37e: 
1:070d37e:         try {
1:070d37e:             ps = conn.prepareStatement( query );
1:070d37e:         } catch (SQLException se )
1:070d37e:         {
1:070d37e:             assertSQLState( sqlState, se );
1:070d37e: 
1:070d37e:             return;
1:070d37e:         }
1:070d37e: 
1:070d37e:         fail( "Expected SQL state: " + sqlState );
1:070d37e:     }
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Assert that the statement text, when executed, raises an error.
1:070d37e:      */
1:070d37e:     protected void    expectExecutionError( Connection conn, String sqlState, String query )
2:8c39c1c:         throws Exception
1:070d37e:     {
1:070d37e:         println( "\nExpecting " + sqlState + " when executing:\n\t"  );
1:070d37e:         PreparedStatement   ps = chattyPrepare( conn, query );
1:070d37e: 
1:070d37e:         assertStatementError( sqlState, ps );
1:070d37e:         ps.close();
1:070d37e:     }
1:070d37e:     
1:ffe3f66: 	/**
1:1ae0d7d: 	  * Gets the LanguageConnectionContext for this connection. You might think that
1:1ae0d7d:       * this method could take an EmbedConnection as its argument and return a
1:1ae0d7d:       * LanguageConnectionContext. That, however, makes the compatibility tests blow up.
1:1ae0d7d:       * With those stronger types, the test lookup machinery in junit.framework.TestSuite
1:1ae0d7d:       * can't resolve the signature of this private method. That is because the engine jar is
1:1ae0d7d:       * not on the client-only classpath used by the compatibility tests. Now you know.
1:1ae0d7d: 	  */
1:1ae0d7d: 	private static Object	getLanguageConnectionContext( Connection conn )
1:1ae0d7d: 	{
1:1ae0d7d:         final EmbedConnection   econn = (EmbedConnection) conn;
1:1ae0d7d:         return AccessController.doPrivileged
1:1ae0d7d:             (
1:1ae0d7d:              new PrivilegedAction<LanguageConnectionContext>()
1:1ae0d7d:              {
1:1ae0d7d:                  public LanguageConnectionContext run()
1:1ae0d7d:                  {
1:1ae0d7d:                      return econn.getLanguageConnection();
1:1ae0d7d:                  }
1:1ae0d7d:              }
1:1ae0d7d:              );
1:1ae0d7d: 	}
1:1ae0d7d: 
1:070d37e: 
1:37952cf: } // End class BaseJDBCTestCase
1:01217c2: 
1:01217c2: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * super.tearDown(). This cleans up and closes the connection
commit:1ae0d7d
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1:         if (! (conn instanceof EmbedConnection))
1: 	    { return; }
1:         EmbedConnection econn = (EmbedConnection) conn;
1:         LanguageConnectionContext   lcc = (LanguageConnectionContext) getLanguageConnectionContext( econn );
1:         RunTimeStatistics rts = lcc.getRunTimeStatisticsObject();
1:         assertNotNull(" RuntimeStatistics is null. Did you call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)?",rts);
1:         assertEquals((long) expectedCount, (long) rts.getEstimatedRowCount());
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  * Gets the LanguageConnectionContext for this connection. You might think that
1:       * this method could take an EmbedConnection as its argument and return a
1:       * LanguageConnectionContext. That, however, makes the compatibility tests blow up.
1:       * With those stronger types, the test lookup machinery in junit.framework.TestSuite
1:       * can't resolve the signature of this private method. That is because the engine jar is
1:       * not on the client-only classpath used by the compatibility tests. Now you know.
1: 	  */
1: 	private static Object	getLanguageConnectionContext( Connection conn )
1: 	{
1:         final EmbedConnection   econn = (EmbedConnection) conn;
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<LanguageConnectionContext>()
1:              {
1:                  public LanguageConnectionContext run()
1:                  {
1:                      return econn.getLanguageConnection();
1:                  }
1:              }
1:              );
1: 	}
1: 
commit:8c39c1c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assert that the statement returns the correct results.
1:      */
1:     protected void assertResults( Connection conn, String query, String[][] rows, boolean trimResults )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare( conn, query );
1:         ResultSet                   rs = ps.executeQuery();
1: 
1:         assertResults( rs, rows, trimResults );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1:         
1:     /**
1:      * Assert that the ResultSet returns the desired rows.
1:      */
1:     protected void assertResults( ResultSet rs, String[][] rows, boolean trimResults )
1:         throws Exception
1:     {
1:         int     rowCount = rows.length;
1: 
1:         for ( int i = 0; i < rowCount; i++ )
1:         {
1:             String[]    row = rows[ i ];
1:             int             columnCount = row.length;
1: 
1:             assertTrue( rs.next() );
1: 
1:             for ( int j = 0; j < columnCount; j++ )
1:             {
1:                 String  expectedValue =  row[ j ];
1:                 //println( "(row, column ) ( " + i + ", " +  j + " ) should be " + expectedValue );
1:                 String  actualValue = null;
1:                 int         column = j+1;
1: 
1:                 actualValue = rs.getString( column );
1:                 if ( rs.wasNull() ) { actualValue = null; }
1: 
1:                 if ( (actualValue != null) && trimResults ) { actualValue = actualValue.trim(); }
1:                 
1:                 assertEquals( (expectedValue == null), rs.wasNull() );
1:                 
1:                 if ( expectedValue == null )    { assertNull( actualValue ); }
1:                 else { assertEquals(expectedValue, actualValue); }
1:             }
1:         }
1: 
1:         assertFalse( rs.next() );
1:     }
1: 
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1: 
1:     // helper methods moved from GeneratedColumnsHelper
1: 
1:     /**
1:      * Run good DDL.
1:      * @throws SQLException 
1:      */
1:     protected void    goodStatement( Connection conn, String command ) throws SQLException
1:     {
1:         PreparedStatement    ps = chattyPrepare( conn, command );
1: 
1:         ps.execute();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Run a good update statement with an expected row count.
1:      * @throws SQLException 
1:      */
1:     protected void    goodUpdate( Connection conn, String update, int expectedRowCount ) throws SQLException
1:     {
1:         PreparedStatement    ps = chattyPrepare( conn, update );
1: 
1:         int actualRowCount = ps.executeUpdate();
1:         ps.close();
1: 
1:         println( "Expecting to touch " + expectedRowCount + " rows." );
1:         assertEquals( expectedRowCount, actualRowCount );
1:     }
1:     
1: 	protected	static	ResultSet	executeQuery( Statement stmt, String text )
1: 		throws SQLException
1: 	{
1: 		println( "Executing '" + text + "'" );
1: 
1:         return stmt.executeQuery( text );
1: 	}
1: 
1:     /**
1:      * Prepare a statement and report its sql text.
1:      */
1:     protected PreparedStatement   chattyPrepare( Connection conn, String text )
1:         throws SQLException
1:     {
1:         println( "Preparing statement:\n\t" + text );
1:         
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     /**
1:      * Prepare a callable statement and report its sql text.
1:      */
1:     protected CallableStatement   chattyPrepareCall( Connection conn, String text )
1:         throws SQLException
1:     {
1:         println( "Preparing callable statement:\n\t" + text );
1:         
1:         return conn.prepareCall( text );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when compiled, raises an exception
1:      */
1:     protected void    expectCompilationError( String sqlState, String query )
1:     {
1:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1: 
1:         assertCompileError( sqlState, query );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when compiled, raises an exception
1:      */
1:     protected void    expectCompilationError( Connection conn, String sqlState, String query )
1:     {
1:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1: 
1:         PreparedStatement ps = null;
1: 
1:         try {
1:             ps = conn.prepareStatement( query );
1:         } catch (SQLException se )
1:         {
1:             assertSQLState( sqlState, se );
1: 
1:             return;
1:         }
1: 
1:         fail( "Expected SQL state: " + sqlState );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when executed, raises an error.
1:      */
1:     protected void    expectExecutionError( Connection conn, String sqlState, String query )
0:         throws Exception
1:     {
1:         println( "\nExpecting " + sqlState + " when executing:\n\t"  );
1:         PreparedStatement   ps = chattyPrepare( conn, query );
1: 
1:         assertStatementError( sqlState, ps );
1:         ps.close();
1:     }
1:     
1: 
commit:e744e84
/////////////////////////////////////////////////////////////////////////
1:      * Assert that a warning is chained to the connection.
1:      *
1:      * @param conn  the connection
1:      * @param expected the expected SQLState of the warning
1:      */
1:     public static void assertWarning( Connection conn, String expected )
1:         throws SQLException
1:     {
1:         SQLWarning  firstWarning = conn.getWarnings();
1:         assertNotNull( firstWarning );
1: 
1:         for ( SQLWarning warning = firstWarning; warning != null; warning = warning.getNextWarning() )
1:         {
1:             if ( expected.equals( warning.getSQLState() ) ) { return; }
1:         }
1: 
1:         fail( "Expected to see a SQLWarning with the SQLState " + expected );
1:     }
1: 
1: 
1:     /**
commit:0828e2d
/////////////////////////////////////////////////////////////////////////
0:      * @param tc
commit:ccce12c
/////////////////////////////////////////////////////////////////////////
0:      * @param conn The Connection handle
1:      * @param callSQL The SQL to execute
commit:bb7eb4d
/////////////////////////////////////////////////////////////////////////
0:         if (HAVE_DRIVER) {            
0:             if (!CONFIG.isSingleLegXA()) {
0:                 con = DriverManager.getConnection(
0:                         CONFIG.getJDBCUrl() + ";create=true",
0:                         CONFIG.getUserName(),
0:                         CONFIG.getUserPassword());
1:             }
0:             else {
0:                 con = getXADataSource().getXAConnection (CONFIG.getUserName(),
0:                             CONFIG.getUserPassword()).getConnection();                
1:             }
commit:f4e0323
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.DataSource;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a2ecbd3
/////////////////////////////////////////////////////////////////////////
1:      * automatically closed on tearDown, the test fixture must
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assert that that a commit fails with the given error
1:      * @param sqlState state
1:      * @param c        the connection
1:      */
1:     public static void assertCommitError(String sqlState, Connection c) {
1:         try {
1:             c.commit();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState(sqlState, e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public static void dumpRs(ResultSet s) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         throws SQLException
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected static void dumpRs(ResultSet s, PrintStream out)
1:             throws SQLException
1:     {
1:         if (s == null) {
1:             out.println("<NULL>");
1:             return;
1:         }
1: 
1:         ResultSetMetaData rsmd = s.getMetaData();
1: 
1:         // Get the number of columns in the result set
1:         int numCols = rsmd.getColumnCount();
1: 
1:         if (numCols <= 0) {
1:             out.println("(no columns!)");
1:             return;
1:         }
1: 
1:         StringBuilder heading = new StringBuilder("\t ");
1:         StringBuilder underline = new StringBuilder("\t ");
1: 
1:         int len;
1:         // Display column headings
1:         for (int i=1; i<=numCols; i++) {
1:             if (i > 1) {
1:                 heading.append(",");
1:                 underline.append(" ");
1:             }
1: 
1:             len = heading.length();
1:             heading.append(rsmd.getColumnLabel(i));
1:             len = heading.length() - len;
1: 
1:             for (int j = len; j > 0; j--) {
1:                 underline.append("-");
1:             }
1:         }
1: 
1:         out.println(heading.toString());
1:         out.println(underline.toString());
1: 
1: 
1:         StringBuilder row = new StringBuilder();
1:         // Display data, fetching until end of the result set
1:         while (s.next()) {
1:             row.append("\t{");
1:             // Loop through each column, getting the
1:             // column data and displaying
1:             for (int i=1; i<=numCols; i++) {
1:                 if (i > 1) row.append(",");
1:                 row.append(s.getString(i));
1:             }
1: 
1:             row.append("}\n");
1:         }
1: 
1:         out.println(row.toString());
1:         s.close();
1:     }
1: 
0:     protected static void dumpRs(ResultSet s) throws SQLException {
1:         dumpRs(s, System.out);
1:     }
commit:64a963d
/////////////////////////////////////////////////////////////////////////
1:      * @param tc test configuration to use
commit:616c0d0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Open a connection to the default database for the given configuration.
1:      * If the database does not exist, it will be created.  A default username
1:      * and password will be used for the connection.
1:      *
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
0:      * @param configuration
1:      * @return connection to default database for the configuration
1:      * @see TestConfiguration#openDefaultConnection()
1:      * @see BaseJDBCTestCase#initializeConnection(Connection)
1:      */
1:     public Connection openDefaultConnection(TestConfiguration tc)
1:         throws SQLException {
1:         Connection conn =  tc.openDefaultConnection();
1:         initializeConnection(conn);
1:         return conn;
1:     }
1: 
commit:00c7a20
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Assert that the query fails (either in execution, or retrieval of
1:      * results--doesn't matter) and throws a SQLException with the expected
1:      * state and error code
1:      *
1:      * Parameters must have been already bound, if any.
1:      *
1:      * @param sqlState expected sql state.
1:      * @param ps PreparedStatement query object to execute.
1:      */
1:     public static void assertPreparedStatementError(String sqlState,
1:                                                     PreparedStatement ps) {
1:         try {
1:             boolean haveRS = ps.execute();
1:             fetchAndDiscardAllResults(ps, haveRS);
1:             fail("Expected error '" + sqlState +
1:                 "' but no error was thrown.");
1:         } catch (SQLException se) {
1:             assertSQLState(sqlState, se);
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9850fb9
/////////////////////////////////////////////////////////////////////////
1:      * Clear the contents of the statement cache. Useful if a test case
1:      * needs to make sure that a statement is actually compiled and not
1:      * just fetched from the statement cache.
1:      *
1:      * @throws SQLException if a database error happens
1:      */
1:     protected final void emptyStatementCache() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CALL SYSCS_UTIL.SYSCS_EMPTY_STATEMENT_CACHE()");
1:         closeStatement(s);
1:     }
1: 
1:     /**
commit:2510115
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
/////////////////////////////////////////////////////////////////////////
1:     private List<Statement> statements;
1:     private List<Connection> connections;
/////////////////////////////////////////////////////////////////////////
1:             statements = new ArrayList<Statement>();
/////////////////////////////////////////////////////////////////////////
1:             connections = new ArrayList<Connection>();
/////////////////////////////////////////////////////////////////////////
1:             for (Statement s : statements) {
1:             for (Connection c : connections) {
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> statesBag = null;
1:             statesBag = new ArrayList<String>(Arrays.asList(sqlStates));
commit:b54db0f
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Assert that the error code is as expected.
1:      *
1:      * @param expected the expected error code
1:      * @param exception the exception to check
1:      * @throws AssertionFailedError if the error code is wrong
1:      */
1:     public static void assertErrorCode(int expected, SQLException exception) {
1:         assertNotNull("Exception should not be null", exception);
1:         int actual = exception.getErrorCode();
1:         if (actual != expected) {
1:             fail("Expected error code " + expected + ", got " + actual,
1:                  exception);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             assertErrorCode(errorCode, se);
commit:148a1f0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.TestNullOutputStream;
/////////////////////////////////////////////////////////////////////////
1:         OutputStream sink = new TestNullOutputStream();
commit:ade6fcf
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Run the bare test, including {@code setUp()} and {@code tearDown()}.
1:      * </p>
1:      *
1:      * <p>
1:      * Subclasses that want to override {@code runBare()}, should override
1:      * this method instead. Overriding this method shouldn't be necessary
1:      * except in very special cases. Override {@code setUp()} and
1:      * {@code tearDown()} instead if possible.
1:      * </p>
1:      *
1:      * <p>
1:      * The overridden method would typically want to call
1:      * {@code super.runBareOverridable()} to actually run the test.
1:      * </p>
1:      */
1:     protected void runBareOverridable() throws Throwable {
1:         super.runBare();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Run the bare test, including {@code setUp()} and {@code tearDown()},
1:      * and finally verify that the cached connection has been released.
1:      * </p>
1:      *
1:      * <p>
1:      * This method is final to prevent subclasses from accidentally bypassing
1:      * the assert that checks if the cached connection has been released.
1:      * Subclasses that want to override the method, should override
1:      * {@link #runBareOverridable()} instead.
1:      * </p>
1:      */
1:     public final void runBare() throws Throwable {
1:         runBareOverridable();
1:         // It's quite common to forget to call super.tearDown() when
1:         // overriding tearDown() in sub-classes.
1:         assertNull(
1:             "Connection should be null by now. " +
1:             "Missing call to super.tearDown()?", conn);
1:     }
1: 
commit:7840c51
/////////////////////////////////////////////////////////////////////////
1:      * Close a statement and remove it from the list of statements to close
1:      * at tearDown(). Useful for test cases that create a large number of
1:      * statements that are only used for a short time, as the memory footprint
1:      * may become big if all the statements are held until tearDown().
1:      *
1:      * @param s the statement to close and forget
1:      * @throws SQLException if closing the statement fails
1:      */
1:     public void closeStatement(Statement s) throws SQLException {
1:         s.close();
1:         if (statements != null) {
1:             statements.remove(s);
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:         String val = rs.getString(1);
1: 
1:         rs.close();
1:         closeStatement(ps);
1: 
1:         return val;
commit:379e4cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             e.initCause(exception);
/////////////////////////////////////////////////////////////////////////
1:         // Check that getCause() returns the same value on the two exceptions.
1:         Throwable se1Cause = se1.getCause();
1:         Throwable se2Cause = se2.getCause();
1:         if (se1Cause == null) {
1:             assertNull(se2Cause);
1:         } else {
1:             assertThrowableEquals(se1Cause, se2Cause);
1:         }
1:         // Check that the two exceptions have the same next exception.
1:         if (se1.getNextException() == null) {
1:             assertNull(se2.getNextException());
1:         } else {
1:             assertSQLExceptionEquals(se1.getNextException(),
1:                                      se2.getNextException());
commit:d13a3ac
/////////////////////////////////////////////////////////////////////////
commit:96889c1
/////////////////////////////////////////////////////////////////////////
0:             if (usingDerbyNet())
commit:b2c1772
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assert that the two (2) passed-in SQLException's are equals and
1:      * not just '=='.
1:      *
1:      * @param se1 first SQLException to compare
1:      * @param se2 second SQLException to compare
1:      */
1:     public static void assertSQLExceptionEquals(SQLException se1,
1:                                                 SQLException se2) {
1:         // Ensure non-null SQLException's are being passed.
1:         assertNotNull(
1:             "Passed-in SQLException se1 cannot be null",
1:             se1);
1:         assertNotNull(
1:             "Passed-in SQLException se2 cannot be null",
1:             se2);
1: 
1:         // Now verify that the passed-in SQLException's are of the same type
1:         assertEquals("SQLException class types are different",
1:                      se1.getClass().getName(), se2.getClass().getName());
1: 
1:         // Here we check that the detailed message of both
1:         // SQLException's is the same
1:         assertEquals(
1:                 "Detailed messages of the SQLException's are different",
1:                  se1.getMessage(), se2.getMessage());
1: 
0:         // Now if we're running in a java runtime that supports chained
0:         // exception, then let's compare these 2 SQLException's and
0:         // whatever chained SQLException there can be through the beauty
0:         // of recursion
0:         if (JVMInfo.JDK_ID >= JVMInfo.J2SE_14)
1:         {
1:             // Here we check that the detailed message of both
0:             // SQLException's throwable "cause" is the same.
0:             // getCause() was introduced as part of Java 4.
1:             // Save the SQLException
0:             Throwable se1Cause = null, se2Cause = null;
0:             Method m = null;
0:             try
1:             {
0:                 m = Throwable.class.getMethod("getCause", new Class[] {});
0:                 se1Cause = (Throwable) m.invoke(se1, new Object[] {});
1:             }
0:             catch (Throwable t)
1:             {
0:                 // Throwable.getCause() should have succeeded
0:                 fail("Unexpected error: " + t.getMessage());
1:             }
0:             if (se1Cause != (Throwable) null)
1:             {
0:                 try
1:                 {
0:                     se2Cause = (Throwable) m.invoke(se2, new Object[] {});
1:                 }
0:                 catch (Throwable t)
1:                 {
0:                     // Throwable.getCause() should have succeeded
0:                     fail("Unexpected error: " + t.getMessage());
1:                 }
0:                 assertThrowableEquals(se1Cause, se2Cause);
1:             }
0:             else // se2.getCause() should not return any Cause then
0:                 assertNull(se2Cause);
1: 
0:             if (se1.getNextException() != null)
1:             {
0:                 assertSQLExceptionEquals(se1.getNextException(),
0:                                          se2.getNextException());
1:             }
1:         }
1:     }
1: 
commit:58588dd
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 Method m = Throwable.class.getMethod(
0:                     "initCause", new Class[] { Throwable.class } );
0:                 m.invoke(e, new Object[] { exception });
0:             } catch (Throwable t) {
0:                 // Some VMs don't support initCause(). It is OK if they fail.
1:             }
commit:a997e8f
/////////////////////////////////////////////////////////////////////////
1:      * <LI> getDefaultConnection(String connAttrs)
0:      * <LI> getConnection(String databaseName, String connAttrs)
/////////////////////////////////////////////////////////////////////////
0:      * Get a connection to the default database using the  specified connection
0:      * attributes.
1:      *  
0:      * @param connAttrs connection attributes
1:      * @return connection to default database.
1:      * @throws SQLException
1:      */
0:     public Connection getDefaultConnection(String connAttrs)
1:     	throws SQLException {
0:     	Connection conn =  getTestConfiguration().
0: 								getDefaultConnection(connAttrs);
1:     	initializeConnection(conn);
1:     	return conn;
1:     }
1: 
1:     /**
0:      * Get a connection to a database using the specified connection 
0:      * attributes.
1:      *  
0:      * @param databaseName database to connect to
0:      * @param connAttrs connection attributes
0:      * @return connection to database
1:      * @throws SQLException
1:      */
0:     public Connection getConnection(String databaseName, String connAttrs) 
1:     	throws SQLException
1: 	{
0:     	Connection conn = getTestConfiguration().getConnection(databaseName, 
0:     															connAttrs);
1:     	initializeConnection(conn);
1:     	return conn;       
1: 	}    
1:     
1:     /**
commit:4183d60
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Assert that SQLState is as expected.
0:      * The expected SQLState is truncated to five characters if required.
1:      *
1:      * @param expected the expected SQLState.
1:      * @param exception the exception to check the SQLState of.
1:      */
1:     public static void assertSQLState(String expected, SQLException exception) {
1:         assertSQLState("Unexpected SQL state.", expected, exception);
1:     }
commit:fff1a02
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if reading or closing a stream fails
1:      * @throws SQLException if obtaining a stream fails
1:     public static void assertEquals(Blob b1, Blob b2)
1:             throws IOException, SQLException {
1:         assertEquals("Blobs have different lengths",
1:                      b1.length(), b2.length());
1:         InputStream is1 = b1.getBinaryStream();
1:         InputStream is2 = b2.getBinaryStream();
1:         if (is1 == null || is2 == null) {
1:             assertNull("Blob b2 has null-stream, blob b1 doesn't", is1);
1:             assertNull("Blob b1 has null-stream, blob b2 doesn't", is2);
1:             return;
1:         long index = 1;
1:         int by1 = is1.read();
1:         int by2 = is2.read();
1:         do {
1:             // Avoid string concatenation for every byte in the stream.
1:             if (by1 != by2) {
1:             }
1:             index++;
1:             by1 = is1.read();
1:             by2 = is2.read();
1:         } while ( by1 != -1 || by2 != -1);
1:         is1.close();
1:         is2.close();
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if reading or closing a stream fails
1:      * @throws SQLException if obtaining a stream fails
1:     public static void assertEquals(Clob c1, Clob c2)
1:             throws IOException, SQLException {
1:         assertEquals("Clobs have different lengths",
1:                      c1.length(), c2.length());
1:         Reader r1 = c1.getCharacterStream();
1:         Reader r2 = c2.getCharacterStream();
0:         if (r1 == null || r2 == null) {
0:             assertNull("Clob c2 has null-stream, clob c1 doesn't", r1);
0:             assertNull("Clob c1 has null-stream, clob c2 doesn't", r2);
1:             return;
1:         long index = 1;
1:         int ch1 = r1.read();
1:         int ch2 = r2.read();
1:         do {
1:             // Avoid string concatenation for every char in the stream.
1:             if (ch1 != ch2) {
1:             }
1:             index++;
1:             ch1 = r1.read();
1:             ch2 = r2.read();
1:         } while (ch1 != -1 || ch2 != -1);
1:         r1.close();
1:         r2.close();
commit:e9f346c
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1:      * Assert equality between two <code>Blob</code> objects.
1:      * If both input references are <code>null</code>, they are considered
1:      * equal. The same is true if both blobs have <code>null</code>-streams.
1:      *
1:      * @param b1 first <code>Blob</code>.
1:      * @param b2 second <code>Blob</code>.
1:      * @throws AssertionFailedError if blobs are not equal.
1:      */
0:     public static void assertEquals(Blob b1, Blob b2) {
1:         if (b1 == null || b2 == null) {
1:             assertNull("Blob b2 is null, b1 is not", b1);
1:             assertNull("Blob b1 is null, b2 is not", b2);
1:             return;
1:         }
0:         InputStream is1 = null, is2 = null;
1:         try {
0:             assertEquals("Blobs have different lengths",
0:                          b1.length(), b2.length());
0:             is1 = b1.getBinaryStream();
0:             is2 = b2.getBinaryStream();
0:             if (is1 == null || is2 == null) {
0:                 assertNull("Blob b2 has null-stream, blob b1 doesn't", is1);
0:                 assertNull("Blob b1 has null-stream, blob b2 doesn't", is2);
1:                 return;
1:             }
0:         } catch (SQLException sqle) {
0:             fail("SQLException while asserting Blob equality: " +
0:                     sqle.getMessage());
1:         }
1:         try {
0:             long index = 1;
0:             int by1 = is1.read();
0:             int by2 = is2.read();
1:             do {
1:                 assertEquals("Blobs differ at index " + index,
1:                         by1, by2);
0:                 index++;
0:                 by1 = is1.read();
0:                 by2 = is2.read();
0:             } while ( by1 != -1 || by2 != -1);
0:         } catch (IOException ioe) {
0:             fail("IOException while asserting Blob equality: " +
0:                     ioe.getMessage());
1:         }
1:     }
1: 
1:     /**
1:      * Assert equality between two <code>Clob</code> objects.
1:      * If both input references are <code>null</code>, they are considered
1:      * equal. The same is true if both clobs have <code>null</code>-streams.
1:      *
1:      * @param c1 first <code>Clob</code>.
1:      * @param c2 second <code>Clob</code>.
1:      * @throws AssertionFailedError if clobs are not equal.
1:      */
0:     public static void assertEquals(Clob c1, Clob c2) {
1:         if (c1 == null || c2 == null) {
1:             assertNull("Clob c2 is null, c1 is not", c1);
1:             assertNull("Clob c1 is null, c2 is not", c2);
1:             return;
1:         }
0:         Reader r1 = null, r2 = null;
1:         try {
0:             assertEquals("Clobs have different lengths",
0:                          c1.length(), c2.length());
0:             r1 = c1.getCharacterStream();
0:             r2 = c2.getCharacterStream();
0:             if (r1 == null || r2 == null) {
0:                 assertNull("Clob c2 has null-stream, clob c1 doesn't", r1);
0:                 assertNull("Clob c1 has null-stream, clob c2 doesn't", r2);
1:                 return;
1:             }
0:         } catch (SQLException sqle) {
0:             fail("SQLException while asserting Clob equality: " +
0:                     sqle.getMessage());
1:         }
1:         try {
0:             long index = 1;
0:             int ch1 = r1.read();
0:             int ch2 = r2.read();
1:             do {
1:                 assertEquals("Clobs differ at index " + index,
1:                         ch1, ch2);
0:                 index++;
0:                 ch1 = r1.read();
0:                 ch2 = r2.read();
0:             } while (ch1 != -1 || ch2 != -1);
0:         } catch (IOException ioe) {
0:             fail("IOException while asserting Clob equality: " +
0:                     ioe.getMessage());
1:         }
1:     }
1: 
1:     /**
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 con = TestDataSourceFactory.getXADataSource().getXAConnection (CONFIG.getUserName(),
0:             con = TestDataSourceFactory.getDataSource().getConnection();
1:      * Tell if the client is embedded.
1:      *
1:      * @return <code>true</code> if using the embedded client
1:      *         <code>false</code> otherwise.
1:      */
1:      public static boolean usingEmbedded() {
0:          return (CONFIG.getJDBCClient() == JDBCClient.EMBEDDED);
1:      }
1:     
1:     /**
commit:ed0e114
/////////////////////////////////////////////////////////////////////////
0:      * Assert that SQLState is as expected.
0:      * The expected SQLState is truncated to five characters if required.
1:      *
1:      * @param message message to print on failure.
1:      * @param expected the expected SQLState.
1:      * @param exception the exception to check the SQLState of.
1:      *
0:      * @throws IllegalArgumentException if exception is <code>null</code>.
1:      */
1:     public static void assertSQLState(String message, 
1:                                       String expected, 
1:                                       SQLException exception) {
1:         // Make sure exception is not null. We want to separate between a
1:         // null-exception object, and a null-SQLState.
0:         if (exception == null) {
0:             throw new IllegalArgumentException("Exception cannot be null " +
0:                                                "when asserting SQLState");
1:         }
0:         // Make sure the expected SQLState is 5 characters long, if not null.
0:         // If it is too short, we let it be.
0:         if (expected != null && expected.length() > 5) {
0:             expected = expected.substring(0, 5);
1:         }
0:         assertEquals(message, expected, exception.getSQLState());
1:     }
1:     
1:     /**
commit:28162f6
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.ConnectionPoolDataSource;
0: import javax.sql.XADataSource;
/////////////////////////////////////////////////////////////////////////
0:             con = getDataSource().getConnection();
1:     /**
0:      * Generate properties which can be set on a
0:      * <code>DataSource</code> in order to connect to the default
0:      * database.
1:      *
0:      * @return a <code>Properties</code> object containing server
0:      * name, port number, database name and other attributes needed to
0:      * connect to the default database
1:      */
0:     private static Properties getDefaultDataSourceProperties() {
0:         Properties attrs = new Properties();
0:         if (!usingEmbedded()) {
0:             attrs.setProperty("serverName", CONFIG.getHostName());
0:             attrs.setProperty("portNumber", Integer.toString(CONFIG.getPort()));
1:         }
0:         attrs.setProperty("databaseName", CONFIG.getDatabaseName());
0:         attrs.setProperty("connectionAttributes", "create=true");
0:         return attrs;
1:     }
1: 
1:     /**
0:      * Return a <code>DataSource</code> for the appropriate framework.
1:      *
0:      * @param attrs properties for the data source
0:      * @return a <code>DataSource</code> object
0:      * @see TestUtil#getDataSource(Properties)
1:      */
0:     public static DataSource getDataSource(Properties attrs) {
0:         return TestUtil.getDataSource(attrs);
1:     }
1: 
1:     /**
0:      * Return a <code>DataSource</code> which can establish a
0:      * connection to the default database.
1:      *
0:      * @return a <code>DataSource</code> object
1:      */
0:     public static DataSource getDataSource() {
0:         return getDataSource(getDefaultDataSourceProperties());
1:     }
1: 
1:     /**
0:      * Return a <code>ConnectionPoolDataSource</code> for the
0:      * appropriate framework.
1:      *
0:      * @param attrs properties for the data source
0:      * @return a <code>ConnectionPoolDataSource</code> object
0:      * @see TestUtil#getConnectionPoolDataSource(Properties)
1:      */
0:     public static ConnectionPoolDataSource
0:         getConnectionPoolDataSource(Properties attrs)
1:     {
0:         return TestUtil.getConnectionPoolDataSource(attrs);
1:     }
1: 
1:     /**
0:      * Return a <code>ConnectionPoolDataSource</code> which can
0:      * establish a connection to the default database.
1:      *
0:      * @return a <code>ConnectionPoolDataSource</code> object
1:      */
0:     public static ConnectionPoolDataSource getConnectionPoolDataSource() {
0:         return getConnectionPoolDataSource(getDefaultDataSourceProperties());
1:     }
1: 
1:     /**
0:      * Return an <code>XADataSource</code> for the appropriate
0:      * framework.
1:      *
0:      * @param attrs properties for the data source
0:      * @return an <code>XADataSource</code> object
0:      * @see TestUtil#getXADataSource(Properties)
1:      */
0:     public static XADataSource getXADataSource(Properties attrs) {
0:         return TestUtil.getXADataSource(attrs);
1:     }
1: 
1:     /**
0:      * Return an <code>XADataSource</code> which can establish a
0:      * connection to the default database.
1:      *
0:      * @return an <code>XADataSource</code> object
1:      */
0:     public static XADataSource getXADataSource() {
0:         return getXADataSource(getDefaultDataSourceProperties());
1:     }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c61e6e8
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Maintain a list of connection objects that
1:      * were returned by utility methods and close
1:      * them at teardown.
1:      */
0:     private List connections;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Add connection to the list. We will close at tearDown
1:      * @param c
1:      */
1:     private void addConnection(Connection c)
1:     {
1:         if (connections == null)
0:             connections = new ArrayList();
1:         connections.add(c);     
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (connections != null) {
0:             for (Iterator i = connections.iterator(); i.hasNext(); )
1:             {
0:                 Connection c = (Connection) i.next();
1:                 JDBC.cleanup(c);
1:             }
1:             // Allow gc'ing of all those connections.
1:             connections = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         addConnection(conn);
/////////////////////////////////////////////////////////////////////////
1:         addConnection(conn);
/////////////////////////////////////////////////////////////////////////
1:         addConnection(conn);
/////////////////////////////////////////////////////////////////////////
1:         addConnection(conn);
commit:89c399d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Attempts to obtain the client-side transaction counter from the given
1:      * connection, which is internal state information.
1:      * <p>
1:      * <em>NOTE:</em> Use with care, accesses internal state.
1:      *
1:      * @param conn the connection
1:      * @return Internal client transaction id.
1:      * @throws SQLException if the given connection is an embedded connection,
1:      *      or if invoking the required method fails
1:      **/
1:     public static int getClientTransactionID(Connection conn)
1:             throws SQLException {
1:         try {
1:             Method m = conn.getClass().getMethod(
1:                     "getTransactionID", new Class[] {});
1:             return ((Integer) m.invoke(conn, new Object[] {} )).intValue();
1:         } catch (Exception e) {
1:             SQLException se = new SQLException(e.getMessage());
1:             se.initCause(e);
1:             throw se;
1:         }
1:     }
commit:02f8e49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: import org.apache.derby.impl.jdbc.EmbedConnection;
/////////////////////////////////////////////////////////////////////////
1:      * Return estimated row count for runtime statistics.  
1:      * Requires caller first turned on RuntimeStatistics, executed a query and closed the ResultSet.
1:      * 
1:      * For client calls we just return as we can't find out this information.
1:      * @param conn
1:      * @param expectedCount
1:      * @throws SQLException
1:      */
1:     public static void checkEstimatedRowCount(Connection conn, double expectedCount) throws SQLException {
0: 	if (! (conn instanceof EmbedConnection))
1: 	    return;
1: 	
0: 	EmbedConnection econn = (EmbedConnection) conn;
0: 	RunTimeStatistics rts = econn.getLanguageConnection().getRunTimeStatisticsObject();
0: 	assertNotNull(" RuntimeStatistics is null. Did you call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)?",rts);
0: 	assertEquals((long) expectedCount, (long) rts.getEstimatedRowCount());
1: 	}
1: 
1:     /**
commit:c48e69a
/////////////////////////////////////////////////////////////////////////
1:   
1: 
1:     /**
1:      * Check consistency of all tables
1:      * 
1:      * @param conn
1:      * @throws SQLException
1:      */
1:     protected void  checkAllConsistency(
1:             Connection  conn)
1:     throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         ResultSet rs = 
1:             s.executeQuery(
1:                     "select schemaname, tablename, SYSCS_UTIL.SYSCS_CHECK_TABLE(schemaname, tablename) " + 
1:             "from sys.systables a,  sys.sysschemas b where a.schemaid = b.schemaid");
1: 
1:         int table_count = 0;
1: 
1:         while (rs.next())
1:         {
1:             table_count++;
1: 
1:             if (rs.getInt(3) != 1)
1:             {
1:                 assertEquals("Bad return from consistency check of " +
1:                         rs.getString(1) + "." + rs.getString(2),1,rs.getInt(3));
1: 
1:             }
1:         }
1:         assertTrue("Something wrong with consistency check query, found only " +
1:                 table_count + " tables.",table_count >= 5);
1: 
1:         rs.close();
1:         s.close();
1: 
1:         conn.commit();
1:     }
commit:c58f84b
/////////////////////////////////////////////////////////////////////////
1:      * Utility method to set auto commit behaviour.
1:      * @param commit false if autoCommit should be disabled.
1:      */
1:     public void setAutoCommit(boolean commit) throws SQLException {
1:     	getConnection().setAutoCommit(commit);
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     
commit:a977a87
/////////////////////////////////////////////////////////////////////////
1:      * @param sqlStates  expected sql states.
commit:86be795
/////////////////////////////////////////////////////////////////////////
1:      * and throws a SQLException with the expected states.
1:      *
1:      * If there are extra chained SQLExceptions that are 
1:      * not in sqlStates, this method will not fail.
0:      * @param sqlStates[]  expected sql state.
1:     public static void assertStatementError(String[] sqlStates,
1:             String errorMsg = "Expected error(s) '" ;
1:             for (int i = 0; i < sqlStates.length;i++)
1:                 errorMsg += " " + sqlStates[i];
1:             errorMsg += "' but no error was thrown.";            
1:             fail(errorMsg);            
1:             int count = 0;
0:             do {
1:                 assertSQLState(sqlStates[count], se);
1:                 count++;
1:                 se = se.getNextException();
1:             } while (se != null && count < sqlStates.length);
1:             // We must have at least as many exceptions as 
1:             // we expected.
1:             assertEquals("Got " +
1:                     count + " exceptions. Expected at least"+
1:                     sqlStates.length,count,sqlStates.length);
1:             
1: 
1:     /**
1:      * Assert that the query fails with a single error
1:      *  
1:      * @param sqlState  Expected SQLState of exception
1:      * @param st         
1:      * @param query
1:      * @see #assertStatementError(String[], Statement, String)
1:      */
1:     public static void assertStatementError(String sqlState, Statement st, String query) {
1:         assertStatementError(new String[] {sqlState},st,query);
1:     }
1:         
1:    
1:    
commit:392f303
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Utility method to create a Statement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
1:      * @throws SQLException
1:      */
1:     public Statement createStatement(int resultSetType,
1:             			int resultSetConcurrency,
1: 	    			int resultSetHoldability) throws SQLException
1:     {
1:         return getConnection().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Utility method to create a CallableStatement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection().prepareCall(sql, resultSetType, resultSetConcurrency)
1:      * @throws SQLException
1:      */
1:     public CallableStatement prepareCall(String sql,
1: 					int resultSetType, 
1: 					int resultSetConcurrency) throws SQLException
1:     {
0:         return getConnection().prepareCall(sql, resultSetType, resultSetConcurrency);
1:     }
1: 
1:     /**
1:      * Utility method to create a CallableStatement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection().prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
1:      * @throws SQLException
1:      */
1:     public CallableStatement prepareCall(String sql,
1:                                         int resultSetType,
1:                                         int resultSetConcurrency,
1: 					 int resultSetHoldability) throws SQLException
1:     {
0:         return getConnection().prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:     }
commit:e162ad6
/////////////////////////////////////////////////////////////////////////
1:      * @param sqle <code>SQLException</code>
commit:48154b2
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static void assertErrorCode(String message, int expected, SQLException exception) {
0:        while (exception != null)
1:        {
1:            try {
0:                assertEquals(message, expected,exception.getErrorCode());
1:            } catch (AssertionFailedError e) {
0:                // check and see if our error code is in a chained exception
1:                exception = exception.getNextException();               
1:            }
1:        }
1:     }
1:     
0:     public static void assertErrorCode(int expected, SQLException exception)
1:     {
0:        assertErrorCode("Unexpected Error Code",expected, exception);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assert that the query fails (either in compilation,
1:      * execution, or retrieval of results--doesn't matter)
1:      * and throws a SQLException with the expected state
1:      * and error code
1:      *
1:      * Assumption is that 'query' does *not* have parameters
1:      * that need binding and thus can be executed using a
1:      * simple Statement.execute() call.
1:      * 
1:      * @param sqlState expected sql state.
1:      * @param errorCode expected error code.
1:      * @param st Statement object on which to execute.
1:      * @param query the query to compile and execute.
1:      */
1:     public static void assertStatementError(String sqlState, int errorCode, Statement st, String query) {
1:         try {
1:             boolean haveRS = st.execute(query);
1:             fetchAndDiscardAllResults(st, haveRS);
1:             fail("Expected error '" + sqlState +
1:                 "' but no error was thrown.");
1:         } catch (SQLException se) {
1:             assertSQLState(sqlState, se);
0:             assertEquals(errorCode,se.getErrorCode());
1:         }
1:         
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Get the last SQLException in chain.
0:      * @param a <code>SQLException</code>
1:      * @return the last exception in the chain.
1:      */
1:     public SQLException getLastSQLException(SQLException sqle) {
1:         SQLException current = sqle;
1:         SQLException next = sqle.getNextException();
1:         while (next != null) {
1:             current = next;
1:             next = next.getNextException();
1:         }
1:         return current;
1:     }
1: 
1:     /**
commit:fdb0ac3
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Executes the Callable statement that is expected to fail and verifies
1:      * that it throws the expected SQL exception.
0:      * @param conn The Connection handle
0:      * @param sql The SQL to execute
1:      * @param expectedSE The expected SQL exception
1:      * @throws SQLException
1:      */
0:     public static void assertCallError(String expectedSE, Connection conn, String callSQL)
1:     throws SQLException
1:     {
1:         try {
0:             CallableStatement cs = conn.prepareCall(callSQL);
1:             cs.execute();
1:             fail("FAIL - SQL expected to throw exception");
1:         } catch (SQLException se) {
0:             assertSQLState(expectedSE, se.getSQLState(), se);
1:         }
1:     }
commit:24b23a8
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Compares two JDBC types to see if they are equivalent.
1:      * DECIMAL and NUMERIC and DOUBLE and FLOAT are considered
1:      * equivalent.
1:      * @param expectedType Expected jdbctype from java.sql.Types
1:      * @param type         Actual type from metadata
1:      */
1:     public static void assertEquivalentDataType(int expectedType, int type)
1:     {
1:      if (expectedType == type)
1:          return;
1:      if (expectedType == java.sql.Types.DECIMAL && 
1:                  type == java.sql.Types.NUMERIC)
1:          return;
1:      if (expectedType == java.sql.Types.NUMERIC && 
1:              type == java.sql.Types.DECIMAL)
1:          return;
1:      if (expectedType == java.sql.Types.DOUBLE && 
1:                  type == java.sql.Types.FLOAT)
1:          return;
1:      if (expectedType == java.sql.Types.FLOAT && 
1:              type == java.sql.Types.DOUBLE)
1:      return;
1:      fail("types:" + expectedType + " and " + type + " are not equivalent");
1:      
1:     }
1:     
commit:c872753
/////////////////////////////////////////////////////////////////////////
1:      * Perform a fetch on the ResultSet with an expected failure
1:      * 
1:      * @param sqlState Expected SQLState
1:      * @param rs   ResultSet upon which next() will be called
1:      */
1:     public static void assertNextError(String sqlState,ResultSet rs)
1:     {
1:     	try {
1:     		rs.next();
1:     		fail("Expected error on next()");
1:     	}catch (SQLException se){
1:     		assertSQLState(sqlState,se);
1:     	}
1:     }
1:     
1:     /**
1:      * Perform getInt(position) with expected error
1:      * @param position  position argument to pass to getInt
1:      * @param sqlState  sqlState of expected error
1:      * @param rs ResultSet upon which to call getInt(position)
1:      */
1:     public static void assertGetIntError(int position, String sqlState, ResultSet rs)
1:     {
1:     	try {
1:     		rs.getInt(position);
1:     		fail("Expected exception " + sqlState);
1:     	} catch (SQLException se){
1:     		assertSQLState(sqlState,se);
1:     	}
1:     			
1:     	
1:     }
1:     /**
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:232f5ef
/////////////////////////////////////////////////////////////////////////
1:      * Execute a DROP VIEW command using the passed in viewName as-is
1:      * and the default connection.
1:      * If the DROP VIEW fails because the view does not exist then
1:      * the exception is ignored.
1:      * @param viewName Table to be dropped.
1:      * @throws SQLException
1:      */
1:     public final void dropView(String viewName) throws SQLException
1:     {
1:        dropView(getConnection(), viewName);
1:     }
1:     
1:     /**
1:      * Execute a DROP VIEW command using the passed in viewName as-is.
1:      * If the DROP VIEW fails because the view does not exist then
1:      * the exception is ignored.
1:      * @param conn Connection to execute the DROP VIEW
1:      * @param viewName Table to be dropped.
1:      * @throws SQLException
1:      */
1:     public static void dropView(Connection conn, String viewName) throws SQLException
1:     {
1:         Statement statement = conn.createStatement();
1:         String dropSQL = "DROP VIEW " + viewName;
1:         try { 
1:             
1:             statement.executeUpdate(dropSQL); 
1:         } catch (SQLException e) {
1:             assertSQLState("42Y55", e);
1:         }
1:         finally {
1:             statement.close();
1:         }
1:     }
1: 
1:     /**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a0f4b68
/////////////////////////////////////////////////////////////////////////
commit:43534c8
/////////////////////////////////////////////////////////////////////////
0:                 attempts++;
/////////////////////////////////////////////////////////////////////////
0:                     return;
commit:7aa3f88
/////////////////////////////////////////////////////////////////////////
0:                 if (attempts == 0) {
0:                     fail("directory doesn't exist: " +
1:                 } else {
0:                     // In the previous iteration we saw remaining files, but
0:                     // now the root directory is gone. Not what we expected...
0:                     System.out.println("<assertDirectoryDeleted> root " +
0:                             "directory unexpectedly gone - delayed, " +
0:                             "external or concurrent delete?");
1:                 }
commit:11194a8
/////////////////////////////////////////////////////////////////////////
0:                 PrivilegedFileOpsForTests.getAbsolutePath(dir) + "): " +
commit:f0f442f
/////////////////////////////////////////////////////////////////////////
0:      * attempted deleted again after a pause. This is repeated, resulting
0:      * in multiple failed delete attempts for any single file before the method
/////////////////////////////////////////////////////////////////////////
0:         while (attempts < 4) {
0:             try {
0:                 Thread.sleep(attempts * 2000);
0:             } catch (InterruptedException ie) {
0:                 // Ignore
1:             }
/////////////////////////////////////////////////////////////////////////
commit:ba553fa
/////////////////////////////////////////////////////////////////////////
0:      * <p>
0:      * After having tried to delete all files once, any remaining files will be
0:      * attempted deleted again after a pause. This is repeated twice, resulting
0:      * in three failed delete attempts for any single file before the method
0:      * gives up and raises a failure.
0:      * <p>
0:      * The approach above will mask any slowness involved in releasing file
0:      * handles, but should fail if a file handle actually isn't released on a
0:      * system that doesn't allow deletes on files with open handles (i.e.
0:      * Windows). It will also mask slowness caused by the JVM, the file system,
0:      * or the operation system.
0:         int attempts = 0;
0:         while (attempts < 3) {
0:             try {
0:                 fl = PrivilegedFileOpsForTests.persistentRecursiveDelete(dir);
0:                 attempts++;
0:             } catch (FileNotFoundException fnfe) {
0:                 fail("directory doesn't exist: " +
0:                         PrivilegedFileOpsForTests.getAbsolutePath(dir));
1:             }
0:             if (fl.length == 0) {
0:                 return;
0:             } else {
0:                 // Print the list of remaining files to stdout for debugging.
0:                 StringBuffer sb = new StringBuffer();
0:                 sb.append("<assertDirectoryDeleted> attempt ").append(attempts).
0:                         append(" left ").append(fl.length).
0:                         append(" files/dirs behind:");
0:                 for (int i=0; i < fl.length; i++) {
0:                     sb.append(' ').append(i).append('=').append(fl[i]);
1:                 }
0:                 System.out.println(sb);
0:                 try {
0:                     Thread.sleep(attempts * 1000);
0:                 } catch (InterruptedException ie) {
0:                     // Ignore
1:                 }
1:             }
commit:7eb8268
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean ORDERED = true;
1:     private static final boolean UNORDERED = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:             Statement st, String query) {
1:         assertStatementErrorMinion(sqlStates, ORDERED, st, query);
1:     }
1: 
1:     /**
1:      * Assert that the query fails (either in compilation,
1:      * execution, or retrieval of results--doesn't matter)
1:      * and throws a SQLException with the expected states.
1:      *
1:      * Assumption is that 'query' does *not* have parameters
1:      * that need binding and thus can be executed using a
1:      * simple Statement.execute() call.
1:      *
1:      * If there are extra chained SQLExceptions that are
1:      * not in sqlStates, this method will not fail.
1:      *
1:      * @param sqlStates  expected sql states.
1:      * @param st Statement object on which to execute.
1:      * @param query the query to compile and execute.
1:      */
1:     public static void assertStatementErrorUnordered(String[] sqlStates,
1:             Statement st, String query) {
1:         assertStatementErrorMinion(sqlStates, UNORDERED, st, query);
1:     }
1: 
1:     /**
1:      * Asserts that the given statement fails (compilation, execution or
1:      * retrieval of results) and throws an {@code SQLException} with the
1:      * expected (chained) states.
1:      *
1:      * @param sqlStates the expected states
1:      * @param orderedStates whether or not the states are expected in the
1:      *      specified order or not
1:      * @param st the statement used to execute the query
1:      * @param query the query to execute
1:      */
1:     private static void assertStatementErrorMinion(
1:             String[] sqlStates, boolean orderedStates,
1:             Statement st, String query) {
0:         ArrayList statesBag = null;
1:         if (!orderedStates) {
0:             statesBag = new ArrayList(Arrays.asList(sqlStates));
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 if (orderedStates) {
0:                     assertSQLState(sqlStates[count], se);
0:                 } else {
1:                     String state = se.getSQLState();
1:                     assertTrue("Unexpected state: " + state,
1:                             statesBag.remove(state));
1:                     // Run through assertSQLStates too, to catch invalid states.
1:                     assertSQLState(state, se);
1:                 }
commit:c7b3589
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Deletes the specified directory and all its files and subdirectories.
0:      * <p>
0:      * This method will attempt to delete all the files inside the root
0:      * directory, even if one of the delete operations fails.
1:      *
0:      * @param dir the root to start deleting from (root will also be deleted)
1:      */
0:     public static void assertDirectoryDeleted(File dir) {
0:         File[] fl = null;
0:         try {
0:             fl = PrivilegedFileOpsForTests.persistentRecursiveDelete(dir);
0:         } catch (FileNotFoundException fnfe) {
0:             fail("directory doesn't exist: " +
0:                     PrivilegedFileOpsForTests.getAbsolutePath(dir));
1:         }
0:         if (fl.length == 0) {
0:             return;
1:         }
1: 
0:         // If we failed to delete some of the files, list them and obtain some
0:         // information about each file.
0:         StringBuffer sb = new StringBuffer();
0:         for (int i=0; i < fl.length; i++) {
0:             File f = fl[i];
0:             sb.append(PrivilegedFileOpsForTests.getAbsolutePath(f)).append(' ').
0:                     append(PrivilegedFileOpsForTests.getFileInfo(f)).
0:                     append(", ");
1:         }
0:         sb.deleteCharAt(sb.length() -1).deleteCharAt(sb.length() -1);
0:         fail("Failed to delete " + fl.length + " files (root=" +
0:                 PrivilegedFileOpsForTests.getAbsolutePath(dir) + ": " +
0:                 sb.toString());
1:     }
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
1:     * Tell if the client is DB2Client.
1:     * @return <code>true</code> if using the DB2 client driver,
1:     public static boolean usingDB2Client() {
/////////////////////////////////////////////////////////////////////////
1:             if (usingDB2Client())
/////////////////////////////////////////////////////////////////////////
1:             if (usingDB2Client())
commit:9c86d82
/////////////////////////////////////////////////////////////////////////
commit:954af77
/////////////////////////////////////////////////////////////////////////
1:      * automaticaly closed on tearDown, the test fixture must
/////////////////////////////////////////////////////////////////////////
0:      * automaticaly closed on tearDown, the test fixture must
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:33cfd07
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             finally { attempts++; }
commit:8a319fb
/////////////////////////////////////////////////////////////////////////
1:      * Assert equality between two <code>java.sql.Time</code> objects.
1:      * If both input references are <code>null</code>, they are considered
1:      * equal.
1:      *
1:      * @param msg String with message to supply with AssertionFailedError
1:      * @param t1 first java.sql.Time object.
1:      * @param t2 second java.sql.Time object.
1:      * @throws AssertionFailedError if Time objects are not equal.
1:      */
1:     public static void assertEquals(String msg, Time t1, Time t2) {
1:         if(null == t1 && null == t2) {
0:             return;
1:         }
1:         assertNotNull(msg, t1);
1:         assertNotNull(msg, t2);
1:         assertEquals(msg, t1.toString(), t2.toString());
1:     }
1:     
1:     /**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b878080
/////////////////////////////////////////////////////////////////////////
1:     }
1:     
1:     /**
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection with result set type and concurrency.
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
1:      * @return Statement object from
1:      * getConnection.prepareStatement(sql)
1:      * @throws SQLException
1:      */
1:     public PreparedStatement prepareStatement(String sql,
1:             int resultSetType, int resultSetConcurrency) throws SQLException
1:     {
1:         PreparedStatement ps = getConnection().prepareStatement(sql,
1:                 resultSetType, resultSetConcurrency);
1:         addStatement(ps);
1:         return ps;
1:     }
1:     /**
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection with result set type and concurrency.
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
1:      * @return Statement object from
1:      * getConnection.prepareStatement(sql)
1:      * @throws SQLException
1:      */
1:     public PreparedStatement prepareStatement(String sql,
1:             int resultSetType, int resultSetConcurrency,
1:             int resultSetHoldability) throws SQLException
1:     {
1:         PreparedStatement ps = getConnection().prepareStatement(sql,
1:                 resultSetType, resultSetConcurrency, resultSetHoldability);
1:         addStatement(ps);
1:         return ps;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         CallableStatement cs = getConnection().prepareCall(sql, resultSetType,
1:                 resultSetConcurrency);
1:         addStatement(cs);
1:         return cs;
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         CallableStatement cs = getConnection().prepareCall(sql,
1:                 resultSetType, resultSetConcurrency, resultSetHoldability);
1:         addStatement(cs);
1:         return cs;
commit:c943ab3
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the value of a database property using the default connection 
1:      * @param propertyName Property key
1:      * @return null if the property is not set at the database level,
1:      * otherwise the value of the property.
1:      * @throws SQLException
1:      */
1:     public String getDatabaseProperty(String propertyName) throws SQLException
1:     {
1:         PreparedStatement ps =  prepareStatement(
1:              "VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY(?)");
1:         
1:         ps.setString(1, propertyName);
1:         ResultSet rs = ps.executeQuery();
1:         
1:         rs.next();
1:         
0:         return rs.getString(1);
1:     }
commit:20a900f
/////////////////////////////////////////////////////////////////////////
1:     public void assertCallError(String expectedSE, String callSQL)
1:             CallableStatement cs = prepareCall(callSQL);
1:             assertSQLState(expectedSE, se);
commit:ddeb000
/////////////////////////////////////////////////////////////////////////
1:      * Execute a DROP TABLE command using the passed in tableName as-is
1:      * and the default connection.
1:      * If the DROP TABLE fails because the table does not exist then
1:      * the exception is ignored.
1:      * @param tableName Table to be dropped.
1:      * @throws SQLException
1:      */
1:     public final void dropTable(String tableName) throws SQLException
1:     {
1:        dropTable(getConnection(), tableName);
1:     }
1:     
1:     /**
1:      * Execute a DROP TABLE command using the passed in tableName as-is.
1:      * If the DROP TABLE fails because the table does not exist then
1:      * the exception is ignored.
1:      * @param conn Connection to execute the DROP TABLE
1:      * @param tableName Table to be dropped.
1:      * @throws SQLException
1:      */
1:     public static void dropTable(Connection conn, String tableName) throws SQLException
1:     {
1:         Statement statement = conn.createStatement();
1:         String dropSQL = "DROP TABLE " + tableName;
0:         try { 
1:             
1:             statement.executeUpdate(dropSQL); 
1:         } catch (SQLException e) {
1:             assertSQLState("42Y55", e);
1:         }
1:         finally {
1:             statement.close();
1:         }
1:     }
1: 
1:     /**
commit:442f696
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.Iterator;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:      * Maintain a list of statement objects that
1:      * were returned by utility methods and close
1:      * them at teardown.
1:      */
0:     private List statements;
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
1:         Statement s = getConnection().createStatement();
1:         addStatement(s);
1:         return s;
1:     }
1:     
1:     /**
1:      * Add a statement into the list we will close
1:      * at tearDown.
1:      */
1:     private void addStatement(Statement s)
1:     {
1:         if (statements == null)
0:             statements = new ArrayList();
1:         statements.add(s);
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         Statement s =
1:             getConnection().createStatement(resultSetType, resultSetConcurrency);
1:         addStatement(s);
1:         return s;
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
1:         PreparedStatement ps = getConnection().prepareStatement(sql);
1:         addStatement(ps);
1:         return ps;
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             getConnection().prepareStatement(sql, autoGeneratedKeys);
1:         
1:         addStatement(ps);
1:         return ps;
/////////////////////////////////////////////////////////////////////////
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             getConnection().prepareStatement(sql, columnIndexes);
1:         addStatement(ps);
1:         return ps;
/////////////////////////////////////////////////////////////////////////
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
1:             getConnection().prepareStatement(sql, columnNames);
1:         addStatement(ps);
1:         return ps;
1:      }
1:      * The returned statement object will be closed automatically
1:      * at tearDown() but may be closed earlier by the test if required.
1:         CallableStatement cs =
1:             getConnection().prepareCall(sql);
1:         addStatement(cs);
1:         return cs;
1:  
/////////////////////////////////////////////////////////////////////////
1:      * if it is open and any statement objects returned through
1:      * the utility methods.
1:         if (statements != null) {
0:             for (Iterator i = statements.iterator(); i.hasNext(); )
1:             {
0:                 Statement s = (Statement) i.next();
1:                 s.close();
1:             }
1:             // Allow gc'ing of all those statements.
1:             statements = null;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:      * Run a set of SQL commands from a String discarding the output.
1:      * is this objects default connection.
/////////////////////////////////////////////////////////////////////////
1:      * Assert that the SQL statement does not compile and throws
1:      * @param sql the SQL to compile.
1:     public void assertCompileError(String sqlState, String sql) {
1:             PreparedStatement pSt = prepareStatement(sql);
/////////////////////////////////////////////////////////////////////////
1:      * Take a Statement object and a SQL statement, execute it
1:      * Assumption is that 'sql' does *not* have parameters
1:      * @param sql SQL to execute.
1:         int expectedRC, String sql) throws SQLException
1:             expectedRC, st.executeUpdate(sql));
commit:f3110ed
/////////////////////////////////////////////////////////////////////////
0:      * Run a set of SQL commands from a String discarding the output,
0:      * intended for setup code, not testing (assert) code.
0:      * is this objects default connection. Note that assertions
0:      * are not performed by this method. Code may assert the number
0:      * of failures returned, typically as zero. Exceptions
0:      * thrown by statements are not thrown through this method.
0:      * For single statements a Statement object should be used directly.
commit:e604a71
/////////////////////////////////////////////////////////////////////////
0:                 try {
1:                     pSt.execute();
1:                 } finally {
1:                     pSt.close();
0:                 }
commit:4b16d4c
/////////////////////////////////////////////////////////////////////////
1:      * Check the table using SYSCS_UTIL.SYSCS_CHECK_TABLE.
1:      */
1:     public void assertCheckTable(String table) throws SQLException
1:     {
1:         PreparedStatement ps = prepareStatement(
1:                 "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE(?, ?)");
1:         
1:         ps.setString(1, getTestConfiguration().getUserName());
1:         ps.setString(2, table);
1:         
1:         ResultSet rs = ps.executeQuery();
1:         JDBC.assertSingleValueResultSet(rs, "1");
1:         ps.close();
0:     }
1:     
1:     /**
commit:e5c9e58
/////////////////////////////////////////////////////////////////////////
1:      * additionalDatabaseDecorator with the matching name.
1:      * @see TestConfiguration#additionalDatabaseDecorator(Test, String)
commit:3a781d5
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(r1); // java.sql.Blob object cannot represent NULL
1:         assertNotNull(r2); // java.sql.Blob object cannot represent NULL
1: 
commit:e65a7e8
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
0:      * @see openDefaultConnection()
/////////////////////////////////////////////////////////////////////////
1:      * Default action is to not modify the connection's state from
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
1:      * @see BaseJDBCTestCase#initializeConnection(Connection)
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
1:      * @see BaseJDBCTestCase#initializeConnection(Connection)
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
1:      * @see BaseJDBCTestCase#initializeConnection(Connection)
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * The connection will be initialized by calling initializeConnection.
1:      * A sub-class may provide an implementation of initializeConnection
1:      * to ensure its connections are in a consistent state that is different
1:      * to the default.
1:      * @see BaseJDBCTestCase#initializeConnection(Connection)
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Assert that the number of rows in a table is an expected value.
1:      * Query uses a SELECT COUNT(*) FROM "table".
1:      * 
1:      * @param table Name of table in current schema, will be quoted
1:      * @param rowCount Number of rows expected in the table
1:      * @throws SQLException Error accessing the database.
1:      */
1:     protected void assertTableRowCount(String table, int rowCount) throws SQLException
1:     {
1:         assertEscapedTableRowCount(JDBC.escape(table), rowCount);
0:     }
1: 
1:     /**
1:      * Assert that the number of rows in a table is an expected value.
1:      * Query uses a SELECT COUNT(*) FROM table.
1:      * 
0:      * @param table Escaped name of table, will be used as-is.
1:      * @param rowCount Number of rows expected in the table
1:      * @throws SQLException Error accessing the database.
1:      */
1:     private void assertEscapedTableRowCount(String escapedTableName, int rowCount)
1:        throws SQLException
1:     {
1:     
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery(
1:                 "SELECT COUNT(*) FROM " + escapedTableName);
1:         rs.next();
1:         assertEquals(escapedTableName + " row count:",
1:             rowCount, rs.getInt(1));
1:         rs.close();
1:         s.close();
0:     }
commit:2346370
/////////////////////////////////////////////////////////////////////////
1:      * Open a connection to the current default database using the
1:      * specified user name and password.
1:      * <BR>
1:      * This connection is not
0:      * automaticaly closed on tearDown, the text fixture must
1:      * ensure the connection is closed.
1:      */
1:     public Connection openDefaultConnection(String user, String password)
1:     throws SQLException
1:     {
1:         Connection conn =  getTestConfiguration().openDefaultConnection(user,
1:                 password);
1:         initializeConnection(conn);
1:         return conn;        
0:     }
1:     
1:     /**
1:      * Open a connection to the current default database using the
1:      * specified user name. The password is a function of
1:      * the user name and the password token setup by the
1:      * builtin authentication decorators.
1:      * <BR>
1:      * If the fixture is not wrapped in one of the decorators
1:      * that setup BUILTIN authentication then the password
1:      * is a function of the user name and the empty string
1:      * as the password token. This mode is not recommended.
1:      * 
1:      * <BR>
1:      * This connection is not
0:      * automaticaly closed on tearDown, the text fixture must
1:      * ensure the connection is closed.
1:      * 
1:      * @see DatabasePropertyTestSetup#builtinAuthentication(Test, String[], String)
1:      * @see TestConfiguration#sqlAuthorizationDecorator(Test, String[], String)
1:      */
1:     public Connection openUserConnection(String user) throws SQLException
1:     {
1:         return openDefaultConnection(user,
1:                 getTestConfiguration().getPassword(user));
0:     }
1:     
1:     /**
commit:3df869c
/////////////////////////////////////////////////////////////////////////
1:      * Open a connection to the specified database.
1:      * If the database does not exist, it will be created.
1:      * A default username and password will be used for the connection.
1:      * Requires that the test has been decorated with a
0:      * singleUseDatabaseDecorator with the matching name.
1:      *
1:      * @return connection to default database.
0:      * @see TestConfiguration#singleUseDatabaseDecorator(Test, String, boolean)
1:      */
1:     public Connection openConnection(String databaseName)
1:         throws SQLException {
1:         Connection conn =  getTestConfiguration().openConnection(databaseName);
0:         initializeConnection(conn);
1:         return conn;
0:     }
1:     
1:     /**
commit:aa8a764
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:      * Run a SQL script through ij discarding the output
1:      * using this object's default connection. Intended for
1:      * setup scripts.
1:      * @return Number of errors executing the script
1:      * @throws UnsupportedEncodingException 
1:      * @throws PrivilegedActionException
1:      * @throws SQLException 
1:      */
1:     public int runScript(String resource,String encoding)
1:         throws UnsupportedEncodingException, SQLException,
1:         PrivilegedActionException,IOException
1:     {
1:         
1:         URL sql = getTestResource(resource);
1:         assertNotNull("SQL script missing: " + resource, sql);
1:         InputStream sqlIn = openTestResource(sql);
1:         Connection conn = getConnection();
1:         int numErrors = runScript(sqlIn,encoding);
1:         sqlIn.close();
1:         
1:         if (!conn.isClosed() && !conn.getAutoCommit())
1:             conn.commit();
1:         
1:         return numErrors;
0:     }
1:     
1:     /**
commit:01fe867
/////////////////////////////////////////////////////////////////////////
commit:45da985
/////////////////////////////////////////////////////////////////////////
commit:9528482
/////////////////////////////////////////////////////////////////////////
commit:0c4649d
/////////////////////////////////////////////////////////////////////////
1:      * Assert that SQLState is as expected.  If the SQLState for
1:      * the top-level exception doesn't match, look for nested
1:      * exceptions and, if there are any, see if they have the
1:      * desired SQLState.
/////////////////////////////////////////////////////////////////////////
0:             if (usingDerbyNetClient())
1:             {
0:                 /* For chained exceptions the Derby Client just concatenates
0:                  * them into the exception message.  So search the message
0:                  * for the desired SQLSTATE.  This isn't ideal, but it
0:                  * should work...
1:                  */
0:                 if (exception.getMessage().
0:                     indexOf("SQLSTATE: " + expected) == -1)
1:                 {
1:                     throw e;
0:                 }
0:             }
0:             else if (usingDerbyNet())
1:             {
1:                 /* For JCC the error message is a series of tokens representing
1:                  * different things like SQLSTATE, SQLCODE, nested SQL error
1:                  * message, and nested SQL state.  Based on observation it
1:                  * appears that the last token in the message is the SQLSTATE
1:                  * of the nested exception, and it's preceded by a colon.
1:                  * So using that (hopefully consistent?) rule, try to find
1:                  * the target SQLSTATE.
1:                  */
1:                 String msg = exception.getMessage();
1:                 if (!msg.substring(msg.lastIndexOf(":")+1)
1:                     .trim().equals(expected))
1:                 {
1:                     throw e;
0:                 }
0:             }
1:             else
1:             {
1:                 // Check nested exceptions to see if any of them is
1:                 // the one we're looking for.
0:                 exception = exception.getNextException();
1:                 if (exception != null)
1:                     assertSQLState(message, expected, exception);
1:                 else
1:                     throw e;
0:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement pSt = prepareStatement(query);
0:             if (usingDerbyNet())
1:             {
1:                 /* For JCC the prepares are deferred until execution,
1:                  * so we have to actually execute in order to see the
1:                  * expected error.  Note that we don't need to worry
1:                  * about binding the parameters (if any); the compile
1:                  * error should occur before the execution-time error
1:                  * about unbound parameters.
1:                  */
0:                 pSt.execute();
0:             }
1:     /**
1:      * Assert that the query fails (either in compilation,
1:      * execution, or retrieval of results--doesn't matter)
0:      * and throws a SQLException with the expected state.
1:      *
1:      * Assumption is that 'query' does *not* have parameters
1:      * that need binding and thus can be executed using a
1:      * simple Statement.execute() call.
1:      * 
0:      * @param sqlstate expected sql state.
1:      * @param st Statement object on which to execute.
1:      * @param query the query to compile and execute.
1:      */
1:     public static void assertStatementError(String sqlState,
0:         Statement st, String query)
1:     {
0:         try {
1:             boolean haveRS = st.execute(query);
1:             fetchAndDiscardAllResults(st, haveRS);
1:             fail("Expected error '" + sqlState +
1:                 "' but no error was thrown.");
1:         } catch (SQLException se) {
1:             assertSQLState(sqlState, se);
0:         }
0:     }
1: 
1:     /**
1:      * Assert that execution of the received PreparedStatement
1:      * object fails (either in execution or when retrieving
1:      * results) and throws a SQLException with the expected
1:      * state.
1:      * 
1:      * Assumption is that "pSt" is either a PreparedStatement
1:      * or a CallableStatement that has already been prepared
1:      * and whose parameters (if any) have already been bound.
1:      * Thus the only thing left to do is to call "execute()"
1:      * and look for the expected SQLException.
1:      * 
0:      * @param sqlstate expected sql state.
1:      * @param pSt A PreparedStatement or CallableStatement on
1:      *  which to call "execute()".
1:      */
1:     public static void assertStatementError(String sqlState,
1:         PreparedStatement pSt)
1:     {
0:         try {
1:             boolean haveRS = pSt.execute();
1:             fetchAndDiscardAllResults(pSt, haveRS);
1:             fail("Expected error '" + sqlState +
1:                 "' but no error was thrown.");
1:         } catch (SQLException se) {
1:             assertSQLState(sqlState, se);
0:         }
0:     }
1: 
1:     /**
0:      * Take a Statement object and a SQL query, execute it
1:      * via the "executeUpdate()" method, and assert that the
1:      * resultant row count matches the received row count.
1:      *
1:      * Assumption is that 'query' does *not* have parameters
1:      * that need binding and that it can be executed using a
1:      * simple Statement.executeUpdate() call.
1:      * 
1:      * @param st Statement object on which to execute.
1:      * @param expectedRC Expected row count.
0:      * @param query Query to execute.
1:      */
1:     public static void assertUpdateCount(Statement st,
0:         int expectedRC, String query) throws SQLException
1:     {
1:         assertEquals("Update count does not match:",
0:             expectedRC, st.executeUpdate(query));
0:     }
1: 
1:     /**
1:      * Assert that a call to "executeUpdate()" on the received
1:      * PreparedStatement object returns a row count that matches
1:      * the received row count.
1:      *
1:      * Assumption is that "pSt" is either a PreparedStatement
1:      * or a CallableStatement that has already been prepared
1:      * and whose parameters (if any) have already been bound.
1:      * Also assumes the statement's SQL is such that a call
1:      * executeUpdate() is allowed.  Thus the only thing left
1:      * to do is to call the "executeUpdate" method.
1:      * 
1:      * @param pSt The PreparedStatement on which to execute.
1:      * @param expectedRC The expected row count.
1:      */
1:     public static void assertUpdateCount(PreparedStatement pSt,
1:         int expectedRC) throws SQLException
1:     {
1:         assertEquals("Update count does not match:",
1:             expectedRC, pSt.executeUpdate());
0:     }
1: 
1:     /**
1:      * Take the received Statement--on which a query has been
1:      * executed--and fetch all rows of all result sets (if any)
1:      * returned from execution.  The rows themselves are
1:      * discarded.  This is useful when we expect there to be
1:      * an error when processing the results but do not know
1:      * (or care) at what point the error occurs.
1:      *
1:      * @param st An already-executed statement from which
1:      *  we get the result set to process (if there is one).
1:      * @param haveRS Whether or not the the statement's
1:      *  first result is a result set (as opposed to an
1:      *  update count).
1:      */
1:     private static void fetchAndDiscardAllResults(Statement st,
1:         boolean haveRS) throws SQLException
1:     {
1:         ResultSet rs = null;
1:         while (haveRS || (st.getUpdateCount() != -1))
1:         {
1:             // If we have a result set, iterate through all
1:             // of the rows.
1:             if (haveRS)
1:                 JDBC.assertDrainResults(st.getResultSet(), -1);
1:             haveRS = st.getMoreResults();
0:         }
0:     }
1: 
commit:80b6a78
/////////////////////////////////////////////////////////////////////////
1:      * @see BaseJDBCTestCase#getConnection()
commit:aef9938
/////////////////////////////////////////////////////////////////////////
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.AssertionFailedError;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         try {
1:             String state = exception.getSQLState();
1:             
1:             if ( state != null )
1:                 assertTrue("The exception's SQL state must be five characters long",
1:                         state.length() == 5);
1:             
1:             if ( expected != null )
1:                 assertTrue("The expected SQL state must be five characters long",
1:                     expected.length() == 5);
1:             
1:             assertEquals(message, expected, state);
0:         } catch (AssertionFailedError e) {
1:             
0:             // Save the SQLException
0:             // e.initCause(exception);
1: 
0:             throw e;
0:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Assert that the query does not compile and throws
1:      * a SQLException with the expected state.
1:      * 
0:      * @param sqlstate expected sql state.
0:      * @param query the query to compile.
1:      */
0:     public void assertCompileError(String sqlState, String query) {
1: 
0:         try {
0:             prepareStatement(query).close();
1:             fail("expected compile error: " + sqlState);
1:         } catch (SQLException se) {
0:             assertSQLState(sqlState, se);
0:         }
0:     }
1: 
1: 
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
1:          return TestConfiguration.getCurrent().getJDBCClient().isEmbedded();
/////////////////////////////////////////////////////////////////////////
1:         return TestConfiguration.getCurrent().getJDBCClient().isDerbyNetClient();
/////////////////////////////////////////////////////////////////////////
1:         return TestConfiguration.getCurrent().getJDBCClient().isDB2Client();
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:     public Connection getConnection() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         return conn = openDefaultConnection();
1:      * consistent connection state for its tests. Called once
1:      * for each time these method calls open a connection:
1:      * <UL>
1:      * <LI> getConnection()
1:      * <LI> openDefaultConnection()
1:      * <LI> openConnection(database)
1:      * </UL>
/////////////////////////////////////////////////////////////////////////
0:         return getConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         return getConnection().createStatement(resultSetType, resultSetConcurrency);
/////////////////////////////////////////////////////////////////////////
0:         return getConnection().prepareStatement(sql);
/////////////////////////////////////////////////////////////////////////
0:         return getConnection().prepareCall(sql);
/////////////////////////////////////////////////////////////////////////
1:         getConnection().commit();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().rollback();
/////////////////////////////////////////////////////////////////////////
1:     public Connection openDefaultConnection()
1:         Connection conn =  getTestConfiguration().openDefaultConnection();
0:         initializeConnection(conn);
0:         return conn;
0:         Connection conn = getTestConfiguration().openConnection(databaseName);
0:         initializeConnection(conn);
0:         return conn;        
/////////////////////////////////////////////////////////////////////////
1:         return ij.runScript(getConnection(), script, encoding,
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
1:      * getConnection.prepareStatement(sql)
1: 
1:     /**
1:      * Utility method to create a CallableStatement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection().prepareCall(sql)
1:      * @throws SQLException
1:      */
1:     public CallableStatement prepareCall(String sql) throws SQLException
0:     {
0:         return getXConnection().prepareCall(sql);
0:     }
/////////////////////////////////////////////////////////////////////////
commit:95011a0
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.OutputStream;
0: import java.io.PrintStream;
1: import java.io.UnsupportedEncodingException;
1: import org.apache.derby.tools.ij;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Run a SQL script through ij discarding the output
1:      * using this object's default connection. Intended for
1:      * setup scripts.
1:      * @throws UnsupportedEncodingException 
1:      * @throws SQLException 
1:      */
1:     public int runScript(InputStream script, String encoding)
1:         throws UnsupportedEncodingException, SQLException
0:     {
1:         // Sink output.
0:         OutputStream sink = new OutputStream() {
0:             public void write(byte[] b, int off, int len) {}
0:             public void write(int b) {}
0:         };
1:         
1:         // Use the same encoding as the input for the output.    
0:         return ij.runScript(getXConnection(), script, encoding,
1:                 sink, encoding);       
0:     }
1:     
1:     /**
0:      * Run a set of SQL commands from a String discarding the output.
1:      * Commands are separated by a semi-colon. Connection used
0:      * is this objects default connection.
1:      * @param sqlCommands
1:      * @return Number of errors executing the script.
1:      * @throws UnsupportedEncodingException
1:      * @throws SQLException
1:      */
1:     public int runSQLCommands(String sqlCommands)
1:         throws UnsupportedEncodingException, SQLException
0:     {
1:         byte[] raw = sqlCommands.getBytes("UTF-8");
1:         ByteArrayInputStream in = new ByteArrayInputStream(raw);
1:         
1:         return runScript(in, "UTF-8");
0:     }
1:     
1:     /**
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.junit;
0: 
commit:fb2bfd5
/////////////////////////////////////////////////////////////////////////
0:         conn = getTestConfiguration().openDefaultConnection();
0:         initializeConnection(conn);
0:         return conn;
0:     }
0:     
1:     /**
1:      * Allow a sub-class to initialize a connection to provide
0:      * consistent connection state for its tests. Called only
0:      * when getConnection() opens a new connection. Default
0:      * action is to not modify the connection's state from
1:      * the initialization provided by the data source.
1:      * @param conn Connection to be intialized
1:      * @throws SQLException Error setting the initial state.
1:      */
1:     protected void initializeConnection(Connection conn) throws SQLException
0:     {
commit:7ebfefe
/////////////////////////////////////////////////////////////////////////
0:     public Connection getXConnection() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * Utility method to create a Statement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from getConnection.createStatement()
1:      * @throws SQLException
1:      */
1:     public Statement createStatement() throws SQLException
0:     {
0:         return getXConnection().createStatement();
0:     }
0: 
1:     /**
1:      * Utility method to create a Statement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection.createStatement(resultSetType, resultSetConcurrency)
1:      * @throws SQLException
1:      */
1:     public Statement createStatement(int resultSetType,
1:             int resultSetConcurrency) throws SQLException
0:     {
0:         return getXConnection().createStatement(resultSetType, resultSetConcurrency);
0:     }
1:     /**
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection.
1:      * @return Statement object from
1:      * getConnection.createStatement(resultSetType, resultSetConcurrency)
1:      * @throws SQLException
1:      */
1:     public PreparedStatement prepareStatement(String sql) throws SQLException
0:     {
0:         return getXConnection().prepareStatement(sql);
0:     }    
0:     
1:     /**
1:      * Utility method to commit using the connection
1:      * returned by getConnection.
1:      * @throws SQLException
1:      */
1:     public void commit() throws SQLException
0:     {
0:         getXConnection().commit();
0:     }  
1:     /**
1:      * Utility method to rollback using the connection
1:      * returned by getConnection.
1:      * @throws SQLException
1:      */
1:     public void rollback() throws SQLException
0:     {
0:         getXConnection().rollback();
0:     } 
1:     /**
commit:ffe3f66
/////////////////////////////////////////////////////////////////////////
1:      * Maintain a single connection to the default
1:      * database, opened at the first call to getConnection.
1:      * Typical setup will just require a single connection.
0:      * @see BaseJDBCTestSetup#getConnection()
1:      */
1:     private Connection conn;
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Obtain the connection to the default database.
1:      * This class maintains a single connection returned
1:      * by this class, it is opened on the first call to
1:      * this method. Subsequent calls will return the same
1:      * connection object unless it has been closed. In that
1:      * case a new connection object will be returned.
1:      * <P>
1:      * The tearDown method will close the connection if
1:      * it is open.
1:      * @see TestConfiguration#openDefaultConnection()
0:      */
0:     // TEMP NAME - WILL BE getConnection() once all uses of the
0:     // static getConnection() have been converted to openDefaultConnection
0:     public final Connection getXConnection() throws SQLException
0:     {
1:         if (conn != null)
0:         {
1:             if (!conn.isClosed())
0:                 return conn;
1:             conn = null;
0:         }
0:         return conn = getTestConfiguration().openDefaultConnection();
0:     }
0:     
0:     /**
1:      * Tear down this fixture, sub-classes should call
0:      * super.tearDown(). This cleanups & closes the connection
0:      * if it is open.
0:      */
1:     protected void tearDown()
1:     throws java.lang.Exception
0:     {
0:         JDBC.cleanup(conn);
1:         conn = null;
0:     }
commit:df2b52c
/////////////////////////////////////////////////////////////////////////
0:     // TEMP
0:     public static Connection getConnection() throws SQLException
0:     {
0:         return openDefaultConnection();
0:     }
0: 
1:      * Open a connection to the default database.
0:      * @see TestConfiguration#openDefaultConnection()
0:     public static Connection openDefaultConnection()
0:         return CONFIG.openDefaultConnection();
0:     public Connection openConnection(String databaseName) throws SQLException
0:     {
0:         return getTestConfiguration().openConnection(databaseName);
0:     }
0:     
commit:00bbcf1
/////////////////////////////////////////////////////////////////////////
0:          return CONFIG.getJDBCClient().isEmbedded();
/////////////////////////////////////////////////////////////////////////
0:         return CONFIG.getJDBCClient().isDerbyNetClient();
/////////////////////////////////////////////////////////////////////////
0:         return CONFIG.getJDBCClient().isDB2Client();
commit:f308936
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return CONFIG.getDefaultConnection();
0:     
0: 
/////////////////////////////////////////////////////////////////////////
commit:576a49f
/////////////////////////////////////////////////////////////////////////
1: public abstract class BaseJDBCTestCase
author:Army
-------------------------------------------------------------------------------
commit:e3bd4bb
/////////////////////////////////////////////////////////////////////////
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection and an array of column indexes that
1:      * indicates which auto-generated keys produced by this Statement
1:      * object should be made available for retrieval.
0:      *
1:      * @return Statement object from:
1:      *     prepareStatement(sql, columnIndexes)
0:      *
1:      * @throws SQLException
0:      */
1:     public PreparedStatement prepareStatement(String sql,
1:         int [] columnIndexes) throws SQLException
0:     {
0:         return getConnection().prepareStatement(sql, columnIndexes);
0:     }
0: 
0:     /**
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection and an array of column names that
1:      * indicates which auto-generated keys produced by this Statement
1:      * object should be made available for retrieval.
0:      *
1:      * @return Statement object from:
1:      *     prepareStatement(sql, columnNames)
0:      *
1:      * @throws SQLException
0:      */
1:     public PreparedStatement prepareStatement(String sql,
1:         String [] columnNames) throws SQLException
0:     {
0:         return getConnection().prepareStatement(sql, columnNames);
0:     }
0: 
0:     /**
author:Jean T. Anderson
-------------------------------------------------------------------------------
commit:c7fdf72
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Utility method to create a PreparedStatement using the connection
1:      * returned by getConnection and a flag that signals the driver whether
1:      * the auto-generated keys produced by this Statement object should be
1:      * made available for retrieval.
1:      * @return Statement object from
1:      * prepareStatement(sql, autoGeneratedKeys)
0:      * @throws SQLException
0:      */
1:     public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
0:         throws SQLException
0:     {
0:         return getConnection().prepareStatement(sql, autoGeneratedKeys);
0:     }    
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
1: import java.io.BufferedReader;
/////////////////////////////////////////////////////////////////////////
0: 
0:         
1:         // wrap buffered stream around the binary stream
1:         is1 = new BufferedInputStream(is1);
1:         is2 = new BufferedInputStream(is2);
0:  
/////////////////////////////////////////////////////////////////////////
1:         // wrap buffered reader around the character stream
1:         r1 = new BufferedReader(r1);
1:         r2 = new BufferedReader(r2);
0: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      * @see #openDefaultConnection()
/////////////////////////////////////////////////////////////////////////
1:      * @param sqlState expected sql state.
/////////////////////////////////////////////////////////////////////////
1:      * @param escapedTableName Escaped name of table, will be used as-is.
/////////////////////////////////////////////////////////////////////////
1:      * @param sqlState expected sql state.
/////////////////////////////////////////////////////////////////////////
0:      * @param sqlState expected sql state.
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:37952cf
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.DataSource;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0:             //Use DataSource for JSR169
0:             Properties prop = new Properties();
0:             prop.setProperty("databaseName", CONFIG.getDatabaseName());
0:             prop.setProperty("connectionAttributes", "create=true");
0:             DataSource ds = TestUtil.getDataSource(prop);
0:             con = ds.getConnection();
/////////////////////////////////////////////////////////////////////////
1: } // End class BaseJDBCTestCase
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull("Exception cannot be null when asserting on SQLState", 
1:                       exception);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e4ba4e1
/////////////////////////////////////////////////////////////////////////
0:         
0:         String state = exception.getSQLState();
0:         
0:         if ( state != null )
0:             assertTrue("The exception's SQL state must be five characters long",
0:                 exception.getSQLState().length() == 5);
0:         
0:         if ( expected != null )
0:             assertTrue("The expected SQL state must be five characters long",
0:                 expected.length() == 5);
0:         
0:         assertEquals(message, expected, state);
commit:b350a56
/////////////////////////////////////////////////////////////////////////
1: /*
0:  *
1:  * Derby - Class BaseJDBCTestCase
0:  *
0:  * Copyright 2006 The Apache Software Foundation or its 
0:  * licensors, as applicable.
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
0:  */
0: package org.apache.derbyTesting.functionTests.util;
0: 
1: import java.sql.*;
0: 
0: /**
1:  * Base class for JDBC JUnit tests.
1:  * A method for getting a default connection is provided, along with methods
1:  * for telling if a specific JDBC client is used.
0:  */
0: public class BaseJDBCTestCase
1:     extends BaseTestCase {
0: 
0:     /**
0:      * Tell if we are allowed to use DriverManager to create database
0:      * connections.
0:      */
0:     private static final boolean HAVE_DRIVER;
0: 
0:     static {
0:         // See if java.sql.Driver is available. If it is not, we must use
0:         // DataSource to create connections.
0:         boolean haveDriver = false;
0:         try {
0:             Class.forName("java.sql.Driver");
0:             haveDriver = true;
0:         } catch (Exception e) {}
0:         HAVE_DRIVER = haveDriver;
0:     }
0:     
0:     /**
1:      * Create a test case with the given name.
0:      *
1:      * @param name of the test case.
0:      */
1:     public BaseJDBCTestCase(String name) {
1:         super(name);
0:     }
0: 
0:     /**
0:      * Get connection to the default database.
1:      * If the database does not exist, it will be created.
1:      * A default username and password will be used for the connection.
0:      *
0:      * @return connection to default database.
0:      */
0:     public static Connection getConnection()
0:         throws SQLException {
0:         Connection con = null;
0:         JDBCClient client = CONFIG.getJDBCClient();
0:         if (HAVE_DRIVER) {
0:             loadJDBCDriver(client.getJDBCDriverName());
0:             con = DriverManager.getConnection(
0:                     CONFIG.getJDBCUrl() + ";create=true",
0:                     CONFIG.getUserName(),
0:                     CONFIG.getUserPassword());
0:         } else {
0:             throw new UnsupportedOperationException(
0:                     "Creating a connection in a JSR-169 " +
0:                     "environment is not yet supported. " +
0:                     "Please implement :)");
0:         }
0:         return con;
0:     }
0: 
0:    /**
0:     * Tell if the client is embedded.
0:     *
0:     * @return <code>true</code> if using the embedded client
1:     *         <code>false</code> otherwise.
0:     */
0:     public static boolean usingEmbedded() {
0:         return (CONFIG.getJDBCClient() == JDBCClient.EMBEDDED);
0:     }
0:    
0:     /**
1:     * Tell if the client is DerbyNetClient.
0:     *
1:     * @return <code>true</code> if using the DerbyNetClient client
1:     *         <code>false</code> otherwise.
0:     */
1:     public static boolean usingDerbyNetClient() {
0:         return (CONFIG.getJDBCClient() == JDBCClient.DERBYNETCLIENT);
0:     }
0:     
0:     /**
0:     * Tell if the client is DerbyNet.
0:     *
0:     * @return <code>true</code> if using the DerbyNet client
1:     *         <code>false</code> otherwise.
0:     */
0:     public static boolean usingDerbyNet() {
0:         return (CONFIG.getJDBCClient() == JDBCClient.DERBYNET);
0:     }
0: 
0:     /**
0:      * Load the specified JDBC driver
0:      *
0:      * @param driverClass name of the JDBC driver class.
0:      * @throws SQLException if loading the driver fails.
0:      */
0:     private static void loadJDBCDriver(String driverClass) 
0:         throws SQLException {
0:         try {
0:             Class.forName(driverClass).newInstance();
0:         } catch (ClassNotFoundException cnfe) {
0:             throw new SQLException("Failed to load JDBC driver '" + 
0:                                     driverClass + "': " + cnfe.getMessage());
0:         } catch (IllegalAccessException iae) {
0:             throw new SQLException("Failed to load JDBC driver '" +
0:                                     driverClass + "': " + iae.getMessage());
0:         } catch (InstantiationException ie) {
0:             throw new SQLException("Failed to load JDBC driver '" +
0:                                     driverClass + "': " + ie.getMessage());
0:         }
0:     }
0: 
0: } // Enc class BaseJDBCTestCase
============================================================================