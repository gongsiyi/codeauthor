1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.execute.ResultSetFactory
1:7ecc1f2: 
1:2dd2d11:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2dd2d11:    contributor license agreements.  See the NOTICE file distributed with
1:2dd2d11:    this work for additional information regarding copyright ownership.
1:2dd2d11:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2dd2d11:    (the "License"); you may not use this file except in compliance with
1:2dd2d11:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.execute;
1:eac0369: 
1:f432362: import org.apache.derby.catalog.TypeDescriptor;
1:f432362: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:3527fd5: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:cbdc90c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * ResultSetFactory provides a wrapper around all of
1:eac0369:  * the result sets needed in an execution implementation.
1:eac0369:  * <p>
1:eac0369:  * For the activations to avoid searching for this module
1:eac0369:  * in their execute methods, the base activation supertype
1:eac0369:  * should implement a method that does the lookup and salts
1:eac0369:  * away this factory for the activation to use as it needs it.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public interface ResultSetFactory {
1:eac0369: 	/**
1:eac0369: 		Module name for the monitor's module locating system.
1:eac0369: 	 */
1:eac0369: 	String MODULE = "org.apache.derby.iapi.sql.execute.ResultSetFactory";
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// DDL operations
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Generic DDL result set creation.
1:eac0369: 
5:eac0369: 		@param activation 		the activation for this result set
1:eac0369: 
1:eac0369: 		@return	ResultSet	A wrapper result set to run the Execution-time
1:eac0369: 		                        logic.
2:eac0369: 		@exception StandardException thrown when unable to create the
2:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	ResultSet getDDLResultSet(Activation activation)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// MISC operations
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Generic Misc result set creation.
1:eac0369: 
1:eac0369: 		@param activation 		the activation for this result set
1:eac0369: 
1:eac0369: 		@return	ResultSet	A wrapper result set to run the Execution-time
1:eac0369: 		                        logic.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	ResultSet getMiscResultSet(Activation activation)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Transaction operations
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 
1:eac0369: 		@param activation 		the activation for this result set
1:eac0369: 
1:eac0369: 		@return	ResultSet	A wrapper result set to run the Execution-time
1:eac0369: 		                        logic.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	ResultSet getSetTransactionResultSet(Activation activation) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// DML statement operations
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 		An insert result set simply reports that it completed, and
1:eac0369: 		the number of rows inserted.  It does not return rows.
1:eac0369: 		The insert has been completed once the
1:eac0369: 		insert result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to
1:eac0369: 			be inserted into the target table.
1:c533cd2: 		@param generationClauses	The code to compute column generation clauses if any
1:eac0369: 		@param checkGM	The code to enforce the check constraints, if any
1:959fef2:         @param fullTemplate Saved item for a row template used by bulk insert,
1:959fef2:                             or -1 if this is not a bulk insert
1:af1c18c:         @param schemaNameName schema name of table
1:af1c18c:         @param tableName table name
1:eac0369: 		@return the insert operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the insert
1:eac0369: 	 */
1:c533cd2: 	ResultSet getInsertResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
1:af1c18c:                                  GeneratedMethod checkGM, int fullTemplate,
1:af1c18c:                                  String schemaNameName,
1:af1c18c:                                  String tableName)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An insert VTI result set simply reports that it completed, and
1:eac0369: 		the number of rows inserted.  It does not return rows.
1:eac0369: 		The insert has been completed once the
1:eac0369: 		insert result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to
1:eac0369: 			be inserted into the target table.
1:eac0369: 		@param vtiRS	The code to instantiate the VTI, if necessary
1:eac0369: 		@return the insert VTI operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the insert
1:eac0369: 	 */
1:eac0369: 	ResultSet getInsertVTIResultSet(NoPutResultSet source, 
1:6b26ee1: 								 NoPutResultSet vtiRS)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A delete VTI result set simply reports that it completed, and
1:eac0369: 		the number of rows deleted.  It does not return rows.
1:eac0369: 		The delete has been completed once the
1:eac0369: 		delete result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to
1:eac0369: 			be inserted into the target table.
1:eac0369: 		@return the delete VTI operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the insert
1:eac0369: 	 */
1:6b26ee1: 	ResultSet getDeleteVTIResultSet(NoPutResultSet source)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A delete result set simply reports that it completed, and
1:eac0369: 		the number of rows deleted.  It does not return rows.
1:eac0369: 		The delete has been completed once the
1:eac0369: 		delete result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to
1:eac0369: 			be deleted from the target table. This result set must
1:eac0369: 			contain one column which provides RowLocations that are
1:eac0369: 			valid in the target table.
1:eac0369: 		@return the delete operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the delete
1:eac0369: 	 */
1:6b26ee1: 	ResultSet getDeleteResultSet(NoPutResultSet source)
1:eac0369: 							throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:508a010: 		A MERGE result set simply reports that it completed, and
1:508a010: 		the number of rows that it INSERTed/UPDATEd/DELETEdd.  It does not return rows.
1:508a010: 		The delete has been completed once the
1:508a010: 		MERGE result set is available.
1:508a010: 
1:508a010: 		@param drivingLeftJoin the result set from which to take rows to
1:508a010: 			be drive the INSERT/UPDATE/DELETE operations.
1:508a010: 		@return the MERGE operation as a result set.
1:508a010: 		@exception StandardException thrown when unable to perform the work
1:508a010: 	 */
1:508a010: 	ResultSet getMergeResultSet(NoPutResultSet drivingLeftJoin)
1:508a010: 							throws StandardException;
1:508a010: 
1:508a010: 	/**
1:eac0369: 		A delete Cascade result set simply reports that it completed, and
1:eac0369: 		the number of rows deleted.  It does not return rows.
1:eac0369: 		The delete has been completed once the
1:eac0369: 		delete result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to
1:eac0369: 			be deleted from the target table.
1:eac0369: 		@param constantActionItem a constant action saved object reference
1:eac0369: 		@param dependentResultSets an array of DeleteCascade Resultsets
1:eac0369:                                    for the current table referential action
1:eac0369: 								   dependents tables.
1:eac0369: 		@param resultSetId  an Id which is used to store the refence
1:eac0369:                             to the temporary result set created of
1:eac0369:                             the materilized rows.Dependent table resultsets
1:eac0369: 							uses the same id to access their parent temporary result sets.
1:eac0369: 		@return the delete operation as a delete cascade result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the delete
1:eac0369: 	 */
1:eac0369: 	ResultSet getDeleteCascadeResultSet(NoPutResultSet source,
1:6b26ee1: 										int constantActionItem,
1:eac0369: 										ResultSet[] dependentResultSets, 
1:eac0369: 										String resultSetId)
1:eac0369: 							throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An update result set simply reports that it completed, and
1:eac0369: 		the number of rows updated.  It does not return rows.
1:eac0369: 		The update has been completed once the
1:eac0369: 		update result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			updated in the target table. This result set must contain 
1:eac0369: 			a column which provides RowLocations that are valid in the 
1:eac0369: 			target table, and new values to be placed in those rows.
1:ca28065: 		@param generationClauses	The code to compute column generation clauses if any
1:eac0369: 		@param checkGM	The code to enforce the check constraints, if any
1:eac0369: 		@return the update operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the update
1:eac0369: 	 */
1:ca28065: 	ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
1:ca28065: 								 GeneratedMethod checkGM)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * @param source the result set from which to take rows to be 
1:eac0369:      *               updated in the target table.
1:eac0369:      * @return the update operation as a result set.
1:eac0369:      * @exception StandardException thrown on error
1:eac0369: 	 */
1:93ff8cc: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An update result set simply reports that it completed, and
1:eac0369: 		the number of rows updated.  It does not return rows.
1:eac0369: 		The update has been completed once the
1:eac0369: 		update result set is available.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			updated in the target table. This result set must contain 
1:eac0369: 			a column which provides RowLocations that are valid in the 
1:eac0369: 			target table, and new values to be placed in those rows.
1:ca28065: 		@param generationClauses	The code to compute generated columns, if any
1:eac0369: 		@param checkGM	The code to enforce the check constraints, if any
1:eac0369: 		@param constantActionItem a constant action saved object reference
1:eac0369: 		@param rsdItem   result Description, saved object id. 				
1:eac0369: 		@return the update operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the update
1:eac0369: 	 */
1:eac0369: 	ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source, 
1:ca28065: 								 GeneratedMethod generationClauses,
3:eac0369: 								 GeneratedMethod checkGM,
1:eac0369: 								 int constantActionItem,
1:eac0369: 								 int rsdItem)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A call statement result set simply reports that it completed.  
1:eac0369: 		It does not return rows.
1:eac0369: 
1:eac0369: 		@param methodCall a reference to a method in the activation
1:eac0369: 			  for the method call
1:eac0369: 		@param activation the activation for this result set
1:eac0369: 
1:eac0369: 		@return the call statement operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to perform the call statement
1:eac0369: 	 */
1:eac0369: 	ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
7:eac0369: 				Activation activation) 
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Query expression operations
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A project restrict result set iterates over its source,
1:eac0369: 		evaluating a restriction and when it is satisfied,
1:eac0369: 		constructing a row to return in its result set based on
1:eac0369: 		its projection.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param restriction a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to determine whether the restriction is satisfied or not.
1:eac0369: 			The signature of this method is
7:eac0369: 			<verbatim>
1:eac0369: 				Boolean restriction() throws StandardException;
7:eac0369: 			</verbatim>
1:eac0369: 		@param projection a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to project out the expected result row.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				ExecRow projection() throws StandardException;
1:eac0369: 			</verbatim>
2:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param constantRestriction a reference to a method in the activation
1:eac0369: 			that represents a constant expression (eg where 1 = 2).
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				Boolean restriction() throws StandardException;
1:eac0369: 			</verbatim>
2:eac0369: 		@param mapArrayItem	Item # for mapping of source to target columns
1:1d0c809:         @param cloneMapItem Item # for columns that need cloning
1:1d0c809:         @param reuseResult  Whether or not to reuse the result row.
1:eac0369: 		@param doesProjection	Whether or not this PRN does a projection
1:af1c18c:         @param validatingCheckConstraint {@code true if this PRN is used to
1:af1c18c:             for validating a deferred check constraint}.
1:f6d02c9:         @param validatingBaseTableUUIDString The uuid for the table being
1:af1c18c:             validated.
3:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
3:eac0369: 											optimizer
2:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the project restrict operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
1:6b26ee1: 		GeneratedMethod restriction, 
1:eac0369: 		GeneratedMethod projection, int resultSetNumber,
1:eac0369: 		GeneratedMethod constantRestriction,
1:eac0369: 		int mapArrayItem,
1:1d0c809:         int cloneMapItem,
1:6b50965: 		boolean reuseResult,
1:eac0369: 		boolean doesProjection,
1:af1c18c:         boolean validatingCheckConstraint,
1:f6d02c9:         String validatingBaseTableUUIDString,
2:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A hash table result set builds a hash table on its source,
1:eac0369: 		applying a list of predicates, if any, to the source,
1:eac0369: 		when building the hash table.  It then does a look up into
1:eac0369: 		the hash table on a probe.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param singleTableRestriction restriction, if any, applied to
1:eac0369: 			input of hash table.
1:eac0369: 		@param equijoinQualifiers Qualifier[] for look up into hash table
1:eac0369: 		@param projection a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to project out the expected result row.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				ExecRow projection() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:6b50965: 		@param mapRefItem	Item # for mapping of source to target columns
2:eac0369: 		@param reuseResult	Whether or not to reuse the result row.
1:eac0369: 		@param keyColItem	Item for hash key column array
1:eac0369: 		@param removeDuplicates	Whether or not to remove duplicates when building the hash table
1:eac0369: 		@param maxInMemoryRowCount			Max size of in-memory hash table
1:eac0369: 		@param initialCapacity				initialCapacity for java.util.HashTable
1:eac0369: 		@param loadFactor					loadFactor for java.util.HashTable
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the project restrict operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
1:93ff8cc: 		GeneratedMethod singleTableRestriction, 
1:eac0369: 		Qualifier[][] equijoinQualifiers,
1:eac0369: 		GeneratedMethod projection, int resultSetNumber,
1:eac0369: 		int mapRefItem,
1:eac0369: 		boolean reuseResult,
1:eac0369: 		int keyColItem,
1:eac0369: 		boolean removeDuplicates,
1:eac0369: 		long maxInMemoryRowCount,
1:eac0369: 		int	initialCapacity,
1:eac0369: 		float loadFactor,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost)
1:eac0369: 			 throws StandardException;
1:7a9ce7e: 
1:af1c18c: 	/**
1:eac0369: 		A sort result set sorts its source and if requested removes
1:eac0369: 		duplicates.  It will generate the entire result when open, and
1:eac0369: 		then return it a row at a time.
1:c723732: 		<p>
1:eac0369: 		If passed aggregates it will do scalar or vector aggregate
1:eac0369: 		processing.  A list of aggregator information is passed
1:eac0369: 		off of the PreparedStatement's savedObjects.  Aggregation
1:eac0369: 		and SELECT DISTINCT cannot be processed in the same sort.
1:7a9ce7e: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param distinct true if distinct SELECT list
1:eac0369: 		@param isInSortedOrder	true if the source result set is in sorted order
3:eac0369: 		@param orderItem entry in preparedStatement's savedObjects for order
1:d868eed: 		@param rowAllocator a reference to a saved object
1:eac0369: 			that generates rows of the right size and shape for the source
1:eac0369: 		@param rowSize the size of the row that is allocated by rowAllocator.
1:eac0369: 			size should be the maximum size of the sum of all the datatypes.
1:eac0369: 			user type are necessarily approximated
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the distinct operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getSortResultSet(NoPutResultSet source,
1:eac0369: 		boolean distinct, 
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int orderItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int rowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 			throws StandardException;
1:c723732: 
1:7a9ce7e: 	/**
1:eac0369: 		A ScalarAggregateResultSet computes non-distinct scalar aggregates.
1:eac0369: 		It will compute the aggregates when open.
1:c723732: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param isInSortedOrder	true if the source result set is in sorted order
1:eac0369: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1:eac0369: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
1:d868eed: 		@param rowAllocator     a reference to a saved object
1:eac0369: 			that generates rows of the right size and shape for the source
1:eac0369: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param singleInputRow	Whether we know we have a single input row or not
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the scalar aggregation operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderingItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int rowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		boolean singleInputRow,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 			throws StandardException;
1:cbdc90c: 
1:c723732: 	/**
1:eac0369: 		A DistinctScalarAggregateResultSet computes scalar aggregates when 
1:eac0369: 		at least one of them is a distinct aggregate.
1:eac0369: 		It will compute the aggregates when open.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param isInSortedOrder	true if the source result set is in sorted order
1:eac0369: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1:6b50965: 		@param orderingItem entry in preparedStatement's savedObjects for order
1:d868eed: 		@param rowAllocator a reference to a saved object
1:eac0369: 			that generates rows of the right size and shape for the source
1:eac0369: 		@param rowSize the size of the row that is allocated by rowAllocator.
1:eac0369: 			size should be the maximum size of the sum of all the datatypes.
1:eac0369: 			user type are necessarily approximated
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param singleInputRow	Whether we know we have a single input row or not
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the scalar aggregation operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderingItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int rowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		boolean singleInputRow,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 			throws StandardException;
1:eac0369: 
1:cbdc90c: 	/**
1:eac0369: 		A GroupedAggregateResultSet computes non-distinct grouped aggregates.
1:eac0369: 		It will compute the aggregates when open.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param isInSortedOrder	true if the source result set is in sorted order
1:eac0369: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1:eac0369: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
1:d868eed: 		@param rowAllocator     a reference to a saved object
1:eac0369: 			that generates rows of the right size and shape for the source
1:eac0369: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:b5105f3: 		@param isRollup true if this is a GROUP BY ROLLUP()
1:eac0369: 		@return the scalar aggregation operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderingItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int rowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:b5105f3: 		double optimizerEstimatedCost,
1:b5105f3: 		boolean isRollup) 
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A DistinctGroupedAggregateResultSet computes scalar aggregates when 
1:eac0369: 		at least one of them is a distinct aggregate.
1:eac0369: 		It will compute the aggregates when open.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param isInSortedOrder	true if the source result set is in sorted order
1:eac0369: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1:6b50965: 		@param orderingItem entry in preparedStatement's savedObjects for order
1:d868eed: 		@param rowAllocator a reference to a saved object
1:eac0369: 			that generates rows of the right size and shape for the source
1:eac0369: 		@param rowSize the size of the row that is allocated by rowAllocator.
1:eac0369: 			size should be the maximum size of the sum of all the datatypes.
1:eac0369: 			user type are necessarily approximated
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:b5105f3: 		@param isRollup true if this is a GROUP BY ROLLUP()
1:eac0369: 		@return the scalar aggregation operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
1:eac0369: 		boolean isInSortedOrder,
1:eac0369: 		int aggregateItem,
1:eac0369: 		int orderingItem,
1:d868eed: 		int rowAllocator,
1:eac0369: 		int rowSize,
1:eac0369: 		int resultSetNumber, 
1:eac0369: 		double optimizerEstimatedRowCount,
1:b5105f3: 		double optimizerEstimatedCost,
1:b5105f3: 		boolean isRollup) 
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An any result set iterates over its source,
1:eac0369: 		returning a row with all columns set to nulls
1:eac0369: 		if the source returns no rows.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param emptyRowFun a reference to a method in the activation
1:eac0369: 			that is called if the source returns no rows
1:eac0369: 		@param resultSetNumber		The resultSetNumber for the ResultSet
1:eac0369: 		@param subqueryNumber		The subquery number for this subquery.
1:eac0369: 		@param pointOfAttachment	The point of attachment for this subquery.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the any operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getAnyResultSet(NoPutResultSet source,
1:6b26ee1: 		GeneratedMethod emptyRowFun, int resultSetNumber,
1:eac0369: 		int subqueryNumber, int pointOfAttachment,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A once result set iterates over its source,
1:dbed020: 		raising an error if the source returns &gt; 1 row and
1:eac0369: 		returning a row with all columns set to nulls
1:eac0369: 		if the source returns no rows.
1:eac0369: 
1:eac0369: 		@param source the result set from which to take rows to be 
1:eac0369: 			filtered by this operation.
1:eac0369: 		@param emptyRowFun a reference to a method in the activation
1:eac0369: 			that is called if the source returns no rows
1:eac0369: 		@param cardinalityCheck The type of cardinality check, if any that
1:eac0369: 			is required
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param subqueryNumber		The subquery number for this subquery.
1:eac0369: 		@param pointOfAttachment	The point of attachment for this subquery.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the once operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getOnceResultSet(NoPutResultSet source,
1:6b26ee1: 		GeneratedMethod emptyRowFun,
1:eac0369: 		int cardinalityCheck, int resultSetNumber, 
1:eac0369: 		int subqueryNumber, int pointOfAttachment,
1:eac0369: 		double optimizerEstimatedRowCount,
1:9e6e461: 		double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A row result set forms a result set on a single, known row value.
1:eac0369: 		It is used to turn constant rows into result sets for use in
1:eac0369: 		the result set paradigm.
1:eac0369: 		The row can be constructed when it is requested from the
1:eac0369: 		result set.
1:eac0369: 
21:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			against which the row operation is performed to
1:eac0369: 			create the result set.
2:eac0369: 		@param row a reference to a method in the activation
1:eac0369: 			that creates the expected row.
1:eac0369: 			<verbatim>
2:eac0369: 				ExecRow row() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param canCacheRow	True if execution can cache the input row
1:eac0369: 			after it has gotten it.  If the input row is constructed soley
1:eac0369: 			of constants or parameters, it is ok to cache this row rather
1:eac0369: 			than recreating it each time it is requested.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the row as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row, 
1:eac0369: 							  boolean canCacheRow,
1:eac0369: 							  int resultSetNumber,
1:eac0369: 							  double optimizerEstimatedRowCount,
1:9e6e461: 							  double optimizerEstimatedCost)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A VTI result set wraps a user supplied result set.
1:eac0369: 
1:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			against which the row operation is performed to
1:eac0369: 			create the result set.
1:d868eed: 		@param row a reference to a saved object
1:eac0369: 			that creates the expected row.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param constructor		The GeneratedMethod for the user's constructor
1:eac0369: 		@param javaClassName	The java class name for the VTI
1:a2d0847: 		@param erdNumber		int for referenced column BitSet (so it can be turned back into an object)
1:eac0369: 		@param version2			Whether or not VTI is a version 2 VTI.
1:eac0369: 		@param isTarget			Whether or not VTI is a target VTI.
1:a2d0847: 		@param optimizerEstimatedRowCount	Estimated total # of rows by optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:4aef9b0: 		@param isDerbyStyleTableFunction    True if this is a Derby-style table function
1:a2d0847: 		@param returnTypeNumber	Which saved object contains the return type (a multi-set) serialized as a byte array
1:a2d0847: 		@param vtiProjectionNumber	Which saved object contains the projection for a RestrictedVTI
1:a2d0847: 		@param vtiRestrictionNumber	Which saved object contains the restriction for a RestrictedVTI
1:29007f0:         @param   vtiSchema   Name of the schema holding the table function.
1:29007f0:         @param   vtiName      Name of the table function.
1:eac0369: 		@return the row as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:d868eed: 	public NoPutResultSet getVTIResultSet(Activation activation, int row,
1:eac0369: 									 int resultSetNumber,
1:eac0369: 									 GeneratedMethod constructor,
1:eac0369: 									 String javaClassName,
1:eac0369: 									 Qualifier[][] pushedQualifiers,
1:c723732: 									 int erdNumber,
1:eac0369: 									 boolean version2, boolean reuseablePs,
1:eac0369: 									 int ctcNumber,
1:eac0369: 									 boolean isTarget,
1:eac0369: 									 int scanIsolationLevel,
1:eac0369: 									 double optimizerEstimatedRowCount,
1:4aef9b0: 									 double optimizerEstimatedCost,
1:f432362:                                      boolean isDerbyStyleTableFunction,
1:a2d0847:                                      int returnTypeNumber,
1:a2d0847:                                      int vtiProjectionNumber,
1:29007f0:                                      int vtiRestrictionNumber,
1:29007f0:                                      String vtiSchema,
1:29007f0:                                      String vtiName
1:4aef9b0:                                           )
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A hash result set forms a result set on a hash table built on a scan
1:eac0369: 		of a table.
1:eac0369: 		The rows are put into the hash table on the 1st open.
2:eac0369: 		<p>
1:eac0369: 
1:eac0369: 		@param activation the activation for this result set,
6:eac0369: 			which provides the context for the row allocation operation.
1:93ff8cc: 		@param conglomId the conglomerate of the table to be scanned.
1:93ff8cc: 		@param scociItem The saved item for the static conglomerate info.
1:959fef2:         @param resultRowTemplate The saved item for result row template.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param startKeyGetter a reference to a method in the activation
1:eac0369: 			that gets the start key indexable row for the scan.  Null
1:eac0369: 			means there is no start key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow startKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param startSearchOperator The start search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param stopKeyGetter	a reference to a method in the activation
1:eac0369: 			that gets the stop key indexable row for the scan.  Null means
1:eac0369: 			there is no stop key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow stopKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param stopSearchOperator	The stop search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1:eac0369: 										(Exact match search.)
1:eac0369: 		@param scanQualifiers the array of Qualifiers for the scan.
1:eac0369: 			Null or an array length of zero means there are no qualifiers.
1:eac0369: 		@param nextQualifiers the array of Qualifiers for the look up into the hash table.
1:eac0369: 		@param initialCapacity	The initialCapacity for the HashTable.
1:eac0369: 		@param loadFactor		The loadFactor for the HashTable.
1:eac0369: 		@param maxCapacity		The maximum size for the HashTable.
1:eac0369: 		@param hashKeyColumn	The 0-based column # for the hash key.
1:eac0369: 		@param tableName		The full name of the table 
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@param indexName		The name of the index, if one used to access table.
1:eac0369: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1:eac0369: 		@param forUpdate		True means open for update
1:eac0369: 		@param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 								are referenced in the underlying table.  -1 if
2:eac0369: 								no item.
1:eac0369: 		@param lockMode			The lock granularity to use (see
1:eac0369: 								TransactionController in access)
1:eac0369: 		@param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 								(in sys.systables)
1:eac0369: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the table scan operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getHashScanResultSet(
1:c723732: 			                    Activation activation,
1:eac0369: 								long conglomId,
1:93ff8cc: 								int scociItem,						
1:959fef2: 								int resultRowTemplate,
1:eac0369: 								int resultSetNumber,
1:eac0369: 								GeneratedMethod startKeyGetter,
1:eac0369: 								int startSearchOperator,
1:eac0369: 								GeneratedMethod stopKeyGetter,
1:eac0369: 								int stopSearchOperator,
1:eac0369: 								boolean sameStartStopPosition,
1:eac0369: 								Qualifier[][] scanQualifiers,
1:eac0369: 								Qualifier[][] nextQualifiers,
1:eac0369: 								int initialCapacity,
1:eac0369: 								float loadFactor,
1:eac0369: 								int maxCapacity,
1:eac0369: 								int hashKeyColumn,
1:eac0369: 								String tableName,
1:c7248d5: 								String userSuppliedOptimizerOverrides,
1:eac0369: 								String indexName,
1:eac0369: 								boolean isConstraint,
2:eac0369: 								boolean forUpdate,
1:eac0369: 								int colRefItem,
1:eac0369: 								int indexColItem,
1:eac0369: 								int lockMode,
1:eac0369: 								boolean tableLocked,
1:eac0369: 								int isolationLevel,
1:eac0369: 								double optimizerEstimatedRowCount,
1:9e6e461: 								double optimizerEstimatedCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A distinct scan result set pushes duplicate elimination into
1:eac0369: 		the scan.
1:eac0369: 		<p>
1:eac0369: 
1:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			which provides the context for the row allocation operation.
1:93ff8cc: 		@param conglomId the conglomerate of the table to be scanned.
1:93ff8cc: 		@param scociItem The saved item for the static conglomerate info.
1:959fef2:         @param resultRowTemplate The saved item for result row template.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param hashKeyColumn	The 0-based column # for the hash key.
1:eac0369: 		@param tableName		The full name of the table
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@param indexName		The name of the index, if one used to access table.
1:eac0369: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1:eac0369: 		@param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 								are referenced in the underlying table.  -1 if
1:eac0369: 								no item.
1:eac0369: 		@param lockMode			The lock granularity to use (see
1:eac0369: 								TransactionController in access)
1:eac0369: 		@param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 								(in sys.systables)
1:eac0369: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the table scan operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getDistinctScanResultSet(
1:93ff8cc: 			                    Activation activation,
1:eac0369: 								long conglomId,
1:93ff8cc: 								int scociItem,			
1:959fef2: 								int resultRowTemplate,
1:eac0369: 								int resultSetNumber,
1:eac0369: 								int hashKeyColumn,
1:eac0369: 								String tableName,
1:c7248d5: 								String userSuppliedOptimizerOverrides,
1:eac0369: 								String indexName,
1:eac0369: 								boolean isConstraint,
1:eac0369: 								int colRefItem,
1:eac0369: 								int lockMode,
1:eac0369: 								boolean tableLocked,
1:eac0369: 								int isolationLevel,
1:eac0369: 								double optimizerEstimatedRowCount,
1:9e6e461: 								double optimizerEstimatedCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A table scan result set forms a result set on a scan
1:eac0369: 		of a table.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 		<p>
1:eac0369: 		This form of the table scan operation is simple, and is
1:eac0369: 		to be used when there are no predicates to be passed down
1:eac0369: 		to the scan to limit its scope on the target table.
1:eac0369: 
4:eac0369: 		@param conglomId the conglomerate of the table to be scanned.
5:eac0369: 		@param scociItem The saved item for the static conglomerate info.
1:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			which provides the context for the row allocation operation.
1:959fef2:         @param resultRowTemplate The saved item for result row template.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param startKeyGetter a reference to a method in the activation
1:eac0369: 			that gets the start key indexable row for the scan.  Null
1:eac0369: 			means there is no start key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow startKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param startSearchOperator The start search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param stopKeyGetter	a reference to a method in the activation
1:eac0369: 			that gets the stop key indexable row for the scan.  Null means
1:eac0369: 			there is no stop key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow stopKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param stopSearchOperator	The stop search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1:eac0369: 										(Exact match search.)
1:eac0369: 		@param qualifiers the array of Qualifiers for the scan.
1:eac0369: 			Null or an array length of zero means there are no qualifiers.
1:eac0369: 		@param tableName		The full name of the table
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@param indexName		The name of the index, if one used to access table.
1:eac0369: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1:eac0369: 		@param forUpdate		True means open for update
1:eac0369: 		@param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 								are referenced in the underlying table.  -1 if
1:eac0369: 								no item.
1:eac0369: 		@param lockMode			The lock granularity to use (see
1:eac0369: 								TransactionController in access)
1:eac0369: 		@param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 								(in sys.systables)
1:eac0369: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 		@param oneRowScan		Whether or not this is a 1 row scan.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 
1:eac0369: 		@return the table scan operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:af1c18c:     NoPutResultSet getValidateCheckConstraintResultSet(
1:af1c18c:                                 Activation activation,
1:af1c18c:                                 long conglomId,
1:af1c18c:                                 int scociItem,
1:af1c18c:                                 int resultRowTemplate,
1:af1c18c:                                 int resultSetNumber,
1:af1c18c:                                 GeneratedMethod startKeyGetter,
1:af1c18c:                                 int startSearchOperator,
1:af1c18c:                                 GeneratedMethod stopKeyGetter,
1:af1c18c:                                 int stopSearchOperator,
1:af1c18c:                                 boolean sameStartStopPosition,
1:af1c18c:                                 Qualifier[][] qualifiers,
1:af1c18c:                                 String tableName,
1:af1c18c:                                 String userSuppliedOptimizerOverrides,
1:af1c18c:                                 String indexName,
1:af1c18c:                                 boolean isConstraint,
1:af1c18c:                                 boolean forUpdate,
1:af1c18c:                                 int colRefItem,
1:af1c18c:                                 int indexColItem,
1:af1c18c:                                 int lockMode,
1:af1c18c:                                 boolean tableLocked,
1:af1c18c:                                 int isolationLevel,
1:af1c18c:                                 boolean oneRowScan,
1:af1c18c:                                 double optimizerEstimatedRowCount,
1:af1c18c:                                 double optimizerEstimatedCost)
1:af1c18c:             throws StandardException;
1:af1c18c: 
1:eac0369: 	NoPutResultSet getTableScanResultSet(
1:93ff8cc: 			                    Activation activation,
1:eac0369: 								long conglomId,
4:eac0369: 								int scociItem,
1:959fef2: 								int resultRowTemplate,
1:eac0369: 								int resultSetNumber,
1:eac0369: 								GeneratedMethod startKeyGetter,
1:eac0369: 								int startSearchOperator,
1:eac0369: 								GeneratedMethod stopKeyGetter,
1:eac0369: 								int stopSearchOperator,
1:eac0369: 								boolean sameStartStopPosition,
1:eac0369: 								Qualifier[][] qualifiers,
1:eac0369: 								String tableName,
1:c7248d5: 								String userSuppliedOptimizerOverrides,
1:eac0369: 								String indexName,
1:eac0369: 								boolean isConstraint,
1:eac0369: 								boolean forUpdate,
1:eac0369: 								int colRefItem,
1:eac0369: 								int indexColItem,
1:eac0369: 								int lockMode,
1:eac0369: 								boolean tableLocked,
1:eac0369: 								int isolationLevel,
1:eac0369: 								boolean oneRowScan,
1:eac0369: 								double optimizerEstimatedRowCount,
1:9e6e461: 								double optimizerEstimatedCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369: 		A table scan result set forms a result set on a scan
1:eac0369: 		of a table.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 		<p>
1:eac0369: 		This form of the table scan operation is simple, and is
1:eac0369: 		to be used when there are no predicates to be passed down
1:eac0369: 		to the scan to limit its scope on the target table.
1:eac0369: 
1:eac0369: 		@param conglomId the conglomerate of the table to be scanned.
1:eac0369: 		@param scociItem The saved item for the static conglomerate info.
1:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			which provides the context for the row allocation operation.
1:959fef2:         @param resultRowTemplate The saved item for result row template.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param startKeyGetter a reference to a method in the activation
1:eac0369: 			that gets the start key indexable row for the scan.  Null
1:eac0369: 			means there is no start key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow startKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param startSearchOperator The start search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param stopKeyGetter	a reference to a method in the activation
1:eac0369: 			that gets the stop key indexable row for the scan.  Null means
1:eac0369: 			there is no stop key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow stopKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param stopSearchOperator	The stop search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1:eac0369: 										(Exact match search.)
1:eac0369: 		@param qualifiers the array of Qualifiers for the scan.
1:eac0369: 			Null or an array length of zero means there are no qualifiers.
1:eac0369: 		@param tableName		The full name of the table
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@param indexName		The name of the index, if one used to access table.
1:eac0369: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1:eac0369: 		@param forUpdate		True means open for update
1:eac0369: 		@param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 								are referenced in the underlying table.  -1 if
1:eac0369: 								no item.
1:eac0369: 		@param lockMode			The lock granularity to use (see
1:eac0369: 								TransactionController in access)
1:eac0369: 		@param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 								(in sys.systables)
1:eac0369: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 		@param rowsPerRead		The number of rows to read per fetch.
1:ec6fcf1:         @param disableForHoldable Whether or not bulk fetch should be disabled
1:ec6fcf1:                                   at runtime if the cursor is holdable.
1:eac0369: 		@param oneRowScan		Whether or not this is a 1 row scan.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 
1:eac0369: 		@return the table scan operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getBulkTableScanResultSet(
1:93ff8cc: 			                    Activation activation,
1:eac0369: 								long conglomId,
1:eac0369: 								int scociItem,
1:959fef2: 								int resultRowTemplate,
1:eac0369: 								int resultSetNumber,
1:eac0369: 								GeneratedMethod startKeyGetter,
1:eac0369: 								int startSearchOperator,
1:eac0369: 								GeneratedMethod stopKeyGetter,
1:eac0369: 								int stopSearchOperator,
1:eac0369: 								boolean sameStartStopPosition,
1:eac0369: 								Qualifier[][] qualifiers,
1:eac0369: 								String tableName,
1:c7248d5: 								String userSuppliedOptimizerOverrides,
1:eac0369: 								String indexName,
1:eac0369: 								boolean isConstraint,
1:eac0369: 								boolean forUpdate,
1:eac0369: 								int colRefItem,
1:eac0369: 								int indexColItem,
1:eac0369: 								int lockMode,
1:eac0369: 								boolean tableLocked,
1:eac0369: 								int isolationLevel,
1:eac0369: 								int rowsPerRead,
1:ec6fcf1:                                 boolean disableForHoldable,
1:eac0369: 								boolean oneRowScan,
1:eac0369: 								double optimizerEstimatedRowCount,
1:9e6e461: 								double optimizerEstimatedCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:cbdc90c: 		A multi-probe result set, used for probing an index with one or more
1:cbdc90c: 		target values (probeValues) and returning the matching rows.  This
1:cbdc90c: 		type of result set is useful for IN lists as it allows us to avoid
1:cbdc90c: 		scannning an entire, potentially very large, index for a mere handful
1:cbdc90c: 		of rows (DERBY-47).
1:cbdc90c: 
1:cbdc90c: 		All arguments are the same as for TableScanResultSet, plus the
1:cbdc90c: 		following:
1:cbdc90c: 
1:cbdc90c: 		@param probeVals List of values with which to probe the underlying
1:cbdc90c: 			table. Should not be null.
1:20bd3c0: 		@param sortRequired Which type of sort we need for the values
1:20bd3c0: 			(ascending, descending, or none).
1:cbdc90c: 	 */
1:cbdc90c: 	NoPutResultSet getMultiProbeTableScanResultSet(
1:cbdc90c: 			                    Activation activation,
1:cbdc90c: 								long conglomId,
1:cbdc90c: 								int scociItem,
1:959fef2: 								int resultRowTemplate,
1:cbdc90c: 								int resultSetNumber,
1:cbdc90c: 								GeneratedMethod startKeyGetter,
1:cbdc90c: 								int startSearchOperator,
1:cbdc90c: 								GeneratedMethod stopKeyGetter,
1:cbdc90c: 								int stopSearchOperator,
1:cbdc90c: 								boolean sameStartStopPosition,
1:cbdc90c: 								Qualifier[][] qualifiers,
1:cbdc90c: 								DataValueDescriptor [] probeVals,
1:20bd3c0: 								int sortRequired,
1:cbdc90c: 								String tableName,
1:cbdc90c: 								String userSuppliedOptimizerOverrides,
1:cbdc90c: 								String indexName,
1:cbdc90c: 								boolean isConstraint,
1:cbdc90c: 								boolean forUpdate,
1:cbdc90c: 								int colRefItem,
1:cbdc90c: 								int indexColItem,
1:cbdc90c: 								int lockMode,
1:cbdc90c: 								boolean tableLocked,
1:cbdc90c: 								int isolationLevel,
1:cbdc90c: 								boolean oneRowScan,
1:cbdc90c: 								double optimizerEstimatedRowCount,
1:cbdc90c: 								double optimizerEstimatedCost)
1:cbdc90c: 			throws StandardException;
1:cbdc90c: 
1:eac0369: 	/**
1:eac0369: 		An index row to base row result set gets an index row from its source
1:eac0369: 		and uses the RowLocation in its last column to get the row from the
1:eac0369: 		base conglomerate.
1:eac0369: 		<p>
1:eac0369: 
1:eac0369: 	    @param conglomId	Conglomerate # for the heap.
1:6b50965: 		@param scoci The saved item for the static conglomerate info.
1:c723732: 		@param source	the source result set, which is expected to provide
1:eac0369: 						rows from an index conglomerate
6:eac0369: 		@param resultRowAllocator a reference to a method in the activation
3:eac0369: 			that creates a holder for the rows from the scan.
1:eac0369: 			<verbatim>
6:eac0369: 				ExecRow rowAllocator() throws StandardException;
1:eac0369: 			</verbatim>
1:c723732: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param indexName		The name of the index.
1:eac0369: 		@param heapColRefItem	A saved item for a bitImpl of columns that
1:eac0369: 								are referenced in the underlying heap.  -1 if
1:eac0369: 								no item.
1:6853511: 		@param allColRefItem A saved item for a bitImpl of columns
1:6853511: 								that are referenced in the underlying
1:6853511: 								index and heap.  -1 if no item.
1:6853511: 		@param heapOnlyColRefItem A saved item for a bitImpl of
1:6853511: 								columns that are referenced in the
1:6853511: 								underlying heap only.  -1 if no item.
1:6853511: 
1:eac0369: 		@param indexColMapItem	A saved item for a ReferencedColumnsDescriptorImpl
1:eac0369: 								which tell  which columms are coming from the index.
1:c723732: 		@param restriction		The restriction, if any, to be applied to the base row
1:eac0369: 		@param forUpdate		True means to open for update
1:c723732: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:c723732: 											optimizer
1:c723732: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:1705596: 		@param baseColumnCount		Number of columns in the base table
1:c723732: 
1:eac0369: 		@return the index row to base row operation as a result set.
1:c723732: 		@exception StandardException thrown when unable to create the
1:c723732: 			result set
1:c723732: 	 */
1:eac0369: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
1:eac0369: 								long conglomId,
1:eac0369: 								int scoci,
1:c723732: 								NoPutResultSet source,
1:bda7291: 								int resultRowAllocator,
1:c723732: 								int resultSetNumber,
1:eac0369: 								String indexName,
1:eac0369: 								int heapColRefItem,
1:6853511: 								int allColRefItem,
1:6853511: 								int heapOnlyColRefItem,
1:eac0369: 								int indexColMapItem,
1:c723732: 								GeneratedMethod restriction,
1:eac0369: 								boolean forUpdate,
1:c723732: 								double optimizerEstimatedRowCount,
1:1705596: 								double optimizerEstimatedCost,
1:1705596: 								int baseColumnCount )
1:c723732: 			throws StandardException;
1:c723732: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:7a9ce7e: 	   A OLAP window on top of a regular result set. It is used to realize
1:7a9ce7e: 	   window functions.
1:7a9ce7e: 	   <p>
1:7a9ce7e: 	   @param activation   Activation
1:7a9ce7e: 	   @param source       The result set input to this result set.
1:d868eed: 	   @param rowAllocator A reference to a saved object
1:7a9ce7e: 			               that generates rows of the right size and
1:7a9ce7e: 						   shape for the source.
1:7a9ce7e: 	   @param resultSetNumber The resultSetNumber for the ResultSet
1:7a9ce7e: 	   @param erdNumber    Int for ResultDescription
1:7a9ce7e: 	                       (so it can be turned back into an object)
1:7a9ce7e: 	   @param restriction  The restriction, if any, to be applied to the
1:7a9ce7e: 	                       base row
1:7a9ce7e: 	   @param optimizerEstimatedRowCount
1:7a9ce7e:                            Estimated total # of rows by optimizer
1:7a9ce7e: 	   @param optimizerEstimatedCost
1:7a9ce7e:                            Estimated total cost by optimizer
1:7a9ce7e: 	   @throws StandardException
1:7a9ce7e: 	 */
1:7a9ce7e: 	public NoPutResultSet getWindowResultSet(
1:7a9ce7e: 								Activation activation,
1:7a9ce7e: 								NoPutResultSet source,
1:d868eed: 								int rowAllocator,
1:7a9ce7e: 								int resultSetNumber,
1:7a9ce7e: 								int erdNumber,
1:7a9ce7e: 								GeneratedMethod restriction,
1:7a9ce7e: 								double optimizerEstimatedRowCount,
1:7a9ce7e: 								double optimizerEstimatedCost)
1:7a9ce7e: 			throws StandardException;
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 
1:eac0369: 	/**
1:eac0369: 		A nested loop left outer join result set forms a result set on top of
1:eac0369: 		2 other result sets.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 		<p>
1:eac0369: 		This form of the nested loop join operation is simple, and is
1:eac0369: 		to be used when there are no join predicates to be passed down
1:eac0369: 		to the join to limit its scope on the right ResultSet.
1:eac0369: 
1:eac0369: 		@param leftResultSet	Outer ResultSet for join.
1:eac0369: 		@param leftNumCols		Number of columns in the leftResultSet
1:eac0369: 		@param rightResultSet	Inner ResultSet for join.
1:eac0369: 		@param rightNumCols		Number of columns in the rightResultSet
1:eac0369: 		@param joinClause a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to determine whether the joinClause is satisfied or not.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				Boolean joinClause() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param oneRowRightSide	boolean, whether or not the right side returns
1:eac0369: 								a single row.  (No need to do 2nd next() if it does.)
1:eac0369: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1:eac0369: 									NOT EXISTS base table
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@return the nested loop join operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
17:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A hash join.
1:eac0369: 
1:eac0369: 		@param leftResultSet	Outer ResultSet for join.
1:eac0369: 		@param leftNumCols		Number of columns in the leftResultSet
1:eac0369: 		@param rightResultSet	Inner ResultSet for join.
1:eac0369: 		@param rightNumCols		Number of columns in the rightResultSet
1:eac0369: 		@param joinClause a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to determine whether the joinClause is satisfied or not.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				Boolean joinClause() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param oneRowRightSide	boolean, whether or not the right side returns
1:eac0369: 								a single row.  (No need to do 2nd next() if it does.)
1:eac0369: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1:eac0369: 									NOT EXISTS base table
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@return the nested loop join operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A nested loop join result set forms a result set on top of
1:eac0369: 		2 other result sets.
1:eac0369: 		The rows can be constructed as they are requested from the
1:eac0369: 		result set.
1:eac0369: 		<p>
1:eac0369: 		This form of the nested loop join operation is simple, and is
1:eac0369: 		to be used when there are no join predicates to be passed down
1:eac0369: 		to the join to limit its scope on the right ResultSet.
1:eac0369: 
1:eac0369: 		@param leftResultSet	Outer ResultSet for join.
1:eac0369: 		@param leftNumCols		Number of columns in the leftResultSet
1:eac0369: 		@param rightResultSet	Inner ResultSet for join.
1:eac0369: 		@param rightNumCols		Number of columns in the rightResultSet
1:eac0369: 		@param joinClause a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to determine whether the joinClause is satisfied or not.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				Boolean joinClause() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param emptyRowFun a reference to a method in the activation
1:eac0369: 							that is called if the right child returns no rows
1:eac0369: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
1:eac0369: 		@param oneRowRightSide	boolean, whether or not the right side returns
1:eac0369: 								a single row.  (No need to do 2nd next() if it does.)
1:eac0369: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1:eac0369: 									NOT EXISTS base table
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@return the nested loop join operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   GeneratedMethod emptyRowFun,
1:eac0369: 								   boolean wasRightOuterJoin,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A left outer join using a hash join.
1:eac0369: 
1:eac0369: 		@param leftResultSet	Outer ResultSet for join.
1:eac0369: 		@param leftNumCols		Number of columns in the leftResultSet
1:eac0369: 		@param rightResultSet	Inner ResultSet for join.
1:eac0369: 		@param rightNumCols		Number of columns in the rightResultSet
1:eac0369: 		@param joinClause a reference to a method in the activation
1:eac0369: 			that is applied to the activation's "current row" field
1:eac0369: 			to determine whether the joinClause is satisfied or not.
1:eac0369: 			The signature of this method is
1:eac0369: 			<verbatim>
1:eac0369: 				Boolean joinClause() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param emptyRowFun a reference to a method in the activation
1:eac0369: 							that is called if the right child returns no rows
1:eac0369: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
1:eac0369: 		@param oneRowRightSide	boolean, whether or not the right side returns
1:eac0369: 								a single row.  (No need to do 2nd next() if it does.)
1:eac0369: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1:eac0369: 									NOT EXISTS base table
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@return the nested loop join operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1:eac0369: 								   int leftNumCols,
1:eac0369: 								   NoPutResultSet rightResultSet,
1:eac0369: 								   int rightNumCols,
1:eac0369: 								   GeneratedMethod joinClause,
1:eac0369: 								   int resultSetNumber,
1:eac0369: 								   GeneratedMethod emptyRowFun,
1:eac0369: 								   boolean wasRightOuterJoin,
1:eac0369: 								   boolean oneRowRightSide,
1:eac0369: 								   boolean notExistsRightSide,
1:eac0369: 								   double optimizerEstimatedRowCount,
1:eac0369: 								   double optimizerEstimatedCost,
1:9e6e461: 								   String userSuppliedOptimizerOverrides)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A ResultSet which materializes the underlying ResultSet tree into a 
1:eac0369: 		temp table on the 1st open.  All subsequent "scans" of this ResultSet
1:eac0369: 		will return results from the temp table.
1:eac0369: 
1:eac0369: 		@param source the result set input to this result set.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the materialization operation as a result set.
1:eac0369: 
1:eac0369: 	 	@exception StandardException		Thrown on failure
1:eac0369: 	 */
1:6b26ee1: 	NoPutResultSet getMaterializedResultSet(NoPutResultSet source, 
1:eac0369: 											int resultSetNumber,
1:eac0369: 											double optimizerEstimatedRowCount,
1:c723732: 											double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A ResultSet which provides the insensitive scrolling functionality
1:eac0369: 		for the underlying result set by materializing the underlying ResultSet 
1:eac0369: 		tree into a hash table while scrolling forward.
1:eac0369: 
1:eac0369: 		@param source the result set input to this result set.
1:eac0369: 		@param activation the activation for this result set,
3:eac0369: 			which provides the context for normalization.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param sourceRowWidth	The # of columns in the source row.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the materialization operation as a result set.
1:eac0369: 
1:eac0369: 	 	@exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source, Activation activation, 
1:eac0369: 											int resultSetNumber,
1:eac0369: 											int sourceRowWidth,
1:eac0369: 											boolean scrollable,
1:eac0369: 											double optimizerEstimatedRowCount,
1:9e6e461: 											double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		REMIND: needs more description...
1:eac0369: 
1:eac0369: 		@param source the result set input to this result set.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param erdNumber	int for ResultDescription 
2:eac0369: 							(so it can be turned back into an object)
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 		@return the normalization operation as a result set.
1:eac0369: 
1:eac0369: 	 	@exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getNormalizeResultSet(NoPutResultSet source, 
1:eac0369: 										 int resultSetNumber, int erdNumber,
1:eac0369: 										 double optimizerEstimatedRowCount,
1:eac0369: 										 double optimizerEstimatedCost,
1:9e6e461: 										 boolean forUpdate) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A current of result set forms a result set on the
1:eac0369: 		current row of an open cursor.
1:eac0369: 		It is used to perform positioned operations such as
1:eac0369: 		positioned update and delete, using the result set paradigm.
1:eac0369: 
1:eac0369: 		@param cursorName the name of the cursor providing the row.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getCurrentOfResultSet(String cursorName, Activation activation, 
1:ec08288: 									int resultSetNumber);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The Union interface is used to evaluate the union (all) of two ResultSets.
1:eac0369: 	 * (Any duplicate elimination is performed above this ResultSet.)
1:eac0369: 	 *
1:eac0369: 	 * Forms a ResultSet returning the union of the rows in two source
1:eac0369: 	 * ResultSets.  The column types in source1 and source2 are assumed to be
1:eac0369: 	 * the same.
1:eac0369: 	 *
1:eac0369: 	 * @param source1	The first ResultSet whose rows go into the union
1:eac0369: 	 * @param source2	The second ResultSet whose rows go into the
1:eac0369: 	 *			union
1:eac0369: 	 *	@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 	 *	@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 	 *										optimizer
1:eac0369: 	 *	@param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 	 *
1:eac0369: 	 * @return	A ResultSet from which the caller can get the union
1:eac0369: 	 *		of the two source ResultSets.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet	getUnionResultSet(NoPutResultSet source1,
1:eac0369: 					NoPutResultSet source2,
1:eac0369: 					int resultSetNumber,
1:eac0369: 					double optimizerEstimatedRowCount,
1:9e6e461: 					double optimizerEstimatedCost)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:6200b38:      * The SetOpResultSet is used to implement an INTERSECT or EXCEPT operation.
1:6200b38:      * It selects rows from two ordered input result sets.
1:6200b38:      *
1:6200b38:      * @param leftSource The result set that implements the left input
1:6200b38:      * @param rightSource The result set that implements the right input
1:eac0369:      * @param activation the activation for this result set
1:6200b38:      * @param resultSetNumber
1:6200b38:      * @param optimizerEstimatedRowCount
1:6200b38:      * @param optimizerEstimatedCost
1:6200b38:      * @param opType IntersectOrExceptNode.INTERSECT_OP or EXCEPT_OP
1:6200b38:      * @param all true if the operation is an INTERSECT ALL or an EXCEPT ALL,
1:6200b38:      *            false if the operation is an INTERSECT DISCTINCT or an EXCEPT DISCTINCT
1:6200b38:      * @param intermediateOrderByColumnsSavedObject The saved object index for the array of order by columns for the
1:6200b38:      *        ordering of the left and right sources. That is, both the left and right sources have an order by
1:6200b38:      *        clause of the form ORDER BY intermediateOrderByColumns[0],intermediateOrderByColumns[1],...
1:6200b38:      * @param intermediateOrderByDirectionSavedObject The saved object index for the array of source
1:6200b38:      *        order by directions. That is, the ordering of the i'th order by column in the input is ascending
1:6200b38:      *        if intermediateOrderByDirection[i] is 1, descending if intermediateOrderByDirection[i] is -1.
1:6200b38: 	 *
1:6200b38: 	 * @return	A ResultSet from which the caller can get the INTERSECT or EXCEPT
1:6200b38: 	 *
1:6200b38: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:6200b38:     NoPutResultSet getSetOpResultSet( NoPutResultSet leftSource,
1:6200b38:                                       NoPutResultSet rightSource,
1:93ff8cc:                                       Activation activation, 
1:eac0369:                                       int resultSetNumber,
1:6200b38:                                       long optimizerEstimatedRowCount,
1:eac0369:                                       double optimizerEstimatedCost,
1:6200b38:                                       int opType,
1:6200b38:                                       boolean all,
1:6200b38:                                       int intermediateOrderByColumnsSavedObject,
1:cc30c0c:                                       int intermediateOrderByDirectionSavedObject,
1:cc30c0c:                                       int intermediateOrderByNullsLowSavedObject)
1:eac0369:         throws StandardException;
1:eac0369:                                                      
1:eac0369:                                                      
1:eac0369: 	//
1:eac0369: 	// Misc operations
1:eac0369: 	//
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * A last index key result set returns the last row from
1:eac0369: 	 * the index in question.  It is used as an ajunct to max().
1:eac0369: 	 *
1:eac0369: 	 * @param activation 		the activation for this result set,
1:eac0369: 	 *		which provides the context for the row allocation operation.
1:eac0369: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
1:959fef2:      * @param resultRowTemplate The saved item for result row template
1:eac0369: 	 * @param conglomId 		the conglomerate of the table to be scanned.
1:eac0369: 	 * @param tableName			The full name of the table
1:c7248d5: 	 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 	 * @param indexName			The name of the index, if one used to access table.
1:eac0369: 	 * @param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 	 *							are referenced in the underlying table.  -1 if
1:eac0369: 	 *							no item.
1:eac0369: 	 * @param lockMode			The lock granularity to use (see
1:eac0369: 	 *							TransactionController in access)
1:eac0369: 	 * @param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 	 *							(in sys.systables)
1:eac0369: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 	 * 										optimizer
1:eac0369: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
1:eac0369: 	 *
1:eac0369: 	 * @return the scan operation as a result set.
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException thrown when unable to create the
1:eac0369: 	 * 				result set
1:eac0369: 	 */
1:eac0369: 	NoPutResultSet getLastIndexKeyResultSet
1:eac0369: 	(
1:eac0369: 		Activation 			activation,
1:eac0369: 		int 				resultSetNumber,
1:959fef2:         int                 resultRowTemplate,
1:eac0369: 		long 				conglomId,
1:eac0369: 		String 				tableName,
1:c7248d5: 		String 				userSuppliedOptimizerOverrides,
1:eac0369: 		String 				indexName,
1:eac0369: 		int 				colRefItem,
1:eac0369: 		int 				lockMode,
1:eac0369: 		boolean				tableLocked,
1:eac0369: 		int					isolationLevel,
1:eac0369: 		double				optimizerEstimatedRowCount,
1:9e6e461: 		double 				optimizerEstimatedCost
1:eac0369: 	) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A Dependent table scan result set forms a result set on a scan
1:959fef2: 		of a dependent table for the rows that got materialized
1:eac0369: 		on the scan of its parent table and if the row being deleted
1:eac0369: 		on parent table has a reference in the dependent table.
1:eac0369: 
1:eac0369: 		@param activation the activation for this result set,
1:eac0369: 			which provides the context for the row allocation operation.
1:93ff8cc: 		@param conglomId the conglomerate of the table to be scanned.
1:93ff8cc: 		@param scociItem The saved item for the static conglomerate info.
1:959fef2:         @param resultRowTemplate The saved item for result row template.
1:eac0369: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1:eac0369: 		@param startKeyGetter a reference to a method in the activation
1:eac0369: 			that gets the start key indexable row for the scan.  Null
1:eac0369: 			means there is no start key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow startKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param startSearchOperator The start search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param stopKeyGetter	a reference to a method in the activation
1:eac0369: 			that gets the stop key indexable row for the scan.  Null means
1:eac0369: 			there is no stop key.
1:eac0369: 			<verbatim>
1:eac0369: 				ExecIndexRow stopKeyGetter() throws StandardException;
1:eac0369: 			</verbatim>
1:eac0369: 		@param stopSearchOperator	The stop search operator for opening
1:eac0369: 			the scan
1:eac0369: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1:eac0369: 										(Exact match search.)
1:eac0369: 		@param qualifiers the array of Qualifiers for the scan.
1:eac0369: 			Null or an array length of zero means there are no qualifiers.
1:eac0369: 		@param tableName		The full name of the table
1:c7248d5: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
1:eac0369: 		@param indexName		The name of the index, if one used to access table.
1:eac0369: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1:eac0369: 		@param forUpdate		True means open for update
1:eac0369: 		@param colRefItem		An saved item for a bitSet of columns that
1:eac0369: 								are referenced in the underlying table.  -1 if
1:eac0369: 								no item.
1:eac0369: 		@param lockMode			The lock granularity to use (see
1:eac0369: 								TransactionController in access)
1:eac0369: 		@param tableLocked		Whether or not the table is marked as using table locking
1:eac0369: 								(in sys.systables)
1:eac0369: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1:eac0369: 		@param oneRowScan		Whether or not this is a 1 row scan.
1:eac0369: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1:eac0369: 											optimizer
1:eac0369: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1:959fef2: 		@param parentResultSetId  Id to access the materialized temporary result
1:959fef2:                             	  set from the reference stored in the activation.
1:eac0369: 		@param fkIndexConglomId foreign key index conglomerate id.
1:eac0369: 		@param fkColArrayItem  saved column array object  that matches the foreign key index
1:eac0369: 		                       columns  and the resultset from the parent table.
1:eac0369: 		@param  rltItem row location template
1:eac0369: 
1:eac0369: 		@return the table scan operation as a result set.
1:eac0369: 		@exception StandardException thrown when unable to create the
1:eac0369: 			result set
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet getRaDependentTableScanResultSet(
1:93ff8cc: 			                        Activation activation,
1:eac0369: 									long conglomId,
1:93ff8cc: 									int scociItem,							
1:959fef2: 									int resultRowTemplate,
1:eac0369: 									int resultSetNumber,
1:eac0369: 									GeneratedMethod startKeyGetter,
1:eac0369: 									int startSearchOperator,
1:eac0369: 									GeneratedMethod stopKeyGetter,
1:eac0369: 									int stopSearchOperator,
1:eac0369: 									boolean sameStartStopPosition,
1:eac0369: 									Qualifier[][] qualifiers,
1:eac0369: 									String tableName,
1:c7248d5: 									String userSuppliedOptimizerOverrides,
1:eac0369: 									String indexName,
1:eac0369: 									boolean isConstraint,
1:eac0369: 									boolean forUpdate,
1:eac0369: 									int colRefItem,
1:eac0369: 									int indexColItem,
1:eac0369: 									int lockMode,
1:eac0369: 									boolean tableLocked,
1:eac0369: 									int isolationLevel,
1:eac0369: 									boolean oneRowScan,
1:eac0369: 									double optimizerEstimatedRowCount,
1:eac0369: 									double optimizerEstimatedCost,
1:eac0369: 									String parentResultSetId,
1:eac0369: 									long fkIndexConglomId,
1:eac0369: 									int fkColArrayItem,
1:eac0369: 									int rltItem)
1:eac0369: 		throws StandardException;
1:69a192a: 
1:69a192a: 
1:69a192a: 	/**
1:69a192a: 	 * This result sets implements the filtering needed by <result offset
1:69a192a: 	 * clause> and <fetch first clause>. It is only ever generated if at least
1:69a192a: 	 * one of the two clauses is present.
1:69a192a: 	 *
1:69a192a: 	 * @param source          The source result set being filtered
1:69a192a: 	 * @param activation      The activation for this result set,
1:69a192a: 	 *		                  which provides the context for the row
1:69a192a: 	 *                        allocation operation
1:69a192a: 	 * @param resultSetNumber The resultSetNumber for the ResultSet
1:00c7a20: 	 * @param offsetMethod   The OFFSET parameter was specified
1:57c1b5c: 	 * @param fetchFirstMethod The FETCH FIRST/NEXT parameter was specified
1:57c1b5c: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses were added by JDBC LIMIT escape syntax
1:69a192a: 	 * @param optimizerEstimatedRowCount
1:69a192a: 	 *                        Estimated total # of rows by optimizer
1:69a192a: 	 * @param optimizerEstimatedCost
1:69a192a: 	 *                        Estimated total cost by optimizer
1:69a192a: 	 * @exception StandardException Standard error policy
1:69a192a: 	 */
1:69a192a: 
1:69a192a: 	public NoPutResultSet getRowCountResultSet(
1:69a192a: 		NoPutResultSet source,
1:69a192a: 		Activation activation,
1:69a192a: 		int resultSetNumber,
1:00c7a20: 		GeneratedMethod offsetMethod,
1:00c7a20: 		GeneratedMethod fetchFirstMethod,
1:57c1b5c:         boolean hasJDBClimitClause,
1:69a192a: 		double optimizerEstimatedRowCount,
1:69a192a: 		double optimizerEstimatedCost) throws StandardException;
1:69a192a: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		raising an error if the source returns &gt; 1 row and
commit:1705596
/////////////////////////////////////////////////////////////////////////
1: 		@param baseColumnCount		Number of columns in the base table
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost,
1: 								int baseColumnCount )
commit:29007f0
/////////////////////////////////////////////////////////////////////////
1:         @param   vtiSchema   Name of the schema holding the table function.
1:         @param   vtiName      Name of the table function.
/////////////////////////////////////////////////////////////////////////
1:                                      int vtiRestrictionNumber,
1:                                      String vtiSchema,
1:                                      String vtiName
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: 		A MERGE result set simply reports that it completed, and
1: 		the number of rows that it INSERTed/UPDATEd/DELETEdd.  It does not return rows.
1: 		The delete has been completed once the
1: 		MERGE result set is available.
1: 
1: 		@param drivingLeftJoin the result set from which to take rows to
1: 			be drive the INSERT/UPDATE/DELETE operations.
1: 		@return the MERGE operation as a result set.
1: 		@exception StandardException thrown when unable to perform the work
1: 	 */
1: 	ResultSet getMergeResultSet(NoPutResultSet drivingLeftJoin)
1: 							throws StandardException;
1: 
1: 	/**
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1: 	 * @param fetchFirstMethod The FETCH FIRST/NEXT parameter was specified
1: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses were added by JDBC LIMIT escape syntax
/////////////////////////////////////////////////////////////////////////
1:         boolean hasJDBClimitClause,
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
1: 		@param erdNumber		int for referenced column BitSet (so it can be turned back into an object)
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by optimizer
1: 		@param returnTypeNumber	Which saved object contains the return type (a multi-set) serialized as a byte array
1: 		@param vtiProjectionNumber	Which saved object contains the projection for a RestrictedVTI
1: 		@param vtiRestrictionNumber	Which saved object contains the restriction for a RestrictedVTI
/////////////////////////////////////////////////////////////////////////
1:                                      int returnTypeNumber,
1:                                      int vtiProjectionNumber,
0:                                      int vtiRestrictionNumber
commit:ca28065
/////////////////////////////////////////////////////////////////////////
1: 		@param generationClauses	The code to compute column generation clauses if any
1: 	ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
1: 								 GeneratedMethod checkGM)
/////////////////////////////////////////////////////////////////////////
1: 		@param generationClauses	The code to compute generated columns, if any
/////////////////////////////////////////////////////////////////////////
1: 								 GeneratedMethod generationClauses,
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
1: 		@param generationClauses	The code to compute column generation clauses if any
1: 	ResultSet getInsertResultSet(NoPutResultSet source, GeneratedMethod generationClauses,
/////////////////////////////////////////////////////////////////////////
0: 	ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod checkGM)
commit:f432362
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		@param returnType The name of the return type (a multi-set) as a string
/////////////////////////////////////////////////////////////////////////
1:                                      boolean isDerbyStyleTableFunction,
0:                                      String returnType
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: 		@param isDerbyStyleTableFunction    True if this is a Derby-style table function
/////////////////////////////////////////////////////////////////////////
1: 									 double optimizerEstimatedCost,
0: 									 boolean isDerbyStyleTableFunction
1:                                           )
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1:         @param validatingBaseTableUUIDString The uuid for the table being
/////////////////////////////////////////////////////////////////////////
1:         String validatingBaseTableUUIDString,
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:         @param schemaNameName schema name of table
1:         @param tableName table name
1:                                  GeneratedMethod checkGM, int fullTemplate,
1:                                  String schemaNameName,
1:                                  String tableName)
/////////////////////////////////////////////////////////////////////////
1:         @param validatingCheckConstraint {@code true if this PRN is used to
1:             for validating a deferred check constraint}.
0:         @param validatingBaseTableCID The conglomerate id for the table being
1:             validated.
/////////////////////////////////////////////////////////////////////////
1:         boolean validatingCheckConstraint,
0:         long validatingBaseTableCID,
/////////////////////////////////////////////////////////////////////////
1:     NoPutResultSet getValidateCheckConstraintResultSet(
1:                                 Activation activation,
1:                                 long conglomId,
1:                                 int scociItem,
1:                                 int resultRowTemplate,
1:                                 int resultSetNumber,
1:                                 GeneratedMethod startKeyGetter,
1:                                 int startSearchOperator,
1:                                 GeneratedMethod stopKeyGetter,
1:                                 int stopSearchOperator,
1:                                 boolean sameStartStopPosition,
1:                                 Qualifier[][] qualifiers,
1:                                 String tableName,
1:                                 String userSuppliedOptimizerOverrides,
1:                                 String indexName,
1:                                 boolean isConstraint,
1:                                 boolean forUpdate,
1:                                 int colRefItem,
1:                                 int indexColItem,
1:                                 int lockMode,
1:                                 boolean tableLocked,
1:                                 int isolationLevel,
1:                                 boolean oneRowScan,
1:                                 double optimizerEstimatedRowCount,
1:                                 double optimizerEstimatedCost)
1:             throws StandardException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
1:         @param cloneMapItem Item # for columns that need cloning
1:         @param reuseResult  Whether or not to reuse the result row.
/////////////////////////////////////////////////////////////////////////
1:         int cloneMapItem,
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	   A OLAP window on top of a regular result set. It is used to realize
1: 	   window functions.
1: 	   <p>
1: 	   @param activation   Activation
1: 	   @param source       The result set input to this result set.
0: 	   @param rowAllocator A reference to a method in the activation
1: 			               that generates rows of the right size and
1: 						   shape for the source.
1: 	   @param resultSetNumber The resultSetNumber for the ResultSet
1: 	   @param erdNumber    Int for ResultDescription
1: 	                       (so it can be turned back into an object)
1: 	   @param restriction  The restriction, if any, to be applied to the
1: 	                       base row
1: 	   @param optimizerEstimatedRowCount
1:                            Estimated total # of rows by optimizer
1: 	   @param optimizerEstimatedCost
1:                            Estimated total cost by optimizer
1: 	   @throws StandardException
1: 	 */
1: 	public NoPutResultSet getWindowResultSet(
1: 								Activation activation,
1: 								NoPutResultSet source,
0: 								GeneratedMethod rowAllocator,
1: 								int resultSetNumber,
1: 								int erdNumber,
1: 								GeneratedMethod restriction,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost)
1: 			throws StandardException;
1: 
1: 
1: 
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultDescription;
/////////////////////////////////////////////////////////////////////////
commit:00c7a20
/////////////////////////////////////////////////////////////////////////
1: 	 * @param offsetMethod   The OFFSET parameter was specified
0: 	 * @param fetchFirstMethod The FETCH FIRST/NEXT parameter was
0: 	 *                        specified
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod offsetMethod,
1: 		GeneratedMethod fetchFirstMethod,
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * This result sets implements the filtering needed by <result offset
1: 	 * clause> and <fetch first clause>. It is only ever generated if at least
1: 	 * one of the two clauses is present.
1: 	 *
1: 	 * @param source          The source result set being filtered
1: 	 * @param activation      The activation for this result set,
1: 	 *		                  which provides the context for the row
1: 	 *                        allocation operation
1: 	 * @param resultSetNumber The resultSetNumber for the ResultSet
0: 	 * @param offset          The offset value (0 by default)
0: 	 * @param fetchFirst      The fetch first value (-1 if not in use)
1: 	 * @param optimizerEstimatedRowCount
1: 	 *                        Estimated total # of rows by optimizer
1: 	 * @param optimizerEstimatedCost
1: 	 *                        Estimated total cost by optimizer
1: 	 * @exception StandardException Standard error policy
1: 	 */
1: 
1: 	public NoPutResultSet getRowCountResultSet(
1: 		NoPutResultSet source,
1: 		Activation activation,
1: 		int resultSetNumber,
0: 		long offset,
0: 		long fetchFirst,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost) throws StandardException;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bda7291
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowAllocator,
commit:d868eed
/////////////////////////////////////////////////////////////////////////
1: 		@param rowAllocator a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		@param rowAllocator     a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		@param rowAllocator a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		@param rowAllocator     a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		@param rowAllocator a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 		int rowAllocator,
/////////////////////////////////////////////////////////////////////////
1: 		@param row a reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 	public NoPutResultSet getVTIResultSet(Activation activation, int row,
/////////////////////////////////////////////////////////////////////////
1: 	   @param rowAllocator A reference to a saved object
/////////////////////////////////////////////////////////////////////////
1: 								int rowAllocator,
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1:         @param fullTemplate Saved item for a row template used by bulk insert,
1:                             or -1 if this is not a bulk insert
0:                                  GeneratedMethod checkGM, int fullTemplate)
/////////////////////////////////////////////////////////////////////////
1:         @param resultRowTemplate The saved item for result row template.
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:         @param resultRowTemplate The saved item for result row template.
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:         @param resultRowTemplate The saved item for result row template.
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:         @param resultRowTemplate The saved item for result row template.
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 								int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:      * @param resultRowTemplate The saved item for result row template
/////////////////////////////////////////////////////////////////////////
1:         int                 resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 		of a dependent table for the rows that got materialized
/////////////////////////////////////////////////////////////////////////
1:         @param resultRowTemplate The saved item for result row template.
/////////////////////////////////////////////////////////////////////////
1: 		@param parentResultSetId  Id to access the materialized temporary result
1:                             	  set from the reference stored in the activation.
/////////////////////////////////////////////////////////////////////////
1: 									int resultRowTemplate,
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:         @param disableForHoldable Whether or not bulk fetch should be disabled
1:                                   at runtime if the cursor is holdable.
/////////////////////////////////////////////////////////////////////////
1:                                 boolean disableForHoldable,
commit:47e1295
/////////////////////////////////////////////////////////////////////////
0: 		@param returnTypeNumber	Which saved object contains the return type
0: 								(a multi-set) serialized as a byte array
/////////////////////////////////////////////////////////////////////////
0:                                      int returnTypeNumber
commit:6853511
/////////////////////////////////////////////////////////////////////////
1: 		@param allColRefItem A saved item for a bitImpl of columns
1: 								that are referenced in the underlying
1: 								index and heap.  -1 if no item.
1: 		@param heapOnlyColRefItem A saved item for a bitImpl of
1: 								columns that are referenced in the
1: 								underlying heap only.  -1 if no item.
1: 
/////////////////////////////////////////////////////////////////////////
1: 								int allColRefItem,
1: 								int heapOnlyColRefItem,
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: 		@param isRollup true if this is a GROUP BY ROLLUP()
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost,
1: 		boolean isRollup) 
/////////////////////////////////////////////////////////////////////////
1: 		@param isRollup true if this is a GROUP BY ROLLUP()
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost,
1: 		boolean isRollup) 
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:                                       int intermediateOrderByDirectionSavedObject,
1:                                       int intermediateOrderByNullsLowSavedObject)
author:Army
-------------------------------------------------------------------------------
commit:c723732
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         /**
0: 		A WindowResultSet is used for gathering rows from OLAP window functions.
1: 
1: 		<p>
1: 
1: 		@param source	the source result set, which is expected to provide
0: 						rows for the WindowResultSet
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param restriction		The restriction, if any, to be applied to the base row
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1: 
0: 		@return the window function as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
0: 	public NoPutResultSet getWindowResultSet(
1: 								Activation activation,
1: 								NoPutResultSet source,
0: 								GeneratedMethod rowAllocator,
1: 								int resultSetNumber,
0: 								int level,
1: 								int erdNumber,
1: 								GeneratedMethod restriction,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost)
1: 	   	throws StandardException;
1:         
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 		@param sortRequired Which type of sort we need for the values
1: 			(ascending, descending, or none).
/////////////////////////////////////////////////////////////////////////
1: 								int sortRequired,
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataValueDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		A multi-probe result set, used for probing an index with one or more
1: 		target values (probeValues) and returning the matching rows.  This
1: 		type of result set is useful for IN lists as it allows us to avoid
1: 		scannning an entire, potentially very large, index for a mere handful
1: 		of rows (DERBY-47).
1: 
1: 		All arguments are the same as for TableScanResultSet, plus the
1: 		following:
1: 
1: 		@param probeVals List of values with which to probe the underlying
1: 			table. Should not be null.
0: 		@param probeValsAreSorted Whether or not the values in probeVals are
0: 			sorted.
1: 	 */
1: 	NoPutResultSet getMultiProbeTableScanResultSet(
1: 			                    Activation activation,
1: 								long conglomId,
1: 								int scociItem,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								GeneratedMethod startKeyGetter,
1: 								int startSearchOperator,
1: 								GeneratedMethod stopKeyGetter,
1: 								int stopSearchOperator,
1: 								boolean sameStartStopPosition,
1: 								Qualifier[][] qualifiers,
1: 								DataValueDescriptor [] probeVals,
0: 								boolean probeValsAreSorted,
1: 								String tableName,
1: 								String userSuppliedOptimizerOverrides,
1: 								String indexName,
1: 								boolean isConstraint,
1: 								boolean forUpdate,
1: 								int colRefItem,
1: 								int indexColItem,
1: 								int lockMode,
1: 								boolean tableLocked,
1: 								int isolationLevel,
1: 								boolean oneRowScan,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost)
1: 			throws StandardException;
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ec08288
/////////////////////////////////////////////////////////////////////////
1: 									int resultSetNumber);
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) throws StandardException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							  double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 									 double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 											double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 											double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										 boolean forUpdate) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		double 				optimizerEstimatedCost
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
1: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod singleTableRestriction, 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
/////////////////////////////////////////////////////////////////////////
1: 			                    Activation activation,
1: 								int scociItem,						
/////////////////////////////////////////////////////////////////////////
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
/////////////////////////////////////////////////////////////////////////
1: 			                    Activation activation,
1: 								int scociItem,			
/////////////////////////////////////////////////////////////////////////
1: 			                    Activation activation,
/////////////////////////////////////////////////////////////////////////
1: 			                    Activation activation,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
/////////////////////////////////////////////////////////////////////////
1: 			                        Activation activation,
1: 									int scociItem,							
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
0: 								 GeneratedMethod checkGM)
/////////////////////////////////////////////////////////////////////////
1: 								 NoPutResultSet vtiRS)
/////////////////////////////////////////////////////////////////////////
1: 	ResultSet getDeleteVTIResultSet(NoPutResultSet source)
/////////////////////////////////////////////////////////////////////////
1: 	ResultSet getDeleteResultSet(NoPutResultSet source)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 										int constantActionItem,
/////////////////////////////////////////////////////////////////////////
0: 								 GeneratedMethod checkGM)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod restriction, 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod emptyRowFun, int resultSetNumber,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		GeneratedMethod emptyRowFun,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	NoPutResultSet getMaterializedResultSet(NoPutResultSet source, 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.execute.ResultSetFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.execute;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: /**
1:  * ResultSetFactory provides a wrapper around all of
1:  * the result sets needed in an execution implementation.
1:  * <p>
1:  * For the activations to avoid searching for this module
1:  * in their execute methods, the base activation supertype
1:  * should implement a method that does the lookup and salts
1:  * away this factory for the activation to use as it needs it.
1:  *
0:  * @author ames
1:  */
1: public interface ResultSetFactory {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 		Module name for the monitor's module locating system.
1: 	 */
1: 	String MODULE = "org.apache.derby.iapi.sql.execute.ResultSetFactory";
1: 
1: 	//
1: 	// DDL operations
1: 	//
1: 
1: 	/**
1: 	    Generic DDL result set creation.
1: 
1: 		@param activation 		the activation for this result set
1: 
1: 		@return	ResultSet	A wrapper result set to run the Execution-time
1: 		                        logic.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	ResultSet getDDLResultSet(Activation activation)
1: 					throws StandardException;
1: 
1: 
1: 	//
1: 	// MISC operations
1: 	//
1: 
1: 	/**
1: 	    Generic Misc result set creation.
1: 
1: 		@param activation 		the activation for this result set
1: 
1: 		@return	ResultSet	A wrapper result set to run the Execution-time
1: 		                        logic.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	ResultSet getMiscResultSet(Activation activation)
1: 					throws StandardException;
1: 
1: 	//
1: 	// Transaction operations
1: 	//
1: 	/**
1: 
1: 		@param activation 		the activation for this result set
1: 
1: 		@return	ResultSet	A wrapper result set to run the Execution-time
1: 		                        logic.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	ResultSet getSetTransactionResultSet(Activation activation) 
1: 		throws StandardException;
1: 
1: 	//
1: 	// DML statement operations
1: 	//
1: 	/**
1: 		An insert result set simply reports that it completed, and
1: 		the number of rows inserted.  It does not return rows.
1: 		The insert has been completed once the
1: 		insert result set is available.
1: 
1: 		@param source the result set from which to take rows to
1: 			be inserted into the target table.
1: 		@param checkGM	The code to enforce the check constraints, if any
1: 		@param activation the activation for this result set,
1: 		@return the insert operation as a result set.
1: 		@exception StandardException thrown when unable to perform the insert
1: 	 */
0: 	ResultSet getInsertResultSet(NoPutResultSet source, 
1: 								 GeneratedMethod checkGM,
1: 							     Activation activation)
1:         throws StandardException;
1: 
1: 	/**
1: 		An insert VTI result set simply reports that it completed, and
1: 		the number of rows inserted.  It does not return rows.
1: 		The insert has been completed once the
1: 		insert result set is available.
1: 
1: 		@param source the result set from which to take rows to
1: 			be inserted into the target table.
1: 		@param vtiRS	The code to instantiate the VTI, if necessary
1: 		@param activation the activation for this result set,
1: 		@return the insert VTI operation as a result set.
1: 		@exception StandardException thrown when unable to perform the insert
1: 	 */
1: 	ResultSet getInsertVTIResultSet(NoPutResultSet source, 
0: 								 NoPutResultSet vtiRS,
1: 							     Activation activation)
1:         throws StandardException;
1: 
1: 	/**
1: 		A delete VTI result set simply reports that it completed, and
1: 		the number of rows deleted.  It does not return rows.
1: 		The delete has been completed once the
1: 		delete result set is available.
1: 
1: 		@param source the result set from which to take rows to
1: 			be inserted into the target table.
1: 		@param activation the activation for this result set,
1: 		@return the delete VTI operation as a result set.
1: 		@exception StandardException thrown when unable to perform the insert
1: 	 */
0: 	ResultSet getDeleteVTIResultSet(NoPutResultSet source, 
1: 							     Activation activation)
1:         throws StandardException;
1: 
1: 	/**
1: 		A delete result set simply reports that it completed, and
1: 		the number of rows deleted.  It does not return rows.
1: 		The delete has been completed once the
1: 		delete result set is available.
1: 
1: 		@param source the result set from which to take rows to
1: 			be deleted from the target table. This result set must
1: 			contain one column which provides RowLocations that are
1: 			valid in the target table.
1: 		@param activation 		the activation for this result set
1: 		@return the delete operation as a result set.
1: 		@exception StandardException thrown when unable to perform the delete
1: 	 */
0: 	ResultSet getDeleteResultSet(NoPutResultSet source,
1: 								 Activation activation)
1: 							throws StandardException;
1: 
1: 	/**
1: 		A delete Cascade result set simply reports that it completed, and
1: 		the number of rows deleted.  It does not return rows.
1: 		The delete has been completed once the
1: 		delete result set is available.
1: 
1: 		@param source the result set from which to take rows to
1: 			be deleted from the target table.
1: 		@param activation 		the activation for this result set
1: 		@param constantActionItem a constant action saved object reference
1: 		@param dependentResultSets an array of DeleteCascade Resultsets
1:                                    for the current table referential action
1: 								   dependents tables.
1: 		@param resultSetId  an Id which is used to store the refence
1:                             to the temporary result set created of
1:                             the materilized rows.Dependent table resultsets
1: 							uses the same id to access their parent temporary result sets.
1: 		@return the delete operation as a delete cascade result set.
1: 		@exception StandardException thrown when unable to perform the delete
1: 	 */
1: 	ResultSet getDeleteCascadeResultSet(NoPutResultSet source,
0: 										Activation activation, int constantActionItem,
1: 										ResultSet[] dependentResultSets, 
1: 										String resultSetId)
1: 							throws StandardException;
1: 
1: 	/**
1: 		An update result set simply reports that it completed, and
1: 		the number of rows updated.  It does not return rows.
1: 		The update has been completed once the
1: 		update result set is available.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			updated in the target table. This result set must contain 
1: 			a column which provides RowLocations that are valid in the 
1: 			target table, and new values to be placed in those rows.
1: 		@param checkGM	The code to enforce the check constraints, if any
1: 		@param activation 		the activation for this result set
1: 		@return the update operation as a result set.
1: 		@exception StandardException thrown when unable to perform the update
1: 	 */
0: 	ResultSet getUpdateResultSet(NoPutResultSet source, 
1: 								 GeneratedMethod checkGM,
1: 							     Activation activation)
1:         throws StandardException;
1: 
1: 	/**
1:      * @param source the result set from which to take rows to be 
1:      *               updated in the target table.
0:      * @param vtiRS the updateable result set for the VTI
1:      * @param activation the activation for this result set
1:      * @return the update operation as a result set.
1:      * @exception StandardException thrown on error
1: 	 */
0: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source,
1:                                            Activation activation)
1:         throws StandardException;
1: 
1: 	/**
1: 		An update result set simply reports that it completed, and
1: 		the number of rows updated.  It does not return rows.
1: 		The update has been completed once the
1: 		update result set is available.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			updated in the target table. This result set must contain 
1: 			a column which provides RowLocations that are valid in the 
1: 			target table, and new values to be placed in those rows.
1: 		@param checkGM	The code to enforce the check constraints, if any
1: 		@param activation 		the activation for this result set
1: 		@param constantActionItem a constant action saved object reference
1: 		@param rsdItem   result Description, saved object id. 				
1: 		@return the update operation as a result set.
1: 		@exception StandardException thrown when unable to perform the update
1: 	 */
1: 	ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source, 
1: 								 GeneratedMethod checkGM,
0: 							     Activation activation,
1: 								 int constantActionItem,
1: 								 int rsdItem)
1:         throws StandardException;
1: 
1: 	/**
1: 		A call statement result set simply reports that it completed.  
1: 		It does not return rows.
1: 
1: 		@param methodCall a reference to a method in the activation
1: 			  for the method call
1: 		@param activation the activation for this result set
1: 
1: 		@return the call statement operation as a result set.
1: 		@exception StandardException thrown when unable to perform the call statement
1: 	 */
1: 	ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
1: 				Activation activation) 
1: 			throws StandardException;
1: 
1: 	//
1: 	// Query expression operations
1: 	//
1: 
1: 	/**
1: 		A project restrict result set iterates over its source,
1: 		evaluating a restriction and when it is satisfied,
1: 		constructing a row to return in its result set based on
1: 		its projection.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
1: 		@param restriction a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to determine whether the restriction is satisfied or not.
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean restriction() throws StandardException;
1: 			</verbatim>
1: 		@param projection a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to project out the expected result row.
1: 			The signature of this method is
1: 			<verbatim>
1: 				ExecRow projection() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param constantRestriction a reference to a method in the activation
1: 			that represents a constant expression (eg where 1 = 2).
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean restriction() throws StandardException;
1: 			</verbatim>
1: 		@param mapArrayItem	Item # for mapping of source to target columns
1: 		@param reuseResult	Whether or not to reuse the result row.
1: 		@param doesProjection	Whether or not this PRN does a projection
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the project restrict operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod restriction, 
1: 		GeneratedMethod projection, int resultSetNumber,
1: 		GeneratedMethod constantRestriction,
1: 		int mapArrayItem,
0: 		boolean resuseResult,
1: 		boolean doesProjection,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) throws StandardException;
1: 
1: 	/**
1: 		A hash table result set builds a hash table on its source,
1: 		applying a list of predicates, if any, to the source,
1: 		when building the hash table.  It then does a look up into
1: 		the hash table on a probe.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
1: 		@param singleTableRestriction restriction, if any, applied to
1: 			input of hash table.
1: 		@param equijoinQualifiers Qualifier[] for look up into hash table
1: 		@param projection a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to project out the expected result row.
1: 			The signature of this method is
1: 			<verbatim>
1: 				ExecRow projection() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param mapArrayItem	Item # for mapping of source to target columns
1: 		@param reuseResult	Whether or not to reuse the result row.
1: 		@param keyColItem	Item for hash key column array
1: 		@param removeDuplicates	Whether or not to remove duplicates when building the hash table
1: 		@param maxInMemoryRowCount			Max size of in-memory hash table
1: 		@param initialCapacity				initialCapacity for java.util.HashTable
1: 		@param loadFactor					loadFactor for java.util.HashTable
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the project restrict operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod singleTableRestriction, 
1: 		Qualifier[][] equijoinQualifiers,
1: 		GeneratedMethod projection, int resultSetNumber,
1: 		int mapRefItem,
1: 		boolean reuseResult,
1: 		int keyColItem,
1: 		boolean removeDuplicates,
1: 		long maxInMemoryRowCount,
1: 		int	initialCapacity,
1: 		float loadFactor,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			 throws StandardException;
1: 
1: 	/**
1: 		A sort result set sorts its source and if requested removes
1: 		duplicates.  It will generate the entire result when open, and
1: 		then return it a row at a time.
1: 		<p>
1: 		If passed aggregates it will do scalar or vector aggregate
1: 		processing.  A list of aggregator information is passed
1: 		off of the PreparedStatement's savedObjects.  Aggregation
1: 		and SELECT DISTINCT cannot be processed in the same sort.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param distinct true if distinct SELECT list
1: 		@param isInSortedOrder	true if the source result set is in sorted order
1: 		@param orderItem entry in preparedStatement's savedObjects for order
1: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
1: 			that generates rows of the right size and shape for the source
1: 		@param rowSize the size of the row that is allocated by rowAllocator.
1: 			size should be the maximum size of the sum of all the datatypes.
1: 			user type are necessarily approximated
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the distinct operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getSortResultSet(NoPutResultSet source,
1: 		boolean distinct, 
1: 		boolean isInSortedOrder,
1: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int rowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException;
1: 
1: 	/**
1: 		A ScalarAggregateResultSet computes non-distinct scalar aggregates.
1: 		It will compute the aggregates when open.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param isInSortedOrder	true if the source result set is in sorted order
1: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
1: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
1: 			that generates rows of the right size and shape for the source
1: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param singleInputRow	Whether we know we have a single input row or not
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the scalar aggregation operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int rowSize,
1: 		int resultSetNumber, 
1: 		boolean singleInputRow,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException;
1: 
1: 	/**
1: 		A DistinctScalarAggregateResultSet computes scalar aggregates when 
1: 		at least one of them is a distinct aggregate.
1: 		It will compute the aggregates when open.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param isInSortedOrder	true if the source result set is in sorted order
1: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1: 		@param orderItem entry in preparedStatement's savedObjects for order
1: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
1: 			that generates rows of the right size and shape for the source
1: 		@param rowSize the size of the row that is allocated by rowAllocator.
1: 			size should be the maximum size of the sum of all the datatypes.
1: 			user type are necessarily approximated
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param singleInputRow	Whether we know we have a single input row or not
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the scalar aggregation operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int rowSize,
1: 		int resultSetNumber, 
1: 		boolean singleInputRow,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException;
1: 
1: 	/**
1: 		A GroupedAggregateResultSet computes non-distinct grouped aggregates.
1: 		It will compute the aggregates when open.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param isInSortedOrder	true if the source result set is in sorted order
1: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
1: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
1: 			that generates rows of the right size and shape for the source
1: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the scalar aggregation operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int rowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException;
1: 
1: 	/**
1: 		A DistinctGroupedAggregateResultSet computes scalar aggregates when 
1: 		at least one of them is a distinct aggregate.
1: 		It will compute the aggregates when open.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param isInSortedOrder	true if the source result set is in sorted order
1: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
1: 		@param orderItem entry in preparedStatement's savedObjects for order
1: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
1: 			that generates rows of the right size and shape for the source
1: 		@param rowSize the size of the row that is allocated by rowAllocator.
1: 			size should be the maximum size of the sum of all the datatypes.
1: 			user type are necessarily approximated
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the scalar aggregation operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
1: 		boolean isInSortedOrder,
1: 		int aggregateItem,
1: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
1: 		int rowSize,
1: 		int resultSetNumber, 
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
1: 			throws StandardException;
1: 
1: 	/**
1: 		An any result set iterates over its source,
1: 		returning a row with all columns set to nulls
1: 		if the source returns no rows.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
1: 		@param emptyRowFun a reference to a method in the activation
1: 			that is called if the source returns no rows
1: 		@param resultSetNumber		The resultSetNumber for the ResultSet
1: 		@param subqueryNumber		The subquery number for this subquery.
1: 		@param pointOfAttachment	The point of attachment for this subquery.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1: 		@return the any operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getAnyResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun, int resultSetNumber,
1: 		int subqueryNumber, int pointOfAttachment,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		A once result set iterates over its source,
0: 		raising an error if the source returns > 1 row and
1: 		returning a row with all columns set to nulls
1: 		if the source returns no rows.
1: 
1: 		@param source the result set from which to take rows to be 
1: 			filtered by this operation.
1: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
1: 		@param emptyRowFun a reference to a method in the activation
1: 			that is called if the source returns no rows
1: 		@param cardinalityCheck The type of cardinality check, if any that
1: 			is required
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param subqueryNumber		The subquery number for this subquery.
1: 		@param pointOfAttachment	The point of attachment for this subquery.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
1: 		@return the once operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getOnceResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun,
1: 		int cardinalityCheck, int resultSetNumber, 
1: 		int subqueryNumber, int pointOfAttachment,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		A row result set forms a result set on a single, known row value.
1: 		It is used to turn constant rows into result sets for use in
1: 		the result set paradigm.
1: 		The row can be constructed when it is requested from the
1: 		result set.
1: 
1: 		@param activation the activation for this result set,
1: 			against which the row operation is performed to
1: 			create the result set.
1: 		@param row a reference to a method in the activation
1: 			that creates the expected row.
1: 			<verbatim>
1: 				ExecRow row() throws StandardException;
1: 			</verbatim>
1: 		@param canCacheRow	True if execution can cache the input row
1: 			after it has gotten it.  If the input row is constructed soley
1: 			of constants or parameters, it is ok to cache this row rather
1: 			than recreating it each time it is requested.
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the row as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row, 
1: 							  boolean canCacheRow,
1: 							  int resultSetNumber,
1: 							  double optimizerEstimatedRowCount,
1: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod closeCleanup)
1: 		throws StandardException;
1: 
1: 	/**
1: 		A VTI result set wraps a user supplied result set.
1: 
1: 		@param activation the activation for this result set,
1: 			against which the row operation is performed to
1: 			create the result set.
1: 		@param row a reference to a method in the activation
1: 			that creates the expected row.
1: 			<verbatim>
1: 				ExecRow row() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param constructor		The GeneratedMethod for the user's constructor
1: 		@param javaClassName	The java class name for the VTI
0: 		@param erdNumber		int for referenced column BitSet 
1: 								(so it can be turned back into an object)
1: 		@param version2			Whether or not VTI is a version 2 VTI.
1: 		@param isTarget			Whether or not VTI is a target VTI.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the row as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
0: 	public NoPutResultSet getVTIResultSet(Activation activation, GeneratedMethod row,
1: 									 int resultSetNumber,
1: 									 GeneratedMethod constructor,
1: 									 String javaClassName,
1: 									 Qualifier[][] pushedQualifiers,
0: 									 int erdNumber,
1: 									 boolean version2, boolean reuseablePs,
1: 									 int ctcNumber,
1: 									 boolean isTarget,
1: 									 int scanIsolationLevel,
1: 									 double optimizerEstimatedRowCount,
1: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		A hash result set forms a result set on a hash table built on a scan
1: 		of a table.
1: 		The rows are put into the hash table on the 1st open.
1: 		<p>
1: 
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param resultRowAllocator a reference to a method in the activation
1: 			that creates a holder for the rows from the scan.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param startKeyGetter a reference to a method in the activation
1: 			that gets the start key indexable row for the scan.  Null
1: 			means there is no start key.
1: 			<verbatim>
1: 				ExecIndexRow startKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param startSearchOperator The start search operator for opening
1: 			the scan
1: 		@param stopKeyGetter	a reference to a method in the activation
1: 			that gets the stop key indexable row for the scan.  Null means
1: 			there is no stop key.
1: 			<verbatim>
1: 				ExecIndexRow stopKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param stopSearchOperator	The stop search operator for opening
1: 			the scan
1: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1: 										(Exact match search.)
1: 		@param scanQualifiers the array of Qualifiers for the scan.
1: 			Null or an array length of zero means there are no qualifiers.
1: 		@param nextQualifiers the array of Qualifiers for the look up into the hash table.
1: 		@param initialCapacity	The initialCapacity for the HashTable.
1: 		@param loadFactor		The loadFactor for the HashTable.
1: 		@param maxCapacity		The maximum size for the HashTable.
1: 		@param hashKeyColumn	The 0-based column # for the hash key.
1: 		@param tableName		The full name of the table
1: 		@param indexName		The name of the index, if one used to access table.
1: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1: 		@param forUpdate		True means open for update
1: 		@param colRefItem		An saved item for a bitSet of columns that
1: 								are referenced in the underlying table.  -1 if
1: 								no item.
1: 		@param lockMode			The lock granularity to use (see
1: 								TransactionController in access)
1: 		@param tableLocked		Whether or not the table is marked as using table locking
1: 								(in sys.systables)
1: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the table scan operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getHashScanResultSet(
1: 								long conglomId,
1: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								GeneratedMethod startKeyGetter,
1: 								int startSearchOperator,
1: 								GeneratedMethod stopKeyGetter,
1: 								int stopSearchOperator,
1: 								boolean sameStartStopPosition,
1: 								Qualifier[][] scanQualifiers,
1: 								Qualifier[][] nextQualifiers,
1: 								int initialCapacity,
1: 								float loadFactor,
1: 								int maxCapacity,
1: 								int hashKeyColumn,
1: 								String tableName,
1: 								String indexName,
1: 								boolean isConstraint,
1: 								boolean forUpdate,
1: 								int colRefItem,
1: 								int indexColItem,
1: 								int lockMode,
1: 								boolean tableLocked,
1: 								int isolationLevel,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A distinct scan result set pushes duplicate elimination into
1: 		the scan.
1: 		<p>
1: 
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param resultRowAllocator a reference to a method in the activation
1: 			that creates a holder for the rows from the scan.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param hashKeyColumn	The 0-based column # for the hash key.
1: 		@param tableName		The full name of the table
1: 		@param indexName		The name of the index, if one used to access table.
1: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1: 		@param colRefItem		An saved item for a bitSet of columns that
1: 								are referenced in the underlying table.  -1 if
1: 								no item.
1: 		@param lockMode			The lock granularity to use (see
1: 								TransactionController in access)
1: 		@param tableLocked		Whether or not the table is marked as using table locking
1: 								(in sys.systables)
1: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the table scan operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getDistinctScanResultSet(
1: 								long conglomId,
1: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								int hashKeyColumn,
1: 								String tableName,
1: 								String indexName,
1: 								boolean isConstraint,
1: 								int colRefItem,
1: 								int lockMode,
1: 								boolean tableLocked,
1: 								int isolationLevel,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A table scan result set forms a result set on a scan
1: 		of a table.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 		<p>
1: 		This form of the table scan operation is simple, and is
1: 		to be used when there are no predicates to be passed down
1: 		to the scan to limit its scope on the target table.
1: 
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param startKeyGetter a reference to a method in the activation
1: 			that gets the start key indexable row for the scan.  Null
1: 			means there is no start key.
1: 			<verbatim>
1: 				ExecIndexRow startKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param startSearchOperator The start search operator for opening
1: 			the scan
1: 		@param stopKeyGetter	a reference to a method in the activation
1: 			that gets the stop key indexable row for the scan.  Null means
1: 			there is no stop key.
1: 			<verbatim>
1: 				ExecIndexRow stopKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param stopSearchOperator	The stop search operator for opening
1: 			the scan
1: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1: 										(Exact match search.)
1: 		@param qualifiers the array of Qualifiers for the scan.
1: 			Null or an array length of zero means there are no qualifiers.
1: 		@param tableName		The full name of the table
1: 		@param indexName		The name of the index, if one used to access table.
1: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1: 		@param forUpdate		True means open for update
1: 		@param colRefItem		An saved item for a bitSet of columns that
1: 								are referenced in the underlying table.  -1 if
1: 								no item.
1: 		@param lockMode			The lock granularity to use (see
1: 								TransactionController in access)
1: 		@param tableLocked		Whether or not the table is marked as using table locking
1: 								(in sys.systables)
1: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1: 		@param oneRowScan		Whether or not this is a 1 row scan.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 
1: 		@return the table scan operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getTableScanResultSet(
1: 								long conglomId,
1: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								GeneratedMethod startKeyGetter,
1: 								int startSearchOperator,
1: 								GeneratedMethod stopKeyGetter,
1: 								int stopSearchOperator,
1: 								boolean sameStartStopPosition,
1: 								Qualifier[][] qualifiers,
1: 								String tableName,
1: 								String indexName,
1: 								boolean isConstraint,
1: 								boolean forUpdate,
1: 								int colRefItem,
1: 								int indexColItem,
1: 								int lockMode,
1: 								boolean tableLocked,
1: 								int isolationLevel,
1: 								boolean oneRowScan,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A table scan result set forms a result set on a scan
1: 		of a table.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 		<p>
1: 		This form of the table scan operation is simple, and is
1: 		to be used when there are no predicates to be passed down
1: 		to the scan to limit its scope on the target table.
1: 
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param startKeyGetter a reference to a method in the activation
1: 			that gets the start key indexable row for the scan.  Null
1: 			means there is no start key.
1: 			<verbatim>
1: 				ExecIndexRow startKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param startSearchOperator The start search operator for opening
1: 			the scan
1: 		@param stopKeyGetter	a reference to a method in the activation
1: 			that gets the stop key indexable row for the scan.  Null means
1: 			there is no stop key.
1: 			<verbatim>
1: 				ExecIndexRow stopKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param stopSearchOperator	The stop search operator for opening
1: 			the scan
1: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1: 										(Exact match search.)
1: 		@param qualifiers the array of Qualifiers for the scan.
1: 			Null or an array length of zero means there are no qualifiers.
1: 		@param tableName		The full name of the table
1: 		@param indexName		The name of the index, if one used to access table.
1: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1: 		@param forUpdate		True means open for update
1: 		@param colRefItem		An saved item for a bitSet of columns that
1: 								are referenced in the underlying table.  -1 if
1: 								no item.
1: 		@param lockMode			The lock granularity to use (see
1: 								TransactionController in access)
1: 		@param tableLocked		Whether or not the table is marked as using table locking
1: 								(in sys.systables)
1: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1: 		@param rowsPerRead		The number of rows to read per fetch.
1: 		@param oneRowScan		Whether or not this is a 1 row scan.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 
1: 		@return the table scan operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	NoPutResultSet getBulkTableScanResultSet(
1: 								long conglomId,
1: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								GeneratedMethod startKeyGetter,
1: 								int startSearchOperator,
1: 								GeneratedMethod stopKeyGetter,
1: 								int stopSearchOperator,
1: 								boolean sameStartStopPosition,
1: 								Qualifier[][] qualifiers,
1: 								String tableName,
1: 								String indexName,
1: 								boolean isConstraint,
1: 								boolean forUpdate,
1: 								int colRefItem,
1: 								int indexColItem,
1: 								int lockMode,
1: 								boolean tableLocked,
1: 								int isolationLevel,
1: 								int rowsPerRead,
1: 								boolean oneRowScan,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 	/**
1: 		An index row to base row result set gets an index row from its source
1: 		and uses the RowLocation in its last column to get the row from the
1: 		base conglomerate.
1: 		<p>
1: 
1: 	    @param conglomId	Conglomerate # for the heap.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
0: 		@param source	the source result set, which is expected to provide
1: 						rows from an index conglomerate
1: 		@param resultRowAllocator a reference to a method in the activation
1: 			that creates a holder for the rows from the scan.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param indexName		The name of the index.
1: 		@param heapColRefItem	A saved item for a bitImpl of columns that
1: 								are referenced in the underlying heap.  -1 if
1: 								no item.
0: 		@param indexColRefItem	A saved item for a bitImpl of columns that
0: 								are referenced in the underlying index.  -1 if
1: 								no item.
1: 		@param indexColMapItem	A saved item for a ReferencedColumnsDescriptorImpl
1: 								which tell  which columms are coming from the index.
0: 		@param restriction		The restriction, if any, to be applied to the base row
1: 		@param forUpdate		True means to open for update
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 
1: 		@return the index row to base row operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
1: 								long conglomId,
1: 								int scoci,
0: 								Activation a,
0: 								NoPutResultSet source,
0: 								GeneratedMethod resultRowAllocator,
1: 								int resultSetNumber,
1: 								String indexName,
1: 								int heapColRefItem,
0: 								int indexColRefItem,
1: 								int indexColMapItem,
0: 								GeneratedMethod restriction,
1: 								boolean forUpdate,
1: 								double optimizerEstimatedRowCount,
1: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A nested loop left outer join result set forms a result set on top of
1: 		2 other result sets.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 		<p>
1: 		This form of the nested loop join operation is simple, and is
1: 		to be used when there are no join predicates to be passed down
1: 		to the join to limit its scope on the right ResultSet.
1: 
1: 		@param leftResultSet	Outer ResultSet for join.
1: 		@param leftNumCols		Number of columns in the leftResultSet
1: 		@param rightResultSet	Inner ResultSet for join.
1: 		@param rightNumCols		Number of columns in the rightResultSet
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param joinClause a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to determine whether the joinClause is satisfied or not.
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean joinClause() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param oneRowRightSide	boolean, whether or not the right side returns
1: 								a single row.  (No need to do 2nd next() if it does.)
1: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1: 									NOT EXISTS base table
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the nested loop join operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation, 
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A hash join.
1: 
1: 		@param leftResultSet	Outer ResultSet for join.
1: 		@param leftNumCols		Number of columns in the leftResultSet
1: 		@param rightResultSet	Inner ResultSet for join.
1: 		@param rightNumCols		Number of columns in the rightResultSet
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param joinClause a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to determine whether the joinClause is satisfied or not.
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean joinClause() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param oneRowRightSide	boolean, whether or not the right side returns
1: 								a single row.  (No need to do 2nd next() if it does.)
1: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1: 									NOT EXISTS base table
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the nested loop join operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation, 
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 
1: 	/**
1: 		A nested loop join result set forms a result set on top of
1: 		2 other result sets.
1: 		The rows can be constructed as they are requested from the
1: 		result set.
1: 		<p>
1: 		This form of the nested loop join operation is simple, and is
1: 		to be used when there are no join predicates to be passed down
1: 		to the join to limit its scope on the right ResultSet.
1: 
1: 		@param leftResultSet	Outer ResultSet for join.
1: 		@param leftNumCols		Number of columns in the leftResultSet
1: 		@param rightResultSet	Inner ResultSet for join.
1: 		@param rightNumCols		Number of columns in the rightResultSet
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param joinClause a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to determine whether the joinClause is satisfied or not.
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean joinClause() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param emptyRowFun a reference to a method in the activation
1: 							that is called if the right child returns no rows
1: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
1: 		@param oneRowRightSide	boolean, whether or not the right side returns
1: 								a single row.  (No need to do 2nd next() if it does.)
1: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1: 									NOT EXISTS base table
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the nested loop join operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation, 
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   GeneratedMethod emptyRowFun,
1: 								   boolean wasRightOuterJoin,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A left outer join using a hash join.
1: 
1: 		@param leftResultSet	Outer ResultSet for join.
1: 		@param leftNumCols		Number of columns in the leftResultSet
1: 		@param rightResultSet	Inner ResultSet for join.
1: 		@param rightNumCols		Number of columns in the rightResultSet
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param joinClause a reference to a method in the activation
1: 			that is applied to the activation's "current row" field
1: 			to determine whether the joinClause is satisfied or not.
1: 			The signature of this method is
1: 			<verbatim>
1: 				Boolean joinClause() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param emptyRowFun a reference to a method in the activation
1: 							that is called if the right child returns no rows
1: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
1: 		@param oneRowRightSide	boolean, whether or not the right side returns
1: 								a single row.  (No need to do 2nd next() if it does.)
1: 		@param notExistsRightSide	boolean, whether or not the right side resides a
1: 									NOT EXISTS base table
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the nested loop join operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
1: 								   int leftNumCols,
1: 								   NoPutResultSet rightResultSet,
1: 								   int rightNumCols,
0: 								   Activation activation, 
1: 								   GeneratedMethod joinClause,
1: 								   int resultSetNumber,
1: 								   GeneratedMethod emptyRowFun,
1: 								   boolean wasRightOuterJoin,
1: 								   boolean oneRowRightSide,
1: 								   boolean notExistsRightSide,
1: 								   double optimizerEstimatedRowCount,
1: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
1: 			throws StandardException;
1: 
1: 	/**
1: 		A ResultSet which materializes the underlying ResultSet tree into a 
1: 		temp table on the 1st open.  All subsequent "scans" of this ResultSet
1: 		will return results from the temp table.
1: 
1: 		@param source the result set input to this result set.
1: 		@param activation the activation for this result set,
1: 			which provides the context for normalization.
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the materialization operation as a result set.
1: 
1: 	 	@exception StandardException		Thrown on failure
1: 	 */
0: 	NoPutResultSet getMaterializedResultSet(NoPutResultSet source, Activation activation, 
1: 											int resultSetNumber,
1: 											double optimizerEstimatedRowCount,
1: 											double optimizerEstimatedCost,
0: 										   GeneratedMethod closeCleanup) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		A ResultSet which provides the insensitive scrolling functionality
1: 		for the underlying result set by materializing the underlying ResultSet 
1: 		tree into a hash table while scrolling forward.
1: 
1: 		@param source the result set input to this result set.
1: 		@param activation the activation for this result set,
1: 			which provides the context for normalization.
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param sourceRowWidth	The # of columns in the source row.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the materialization operation as a result set.
1: 
1: 	 	@exception StandardException		Thrown on failure
1: 	 */
1: 	NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source, Activation activation, 
1: 											int resultSetNumber,
1: 											int sourceRowWidth,
1: 											boolean scrollable,
1: 											double optimizerEstimatedRowCount,
1: 											double optimizerEstimatedCost,
0: 										   GeneratedMethod closeCleanup) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		REMIND: needs more description...
1: 
1: 		@param source the result set input to this result set.
1: 		@param activation the activation for this result set,
1: 			which provides the context for normalization.
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param erdNumber	int for ResultDescription 
1: 							(so it can be turned back into an object)
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
1: 		@return the normalization operation as a result set.
1: 
1: 	 	@exception StandardException		Thrown on failure
1: 	 */
1: 	NoPutResultSet getNormalizeResultSet(NoPutResultSet source, 
0: 										 Activation activation, 
1: 										 int resultSetNumber, int erdNumber,
1: 										 double optimizerEstimatedRowCount,
1: 										 double optimizerEstimatedCost,
1: 										 boolean forUpdate,
0: 										 GeneratedMethod closeCleanup) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		A current of result set forms a result set on the
1: 		current row of an open cursor.
1: 		It is used to perform positioned operations such as
1: 		positioned update and delete, using the result set paradigm.
1: 
1: 		@param cursorName the name of the cursor providing the row.
1: 		@param activation the activation for this result set,
0: 			used to provide information about the result set.
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 	 */
1: 	NoPutResultSet getCurrentOfResultSet(String cursorName, Activation activation, 
0: 									int resultSetNumber, String psName);
1: 
1: 	/**
1: 	 * The Union interface is used to evaluate the union (all) of two ResultSets.
1: 	 * (Any duplicate elimination is performed above this ResultSet.)
1: 	 *
1: 	 * Forms a ResultSet returning the union of the rows in two source
1: 	 * ResultSets.  The column types in source1 and source2 are assumed to be
1: 	 * the same.
1: 	 *
1: 	 * @param source1	The first ResultSet whose rows go into the union
1: 	 * @param source2	The second ResultSet whose rows go into the
1: 	 *			union
0: 	 *	@param activation the activation for this result set,
0: 	 *		which provides the context for normalization.
1: 	 *	@param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 *	@param closeCleanup	any cleanup the activation needs to do on close.
1: 	 *	@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 	 *										optimizer
1: 	 *	@param optimizerEstimatedCost		Estimated total cost by optimizer
1: 	 *
1: 	 * @return	A ResultSet from which the caller can get the union
1: 	 *		of the two source ResultSets.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	NoPutResultSet	getUnionResultSet(NoPutResultSet source1,
1: 					NoPutResultSet source2,
0: 					Activation activation, 
1: 					int resultSetNumber,
1: 					double optimizerEstimatedRowCount,
1: 					double optimizerEstimatedCost,
0: 					GeneratedMethod closeCleanup)
1: 					throws StandardException;
1: 
1: 
1: 	//
1: 	// Misc operations
1: 	//
1: 
1: 
1: 
1: 	/**
1: 	 * A last index key result set returns the last row from
1: 	 * the index in question.  It is used as an ajunct to max().
1: 	 *
1: 	 * @param activation 		the activation for this result set,
1: 	 *		which provides the context for the row allocation operation.
1: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 * @param resultRowAllocator a reference to a method in the activation
0: 	 * 						that creates a holder for the result row of the scan.  May
0: 	 *						be a partial row.  <verbatim>
0: 	 *		ExecRow rowAllocator() throws StandardException; </verbatim>
1: 	 * @param conglomId 		the conglomerate of the table to be scanned.
1: 	 * @param tableName			The full name of the table
1: 	 * @param indexName			The name of the index, if one used to access table.
1: 	 * @param colRefItem		An saved item for a bitSet of columns that
1: 	 *							are referenced in the underlying table.  -1 if
1: 	 *							no item.
1: 	 * @param lockMode			The lock granularity to use (see
1: 	 *							TransactionController in access)
1: 	 * @param tableLocked		Whether or not the table is marked as using table locking
1: 	 *							(in sys.systables)
1: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
1: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
1: 	 * 										optimizer
1: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
0: 	 * @param closeCleanup		any cleanup the activation needs to do on close.
1: 	 *
1: 	 * @return the scan operation as a result set.
1:  	 *
1: 	 * @exception StandardException thrown when unable to create the
1: 	 * 				result set
1: 	 */
1: 	NoPutResultSet getLastIndexKeyResultSet
1: 	(
1: 		Activation 			activation,
1: 		int 				resultSetNumber,
0: 		GeneratedMethod 	resultRowAllocator,
1: 		long 				conglomId,
1: 		String 				tableName,
1: 		String 				indexName,
1: 		int 				colRefItem,
1: 		int 				lockMode,
1: 		boolean				tableLocked,
1: 		int					isolationLevel,
1: 		double				optimizerEstimatedRowCount,
0: 		double 				optimizerEstimatedCost,
0: 		GeneratedMethod 	closeCleanup
1: 	) throws StandardException;
1: 
1: 
1: 	/**
1: 		A Dependent table scan result set forms a result set on a scan
0: 		of a dependent table for the rows that got materilized 
1: 		on the scan of its parent table and if the row being deleted
1: 		on parent table has a reference in the dependent table.
1: 
1: 		@param conglomId the conglomerate of the table to be scanned.
1: 		@param scociItem The saved item for the static conglomerate info.
1: 		@param activation the activation for this result set,
1: 			which provides the context for the row allocation operation.
1: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
1: 			<verbatim>
1: 				ExecRow rowAllocator() throws StandardException;
1: 			</verbatim>
1: 		@param resultSetNumber	The resultSetNumber for the ResultSet
1: 		@param startKeyGetter a reference to a method in the activation
1: 			that gets the start key indexable row for the scan.  Null
1: 			means there is no start key.
1: 			<verbatim>
1: 				ExecIndexRow startKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param startSearchOperator The start search operator for opening
1: 			the scan
1: 		@param stopKeyGetter	a reference to a method in the activation
1: 			that gets the stop key indexable row for the scan.  Null means
1: 			there is no stop key.
1: 			<verbatim>
1: 				ExecIndexRow stopKeyGetter() throws StandardException;
1: 			</verbatim>
1: 		@param stopSearchOperator	The stop search operator for opening
1: 			the scan
1: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
1: 										(Exact match search.)
1: 		@param qualifiers the array of Qualifiers for the scan.
1: 			Null or an array length of zero means there are no qualifiers.
1: 		@param tableName		The full name of the table
1: 		@param indexName		The name of the index, if one used to access table.
1: 		@param isConstraint		If index, if used, is a backing index for a constraint.
1: 		@param forUpdate		True means open for update
1: 		@param colRefItem		An saved item for a bitSet of columns that
1: 								are referenced in the underlying table.  -1 if
1: 								no item.
1: 		@param lockMode			The lock granularity to use (see
1: 								TransactionController in access)
1: 		@param tableLocked		Whether or not the table is marked as using table locking
1: 								(in sys.systables)
1: 		@param isolationLevel	Isolation level (specified or not) to use on scans
1: 		@param oneRowScan		Whether or not this is a 1 row scan.
1: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
1: 											optimizer
1: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@param parentResultSetId  Id to access the materlized temporary result
0:                             	  set from the refence stored in the activation.
1: 		@param fkIndexConglomId foreign key index conglomerate id.
1: 		@param fkColArrayItem  saved column array object  that matches the foreign key index
1: 		                       columns  and the resultset from the parent table.
1: 		@param  rltItem row location template
1: 
1: 		@return the table scan operation as a result set.
1: 		@exception StandardException thrown when unable to create the
1: 			result set
1: 	 */
1: 	public NoPutResultSet getRaDependentTableScanResultSet(
1: 									long conglomId,
1: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
1: 									int resultSetNumber,
1: 									GeneratedMethod startKeyGetter,
1: 									int startSearchOperator,
1: 									GeneratedMethod stopKeyGetter,
1: 									int stopSearchOperator,
1: 									boolean sameStartStopPosition,
1: 									Qualifier[][] qualifiers,
1: 									String tableName,
1: 									String indexName,
1: 									boolean isConstraint,
1: 									boolean forUpdate,
1: 									int colRefItem,
1: 									int indexColItem,
1: 									int lockMode,
1: 									boolean tableLocked,
1: 									int isolationLevel,
1: 									boolean oneRowScan,
1: 									double optimizerEstimatedRowCount,
1: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup,
1: 									String parentResultSetId,
1: 									long fkIndexConglomId,
1: 									int fkColArrayItem,
1: 									int rltItem)
1: 		throws StandardException;
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2dd2d11
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		boolean reuseResult,
/////////////////////////////////////////////////////////////////////////
1: 		@param mapRefItem	Item # for mapping of source to target columns
/////////////////////////////////////////////////////////////////////////
1: 		@param orderingItem entry in preparedStatement's savedObjects for order
/////////////////////////////////////////////////////////////////////////
1: 		@param orderingItem entry in preparedStatement's savedObjects for order
/////////////////////////////////////////////////////////////////////////
1: 		@param scoci The saved item for the static conglomerate info.
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
0: 		@param tableName		The full name of the table 
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 								String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 								String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 								String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 								String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
0: 								   String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 	 * @param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
1: 		String 				userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		@param userSuppliedOptimizerOverrides		Overrides specified by the user on the sql
/////////////////////////////////////////////////////////////////////////
0: 									String userSuppliedOptimizerOverrides,
commit:6200b38
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * The SetOpResultSet is used to implement an INTERSECT or EXCEPT operation.
1:      * It selects rows from two ordered input result sets.
1:      *
1:      * @param leftSource The result set that implements the left input
1:      * @param rightSource The result set that implements the right input
0:      * @param activation the activation for this result set
1:      * @param resultSetNumber
1:      * @param optimizerEstimatedRowCount
1:      * @param optimizerEstimatedCost
1:      * @param opType IntersectOrExceptNode.INTERSECT_OP or EXCEPT_OP
1:      * @param all true if the operation is an INTERSECT ALL or an EXCEPT ALL,
1:      *            false if the operation is an INTERSECT DISCTINCT or an EXCEPT DISCTINCT
0:      * @param closeCleanup a method to be called by close
1:      * @param intermediateOrderByColumnsSavedObject The saved object index for the array of order by columns for the
1:      *        ordering of the left and right sources. That is, both the left and right sources have an order by
1:      *        clause of the form ORDER BY intermediateOrderByColumns[0],intermediateOrderByColumns[1],...
1:      * @param intermediateOrderByDirectionSavedObject The saved object index for the array of source
1:      *        order by directions. That is, the ordering of the i'th order by column in the input is ascending
1:      *        if intermediateOrderByDirection[i] is 1, descending if intermediateOrderByDirection[i] is -1.
1: 	 *
1: 	 * @return	A ResultSet from which the caller can get the INTERSECT or EXCEPT
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 */
1:     NoPutResultSet getSetOpResultSet( NoPutResultSet leftSource,
1:                                       NoPutResultSet rightSource,
0:                                       Activation activation, 
0:                                       int resultSetNumber,
1:                                       long optimizerEstimatedRowCount,
0:                                       double optimizerEstimatedCost,
1:                                       int opType,
1:                                       boolean all,
0:                                       GeneratedMethod closeCleanup,
1:                                       int intermediateOrderByColumnsSavedObject,
0:                                       int intermediateOrderByDirectionSavedObject)
0:         throws StandardException;
0:                                                      
0:                                                      
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.execute;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: /**
0:  * ResultSetFactory provides a wrapper around all of
0:  * the result sets needed in an execution implementation.
0:  * <p>
0:  * For the activations to avoid searching for this module
0:  * in their execute methods, the base activation supertype
0:  * should implement a method that does the lookup and salts
0:  * away this factory for the activation to use as it needs it.
0:  *
0:  * @author ames
0:  */
0: public interface ResultSetFactory {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 		Module name for the monitor's module locating system.
0: 	 */
0: 	String MODULE = "org.apache.derby.iapi.sql.execute.ResultSetFactory";
0: 
0: 	//
0: 	// DDL operations
0: 	//
0: 
0: 	/**
0: 	    Generic DDL result set creation.
0: 
0: 		@param activation 		the activation for this result set
0: 
0: 		@return	ResultSet	A wrapper result set to run the Execution-time
0: 		                        logic.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	ResultSet getDDLResultSet(Activation activation)
0: 					throws StandardException;
0: 
0: 
0: 	//
0: 	// MISC operations
0: 	//
0: 
0: 	/**
0: 	    Generic Misc result set creation.
0: 
0: 		@param activation 		the activation for this result set
0: 
0: 		@return	ResultSet	A wrapper result set to run the Execution-time
0: 		                        logic.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	ResultSet getMiscResultSet(Activation activation)
0: 					throws StandardException;
0: 
0: 	//
0: 	// Transaction operations
0: 	//
0: 	/**
0: 
0: 		@param activation 		the activation for this result set
0: 
0: 		@return	ResultSet	A wrapper result set to run the Execution-time
0: 		                        logic.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	ResultSet getSetTransactionResultSet(Activation activation) 
0: 		throws StandardException;
0: 
0: 	//
0: 	// DML statement operations
0: 	//
0: 	/**
0: 		An insert result set simply reports that it completed, and
0: 		the number of rows inserted.  It does not return rows.
0: 		The insert has been completed once the
0: 		insert result set is available.
0: 
0: 		@param source the result set from which to take rows to
0: 			be inserted into the target table.
0: 		@param checkGM	The code to enforce the check constraints, if any
0: 		@param activation the activation for this result set,
0: 		@return the insert operation as a result set.
0: 		@exception StandardException thrown when unable to perform the insert
0: 	 */
0: 	ResultSet getInsertResultSet(NoPutResultSet source, 
0: 								 GeneratedMethod checkGM,
0: 							     Activation activation)
0:         throws StandardException;
0: 
0: 	/**
0: 		An insert VTI result set simply reports that it completed, and
0: 		the number of rows inserted.  It does not return rows.
0: 		The insert has been completed once the
0: 		insert result set is available.
0: 
0: 		@param source the result set from which to take rows to
0: 			be inserted into the target table.
0: 		@param vtiRS	The code to instantiate the VTI, if necessary
0: 		@param activation the activation for this result set,
0: 		@return the insert VTI operation as a result set.
0: 		@exception StandardException thrown when unable to perform the insert
0: 	 */
0: 	ResultSet getInsertVTIResultSet(NoPutResultSet source, 
0: 								 NoPutResultSet vtiRS,
0: 							     Activation activation)
0:         throws StandardException;
0: 
0: 	/**
0: 		A delete VTI result set simply reports that it completed, and
0: 		the number of rows deleted.  It does not return rows.
0: 		The delete has been completed once the
0: 		delete result set is available.
0: 
0: 		@param source the result set from which to take rows to
0: 			be inserted into the target table.
0: 		@param activation the activation for this result set,
0: 		@return the delete VTI operation as a result set.
0: 		@exception StandardException thrown when unable to perform the insert
0: 	 */
0: 	ResultSet getDeleteVTIResultSet(NoPutResultSet source, 
0: 							     Activation activation)
0:         throws StandardException;
0: 
0: 	/**
0: 		A delete result set simply reports that it completed, and
0: 		the number of rows deleted.  It does not return rows.
0: 		The delete has been completed once the
0: 		delete result set is available.
0: 
0: 		@param source the result set from which to take rows to
0: 			be deleted from the target table. This result set must
0: 			contain one column which provides RowLocations that are
0: 			valid in the target table.
0: 		@param activation 		the activation for this result set
0: 		@return the delete operation as a result set.
0: 		@exception StandardException thrown when unable to perform the delete
0: 	 */
0: 	ResultSet getDeleteResultSet(NoPutResultSet source,
0: 								 Activation activation)
0: 							throws StandardException;
0: 
0: 	/**
0: 		A delete Cascade result set simply reports that it completed, and
0: 		the number of rows deleted.  It does not return rows.
0: 		The delete has been completed once the
0: 		delete result set is available.
0: 
0: 		@param source the result set from which to take rows to
0: 			be deleted from the target table.
0: 		@param activation 		the activation for this result set
0: 		@param constantActionItem a constant action saved object reference
0: 		@param dependentResultSets an array of DeleteCascade Resultsets
0:                                    for the current table referential action
0: 								   dependents tables.
0: 		@param resultSetId  an Id which is used to store the refence
0:                             to the temporary result set created of
0:                             the materilized rows.Dependent table resultsets
0: 							uses the same id to access their parent temporary result sets.
0: 		@return the delete operation as a delete cascade result set.
0: 		@exception StandardException thrown when unable to perform the delete
0: 	 */
0: 	ResultSet getDeleteCascadeResultSet(NoPutResultSet source,
0: 										Activation activation, int constantActionItem,
0: 										ResultSet[] dependentResultSets, 
0: 										String resultSetId)
0: 							throws StandardException;
0: 
0: 	/**
0: 		An update result set simply reports that it completed, and
0: 		the number of rows updated.  It does not return rows.
0: 		The update has been completed once the
0: 		update result set is available.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			updated in the target table. This result set must contain 
0: 			a column which provides RowLocations that are valid in the 
0: 			target table, and new values to be placed in those rows.
0: 		@param checkGM	The code to enforce the check constraints, if any
0: 		@param activation 		the activation for this result set
0: 		@return the update operation as a result set.
0: 		@exception StandardException thrown when unable to perform the update
0: 	 */
0: 	ResultSet getUpdateResultSet(NoPutResultSet source, 
0: 								 GeneratedMethod checkGM,
0: 							     Activation activation)
0:         throws StandardException;
0: 
0: 	/**
0:      * @param source the result set from which to take rows to be 
0:      *               updated in the target table.
0:      * @param vtiRS the updateable result set for the VTI
0:      * @param activation the activation for this result set
0:      * @return the update operation as a result set.
0:      * @exception StandardException thrown on error
0: 	 */
0: 	public ResultSet getUpdateVTIResultSet(NoPutResultSet source,
0:                                            Activation activation)
0:         throws StandardException;
0: 
0: 	/**
0: 		An update result set simply reports that it completed, and
0: 		the number of rows updated.  It does not return rows.
0: 		The update has been completed once the
0: 		update result set is available.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			updated in the target table. This result set must contain 
0: 			a column which provides RowLocations that are valid in the 
0: 			target table, and new values to be placed in those rows.
0: 		@param checkGM	The code to enforce the check constraints, if any
0: 		@param activation 		the activation for this result set
0: 		@param constantActionItem a constant action saved object reference
0: 		@param rsdItem   result Description, saved object id. 				
0: 		@return the update operation as a result set.
0: 		@exception StandardException thrown when unable to perform the update
0: 	 */
0: 	ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source, 
0: 								 GeneratedMethod checkGM,
0: 							     Activation activation,
0: 								 int constantActionItem,
0: 								 int rsdItem)
0:         throws StandardException;
0: 
0: 	/**
0: 		A call statement result set simply reports that it completed.  
0: 		It does not return rows.
0: 
0: 		@param methodCall a reference to a method in the activation
0: 			  for the method call
0: 		@param activation the activation for this result set
0: 
0: 		@return the call statement operation as a result set.
0: 		@exception StandardException thrown when unable to perform the call statement
0: 	 */
0: 	ResultSet getCallStatementResultSet(GeneratedMethod methodCall,
0: 				Activation activation) 
0: 			throws StandardException;
0: 
0: 	//
0: 	// Query expression operations
0: 	//
0: 
0: 	/**
0: 		A project restrict result set iterates over its source,
0: 		evaluating a restriction and when it is satisfied,
0: 		constructing a row to return in its result set based on
0: 		its projection.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
0: 		@param restriction a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to determine whether the restriction is satisfied or not.
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean restriction() throws StandardException;
0: 			</verbatim>
0: 		@param projection a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to project out the expected result row.
0: 			The signature of this method is
0: 			<verbatim>
0: 				ExecRow projection() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param constantRestriction a reference to a method in the activation
0: 			that represents a constant expression (eg where 1 = 2).
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean restriction() throws StandardException;
0: 			</verbatim>
0: 		@param mapArrayItem	Item # for mapping of source to target columns
0: 		@param reuseResult	Whether or not to reuse the result row.
0: 		@param doesProjection	Whether or not this PRN does a projection
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the project restrict operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getProjectRestrictResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod restriction, 
0: 		GeneratedMethod projection, int resultSetNumber,
0: 		GeneratedMethod constantRestriction,
0: 		int mapArrayItem,
0: 		boolean resuseResult,
0: 		boolean doesProjection,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) throws StandardException;
0: 
0: 	/**
0: 		A hash table result set builds a hash table on its source,
0: 		applying a list of predicates, if any, to the source,
0: 		when building the hash table.  It then does a look up into
0: 		the hash table on a probe.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
0: 		@param singleTableRestriction restriction, if any, applied to
0: 			input of hash table.
0: 		@param equijoinQualifiers Qualifier[] for look up into hash table
0: 		@param projection a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to project out the expected result row.
0: 			The signature of this method is
0: 			<verbatim>
0: 				ExecRow projection() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param mapArrayItem	Item # for mapping of source to target columns
0: 		@param reuseResult	Whether or not to reuse the result row.
0: 		@param keyColItem	Item for hash key column array
0: 		@param removeDuplicates	Whether or not to remove duplicates when building the hash table
0: 		@param maxInMemoryRowCount			Max size of in-memory hash table
0: 		@param initialCapacity				initialCapacity for java.util.HashTable
0: 		@param loadFactor					loadFactor for java.util.HashTable
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the project restrict operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	public NoPutResultSet getHashTableResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod singleTableRestriction, 
0: 		Qualifier[][] equijoinQualifiers,
0: 		GeneratedMethod projection, int resultSetNumber,
0: 		int mapRefItem,
0: 		boolean reuseResult,
0: 		int keyColItem,
0: 		boolean removeDuplicates,
0: 		long maxInMemoryRowCount,
0: 		int	initialCapacity,
0: 		float loadFactor,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			 throws StandardException;
0: 
0: 	/**
0: 		A sort result set sorts its source and if requested removes
0: 		duplicates.  It will generate the entire result when open, and
0: 		then return it a row at a time.
0: 		<p>
0: 		If passed aggregates it will do scalar or vector aggregate
0: 		processing.  A list of aggregator information is passed
0: 		off of the PreparedStatement's savedObjects.  Aggregation
0: 		and SELECT DISTINCT cannot be processed in the same sort.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param distinct true if distinct SELECT list
0: 		@param isInSortedOrder	true if the source result set is in sorted order
0: 		@param orderItem entry in preparedStatement's savedObjects for order
0: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
0: 			that generates rows of the right size and shape for the source
0: 		@param rowSize the size of the row that is allocated by rowAllocator.
0: 			size should be the maximum size of the sum of all the datatypes.
0: 			user type are necessarily approximated
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the distinct operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getSortResultSet(NoPutResultSet source,
0: 		boolean distinct, 
0: 		boolean isInSortedOrder,
0: 		int orderItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int rowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException;
0: 
0: 	/**
0: 		A ScalarAggregateResultSet computes non-distinct scalar aggregates.
0: 		It will compute the aggregates when open.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param isInSortedOrder	true if the source result set is in sorted order
0: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
0: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
0: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
0: 			that generates rows of the right size and shape for the source
0: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param singleInputRow	Whether we know we have a single input row or not
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the scalar aggregation operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getScalarAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int rowSize,
0: 		int resultSetNumber, 
0: 		boolean singleInputRow,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException;
0: 
0: 	/**
0: 		A DistinctScalarAggregateResultSet computes scalar aggregates when 
0: 		at least one of them is a distinct aggregate.
0: 		It will compute the aggregates when open.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param isInSortedOrder	true if the source result set is in sorted order
0: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
0: 		@param orderItem entry in preparedStatement's savedObjects for order
0: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
0: 			that generates rows of the right size and shape for the source
0: 		@param rowSize the size of the row that is allocated by rowAllocator.
0: 			size should be the maximum size of the sum of all the datatypes.
0: 			user type are necessarily approximated
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param singleInputRow	Whether we know we have a single input row or not
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the scalar aggregation operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getDistinctScalarAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int rowSize,
0: 		int resultSetNumber, 
0: 		boolean singleInputRow,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException;
0: 
0: 	/**
0: 		A GroupedAggregateResultSet computes non-distinct grouped aggregates.
0: 		It will compute the aggregates when open.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param isInSortedOrder	true if the source result set is in sorted order
0: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
0: 		@param orderingItem		Ignored to allow same signature as getDistinctScalarAggregateResultSet
0: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
0: 			that generates rows of the right size and shape for the source
0: 		@param rowSize			Ignored to allow same signature as getDistinctScalarAggregateResultSet
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the scalar aggregation operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getGroupedAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int rowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException;
0: 
0: 	/**
0: 		A DistinctGroupedAggregateResultSet computes scalar aggregates when 
0: 		at least one of them is a distinct aggregate.
0: 		It will compute the aggregates when open.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param isInSortedOrder	true if the source result set is in sorted order
0: 		@param aggregateItem entry in preparedStatement's savedObjects for aggregates
0: 		@param orderItem entry in preparedStatement's savedObjects for order
0: 		@param activation the activation for this result set,
0: 			against which the sort-unique is performed.
0: 		@param rowAllocator a reference to a method in the activation
0: 			that generates rows of the right size and shape for the source
0: 		@param rowSize the size of the row that is allocated by rowAllocator.
0: 			size should be the maximum size of the sum of all the datatypes.
0: 			user type are necessarily approximated
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the scalar aggregation operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getDistinctGroupedAggregateResultSet(NoPutResultSet source,
0: 		boolean isInSortedOrder,
0: 		int aggregateItem,
0: 		int orderingItem,
0: 		Activation activation, 
0: 		GeneratedMethod rowAllocator, 
0: 		int rowSize,
0: 		int resultSetNumber, 
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup) 
0: 			throws StandardException;
0: 
0: 	/**
0: 		An any result set iterates over its source,
0: 		returning a row with all columns set to nulls
0: 		if the source returns no rows.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
0: 		@param emptyRowFun a reference to a method in the activation
0: 			that is called if the source returns no rows
0: 		@param resultSetNumber		The resultSetNumber for the ResultSet
0: 		@param subqueryNumber		The subquery number for this subquery.
0: 		@param pointOfAttachment	The point of attachment for this subquery.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@return the any operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getAnyResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun, int resultSetNumber,
0: 		int subqueryNumber, int pointOfAttachment,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		A once result set iterates over its source,
0: 		raising an error if the source returns > 1 row and
0: 		returning a row with all columns set to nulls
0: 		if the source returns no rows.
0: 
0: 		@param source the result set from which to take rows to be 
0: 			filtered by this operation.
0: 		@param activation the activation for this result set,
0: 			against whcih the restriction and projection are performed
0: 			and to which current rows must be assigned for the
0: 			projection and restriction to be performed.
0: 		@param emptyRowFun a reference to a method in the activation
0: 			that is called if the source returns no rows
0: 		@param cardinalityCheck The type of cardinality check, if any that
0: 			is required
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param subqueryNumber		The subquery number for this subquery.
0: 		@param pointOfAttachment	The point of attachment for this subquery.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@return the once operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getOnceResultSet(NoPutResultSet source,
0: 		Activation activation, GeneratedMethod emptyRowFun,
0: 		int cardinalityCheck, int resultSetNumber, 
0: 		int subqueryNumber, int pointOfAttachment,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		A row result set forms a result set on a single, known row value.
0: 		It is used to turn constant rows into result sets for use in
0: 		the result set paradigm.
0: 		The row can be constructed when it is requested from the
0: 		result set.
0: 
0: 		@param activation the activation for this result set,
0: 			against which the row operation is performed to
0: 			create the result set.
0: 		@param row a reference to a method in the activation
0: 			that creates the expected row.
0: 			<verbatim>
0: 				ExecRow row() throws StandardException;
0: 			</verbatim>
0: 		@param canCacheRow	True if execution can cache the input row
0: 			after it has gotten it.  If the input row is constructed soley
0: 			of constants or parameters, it is ok to cache this row rather
0: 			than recreating it each time it is requested.
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the row as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getRowResultSet(Activation activation, GeneratedMethod row, 
0: 							  boolean canCacheRow,
0: 							  int resultSetNumber,
0: 							  double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod closeCleanup)
0: 		throws StandardException;
0: 
0: 	/**
0: 		A VTI result set wraps a user supplied result set.
0: 
0: 		@param activation the activation for this result set,
0: 			against which the row operation is performed to
0: 			create the result set.
0: 		@param row a reference to a method in the activation
0: 			that creates the expected row.
0: 			<verbatim>
0: 				ExecRow row() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param constructor		The GeneratedMethod for the user's constructor
0: 		@param javaClassName	The java class name for the VTI
0: 		@param erdNumber		int for referenced column BitSet 
0: 								(so it can be turned back into an object)
0: 		@param version2			Whether or not VTI is a version 2 VTI.
0: 		@param isTarget			Whether or not VTI is a target VTI.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the row as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	public NoPutResultSet getVTIResultSet(Activation activation, GeneratedMethod row,
0: 									 int resultSetNumber,
0: 									 GeneratedMethod constructor,
0: 									 String javaClassName,
0: 									 Qualifier[][] pushedQualifiers,
0: 									 int erdNumber,
0: 									 boolean version2, boolean reuseablePs,
0: 									 int ctcNumber,
0: 									 boolean isTarget,
0: 									 int scanIsolationLevel,
0: 									 double optimizerEstimatedRowCount,
0: 									 double optimizerEstimatedCost,
0: 								     GeneratedMethod closeCleanup)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		A hash result set forms a result set on a hash table built on a scan
0: 		of a table.
0: 		The rows are put into the hash table on the 1st open.
0: 		<p>
0: 
0: 		@param conglomId the conglomerate of the table to be scanned.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the rows from the scan.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param startKeyGetter a reference to a method in the activation
0: 			that gets the start key indexable row for the scan.  Null
0: 			means there is no start key.
0: 			<verbatim>
0: 				ExecIndexRow startKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param startSearchOperator The start search operator for opening
0: 			the scan
0: 		@param stopKeyGetter	a reference to a method in the activation
0: 			that gets the stop key indexable row for the scan.  Null means
0: 			there is no stop key.
0: 			<verbatim>
0: 				ExecIndexRow stopKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param stopSearchOperator	The stop search operator for opening
0: 			the scan
0: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
0: 										(Exact match search.)
0: 		@param scanQualifiers the array of Qualifiers for the scan.
0: 			Null or an array length of zero means there are no qualifiers.
0: 		@param nextQualifiers the array of Qualifiers for the look up into the hash table.
0: 		@param initialCapacity	The initialCapacity for the HashTable.
0: 		@param loadFactor		The loadFactor for the HashTable.
0: 		@param maxCapacity		The maximum size for the HashTable.
0: 		@param hashKeyColumn	The 0-based column # for the hash key.
0: 		@param tableName		The full name of the table
0: 		@param indexName		The name of the index, if one used to access table.
0: 		@param isConstraint		If index, if used, is a backing index for a constraint.
0: 		@param forUpdate		True means open for update
0: 		@param colRefItem		An saved item for a bitSet of columns that
0: 								are referenced in the underlying table.  -1 if
0: 								no item.
0: 		@param lockMode			The lock granularity to use (see
0: 								TransactionController in access)
0: 		@param tableLocked		Whether or not the table is marked as using table locking
0: 								(in sys.systables)
0: 		@param isolationLevel	Isolation level (specified or not) to use on scans
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the table scan operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getHashScanResultSet(
0: 								long conglomId,
0: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								GeneratedMethod startKeyGetter,
0: 								int startSearchOperator,
0: 								GeneratedMethod stopKeyGetter,
0: 								int stopSearchOperator,
0: 								boolean sameStartStopPosition,
0: 								Qualifier[][] scanQualifiers,
0: 								Qualifier[][] nextQualifiers,
0: 								int initialCapacity,
0: 								float loadFactor,
0: 								int maxCapacity,
0: 								int hashKeyColumn,
0: 								String tableName,
0: 								String indexName,
0: 								boolean isConstraint,
0: 								boolean forUpdate,
0: 								int colRefItem,
0: 								int indexColItem,
0: 								int lockMode,
0: 								boolean tableLocked,
0: 								int isolationLevel,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A distinct scan result set pushes duplicate elimination into
0: 		the scan.
0: 		<p>
0: 
0: 		@param conglomId the conglomerate of the table to be scanned.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the rows from the scan.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param hashKeyColumn	The 0-based column # for the hash key.
0: 		@param tableName		The full name of the table
0: 		@param indexName		The name of the index, if one used to access table.
0: 		@param isConstraint		If index, if used, is a backing index for a constraint.
0: 		@param colRefItem		An saved item for a bitSet of columns that
0: 								are referenced in the underlying table.  -1 if
0: 								no item.
0: 		@param lockMode			The lock granularity to use (see
0: 								TransactionController in access)
0: 		@param tableLocked		Whether or not the table is marked as using table locking
0: 								(in sys.systables)
0: 		@param isolationLevel	Isolation level (specified or not) to use on scans
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the table scan operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getDistinctScanResultSet(
0: 								long conglomId,
0: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								int hashKeyColumn,
0: 								String tableName,
0: 								String indexName,
0: 								boolean isConstraint,
0: 								int colRefItem,
0: 								int lockMode,
0: 								boolean tableLocked,
0: 								int isolationLevel,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A table scan result set forms a result set on a scan
0: 		of a table.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 		<p>
0: 		This form of the table scan operation is simple, and is
0: 		to be used when there are no predicates to be passed down
0: 		to the scan to limit its scope on the target table.
0: 
0: 		@param conglomId the conglomerate of the table to be scanned.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param startKeyGetter a reference to a method in the activation
0: 			that gets the start key indexable row for the scan.  Null
0: 			means there is no start key.
0: 			<verbatim>
0: 				ExecIndexRow startKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param startSearchOperator The start search operator for opening
0: 			the scan
0: 		@param stopKeyGetter	a reference to a method in the activation
0: 			that gets the stop key indexable row for the scan.  Null means
0: 			there is no stop key.
0: 			<verbatim>
0: 				ExecIndexRow stopKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param stopSearchOperator	The stop search operator for opening
0: 			the scan
0: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
0: 										(Exact match search.)
0: 		@param qualifiers the array of Qualifiers for the scan.
0: 			Null or an array length of zero means there are no qualifiers.
0: 		@param tableName		The full name of the table
0: 		@param indexName		The name of the index, if one used to access table.
0: 		@param isConstraint		If index, if used, is a backing index for a constraint.
0: 		@param forUpdate		True means open for update
0: 		@param colRefItem		An saved item for a bitSet of columns that
0: 								are referenced in the underlying table.  -1 if
0: 								no item.
0: 		@param lockMode			The lock granularity to use (see
0: 								TransactionController in access)
0: 		@param tableLocked		Whether or not the table is marked as using table locking
0: 								(in sys.systables)
0: 		@param isolationLevel	Isolation level (specified or not) to use on scans
0: 		@param oneRowScan		Whether or not this is a 1 row scan.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 
0: 		@return the table scan operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getTableScanResultSet(
0: 								long conglomId,
0: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								GeneratedMethod startKeyGetter,
0: 								int startSearchOperator,
0: 								GeneratedMethod stopKeyGetter,
0: 								int stopSearchOperator,
0: 								boolean sameStartStopPosition,
0: 								Qualifier[][] qualifiers,
0: 								String tableName,
0: 								String indexName,
0: 								boolean isConstraint,
0: 								boolean forUpdate,
0: 								int colRefItem,
0: 								int indexColItem,
0: 								int lockMode,
0: 								boolean tableLocked,
0: 								int isolationLevel,
0: 								boolean oneRowScan,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A table scan result set forms a result set on a scan
0: 		of a table.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 		<p>
0: 		This form of the table scan operation is simple, and is
0: 		to be used when there are no predicates to be passed down
0: 		to the scan to limit its scope on the target table.
0: 
0: 		@param conglomId the conglomerate of the table to be scanned.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param startKeyGetter a reference to a method in the activation
0: 			that gets the start key indexable row for the scan.  Null
0: 			means there is no start key.
0: 			<verbatim>
0: 				ExecIndexRow startKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param startSearchOperator The start search operator for opening
0: 			the scan
0: 		@param stopKeyGetter	a reference to a method in the activation
0: 			that gets the stop key indexable row for the scan.  Null means
0: 			there is no stop key.
0: 			<verbatim>
0: 				ExecIndexRow stopKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param stopSearchOperator	The stop search operator for opening
0: 			the scan
0: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
0: 										(Exact match search.)
0: 		@param qualifiers the array of Qualifiers for the scan.
0: 			Null or an array length of zero means there are no qualifiers.
0: 		@param tableName		The full name of the table
0: 		@param indexName		The name of the index, if one used to access table.
0: 		@param isConstraint		If index, if used, is a backing index for a constraint.
0: 		@param forUpdate		True means open for update
0: 		@param colRefItem		An saved item for a bitSet of columns that
0: 								are referenced in the underlying table.  -1 if
0: 								no item.
0: 		@param lockMode			The lock granularity to use (see
0: 								TransactionController in access)
0: 		@param tableLocked		Whether or not the table is marked as using table locking
0: 								(in sys.systables)
0: 		@param isolationLevel	Isolation level (specified or not) to use on scans
0: 		@param rowsPerRead		The number of rows to read per fetch.
0: 		@param oneRowScan		Whether or not this is a 1 row scan.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 
0: 		@return the table scan operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	NoPutResultSet getBulkTableScanResultSet(
0: 								long conglomId,
0: 								int scociItem,
0: 								Activation activation,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								GeneratedMethod startKeyGetter,
0: 								int startSearchOperator,
0: 								GeneratedMethod stopKeyGetter,
0: 								int stopSearchOperator,
0: 								boolean sameStartStopPosition,
0: 								Qualifier[][] qualifiers,
0: 								String tableName,
0: 								String indexName,
0: 								boolean isConstraint,
0: 								boolean forUpdate,
0: 								int colRefItem,
0: 								int indexColItem,
0: 								int lockMode,
0: 								boolean tableLocked,
0: 								int isolationLevel,
0: 								int rowsPerRead,
0: 								boolean oneRowScan,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 	/**
0: 		An index row to base row result set gets an index row from its source
0: 		and uses the RowLocation in its last column to get the row from the
0: 		base conglomerate.
0: 		<p>
0: 
0: 	    @param conglomId	Conglomerate # for the heap.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param source	the source result set, which is expected to provide
0: 						rows from an index conglomerate
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the rows from the scan.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param indexName		The name of the index.
0: 		@param heapColRefItem	A saved item for a bitImpl of columns that
0: 								are referenced in the underlying heap.  -1 if
0: 								no item.
0: 		@param indexColRefItem	A saved item for a bitImpl of columns that
0: 								are referenced in the underlying index.  -1 if
0: 								no item.
0: 		@param indexColMapItem	A saved item for a ReferencedColumnsDescriptorImpl
0: 								which tell  which columms are coming from the index.
0: 		@param restriction		The restriction, if any, to be applied to the base row
0: 		@param forUpdate		True means to open for update
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 
0: 		@return the index row to base row operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	public NoPutResultSet getIndexRowToBaseRowResultSet(
0: 								long conglomId,
0: 								int scoci,
0: 								Activation a,
0: 								NoPutResultSet source,
0: 								GeneratedMethod resultRowAllocator,
0: 								int resultSetNumber,
0: 								String indexName,
0: 								int heapColRefItem,
0: 								int indexColRefItem,
0: 								int indexColMapItem,
0: 								GeneratedMethod restriction,
0: 								boolean forUpdate,
0: 								double optimizerEstimatedRowCount,
0: 								double optimizerEstimatedCost,
0: 								GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A nested loop left outer join result set forms a result set on top of
0: 		2 other result sets.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 		<p>
0: 		This form of the nested loop join operation is simple, and is
0: 		to be used when there are no join predicates to be passed down
0: 		to the join to limit its scope on the right ResultSet.
0: 
0: 		@param leftResultSet	Outer ResultSet for join.
0: 		@param leftNumCols		Number of columns in the leftResultSet
0: 		@param rightResultSet	Inner ResultSet for join.
0: 		@param rightNumCols		Number of columns in the rightResultSet
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param joinClause a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to determine whether the joinClause is satisfied or not.
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean joinClause() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param oneRowRightSide	boolean, whether or not the right side returns
0: 								a single row.  (No need to do 2nd next() if it does.)
0: 		@param notExistsRightSide	boolean, whether or not the right side resides a
0: 									NOT EXISTS base table
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the nested loop join operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0:     public NoPutResultSet getNestedLoopJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation, 
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A hash join.
0: 
0: 		@param leftResultSet	Outer ResultSet for join.
0: 		@param leftNumCols		Number of columns in the leftResultSet
0: 		@param rightResultSet	Inner ResultSet for join.
0: 		@param rightNumCols		Number of columns in the rightResultSet
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param joinClause a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to determine whether the joinClause is satisfied or not.
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean joinClause() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param oneRowRightSide	boolean, whether or not the right side returns
0: 								a single row.  (No need to do 2nd next() if it does.)
0: 		@param notExistsRightSide	boolean, whether or not the right side resides a
0: 									NOT EXISTS base table
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the nested loop join operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0:     public NoPutResultSet getHashJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation, 
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 
0: 	/**
0: 		A nested loop join result set forms a result set on top of
0: 		2 other result sets.
0: 		The rows can be constructed as they are requested from the
0: 		result set.
0: 		<p>
0: 		This form of the nested loop join operation is simple, and is
0: 		to be used when there are no join predicates to be passed down
0: 		to the join to limit its scope on the right ResultSet.
0: 
0: 		@param leftResultSet	Outer ResultSet for join.
0: 		@param leftNumCols		Number of columns in the leftResultSet
0: 		@param rightResultSet	Inner ResultSet for join.
0: 		@param rightNumCols		Number of columns in the rightResultSet
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param joinClause a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to determine whether the joinClause is satisfied or not.
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean joinClause() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param emptyRowFun a reference to a method in the activation
0: 							that is called if the right child returns no rows
0: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
0: 		@param oneRowRightSide	boolean, whether or not the right side returns
0: 								a single row.  (No need to do 2nd next() if it does.)
0: 		@param notExistsRightSide	boolean, whether or not the right side resides a
0: 									NOT EXISTS base table
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the nested loop join operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0:     public NoPutResultSet getNestedLoopLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation, 
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   GeneratedMethod emptyRowFun,
0: 								   boolean wasRightOuterJoin,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A left outer join using a hash join.
0: 
0: 		@param leftResultSet	Outer ResultSet for join.
0: 		@param leftNumCols		Number of columns in the leftResultSet
0: 		@param rightResultSet	Inner ResultSet for join.
0: 		@param rightNumCols		Number of columns in the rightResultSet
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param joinClause a reference to a method in the activation
0: 			that is applied to the activation's "current row" field
0: 			to determine whether the joinClause is satisfied or not.
0: 			The signature of this method is
0: 			<verbatim>
0: 				Boolean joinClause() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param emptyRowFun a reference to a method in the activation
0: 							that is called if the right child returns no rows
0: 		@param wasRightOuterJoin	Whether or not this was originally a right outer join
0: 		@param oneRowRightSide	boolean, whether or not the right side returns
0: 								a single row.  (No need to do 2nd next() if it does.)
0: 		@param notExistsRightSide	boolean, whether or not the right side resides a
0: 									NOT EXISTS base table
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the nested loop join operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0:     public NoPutResultSet getHashLeftOuterJoinResultSet(NoPutResultSet leftResultSet,
0: 								   int leftNumCols,
0: 								   NoPutResultSet rightResultSet,
0: 								   int rightNumCols,
0: 								   Activation activation, 
0: 								   GeneratedMethod joinClause,
0: 								   int resultSetNumber,
0: 								   GeneratedMethod emptyRowFun,
0: 								   boolean wasRightOuterJoin,
0: 								   boolean oneRowRightSide,
0: 								   boolean notExistsRightSide,
0: 								   double optimizerEstimatedRowCount,
0: 								   double optimizerEstimatedCost,
0: 								   GeneratedMethod closeCleanup)
0: 			throws StandardException;
0: 
0: 	/**
0: 		A ResultSet which materializes the underlying ResultSet tree into a 
0: 		temp table on the 1st open.  All subsequent "scans" of this ResultSet
0: 		will return results from the temp table.
0: 
0: 		@param source the result set input to this result set.
0: 		@param activation the activation for this result set,
0: 			which provides the context for normalization.
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the materialization operation as a result set.
0: 
0: 	 	@exception StandardException		Thrown on failure
0: 	 */
0: 	NoPutResultSet getMaterializedResultSet(NoPutResultSet source, Activation activation, 
0: 											int resultSetNumber,
0: 											double optimizerEstimatedRowCount,
0: 											double optimizerEstimatedCost,
0: 										   GeneratedMethod closeCleanup) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		A ResultSet which provides the insensitive scrolling functionality
0: 		for the underlying result set by materializing the underlying ResultSet 
0: 		tree into a hash table while scrolling forward.
0: 
0: 		@param source the result set input to this result set.
0: 		@param activation the activation for this result set,
0: 			which provides the context for normalization.
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param sourceRowWidth	The # of columns in the source row.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the materialization operation as a result set.
0: 
0: 	 	@exception StandardException		Thrown on failure
0: 	 */
0: 	NoPutResultSet getScrollInsensitiveResultSet(NoPutResultSet source, Activation activation, 
0: 											int resultSetNumber,
0: 											int sourceRowWidth,
0: 											boolean scrollable,
0: 											double optimizerEstimatedRowCount,
0: 											double optimizerEstimatedCost,
0: 										   GeneratedMethod closeCleanup) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		REMIND: needs more description...
0: 
0: 		@param source the result set input to this result set.
0: 		@param activation the activation for this result set,
0: 			which provides the context for normalization.
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param erdNumber	int for ResultDescription 
0: 							(so it can be turned back into an object)
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@return the normalization operation as a result set.
0: 
0: 	 	@exception StandardException		Thrown on failure
0: 	 */
0: 	NoPutResultSet getNormalizeResultSet(NoPutResultSet source, 
0: 										 Activation activation, 
0: 										 int resultSetNumber, int erdNumber,
0: 										 double optimizerEstimatedRowCount,
0: 										 double optimizerEstimatedCost,
0: 										 boolean forUpdate,
0: 										 GeneratedMethod closeCleanup) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		A current of result set forms a result set on the
0: 		current row of an open cursor.
0: 		It is used to perform positioned operations such as
0: 		positioned update and delete, using the result set paradigm.
0: 
0: 		@param cursorName the name of the cursor providing the row.
0: 		@param activation the activation for this result set,
0: 			used to provide information about the result set.
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 */
0: 	NoPutResultSet getCurrentOfResultSet(String cursorName, Activation activation, 
0: 									int resultSetNumber, String psName);
0: 
0: 	/**
0: 	 * The Union interface is used to evaluate the union (all) of two ResultSets.
0: 	 * (Any duplicate elimination is performed above this ResultSet.)
0: 	 *
0: 	 * Forms a ResultSet returning the union of the rows in two source
0: 	 * ResultSets.  The column types in source1 and source2 are assumed to be
0: 	 * the same.
0: 	 *
0: 	 * @param source1	The first ResultSet whose rows go into the union
0: 	 * @param source2	The second ResultSet whose rows go into the
0: 	 *			union
0: 	 *	@param activation the activation for this result set,
0: 	 *		which provides the context for normalization.
0: 	 *	@param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 *	@param closeCleanup	any cleanup the activation needs to do on close.
0: 	 *	@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 	 *										optimizer
0: 	 *	@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 	 *
0: 	 * @return	A ResultSet from which the caller can get the union
0: 	 *		of the two source ResultSets.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	NoPutResultSet	getUnionResultSet(NoPutResultSet source1,
0: 					NoPutResultSet source2,
0: 					Activation activation, 
0: 					int resultSetNumber,
0: 					double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod closeCleanup)
0: 					throws StandardException;
0: 
0: 
0: 	//
0: 	// Misc operations
0: 	//
0: 
0: 
0: 
0: 	/**
0: 	 * A last index key result set returns the last row from
0: 	 * the index in question.  It is used as an ajunct to max().
0: 	 *
0: 	 * @param activation 		the activation for this result set,
0: 	 *		which provides the context for the row allocation operation.
0: 	 * @param resultSetNumber	The resultSetNumber for the ResultSet
0: 	 * @param resultRowAllocator a reference to a method in the activation
0: 	 * 						that creates a holder for the result row of the scan.  May
0: 	 *						be a partial row.  <verbatim>
0: 	 *		ExecRow rowAllocator() throws StandardException; </verbatim>
0: 	 * @param conglomId 		the conglomerate of the table to be scanned.
0: 	 * @param tableName			The full name of the table
0: 	 * @param indexName			The name of the index, if one used to access table.
0: 	 * @param colRefItem		An saved item for a bitSet of columns that
0: 	 *							are referenced in the underlying table.  -1 if
0: 	 *							no item.
0: 	 * @param lockMode			The lock granularity to use (see
0: 	 *							TransactionController in access)
0: 	 * @param tableLocked		Whether or not the table is marked as using table locking
0: 	 *							(in sys.systables)
0: 	 * @param isolationLevel	Isolation level (specified or not) to use on scans
0: 	 * @param optimizerEstimatedRowCount	Estimated total # of rows by
0: 	 * 										optimizer
0: 	 * @param optimizerEstimatedCost		Estimated total cost by optimizer
0: 	 * @param closeCleanup		any cleanup the activation needs to do on close.
0: 	 *
0: 	 * @return the scan operation as a result set.
0:  	 *
0: 	 * @exception StandardException thrown when unable to create the
0: 	 * 				result set
0: 	 */
0: 	NoPutResultSet getLastIndexKeyResultSet
0: 	(
0: 		Activation 			activation,
0: 		int 				resultSetNumber,
0: 		GeneratedMethod 	resultRowAllocator,
0: 		long 				conglomId,
0: 		String 				tableName,
0: 		String 				indexName,
0: 		int 				colRefItem,
0: 		int 				lockMode,
0: 		boolean				tableLocked,
0: 		int					isolationLevel,
0: 		double				optimizerEstimatedRowCount,
0: 		double 				optimizerEstimatedCost,
0: 		GeneratedMethod 	closeCleanup
0: 	) throws StandardException;
0: 
0: 
0: 	/**
0: 		A Dependent table scan result set forms a result set on a scan
0: 		of a dependent table for the rows that got materilized 
0: 		on the scan of its parent table and if the row being deleted
0: 		on parent table has a reference in the dependent table.
0: 
0: 		@param conglomId the conglomerate of the table to be scanned.
0: 		@param scociItem The saved item for the static conglomerate info.
0: 		@param activation the activation for this result set,
0: 			which provides the context for the row allocation operation.
0: 		@param resultRowAllocator a reference to a method in the activation
0: 			that creates a holder for the result row of the scan.  May
0: 			be a partial row.
0: 			<verbatim>
0: 				ExecRow rowAllocator() throws StandardException;
0: 			</verbatim>
0: 		@param resultSetNumber	The resultSetNumber for the ResultSet
0: 		@param startKeyGetter a reference to a method in the activation
0: 			that gets the start key indexable row for the scan.  Null
0: 			means there is no start key.
0: 			<verbatim>
0: 				ExecIndexRow startKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param startSearchOperator The start search operator for opening
0: 			the scan
0: 		@param stopKeyGetter	a reference to a method in the activation
0: 			that gets the stop key indexable row for the scan.  Null means
0: 			there is no stop key.
0: 			<verbatim>
0: 				ExecIndexRow stopKeyGetter() throws StandardException;
0: 			</verbatim>
0: 		@param stopSearchOperator	The stop search operator for opening
0: 			the scan
0: 		@param sameStartStopPosition	Re-use the startKeyGetter for the stopKeyGetter
0: 										(Exact match search.)
0: 		@param qualifiers the array of Qualifiers for the scan.
0: 			Null or an array length of zero means there are no qualifiers.
0: 		@param tableName		The full name of the table
0: 		@param indexName		The name of the index, if one used to access table.
0: 		@param isConstraint		If index, if used, is a backing index for a constraint.
0: 		@param forUpdate		True means open for update
0: 		@param colRefItem		An saved item for a bitSet of columns that
0: 								are referenced in the underlying table.  -1 if
0: 								no item.
0: 		@param lockMode			The lock granularity to use (see
0: 								TransactionController in access)
0: 		@param tableLocked		Whether or not the table is marked as using table locking
0: 								(in sys.systables)
0: 		@param isolationLevel	Isolation level (specified or not) to use on scans
0: 		@param oneRowScan		Whether or not this is a 1 row scan.
0: 		@param optimizerEstimatedRowCount	Estimated total # of rows by
0: 											optimizer
0: 		@param optimizerEstimatedCost		Estimated total cost by optimizer
0: 		@param closeCleanup	any cleanup the activation needs to do on close.
0: 		@param parentResultSetId  Id to access the materlized temporary result
0:                             	  set from the refence stored in the activation.
0: 		@param fkIndexConglomId foreign key index conglomerate id.
0: 		@param fkColArrayItem  saved column array object  that matches the foreign key index
0: 		                       columns  and the resultset from the parent table.
0: 		@param  rltItem row location template
0: 
0: 		@return the table scan operation as a result set.
0: 		@exception StandardException thrown when unable to create the
0: 			result set
0: 	 */
0: 	public NoPutResultSet getRaDependentTableScanResultSet(
0: 									long conglomId,
0: 									int scociItem,
0: 									Activation activation,
0: 									GeneratedMethod resultRowAllocator,
0: 									int resultSetNumber,
0: 									GeneratedMethod startKeyGetter,
0: 									int startSearchOperator,
0: 									GeneratedMethod stopKeyGetter,
0: 									int stopSearchOperator,
0: 									boolean sameStartStopPosition,
0: 									Qualifier[][] qualifiers,
0: 									String tableName,
0: 									String indexName,
0: 									boolean isConstraint,
0: 									boolean forUpdate,
0: 									int colRefItem,
0: 									int indexColItem,
0: 									int lockMode,
0: 									boolean tableLocked,
0: 									int isolationLevel,
0: 									boolean oneRowScan,
0: 									double optimizerEstimatedRowCount,
0: 									double optimizerEstimatedCost,
0: 									GeneratedMethod closeCleanup,
0: 									String parentResultSetId,
0: 									long fkIndexConglomId,
0: 									int fkColArrayItem,
0: 									int rltItem)
0: 		throws StandardException;
0: }
============================================================================