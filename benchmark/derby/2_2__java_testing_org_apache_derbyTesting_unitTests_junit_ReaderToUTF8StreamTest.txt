1:5b9a6d9: /*
1:5b9a6d9: 
1:5b9a6d9:    Derby - Class org.apache.derbyTesting.unitTests.junit.ReaderToUTF8StreamTest
1:5b9a6d9: 
1:5b9a6d9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:5b9a6d9:    contributor license agreements.  See the NOTICE file distributed with
1:5b9a6d9:    this work for additional information regarding copyright ownership.
1:5b9a6d9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:5b9a6d9:    (the "License"); you may not use this file except in compliance with
1:5b9a6d9:    the License.  You may obtain a copy of the License at
1:5b9a6d9: 
1:5b9a6d9:       http://www.apache.org/licenses/LICENSE-2.0
1:5b9a6d9: 
1:5b9a6d9:    Unless required by applicable law or agreed to in writing, software
1:5b9a6d9:    distributed under the License is distributed on an "AS IS" BASIS,
1:5b9a6d9:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5b9a6d9:    See the License for the specific language governing permissions and
1:5b9a6d9:    limitations under the License.
1:5b9a6d9: 
1:5b9a6d9:  */
1:5b9a6d9: 
1:5b9a6d9: package org.apache.derbyTesting.unitTests.junit;
1:5b9a6d9: 
1:5b9a6d9: import java.io.ByteArrayInputStream;
1:5b9a6d9: import java.io.IOException;
1:5b9a6d9: import java.io.InputStream;
1:5b9a6d9: import java.io.Reader;
1:5b9a6d9: import java.util.Arrays;
1:5b9a6d9: import java.util.Random;
1:5b9a6d9: import junit.framework.Test;
1:5b9a6d9: import org.apache.derby.iapi.services.io.InputStreamUtil;
1:5b9a6d9: import org.apache.derby.iapi.types.ClobStreamHeaderGenerator;
1:5b9a6d9: import org.apache.derby.iapi.types.ReaderToUTF8Stream;
1:5b9a6d9: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:5b9a6d9: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:5b9a6d9: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:5b9a6d9: 
1:5b9a6d9: /**
1:5b9a6d9:  * Unit tests for ReaderToUTF8Stream.
1:5b9a6d9:  * <p>
1:5b9a6d9:  * Explicit tests for the mark/reset feature start with "testMark".
1:5b9a6d9:  */
1:5b9a6d9: public class ReaderToUTF8StreamTest
1:5b9a6d9:         extends BaseTestCase {
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * The default size of the internal buffer in ReaderToUTF8Stream. Used to
1:5b9a6d9:      * trigger specific events in the reader.
1:5b9a6d9:      */
1:5b9a6d9:     private static int DEFAULT_INTERNAL_BUFFER_SIZE = 32*1024;
1:5b9a6d9: 
1:5b9a6d9:     public ReaderToUTF8StreamTest(String name) {
1:5b9a6d9:         super(name);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     public static Test suite() {
1:1ae02c9:         return new BaseTestSuite(ReaderToUTF8StreamTest.class);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests a very basic use of the mark/reset mechanism.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetSimplePosZero()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(100);
1:5b9a6d9:         is.mark(10);
1:5b9a6d9:         assertEquals(10, is.read(new byte[10]));
1:5b9a6d9:         is.reset();
1:5b9a6d9:         checkBeginningOfStream(is);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests a very basic use of the mark/reset mechanism.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetSimplePosNonZero()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(200);
1:5b9a6d9:         assertEquals(127, is.read(new byte[127]));
1:5b9a6d9:         is.mark(10);
1:5b9a6d9:         byte[] readBeforeReset = new byte[10];
1:5b9a6d9:         byte[] readAfterReset = new byte[10];
1:5b9a6d9:         assertEquals(10, is.read(readBeforeReset));
1:5b9a6d9:         is.reset();
1:5b9a6d9:         assertEquals(10, is.read(readAfterReset));
1:5b9a6d9:         assertTrue(Arrays.equals(readBeforeReset, readAfterReset));
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests that shifting of existing bytes works.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetShiftBytesFew_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(128*1024);
1:5b9a6d9:         byte[] buf = new byte[DEFAULT_INTERNAL_BUFFER_SIZE - 2*1024];
1:5b9a6d9:         fillArray(is, buf);
1:5b9a6d9:         // The following mark fits within the existing default buffer, but the
1:5b9a6d9:         // bytes after the mark have to be shifted to the left.
1:5b9a6d9:         is.mark(4*1024);
1:5b9a6d9:         byte[] readBeforeReset = new byte[3*1024];
1:5b9a6d9:         byte[] readAfterReset = new byte[3*1024];
1:5b9a6d9:         fillArray(is, readBeforeReset);
1:5b9a6d9:         // Obtain something to compare with.
1:5b9a6d9:         InputStream src = getStream(128*1024);
1:5b9a6d9:         InputStreamUtil.skipFully(src, DEFAULT_INTERNAL_BUFFER_SIZE - 2*1024);
1:5b9a6d9:         byte[] comparisonRead = new byte[3*1024];
1:5b9a6d9:         fillArray(src, comparisonRead);
1:5b9a6d9:         // Compare
1:5b9a6d9:         assertEquals(new ByteArrayInputStream(comparisonRead),
1:5b9a6d9:                      new ByteArrayInputStream(readBeforeReset));
1:5b9a6d9:         // Reset the stream.
1:5b9a6d9:         is.reset();
1:5b9a6d9:         fillArray(is, readAfterReset);
1:5b9a6d9:         assertEquals(new ByteArrayInputStream(readBeforeReset),
1:5b9a6d9:                      new ByteArrayInputStream(readAfterReset));
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests that shifting of existing bytes works.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetShiftBytesMany_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(128*1024);
1:5b9a6d9:         is.read();
1:5b9a6d9:         is.read();
1:5b9a6d9:         // The following mark fits within the existing default buffer, but the
1:5b9a6d9:         // bytes after the mark have to be shifted to the left.
1:5b9a6d9:         is.mark(DEFAULT_INTERNAL_BUFFER_SIZE -6);
1:5b9a6d9:         byte[] readBeforeReset = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:5b9a6d9:         byte[] readAfterReset = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:5b9a6d9:         fillArray(is, readBeforeReset);
1:5b9a6d9:         // Obtain something to compare with.
1:5b9a6d9:         InputStream src = getStream(128*1024);
1:5b9a6d9:         src.read();
1:5b9a6d9:         src.read();
1:5b9a6d9:         byte[] comparisonRead = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:5b9a6d9:         fillArray(src, comparisonRead);
1:5b9a6d9:         // Compare
1:5b9a6d9:         assertEquals(new ByteArrayInputStream(comparisonRead),
1:5b9a6d9:                      new ByteArrayInputStream(readBeforeReset));
1:5b9a6d9:         // Reset the stream.
1:5b9a6d9:         is.reset();
1:5b9a6d9:         fillArray(is, readAfterReset);
1:5b9a6d9:         assertEquals(new ByteArrayInputStream(readBeforeReset),
1:5b9a6d9:                      new ByteArrayInputStream(readAfterReset));
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests an implementation specific feature of ReaderToUTF8Stream, which is
1:5b9a6d9:      * that the mark isn't invalidated even though we read past the read ahead
1:5b9a6d9:      * limit, given that the internal buffer doesn't have to be refilled.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * <em>WARNING</em>:This implementation specific feature should not be
1:5b9a6d9:      * relied on by the production code! It may change at any time.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetExceedReadAheadLimitOK_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(4*1024+17);
1:5b9a6d9:         is.mark(10);
1:5b9a6d9:         assertEquals(20, is.read(new byte[20]));
1:5b9a6d9:         // Note the following is implementation dependent.
1:5b9a6d9:         // Since the bytes are already stored in the internal buffer, we won't
1:5b9a6d9:         // fail the reset even though we have exceeded the read ahead limit.
1:5b9a6d9:         // With a different stream implementation, this may fail!
1:5b9a6d9:         is.reset();
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests that the reset-call will fail we exceed the mark ahead limit and
1:5b9a6d9:      * the internal buffer has to be refilled.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetExceedReadAheadLimitFail_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(64*1024+17);
1:5b9a6d9:         is.mark(10);
1:5b9a6d9:         // The internal buffer is 32 KB (implementation detail).
1:5b9a6d9:         int toRead = 38*1024+7;
1:5b9a6d9:         int read = 0;
1:5b9a6d9:         byte[] buf = new byte[toRead];
1:5b9a6d9:         while (read < toRead) {
1:5b9a6d9:             read += is.read(buf, read, toRead - read);
1:5b9a6d9:         }
1:5b9a6d9:         // Note the following is implementation dependent.
1:5b9a6d9:         try {
1:5b9a6d9:             is.reset();
1:5b9a6d9:             fail("reset-call was expected to throw IOException");
1:5b9a6d9:         } catch (IOException ioe) {
1:5b9a6d9:             // As expected, do nothing
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Reads almost enough bytes to read past the read ahead limit, then tests
1:5b9a6d9:      * that the reset works. After that, reads past the read ahead limit and
1:5b9a6d9:      * tests that the reset fails.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkResetOverflowInternalBufferKeepBytes()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(128*1024);
1:5b9a6d9:         is.mark(120*1024);
1:5b9a6d9:         byte[] buf = new byte[120*1024-1];
1:5b9a6d9:         fillArray(is, buf);
1:5b9a6d9:         is.reset();
1:5b9a6d9:         checkBeginningOfStream(is);
1:5b9a6d9: 
1:5b9a6d9:         // Again, but this time read past the read ahead limit.
1:5b9a6d9:         is = getStream(36*1024);
1:5b9a6d9:         is.mark(4*1024);
1:5b9a6d9:         buf = new byte[36*1024-1];
1:5b9a6d9:         fillArray(is, buf);
1:5b9a6d9:         try {
1:5b9a6d9:             is.reset();
1:5b9a6d9:             fail("reset-call was expected to throw IOException");
1:5b9a6d9:         }  catch (IOException ioe) {
1:5b9a6d9:             // As expected, do nothing
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Marks the stream with a read ahead limit larger than the stream itself,
1:5b9a6d9:      * then reads until the end of the stream.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * The current implementation does not allow the stream to be reset after
1:5b9a6d9:      * the last byte in the stream has been read once.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkReadUntilEOF()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         // Try with a single buffer fill first.
1:5b9a6d9:         InputStream is = getStream(4*1024);
1:5b9a6d9:         is.mark(8*1024);
1:5b9a6d9:         byte[] buf = new byte[8*1024];
1:5b9a6d9:         int read = 0;
1:5b9a6d9:         while (true) {
1:5b9a6d9:             int readNow = is.read(buf, read, buf.length - read);
1:5b9a6d9:             if (readNow == -1) {
1:5b9a6d9:                 break;
1:5b9a6d9:             }
1:5b9a6d9:             read += readNow;
1:5b9a6d9:         }
1:5b9a6d9:         try {
1:5b9a6d9:             is.reset();
1:5b9a6d9:             fail("reset-call was expected to throw IOException");
1:5b9a6d9:         } catch (IOException ioe) {
1:5b9a6d9:             // The current implementation does not allow resetting the stream
1:5b9a6d9:             // when the source stream itself has been drained and all the data
1:5b9a6d9:             // has been read once.
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         // Now try with multiple buffer fills.
1:5b9a6d9:         is = getStream(640*1024);
1:5b9a6d9:         is.mark(128*1024);
1:5b9a6d9:         buf = new byte[8*1024];
1:5b9a6d9:         while (true) {
1:5b9a6d9:             // Just drain the stream.
1:5b9a6d9:             if (is.read(buf, 0, buf.length) == -1) {
1:5b9a6d9:                 break;
1:5b9a6d9:             }
1:5b9a6d9:         }
1:5b9a6d9:         try {
1:5b9a6d9:             is.reset();
1:5b9a6d9:             fail("reset-call was expected to throw IOException");
1:5b9a6d9:         } catch (IOException ioe) {
1:5b9a6d9:             // The current implementation does not allow resetting the stream
1:5b9a6d9:             // when the source stream itself has been drained and all the data
1:5b9a6d9:             // has been read once.
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Marks the stream with a read ahead limit larger than the stream itself,
1:5b9a6d9:      * then reads until just before the end of the stream.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkReadAlmostUntilEOF()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         // Try with a single buffer fill first.
1:5b9a6d9:         int limit = 4*1024;
1:5b9a6d9:         InputStream is = getStream(limit);
1:5b9a6d9:         is.mark(8*1024);
1:5b9a6d9:         byte[] buf = new byte[limit*2];
1:5b9a6d9:         int read = 0;
1:5b9a6d9:         while (read < limit -1) {
1:5b9a6d9:             int readNow = is.read(buf, read, (limit -1) - read);
1:5b9a6d9:             if (readNow == -1) {
1:5b9a6d9:                 break;
1:5b9a6d9:             }
1:5b9a6d9:             read += readNow;
1:5b9a6d9:         }
1:5b9a6d9:         // EOF has been reached when filling the internal buffer, but we still
1:5b9a6d9:         // havent't read it. Therefore, the reset should succeed.
1:5b9a6d9:         is.reset();
1:5b9a6d9:         checkBeginningOfStream(is);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Makes sure that the header bytes are copied when creating a new buffer
1:5b9a6d9:      * to hold all the required bytes when the stream has been marked.
1:5b9a6d9:      * This will only happen the first time the buffer is filled, i.e. when the
1:5b9a6d9:      * stream is marked before the first read (mark at position zero).
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if something goes wrong
1:5b9a6d9:      */
1:5b9a6d9:     public void testHeaderPresentInStream_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         final int valueLen = DEFAULT_INTERNAL_BUFFER_SIZE + 5*1024;
1:5b9a6d9:         InputStream is = getStream(valueLen);
1:5b9a6d9:         is.mark(valueLen - 1024);
1:5b9a6d9:         // Obtain a header generator to compare with.
1:5b9a6d9:         ClobStreamHeaderGenerator hdrGen = new ClobStreamHeaderGenerator(false);
1:5b9a6d9:         byte[] hdrTmp = new byte[100];
1:5b9a6d9:         int headerLen = hdrGen.generateInto(hdrTmp, 0, valueLen);
1:5b9a6d9:         byte[] hdr1 = new byte[headerLen];
1:5b9a6d9:         System.arraycopy(hdrTmp, 0, hdr1, 0, headerLen);
1:5b9a6d9:         byte[] hdr2 = new byte[headerLen];
1:5b9a6d9:         // Get the first bytes from the stream being tested.
1:5b9a6d9:         assertEquals(headerLen, is.read(hdr2));
1:5b9a6d9:         assertEquals(new ByteArrayInputStream(hdr1),
1:5b9a6d9:                      new ByteArrayInputStream(hdr2));
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Returns a stream to test, loaded with the repeating modern latin
1:5b9a6d9:      * lowercase alphabet.
1:5b9a6d9:      *
1:5b9a6d9:      * @param length the length of the stream in characters
1:5b9a6d9:      * @return A stream serving bytes.
1:5b9a6d9:      */
1:5b9a6d9:     private InputStream getStream(int length) {
1:5b9a6d9:         Reader src = new LoopingAlphabetReader(length,
1:5b9a6d9:                                         CharAlphabet.modernLatinLowercase());
1:5b9a6d9:         InputStream is = new ReaderToUTF8Stream(
1:5b9a6d9:                 src, length, 0, "CLOB", new ClobStreamHeaderGenerator(false));
1:5b9a6d9:         assertTrue("The stream doesn't support mark/reset", is.markSupported());
1:5b9a6d9:         return is;
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Checks the beginning of the stream, which is expected to consist of five
1:5b9a6d9:      * header bytes (skipped) followed by the bytes for the characters 'a' and
1:5b9a6d9:      * 'b'.
1:5b9a6d9:      *
1:5b9a6d9:      * @param is the stream to check
1:5b9a6d9:      * @throws IOException if reading from the stream fails
1:5b9a6d9:      * @throws AssertionFailedError if the stream content isn't as expected
1:5b9a6d9:      */
1:5b9a6d9:     private void checkBeginningOfStream(InputStream is)
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         assertEquals(5, is.skip(5));
1:5b9a6d9:         // We should now get the character a, followed by b.
1:5b9a6d9:         assertEquals((byte)'a', is.read());
1:5b9a6d9:         assertEquals((byte)'b', is.read());
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Fills the array by reading from the stream.
1:5b9a6d9:      *
1:5b9a6d9:      * @param is input stream to read from
1:5b9a6d9:      * @param b array to fill with bytes from the stream
1:5b9a6d9:      * @throws IOException if reading from the array fails, or the end of the
1:5b9a6d9:      *      stream is reached
1:5b9a6d9:      */
1:5b9a6d9:     private void fillArray(InputStream is, byte[] b)
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         final int toRead = b.length;
1:5b9a6d9:         int read = 0;
1:5b9a6d9:         while (read < toRead) {
1:5b9a6d9:             int readNow = is.read(b, read, toRead - read);
1:5b9a6d9:             assertTrue("reached EOF", readNow != -1);
1:5b9a6d9:             read += readNow;
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Performs a series of random operations on a {@code ReaderToUTF8Stream},
1:5b9a6d9:      * consisting of read, skip, mark, reset and a noop.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * <em>Note</em>: Turn on debugging (derby.tests.debug=true) to see some
1:5b9a6d9:      * information, turn on tracing (derby.tests.trace=true) in addition to see
1:5b9a6d9:      * a lot more information.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * If the test fails, the seed will be reported in the error message, and
1:5b9a6d9:      * the load that failed can be rerun.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if the test fails
1:5b9a6d9:      */
1:5b9a6d9:     public void testRandomSequence()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         final long seed = System.currentTimeMillis();
1:5b9a6d9:         try {
1:5b9a6d9:             testRandomSequence(seed);
1:5b9a6d9:         } catch (IOException ioe) {
1:5b9a6d9:             // Report the seed for repeatability.
1:5b9a6d9:             IOException wrapper = new IOException("seed=" + seed);
1:5b9a6d9:             wrapper.initCause(ioe);
1:5b9a6d9:             throw wrapper;
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Performs a series of random operations on a {@code ReaderToUTF8Stream},
1:5b9a6d9:      * consisting of read, skip, mark, reset and a noop.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * Note that this test verifies that executing the operations don't fail,
1:5b9a6d9:      * but it doesn't verify that the bytes obtained from the stream are the
1:5b9a6d9:      * correct ones.
1:5b9a6d9:      *
1:5b9a6d9:      * @param seed seed controlling the test load
1:5b9a6d9:      * @throws IOException if the test fails
1:5b9a6d9:      */
1:5b9a6d9:     private void testRandomSequence(long seed)
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         println("testRandomSequence seed: " + seed);
1:5b9a6d9:         final int iterations = 100;
1:5b9a6d9:         final Random rng = new Random(seed);
1:5b9a6d9:         for (int i=0; i < iterations; i++) {
1:5b9a6d9:             // Operation counters.
1:5b9a6d9:             int reads = 0, skips = 0, resets = 0, marks = 0, invalidations = 0;
1:5b9a6d9:             // Stream length (up to ~1 MB).
1:5b9a6d9:             int length = 1024*rng.nextInt(1024) + rng.nextInt(1024);
1:5b9a6d9:             boolean rs = rng.nextBoolean();
1:5b9a6d9:             println(">>> iteration " + i + ", length=" + length);
1:5b9a6d9:             int currentPos = 0;
1:5b9a6d9:             int limit = 0;
1:5b9a6d9:             int mark = -1;
1:5b9a6d9:             InputStream is = getStream(length);
1:5b9a6d9:             int ops = 0;
1:5b9a6d9:             while (ops < 200 && currentPos < length - 10) {
1:5b9a6d9:                 if (rng.nextBoolean()) { // Whether to read/skip or mark/reset.
1:5b9a6d9:                     int toRead = getRandomLength(currentPos, length, rng, rs);
1:5b9a6d9:                     if (rng.nextBoolean()) {
1:5b9a6d9:                         // Read
1:5b9a6d9:                         mytrace("\treading " + toRead + " bytes");
1:5b9a6d9:                         reads++;
1:5b9a6d9:                         is.read(new byte[toRead]);
1:5b9a6d9:                     } else {
1:5b9a6d9:                         // Skip
1:5b9a6d9:                         mytrace("\tskipping " + toRead + " bytes");
1:5b9a6d9:                         skips++;
1:5b9a6d9:                         is.skip(toRead);
1:5b9a6d9:                     }
1:5b9a6d9:                     currentPos += toRead;
1:5b9a6d9:                     if (mark != -1 && (currentPos - mark) > limit) {
1:5b9a6d9:                         mytrace("\t\tmark invalidated");
1:5b9a6d9:                         invalidations++;
1:5b9a6d9:                         mark = -1;
1:5b9a6d9:                         limit = 0;
1:5b9a6d9:                     }
1:5b9a6d9:                 }
1:5b9a6d9:                 if (rng.nextBoolean()) { // Whether to read/skip or mark/reset.
1:5b9a6d9:                     // Mark/reset, or do nothing.
1:5b9a6d9:                     if (rng.nextBoolean()) {
1:5b9a6d9:                         if (rng.nextInt(100) < 40 && mark != -1) {
1:5b9a6d9:                             // Reset
1:5b9a6d9:                             mytrace("\tresetting to position " + mark);
1:5b9a6d9:                             resets++;
1:5b9a6d9:                             is.reset();
1:5b9a6d9:                             currentPos = mark;
1:5b9a6d9:                             mark = -1;
1:5b9a6d9:                         } else {
1:5b9a6d9:                             // Mark
1:5b9a6d9:                             limit = getRandomLength(currentPos, length, rng);
1:5b9a6d9:                             mytrace("\tmarking position " + currentPos +
1:5b9a6d9:                                     " with limit " + limit);
1:5b9a6d9:                             marks++;
1:5b9a6d9:                             mark = currentPos;
1:5b9a6d9:                             is.mark(limit);
1:5b9a6d9:                         }
1:5b9a6d9:                     }
1:5b9a6d9:                 }
1:5b9a6d9:                 ops++;
1:5b9a6d9:             }
1:5b9a6d9:             println("ops=" + ops + ", reads=" + reads + ", skips=" + skips +
1:5b9a6d9:                     ", marks=" + marks + ", resets=" + resets +
1:5b9a6d9:                     ", invalidations=" + invalidations);
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Returns a random length within the limits.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * This call will operate in the full range of the remaining bytes.
1:5b9a6d9:      *
1:5b9a6d9:      * @param currentPos the current position of the stream
1:5b9a6d9:      * @param length the length of the stream
1:5b9a6d9:      * @param rng random generator
1:5b9a6d9:      * @return A random length within the limits of the stream.
1:5b9a6d9:      */
1:5b9a6d9:     private int getRandomLength(int currentPos, int length, Random rng) {
1:5b9a6d9:         return getRandomLength(currentPos, length, rng, false);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Returns a random length within the limits.
1:5b9a6d9:      *
1:5b9a6d9:      * @param currentPos the current position of the stream
1:5b9a6d9:      * @param length the length of the stream
1:5b9a6d9:      * @param rng random generator
1:5b9a6d9:      * @param reducedSize whether to return smaller number or not
1:5b9a6d9:      *      (setting to true may increase the number of operations that will be
1:5b9a6d9:      *      performed on a stream before it is exhausted)
1:5b9a6d9:      * @return A random length within the limits of the stream.
1:5b9a6d9:      */
1:5b9a6d9:     private int getRandomLength(int currentPos, int length, Random rng, boolean reducedSize) {
1:5b9a6d9:         int max = length - currentPos;
1:5b9a6d9:         if (reducedSize) {
1:5b9a6d9:             max = max / 5;
1:5b9a6d9:         }
1:5b9a6d9:         return (1 + (int)(max * rng.nextFloat()));
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Trace only if both trace and verbose is true in the test configuration.
1:5b9a6d9:      *
1:5b9a6d9:      * @param str the string to print
1:5b9a6d9:      */
1:5b9a6d9:     private void mytrace(String str) {
1:5b9a6d9:         if (getTestConfiguration().isVerbose()) {
1:5b9a6d9:             traceit(str);
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests mark/reset functionality by comparing with
1:5b9a6d9:      * {@code ByteArrayInputStream}.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if the test fails
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkReset1()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(64*1024);
1:5b9a6d9:         byte[] srcBuf = new byte[64*1024+5];
1:5b9a6d9:         fillArray(is, srcBuf);
1:5b9a6d9:         InputStream src = new ByteArrayInputStream(srcBuf);
1:5b9a6d9:         // Reinitialize the stream.
1:5b9a6d9:         is = getStream(64*1024);
1:5b9a6d9: 
1:5b9a6d9:         StreamUtil su = new StreamUtil(is, src);
1:5b9a6d9:         su.mark(1024);
1:5b9a6d9:         su.skip(17);
1:5b9a6d9:         su.reset();
1:5b9a6d9:         su.read(1);
1:5b9a6d9:         su.read(2133);
1:5b9a6d9:         su.mark(1024);
1:5b9a6d9:         su.reset();
1:5b9a6d9:         su.mark(1024);
1:5b9a6d9:         su.skip(18);
1:5b9a6d9:         su.read(1024);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests mark/reset functionality by comparing with
1:5b9a6d9:      * {@code ByteArrayInputStream}. This test relies on knowing the size of
1:5b9a6d9:      * the internal buffer to force a shifting of existing bytes to take place.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws IOException if the test fails
1:5b9a6d9:      */
1:5b9a6d9:     public void testMarkReset2_Internal()
1:5b9a6d9:             throws IOException {
1:5b9a6d9:         InputStream is = getStream(128*1024);
1:5b9a6d9:         byte[] srcBuf = new byte[128*1024+5];
1:5b9a6d9:         fillArray(is, srcBuf);
1:5b9a6d9:         InputStream src = new ByteArrayInputStream(srcBuf);
1:5b9a6d9:         // Reinitialize the stream.
1:5b9a6d9:         is = getStream(128*1024);
1:5b9a6d9: 
1:5b9a6d9:         StreamUtil su = new StreamUtil(is, src);
1:5b9a6d9:         su.skip(DEFAULT_INTERNAL_BUFFER_SIZE);
1:5b9a6d9:         su.mark(DEFAULT_INTERNAL_BUFFER_SIZE + 2*1024);
1:5b9a6d9:         su.read(1024);
1:5b9a6d9:         su.reset();
1:5b9a6d9:         su.read(3*1024);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Utility class executing a few selected method calls on two streams,
1:5b9a6d9:      * expecting both of them to behave in the same way.
1:5b9a6d9:      */
1:5b9a6d9:     private class StreamUtil {
1:5b9a6d9:         private final InputStream is1;
1:5b9a6d9:         private final InputStream is2;
1:5b9a6d9: 
1:5b9a6d9:         StreamUtil(InputStream is1, InputStream is2) {
1:5b9a6d9:             assertNotNull(is1);
1:5b9a6d9:             assertNotNull(is2);
1:5b9a6d9:             this.is1 = is1;
1:5b9a6d9:             this.is2 = is2;
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         public void mark(int readAheadLimit) {
1:5b9a6d9:             is1.mark(readAheadLimit);
1:5b9a6d9:             is2.mark(readAheadLimit);
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         public void reset()
1:5b9a6d9:                 throws IOException {
1:5b9a6d9:             is1.reset();
1:5b9a6d9:             is2.reset();
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         public long skip(long skip)
1:5b9a6d9:                 throws IOException {
1:5b9a6d9:             long skip1 = 0;
1:5b9a6d9:             long skip2 = 0;
1:5b9a6d9:             // Skip data in the first stream.
1:5b9a6d9:             while (skip1 < skip) {
1:5b9a6d9:                 long skippedNow = is1.skip(skip - skip1);
1:5b9a6d9:                 if (skippedNow == -1) {
1:5b9a6d9:                     fail("stream one reached EOF: " + is1.getClass());
1:5b9a6d9:                 }
1:5b9a6d9:                 skip1 += skippedNow;
1:5b9a6d9:             }
1:5b9a6d9:             // Skip data in the second stream.
1:5b9a6d9:             while (skip2 < skip) {
1:5b9a6d9:                 long skippedNow = is2.skip(skip - skip2);
1:5b9a6d9:                 if (skippedNow == -1) {
1:5b9a6d9:                     fail("stream two reached EOF: " + is2.getClass());
1:5b9a6d9:                 }
1:5b9a6d9:                 skip2 += skippedNow;
1:5b9a6d9:             }
1:5b9a6d9:             assertEquals(skip1, skip2);
1:5b9a6d9:             return skip1;
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         public int read(int toRead)
1:5b9a6d9:                 throws IOException {
1:5b9a6d9:             byte[] b1 = new byte[toRead];
1:5b9a6d9:             byte[] b2 = new byte[toRead];
1:5b9a6d9:             int read = read(b1, b2, false);
1:5b9a6d9:             assertEquals(new ByteArrayInputStream(b1),
1:5b9a6d9:                          new ByteArrayInputStream(b2));
1:5b9a6d9:             return read;
1:5b9a6d9:         }
1:5b9a6d9: 
1:5b9a6d9:         public int read(byte[] b1, byte[] b2, boolean expectEOF)
1:5b9a6d9:                 throws IOException {
1:5b9a6d9:             assertEquals("unequal sized arrays", b1.length, b2.length);
1:5b9a6d9:             int read1 = 0;
1:5b9a6d9:             int read2 = 0;
1:5b9a6d9:             final int toRead = b1.length;
1:5b9a6d9:             // Read from the first stream.
1:5b9a6d9:             while (read1 < toRead) {
1:5b9a6d9:                 int readNow = is1.read(b1, read1, toRead - read1);
1:5b9a6d9:                 if (readNow == -1) {
1:5b9a6d9:                     if (expectEOF) {
1:5b9a6d9:                         break;
1:5b9a6d9:                     } else {
1:5b9a6d9:                         fail("stream one reached EOF: " + is1.getClass());
1:5b9a6d9:                     }
1:5b9a6d9:                 }
1:5b9a6d9:                 read1 += readNow;
1:5b9a6d9:             }
1:5b9a6d9:             // Read from the second stream.
1:5b9a6d9:             while (read2 < toRead) {
1:5b9a6d9:                 int readNow = is2.read(b2, read2, toRead - read2);
1:5b9a6d9:                 if (readNow == -1) {
1:5b9a6d9:                     if (expectEOF) {
1:5b9a6d9:                         break;
1:5b9a6d9:                     } else {
1:5b9a6d9:                         fail("stream two reached EOF: " + is2.getClass());
1:5b9a6d9:                     }
1:5b9a6d9:                 }
1:5b9a6d9:                 read2 += readNow;
1:5b9a6d9:             }
1:5b9a6d9:             assertEquals(read1, read2);
1:5b9a6d9:             return read1;
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         return new BaseTestSuite(ReaderToUTF8StreamTest.class);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:5b9a6d9
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.junit.ReaderToUTF8StreamTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.junit;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.util.Arrays;
1: import java.util.Random;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derby.iapi.services.io.InputStreamUtil;
1: import org.apache.derby.iapi.types.ClobStreamHeaderGenerator;
1: import org.apache.derby.iapi.types.ReaderToUTF8Stream;
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: 
1: /**
1:  * Unit tests for ReaderToUTF8Stream.
1:  * <p>
1:  * Explicit tests for the mark/reset feature start with "testMark".
1:  */
1: public class ReaderToUTF8StreamTest
1:         extends BaseTestCase {
1: 
1:     /**
1:      * The default size of the internal buffer in ReaderToUTF8Stream. Used to
1:      * trigger specific events in the reader.
1:      */
1:     private static int DEFAULT_INTERNAL_BUFFER_SIZE = 32*1024;
1: 
1:     public ReaderToUTF8StreamTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         return new TestSuite(ReaderToUTF8StreamTest.class);
1:     }
1: 
1:     /**
1:      * Tests a very basic use of the mark/reset mechanism.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetSimplePosZero()
1:             throws IOException {
1:         InputStream is = getStream(100);
1:         is.mark(10);
1:         assertEquals(10, is.read(new byte[10]));
1:         is.reset();
1:         checkBeginningOfStream(is);
1:     }
1: 
1:     /**
1:      * Tests a very basic use of the mark/reset mechanism.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetSimplePosNonZero()
1:             throws IOException {
1:         InputStream is = getStream(200);
1:         assertEquals(127, is.read(new byte[127]));
1:         is.mark(10);
1:         byte[] readBeforeReset = new byte[10];
1:         byte[] readAfterReset = new byte[10];
1:         assertEquals(10, is.read(readBeforeReset));
1:         is.reset();
1:         assertEquals(10, is.read(readAfterReset));
1:         assertTrue(Arrays.equals(readBeforeReset, readAfterReset));
1:     }
1: 
1:     /**
1:      * Tests that shifting of existing bytes works.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetShiftBytesFew_Internal()
1:             throws IOException {
1:         InputStream is = getStream(128*1024);
1:         byte[] buf = new byte[DEFAULT_INTERNAL_BUFFER_SIZE - 2*1024];
1:         fillArray(is, buf);
1:         // The following mark fits within the existing default buffer, but the
1:         // bytes after the mark have to be shifted to the left.
1:         is.mark(4*1024);
1:         byte[] readBeforeReset = new byte[3*1024];
1:         byte[] readAfterReset = new byte[3*1024];
1:         fillArray(is, readBeforeReset);
1:         // Obtain something to compare with.
1:         InputStream src = getStream(128*1024);
1:         InputStreamUtil.skipFully(src, DEFAULT_INTERNAL_BUFFER_SIZE - 2*1024);
1:         byte[] comparisonRead = new byte[3*1024];
1:         fillArray(src, comparisonRead);
1:         // Compare
1:         assertEquals(new ByteArrayInputStream(comparisonRead),
1:                      new ByteArrayInputStream(readBeforeReset));
1:         // Reset the stream.
1:         is.reset();
1:         fillArray(is, readAfterReset);
1:         assertEquals(new ByteArrayInputStream(readBeforeReset),
1:                      new ByteArrayInputStream(readAfterReset));
1:     }
1: 
1:     /**
1:      * Tests that shifting of existing bytes works.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetShiftBytesMany_Internal()
1:             throws IOException {
1:         InputStream is = getStream(128*1024);
1:         is.read();
1:         is.read();
1:         // The following mark fits within the existing default buffer, but the
1:         // bytes after the mark have to be shifted to the left.
1:         is.mark(DEFAULT_INTERNAL_BUFFER_SIZE -6);
1:         byte[] readBeforeReset = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:         byte[] readAfterReset = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:         fillArray(is, readBeforeReset);
1:         // Obtain something to compare with.
1:         InputStream src = getStream(128*1024);
1:         src.read();
1:         src.read();
1:         byte[] comparisonRead = new byte[DEFAULT_INTERNAL_BUFFER_SIZE -6];
1:         fillArray(src, comparisonRead);
1:         // Compare
1:         assertEquals(new ByteArrayInputStream(comparisonRead),
1:                      new ByteArrayInputStream(readBeforeReset));
1:         // Reset the stream.
1:         is.reset();
1:         fillArray(is, readAfterReset);
1:         assertEquals(new ByteArrayInputStream(readBeforeReset),
1:                      new ByteArrayInputStream(readAfterReset));
1:     }
1: 
1:     /**
1:      * Tests an implementation specific feature of ReaderToUTF8Stream, which is
1:      * that the mark isn't invalidated even though we read past the read ahead
1:      * limit, given that the internal buffer doesn't have to be refilled.
1:      * <p>
1:      * <em>WARNING</em>:This implementation specific feature should not be
1:      * relied on by the production code! It may change at any time.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetExceedReadAheadLimitOK_Internal()
1:             throws IOException {
1:         InputStream is = getStream(4*1024+17);
1:         is.mark(10);
1:         assertEquals(20, is.read(new byte[20]));
1:         // Note the following is implementation dependent.
1:         // Since the bytes are already stored in the internal buffer, we won't
1:         // fail the reset even though we have exceeded the read ahead limit.
1:         // With a different stream implementation, this may fail!
1:         is.reset();
1:     }
1: 
1:     /**
1:      * Tests that the reset-call will fail we exceed the mark ahead limit and
1:      * the internal buffer has to be refilled.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetExceedReadAheadLimitFail_Internal()
1:             throws IOException {
1:         InputStream is = getStream(64*1024+17);
1:         is.mark(10);
1:         // The internal buffer is 32 KB (implementation detail).
1:         int toRead = 38*1024+7;
1:         int read = 0;
1:         byte[] buf = new byte[toRead];
1:         while (read < toRead) {
1:             read += is.read(buf, read, toRead - read);
1:         }
1:         // Note the following is implementation dependent.
1:         try {
1:             is.reset();
1:             fail("reset-call was expected to throw IOException");
1:         } catch (IOException ioe) {
1:             // As expected, do nothing
1:         }
1:     }
1: 
1:     /**
1:      * Reads almost enough bytes to read past the read ahead limit, then tests
1:      * that the reset works. After that, reads past the read ahead limit and
1:      * tests that the reset fails.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkResetOverflowInternalBufferKeepBytes()
1:             throws IOException {
1:         InputStream is = getStream(128*1024);
1:         is.mark(120*1024);
1:         byte[] buf = new byte[120*1024-1];
1:         fillArray(is, buf);
1:         is.reset();
1:         checkBeginningOfStream(is);
1: 
1:         // Again, but this time read past the read ahead limit.
1:         is = getStream(36*1024);
1:         is.mark(4*1024);
1:         buf = new byte[36*1024-1];
1:         fillArray(is, buf);
1:         try {
1:             is.reset();
1:             fail("reset-call was expected to throw IOException");
1:         }  catch (IOException ioe) {
1:             // As expected, do nothing
1:         }
1:     }
1: 
1:     /**
1:      * Marks the stream with a read ahead limit larger than the stream itself,
1:      * then reads until the end of the stream.
1:      * <p>
1:      * The current implementation does not allow the stream to be reset after
1:      * the last byte in the stream has been read once.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkReadUntilEOF()
1:             throws IOException {
1:         // Try with a single buffer fill first.
1:         InputStream is = getStream(4*1024);
1:         is.mark(8*1024);
1:         byte[] buf = new byte[8*1024];
1:         int read = 0;
1:         while (true) {
1:             int readNow = is.read(buf, read, buf.length - read);
1:             if (readNow == -1) {
1:                 break;
1:             }
1:             read += readNow;
1:         }
1:         try {
1:             is.reset();
1:             fail("reset-call was expected to throw IOException");
1:         } catch (IOException ioe) {
1:             // The current implementation does not allow resetting the stream
1:             // when the source stream itself has been drained and all the data
1:             // has been read once.
1:         }
1: 
1:         // Now try with multiple buffer fills.
1:         is = getStream(640*1024);
1:         is.mark(128*1024);
1:         buf = new byte[8*1024];
1:         while (true) {
1:             // Just drain the stream.
1:             if (is.read(buf, 0, buf.length) == -1) {
1:                 break;
1:             }
1:         }
1:         try {
1:             is.reset();
1:             fail("reset-call was expected to throw IOException");
1:         } catch (IOException ioe) {
1:             // The current implementation does not allow resetting the stream
1:             // when the source stream itself has been drained and all the data
1:             // has been read once.
1:         }
1:     }
1: 
1:     /**
1:      * Marks the stream with a read ahead limit larger than the stream itself,
1:      * then reads until just before the end of the stream.
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testMarkReadAlmostUntilEOF()
1:             throws IOException {
1:         // Try with a single buffer fill first.
1:         int limit = 4*1024;
1:         InputStream is = getStream(limit);
1:         is.mark(8*1024);
1:         byte[] buf = new byte[limit*2];
1:         int read = 0;
1:         while (read < limit -1) {
1:             int readNow = is.read(buf, read, (limit -1) - read);
1:             if (readNow == -1) {
1:                 break;
1:             }
1:             read += readNow;
1:         }
1:         // EOF has been reached when filling the internal buffer, but we still
1:         // havent't read it. Therefore, the reset should succeed.
1:         is.reset();
1:         checkBeginningOfStream(is);
1:     }
1: 
1:     /**
1:      * Makes sure that the header bytes are copied when creating a new buffer
1:      * to hold all the required bytes when the stream has been marked.
1:      * This will only happen the first time the buffer is filled, i.e. when the
1:      * stream is marked before the first read (mark at position zero).
1:      *
1:      * @throws IOException if something goes wrong
1:      */
1:     public void testHeaderPresentInStream_Internal()
1:             throws IOException {
1:         final int valueLen = DEFAULT_INTERNAL_BUFFER_SIZE + 5*1024;
1:         InputStream is = getStream(valueLen);
1:         is.mark(valueLen - 1024);
1:         // Obtain a header generator to compare with.
1:         ClobStreamHeaderGenerator hdrGen = new ClobStreamHeaderGenerator(false);
1:         byte[] hdrTmp = new byte[100];
1:         int headerLen = hdrGen.generateInto(hdrTmp, 0, valueLen);
1:         byte[] hdr1 = new byte[headerLen];
1:         System.arraycopy(hdrTmp, 0, hdr1, 0, headerLen);
1:         byte[] hdr2 = new byte[headerLen];
1:         // Get the first bytes from the stream being tested.
1:         assertEquals(headerLen, is.read(hdr2));
1:         assertEquals(new ByteArrayInputStream(hdr1),
1:                      new ByteArrayInputStream(hdr2));
1:     }
1: 
1:     /**
1:      * Returns a stream to test, loaded with the repeating modern latin
1:      * lowercase alphabet.
1:      *
1:      * @param length the length of the stream in characters
1:      * @return A stream serving bytes.
1:      */
1:     private InputStream getStream(int length) {
1:         Reader src = new LoopingAlphabetReader(length,
1:                                         CharAlphabet.modernLatinLowercase());
1:         InputStream is = new ReaderToUTF8Stream(
1:                 src, length, 0, "CLOB", new ClobStreamHeaderGenerator(false));
1:         assertTrue("The stream doesn't support mark/reset", is.markSupported());
1:         return is;
1:     }
1: 
1:     /**
1:      * Checks the beginning of the stream, which is expected to consist of five
1:      * header bytes (skipped) followed by the bytes for the characters 'a' and
1:      * 'b'.
1:      *
1:      * @param is the stream to check
1:      * @throws IOException if reading from the stream fails
1:      * @throws AssertionFailedError if the stream content isn't as expected
1:      */
1:     private void checkBeginningOfStream(InputStream is)
1:             throws IOException {
1:         assertEquals(5, is.skip(5));
1:         // We should now get the character a, followed by b.
1:         assertEquals((byte)'a', is.read());
1:         assertEquals((byte)'b', is.read());
1:     }
1: 
1:     /**
1:      * Fills the array by reading from the stream.
1:      *
1:      * @param is input stream to read from
1:      * @param b array to fill with bytes from the stream
1:      * @throws IOException if reading from the array fails, or the end of the
1:      *      stream is reached
1:      */
1:     private void fillArray(InputStream is, byte[] b)
1:             throws IOException {
1:         final int toRead = b.length;
1:         int read = 0;
1:         while (read < toRead) {
1:             int readNow = is.read(b, read, toRead - read);
1:             assertTrue("reached EOF", readNow != -1);
1:             read += readNow;
1:         }
1:     }
1: 
1:     /**
1:      * Performs a series of random operations on a {@code ReaderToUTF8Stream},
1:      * consisting of read, skip, mark, reset and a noop.
1:      * <p>
1:      * <em>Note</em>: Turn on debugging (derby.tests.debug=true) to see some
1:      * information, turn on tracing (derby.tests.trace=true) in addition to see
1:      * a lot more information.
1:      * <p>
1:      * If the test fails, the seed will be reported in the error message, and
1:      * the load that failed can be rerun.
1:      *
1:      * @throws IOException if the test fails
1:      */
1:     public void testRandomSequence()
1:             throws IOException {
1:         final long seed = System.currentTimeMillis();
1:         try {
1:             testRandomSequence(seed);
1:         } catch (IOException ioe) {
1:             // Report the seed for repeatability.
1:             IOException wrapper = new IOException("seed=" + seed);
1:             wrapper.initCause(ioe);
1:             throw wrapper;
1:         }
1:     }
1: 
1:     /**
1:      * Performs a series of random operations on a {@code ReaderToUTF8Stream},
1:      * consisting of read, skip, mark, reset and a noop.
1:      * <p>
1:      * Note that this test verifies that executing the operations don't fail,
1:      * but it doesn't verify that the bytes obtained from the stream are the
1:      * correct ones.
1:      *
1:      * @param seed seed controlling the test load
1:      * @throws IOException if the test fails
1:      */
1:     private void testRandomSequence(long seed)
1:             throws IOException {
1:         println("testRandomSequence seed: " + seed);
1:         final int iterations = 100;
1:         final Random rng = new Random(seed);
1:         for (int i=0; i < iterations; i++) {
1:             // Operation counters.
1:             int reads = 0, skips = 0, resets = 0, marks = 0, invalidations = 0;
1:             // Stream length (up to ~1 MB).
1:             int length = 1024*rng.nextInt(1024) + rng.nextInt(1024);
1:             boolean rs = rng.nextBoolean();
1:             println(">>> iteration " + i + ", length=" + length);
1:             int currentPos = 0;
1:             int limit = 0;
1:             int mark = -1;
1:             InputStream is = getStream(length);
1:             int ops = 0;
1:             while (ops < 200 && currentPos < length - 10) {
1:                 if (rng.nextBoolean()) { // Whether to read/skip or mark/reset.
1:                     int toRead = getRandomLength(currentPos, length, rng, rs);
1:                     if (rng.nextBoolean()) {
1:                         // Read
1:                         mytrace("\treading " + toRead + " bytes");
1:                         reads++;
1:                         is.read(new byte[toRead]);
1:                     } else {
1:                         // Skip
1:                         mytrace("\tskipping " + toRead + " bytes");
1:                         skips++;
1:                         is.skip(toRead);
1:                     }
1:                     currentPos += toRead;
1:                     if (mark != -1 && (currentPos - mark) > limit) {
1:                         mytrace("\t\tmark invalidated");
1:                         invalidations++;
1:                         mark = -1;
1:                         limit = 0;
1:                     }
1:                 }
1:                 if (rng.nextBoolean()) { // Whether to read/skip or mark/reset.
1:                     // Mark/reset, or do nothing.
1:                     if (rng.nextBoolean()) {
1:                         if (rng.nextInt(100) < 40 && mark != -1) {
1:                             // Reset
1:                             mytrace("\tresetting to position " + mark);
1:                             resets++;
1:                             is.reset();
1:                             currentPos = mark;
1:                             mark = -1;
1:                         } else {
1:                             // Mark
1:                             limit = getRandomLength(currentPos, length, rng);
1:                             mytrace("\tmarking position " + currentPos +
1:                                     " with limit " + limit);
1:                             marks++;
1:                             mark = currentPos;
1:                             is.mark(limit);
1:                         }
1:                     }
1:                 }
1:                 ops++;
1:             }
1:             println("ops=" + ops + ", reads=" + reads + ", skips=" + skips +
1:                     ", marks=" + marks + ", resets=" + resets +
1:                     ", invalidations=" + invalidations);
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Returns a random length within the limits.
1:      * <p>
1:      * This call will operate in the full range of the remaining bytes.
1:      *
1:      * @param currentPos the current position of the stream
1:      * @param length the length of the stream
1:      * @param rng random generator
1:      * @return A random length within the limits of the stream.
1:      */
1:     private int getRandomLength(int currentPos, int length, Random rng) {
1:         return getRandomLength(currentPos, length, rng, false);
1:     }
1: 
1:     /**
1:      * Returns a random length within the limits.
1:      *
1:      * @param currentPos the current position of the stream
1:      * @param length the length of the stream
1:      * @param rng random generator
1:      * @param reducedSize whether to return smaller number or not
1:      *      (setting to true may increase the number of operations that will be
1:      *      performed on a stream before it is exhausted)
1:      * @return A random length within the limits of the stream.
1:      */
1:     private int getRandomLength(int currentPos, int length, Random rng, boolean reducedSize) {
1:         int max = length - currentPos;
1:         if (reducedSize) {
1:             max = max / 5;
1:         }
1:         return (1 + (int)(max * rng.nextFloat()));
1:     }
1: 
1:     /**
1:      * Trace only if both trace and verbose is true in the test configuration.
1:      *
1:      * @param str the string to print
1:      */
1:     private void mytrace(String str) {
1:         if (getTestConfiguration().isVerbose()) {
1:             traceit(str);
1:         }
1:     }
1: 
1:     /**
1:      * Tests mark/reset functionality by comparing with
1:      * {@code ByteArrayInputStream}.
1:      *
1:      * @throws IOException if the test fails
1:      */
1:     public void testMarkReset1()
1:             throws IOException {
1:         InputStream is = getStream(64*1024);
1:         byte[] srcBuf = new byte[64*1024+5];
1:         fillArray(is, srcBuf);
1:         InputStream src = new ByteArrayInputStream(srcBuf);
1:         // Reinitialize the stream.
1:         is = getStream(64*1024);
1: 
1:         StreamUtil su = new StreamUtil(is, src);
1:         su.mark(1024);
1:         su.skip(17);
1:         su.reset();
1:         su.read(1);
1:         su.read(2133);
1:         su.mark(1024);
1:         su.reset();
1:         su.mark(1024);
1:         su.skip(18);
1:         su.read(1024);
1:     }
1: 
1:     /**
1:      * Tests mark/reset functionality by comparing with
1:      * {@code ByteArrayInputStream}. This test relies on knowing the size of
1:      * the internal buffer to force a shifting of existing bytes to take place.
1:      *
1:      * @throws IOException if the test fails
1:      */
1:     public void testMarkReset2_Internal()
1:             throws IOException {
1:         InputStream is = getStream(128*1024);
1:         byte[] srcBuf = new byte[128*1024+5];
1:         fillArray(is, srcBuf);
1:         InputStream src = new ByteArrayInputStream(srcBuf);
1:         // Reinitialize the stream.
1:         is = getStream(128*1024);
1: 
1:         StreamUtil su = new StreamUtil(is, src);
1:         su.skip(DEFAULT_INTERNAL_BUFFER_SIZE);
1:         su.mark(DEFAULT_INTERNAL_BUFFER_SIZE + 2*1024);
1:         su.read(1024);
1:         su.reset();
1:         su.read(3*1024);
1:     }
1: 
1:     /**
1:      * Utility class executing a few selected method calls on two streams,
1:      * expecting both of them to behave in the same way.
1:      */
1:     private class StreamUtil {
1:         private final InputStream is1;
1:         private final InputStream is2;
1: 
1:         StreamUtil(InputStream is1, InputStream is2) {
1:             assertNotNull(is1);
1:             assertNotNull(is2);
1:             this.is1 = is1;
1:             this.is2 = is2;
1:         }
1: 
1:         public void mark(int readAheadLimit) {
1:             is1.mark(readAheadLimit);
1:             is2.mark(readAheadLimit);
1:         }
1: 
1:         public void reset()
1:                 throws IOException {
1:             is1.reset();
1:             is2.reset();
1:         }
1: 
1:         public long skip(long skip)
1:                 throws IOException {
1:             long skip1 = 0;
1:             long skip2 = 0;
1:             // Skip data in the first stream.
1:             while (skip1 < skip) {
1:                 long skippedNow = is1.skip(skip - skip1);
1:                 if (skippedNow == -1) {
1:                     fail("stream one reached EOF: " + is1.getClass());
1:                 }
1:                 skip1 += skippedNow;
1:             }
1:             // Skip data in the second stream.
1:             while (skip2 < skip) {
1:                 long skippedNow = is2.skip(skip - skip2);
1:                 if (skippedNow == -1) {
1:                     fail("stream two reached EOF: " + is2.getClass());
1:                 }
1:                 skip2 += skippedNow;
1:             }
1:             assertEquals(skip1, skip2);
1:             return skip1;
1:         }
1: 
1:         public int read(int toRead)
1:                 throws IOException {
1:             byte[] b1 = new byte[toRead];
1:             byte[] b2 = new byte[toRead];
1:             int read = read(b1, b2, false);
1:             assertEquals(new ByteArrayInputStream(b1),
1:                          new ByteArrayInputStream(b2));
1:             return read;
1:         }
1: 
1:         public int read(byte[] b1, byte[] b2, boolean expectEOF)
1:                 throws IOException {
1:             assertEquals("unequal sized arrays", b1.length, b2.length);
1:             int read1 = 0;
1:             int read2 = 0;
1:             final int toRead = b1.length;
1:             // Read from the first stream.
1:             while (read1 < toRead) {
1:                 int readNow = is1.read(b1, read1, toRead - read1);
1:                 if (readNow == -1) {
1:                     if (expectEOF) {
1:                         break;
1:                     } else {
1:                         fail("stream one reached EOF: " + is1.getClass());
1:                     }
1:                 }
1:                 read1 += readNow;
1:             }
1:             // Read from the second stream.
1:             while (read2 < toRead) {
1:                 int readNow = is2.read(b2, read2, toRead - read2);
1:                 if (readNow == -1) {
1:                     if (expectEOF) {
1:                         break;
1:                     } else {
1:                         fail("stream two reached EOF: " + is2.getClass());
1:                     }
1:                 }
1:                 read2 += readNow;
1:             }
1:             assertEquals(read1, read2);
1:             return read1;
1:         }
1:     }
1: }
============================================================================