1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.AccessFactory
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
3:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PropertySetCallback;
1:eac0369: import java.util.Properties;
1:eac0369: import java.io.File;
1:eac0369: 
4:eac0369: /**
1:eac0369: 
1:eac0369:   Module interface for an access manager.  An access manager provides
1:eac0369:   transactional access via access methods to data in a single storage
1:eac0369:   manager.
1:eac0369:   <p>
1:eac0369:   An AccessFactory is typically obtained from the Monitor:
1:eac0369:   <p>
1:eac0369:   <blockquote><pre>
1:eac0369: 	// Get the current transaction controller.
1:eac0369: 	AccessFactory af;
1:eac0369: 	af = (AccessFactory) Monitor.findServiceModule(this, AccessFactory.MODULE);
1:eac0369:   </pre></blockquote>
1:eac0369: **/
1:eac0369: 
1:eac0369: public interface AccessFactory
1:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * Used to identify this interface when finding it with the Monitor.
1:eac0369:      **/
1:eac0369: 	public static final String MODULE = 
1:eac0369:         "org.apache.derby.iapi.store.access.AccessFactory";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Register an access method that this access manager can use.
1:eac0369: 	 **/
1:eac0369: 	void registerAccessMethod(MethodFactory factory);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Database creation has finished.
1:fbb8866:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	public void createFinished() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *Find an access method that implements an implementation type.
1:fbb8866:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	MethodFactory findMethodFactoryByImpl(String impltype)
2:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Find an access method that implements a format type.
1:eac0369: 	 **/
1:eac0369: 	MethodFactory findMethodFactoryByFormat(UUID format);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the LockFactory to use with this store.
1:fbb8866:      *
1:eac0369: 	 * @return The lock factory to use with this store.
1:fbb8866:      *
1:eac0369:      **/
1:eac0369: 	public LockFactory getLockFactory();
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the XAResourceManager associated with this AccessFactory.
1:eac0369:      * <p>
1:eac0369:      * Returns an object which can be used to implement the "offline" 
1:eac0369:      * 2 phase commit interaction between the accessfactory and outstanding
1:eac0369:      * transaction managers taking care of in-doubt transactions.
8:eac0369:      *
1:eac0369:      * @return The XAResourceManager associated with this accessfactory.
1:eac0369:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public /* XAResourceManager */ Object getXAResourceManager()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the store read-only.
1:eac0369: 	 */
1:eac0369: 	public boolean isReadOnly();
1:eac0369: 
1:9496f49:     /**
1:9496f49:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:9496f49:      *  database files) at database hard upgrade time)
1:9496f49:      * This gets called during hard upgrade. It will create 3 readme files
1:9496f49:      *  one in database directory, one in "seg0" directory and one in log
1:9496f49:      *  directory. These readme files warn users against touching any of
1:9496f49:      *  files associated with derby database 
1:9496f49:      */
1:9496f49:     public void createReadMeFiles()
1:9496f49:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * methods that are Property related.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * methods that are transaction related.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:4aeada8: 	/**
1:eac0369: 	 * Get a transaction controller with which to manipulate data within
1:eac0369: 	 * the access manager.  Implicitly creates an access context if one
1:eac0369: 	 * does not already exist.
1:eac0369:      *
1:eac0369:      * @param cm    The context manager for the current context.
1:eac0369:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 * @see TransactionController
1:eac0369: 	 **/
1:eac0369: 
1:eac0369: 	TransactionController getTransaction(ContextManager cm)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get a transaction. If a new transaction is 
1:eac0369:      * implicitly created, give it name transName.
1:eac0369:      *
1:eac0369:      * @param cm            The context manager for the current context.
1:eac0369:      * @param transName     If a new transaction is started, it will be given 
1:eac0369:      *                      this name.  The name is displayed in the 
1:eac0369:      *                      transactiontable VTI.
1:eac0369:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see TransactionController
1:eac0369: 	 * @see AccessFactory#getTransaction
1:eac0369:      */
1:eac0369: 	TransactionController getAndNameTransaction(
1:eac0369:     ContextManager  cm, 
1:eac0369:     String          transName)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return a snap shot of all transactions in the db.
1:eac0369:      * <p>
1:eac0369:      * Take a snap shot of all transactions currently in the database and make
1:eac0369:      * a record of their information.
1:eac0369:      *
1:eac0369:      * @return an array of TransactionInfo, or null if there is 
1:eac0369:      *         no transaction in the database.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public TransactionInfo[] getTransactionInfo();
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Start a global transaction.
1:eac0369:      * <p>
1:eac0369: 	 * Get a transaction controller with which to manipulate data within
1:eac0369: 	 * the access manager.  Implicitly creates an access context.
1:eac0369:      * <p>
1:eac0369:      * Must only be called if no other transaction context exists in the
1:eac0369:      * current context manager.  If another transaction exists in the context
1:eac0369:      * an exception will be thrown.
1:eac0369:      * <p>
1:eac0369:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:eac0369:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:eac0369:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:eac0369:      * in the path.
1:eac0369:      * <p>
1:eac0369:      * If the global transaction id given matches an existing in-doubt global
1:eac0369:      * transaction in the current system, then a StandardException will
1:eac0369:      * be thrown with a state of SQLState.STORE_XA_XAER_DUPID.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param cm        The context manager for the current context.
1:eac0369:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:eac0369:      * @param global_id the global transaction identifier part of XID - ie.
1:eac0369:      *                  Xid.getGlobalTransactionId().
1:eac0369:      * @param branch_id The branch qualifier of the Xid - ie.
1:eac0369:      *                  Xid.getBranchQaulifier()
1:eac0369:      *
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 * @see TransactionController
1:eac0369: 	 **/
1:eac0369: 	/* XATransactionController */ Object startXATransaction(
1:eac0369:     ContextManager  cm,
1:eac0369:     int             format_id,
1:eac0369:     byte[]          global_id,
1:eac0369:     byte[]          branch_id)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * methods that implement functionality on the 
1:eac0369:      *     org.apache.derby.iapi.db API
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:4aeada8:      * Start the replication master role for this database
1:964abfa:      * @param dbmaster The master database that is being replicated.
1:4aeada8:      * @param host The hostname for the slave
1:4aeada8:      * @param port The port the slave is listening on
1:4aeada8:      * @param replicationMode The type of replication contract.
1:4aeada8:      * Currently only asynchronous replication is supported, but
1:4aeada8:      * 1-safe/2-safe/very-safe modes may be added later.
1:4aeada8:      * @exception StandardException Standard Derby exception policy,
1:4aeada8:      * thrown on error.
1:4aeada8:      */
1:964abfa:     public void startReplicationMaster(String dbmaster, String host, int port,
1:4aeada8:                                        String replicationMode)
1:4aeada8:         throws StandardException;
1:4aeada8: 
1:54be3b4:     /**
1:54be3b4:      * Stop the replication master role for this database.
1:54be3b4:      * 
1:54be3b4:      * @exception StandardException Standard Derby exception policy,
1:54be3b4:      * thrown on error.
1:54be3b4:      */
1:54be3b4:     public void stopReplicationMaster() throws StandardException;
1:fd20d6b:         
1:fd20d6b:     /**
1:fd20d6b:      * Start the failover for this database.
1:fd20d6b:      *
1:fd20d6b:      * @param dbname the replication database that is being failed over.
1:fd20d6b:      * 
1:fd20d6b:      * @exception StandardException Standard Derby exception policy,
1:fd20d6b:      *                           1) If the failover succeeds, an exception is
1:fd20d6b:      *                              thrown to indicate that the master database
1:fd20d6b:      *                              was shutdown after a successful failover
1:fd20d6b:      *                           2) If a failure occurs during network 
1:fd20d6b:      *                              communication with slave.
1:fd20d6b:      */
1:fd20d6b:     public void failover(String dbname) throws StandardException;
1:fd20d6b:     
1:54be3b4: 
1:eac0369: 	/**
1:eac0369: 	  * Freeze the database temporarily so a backup can be taken.
1:402725c: 	  * <P>Please see Derby on line documentation on backup and restore.
1:eac0369: 	  *
4:eac0369: 	  * @exception StandardException Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void freeze() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  * Unfreeze the database after a backup has been taken.
1:402725c: 	  * <P>Please see Derby on line documentation on backup and restore.
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void unfreeze() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:fbb8866:      * Backup the database to backupDir.  
1:402725c:      * <P>Please see Derby on line documentation on backup and restore.
1:fbb8866:      *
1:fbb8866:      * @param backupDir the name of the directory where the backup should be
1:fbb8866:      *		             stored.
1:fbb8866:      * @param wait      if <tt>true</tt>, waits for  all the backup blocking 
1:fbb8866:      *                  operations in progress to finish.
1:fbb8866:      *
1:fbb8866:      * @exception StandardException Thrown on error
1:fbb8866:      */
1:fbb8866:     public void backup(String backupDir, boolean wait) 
1:fbb8866:         throws StandardException;
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:fbb8866:      * Backup the database to a backup directory and enable the log archive
1:fbb8866:      * mode that will keep the archived log files required for roll-forward
1:fbb8866:      * from this version backup.
1:fbb8866:      *
2:fbb8866:      * @param backupDir                     the directory name where the 
2:fbb8866:      *                                      database backup should go.  This 
2:fbb8866:      *                                      directory will be created if not it
2:fbb8866:      *                                      does not exist.
1:fbb8866:      *
2:fbb8866:      * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
2:fbb8866:      *                                      files that exist before this backup,
2:fbb8866:      *                                      delete will occur only after backup
2:fbb8866:      *                                      is complete.
1:eac0369:      *
1:fbb8866:      * @param wait                          if <tt>true</tt>, waits for all the
1:fbb8866:      *                                      backup blocking operations in 
1:fbb8866:      *                                      progress to finish.
1:fbb8866:      *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
2:fbb8866:     public void backupAndEnableLogArchiveMode(
1:fbb8866:     String  backupDir, 
1:fbb8866:     boolean deleteOnlineArchivedLogFiles,
1:fbb8866:     boolean wait) 	
1:fbb8866: 		throws StandardException;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * disables the log archival process, i.e No old log files
1:eac0369: 	 * will be kept around for a roll-forward recovery.
1:fbb8866:      *
1:fbb8866: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived
1:fbb8866:      *                                      log files that exist before this 
1:fbb8866:      *                                      call immediately; Only restore that
1:fbb8866:      *                                      can be performed after disabling log
1:fbb8866:      *                                      archive mode is version recovery.
1:fbb8866:      *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Checkpoints the database, that is, flushes all dirty data to disk.
1:eac0369: 	 * Records a checkpoint in the transaction log, if there is a log.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void checkpoint() throws StandardException;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *Wait until the thread handling the post commit work
1:eac0369: 	 *finihes the work assigned to it.
1:eac0369: 	 */
1:eac0369: 	public void waitForPostCommitToFinishWork();
1:eac0369: 
1:eac0369: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:9496f49
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:      *  database files) at database hard upgrade time)
1:      * This gets called during hard upgrade. It will create 3 readme files
1:      *  one in database directory, one in "seg0" directory and one in log
1:      *  directory. These readme files warn users against touching any of
1:      *  files associated with derby database 
1:      */
1:     public void createReadMeFiles()
1:         throws StandardException;
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:fd20d6b
/////////////////////////////////////////////////////////////////////////
1:         
1:     /**
1:      * Start the failover for this database.
1:      *
1:      * @param dbname the replication database that is being failed over.
1:      * 
1:      * @exception StandardException Standard Derby exception policy,
1:      *                           1) If the failover succeeds, an exception is
1:      *                              thrown to indicate that the master database
1:      *                              was shutdown after a successful failover
1:      *                           2) If a failure occurs during network 
1:      *                              communication with slave.
1:      */
1:     public void failover(String dbname) throws StandardException;
1:     
commit:964abfa
/////////////////////////////////////////////////////////////////////////
1:      * @param dbmaster The master database that is being replicated.
/////////////////////////////////////////////////////////////////////////
1:     public void startReplicationMaster(String dbmaster, String host, int port,
commit:54be3b4
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Stop the replication master role for this database.
1:      * 
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
1:     public void stopReplicationMaster() throws StandardException;
1: 
commit:4aeada8
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Start the replication master role for this database
1:      * @param host The hostname for the slave
1:      * @param port The port the slave is listening on
1:      * @param replicationMode The type of replication contract.
1:      * Currently only asynchronous replication is supported, but
1:      * 1-safe/2-safe/very-safe modes may be added later.
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
0:     public void startReplicationMaster(String host, int port,
1:                                        String replicationMode)
1:         throws StandardException;
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ffd4e9b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:402725c
/////////////////////////////////////////////////////////////////////////
1: 	  * <P>Please see Derby on line documentation on backup and restore.
/////////////////////////////////////////////////////////////////////////
1: 	  * <P>Please see Derby on line documentation on backup and restore.
/////////////////////////////////////////////////////////////////////////
1:      * <P>Please see Derby on line documentation on backup and restore.
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
1:      * Backup the database to backupDir.  
0:      * <P>Please see cloudscape on line documentation on backup and restore.
1:      *
1:      * @param backupDir the name of the directory where the backup should be
1:      *		             stored.
1:      * @param wait      if <tt>true</tt>, waits for  all the backup blocking 
1:      *                  operations in progress to finish.
1:      *
1:      * @exception StandardException Thrown on error
1:      */
1:     public void backup(String backupDir, boolean wait) 
1:         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:      * Backup the database to a backup directory and enable the log archive
1:      * mode that will keep the archived log files required for roll-forward
1:      * from this version backup.
1:      *
1:      * @param backupDir                     the directory name where the 
1:      *                                      database backup should go.  This 
1:      *                                      directory will be created if not it
1:      *                                      does not exist.
1:      *
1:      * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
1:      *                                      files that exist before this backup,
1:      *                                      delete will occur only after backup
1:      *                                      is complete.
1:      *
1:      * @param wait                          if <tt>true</tt>, waits for all the
1:      *                                      backup blocking operations in 
1:      *                                      progress to finish.
1:      *
1:     public void backupAndEnableLogArchiveMode(
1:     String  backupDir, 
1:     boolean deleteOnlineArchivedLogFiles,
1:     boolean wait) 	
1: 		throws StandardException;
1:      *
1: 	 * @param backupDir                     the directory name where the 
1:      *                                      database backup should go.  This 
1:      *                                      directory will be created if not it
1:      *                                      does not exist.
1:      *
1: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
1:      *                                      files that exist before this backup,
1:      *                                      delete will occur only after backup
1:      *                                      is complete.
1:      *
1: 	public void backupAndEnableLogArchiveMode(
0:     File    backupDir, 
0:     boolean deleteOnlineArchivedLogFiles) 
1:      *
1: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived
1:      *                                      log files that exist before this 
1:      *                                      call immediately; Only restore that
1:      *                                      can be performed after disabling log
1:      *                                      archive mode is version recovery.
1:      *
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.AccessFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: 
1: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: import java.util.Properties;
1: import java.io.File;
1: 
1: /**
1: 
1:   Module interface for an access manager.  An access manager provides
1:   transactional access via access methods to data in a single storage
1:   manager.
1:   <p>
1:   An AccessFactory is typically obtained from the Monitor:
1:   <p>
1:   <blockquote><pre>
1: 	// Get the current transaction controller.
1: 	AccessFactory af;
1: 	af = (AccessFactory) Monitor.findServiceModule(this, AccessFactory.MODULE);
1:   </pre></blockquote>
1: **/
1: 
1: public interface AccessFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 * Used to identify this interface when finding it with the Monitor.
1:      **/
1: 	public static final String MODULE = 
1:         "org.apache.derby.iapi.store.access.AccessFactory";
1: 
1: 	/**
1: 	 * Register an access method that this access manager can use.
1: 	 **/
1: 	void registerAccessMethod(MethodFactory factory);
1: 
1: 	/**
1: 	 * Database creation has finished.
1:      *
1: 	 * @exception StandardException Standard exception policy.
1: 	 **/
1: 	public void createFinished() throws StandardException;
1: 
1: 	/**
1: 	 *Find an access method that implements an implementation type.
1:      *
1: 	 * @exception StandardException Standard exception policy.
1: 	 **/
1: 	MethodFactory findMethodFactoryByImpl(String impltype)
1:         throws StandardException;
1: 
1: 	/**
1: 	 * Find an access method that implements a format type.
1: 	 **/
1: 	MethodFactory findMethodFactoryByFormat(UUID format);
1: 
1:     /**
1:      * Get the LockFactory to use with this store.
1:      *
1: 	 * @return The lock factory to use with this store.
1:      *
1:      **/
1: 	public LockFactory getLockFactory();
1: 
1: 
1:     /**
1:      * Return the XAResourceManager associated with this AccessFactory.
1:      * <p>
1:      * Returns an object which can be used to implement the "offline" 
1:      * 2 phase commit interaction between the accessfactory and outstanding
1:      * transaction managers taking care of in-doubt transactions.
1:      *
1:      * @return The XAResourceManager associated with this accessfactory.
1:      *
1: 	 * @exception StandardException Standard exception policy.
1:      *
1:      **/
1: 	public /* XAResourceManager */ Object getXAResourceManager()
1: 		throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Is the store read-only.
1: 	 */
1: 	public boolean isReadOnly();
1: 
1: 
1: 
1:     /**************************************************************************
1:      * methods that are Property related.
1:      **************************************************************************
1:      */
1: 
1: 
1:     /**************************************************************************
1:      * methods that are transaction related.
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	 * Get a transaction controller with which to manipulate data within
1: 	 * the access manager.  Implicitly creates an access context if one
1: 	 * does not already exist.
1:      *
1:      * @param cm    The context manager for the current context.
1:      *
1: 	 * @exception StandardException Standard exception policy.
1: 	 * @see TransactionController
1: 	 **/
1: 
1: 	TransactionController getTransaction(ContextManager cm)
1: 		throws StandardException;
1: 
1:     /**
1:      * Get a transaction. If a new transaction is 
1:      * implicitly created, give it name transName.
1:      *
1:      * @param cm            The context manager for the current context.
1:      * @param transName     If a new transaction is started, it will be given 
1:      *                      this name.  The name is displayed in the 
1:      *                      transactiontable VTI.
1:      *
1: 	 * @exception StandardException Standard exception policy.
1:      *
1: 	 * @see TransactionController
1: 	 * @see AccessFactory#getTransaction
1:      */
1: 	TransactionController getAndNameTransaction(
1:     ContextManager  cm, 
1:     String          transName)
1: 		throws StandardException;
1: 
1:     /**
1:      * Return a snap shot of all transactions in the db.
1:      * <p>
1:      * Take a snap shot of all transactions currently in the database and make
1:      * a record of their information.
1:      *
1:      * @return an array of TransactionInfo, or null if there is 
1:      *         no transaction in the database.
1:      *
1:      **/
1: 	public TransactionInfo[] getTransactionInfo();
1: 
1: 	/**
1:      * Start a global transaction.
1:      * <p>
1: 	 * Get a transaction controller with which to manipulate data within
1: 	 * the access manager.  Implicitly creates an access context.
1:      * <p>
1:      * Must only be called if no other transaction context exists in the
1:      * current context manager.  If another transaction exists in the context
1:      * an exception will be thrown.
1:      * <p>
1:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:      * in the path.
1:      * <p>
1:      * If the global transaction id given matches an existing in-doubt global
1:      * transaction in the current system, then a StandardException will
1:      * be thrown with a state of SQLState.STORE_XA_XAER_DUPID.
1:      * <p>
1:      *
1:      * @param cm        The context manager for the current context.
1:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:      * @param global_id the global transaction identifier part of XID - ie.
1:      *                  Xid.getGlobalTransactionId().
1:      * @param branch_id The branch qualifier of the Xid - ie.
1:      *                  Xid.getBranchQaulifier()
1:      *
1: 	 * @exception StandardException Standard exception policy.
1: 	 * @see TransactionController
1: 	 **/
1: 	/* XATransactionController */ Object startXATransaction(
1:     ContextManager  cm,
1:     int             format_id,
1:     byte[]          global_id,
1:     byte[]          branch_id)
1: 		throws StandardException;
1: 
1: 
1:     /**************************************************************************
1:      * methods that implement functionality on the 
1:      *     org.apache.derby.iapi.db API
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	  * Freeze the database temporarily so a backup can be taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
1: 	  * @exception StandardException Thrown on error
1: 	  */
1: 	public void freeze() throws StandardException;
1: 
1: 	/**
1: 	  * Unfreeze the database after a backup has been taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
1: 	  * @exception StandardException Thrown on error
1: 	  */
1: 	public void unfreeze() throws StandardException;
1: 
1: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @param backupDir the name of the directory where the backup should be
0: 	  *		stored.
1: 	  *
1: 	  * @exception StandardException Thrown on error
1: 	  */
0: 	public void backup(String backupDir) throws StandardException;
1: 
1: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @param backupDir the directory where the backup should be stored.
1: 	  *
1: 	  * @exception StandardException Thrown on error
1: 	  */
0: 	public void backup(File backupDir) throws StandardException;
1: 	
1: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
1: 	 * @exception StandardException Thrown on error
1: 	 */
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean	
0: 											  deleteOnlineArchivedLogFiles) 	
0: 		throws StandardException ;
1: 	
1: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
1: 	 * @exception StandardException Thrown on error
1: 	 */
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * disables the log archival process, i.e No old log files
1: 	 * will be kept around for a roll-forward recovery.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived log files
0: 	 * that exist before this call immediately; Only restore that can be performed
0: 	 * after disabling log archive mode is version recovery.
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1: 		throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Checkpoints the database, that is, flushes all dirty data to disk.
1: 	 * Records a checkpoint in the transaction log, if there is a log.
1: 	 *
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void checkpoint() throws StandardException;
1: 
1: 	/*
1: 	 *Wait until the thread handling the post commit work
1: 	 *finihes the work assigned to it.
1: 	 */
1: 	public void waitForPostCommitToFinishWork();
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
0: 
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: import java.util.Properties;
0: import java.io.File;
0: 
0: /**
0: 
0:   Module interface for an access manager.  An access manager provides
0:   transactional access via access methods to data in a single storage
0:   manager.
0:   <p>
0:   An AccessFactory is typically obtained from the Monitor:
0:   <p>
0:   <blockquote><pre>
0: 	// Get the current transaction controller.
0: 	AccessFactory af;
0: 	af = (AccessFactory) Monitor.findServiceModule(this, AccessFactory.MODULE);
0:   </pre></blockquote>
0: **/
0: 
0: public interface AccessFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * Used to identify this interface when finding it with the Monitor.
0:      **/
0: 	public static final String MODULE = 
0:         "org.apache.derby.iapi.store.access.AccessFactory";
0: 
0: 	/**
0: 	 * Register an access method that this access manager can use.
0: 	 **/
0: 	void registerAccessMethod(MethodFactory factory);
0: 
0: 	/**
0: 	 * Database creation has finished.
0:      *
0: 	 * @exception StandardException Standard exception policy.
0: 	 **/
0: 	public void createFinished() throws StandardException;
0: 
0: 	/**
0: 	 *Find an access method that implements an implementation type.
0:      *
0: 	 * @exception StandardException Standard exception policy.
0: 	 **/
0: 	MethodFactory findMethodFactoryByImpl(String impltype)
0:         throws StandardException;
0: 
0: 	/**
0: 	 * Find an access method that implements a format type.
0: 	 **/
0: 	MethodFactory findMethodFactoryByFormat(UUID format);
0: 
0:     /**
0:      * Get the LockFactory to use with this store.
0:      *
0: 	 * @return The lock factory to use with this store.
0:      *
0:      **/
0: 	public LockFactory getLockFactory();
0: 
0: 
0:     /**
0:      * Return the XAResourceManager associated with this AccessFactory.
0:      * <p>
0:      * Returns an object which can be used to implement the "offline" 
0:      * 2 phase commit interaction between the accessfactory and outstanding
0:      * transaction managers taking care of in-doubt transactions.
0:      *
0:      * @return The XAResourceManager associated with this accessfactory.
0:      *
0: 	 * @exception StandardException Standard exception policy.
0:      *
0:      **/
0: 	public /* XAResourceManager */ Object getXAResourceManager()
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Is the store read-only.
0: 	 */
0: 	public boolean isReadOnly();
0: 
0: 
0: 
0:     /**************************************************************************
0:      * methods that are Property related.
0:      **************************************************************************
0:      */
0: 
0: 
0:     /**************************************************************************
0:      * methods that are transaction related.
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	 * Get a transaction controller with which to manipulate data within
0: 	 * the access manager.  Implicitly creates an access context if one
0: 	 * does not already exist.
0:      *
0:      * @param cm    The context manager for the current context.
0:      *
0: 	 * @exception StandardException Standard exception policy.
0: 	 * @see TransactionController
0: 	 **/
0: 
0: 	TransactionController getTransaction(ContextManager cm)
0: 		throws StandardException;
0: 
0:     /**
0:      * Get a transaction. If a new transaction is 
0:      * implicitly created, give it name transName.
0:      *
0:      * @param cm            The context manager for the current context.
0:      * @param transName     If a new transaction is started, it will be given 
0:      *                      this name.  The name is displayed in the 
0:      *                      transactiontable VTI.
0:      *
0: 	 * @exception StandardException Standard exception policy.
0:      *
0: 	 * @see TransactionController
0: 	 * @see AccessFactory#getTransaction
0:      */
0: 	TransactionController getAndNameTransaction(
0:     ContextManager  cm, 
0:     String          transName)
0: 		throws StandardException;
0: 
0:     /**
0:      * Return a snap shot of all transactions in the db.
0:      * <p>
0:      * Take a snap shot of all transactions currently in the database and make
0:      * a record of their information.
0:      *
0:      * @return an array of TransactionInfo, or null if there is 
0:      *         no transaction in the database.
0:      *
0:      **/
0: 	public TransactionInfo[] getTransactionInfo();
0: 
0: 	/**
0:      * Start a global transaction.
0:      * <p>
0: 	 * Get a transaction controller with which to manipulate data within
0: 	 * the access manager.  Implicitly creates an access context.
0:      * <p>
0:      * Must only be called if no other transaction context exists in the
0:      * current context manager.  If another transaction exists in the context
0:      * an exception will be thrown.
0:      * <p>
0:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
0:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
0:      * can be delivered on a non-1.2 vm system and not require the javax classes
0:      * in the path.
0:      * <p>
0:      * If the global transaction id given matches an existing in-doubt global
0:      * transaction in the current system, then a StandardException will
0:      * be thrown with a state of SQLState.STORE_XA_XAER_DUPID.
0:      * <p>
0:      *
0:      * @param cm        The context manager for the current context.
0:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
0:      * @param global_id the global transaction identifier part of XID - ie.
0:      *                  Xid.getGlobalTransactionId().
0:      * @param branch_id The branch qualifier of the Xid - ie.
0:      *                  Xid.getBranchQaulifier()
0:      *
0: 	 * @exception StandardException Standard exception policy.
0: 	 * @see TransactionController
0: 	 **/
0: 	/* XATransactionController */ Object startXATransaction(
0:     ContextManager  cm,
0:     int             format_id,
0:     byte[]          global_id,
0:     byte[]          branch_id)
0: 		throws StandardException;
0: 
0: 
0:     /**************************************************************************
0:      * methods that implement functionality on the 
0:      *     org.apache.derby.iapi.db API
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	  * Freeze the database temporarily so a backup can be taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void freeze() throws StandardException;
0: 
0: 	/**
0: 	  * Unfreeze the database after a backup has been taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void unfreeze() throws StandardException;
0: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @param backupDir the name of the directory where the backup should be
0: 	  *		stored.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(String backupDir) throws StandardException;
0: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @param backupDir the directory where the backup should be stored.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(File backupDir) throws StandardException;
0: 	
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean	
0: 											  deleteOnlineArchivedLogFiles) 	
0: 		throws StandardException ;
0: 	
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * disables the log archival process, i.e No old log files
0: 	 * will be kept around for a roll-forward recovery.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived log files
0: 	 * that exist before this call immediately; Only restore that can be performed
0: 	 * after disabling log archive mode is version recovery.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Checkpoints the database, that is, flushes all dirty data to disk.
0: 	 * Records a checkpoint in the transaction log, if there is a log.
0: 	 *
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void checkpoint() throws StandardException;
0: 
0: 	/*
0: 	 *Wait until the thread handling the post commit work
0: 	 *finihes the work assigned to it.
0: 	 */
0: 	public void waitForPostCommitToFinishWork();
0: 
0: }
============================================================================