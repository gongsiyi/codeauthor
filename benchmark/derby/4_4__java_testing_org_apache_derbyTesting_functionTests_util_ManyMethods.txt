1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.util.ManyMethods
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
97:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
2:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.util;
1:67614ad: 
1:67614ad: import java.sql.Date;
1:67614ad: import java.sql.Time;
1:67614ad: import java.sql.Timestamp;
1:67614ad: 
1:67614ad: import java.math.BigDecimal;
1:67614ad: 
1:67614ad: import java.io.Serializable;
1:2510115: import java.util.Calendar;
1:67614ad: 
2:67614ad: /**
1:67614ad:  * This class is for testing method calls on user-defined types.  It has
1:67614ad:  * many different methods for testing different cases.
1:67614ad:  */
1:67614ad: 
1:67614ad: public class ManyMethods implements Serializable
1:67614ad: {
1:67614ad: 
1:67614ad: 	int	value;
1:67614ad: 	protected int protectedValue;
1:67614ad: 	private int privateValue;
1:67614ad: 	public int publicValue;
1:67614ad: 	public short publicshort;
1:67614ad: 	public Short publicShort;
1:67614ad: 	public byte publicbyte;
1:67614ad: 	public Byte publicByte;
1:67614ad: 	public int publicint;
1:67614ad: 	public Integer publicInteger;
1:67614ad: 	public long publiclong;
1:67614ad: 	public Long publicLong;
1:67614ad: 	public boolean publicboolean;
1:67614ad: 	public Boolean publicBoolean;
1:67614ad: 	public float publicfloat;
1:67614ad: 	public Float publicFloat;
1:67614ad: 	public double publicdouble;
1:67614ad: 	public Double publicDouble;
1:67614ad: 	public String publicString;
1:67614ad: 	public Date publicDate;
1:67614ad: 	public Time publicTime;
1:67614ad: 	public Timestamp publicTimestamp;
1:67614ad: 	public ManyMethods myself;
1:67614ad: 
1:67614ad: 	public static int NONOVERLOADED_INTSTATIC = 1;
1:67614ad: 	public static int OVERLOADED_INTSTATIC = 1;
1:67614ad: 	public static int OVEROVERLOADED_INTSTATIC = 1;
1:67614ad: 
1:67614ad: 	public ManyMethods(int value)
1:67614ad: 	{
1:67614ad: 		this.value = value;
1:67614ad: 		this.myself = this;
1:67614ad: 		protectedValue = value;
1:67614ad: 		privateValue = value;
1:67614ad: 		publicValue = value;
1:67614ad: 		publicint = value;
1:39b3237: 		publicInteger = value;
1:67614ad: 		publicshort = (short) value;
1:39b3237: 		publicShort = (short) value;
1:67614ad: 		publicbyte = (byte) value;
1:39b3237: 		publicByte = (byte) value;
1:67614ad: 		publiclong = (long) value;
1:39b3237: 		publicLong = (long) value;
1:67614ad: 		publicboolean = booleanMethod();
1:67614ad: 		publicBoolean = BooleanMethod();
1:67614ad: 		publicfloat = floatMethod();
1:67614ad: 		publicFloat = FloatMethod();
1:67614ad: 		publicdouble = doubleMethod();
1:67614ad: 		publicDouble = DoubleMethod();
1:67614ad: 		publicString = StringMethod();
1:67614ad: 		publicDate = DateMethod();
1:67614ad: 		publicTime = TimeMethod();
1:67614ad: 		publicTimestamp = TimestampMethod();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/*
1:67614ad: 	** The following methods are for testing signature matching.  Each method
1:67614ad: 	** takes a single parameter.  The parameter types vary by method.  All
1:67614ad: 	** of the Java primitive types are covered as well as their wrapper classes.
1:67614ad: 	** All of the Java classes corresponding to the currently supported SQL
1:67614ad: 	** types are covered.
1:67614ad: 	*/
1:67614ad: 
1:67614ad: 	public String parmType(byte value)
1:67614ad: 	{
1:67614ad: 		return "byte parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(byte[][][] value)
1:67614ad: 	{
1:67614ad: 		return "byte[][][] parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Byte value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Byte parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(char value)
1:67614ad: 	{
1:67614ad: 		return "char parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Character value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Character parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(double value)
1:67614ad: 	{
1:67614ad: 		return "double parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Double value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Double parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(BigDecimal value)
1:67614ad: 	{
1:67614ad: 		return "java.math.BigDecimal parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(float value)
1:67614ad: 	{
1:67614ad: 		return "float parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Float value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Float parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(int value)
1:67614ad: 	{
1:67614ad: 		return "int parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Integer value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Integer parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(long value)
1:67614ad: 	{
1:67614ad: 		return "long parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Long value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Long parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(short value)
1:67614ad: 	{
1:67614ad: 		return "short parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Short value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Short parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(boolean value)
1:67614ad: 	{
1:67614ad: 		return "boolean parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Boolean value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.Boolean parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(String value)
1:67614ad: 	{
1:67614ad: 		return "java.lang.String parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Date value)
1:67614ad: 	{
1:67614ad: 		return "java.sql.Date parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Time value)
1:67614ad: 	{
1:67614ad: 		return "java.sql.Time parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String parmType(Timestamp value)
1:67614ad: 	{
1:67614ad: 		return "java.sql.Timestamp parameter";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/*
1:67614ad: 	** The following methods return all of the java primitive types and
1:67614ad: 	** their wrapper classes, plus all of the types corresponding to the
1:67614ad: 	** built-in SQL types.
1:67614ad: 	*/
1:67614ad: 	public byte byteMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public byte[][][] byteArrayArrayArrayMethod()
1:67614ad: 	{
1:67614ad: 		return new byte[3][][];
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Byte ByteMethod()
1:67614ad: 	{
1:39b3237: 		return (byte) 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public char charMethod()
1:67614ad: 	{
1:67614ad: 		return 'a';
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Character CharacterMethod()
1:67614ad: 	{
1:39b3237: 		return 'a';
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public double doubleMethod()
1:67614ad: 	{
1:67614ad: 		return 1.5;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Double DoubleMethod()
1:67614ad: 	{
1:39b3237: 		return 1.5;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public BigDecimal BigDecimalMethod()
1:67614ad: 	{
1:67614ad: 		return new BigDecimal(1.4d);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public float floatMethod()
1:67614ad: 	{
1:67614ad: 		return 2.5F;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Float FloatMethod()
1:67614ad: 	{
1:39b3237: 		return 2.5F;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public int intMethod()
1:67614ad: 	{
1:67614ad: 		return 2;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Integer IntegerMethod()
1:67614ad: 	{
1:39b3237: 		return 2;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public long longMethod()
1:67614ad: 	{
1:67614ad: 		return 3L;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Long LongMethod()
1:67614ad: 	{
1:39b3237: 		return 3L;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public short shortMethod()
1:67614ad: 	{
1:67614ad: 		return (short) 4;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Short ShortMethod()
1:67614ad: 	{
1:39b3237: 		return (short) 4;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public boolean booleanMethod()
1:67614ad: 	{
1:67614ad: 		return true;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Boolean BooleanMethod()
1:67614ad: 	{
1:39b3237: 		return true;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String StringMethod()
1:67614ad: 	{
1:67614ad: 		return "A String";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Date DateMethod()
1:67614ad: 	{
2:67614ad: 		/* July 2, 1997 */
1:67614ad: 		// deprecated...note, that it was actually august, not july.
1:67614ad: 		// return new Date(97, 7, 2);
1:67614ad: 		return new Date(870505200000L);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Time TimeMethod()
1:67614ad: 	{
1:67614ad: 		/* 10:58:33 AM */
1:67614ad: 		// deprecated...
1:67614ad: 		// return new Time(10, 58, 33);
1:67614ad: 		return new Time(68313000L);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Timestamp TimestampMethod()
1:67614ad: 	{
2:67614ad: 		/* July 2, 1997 10:59:15.0 AM */
1:67614ad: 		// deprecated...note, actually August, not July, 1997
1:67614ad: 		// return new Timestamp(97, 7, 2, 10, 59, 15, 0);
1:67614ad: 		return new Timestamp(870544755000L);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public ManyMethods ManyMethodsMethod()
1:67614ad: 	{
1:67614ad: 		return this;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/*
1:67614ad: 	** The following methods are for testing null arguments.  These methods
1:67614ad: 	** return Strings with the names of the parameter types, so we can be
1:67614ad: 	** sure the right method was called.
1:67614ad: 	*/
1:67614ad: 	public String isNull(Boolean value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Boolean is null";
1:67614ad: 		else
1:67614ad: 			return "Boolean is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(String value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "String is null";
1:67614ad: 		else
1:67614ad: 			return "String is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Double value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Double is null";
1:67614ad: 		else
1:67614ad: 			return "Double is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(BigDecimal value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "BigDecimal is null";
1:67614ad: 		else
1:67614ad: 			return "BigDecimal is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Integer value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Integer is null";
1:67614ad: 		else
1:67614ad: 			return "Integer is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Float value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Float is null";
1:67614ad: 		else
1:67614ad: 			return "Float is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Short value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Short is null";
1:67614ad: 		else
1:67614ad: 			return "Short is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Date value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Date is null";
1:67614ad: 		else
1:67614ad: 			return "Date is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Time value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Time is null";
1:67614ad: 		else
1:67614ad: 			return "Time is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String isNull(Timestamp value)
1:67614ad: 	{
1:67614ad: 		if (value == null)
1:67614ad: 			return "Timestamp is null";
1:67614ad: 		else
1:67614ad: 			return "Timestamp is not null";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* Methods with more than one parameter */
1:67614ad: 	public String integerFloatDouble(Integer parm1, Float parm2, Double parm3)
1:67614ad: 	{
1:67614ad: 		return "integerFloatDouble method";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public String stringDateTimeTimestamp(String parm1, Date parm2, Time parm3,
1:67614ad: 											Timestamp parm4)
1:67614ad: 	{
1:67614ad: 		return "stringDateTimeTimestamp method";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* Static methods */
1:67614ad: 	public static int staticMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static int overloadedStaticMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static int overOverloadedStaticMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Byte staticByteMethod()
1:67614ad: 	{
1:39b3237: 		return (byte) 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Character staticCharacterMethod()
1:67614ad: 	{
1:39b3237: 		return 'a';
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Double staticDoubleMethod()
1:67614ad: 	{
1:39b3237: 		return 1.5;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static BigDecimal staticBigDecimalMethod()
1:67614ad: 	{
1:67614ad: 		return new BigDecimal(1.1d);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Float staticFloatMethod()
1:67614ad: 	{
1:39b3237: 		return 2.5F;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Long staticLongMethod()
1:67614ad: 	{
1:39b3237: 		return 3L;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Short staticShortMethod()
1:67614ad: 	{
1:39b3237: 		return (short) 4;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Integer staticIntegerMethod()
1:67614ad: 	{
1:39b3237: 		return 2;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Boolean staticBooleanMethod()
1:67614ad: 	{
1:39b3237: 		return true;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static String staticStringMethod()
1:67614ad: 	{
1:67614ad: 		return "A String";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Date staticDateMethod()
1:67614ad: 	{
1:2510115:         /* August 2, 1997 */
1:2510115:         Calendar cal = Calendar.getInstance();
1:2510115:         cal.clear();
1:2510115:         cal.set(1997, Calendar.AUGUST, 2, 0, 0, 0);
1:2510115:         return new Date(cal.getTimeInMillis());
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Time staticTimeMethod()
1:67614ad: 	{
1:67614ad: 		/* 10:58:33 AM */
1:2510115:         Calendar cal = Calendar.getInstance();
1:2510115:         cal.clear();
1:2510115:         cal.set(1970, Calendar.JANUARY, 1, 10, 58, 33);
1:2510115:         return new Time(cal.getTimeInMillis());
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Timestamp staticTimestampMethod()
1:67614ad: 	{
1:2510115:         /* August 2, 1997 10:59:15.0 AM */
1:2510115:         Calendar cal = Calendar.getInstance();
1:2510115:         cal.clear();
1:2510115:         cal.set(1997, Calendar.AUGUST, 2, 10, 59, 15);
1:2510115:         return new Timestamp(cal.getTimeInMillis());
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static ManyMethods staticManyMethods(Integer value)
1:67614ad: 	{
1:67614ad: 		return new ManyMethods(value.intValue());
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* "Cast to sub class" */
1:67614ad: 	public SubClass subClass()
1:67614ad: 	{
1:67614ad: 		if (this instanceof SubClass)
1:67614ad: 		{
1:67614ad: 			return (SubClass) this;
1:67614ad: 		}
1:67614ad: 		else
1:67614ad: 		{
1:67614ad: 			return null;
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public int[] getIntArray() {
1:67614ad: 		return new int[0];
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public Object[] getObjectArray() {
1:67614ad: 		return new String[0];
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* Methods for negative testing */
1:67614ad: 	protected int protectedMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	private int privateMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	int packageMethod()
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public int exceptionMethod() throws Throwable
1:67614ad: 	{
1:67614ad: 		throw new Throwable("This exception should be caught by the runtime system.");
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/*
1:67614ad: 	** Some methods for testing interface resolution
1:67614ad: 	*/
1:67614ad: 
1:67614ad: 	public static NoMethodInterface getNoMethodInterface() {
1:67614ad: 		return new SubInterfaceClass(67);
1:67614ad: 	}
1:67614ad: 	public static Runnable getRunnable() {
1:67614ad: 		return new SubInterfaceClass(89);
1:67614ad: 	}
1:67614ad: 	public static ExtendingInterface getExtendingInterface() {
1:67614ad: 		return new SubInterfaceClass(235);
1:67614ad: 	}
1:67614ad: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 		publicInteger = value;
1: 		publicShort = (short) value;
1: 		publicByte = (byte) value;
1: 		publicLong = (long) value;
/////////////////////////////////////////////////////////////////////////
1: 		return (byte) 1;
/////////////////////////////////////////////////////////////////////////
1: 		return 'a';
/////////////////////////////////////////////////////////////////////////
1: 		return 1.5;
/////////////////////////////////////////////////////////////////////////
1: 		return 2.5F;
/////////////////////////////////////////////////////////////////////////
1: 		return 2;
/////////////////////////////////////////////////////////////////////////
1: 		return 3L;
/////////////////////////////////////////////////////////////////////////
1: 		return (short) 4;
/////////////////////////////////////////////////////////////////////////
1: 		return true;
/////////////////////////////////////////////////////////////////////////
1: 		return (byte) 1;
1: 		return 'a';
1: 		return 1.5;
/////////////////////////////////////////////////////////////////////////
1: 		return 2.5F;
1: 		return 3L;
1: 		return (short) 4;
1: 		return 2;
1: 		return true;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2510115
/////////////////////////////////////////////////////////////////////////
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:         /* August 2, 1997 */
1:         Calendar cal = Calendar.getInstance();
1:         cal.clear();
1:         cal.set(1997, Calendar.AUGUST, 2, 0, 0, 0);
1:         return new Date(cal.getTimeInMillis());
1:         Calendar cal = Calendar.getInstance();
1:         cal.clear();
1:         cal.set(1970, Calendar.JANUARY, 1, 10, 58, 33);
1:         return new Time(cal.getTimeInMillis());
1:         /* August 2, 1997 10:59:15.0 AM */
1:         Calendar cal = Calendar.getInstance();
1:         cal.clear();
1:         cal.set(1997, Calendar.AUGUST, 2, 10, 59, 15);
1:         return new Timestamp(cal.getTimeInMillis());
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.util
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
1: import java.math.BigDecimal;
1: 
1: import java.io.Serializable;
1: 
1: /**
1:  * This class is for testing method calls on user-defined types.  It has
1:  * many different methods for testing different cases.
1:  */
1: 
1: public class ManyMethods implements Serializable
1: { 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	int	value;
1: 	protected int protectedValue;
1: 	private int privateValue;
1: 	public int publicValue;
1: 	public short publicshort;
1: 	public Short publicShort;
1: 	public byte publicbyte;
1: 	public Byte publicByte;
1: 	public int publicint;
1: 	public Integer publicInteger;
1: 	public long publiclong;
1: 	public Long publicLong;
1: 	public boolean publicboolean;
1: 	public Boolean publicBoolean;
1: 	public float publicfloat;
1: 	public Float publicFloat;
1: 	public double publicdouble;
1: 	public Double publicDouble;
1: 	public String publicString;
1: 	public Date publicDate;
1: 	public Time publicTime;
1: 	public Timestamp publicTimestamp;
1: 	public ManyMethods myself;
1: 
1: 	public static int NONOVERLOADED_INTSTATIC = 1;
1: 	public static int OVERLOADED_INTSTATIC = 1;
1: 	public static int OVEROVERLOADED_INTSTATIC = 1;
1: 
1: 	public ManyMethods(int value)
1: 	{
1: 		this.value = value;
1: 		this.myself = this;
1: 		protectedValue = value;
1: 		privateValue = value;
1: 		publicValue = value;
1: 		publicint = value;
0: 		publicInteger = new Integer(value);
1: 		publicshort = (short) value;
0: 		publicShort = new Short((short) value);
1: 		publicbyte = (byte) value;
0: 		publicByte = new Byte((byte) value);
1: 		publiclong = (long) value;
0: 		publicLong = new Long((long) value);
1: 		publicboolean = booleanMethod();
1: 		publicBoolean = BooleanMethod();
1: 		publicfloat = floatMethod();
1: 		publicFloat = FloatMethod();
1: 		publicdouble = doubleMethod();
1: 		publicDouble = DoubleMethod();
1: 		publicString = StringMethod();
1: 		publicDate = DateMethod();
1: 		publicTime = TimeMethod();
1: 		publicTimestamp = TimestampMethod();
1: 	}
1: 
1: 	/*
1: 	** The following methods are for testing signature matching.  Each method
1: 	** takes a single parameter.  The parameter types vary by method.  All
1: 	** of the Java primitive types are covered as well as their wrapper classes.
1: 	** All of the Java classes corresponding to the currently supported SQL
1: 	** types are covered.
1: 	*/
1: 
1: 	public String parmType(byte value)
1: 	{
1: 		return "byte parameter";
1: 	}
1: 
1: 	public String parmType(byte[][][] value)
1: 	{
1: 		return "byte[][][] parameter";
1: 	}
1: 
1: 	public String parmType(Byte value)
1: 	{
1: 		return "java.lang.Byte parameter";
1: 	}
1: 
1: 	public String parmType(char value)
1: 	{
1: 		return "char parameter";
1: 	}
1: 
1: 	public String parmType(Character value)
1: 	{
1: 		return "java.lang.Character parameter";
1: 	}
1: 
1: 	public String parmType(double value)
1: 	{
1: 		return "double parameter";
1: 	}
1: 
1: 	public String parmType(Double value)
1: 	{
1: 		return "java.lang.Double parameter";
1: 	}
1: 
1: 	public String parmType(BigDecimal value)
1: 	{
1: 		return "java.math.BigDecimal parameter";
1: 	}
1: 
1: 	public String parmType(float value)
1: 	{
1: 		return "float parameter";
1: 	}
1: 
1: 	public String parmType(Float value)
1: 	{
1: 		return "java.lang.Float parameter";
1: 	}
1: 
1: 	public String parmType(int value)
1: 	{
1: 		return "int parameter";
1: 	}
1: 
1: 	public String parmType(Integer value)
1: 	{
1: 		return "java.lang.Integer parameter";
1: 	}
1: 
1: 	public String parmType(long value)
1: 	{
1: 		return "long parameter";
1: 	}
1: 
1: 	public String parmType(Long value)
1: 	{
1: 		return "java.lang.Long parameter";
1: 	}
1: 
1: 	public String parmType(short value)
1: 	{
1: 		return "short parameter";
1: 	}
1: 
1: 	public String parmType(Short value)
1: 	{
1: 		return "java.lang.Short parameter";
1: 	}
1: 
1: 	public String parmType(boolean value)
1: 	{
1: 		return "boolean parameter";
1: 	}
1: 
1: 	public String parmType(Boolean value)
1: 	{
1: 		return "java.lang.Boolean parameter";
1: 	}
1: 
1: 	public String parmType(String value)
1: 	{
1: 		return "java.lang.String parameter";
1: 	}
1: 
1: 	public String parmType(Date value)
1: 	{
1: 		return "java.sql.Date parameter";
1: 	}
1: 
1: 	public String parmType(Time value)
1: 	{
1: 		return "java.sql.Time parameter";
1: 	}
1: 
1: 	public String parmType(Timestamp value)
1: 	{
1: 		return "java.sql.Timestamp parameter";
1: 	}
1: 
1: 	/*
1: 	** The following methods return all of the java primitive types and
1: 	** their wrapper classes, plus all of the types corresponding to the
1: 	** built-in SQL types.
1: 	*/
1: 	public byte byteMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public byte[][][] byteArrayArrayArrayMethod()
1: 	{
1: 		return new byte[3][][];
1: 	}
1: 
1: 	public Byte ByteMethod()
1: 	{
0: 		return new Byte((byte) 1);
1: 	}
1: 
1: 	public char charMethod()
1: 	{
1: 		return 'a';
1: 	}
1: 
1: 	public Character CharacterMethod()
1: 	{
0: 		return new Character('a');
1: 	}
1: 
1: 	public double doubleMethod()
1: 	{
1: 		return 1.5;
1: 	}
1: 
1: 	public Double DoubleMethod()
1: 	{
0: 		return new Double(1.5);
1: 	}
1: 
1: 	public BigDecimal BigDecimalMethod()
1: 	{
1: 		return new BigDecimal(1.4d);
1: 	}
1: 
1: 	public float floatMethod()
1: 	{
1: 		return 2.5F;
1: 	}
1: 
1: 	public Float FloatMethod()
1: 	{
0: 		return new Float(2.5F);
1: 	}
1: 
1: 	public int intMethod()
1: 	{
1: 		return 2;
1: 	}
1: 
1: 	public Integer IntegerMethod()
1: 	{
0: 		return new Integer(2);
1: 	}
1: 
1: 	public long longMethod()
1: 	{
1: 		return 3L;
1: 	}
1: 
1: 	public Long LongMethod()
1: 	{
0: 		return new Long(3L);
1: 	}
1: 
1: 	public short shortMethod()
1: 	{
1: 		return (short) 4;
1: 	}
1: 
1: 	public Short ShortMethod()
1: 	{
0: 		return new Short((short) 4);
1: 	}
1: 
1: 	public boolean booleanMethod()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	public Boolean BooleanMethod()
1: 	{
0: 		return new Boolean(true);
1: 	}
1: 
1: 	public String StringMethod()
1: 	{
1: 		return "A String";
1: 	}
1: 
1: 	public Date DateMethod()
1: 	{
1: 		/* July 2, 1997 */
1: 		// deprecated...note, that it was actually august, not july.
1: 		// return new Date(97, 7, 2);
1: 		return new Date(870505200000L);
1: 	}
1: 
1: 	public Time TimeMethod()
1: 	{
1: 		/* 10:58:33 AM */
1: 		// deprecated...
1: 		// return new Time(10, 58, 33);
1: 		return new Time(68313000L);
1: 	}
1: 
1: 	public Timestamp TimestampMethod()
1: 	{
1: 		/* July 2, 1997 10:59:15.0 AM */
1: 		// deprecated...note, actually August, not July, 1997
1: 		// return new Timestamp(97, 7, 2, 10, 59, 15, 0);
1: 		return new Timestamp(870544755000L);
1: 	}
1: 
1: 	public ManyMethods ManyMethodsMethod()
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/*
1: 	** The following methods are for testing null arguments.  These methods
1: 	** return Strings with the names of the parameter types, so we can be
1: 	** sure the right method was called.
1: 	*/
1: 	public String isNull(Boolean value)
1: 	{
1: 		if (value == null)
1: 			return "Boolean is null";
1: 		else
1: 			return "Boolean is not null";
1: 	}
1: 
1: 	public String isNull(String value)
1: 	{
1: 		if (value == null)
1: 			return "String is null";
1: 		else
1: 			return "String is not null";
1: 	}
1: 
1: 	public String isNull(Double value)
1: 	{
1: 		if (value == null)
1: 			return "Double is null";
1: 		else
1: 			return "Double is not null";
1: 	}
1: 
1: 	public String isNull(BigDecimal value)
1: 	{
1: 		if (value == null)
1: 			return "BigDecimal is null";
1: 		else
1: 			return "BigDecimal is not null";
1: 	}
1: 
1: 	public String isNull(Integer value)
1: 	{
1: 		if (value == null)
1: 			return "Integer is null";
1: 		else
1: 			return "Integer is not null";
1: 	}
1: 
1: 	public String isNull(Float value)
1: 	{
1: 		if (value == null)
1: 			return "Float is null";
1: 		else
1: 			return "Float is not null";
1: 	}
1: 
1: 	public String isNull(Short value)
1: 	{
1: 		if (value == null)
1: 			return "Short is null";
1: 		else
1: 			return "Short is not null";
1: 	}
1: 
1: 	public String isNull(Date value)
1: 	{
1: 		if (value == null)
1: 			return "Date is null";
1: 		else
1: 			return "Date is not null";
1: 	}
1: 
1: 	public String isNull(Time value)
1: 	{
1: 		if (value == null)
1: 			return "Time is null";
1: 		else
1: 			return "Time is not null";
1: 	}
1: 
1: 	public String isNull(Timestamp value)
1: 	{
1: 		if (value == null)
1: 			return "Timestamp is null";
1: 		else
1: 			return "Timestamp is not null";
1: 	}
1: 
1: 	/* Methods with more than one parameter */
1: 	public String integerFloatDouble(Integer parm1, Float parm2, Double parm3)
1: 	{
1: 		return "integerFloatDouble method";
1: 	}
1: 
1: 	public String stringDateTimeTimestamp(String parm1, Date parm2, Time parm3,
1: 											Timestamp parm4)
1: 	{
1: 		return "stringDateTimeTimestamp method";
1: 	}
1: 
1: 	/* Static methods */
1: 	public static int staticMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public static int overloadedStaticMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public static int overOverloadedStaticMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public static Byte staticByteMethod()
1: 	{
0: 		return new Byte((byte) 1);
1: 	}
1: 
1: 	public static Character staticCharacterMethod()
1: 	{
0: 		return new Character('a');
1: 	}
1: 
1: 	public static Double staticDoubleMethod()
1: 	{
0: 		return new Double(1.5);
1: 	}
1: 
1: 	public static BigDecimal staticBigDecimalMethod()
1: 	{
1: 		return new BigDecimal(1.1d);
1: 	}
1: 
1: 	public static Float staticFloatMethod()
1: 	{
0: 		return new Float(2.5F);
1: 	}
1: 
1: 	public static Long staticLongMethod()
1: 	{
0: 		return new Long(3L);
1: 	}
1: 
1: 	public static Short staticShortMethod()
1: 	{
0: 		return new Short((short) 4);
1: 	}
1: 
1: 	public static Integer staticIntegerMethod()
1: 	{
0: 		return new Integer(2);
1: 	}
1: 
1: 	public static Boolean staticBooleanMethod()
1: 	{
0: 		return new Boolean(true);
1: 	}
1: 
1: 	public static String staticStringMethod()
1: 	{
1: 		return "A String";
1: 	}
1: 
1: 	public static Date staticDateMethod()
1: 	{
1: 		/* July 2, 1997 */
0: 		return new Date(97, 7, 2);
1: 	}
1: 
1: 	public static Time staticTimeMethod()
1: 	{
1: 		/* 10:58:33 AM */
0: 		return new Time(10, 58, 33);
1: 	}
1: 
1: 	public static Timestamp staticTimestampMethod()
1: 	{
1: 		/* July 2, 1997 10:59:15.0 AM */
0: 		return new Timestamp(97, 7, 2, 10, 59, 15, 0);
1: 	}
1: 
1: 	public static ManyMethods staticManyMethods(Integer value)
1: 	{
1: 		return new ManyMethods(value.intValue());
1: 	}
1: 
1: 	/* "Cast to sub class" */
1: 	public SubClass subClass()
1: 	{
1: 		if (this instanceof SubClass)
1: 		{
1: 			return (SubClass) this;
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
1: 	public int[] getIntArray() {
1: 		return new int[0];
1: 	}
1: 
1: 	public Object[] getObjectArray() {
1: 		return new String[0];
1: 	}
1: 
1: 	/* Methods for negative testing */
1: 	protected int protectedMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	private int privateMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	int packageMethod()
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public int exceptionMethod() throws Throwable
1: 	{
1: 		throw new Throwable("This exception should be caught by the runtime system.");
1: 	}
1: 
1: 	/*
1: 	** Some methods for testing interface resolution
1: 	*/
1: 
1: 	public static NoMethodInterface getNoMethodInterface() {
1: 		return new SubInterfaceClass(67);
1: 	}
1: 	public static Runnable getRunnable() {
1: 		return new SubInterfaceClass(89);
1: 	}
1: 	public static ExtendingInterface getExtendingInterface() {
1: 		return new SubInterfaceClass(235);
1: 	}
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.util.ManyMethods
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0:  */
1: 
0: package org.apache.derbyTesting.functionTests.util;
1: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
1: 
0: import java.math.BigDecimal;
1: 
0: import java.io.Serializable;
1: 
0: /**
0:  * This class is for testing method calls on user-defined types.  It has
0:  * many different methods for testing different cases.
0:  */
1: 
0: public class ManyMethods implements Serializable
0: {
1: 
0: 	int	value;
0: 	protected int protectedValue;
0: 	private int privateValue;
0: 	public int publicValue;
0: 	public short publicshort;
0: 	public Short publicShort;
0: 	public byte publicbyte;
0: 	public Byte publicByte;
0: 	public int publicint;
0: 	public Integer publicInteger;
0: 	public long publiclong;
0: 	public Long publicLong;
0: 	public boolean publicboolean;
0: 	public Boolean publicBoolean;
0: 	public float publicfloat;
0: 	public Float publicFloat;
0: 	public double publicdouble;
0: 	public Double publicDouble;
0: 	public String publicString;
0: 	public Date publicDate;
0: 	public Time publicTime;
0: 	public Timestamp publicTimestamp;
0: 	public ManyMethods myself;
1: 
0: 	public static int NONOVERLOADED_INTSTATIC = 1;
0: 	public static int OVERLOADED_INTSTATIC = 1;
0: 	public static int OVEROVERLOADED_INTSTATIC = 1;
1: 
0: 	public ManyMethods(int value)
0: 	{
0: 		this.value = value;
0: 		this.myself = this;
0: 		protectedValue = value;
0: 		privateValue = value;
0: 		publicValue = value;
0: 		publicint = value;
0: 		publicInteger = new Integer(value);
0: 		publicshort = (short) value;
0: 		publicShort = new Short((short) value);
0: 		publicbyte = (byte) value;
0: 		publicByte = new Byte((byte) value);
0: 		publiclong = (long) value;
0: 		publicLong = new Long((long) value);
0: 		publicboolean = booleanMethod();
0: 		publicBoolean = BooleanMethod();
0: 		publicfloat = floatMethod();
0: 		publicFloat = FloatMethod();
0: 		publicdouble = doubleMethod();
0: 		publicDouble = DoubleMethod();
0: 		publicString = StringMethod();
0: 		publicDate = DateMethod();
0: 		publicTime = TimeMethod();
0: 		publicTimestamp = TimestampMethod();
0: 	}
1: 
0: 	/*
0: 	** The following methods are for testing signature matching.  Each method
0: 	** takes a single parameter.  The parameter types vary by method.  All
0: 	** of the Java primitive types are covered as well as their wrapper classes.
0: 	** All of the Java classes corresponding to the currently supported SQL
0: 	** types are covered.
0: 	*/
1: 
0: 	public String parmType(byte value)
0: 	{
0: 		return "byte parameter";
0: 	}
1: 
0: 	public String parmType(byte[][][] value)
0: 	{
0: 		return "byte[][][] parameter";
0: 	}
1: 
0: 	public String parmType(Byte value)
0: 	{
0: 		return "java.lang.Byte parameter";
0: 	}
1: 
0: 	public String parmType(char value)
0: 	{
0: 		return "char parameter";
0: 	}
1: 
0: 	public String parmType(Character value)
0: 	{
0: 		return "java.lang.Character parameter";
0: 	}
1: 
0: 	public String parmType(double value)
0: 	{
0: 		return "double parameter";
0: 	}
1: 
0: 	public String parmType(Double value)
0: 	{
0: 		return "java.lang.Double parameter";
0: 	}
1: 
0: 	public String parmType(BigDecimal value)
0: 	{
0: 		return "java.math.BigDecimal parameter";
0: 	}
1: 
0: 	public String parmType(float value)
0: 	{
0: 		return "float parameter";
0: 	}
1: 
0: 	public String parmType(Float value)
0: 	{
0: 		return "java.lang.Float parameter";
0: 	}
1: 
0: 	public String parmType(int value)
0: 	{
0: 		return "int parameter";
0: 	}
1: 
0: 	public String parmType(Integer value)
0: 	{
0: 		return "java.lang.Integer parameter";
0: 	}
1: 
0: 	public String parmType(long value)
0: 	{
0: 		return "long parameter";
0: 	}
1: 
0: 	public String parmType(Long value)
0: 	{
0: 		return "java.lang.Long parameter";
0: 	}
1: 
0: 	public String parmType(short value)
0: 	{
0: 		return "short parameter";
0: 	}
1: 
0: 	public String parmType(Short value)
0: 	{
0: 		return "java.lang.Short parameter";
0: 	}
1: 
0: 	public String parmType(boolean value)
0: 	{
0: 		return "boolean parameter";
0: 	}
1: 
0: 	public String parmType(Boolean value)
0: 	{
0: 		return "java.lang.Boolean parameter";
0: 	}
1: 
0: 	public String parmType(String value)
0: 	{
0: 		return "java.lang.String parameter";
0: 	}
1: 
0: 	public String parmType(Date value)
0: 	{
0: 		return "java.sql.Date parameter";
0: 	}
1: 
0: 	public String parmType(Time value)
0: 	{
0: 		return "java.sql.Time parameter";
0: 	}
1: 
0: 	public String parmType(Timestamp value)
0: 	{
0: 		return "java.sql.Timestamp parameter";
0: 	}
1: 
0: 	/*
0: 	** The following methods return all of the java primitive types and
0: 	** their wrapper classes, plus all of the types corresponding to the
0: 	** built-in SQL types.
0: 	*/
0: 	public byte byteMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	public byte[][][] byteArrayArrayArrayMethod()
0: 	{
0: 		return new byte[3][][];
0: 	}
1: 
0: 	public Byte ByteMethod()
0: 	{
0: 		return new Byte((byte) 1);
0: 	}
1: 
0: 	public char charMethod()
0: 	{
0: 		return 'a';
0: 	}
1: 
0: 	public Character CharacterMethod()
0: 	{
0: 		return new Character('a');
0: 	}
1: 
0: 	public double doubleMethod()
0: 	{
0: 		return 1.5;
0: 	}
1: 
0: 	public Double DoubleMethod()
0: 	{
0: 		return new Double(1.5);
0: 	}
1: 
0: 	public BigDecimal BigDecimalMethod()
0: 	{
0: 		return new BigDecimal(1.4d);
0: 	}
1: 
0: 	public float floatMethod()
0: 	{
0: 		return 2.5F;
0: 	}
1: 
0: 	public Float FloatMethod()
0: 	{
0: 		return new Float(2.5F);
0: 	}
1: 
0: 	public int intMethod()
0: 	{
0: 		return 2;
0: 	}
1: 
0: 	public Integer IntegerMethod()
0: 	{
0: 		return new Integer(2);
0: 	}
1: 
0: 	public long longMethod()
0: 	{
0: 		return 3L;
0: 	}
1: 
0: 	public Long LongMethod()
0: 	{
0: 		return new Long(3L);
0: 	}
1: 
0: 	public short shortMethod()
0: 	{
0: 		return (short) 4;
0: 	}
1: 
0: 	public Short ShortMethod()
0: 	{
0: 		return new Short((short) 4);
0: 	}
1: 
0: 	public boolean booleanMethod()
0: 	{
0: 		return true;
0: 	}
1: 
0: 	public Boolean BooleanMethod()
0: 	{
0: 		return new Boolean(true);
0: 	}
1: 
0: 	public String StringMethod()
0: 	{
0: 		return "A String";
0: 	}
1: 
0: 	public Date DateMethod()
0: 	{
0: 		/* July 2, 1997 */
0: 		// deprecated...note, that it was actually august, not july.
0: 		// return new Date(97, 7, 2);
0: 		return new Date(870505200000L);
0: 	}
1: 
0: 	public Time TimeMethod()
0: 	{
0: 		/* 10:58:33 AM */
0: 		// deprecated...
0: 		// return new Time(10, 58, 33);
0: 		return new Time(68313000L);
0: 	}
1: 
0: 	public Timestamp TimestampMethod()
0: 	{
0: 		/* July 2, 1997 10:59:15.0 AM */
0: 		// deprecated...note, actually August, not July, 1997
0: 		// return new Timestamp(97, 7, 2, 10, 59, 15, 0);
0: 		return new Timestamp(870544755000L);
0: 	}
1: 
0: 	public ManyMethods ManyMethodsMethod()
0: 	{
0: 		return this;
0: 	}
1: 
0: 	/*
0: 	** The following methods are for testing null arguments.  These methods
0: 	** return Strings with the names of the parameter types, so we can be
0: 	** sure the right method was called.
0: 	*/
0: 	public String isNull(Boolean value)
0: 	{
0: 		if (value == null)
0: 			return "Boolean is null";
0: 		else
0: 			return "Boolean is not null";
0: 	}
1: 
0: 	public String isNull(String value)
0: 	{
0: 		if (value == null)
0: 			return "String is null";
0: 		else
0: 			return "String is not null";
0: 	}
1: 
0: 	public String isNull(Double value)
0: 	{
0: 		if (value == null)
0: 			return "Double is null";
0: 		else
0: 			return "Double is not null";
0: 	}
1: 
0: 	public String isNull(BigDecimal value)
0: 	{
0: 		if (value == null)
0: 			return "BigDecimal is null";
0: 		else
0: 			return "BigDecimal is not null";
0: 	}
1: 
0: 	public String isNull(Integer value)
0: 	{
0: 		if (value == null)
0: 			return "Integer is null";
0: 		else
0: 			return "Integer is not null";
0: 	}
1: 
0: 	public String isNull(Float value)
0: 	{
0: 		if (value == null)
0: 			return "Float is null";
0: 		else
0: 			return "Float is not null";
0: 	}
1: 
0: 	public String isNull(Short value)
0: 	{
0: 		if (value == null)
0: 			return "Short is null";
0: 		else
0: 			return "Short is not null";
0: 	}
1: 
0: 	public String isNull(Date value)
0: 	{
0: 		if (value == null)
0: 			return "Date is null";
0: 		else
0: 			return "Date is not null";
0: 	}
1: 
0: 	public String isNull(Time value)
0: 	{
0: 		if (value == null)
0: 			return "Time is null";
0: 		else
0: 			return "Time is not null";
0: 	}
1: 
0: 	public String isNull(Timestamp value)
0: 	{
0: 		if (value == null)
0: 			return "Timestamp is null";
0: 		else
0: 			return "Timestamp is not null";
0: 	}
1: 
0: 	/* Methods with more than one parameter */
0: 	public String integerFloatDouble(Integer parm1, Float parm2, Double parm3)
0: 	{
0: 		return "integerFloatDouble method";
0: 	}
1: 
0: 	public String stringDateTimeTimestamp(String parm1, Date parm2, Time parm3,
0: 											Timestamp parm4)
0: 	{
0: 		return "stringDateTimeTimestamp method";
0: 	}
1: 
0: 	/* Static methods */
0: 	public static int staticMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	public static int overloadedStaticMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	public static int overOverloadedStaticMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	public static Byte staticByteMethod()
0: 	{
0: 		return new Byte((byte) 1);
0: 	}
1: 
0: 	public static Character staticCharacterMethod()
0: 	{
0: 		return new Character('a');
0: 	}
1: 
0: 	public static Double staticDoubleMethod()
0: 	{
0: 		return new Double(1.5);
0: 	}
1: 
0: 	public static BigDecimal staticBigDecimalMethod()
0: 	{
0: 		return new BigDecimal(1.1d);
0: 	}
1: 
0: 	public static Float staticFloatMethod()
0: 	{
0: 		return new Float(2.5F);
0: 	}
1: 
0: 	public static Long staticLongMethod()
0: 	{
0: 		return new Long(3L);
0: 	}
1: 
0: 	public static Short staticShortMethod()
0: 	{
0: 		return new Short((short) 4);
0: 	}
1: 
0: 	public static Integer staticIntegerMethod()
0: 	{
0: 		return new Integer(2);
0: 	}
1: 
0: 	public static Boolean staticBooleanMethod()
0: 	{
0: 		return new Boolean(true);
0: 	}
1: 
0: 	public static String staticStringMethod()
0: 	{
0: 		return "A String";
0: 	}
1: 
0: 	public static Date staticDateMethod()
0: 	{
0: 		/* July 2, 1997 */
0: 		return new Date(97, 7, 2);
0: 	}
1: 
0: 	public static Time staticTimeMethod()
0: 	{
0: 		/* 10:58:33 AM */
0: 		return new Time(10, 58, 33);
0: 	}
1: 
0: 	public static Timestamp staticTimestampMethod()
0: 	{
0: 		/* July 2, 1997 10:59:15.0 AM */
0: 		return new Timestamp(97, 7, 2, 10, 59, 15, 0);
0: 	}
1: 
0: 	public static ManyMethods staticManyMethods(Integer value)
0: 	{
0: 		return new ManyMethods(value.intValue());
0: 	}
1: 
0: 	/* "Cast to sub class" */
0: 	public SubClass subClass()
0: 	{
0: 		if (this instanceof SubClass)
0: 		{
0: 			return (SubClass) this;
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
1: 
0: 	public int[] getIntArray() {
0: 		return new int[0];
0: 	}
1: 
0: 	public Object[] getObjectArray() {
0: 		return new String[0];
0: 	}
1: 
0: 	/* Methods for negative testing */
0: 	protected int protectedMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	private int privateMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	int packageMethod()
0: 	{
0: 		return 1;
0: 	}
1: 
0: 	public int exceptionMethod() throws Throwable
0: 	{
0: 		throw new Throwable("This exception should be caught by the runtime system.");
0: 	}
1: 
0: 	/*
0: 	** Some methods for testing interface resolution
0: 	*/
1: 
0: 	public static NoMethodInterface getNoMethodInterface() {
0: 		return new SubInterfaceClass(67);
0: 	}
0: 	public static Runnable getRunnable() {
0: 		return new SubInterfaceClass(89);
0: 	}
0: 	public static ExtendingInterface getExtendingInterface() {
0: 		return new SubInterfaceClass(235);
0: 	}
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.util.ManyMethods
0: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================