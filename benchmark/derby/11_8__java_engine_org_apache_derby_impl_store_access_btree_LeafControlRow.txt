1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.LeafControlRow
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
2:eac0369: /**
1:787ceb4:  * @derby.formatId ACCESS_BTREE_LEAFCONTROLROW_V1_ID
3:eac0369:  *
1:787ceb4:  * @derby.purpose   Btree pages all have a control row at the front of every page.  To
1:eac0369:  *            determine the type of row, read the first column which is a format
1:eac0369:  *            id and it tells what kind of control row it is.
1:eac0369:  *
1:787ceb4:  * @derby.upgrade   This format was made obsolete in the kimono release.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout 
1:eac0369:  * column 1 - control row type         : StorableFormatId
1:eac0369:  * column 2 - left sibling page number : SQLLongint
1:eac0369:  * column 3 - right sibling page number: SQLLongint
1:eac0369:  * column 4 - parent page number       : SQLLongint
1:eac0369:  * column 5 - level number (0 is leaf) : SQLLongint
1:eac0369:  * column 6 - isRoot                   : SQLLongint
1:eac0369:  * column 7 - Conglomerate object      : null unless it is root else
1:eac0369:  *                                       a Conglomerate object, matching
1:eac0369:  *                                       that of current table.
1:eac0369:  *                                       Currently this field
1:eac0369:  *                                       is only used by logical undo and
1:eac0369:  *                                       the type of object is inferred by
1:eac0369:  *                                       the logical undo code.
1:eac0369:  **/
1:eac0369: 
1:eac0369: public class LeafControlRow extends ControlRow
1:1f9b9c4: {
1:eac0369: 	/*
1:eac0369: 	** Constructors of BranchControlRow
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * No arg constructor.
1:eac0369:      * <p>
1:eac0369:      * Public no arg constructor is for the monitor to call for format
1:eac0369:      * id implemenation, it should not be called for any other reason.
1:eac0369:      **/
1:eac0369:     public LeafControlRow()
4:eac0369:     {
3:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Constructs a leaf-page control row, for a newly allocated leaf page.  
1:eac0369:      *
1:eac0369:      * @param btree     The open btree to allocate this page from.
1:eac0369:      * @param page      The newly allocated page where the control row will
1:eac0369:      *                  be inserted.
1:eac0369:      * @param parent    The parent of the leaf page.  Set to null for root.
1:eac0369:      *                  RESOLVE (mikem) - set to null otherwise?
1:eac0369:      * @param isRoot    Is this page the root of the tree?
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369:      */
1:eac0369:     LeafControlRow(
1:eac0369:     OpenBTree         btree,
1:eac0369:     Page		      page, 
1:eac0369:     ControlRow	      parent,
1:eac0369:     boolean           isRoot)
1:eac0369:             throws StandardException
1:eac0369:     {
1:eac0369:         // All leaf pages are at level 0.
1:eac0369:         super(btree, page, 0, parent, isRoot);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Allocate a new leaf page to the conglomerate.
1:eac0369:      *
1:eac0369:      * @param btree     The open conglomerate from which to get the leaf from
1:eac0369:      * @param parent    The parent page of the newly allocated page, null if
1:eac0369:      *                  allocating root page.
1:eac0369:      * 
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369:      */
1:4a2b0d9:     private static LeafControlRow allocate(
1:eac0369:     OpenBTree   btree, 
1:eac0369:     ControlRow  parent)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         Page      page      = btree.container.addPage();
1:eac0369: 
1:eac0369:         // Create a control row for the new page.
1:eac0369:         LeafControlRow control_row = 
1:eac0369:             new LeafControlRow(btree, page, parent, false);
1:eac0369: 
1:eac0369:         // Insert the control row on the page, in the first slot on the page.
1:eac0369:         // This operation is only done as part of a new tree or split, which
1:eac0369:         // which both will be undone physically so no logical undo record is
1:eac0369:         // needed.
1:eac0369: 		byte insertFlag = Page.INSERT_INITIAL;
1:eac0369: 		insertFlag |= Page.INSERT_DEFAULT;
1:eac0369:         RecordHandle rh = 
1:eac0369:             page.insertAtSlot(Page.FIRST_SLOT_NUMBER,
1:eac0369:                 control_row.getRow(),
1:eac0369:                 (FormatableBitSet) null, 
1:eac0369:                 (LogicalUndo) null, insertFlag,
1:eac0369: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1:eac0369: 
2:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             RecordHandle    rh2 = null;
1:eac0369: 
1:eac0369:             rh2 = page.fetchFromSlot(
1:eac0369:                     (RecordHandle) null, page.FIRST_SLOT_NUMBER, 
1:eac0369:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
1:eac0369:                                  rh.getPageNumber() == rh2.getPageNumber());
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Page is returned latched.
1:eac0369:         return(control_row);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the number of non-deleted rows from slot 1 through "startslot"
1:eac0369:      * <p>
1:eac0369:      * Return the number of non-deleted rows that exist on the page starting
1:eac0369:      * at slot one through "startslot".
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - is the expense of this routine worth it, it is only
1:eac0369:      * used for costing.  Could an estimate from the nonDeletedRecordCount()
1:eac0369:      * be used instead?
1:eac0369:      *
1:eac0369: 	 * @return The requested non_deleted_row_count.
1:eac0369:      *
1:eac0369:      * @param startslot  Count non deleted row up to and including this slot.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private float get_left_nondeleted_rowcnt(
1:eac0369:     int startslot)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         int non_deleted_row_count = 0;
1:eac0369: 
1:eac0369:         for (int slot = 1; slot <= startslot; slot++)
1:eac0369:         {
1:eac0369:             if (!this.page.isDeletedAtSlot(slot))
1:eac0369:             {
1:eac0369:                 non_deleted_row_count++;
1:eac0369:             }
1:eac0369:         }
1:eac0369:         return(non_deleted_row_count);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /* Public Methods of LeafControlRow class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Perform page specific initialization.
1:eac0369:      * <p>
1:eac0369:      **/
1:4a2b0d9:     protected final void controlRowInit()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Initialize conglomerate with one page, to be a 1 page btree.
1:eac0369:      *
1:eac0369:      * Given a conglomerate which already has one page allocated to it, 
1:eac0369:      * initialize the page to be a leaf-root page with no entries.  Allocate
1:eac0369:      * the control row and store it on the page.
1:eac0369:      *
1:eac0369:      * @param open_btree The open btree to initialize (container is open).
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369:      */
1:eac0369:     public static void initEmptyBtree(
1:eac0369:     OpenBTree   open_btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         Page page = 
1:eac0369:             open_btree.container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1:eac0369: 
1:eac0369:         // create a leaf control row for root page of a single page index //
1:eac0369:         LeafControlRow control_row =
1:eac0369:             new LeafControlRow(open_btree, page, null, true);
1:eac0369: 
1:eac0369: 		byte insertFlag = Page.INSERT_INITIAL;
1:eac0369: 		insertFlag |= Page.INSERT_DEFAULT;
1:eac0369:         RecordHandle rh = 
1:eac0369:             page.insertAtSlot(
1:eac0369:                 Page.FIRST_SLOT_NUMBER,
1:eac0369:                 control_row.getRow(),
1:eac0369:                 (FormatableBitSet) null,
1:eac0369:                 (LogicalUndo) null, insertFlag,
1:eac0369: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             RecordHandle    rh2 = null;
1:eac0369: 
1:eac0369:             rh2 = page.fetchFromSlot(
1:eac0369:                     (RecordHandle) null, 
1:eac0369:                     Page.FIRST_SLOT_NUMBER, 
1:eac0369:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
1:eac0369:                                  rh.getPageNumber() == rh2.getPageNumber());
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 control_row.checkConsistency(
1:eac0369:                     open_btree, (ControlRow) null, true);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         page.unlatch();
1:eac0369: 
2:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Non - Debug/consistency check Methods of ControlRow:
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the number of columns in the control row.  
1:eac0369:      * <p>
1:eac0369:      * Control rows all share the first columns as defined by this class and
1:eac0369:      * then add columns to the end of the control row.  For instance a branch
1:eac0369:      * control row add a child page pointer field.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The total number of columns in the control row.
1:eac0369:      **/
1:eac0369:     protected final int getNumberOfControlRowColumns()
1:eac0369:     {
1:eac0369:         return(this.CR_NCOLUMNS);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the current page the leftmost leaf of tree?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return true if the current page is the leftmost leaf of the tree,
1:eac0369:      *              else return false.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean isLeftmostLeaf()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(getleftSiblingPageNumber() == 
1:eac0369:                ContainerHandle.INVALID_PAGE_NUMBER); 
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the current page the rightmost leaf of tree?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return true if the current page is the rightmost leaf of the tree,
1:eac0369:      *              else return false.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean isRightmostLeaf()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(getrightSiblingPageNumber() == 
1:eac0369:                ContainerHandle.INVALID_PAGE_NUMBER); 
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Perform a search of this leaf page, ultimately returning the latched
1:eac0369: 	 ** leaf page and row slot after which the given key belongs.
1:eac0369: 	 ** The slot is returned in the result structure.  If the key
1:eac0369: 	 ** exists on the page, the result.exact will be true.  Otherwise,
1:eac0369: 	 ** result.exact will be false, and the row slot returned will be
1:eac0369: 	 ** the one immediately preceding the position at which the key
1:eac0369: 	 ** belongs.
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	public ControlRow search(
1:eac0369:         SearchParameters    sp)
1:eac0369:             throws StandardException
1:eac0369:     {
1:eac0369:         searchForEntry(sp);
1:eac0369: 
1:eac0369:         if (sp.searchForOptimizer)
1:eac0369:         {
1:eac0369:             // Update left_fraction to be used to estimate the number of
1:eac0369:             // rows left of the current search location.
1:eac0369: 
1:eac0369:             // after the code below startslot will be the slot that is one
1:eac0369:             // before the first slot to be returned by the scan positioning
1:eac0369:             // for this key, including GT/GE positioning.  This is exactly
1:eac0369:             // what the LeafControlRow.positionAtStartForForwardScan() does,
1:eac0369:             // to position for the start of a scan.
1:eac0369: 
1:eac0369:             int startslot = sp.resultSlot;
1:eac0369: 
1:eac0369:             if (sp.resultExact)
1:eac0369:             {
1:eac0369:                 // we found exactly the row we are looking for.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                     SanityManager.ASSERT(sp.resultSlot > 0);
1:eac0369: 
1:eac0369:                 // RESOLVE (mikem) - add in a search operator argument so that 
1:eac0369:                 //     below can be if (op == ScanController.GE)
1:eac0369: 
1:eac0369:                 if (sp.partial_key_match_op == 
1:eac0369:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH)
1:eac0369:                 {
1:eac0369:                     // This means the scan was positioned for GE rather than GT
1:eac0369:                     startslot--;
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             // non_deleted_left_row is the number of actual rows left of the 
1:eac0369:             // first row to be returned by a scan positioned as requested.  
1:eac0369:             // The 0th slot is a control row which is not counted.
1:eac0369:             float non_deleted_left_rows = get_left_nondeleted_rowcnt(startslot);
1:eac0369: 
1:eac0369:             int   non_deleted_row_count = this.page.nonDeletedRecordCount();
1:eac0369: 
1:eac0369:             // System.out.println(
1:eac0369:             //   "\n\t non_deleted_row_count = " + non_deleted_row_count +
1:eac0369:             // "\n\t non_deleted_left_rows = " + non_deleted_left_rows +
1:eac0369:             // "\n\t startslot = " + startslot);
1:eac0369: 
1:eac0369:             if (this.getIsRoot())
1:eac0369:             {
1:eac0369:                 sp.current_fraction = 1;
1:eac0369:                 sp.left_fraction    = 0;
1:eac0369:             }
1:eac0369: 
1:eac0369:             // calculate the fraction of rows in the table which are left of
1:eac0369:             // the current slot in the search.  After the search is completed
1:eac0369:             // (sp.left_fraction * number of rows), is the estimated number
1:eac0369:             // of rows to the left of the current row.
1:eac0369: 
1:eac0369:             if (non_deleted_row_count > 1)
1:eac0369:                 sp.left_fraction    += 
1:eac0369:                     (sp.current_fraction) * 
1:eac0369:                     (non_deleted_left_rows / (non_deleted_row_count - 1));
1:eac0369: 
1:eac0369:             // no-one really uses current fraction after leaf is through with
1:eac0369:             // it.  Set it to help diagnose algorithm.
1:eac0369:             if (non_deleted_row_count > 1)
1:eac0369:                 sp.current_fraction = 
1:eac0369:                     (sp.current_fraction) * 
1:eac0369:                     (((float) 1) / (non_deleted_row_count - 1));
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 	
1:eac0369:     /**
1:eac0369:      * Search and return the left most leaf page.
1:eac0369:      * <p>
1:eac0369: 	 * Perform a recursive search, ultimately returning the
1:eac0369:      * leftmost leaf page which is the first leaf page in the
1:eac0369: 	 * leaf sibling chain.  (This method might better be called
1:eac0369: 	 * getFirstLeafPage()).
1:eac0369:      *
1:eac0369: 	 * @return The leftmost leaf page.
1:eac0369:      *
1:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow searchLeft(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Search and return the right most leaf page.
1:eac0369:      * <p>
1:eac0369: 	 * Perform a recursive search, ultimately returning the
1:eac0369: 	 * rightmost leaf page which is the last leaf page in the
1:eac0369: 	 * leaf sibling chain.  (This method might better be called
1:eac0369: 	 * getLastLeafPage()).
1:eac0369:      *
1:eac0369: 	 * @return The rightmost leaf page.
1:eac0369:      *
1:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow searchRight(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 **	Perform a recursive shrink operation for the key.
1:eac0369: 	 ** If this method returns true, the caller should
1:eac0369: 	 ** remove the corresponding entry for the page.
1:eac0369: 	 ** This routine is not guaranteed to successfully
1:eac0369: 	 ** shrink anything.  The page lead to by the key might
1:eac0369: 	 ** turn out not to be empty by the time shrink gets
1:eac0369: 	 ** there, and shrinks will give up if there is a deadlock.
1:eac0369: 	 ** <P>
1:eac0369: 	 ** The receiver page must be latched on entry and is
1:eac0369: 	 ** returned unlatched.
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	protected boolean shrinkFor(
1:eac0369:     OpenBTree               btree, 
1:eac0369:     DataValueDescriptor[]   key)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean shrink_me = false;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // If this page is empty (ie. only has a control row), and it's not 
1:eac0369:             // the root page, unlink it.  An empty btree consists of
1:eac0369:             // simply an empty leaf-root page.
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) - may want this routine to try to purge 
1:eac0369:             // committed delete rows here?
1:eac0369:             
1:eac0369:             if ((this.page.recordCount() == 1) && !getIsRoot())
1:eac0369:             {
1:eac0369:                  // See if we can unlink this page (might not be able to because
1:eac0369:                  // unlinking can cause deadlocks).  A successful unlink 
1:eac0369:                  // unlatches the page.
1:eac0369:                  shrink_me = unlink(btree);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (!shrink_me)
1:eac0369:                 this.release();
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return(shrink_me);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Perform a top down split pass making room for the the key in "row".
1:eac0369:      * <p>
1:eac0369:      * Perform a split such that a subsequent call to insert
1:eac0369: 	 * given the argument index row will likely find room for it.  Since 
1:eac0369:      * latches are released the client must code for the case where another
1:eac0369:      * user has grabbed the space made available by the split pass and be
1:eac0369:      * ready to do another split.
1:eac0369:      * <p>
1:eac0369:      * On entry, the parent is either null or latched, and the
1:eac0369:      * current page is latched.  On exit, all pages will have been
1:eac0369:      * unlatched.  If the parent is null, then this page is a root
1:eac0369:      * leaf page.
1:eac0369:      *
1:eac0369: 	 * @return page number of the newly allocated leaf page created by split.
1:eac0369:      *
1:06dbbcf:      * @param open_btree  The open btree to associate latches with.
1:06dbbcf:      * @param template    A scratch area to use while searching for split pass.
1:06dbbcf:      * @param parent_page The parent page of the current page in the split pass.
1:06dbbcf:      *                    starts at null for root.
1:06dbbcf:      * @param splitrow    The key to make room for during the split pass.
1:06dbbcf:      * @param flag        A flag used to direct where point of split should be
1:06dbbcf:      *                    chosen.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected long splitFor(
1:eac0369:     OpenBTree               open_btree, 
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     BranchControlRow        parent_page, 
1:eac0369:     DataValueDescriptor[]	splitrow,
1:eac0369:     int                     flag)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         long current_leaf_pageno = this.page.getPageNumber();
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			if (parent_page == null && ( ! this.getIsRoot()))
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369:                 	this + " splitFor null parent and non-root");
1:eac0369:         }
1:eac0369: 
1:eac0369:         // See if this page has space.
1:0750c7b:         if ((this.page.recordCount() - 1 < BTree.maxRowsPerPage) &&
1:eac0369:             (this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
1:eac0369: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
1:eac0369:         {
1:eac0369:             // The splitFor() operation is complete, commit the work done
1:eac0369:             // before releasing the latches.
1:eac0369:             open_btree.getXactMgr().commit();
1:eac0369:              
1:eac0369:             if (parent_page != null)
1:eac0369:                  parent_page.release();
1:eac0369: 
1:eac0369:             this.release();
1:eac0369: 
2:eac0369:             return(current_leaf_pageno);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - for rows bigger than pages this assert may 
1:eac0369:         // trigger until we have long rows.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(this.page.recordCount() > 1);
1:eac0369: 
1:eac0369:         // Track.LeafSplit++;
1:eac0369: 
1:eac0369:         if (this.getIsRoot())
1:eac0369:         {
1:eac0369:             // Track.LeafSplitRoot++;
1:eac0369: 
1:eac0369:             growRoot(open_btree, template, this);
1:eac0369: 
1:eac0369:          
1:eac0369:             // At this point, this page has been unlatched.  So code below this
1:eac0369:             // point must not access this object's fields.
1:eac0369:             
1:4a2b0d9:             ControlRow new_root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 new_root.splitFor(open_btree, template, null, splitrow, flag));
1:eac0369:         }
1:eac0369: 
1:eac0369:         // At this point we know that this page has to be split and
1:eac0369:         // that it isn't a root page.
1:eac0369: 
1:eac0369:         int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
1:eac0369: 
1:eac0369:         if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
1:eac0369:         {
1:eac0369:             // move all the row to the new page
1:eac0369:             splitpoint = 1;
1:eac0369:         }
1:eac0369:         else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
1:eac0369:         {
1:eac0369:             // This is not optimal as we would rather move no rows to the
1:eac0369:             // next page, but what should we use as a discriminator?
1:eac0369:             splitpoint = this.page.recordCount() - 1;
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			if (splitpoint <= 0)
1:eac0369:             	SanityManager.THROWASSERT(this + " yikes! splitpoint of 0!");
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Save away current split point leaf row, and build a branch row
1:eac0369:         // based on it.
1:eac0369:         DataValueDescriptor[] split_leaf_row = 
1:722a889:             open_btree.getConglomerate().createTemplate(
1:722a889:                     open_btree.getRawTran());
1:eac0369: 
1:eac0369:         this.page.fetchFromSlot(
1:eac0369:             (RecordHandle) null, splitpoint, split_leaf_row, 
1:eac0369:             (FetchDescriptor) null, true); 
1:eac0369: 
1:eac0369:         // Create the branch row to insert onto the parent page.  For now
1:eac0369:         // use a fake page number because we don't know the real page 
1:eac0369:         // number until the allocate is done, but want to delay the 
1:eac0369:         // allocate until we know the insert will succeed.
1:eac0369:         BranchRow branchrow = BranchRow.createBranchRowFromOldLeafRow(
1:eac0369:             split_leaf_row, BranchRow.DUMMY_PAGE_NUMBER);
1:eac0369: 
1:eac0369: 
1:eac0369:         // At this point we have guaranteed there is space in the parent
1:eac0369:         // page for splitrow, but it could be the case that the new
1:eac0369:         // "branchrow" does not fit on the parent page.
1:eac0369:         if (!parent_page.page.spaceForInsert(
1:eac0369:                 branchrow.getRow(), (FormatableBitSet) null,
1:eac0369: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
1:eac0369:         {
1:eac0369:             // There is no room on the parent page to complete a split at
1:eac0369:             // the current level, so restart the split at top with the 
1:eac0369:             // branchrow that did not fit.  On return from this routine
1:eac0369:             // there is no way to know the state of the tree, so the
1:eac0369:             // current split pass recursion must end.
1:eac0369:             return(
1:56a7b39:                 BranchControlRow.restartSplitFor(
1:eac0369:                     open_btree, template, parent_page, this, 
1:eac0369:                     branchrow.getRow(), splitrow, flag));
1:eac0369: 
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Create a new leaf page under the parent.
1:eac0369:         LeafControlRow newleaf = 
1:4a2b0d9:             LeafControlRow.allocate(open_btree, parent_page);
1:eac0369: 
1:eac0369:         // Now that we know the page number of the new child page update
1:eac0369:         // the branch row to be inserted with the correct value.
1:eac0369:         branchrow.setPageNumber(newleaf.page.getPageNumber());
1:eac0369: 
1:eac0369:         // Test fail after allocation
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_abort1"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Link it to the right of the current page.
1:eac0369:         newleaf.linkRight(open_btree, this);
1:eac0369: 
1:eac0369: 
1:eac0369: 		// Copy the index rows (from the splitpoint to the end of the page) 
1:eac0369:         // from the old page to the new leaf, do not
1:eac0369:         // copy the control row.  This routine will purge all the copied rows
1:eac0369:         // and maintain the deleted status of the moved rows.
1:eac0369:         int num_rows_to_move = this.page.recordCount() - splitpoint;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(num_rows_to_move >= 0);
1:eac0369: 
1:eac0369:         if (num_rows_to_move != 0)
1:eac0369:         {
1:eac0369:             this.page.copyAndPurge(
1:eac0369:                 newleaf.page, splitpoint, num_rows_to_move, 1);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Test fail after new page has been updated.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_abort2"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Test fail after new page has been updated.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_abort3"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Find spot to insert branch row, and insert it.
1:eac0369: 
1:eac0369: 
1:eac0369:         BranchRow branch_template = 
1:722a889:             BranchRow.createEmptyTemplate(
1:722a889:                     open_btree.getRawTran(),
1:722a889:                     open_btree.getConglomerate());
1:722a889: 
1:eac0369:         SearchParameters sp = 
1:eac0369:             new SearchParameters(
1:eac0369:                 branchrow.getRow(),
1:eac0369:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:eac0369:                 branch_template.getRow(),
1:eac0369:                 open_btree, false);
1:eac0369: 
1:eac0369:         parent_page.searchForEntry(sp);
1:eac0369: 
1:eac0369:         // There must be space on the parent to insert the row!
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 parent_page.page.spaceForInsert(
1:eac0369:                     branchrow.getRow(), (FormatableBitSet) null,
1:eac0369: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD));
1:eac0369:         }
1:eac0369: 
1:eac0369: 		byte insertFlag = Page.INSERT_INITIAL;
1:eac0369: 		insertFlag |= Page.INSERT_DEFAULT;
1:eac0369: 		insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
1:eac0369:         if (parent_page.page.insertAtSlot(
1:eac0369:             sp.resultSlot + 1,
1:eac0369:             branchrow.getRow(),
1:eac0369:             (FormatableBitSet) null,
1:eac0369: 			(LogicalUndo)null, 
1:eac0369:             insertFlag,
1:eac0369: 			AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) == null) {
1:eac0369: 
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.BTREE_NO_SPACE_FOR_KEY);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // branchrow is only valid while split_leaf_row remains unchanged.
1:eac0369:         branchrow = null;
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - this case breaks the btree currently - as the
1:eac0369:         // abort of the insert leaves a logical delete in the tree.
3:eac0369:         //
1:eac0369:         // Test fail after parent page has been updated.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_abort4"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 this.checkConsistency(open_btree, parent_page, false);
1:eac0369:                 newleaf.checkConsistency(open_btree, parent_page, false);
1:eac0369:                 parent_page.checkConsistency(open_btree, null, false);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:86e051f:         // Set a hint in the page that any scan positioned on it needs
1:86e051f:         // to reposition because rows may have moved off the page.
1:86e051f:         page.setRepositionNeeded();
1:86e051f: 
1:eac0369:         // At this point a unit of work in the split down the tree has
1:eac0369:         // been performed in an internal transaction.  This work must
1:eac0369:         // be committed before any latches are released.
1:eac0369:         open_btree.getXactMgr().commit();
1:eac0369: 
1:eac0369:         parent_page.release();
1:eac0369:         this.release();  // XXX (nat) Not good form to unlatch self.
1:eac0369: 
1:eac0369:         long new_leaf_pageno = newleaf.page.getPageNumber();
1:eac0369:         newleaf.release();
1:eac0369: 
1:eac0369:         // Because we are at the leaf level and have completed the split
1:eac0369:         // there is no more work, no latches should be held, and control
1:eac0369:         // is returned up the recursive stack, to the insert causing the
1:eac0369:         // split.  Because latches are released, the inserter must recheck
1:eac0369:         // that there is now space available as some other thread of control
1:eac0369:         // could get in before he latches the page again.
1:eac0369:         return(new_leaf_pageno);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Grow a new root page from a leaf page.  Slightly
1:eac0369: 	 ** tricky because we want to retain page 0 as the root.
1:eac0369: 	 ** <P>
1:eac0369: 	 ** On entry, the current leaf root page is expected 
1:eac0369: 	 ** to be latched.  On exit, all latches will have been
1:eac0369: 	 ** released.
1:eac0369:      ** <P>
1:eac0369:      ** The caller cannot not assume success.  If we have to release latches
1:eac0369:      ** this routine just returns and assumes the caller will retry the 
1:eac0369:      ** grow root if necessary.
1:eac0369: 	 **/
1:eac0369: 	private static void growRoot(
1:eac0369:     OpenBTree               open_btree, 
1:eac0369:     DataValueDescriptor[]   template, 
1:eac0369:     LeafControlRow          leafroot)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		BranchControlRow branchroot =  null;
1:eac0369: 		LeafControlRow   newleaf    =  null; 
1:eac0369: 
1:eac0369:         // Allocate a new leaf page under the existing leaf root.
1:eac0369: 
1:4a2b0d9:         newleaf = LeafControlRow.allocate(open_btree, leafroot);
1:eac0369: 
1:eac0369:         // Test fail after allocation
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_growRoot1"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Copy all the index rows from the root to the new leaf, do not
1:eac0369:         // copy the control row.  This routine will purge all the copied 
1:eac0369:         // rows and maintain the deleted status of the moved rows.
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT((leafroot.page.recordCount() - 1) > 0);
1:eac0369:         leafroot.page.copyAndPurge(
1:eac0369:             newleaf.page, 1, leafroot.page.recordCount() - 1, 1);
1:eac0369: 
1:eac0369:         // Test fail after row copy
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_growRoot2"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Test fail after purge 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_growRoot3"))
1:eac0369:             {
1:eac0369:                 // Make sure tree is very trashed and logical recovery will
1:eac0369:                 // not work.
1:eac0369:                 leafroot.setLevel(42);
1:eac0369:                 leafroot.setParent(42);
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Put a branch control row on the root page, making the new leaf 
1:eac0369:         // the left child.  All leaf splits result in level-1 branch pages.
1:eac0369:         // This will be a branch-root page.
1:eac0369: 
1:eac0369:         // Construction of the BranchControlRow will set it as the aux 
1:eac0369:         // object for the page, this in turn invalidates the previous aux 
1:eac0369:         // object which is leafroot. Thus leafroot must not be used once 
1:eac0369:         // the constructor returns.
1:eac0369: 
1:eac0369:         branchroot = new BranchControlRow(
1:eac0369:             open_btree, leafroot.page, 1, null, true, 
1:eac0369:             newleaf.page.getPageNumber());
1:eac0369:         leafroot = null;
1:eac0369: 
1:eac0369:         // Replace the old leaf root control row with the new branch root 
1:eac0369:         // control row.
1:eac0369:         branchroot.page.updateAtSlot(
1:eac0369:             0, branchroot.getRow(), (FormatableBitSet) null);
1:eac0369: 
1:eac0369:         // Test fail after purge 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_growRoot4"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:eac0369:             {
1:eac0369:                 newleaf.checkConsistency(open_btree, branchroot, false);
1:eac0369:                 branchroot.checkConsistency(open_btree, null, false);
1:eac0369:             }
1:eac0369:         }
1:86e051f: 
1:86e051f:         // Set a hint in the page that any scan positioned on it needs
1:86e051f:         // to reposition because the page is no longer a leaf.
1:86e051f:         branchroot.page.setRepositionNeeded();
1:eac0369:         
1:eac0369:         // At this point a unit of work in the split down the tree has
1:eac0369:         // been performed in an internal transaction.  This work must
1:eac0369:         // be committed before any latches are released.
1:eac0369:         open_btree.getXactMgr().commit();
1:eac0369: 
1:eac0369:         // Test fail after commit of split
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("leaf_split_growRoot5"))
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // The variable 'branchroot' refers to a page that was latched by 
1:eac0369:         // leafroot.  After a growRoot() from a leaf there will be no pages 
1:eac0369:         // latched.  It is up to the callers to reget the root page latched 
1:eac0369:         // and continue their work.
1:eac0369:         //
1:eac0369:         if (branchroot != null)
1:eac0369:             branchroot.release();
1:eac0369:         if (leafroot != null)
1:eac0369:             leafroot.release();
1:eac0369:         if (newleaf != null)
1:eac0369:             newleaf.release();
1:eac0369: 	}
1:eac0369: 	
1:eac0369:     /**
1:eac0369:      * Return the left child pointer for the page.
1:eac0369:      * <p>
1:eac0369:      * Leaf pages don't have children, so they override this and return null.
1:eac0369:      *
1:eac0369: 	 * @return The page which is the leftmost child of this page.
1:eac0369:      *
1:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow getLeftChild(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the right child pointer for the page.
1:eac0369:      * <p>
1:eac0369:      * Leaf pages don't have children, so they override this and return null.
1:eac0369:      *
1:eac0369: 	 * @return The page which is the rightmost child of this page.
1:eac0369:      *
1:eac0369:      * @param btree  The open btree to associate latches/locks with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected ControlRow getRightChild(OpenBTree btree)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(null);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Debug/consistency check Methods of ControlRow:
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Perform consistency checks on a leaf page.
1:eac0369:      ** 
1:eac0369: 	 ** Check consistency of the page and its children,
1:eac0369: 	 ** returning the number of pages seen, and throwing
1:eac0369: 	 ** errors if inconsistencies are found.
1:eac0369:      ** The checks specific to a leaf page are:
1:eac0369: 	 ** <menu>
1:eac0369: 	 ** <li> Page is at level 0.
1:eac0369: 	 ** <li> Version is a valid leaf page version.
1:eac0369: 	 ** <li> Control row has right number of columns for leaf.
1:eac0369: 	 ** </menu>
1:eac0369: 	 ** This method also performs the consistency checks that
1:eac0369: 	 ** are common to both leaf and branch pages.
1:eac0369:      ** @see ControlRow#checkGeneric
1:eac0369:      **
1:eac0369:      ** @exception StandardException Standard exception policy.
1:eac0369: 	 **/  
1:eac0369: 	public int checkConsistency(
1:eac0369:     OpenBTree  btree, 
1:eac0369:     ControlRow parent,
1:eac0369:     boolean    check_other_pages
1:eac0369:     )
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// Do the consistency checks that are common to all
1:eac0369: 		// types of pages.
1:eac0369: 		checkGeneric(btree, parent, check_other_pages);
1:eac0369: 
1:eac0369:         // Leaf specific, control row checks
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(this.getLevel() == 0, "leaf not at level 0");
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) - how to sanity check correct version?
1:eac0369:             /*
1:eac0369: 			if (this.getVersion() != CURRENT_LEAF_VERSION)
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369:                 	"Expected leaf version:(" + 
1:eac0369:                 	CURRENT_LEAF_VERSION + ") but got (" +
1:eac0369:                 	this.getVersion());
1:eac0369:             */
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) == 
1:eac0369:                 ControlRow.CR_NCOLUMNS);
1:eac0369: 
1:eac0369:             // The remaining checks are specific to leaf pages.
1:eac0369: 
1:eac0369:             // Check that every row has at least as many columns
1:eac0369:             // as the number of key fields in the b-tree.
1:eac0369:             int numslots = this.page.recordCount();
1:eac0369:             for (int slot = 1; slot < numslots; slot++)
1:eac0369:             {
1:eac0369: 				if (this.page.fetchNumFieldsAtSlot(slot) <
1:eac0369:                      btree.getConglomerate().nKeyFields)
1:eac0369:                 	SanityManager.THROWASSERT(
1:eac0369:                     	"row[" + slot + "]"
1:eac0369:                         	+ " has " + this.page.fetchNumFieldsAtSlot(slot)
1:eac0369:                         	+ " columns, should have at least" + 
1:eac0369:                         	btree.getConglomerate().nKeyFields);
1:eac0369:                 
1:eac0369:                 // RESOLVE - the generic btree code should know nothing about
1:eac0369:                 // the secondaryindex row location column, but put this here for
1:eac0369:                 // now because I can't figure how to get a call out to the
1:eac0369:                 // secondary index code at the page level consistency checking
1:eac0369:                 // level.
1:eac0369:             }
1:eac0369: 
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// We checked one page (this one).
1:eac0369: 		return 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** Recursively print the tree starting at current node in tree.
1:eac0369:      ** This is a leaf so return.
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	public void printTree(
1:eac0369:     OpenBTree  btree) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
1:eac0369: 
1:eac0369:             return;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of TypedFormat:
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() 
1:eac0369:     {
1:eac0369: 		return StoredFormatIds.ACCESS_BTREE_LEAFCONTROLROW_V1_ID;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0750c7b
/////////////////////////////////////////////////////////////////////////
1:         if ((this.page.recordCount() - 1 < BTree.maxRowsPerPage) &&
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_BTREE_LEAFCONTROLROW_V1_ID
1:  * @derby.purpose   Btree pages all have a control row at the front of every page.  To
1:  * @derby.upgrade   This format was made obsolete in the kimono release.
1:  * @derby.diskLayout 
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1:                 BranchControlRow.restartSplitFor(
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86e051f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Set a hint in the page that any scan positioned on it needs
1:         // to reposition because rows may have moved off the page.
1:         page.setRepositionNeeded();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Set a hint in the page that any scan positioned on it needs
1:         // to reposition because the page is no longer a leaf.
1:         branchroot.page.setRepositionNeeded();
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:             open_btree.getConglomerate().createTemplate(
1:                     open_btree.getRawTran());
/////////////////////////////////////////////////////////////////////////
1:             BranchRow.createEmptyTemplate(
1:                     open_btree.getRawTran(),
1:                     open_btree.getConglomerate());
1: 
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
1:      * @param open_btree  The open btree to associate latches with.
1:      * @param template    A scratch area to use while searching for split pass.
1:      * @param parent_page The parent page of the current page in the split pass.
1:      *                    starts at null for root.
1:      * @param splitrow    The key to make room for during the split pass.
1:      * @param flag        A flag used to direct where point of split should be
1:      *                    chosen.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:     private static LeafControlRow allocate(
/////////////////////////////////////////////////////////////////////////
1:     protected final void controlRowInit()
/////////////////////////////////////////////////////////////////////////
1:             ControlRow new_root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:             LeafControlRow.allocate(open_btree, parent_page);
/////////////////////////////////////////////////////////////////////////
1:         newleaf = LeafControlRow.allocate(open_btree, leafroot);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.LeafControlRow
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
1: {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.TypedFormat;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import java.io.PrintStream;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
0:  * @format_id ACCESS_BTREE_LEAFCONTROLROW_V1_ID
1:  *
0:  * @purpose   Btree pages all have a control row at the front of every page.  To
1:  *            determine the type of row, read the first column which is a format
1:  *            id and it tells what kind of control row it is.
1:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
1:  *
0:  * @disk_layout 
1:  * column 1 - control row type         : StorableFormatId
1:  * column 2 - left sibling page number : SQLLongint
1:  * column 3 - right sibling page number: SQLLongint
1:  * column 4 - parent page number       : SQLLongint
1:  * column 5 - level number (0 is leaf) : SQLLongint
1:  * column 6 - isRoot                   : SQLLongint
1:  * column 7 - Conglomerate object      : null unless it is root else
1:  *                                       a Conglomerate object, matching
1:  *                                       that of current table.
1:  *                                       Currently this field
1:  *                                       is only used by logical undo and
1:  *                                       the type of object is inferred by
1:  *                                       the logical undo code.
1:  **/
1: 
1: public class LeafControlRow extends ControlRow
1: {	
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** Constructors of BranchControlRow
1: 	*/
1: 
1:     /**
1:      * No arg constructor.
1:      * <p>
1:      * Public no arg constructor is for the monitor to call for format
1:      * id implemenation, it should not be called for any other reason.
1:      **/
1:     public LeafControlRow()
1:     {
1:     }
1: 
1:     /**
1:      * Constructs a leaf-page control row, for a newly allocated leaf page.  
1:      *
1:      * @param btree     The open btree to allocate this page from.
1:      * @param page      The newly allocated page where the control row will
1:      *                  be inserted.
1:      * @param parent    The parent of the leaf page.  Set to null for root.
1:      *                  RESOLVE (mikem) - set to null otherwise?
1:      * @param isRoot    Is this page the root of the tree?
1:      *
1:      * @exception StandardException Standard exception policy.
1:      */
1:     LeafControlRow(
1:     OpenBTree         btree,
1:     Page		      page, 
1:     ControlRow	      parent,
1:     boolean           isRoot)
1:             throws StandardException
1:     {
1:         // All leaf pages are at level 0.
1:         super(btree, page, 0, parent, isRoot);
1:     }
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Allocate a new leaf page to the conglomerate.
1:      *
1:      * @param btree     The open conglomerate from which to get the leaf from
1:      * @param parent    The parent page of the newly allocated page, null if
1:      *                  allocating root page.
1:      * 
1:      * @exception StandardException Standard exception policy.
1:      */
0:     private static LeafControlRow Allocate(
1:     OpenBTree   btree, 
1:     ControlRow  parent)
1:         throws StandardException
1:     {
1:         Page      page      = btree.container.addPage();
1: 
1:         // Create a control row for the new page.
1:         LeafControlRow control_row = 
1:             new LeafControlRow(btree, page, parent, false);
1: 
1:         // Insert the control row on the page, in the first slot on the page.
1:         // This operation is only done as part of a new tree or split, which
1:         // which both will be undone physically so no logical undo record is
1:         // needed.
1: 		byte insertFlag = Page.INSERT_INITIAL;
1: 		insertFlag |= Page.INSERT_DEFAULT;
1:         RecordHandle rh = 
1:             page.insertAtSlot(Page.FIRST_SLOT_NUMBER,
1:                 control_row.getRow(),
1:                 (FormatableBitSet) null, 
1:                 (LogicalUndo) null, insertFlag,
1: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             RecordHandle    rh2 = null;
1: 
1:             rh2 = page.fetchFromSlot(
1:                     (RecordHandle) null, page.FIRST_SLOT_NUMBER, 
1:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
1: 
1:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
1:                                  rh.getPageNumber() == rh2.getPageNumber());
1:         }
1: 
1:         // Page is returned latched.
1:         return(control_row);
1:     }
1: 
1:     /**
1:      * Return the number of non-deleted rows from slot 1 through "startslot"
1:      * <p>
1:      * Return the number of non-deleted rows that exist on the page starting
1:      * at slot one through "startslot".
1:      * <p>
1:      * RESOLVE (mikem) - is the expense of this routine worth it, it is only
1:      * used for costing.  Could an estimate from the nonDeletedRecordCount()
1:      * be used instead?
1:      *
1: 	 * @return The requested non_deleted_row_count.
1:      *
1:      * @param startslot  Count non deleted row up to and including this slot.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private float get_left_nondeleted_rowcnt(
1:     int startslot)
1:         throws StandardException
1:     {
1:         int non_deleted_row_count = 0;
1: 
1:         for (int slot = 1; slot <= startslot; slot++)
1:         {
1:             if (!this.page.isDeletedAtSlot(slot))
1:             {
1:                 non_deleted_row_count++;
1:             }
1:         }
1:         return(non_deleted_row_count);
1:     }
1: 
1: 
1:     /* Public Methods of LeafControlRow class: */
1: 
1:     /**
1:      * Perform page specific initialization.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      **/
0:     protected final void ControlRowInit()
1:     {
1:     }
1: 
1:     /**
1:      * Initialize conglomerate with one page, to be a 1 page btree.
1:      *
1:      * Given a conglomerate which already has one page allocated to it, 
1:      * initialize the page to be a leaf-root page with no entries.  Allocate
1:      * the control row and store it on the page.
1:      *
1:      * @param open_btree The open btree to initialize (container is open).
1:      *
1:      * @exception StandardException Standard exception policy.
1:      */
1:     public static void initEmptyBtree(
1:     OpenBTree   open_btree)
1:         throws StandardException
1:     {
1:         Page page = 
1:             open_btree.container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:         // create a leaf control row for root page of a single page index //
1:         LeafControlRow control_row =
1:             new LeafControlRow(open_btree, page, null, true);
1: 
1: 		byte insertFlag = Page.INSERT_INITIAL;
1: 		insertFlag |= Page.INSERT_DEFAULT;
1:         RecordHandle rh = 
1:             page.insertAtSlot(
1:                 Page.FIRST_SLOT_NUMBER,
1:                 control_row.getRow(),
1:                 (FormatableBitSet) null,
1:                 (LogicalUndo) null, insertFlag,
1: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             RecordHandle    rh2 = null;
1: 
1:             rh2 = page.fetchFromSlot(
1:                     (RecordHandle) null, 
1:                     Page.FIRST_SLOT_NUMBER, 
1:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
1: 
1:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
1:                                  rh.getPageNumber() == rh2.getPageNumber());
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 control_row.checkConsistency(
1:                     open_btree, (ControlRow) null, true);
1:             }
1:         }
1: 
1:         page.unlatch();
1: 
1:         return;
1:     }
1: 
1: 	/*
1: 	** Non - Debug/consistency check Methods of ControlRow:
1: 	*/
1: 
1: 
1:     /**
1:      * Get the number of columns in the control row.  
1:      * <p>
1:      * Control rows all share the first columns as defined by this class and
1:      * then add columns to the end of the control row.  For instance a branch
1:      * control row add a child page pointer field.
1:      * <p>
1:      *
1: 	 * @return The total number of columns in the control row.
1:      **/
1:     protected final int getNumberOfControlRowColumns()
1:     {
1:         return(this.CR_NCOLUMNS);
1:     }
1: 
1:     /**
1:      * Is the current page the leftmost leaf of tree?
1:      * <p>
1:      *
1: 	 * @return true if the current page is the leftmost leaf of the tree,
1:      *              else return false.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean isLeftmostLeaf()
1: 		throws StandardException
1:     {
1:         return(getleftSiblingPageNumber() == 
1:                ContainerHandle.INVALID_PAGE_NUMBER); 
1:     }
1: 
1:     /**
1:      * Is the current page the rightmost leaf of tree?
1:      * <p>
1:      *
1: 	 * @return true if the current page is the rightmost leaf of the tree,
1:      *              else return false.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean isRightmostLeaf()
1: 		throws StandardException
1:     {
1:         return(getrightSiblingPageNumber() == 
1:                ContainerHandle.INVALID_PAGE_NUMBER); 
1:     }
1: 
1: 
1: 	/**
1: 	 ** Perform a search of this leaf page, ultimately returning the latched
1: 	 ** leaf page and row slot after which the given key belongs.
1: 	 ** The slot is returned in the result structure.  If the key
1: 	 ** exists on the page, the result.exact will be true.  Otherwise,
1: 	 ** result.exact will be false, and the row slot returned will be
1: 	 ** the one immediately preceding the position at which the key
1: 	 ** belongs.
1:      *
1:      * @exception StandardException Standard exception policy.
1: 	 **/
1: 	public ControlRow search(
1:         SearchParameters    sp)
1:             throws StandardException
1:     {
1:         searchForEntry(sp);
1: 
1:         if (sp.searchForOptimizer)
1:         {
1:             // Update left_fraction to be used to estimate the number of
1:             // rows left of the current search location.
1: 
1:             // after the code below startslot will be the slot that is one
1:             // before the first slot to be returned by the scan positioning
1:             // for this key, including GT/GE positioning.  This is exactly
1:             // what the LeafControlRow.positionAtStartForForwardScan() does,
1:             // to position for the start of a scan.
1: 
1:             int startslot = sp.resultSlot;
1: 
1:             if (sp.resultExact)
1:             {
1:                 // we found exactly the row we are looking for.
1: 
1:                 if (SanityManager.DEBUG)
1:                     SanityManager.ASSERT(sp.resultSlot > 0);
1: 
1:                 // RESOLVE (mikem) - add in a search operator argument so that 
1:                 //     below can be if (op == ScanController.GE)
1: 
1:                 if (sp.partial_key_match_op == 
1:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH)
1:                 {
1:                     // This means the scan was positioned for GE rather than GT
1:                     startslot--;
1:                 }
1:             }
1: 
1:             // non_deleted_left_row is the number of actual rows left of the 
1:             // first row to be returned by a scan positioned as requested.  
1:             // The 0th slot is a control row which is not counted.
1:             float non_deleted_left_rows = get_left_nondeleted_rowcnt(startslot);
1: 
1:             int   non_deleted_row_count = this.page.nonDeletedRecordCount();
1: 
1:             // System.out.println(
1:             //   "\n\t non_deleted_row_count = " + non_deleted_row_count +
1:             // "\n\t non_deleted_left_rows = " + non_deleted_left_rows +
1:             // "\n\t startslot = " + startslot);
1: 
1:             if (this.getIsRoot())
1:             {
1:                 sp.current_fraction = 1;
1:                 sp.left_fraction    = 0;
1:             }
1: 
1:             // calculate the fraction of rows in the table which are left of
1:             // the current slot in the search.  After the search is completed
1:             // (sp.left_fraction * number of rows), is the estimated number
1:             // of rows to the left of the current row.
1: 
1:             if (non_deleted_row_count > 1)
1:                 sp.left_fraction    += 
1:                     (sp.current_fraction) * 
1:                     (non_deleted_left_rows / (non_deleted_row_count - 1));
1: 
1:             // no-one really uses current fraction after leaf is through with
1:             // it.  Set it to help diagnose algorithm.
1:             if (non_deleted_row_count > 1)
1:                 sp.current_fraction = 
1:                     (sp.current_fraction) * 
1:                     (((float) 1) / (non_deleted_row_count - 1));
1:         }
1: 
1:         return(this);
1:     }
1: 	
1:     /**
1:      * Search and return the left most leaf page.
1:      * <p>
1: 	 * Perform a recursive search, ultimately returning the
1:      * leftmost leaf page which is the first leaf page in the
1: 	 * leaf sibling chain.  (This method might better be called
1: 	 * getFirstLeafPage()).
1:      *
1: 	 * @return The leftmost leaf page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow searchLeft(OpenBTree btree)
1:         throws StandardException
1:     {
1:         return(this);
1:     }
1: 
1:     /**
1:      * Search and return the right most leaf page.
1:      * <p>
1: 	 * Perform a recursive search, ultimately returning the
1: 	 * rightmost leaf page which is the last leaf page in the
1: 	 * leaf sibling chain.  (This method might better be called
1: 	 * getLastLeafPage()).
1:      *
1: 	 * @return The rightmost leaf page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow searchRight(OpenBTree btree)
1:         throws StandardException
1:     {
1:         return(this);
1:     }
1: 
1: 
1: 	/**
1: 	 **	Perform a recursive shrink operation for the key.
1: 	 ** If this method returns true, the caller should
1: 	 ** remove the corresponding entry for the page.
1: 	 ** This routine is not guaranteed to successfully
1: 	 ** shrink anything.  The page lead to by the key might
1: 	 ** turn out not to be empty by the time shrink gets
1: 	 ** there, and shrinks will give up if there is a deadlock.
1: 	 ** <P>
1: 	 ** The receiver page must be latched on entry and is
1: 	 ** returned unlatched.
1:      *
1:      * @exception StandardException Standard exception policy.
1: 	 **/
1: 	protected boolean shrinkFor(
1:     OpenBTree               btree, 
1:     DataValueDescriptor[]   key)
1:         throws StandardException
1:     {
1:         boolean shrink_me = false;
1: 
1:         try
1:         {
1:             // If this page is empty (ie. only has a control row), and it's not 
1:             // the root page, unlink it.  An empty btree consists of
1:             // simply an empty leaf-root page.
1: 
1:             // RESOLVE (mikem) - may want this routine to try to purge 
1:             // committed delete rows here?
1:             
1:             if ((this.page.recordCount() == 1) && !getIsRoot())
1:             {
1:                  // See if we can unlink this page (might not be able to because
1:                  // unlinking can cause deadlocks).  A successful unlink 
1:                  // unlatches the page.
1:                  shrink_me = unlink(btree);
1:             }
1:         }
1:         finally
1:         {
1:             if (!shrink_me)
1:                 this.release();
1:         }
1: 
1: 		return(shrink_me);
1:     }
1: 
1: 
1:     /**
1:      * Perform a top down split pass making room for the the key in "row".
1:      * <p>
1:      * Perform a split such that a subsequent call to insert
1: 	 * given the argument index row will likely find room for it.  Since 
1:      * latches are released the client must code for the case where another
1:      * user has grabbed the space made available by the split pass and be
1:      * ready to do another split.
1:      * <p>
1:      * On entry, the parent is either null or latched, and the
1:      * current page is latched.  On exit, all pages will have been
1:      * unlatched.  If the parent is null, then this page is a root
1:      * leaf page.
1:      *
1: 	 * @return page number of the newly allocated leaf page created by split.
1:      *
0:      * @param btree      The open btree to associate latches with.
0:      * @param template   A scratch area to use while searching for split pass.
0:      * @param parentpage The parent page of the current page in the split pass.
0:      *                   starts at null for root.
0:      * @param row        The key to make room for during the split pass.
0:      * @param flag       A flag used to direct where point of split should be
0:      *                   chosen.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected long splitFor(
1:     OpenBTree               open_btree, 
1:     DataValueDescriptor[]   template,
1:     BranchControlRow        parent_page, 
1:     DataValueDescriptor[]	splitrow,
1:     int                     flag)
1:         throws StandardException
1:     {
1:         long current_leaf_pageno = this.page.getPageNumber();
1: 
1:         if (SanityManager.DEBUG)
1:         {
1: 			if (parent_page == null && ( ! this.getIsRoot()))
1:             	SanityManager.THROWASSERT(
1:                 	this + " splitFor null parent and non-root");
1:         }
1: 
1:         // See if this page has space.
0:         if ((this.page.recordCount() - 1 < 
0:                 open_btree.getConglomerate().maxRowsPerPage) &&
1:             (this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
1: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
1:         {
1:             // The splitFor() operation is complete, commit the work done
1:             // before releasing the latches.
1:             open_btree.getXactMgr().commit();
1:              
1:             if (parent_page != null)
1:                  parent_page.release();
1: 
1:             this.release();
1: 
1:             return(current_leaf_pageno);
1:         }
1: 
1:         // RESOLVE (mikem) - for rows bigger than pages this assert may 
1:         // trigger until we have long rows.
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(this.page.recordCount() > 1);
1: 
1:         // Track.LeafSplit++;
1: 
1:         if (this.getIsRoot())
1:         {
1:             // Track.LeafSplitRoot++;
1: 
1:             growRoot(open_btree, template, this);
1: 
1:          
1:             // At this point, this page has been unlatched.  So code below this
1:             // point must not access this object's fields.
1:             
0:             ControlRow new_root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
1: 
1:             return(
1:                 new_root.splitFor(open_btree, template, null, splitrow, flag));
1:         }
1: 
1:         // At this point we know that this page has to be split and
1:         // that it isn't a root page.
1: 
1:         int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
1: 
1:         if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
1:         {
1:             // move all the row to the new page
1:             splitpoint = 1;
1:         }
1:         else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
1:         {
1:             // This is not optimal as we would rather move no rows to the
1:             // next page, but what should we use as a discriminator?
1:             splitpoint = this.page.recordCount() - 1;
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1: 			if (splitpoint <= 0)
1:             	SanityManager.THROWASSERT(this + " yikes! splitpoint of 0!");
1:         }
1: 
1:         // Save away current split point leaf row, and build a branch row
1:         // based on it.
1:         DataValueDescriptor[] split_leaf_row = 
0:             open_btree.getConglomerate().createTemplate();
1: 
1:         this.page.fetchFromSlot(
1:             (RecordHandle) null, splitpoint, split_leaf_row, 
1:             (FetchDescriptor) null, true); 
1: 
1:         // Create the branch row to insert onto the parent page.  For now
1:         // use a fake page number because we don't know the real page 
1:         // number until the allocate is done, but want to delay the 
1:         // allocate until we know the insert will succeed.
1:         BranchRow branchrow = BranchRow.createBranchRowFromOldLeafRow(
1:             split_leaf_row, BranchRow.DUMMY_PAGE_NUMBER);
1: 
1: 
1:         // At this point we have guaranteed there is space in the parent
1:         // page for splitrow, but it could be the case that the new
1:         // "branchrow" does not fit on the parent page.
1:         if (!parent_page.page.spaceForInsert(
1:                 branchrow.getRow(), (FormatableBitSet) null,
1: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
1:         {
1:             // There is no room on the parent page to complete a split at
1:             // the current level, so restart the split at top with the 
1:             // branchrow that did not fit.  On return from this routine
1:             // there is no way to know the state of the tree, so the
1:             // current split pass recursion must end.
1:             return(
0:                 ((BranchControlRow) parent_page).restartSplitFor(
1:                     open_btree, template, parent_page, this, 
1:                     branchrow.getRow(), splitrow, flag));
1: 
1:         }
0:         // Before moving the rows on the page, while having the latch on the
0:         // page, notify btree scans that the rows on this page may be moving
0:         // onto another page.
1:         //
0:         // RESOLVE (mikem) - need to pass conlgomid.
0:         // RESOLVE (mikem) - some optimization later, we only need to notify
0:         // the scans which are positioned on moving rows.
1:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(open_btree.init_open_user_scans != null);
1: 
0:         open_btree.init_open_user_scans.saveScanPositions(
0:                 open_btree.getConglomerate(), this.page);
1: 
0:         // Get exclusive RECORD_ID_PROTECTION_HANDLE lock to make sure that
0:         // we wait for scans in other transactions to move off of this page
0:         // before we split.
1: 
0:         if (!open_btree.getLockingPolicy().lockScan(
0:                 this, parent_page, true /* for update */, 
0:                 ConglomerateController.LOCK_UPD))
1:         {
0:             // we had to give up latches on this and parent_page to get the
0:             // split lock.  Redo the whole split pass as we have lost our
0:             // latches.  Just returning is ok, as the caller can not assume
0:             // that split has succeeded in making space.  Note that at this
0:             // point in the split no write work has been done in the current
0:             // internal transaction, so giving up here is fairly cheap.
1: 
0:             // RESOLVE RLL PERFORMANCE - we could keep a stack of visited
0:             // pages so as to not have to redo the complete search.
1:             return(current_leaf_pageno);
1:         }
1: 
1:         // Create a new leaf page under the parent.
1:         LeafControlRow newleaf = 
0:             LeafControlRow.Allocate(open_btree, parent_page);
1: 
1:         // Now that we know the page number of the new child page update
1:         // the branch row to be inserted with the correct value.
1:         branchrow.setPageNumber(newleaf.page.getPageNumber());
1: 
1:         // Test fail after allocation
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_abort1"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Link it to the right of the current page.
1:         newleaf.linkRight(open_btree, this);
1: 
1: 
1: 		// Copy the index rows (from the splitpoint to the end of the page) 
1:         // from the old page to the new leaf, do not
1:         // copy the control row.  This routine will purge all the copied rows
1:         // and maintain the deleted status of the moved rows.
1:         int num_rows_to_move = this.page.recordCount() - splitpoint;
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(num_rows_to_move >= 0);
1: 
1:         if (num_rows_to_move != 0)
1:         {
1:             this.page.copyAndPurge(
1:                 newleaf.page, splitpoint, num_rows_to_move, 1);
1:         }
1: 
1:         // Test fail after new page has been updated.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_abort2"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Test fail after new page has been updated.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_abort3"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Find spot to insert branch row, and insert it.
1: 
1: 
1:         BranchRow branch_template = 
0:             BranchRow.createEmptyTemplate(open_btree.getConglomerate());
1:         SearchParameters sp = 
1:             new SearchParameters(
1:                 branchrow.getRow(),
1:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
1:                 branch_template.getRow(),
1:                 open_btree, false);
1: 
1:         parent_page.searchForEntry(sp);
1: 
1:         // There must be space on the parent to insert the row!
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 parent_page.page.spaceForInsert(
1:                     branchrow.getRow(), (FormatableBitSet) null,
1: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD));
1:         }
1: 
1: 		byte insertFlag = Page.INSERT_INITIAL;
1: 		insertFlag |= Page.INSERT_DEFAULT;
1: 		insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
1:         if (parent_page.page.insertAtSlot(
1:             sp.resultSlot + 1,
1:             branchrow.getRow(),
1:             (FormatableBitSet) null,
1: 			(LogicalUndo)null, 
1:             insertFlag,
1: 			AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) == null) {
1: 
1:             throw StandardException.newException(
1:                     SQLState.BTREE_NO_SPACE_FOR_KEY);
1: 		}
1: 
1:         // branchrow is only valid while split_leaf_row remains unchanged.
1:         branchrow = null;
1: 
1:         // RESOLVE (mikem) - this case breaks the btree currently - as the
1:         // abort of the insert leaves a logical delete in the tree.
1:         //
1:         // Test fail after parent page has been updated.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_abort4"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 this.checkConsistency(open_btree, parent_page, false);
1:                 newleaf.checkConsistency(open_btree, parent_page, false);
1:                 parent_page.checkConsistency(open_btree, null, false);
1:             }
1:         }
1: 
1:         // At this point a unit of work in the split down the tree has
1:         // been performed in an internal transaction.  This work must
1:         // be committed before any latches are released.
1:         open_btree.getXactMgr().commit();
1: 
1:         parent_page.release();
1:         this.release();  // XXX (nat) Not good form to unlatch self.
1: 
1:         long new_leaf_pageno = newleaf.page.getPageNumber();
1:         newleaf.release();
1: 
1:         // Because we are at the leaf level and have completed the split
1:         // there is no more work, no latches should be held, and control
1:         // is returned up the recursive stack, to the insert causing the
1:         // split.  Because latches are released, the inserter must recheck
1:         // that there is now space available as some other thread of control
1:         // could get in before he latches the page again.
1:         return(new_leaf_pageno);
1:     }
1: 
1: 	/**
1: 	 ** Grow a new root page from a leaf page.  Slightly
1: 	 ** tricky because we want to retain page 0 as the root.
1: 	 ** <P>
1: 	 ** On entry, the current leaf root page is expected 
1: 	 ** to be latched.  On exit, all latches will have been
1: 	 ** released.
1:      ** <P>
1:      ** The caller cannot not assume success.  If we have to release latches
1:      ** this routine just returns and assumes the caller will retry the 
1:      ** grow root if necessary.
1: 	 **/
1: 	private static void growRoot(
1:     OpenBTree               open_btree, 
1:     DataValueDescriptor[]   template, 
1:     LeafControlRow          leafroot)
1:         throws StandardException
1: 	{
1: 		BranchControlRow branchroot =  null;
1: 		LeafControlRow   newleaf    =  null; 
1: 
1: 
0:         // Before moving the rows on the page, while having the latch on the
0:         // page, notify btree scans that the rows on this page may be moving
0:         // onto another page.
1:         //
0:         open_btree.init_open_user_scans.saveScanPositions(
0:                 open_btree.getConglomerate(), leafroot.page);
1: 
0:         // Get exclusive RECORD_ID_PROTECTION_HANDLE lock to make sure that
0:         // we wait for scans in other transactions to move off of this page
0:         // before we grow root.  If we don't wait, scanners in other 
0:         // transactions may be positioned on the leaf page which we are 
0:         // about to make into a branch page.
1: 
0:         if (!open_btree.getLockingPolicy().lockScan(
0:                 leafroot, (ControlRow) null, 
0:                 true /* for update */,
0:                 ConglomerateController.LOCK_UPD))
1:         {
0:             // We had to give up latches on leafroot to get the
0:             // split lock.  Redo the whole split pass as we have lost our
0:             // latches - which may mean that the root has grown when we gave
0:             // up the latch.  Just returning is ok, as the caller can not assume
0:             // that grow root has succeeded in making space.  Note that at this
0:             // point in the split no write work has been done in the current
0:             // internal transaction, so giving up here is fairly cheap.
1: 
1:             return;
1:         }
1: 
1:         // Allocate a new leaf page under the existing leaf root.
1: 
0:         newleaf = LeafControlRow.Allocate(open_btree, leafroot);
1: 
1:         // Test fail after allocation
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_growRoot1"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Copy all the index rows from the root to the new leaf, do not
1:         // copy the control row.  This routine will purge all the copied 
1:         // rows and maintain the deleted status of the moved rows.
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT((leafroot.page.recordCount() - 1) > 0);
1:         leafroot.page.copyAndPurge(
1:             newleaf.page, 1, leafroot.page.recordCount() - 1, 1);
1: 
1:         // Test fail after row copy
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_growRoot2"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Test fail after purge 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_growRoot3"))
1:             {
1:                 // Make sure tree is very trashed and logical recovery will
1:                 // not work.
1:                 leafroot.setLevel(42);
1:                 leafroot.setParent(42);
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // Put a branch control row on the root page, making the new leaf 
1:         // the left child.  All leaf splits result in level-1 branch pages.
1:         // This will be a branch-root page.
1: 
1:         // Construction of the BranchControlRow will set it as the aux 
1:         // object for the page, this in turn invalidates the previous aux 
1:         // object which is leafroot. Thus leafroot must not be used once 
1:         // the constructor returns.
1: 
1:         branchroot = new BranchControlRow(
1:             open_btree, leafroot.page, 1, null, true, 
1:             newleaf.page.getPageNumber());
1:         leafroot = null;
1: 
1:         // Replace the old leaf root control row with the new branch root 
1:         // control row.
1:         branchroot.page.updateAtSlot(
1:             0, branchroot.getRow(), (FormatableBitSet) null);
1: 
1:         // Test fail after purge 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_growRoot4"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
1:             {
1:                 newleaf.checkConsistency(open_btree, branchroot, false);
1:                 branchroot.checkConsistency(open_btree, null, false);
1:             }
1:         }
1:         
1:         // At this point a unit of work in the split down the tree has
1:         // been performed in an internal transaction.  This work must
1:         // be committed before any latches are released.
1:         open_btree.getXactMgr().commit();
1: 
1:         // Test fail after commit of split
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("leaf_split_growRoot5"))
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
1:             }
1:         }
1: 
1:         // The variable 'branchroot' refers to a page that was latched by 
1:         // leafroot.  After a growRoot() from a leaf there will be no pages 
1:         // latched.  It is up to the callers to reget the root page latched 
1:         // and continue their work.
1:         //
1:         if (branchroot != null)
1:             branchroot.release();
1:         if (leafroot != null)
1:             leafroot.release();
1:         if (newleaf != null)
1:             newleaf.release();
1: 	}
1: 	
1:     /**
1:      * Return the left child pointer for the page.
1:      * <p>
1:      * Leaf pages don't have children, so they override this and return null.
1:      *
1: 	 * @return The page which is the leftmost child of this page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow getLeftChild(OpenBTree btree)
1:         throws StandardException
1:     {
1:         return(null);
1:     }
1: 
1:     /**
1:      * Return the right child pointer for the page.
1:      * <p>
1:      * Leaf pages don't have children, so they override this and return null.
1:      *
1: 	 * @return The page which is the rightmost child of this page.
1:      *
1:      * @param btree  The open btree to associate latches/locks with.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected ControlRow getRightChild(OpenBTree btree)
1:         throws StandardException
1:     {
1:         return(null);
1:     }
1: 
1: 	/*
1: 	** Debug/consistency check Methods of ControlRow:
1: 	*/
1: 
1: 	/**
1: 	 ** Perform consistency checks on a leaf page.
1:      ** 
1: 	 ** Check consistency of the page and its children,
1: 	 ** returning the number of pages seen, and throwing
1: 	 ** errors if inconsistencies are found.
1:      ** The checks specific to a leaf page are:
1: 	 ** <menu>
1: 	 ** <li> Page is at level 0.
1: 	 ** <li> Version is a valid leaf page version.
1: 	 ** <li> Control row has right number of columns for leaf.
1: 	 ** </menu>
1: 	 ** This method also performs the consistency checks that
1: 	 ** are common to both leaf and branch pages.
1:      ** @see ControlRow#checkGeneric
1:      **
1:      ** @exception StandardException Standard exception policy.
1: 	 **/  
1: 	public int checkConsistency(
1:     OpenBTree  btree, 
1:     ControlRow parent,
1:     boolean    check_other_pages
1:     )
1:         throws StandardException
1: 	{
1: 		// Do the consistency checks that are common to all
1: 		// types of pages.
1: 		checkGeneric(btree, parent, check_other_pages);
1: 
1:         // Leaf specific, control row checks
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(this.getLevel() == 0, "leaf not at level 0");
1: 
1:             // RESOLVE (mikem) - how to sanity check correct version?
1:             /*
1: 			if (this.getVersion() != CURRENT_LEAF_VERSION)
1:             	SanityManager.THROWASSERT(
1:                 	"Expected leaf version:(" + 
1:                 	CURRENT_LEAF_VERSION + ") but got (" +
1:                 	this.getVersion());
1:             */
1:             SanityManager.ASSERT(
1:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) == 
1:                 ControlRow.CR_NCOLUMNS);
1: 
1:             // The remaining checks are specific to leaf pages.
1: 
1:             // Check that every row has at least as many columns
1:             // as the number of key fields in the b-tree.
1:             int numslots = this.page.recordCount();
1:             for (int slot = 1; slot < numslots; slot++)
1:             {
1: 				if (this.page.fetchNumFieldsAtSlot(slot) <
1:                      btree.getConglomerate().nKeyFields)
1:                 	SanityManager.THROWASSERT(
1:                     	"row[" + slot + "]"
1:                         	+ " has " + this.page.fetchNumFieldsAtSlot(slot)
1:                         	+ " columns, should have at least" + 
1:                         	btree.getConglomerate().nKeyFields);
1:                 
1:                 // RESOLVE - the generic btree code should know nothing about
1:                 // the secondaryindex row location column, but put this here for
1:                 // now because I can't figure how to get a call out to the
1:                 // secondary index code at the page level consistency checking
1:                 // level.
1:             }
1: 
1:         }
1: 
1: 		// We checked one page (this one).
1: 		return 1;
1: 	}
1: 
1: 	/**
1: 	 ** Recursively print the tree starting at current node in tree.
1:      ** This is a leaf so return.
1: 
1:     @exception StandardException Standard exception policy.
1: 	 **/
1: 	public void printTree(
1:     OpenBTree  btree) 
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
1: 
1:             return;
1:         }
1:     }
1: 
1: 
1: 	/*
1: 	 * Methods of TypedFormat:
1: 	 */
1: 
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() 
1:     {
1: 		return StoredFormatIds.ACCESS_BTREE_LEAFCONTROLROW_V1_ID;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.TypedFormat;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import java.io.PrintStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * @format_id ACCESS_BTREE_LEAFCONTROLROW_V1_ID
0:  *
0:  * @purpose   Btree pages all have a control row at the front of every page.  To
0:  *            determine the type of row, read the first column which is a format
0:  *            id and it tells what kind of control row it is.
0:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
0:  *
0:  * @disk_layout 
0:  * column 1 - control row type         : StorableFormatId
0:  * column 2 - left sibling page number : SQLLongint
0:  * column 3 - right sibling page number: SQLLongint
0:  * column 4 - parent page number       : SQLLongint
0:  * column 5 - level number (0 is leaf) : SQLLongint
0:  * column 6 - isRoot                   : SQLLongint
0:  * column 7 - Conglomerate object      : null unless it is root else
0:  *                                       a Conglomerate object, matching
0:  *                                       that of current table.
0:  *                                       Currently this field
0:  *                                       is only used by logical undo and
0:  *                                       the type of object is inferred by
0:  *                                       the logical undo code.
0:  **/
0: 
0: public class LeafControlRow extends ControlRow
0: {	
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** Constructors of BranchControlRow
0: 	*/
0: 
0:     /**
0:      * No arg constructor.
0:      * <p>
0:      * Public no arg constructor is for the monitor to call for format
0:      * id implemenation, it should not be called for any other reason.
0:      **/
0:     public LeafControlRow()
0:     {
0:     }
0: 
0:     /**
0:      * Constructs a leaf-page control row, for a newly allocated leaf page.  
0:      *
0:      * @param btree     The open btree to allocate this page from.
0:      * @param page      The newly allocated page where the control row will
0:      *                  be inserted.
0:      * @param parent    The parent of the leaf page.  Set to null for root.
0:      *                  RESOLVE (mikem) - set to null otherwise?
0:      * @param isRoot    Is this page the root of the tree?
0:      *
0:      * @exception StandardException Standard exception policy.
0:      */
0:     LeafControlRow(
0:     OpenBTree         btree,
0:     Page		      page, 
0:     ControlRow	      parent,
0:     boolean           isRoot)
0:             throws StandardException
0:     {
0:         // All leaf pages are at level 0.
0:         super(btree, page, 0, parent, isRoot);
0:     }
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Allocate a new leaf page to the conglomerate.
0:      *
0:      * @param btree     The open conglomerate from which to get the leaf from
0:      * @param parent    The parent page of the newly allocated page, null if
0:      *                  allocating root page.
0:      * 
0:      * @exception StandardException Standard exception policy.
0:      */
0:     private static LeafControlRow Allocate(
0:     OpenBTree   btree, 
0:     ControlRow  parent)
0:         throws StandardException
0:     {
0:         Page      page      = btree.container.addPage();
0: 
0:         // Create a control row for the new page.
0:         LeafControlRow control_row = 
0:             new LeafControlRow(btree, page, parent, false);
0: 
0:         // Insert the control row on the page, in the first slot on the page.
0:         // This operation is only done as part of a new tree or split, which
0:         // which both will be undone physically so no logical undo record is
0:         // needed.
0: 		byte insertFlag = Page.INSERT_INITIAL;
0: 		insertFlag |= Page.INSERT_DEFAULT;
0:         RecordHandle rh = 
0:             page.insertAtSlot(Page.FIRST_SLOT_NUMBER,
0:                 control_row.getRow(),
0:                 (FormatableBitSet) null, 
0:                 (LogicalUndo) null, insertFlag,
0: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             RecordHandle    rh2 = null;
0: 
0:             rh2 = page.fetchFromSlot(
0:                     (RecordHandle) null, page.FIRST_SLOT_NUMBER, 
0:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
0: 
0:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
0:                                  rh.getPageNumber() == rh2.getPageNumber());
0:         }
0: 
0:         // Page is returned latched.
0:         return(control_row);
0:     }
0: 
0:     /**
0:      * Return the number of non-deleted rows from slot 1 through "startslot"
0:      * <p>
0:      * Return the number of non-deleted rows that exist on the page starting
0:      * at slot one through "startslot".
0:      * <p>
0:      * RESOLVE (mikem) - is the expense of this routine worth it, it is only
0:      * used for costing.  Could an estimate from the nonDeletedRecordCount()
0:      * be used instead?
0:      *
0: 	 * @return The requested non_deleted_row_count.
0:      *
0:      * @param startslot  Count non deleted row up to and including this slot.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private float get_left_nondeleted_rowcnt(
0:     int startslot)
0:         throws StandardException
0:     {
0:         int non_deleted_row_count = 0;
0: 
0:         for (int slot = 1; slot <= startslot; slot++)
0:         {
0:             if (!this.page.isDeletedAtSlot(slot))
0:             {
0:                 non_deleted_row_count++;
0:             }
0:         }
0:         return(non_deleted_row_count);
0:     }
0: 
0: 
0:     /* Public Methods of LeafControlRow class: */
0: 
0:     /**
0:      * Perform page specific initialization.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      **/
0:     protected final void ControlRowInit()
0:     {
0:     }
0: 
0:     /**
0:      * Initialize conglomerate with one page, to be a 1 page btree.
0:      *
0:      * Given a conglomerate which already has one page allocated to it, 
0:      * initialize the page to be a leaf-root page with no entries.  Allocate
0:      * the control row and store it on the page.
0:      *
0:      * @param open_btree The open btree to initialize (container is open).
0:      *
0:      * @exception StandardException Standard exception policy.
0:      */
0:     public static void initEmptyBtree(
0:     OpenBTree   open_btree)
0:         throws StandardException
0:     {
0:         Page page = 
0:             open_btree.container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:         // create a leaf control row for root page of a single page index //
0:         LeafControlRow control_row =
0:             new LeafControlRow(open_btree, page, null, true);
0: 
0: 		byte insertFlag = Page.INSERT_INITIAL;
0: 		insertFlag |= Page.INSERT_DEFAULT;
0:         RecordHandle rh = 
0:             page.insertAtSlot(
0:                 Page.FIRST_SLOT_NUMBER,
0:                 control_row.getRow(),
0:                 (FormatableBitSet) null,
0:                 (LogicalUndo) null, insertFlag,
0: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             RecordHandle    rh2 = null;
0: 
0:             rh2 = page.fetchFromSlot(
0:                     (RecordHandle) null, 
0:                     Page.FIRST_SLOT_NUMBER, 
0:                     new DataValueDescriptor[0], (FetchDescriptor) null, true); 
0: 
0:             SanityManager.ASSERT(rh.getId() == rh2.getId() &&
0:                                  rh.getPageNumber() == rh2.getPageNumber());
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 control_row.checkConsistency(
0:                     open_btree, (ControlRow) null, true);
0:             }
0:         }
0: 
0:         page.unlatch();
0: 
0:         return;
0:     }
0: 
0: 	/*
0: 	** Non - Debug/consistency check Methods of ControlRow:
0: 	*/
0: 
0: 
0:     /**
0:      * Get the number of columns in the control row.  
0:      * <p>
0:      * Control rows all share the first columns as defined by this class and
0:      * then add columns to the end of the control row.  For instance a branch
0:      * control row add a child page pointer field.
0:      * <p>
0:      *
0: 	 * @return The total number of columns in the control row.
0:      **/
0:     protected final int getNumberOfControlRowColumns()
0:     {
0:         return(this.CR_NCOLUMNS);
0:     }
0: 
0:     /**
0:      * Is the current page the leftmost leaf of tree?
0:      * <p>
0:      *
0: 	 * @return true if the current page is the leftmost leaf of the tree,
0:      *              else return false.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean isLeftmostLeaf()
0: 		throws StandardException
0:     {
0:         return(getleftSiblingPageNumber() == 
0:                ContainerHandle.INVALID_PAGE_NUMBER); 
0:     }
0: 
0:     /**
0:      * Is the current page the rightmost leaf of tree?
0:      * <p>
0:      *
0: 	 * @return true if the current page is the rightmost leaf of the tree,
0:      *              else return false.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean isRightmostLeaf()
0: 		throws StandardException
0:     {
0:         return(getrightSiblingPageNumber() == 
0:                ContainerHandle.INVALID_PAGE_NUMBER); 
0:     }
0: 
0: 
0: 	/**
0: 	 ** Perform a search of this leaf page, ultimately returning the latched
0: 	 ** leaf page and row slot after which the given key belongs.
0: 	 ** The slot is returned in the result structure.  If the key
0: 	 ** exists on the page, the result.exact will be true.  Otherwise,
0: 	 ** result.exact will be false, and the row slot returned will be
0: 	 ** the one immediately preceding the position at which the key
0: 	 ** belongs.
0:      *
0:      * @exception StandardException Standard exception policy.
0: 	 **/
0: 	public ControlRow search(
0:         SearchParameters    sp)
0:             throws StandardException
0:     {
0:         searchForEntry(sp);
0: 
0:         if (sp.searchForOptimizer)
0:         {
0:             // Update left_fraction to be used to estimate the number of
0:             // rows left of the current search location.
0: 
0:             // after the code below startslot will be the slot that is one
0:             // before the first slot to be returned by the scan positioning
0:             // for this key, including GT/GE positioning.  This is exactly
0:             // what the LeafControlRow.positionAtStartForForwardScan() does,
0:             // to position for the start of a scan.
0: 
0:             int startslot = sp.resultSlot;
0: 
0:             if (sp.resultExact)
0:             {
0:                 // we found exactly the row we are looking for.
0: 
0:                 if (SanityManager.DEBUG)
0:                     SanityManager.ASSERT(sp.resultSlot > 0);
0: 
0:                 // RESOLVE (mikem) - add in a search operator argument so that 
0:                 //     below can be if (op == ScanController.GE)
0: 
0:                 if (sp.partial_key_match_op == 
0:                         SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH)
0:                 {
0:                     // This means the scan was positioned for GE rather than GT
0:                     startslot--;
0:                 }
0:             }
0: 
0:             // non_deleted_left_row is the number of actual rows left of the 
0:             // first row to be returned by a scan positioned as requested.  
0:             // The 0th slot is a control row which is not counted.
0:             float non_deleted_left_rows = get_left_nondeleted_rowcnt(startslot);
0: 
0:             int   non_deleted_row_count = this.page.nonDeletedRecordCount();
0: 
0:             // System.out.println(
0:             //   "\n\t non_deleted_row_count = " + non_deleted_row_count +
0:             // "\n\t non_deleted_left_rows = " + non_deleted_left_rows +
0:             // "\n\t startslot = " + startslot);
0: 
0:             if (this.getIsRoot())
0:             {
0:                 sp.current_fraction = 1;
0:                 sp.left_fraction    = 0;
0:             }
0: 
0:             // calculate the fraction of rows in the table which are left of
0:             // the current slot in the search.  After the search is completed
0:             // (sp.left_fraction * number of rows), is the estimated number
0:             // of rows to the left of the current row.
0: 
0:             if (non_deleted_row_count > 1)
0:                 sp.left_fraction    += 
0:                     (sp.current_fraction) * 
0:                     (non_deleted_left_rows / (non_deleted_row_count - 1));
0: 
0:             // no-one really uses current fraction after leaf is through with
0:             // it.  Set it to help diagnose algorithm.
0:             if (non_deleted_row_count > 1)
0:                 sp.current_fraction = 
0:                     (sp.current_fraction) * 
0:                     (((float) 1) / (non_deleted_row_count - 1));
0:         }
0: 
0:         return(this);
0:     }
0: 	
0:     /**
0:      * Search and return the left most leaf page.
0:      * <p>
0: 	 * Perform a recursive search, ultimately returning the
0:      * leftmost leaf page which is the first leaf page in the
0: 	 * leaf sibling chain.  (This method might better be called
0: 	 * getFirstLeafPage()).
0:      *
0: 	 * @return The leftmost leaf page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow searchLeft(OpenBTree btree)
0:         throws StandardException
0:     {
0:         return(this);
0:     }
0: 
0:     /**
0:      * Search and return the right most leaf page.
0:      * <p>
0: 	 * Perform a recursive search, ultimately returning the
0: 	 * rightmost leaf page which is the last leaf page in the
0: 	 * leaf sibling chain.  (This method might better be called
0: 	 * getLastLeafPage()).
0:      *
0: 	 * @return The rightmost leaf page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow searchRight(OpenBTree btree)
0:         throws StandardException
0:     {
0:         return(this);
0:     }
0: 
0: 
0: 	/**
0: 	 **	Perform a recursive shrink operation for the key.
0: 	 ** If this method returns true, the caller should
0: 	 ** remove the corresponding entry for the page.
0: 	 ** This routine is not guaranteed to successfully
0: 	 ** shrink anything.  The page lead to by the key might
0: 	 ** turn out not to be empty by the time shrink gets
0: 	 ** there, and shrinks will give up if there is a deadlock.
0: 	 ** <P>
0: 	 ** The receiver page must be latched on entry and is
0: 	 ** returned unlatched.
0:      *
0:      * @exception StandardException Standard exception policy.
0: 	 **/
0: 	protected boolean shrinkFor(
0:     OpenBTree               btree, 
0:     DataValueDescriptor[]   key)
0:         throws StandardException
0:     {
0:         boolean shrink_me = false;
0: 
0:         try
0:         {
0:             // If this page is empty (ie. only has a control row), and it's not 
0:             // the root page, unlink it.  An empty btree consists of
0:             // simply an empty leaf-root page.
0: 
0:             // RESOLVE (mikem) - may want this routine to try to purge 
0:             // committed delete rows here?
0:             
0:             if ((this.page.recordCount() == 1) && !getIsRoot())
0:             {
0:                  // See if we can unlink this page (might not be able to because
0:                  // unlinking can cause deadlocks).  A successful unlink 
0:                  // unlatches the page.
0:                  shrink_me = unlink(btree);
0:             }
0:         }
0:         finally
0:         {
0:             if (!shrink_me)
0:                 this.release();
0:         }
0: 
0: 		return(shrink_me);
0:     }
0: 
0: 
0:     /**
0:      * Perform a top down split pass making room for the the key in "row".
0:      * <p>
0:      * Perform a split such that a subsequent call to insert
0: 	 * given the argument index row will likely find room for it.  Since 
0:      * latches are released the client must code for the case where another
0:      * user has grabbed the space made available by the split pass and be
0:      * ready to do another split.
0:      * <p>
0:      * On entry, the parent is either null or latched, and the
0:      * current page is latched.  On exit, all pages will have been
0:      * unlatched.  If the parent is null, then this page is a root
0:      * leaf page.
0:      *
0: 	 * @return page number of the newly allocated leaf page created by split.
0:      *
0:      * @param btree      The open btree to associate latches with.
0:      * @param template   A scratch area to use while searching for split pass.
0:      * @param parentpage The parent page of the current page in the split pass.
0:      *                   starts at null for root.
0:      * @param row        The key to make room for during the split pass.
0:      * @param flag       A flag used to direct where point of split should be
0:      *                   chosen.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected long splitFor(
0:     OpenBTree               open_btree, 
0:     DataValueDescriptor[]   template,
0:     BranchControlRow        parent_page, 
0:     DataValueDescriptor[]	splitrow,
0:     int                     flag)
0:         throws StandardException
0:     {
0:         long current_leaf_pageno = this.page.getPageNumber();
0: 
0:         if (SanityManager.DEBUG)
0:         {
0: 			if (parent_page == null && ( ! this.getIsRoot()))
0:             	SanityManager.THROWASSERT(
0:                 	this + " splitFor null parent and non-root");
0:         }
0: 
0:         // See if this page has space.
0:         if ((this.page.recordCount() - 1 < 
0:                 open_btree.getConglomerate().maxRowsPerPage) &&
0:             (this.page.spaceForInsert(splitrow, (FormatableBitSet) null,
0: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD)))
0:         {
0:             // The splitFor() operation is complete, commit the work done
0:             // before releasing the latches.
0:             open_btree.getXactMgr().commit();
0:              
0:             if (parent_page != null)
0:                  parent_page.release();
0: 
0:             this.release();
0: 
0:             return(current_leaf_pageno);
0:         }
0: 
0:         // RESOLVE (mikem) - for rows bigger than pages this assert may 
0:         // trigger until we have long rows.
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(this.page.recordCount() > 1);
0: 
0:         // Track.LeafSplit++;
0: 
0:         if (this.getIsRoot())
0:         {
0:             // Track.LeafSplitRoot++;
0: 
0:             growRoot(open_btree, template, this);
0: 
0:          
0:             // At this point, this page has been unlatched.  So code below this
0:             // point must not access this object's fields.
0:             
0:             ControlRow new_root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
0: 
0:             return(
0:                 new_root.splitFor(open_btree, template, null, splitrow, flag));
0:         }
0: 
0:         // At this point we know that this page has to be split and
0:         // that it isn't a root page.
0: 
0:         int splitpoint = (this.page.recordCount() - 1) / 2 + 1;
0: 
0:         if ((flag & ControlRow.SPLIT_FLAG_FIRST_ON_PAGE) != 0)
0:         {
0:             // move all the row to the new page
0:             splitpoint = 1;
0:         }
0:         else if ((flag & ControlRow.SPLIT_FLAG_LAST_ON_PAGE) != 0)
0:         {
0:             // This is not optimal as we would rather move no rows to the
0:             // next page, but what should we use as a discriminator?
0:             splitpoint = this.page.recordCount() - 1;
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0: 			if (splitpoint <= 0)
0:             	SanityManager.THROWASSERT(this + " yikes! splitpoint of 0!");
0:         }
0: 
0:         // Save away current split point leaf row, and build a branch row
0:         // based on it.
0:         DataValueDescriptor[] split_leaf_row = 
0:             open_btree.getConglomerate().createTemplate();
0: 
0:         this.page.fetchFromSlot(
0:             (RecordHandle) null, splitpoint, split_leaf_row, 
0:             (FetchDescriptor) null, true); 
0: 
0:         // Create the branch row to insert onto the parent page.  For now
0:         // use a fake page number because we don't know the real page 
0:         // number until the allocate is done, but want to delay the 
0:         // allocate until we know the insert will succeed.
0:         BranchRow branchrow = BranchRow.createBranchRowFromOldLeafRow(
0:             split_leaf_row, BranchRow.DUMMY_PAGE_NUMBER);
0: 
0: 
0:         // At this point we have guaranteed there is space in the parent
0:         // page for splitrow, but it could be the case that the new
0:         // "branchrow" does not fit on the parent page.
0:         if (!parent_page.page.spaceForInsert(
0:                 branchrow.getRow(), (FormatableBitSet) null,
0: 				AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD))
0:         {
0:             // There is no room on the parent page to complete a split at
0:             // the current level, so restart the split at top with the 
0:             // branchrow that did not fit.  On return from this routine
0:             // there is no way to know the state of the tree, so the
0:             // current split pass recursion must end.
0:             return(
0:                 ((BranchControlRow) parent_page).restartSplitFor(
0:                     open_btree, template, parent_page, this, 
0:                     branchrow.getRow(), splitrow, flag));
0: 
0:         }
0:         // Before moving the rows on the page, while having the latch on the
0:         // page, notify btree scans that the rows on this page may be moving
0:         // onto another page.
0:         //
0:         // RESOLVE (mikem) - need to pass conlgomid.
0:         // RESOLVE (mikem) - some optimization later, we only need to notify
0:         // the scans which are positioned on moving rows.
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(open_btree.init_open_user_scans != null);
0: 
0:         open_btree.init_open_user_scans.saveScanPositions(
0:                 open_btree.getConglomerate(), this.page);
0: 
0:         // Get exclusive RECORD_ID_PROTECTION_HANDLE lock to make sure that
0:         // we wait for scans in other transactions to move off of this page
0:         // before we split.
0: 
0:         if (!open_btree.getLockingPolicy().lockScan(
0:                 this, parent_page, true /* for update */, 
0:                 ConglomerateController.LOCK_UPD))
0:         {
0:             // we had to give up latches on this and parent_page to get the
0:             // split lock.  Redo the whole split pass as we have lost our
0:             // latches.  Just returning is ok, as the caller can not assume
0:             // that split has succeeded in making space.  Note that at this
0:             // point in the split no write work has been done in the current
0:             // internal transaction, so giving up here is fairly cheap.
0: 
0:             // RESOLVE RLL PERFORMANCE - we could keep a stack of visited
0:             // pages so as to not have to redo the complete search.
0:             return(current_leaf_pageno);
0:         }
0: 
0:         // Create a new leaf page under the parent.
0:         LeafControlRow newleaf = 
0:             LeafControlRow.Allocate(open_btree, parent_page);
0: 
0:         // Now that we know the page number of the new child page update
0:         // the branch row to be inserted with the correct value.
0:         branchrow.setPageNumber(newleaf.page.getPageNumber());
0: 
0:         // Test fail after allocation
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_abort1"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Link it to the right of the current page.
0:         newleaf.linkRight(open_btree, this);
0: 
0: 
0: 		// Copy the index rows (from the splitpoint to the end of the page) 
0:         // from the old page to the new leaf, do not
0:         // copy the control row.  This routine will purge all the copied rows
0:         // and maintain the deleted status of the moved rows.
0:         int num_rows_to_move = this.page.recordCount() - splitpoint;
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(num_rows_to_move >= 0);
0: 
0:         if (num_rows_to_move != 0)
0:         {
0:             this.page.copyAndPurge(
0:                 newleaf.page, splitpoint, num_rows_to_move, 1);
0:         }
0: 
0:         // Test fail after new page has been updated.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_abort2"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Test fail after new page has been updated.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_abort3"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Find spot to insert branch row, and insert it.
0: 
0: 
0:         BranchRow branch_template = 
0:             BranchRow.createEmptyTemplate(open_btree.getConglomerate());
0:         SearchParameters sp = 
0:             new SearchParameters(
0:                 branchrow.getRow(),
0:                 SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
0:                 branch_template.getRow(),
0:                 open_btree, false);
0: 
0:         parent_page.searchForEntry(sp);
0: 
0:         // There must be space on the parent to insert the row!
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 parent_page.page.spaceForInsert(
0:                     branchrow.getRow(), (FormatableBitSet) null,
0: 					AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD));
0:         }
0: 
0: 		byte insertFlag = Page.INSERT_INITIAL;
0: 		insertFlag |= Page.INSERT_DEFAULT;
0: 		insertFlag |= Page.INSERT_UNDO_WITH_PURGE;
0:         if (parent_page.page.insertAtSlot(
0:             sp.resultSlot + 1,
0:             branchrow.getRow(),
0:             (FormatableBitSet) null,
0: 			(LogicalUndo)null, 
0:             insertFlag,
0: 			AccessFactoryGlobals.BTREE_OVERFLOW_THRESHOLD) == null) {
0: 
0:             throw StandardException.newException(
0:                     SQLState.BTREE_NO_SPACE_FOR_KEY);
0: 		}
0: 
0:         // branchrow is only valid while split_leaf_row remains unchanged.
0:         branchrow = null;
0: 
0:         // RESOLVE (mikem) - this case breaks the btree currently - as the
0:         // abort of the insert leaves a logical delete in the tree.
0:         //
0:         // Test fail after parent page has been updated.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_abort4"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 this.checkConsistency(open_btree, parent_page, false);
0:                 newleaf.checkConsistency(open_btree, parent_page, false);
0:                 parent_page.checkConsistency(open_btree, null, false);
0:             }
0:         }
0: 
0:         // At this point a unit of work in the split down the tree has
0:         // been performed in an internal transaction.  This work must
0:         // be committed before any latches are released.
0:         open_btree.getXactMgr().commit();
0: 
0:         parent_page.release();
0:         this.release();  // XXX (nat) Not good form to unlatch self.
0: 
0:         long new_leaf_pageno = newleaf.page.getPageNumber();
0:         newleaf.release();
0: 
0:         // Because we are at the leaf level and have completed the split
0:         // there is no more work, no latches should be held, and control
0:         // is returned up the recursive stack, to the insert causing the
0:         // split.  Because latches are released, the inserter must recheck
0:         // that there is now space available as some other thread of control
0:         // could get in before he latches the page again.
0:         return(new_leaf_pageno);
0:     }
0: 
0: 	/**
0: 	 ** Grow a new root page from a leaf page.  Slightly
0: 	 ** tricky because we want to retain page 0 as the root.
0: 	 ** <P>
0: 	 ** On entry, the current leaf root page is expected 
0: 	 ** to be latched.  On exit, all latches will have been
0: 	 ** released.
0:      ** <P>
0:      ** The caller cannot not assume success.  If we have to release latches
0:      ** this routine just returns and assumes the caller will retry the 
0:      ** grow root if necessary.
0: 	 **/
0: 	private static void growRoot(
0:     OpenBTree               open_btree, 
0:     DataValueDescriptor[]   template, 
0:     LeafControlRow          leafroot)
0:         throws StandardException
0: 	{
0: 		BranchControlRow branchroot =  null;
0: 		LeafControlRow   newleaf    =  null; 
0: 
0: 
0:         // Before moving the rows on the page, while having the latch on the
0:         // page, notify btree scans that the rows on this page may be moving
0:         // onto another page.
0:         //
0:         open_btree.init_open_user_scans.saveScanPositions(
0:                 open_btree.getConglomerate(), leafroot.page);
0: 
0:         // Get exclusive RECORD_ID_PROTECTION_HANDLE lock to make sure that
0:         // we wait for scans in other transactions to move off of this page
0:         // before we grow root.  If we don't wait, scanners in other 
0:         // transactions may be positioned on the leaf page which we are 
0:         // about to make into a branch page.
0: 
0:         if (!open_btree.getLockingPolicy().lockScan(
0:                 leafroot, (ControlRow) null, 
0:                 true /* for update */,
0:                 ConglomerateController.LOCK_UPD))
0:         {
0:             // We had to give up latches on leafroot to get the
0:             // split lock.  Redo the whole split pass as we have lost our
0:             // latches - which may mean that the root has grown when we gave
0:             // up the latch.  Just returning is ok, as the caller can not assume
0:             // that grow root has succeeded in making space.  Note that at this
0:             // point in the split no write work has been done in the current
0:             // internal transaction, so giving up here is fairly cheap.
0: 
0:             return;
0:         }
0: 
0:         // Allocate a new leaf page under the existing leaf root.
0: 
0:         newleaf = LeafControlRow.Allocate(open_btree, leafroot);
0: 
0:         // Test fail after allocation
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_growRoot1"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Copy all the index rows from the root to the new leaf, do not
0:         // copy the control row.  This routine will purge all the copied 
0:         // rows and maintain the deleted status of the moved rows.
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT((leafroot.page.recordCount() - 1) > 0);
0:         leafroot.page.copyAndPurge(
0:             newleaf.page, 1, leafroot.page.recordCount() - 1, 1);
0: 
0:         // Test fail after row copy
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_growRoot2"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Test fail after purge 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_growRoot3"))
0:             {
0:                 // Make sure tree is very trashed and logical recovery will
0:                 // not work.
0:                 leafroot.setLevel(42);
0:                 leafroot.setParent(42);
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // Put a branch control row on the root page, making the new leaf 
0:         // the left child.  All leaf splits result in level-1 branch pages.
0:         // This will be a branch-root page.
0: 
0:         // Construction of the BranchControlRow will set it as the aux 
0:         // object for the page, this in turn invalidates the previous aux 
0:         // object which is leafroot. Thus leafroot must not be used once 
0:         // the constructor returns.
0: 
0:         branchroot = new BranchControlRow(
0:             open_btree, leafroot.page, 1, null, true, 
0:             newleaf.page.getPageNumber());
0:         leafroot = null;
0: 
0:         // Replace the old leaf root control row with the new branch root 
0:         // control row.
0:         branchroot.page.updateAtSlot(
0:             0, branchroot.getRow(), (FormatableBitSet) null);
0: 
0:         // Test fail after purge 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_growRoot4"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("enableBtreeConsistencyCheck"))
0:             {
0:                 newleaf.checkConsistency(open_btree, branchroot, false);
0:                 branchroot.checkConsistency(open_btree, null, false);
0:             }
0:         }
0:         
0:         // At this point a unit of work in the split down the tree has
0:         // been performed in an internal transaction.  This work must
0:         // be committed before any latches are released.
0:         open_btree.getXactMgr().commit();
0: 
0:         // Test fail after commit of split
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("leaf_split_growRoot5"))
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_ABORT_THROUGH_TRACE);
0:             }
0:         }
0: 
0:         // The variable 'branchroot' refers to a page that was latched by 
0:         // leafroot.  After a growRoot() from a leaf there will be no pages 
0:         // latched.  It is up to the callers to reget the root page latched 
0:         // and continue their work.
0:         //
0:         if (branchroot != null)
0:             branchroot.release();
0:         if (leafroot != null)
0:             leafroot.release();
0:         if (newleaf != null)
0:             newleaf.release();
0: 	}
0: 	
0:     /**
0:      * Return the left child pointer for the page.
0:      * <p>
0:      * Leaf pages don't have children, so they override this and return null.
0:      *
0: 	 * @return The page which is the leftmost child of this page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow getLeftChild(OpenBTree btree)
0:         throws StandardException
0:     {
0:         return(null);
0:     }
0: 
0:     /**
0:      * Return the right child pointer for the page.
0:      * <p>
0:      * Leaf pages don't have children, so they override this and return null.
0:      *
0: 	 * @return The page which is the rightmost child of this page.
0:      *
0:      * @param btree  The open btree to associate latches/locks with.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected ControlRow getRightChild(OpenBTree btree)
0:         throws StandardException
0:     {
0:         return(null);
0:     }
0: 
0: 	/*
0: 	** Debug/consistency check Methods of ControlRow:
0: 	*/
0: 
0: 	/**
0: 	 ** Perform consistency checks on a leaf page.
0:      ** 
0: 	 ** Check consistency of the page and its children,
0: 	 ** returning the number of pages seen, and throwing
0: 	 ** errors if inconsistencies are found.
0:      ** The checks specific to a leaf page are:
0: 	 ** <menu>
0: 	 ** <li> Page is at level 0.
0: 	 ** <li> Version is a valid leaf page version.
0: 	 ** <li> Control row has right number of columns for leaf.
0: 	 ** </menu>
0: 	 ** This method also performs the consistency checks that
0: 	 ** are common to both leaf and branch pages.
0:      ** @see ControlRow#checkGeneric
0:      **
0:      ** @exception StandardException Standard exception policy.
0: 	 **/  
0: 	public int checkConsistency(
0:     OpenBTree  btree, 
0:     ControlRow parent,
0:     boolean    check_other_pages
0:     )
0:         throws StandardException
0: 	{
0: 		// Do the consistency checks that are common to all
0: 		// types of pages.
0: 		checkGeneric(btree, parent, check_other_pages);
0: 
0:         // Leaf specific, control row checks
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(this.getLevel() == 0, "leaf not at level 0");
0: 
0:             // RESOLVE (mikem) - how to sanity check correct version?
0:             /*
0: 			if (this.getVersion() != CURRENT_LEAF_VERSION)
0:             	SanityManager.THROWASSERT(
0:                 	"Expected leaf version:(" + 
0:                 	CURRENT_LEAF_VERSION + ") but got (" +
0:                 	this.getVersion());
0:             */
0:             SanityManager.ASSERT(
0:                 this.page.fetchNumFieldsAtSlot(CR_SLOT) == 
0:                 ControlRow.CR_NCOLUMNS);
0: 
0:             // The remaining checks are specific to leaf pages.
0: 
0:             // Check that every row has at least as many columns
0:             // as the number of key fields in the b-tree.
0:             int numslots = this.page.recordCount();
0:             for (int slot = 1; slot < numslots; slot++)
0:             {
0: 				if (this.page.fetchNumFieldsAtSlot(slot) <
0:                      btree.getConglomerate().nKeyFields)
0:                 	SanityManager.THROWASSERT(
0:                     	"row[" + slot + "]"
0:                         	+ " has " + this.page.fetchNumFieldsAtSlot(slot)
0:                         	+ " columns, should have at least" + 
0:                         	btree.getConglomerate().nKeyFields);
0:                 
0:                 // RESOLVE - the generic btree code should know nothing about
0:                 // the secondaryindex row location column, but put this here for
0:                 // now because I can't figure how to get a call out to the
0:                 // secondary index code at the page level consistency checking
0:                 // level.
0:             }
0: 
0:         }
0: 
0: 		// We checked one page (this one).
0: 		return 1;
0: 	}
0: 
0: 	/**
0: 	 ** Recursively print the tree starting at current node in tree.
0:      ** This is a leaf so return.
0: 
0:     @exception StandardException Standard exception policy.
0: 	 **/
0: 	public void printTree(
0:     OpenBTree  btree) 
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.DEBUG_PRINT("p_tree", this.debugPage(btree));
0: 
0:             return;
0:         }
0:     }
0: 
0: 
0: 	/*
0: 	 * Methods of TypedFormat:
0: 	 */
0: 
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() 
0:     {
0: 		return StoredFormatIds.ACCESS_BTREE_LEAFCONTROLROW_V1_ID;
0: 	}
0: }
============================================================================