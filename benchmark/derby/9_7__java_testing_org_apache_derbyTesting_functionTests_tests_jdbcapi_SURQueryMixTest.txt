1:bc50840: /*
2:bc50840:  *
1:bc50840:  * Derby - Class SURQueryMixTest
1:bc50840:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:bc50840:  *
1:bc50840:  *    http://www.apache.org/licenses/LICENSE-2.0
1:bc50840:  *
1:bc50840:  * Unless required by applicable law or agreed to in writing,
1:bc50840:  * software distributed under the License is distributed on an
1:bc50840:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:bc50840:  * either express or implied. See the License for the specific
1:bc50840:  * language governing permissions and limitations under the License.
1:bc50840:  */
1:bc50840: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:bc50840: import java.sql.DatabaseMetaData;
1:1ae02c9: import java.sql.PreparedStatement;
1:bc50840: import java.sql.ResultSet;
1:bc50840: import java.sql.ResultSetMetaData;
1:bc50840: import java.sql.SQLException;
1:bc50840: import java.sql.Statement;
1:bc50840: import java.sql.Types;
1:bc50840: import java.util.ArrayList;
1:bc50840: import java.util.HashMap;
1:bc50840: import java.util.HashSet;
1:bc50840: import java.util.Iterator;
1:bc50840: import java.util.List;
1:bc50840: import java.util.Map;
1:bc50840: import java.util.Random;
1:bc50840: import java.util.Set;
1:bc50840: import junit.extensions.TestSetup;
1:bc50840: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:16c6f35: 
1:bc50840: /**
1:bc50840:  * Tests for Scrollable Updatable ResultSet (SUR). This TestCase tests
1:bc50840:  * scrolling (navigation), updates (using updateXXX() and updateRow() or
1:bc50840:  * positioned updates), deletion of records (using deleteRow() or positioned 
1:bc50840:  * deletes) of ResultSets.
1:bc50840:  */
1:bc50840: public class SURQueryMixTest extends SURBaseTest
1:bc50840: {
1:bc50840:     /**
1:bc50840:      * Constructor
1:df4020d:      * @param model name of data model for this TestCase
1:bc50840:      * @param query to use for producing the resultset
1:bc50840:      * @param cursorName name of cursor
1:bc50840:      * @param positioned flag to determine if the Test should use positioned
1:bc50840:      *        updates/deletes instead of updateRow() and deleteRow()
1:bc50840:      */
1:bc50840:     public SURQueryMixTest(final String model, final String query, 
1:bc50840:                            final String cursorName, final boolean positioned) 
1:bc50840:     {
1:bc50840:         super("SURQueryMixTest{Model=" + model + ",Query=" +query + ",Cursor=" 
1:bc50840:                 + cursorName + ",Positioned=" + positioned + "}");
1:bc50840:         this.query = query;
1:bc50840:         this.cursorName = cursorName;
1:bc50840:         this.positioned = positioned;
1:bc50840:         this.checkRowUpdated = false;
1:bc50840:         this.checkRowDeleted = false;
1:16c6f35:     }
1:16c6f35: 
1:bc50840:     /**
1:bc50840:      * Test SUR properties of the query
1:bc50840:      */
1:bc50840:     public void runTest() 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         println(query);
1:03a99e2:         DatabaseMetaData dbMeta = getConnection().getMetaData();
1:d038483:                 
1:bc50840:         if (dbMeta.ownDeletesAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE)) {
1:bc50840:             checkRowDeleted = true;
2:bc50840:         }
1:d038483:         
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
9:bc50840:         
1:bc50840:         s.setCursorName(cursorName);
1:bc50840:         ResultSet rs = s.executeQuery(query);
1:bc50840: 
1:bc50840:         checkRowUpdated = dbMeta.ownUpdatesAreVisible(rs.getType());        
1:bc50840:         checkRowDeleted = dbMeta.ownDeletesAreVisible(rs.getType());
1:bc50840:         
1:bc50840:         // Create map with rows
1:e18f54b:         Map<Integer, String> rows = createRowMap(rs);
1:bc50840:         
1:bc50840:         // Set of rows which are updated (contains Integer with position in RS)
1:e18f54b:         final Set<Integer> updatedRows = new HashSet<Integer>();
1:bc50840:         
1:bc50840:         // Set of rows which are deleted (contains Integer with position in RS)
1:e18f54b:         final Set<Integer> deletedRows = new HashSet<Integer>();
1:bc50840:                 
1:bc50840:         // Test navigation
1:bc50840:         testNavigation(rs, rows, updatedRows, deletedRows);
1:bc50840:         
1:bc50840:         // Only test updatability if the ResultSet is updatable:
1:bc50840:         // (Note: this enables the test do run successfully even if
1:bc50840:         // scrollable updatable resultsets are not implemented. 
1:bc50840:         // If SUR is not implemented, a well behaved JDBC driver will 
1:bc50840:         // downgrade the concurrency mode to READ_ONLY).
1:bc50840:         // SUR may be implemented incrementally, i.e first in embedded mode
1:bc50840:         // then in the network driver.)
1:bc50840:         if (rs.getConcurrency()==ResultSet.CONCUR_UPDATABLE) {
1:bc50840:         
1:bc50840:             // update a random sample of 2 records
1:bc50840:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 2); 
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:             
1:bc50840:             // update a random sample of 5 records
1:bc50840:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 5); 
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:             
1:bc50840:             // update a random sample of 10 records
1:bc50840:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 10); 
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:             
1:bc50840:             // delete a random sample of 2 records
1:bc50840:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 2);
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:             
1:bc50840:             // delete a random sample of 5 records
1:bc50840:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 5);
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:             
1:bc50840:             // delete a random sample of 10 records
1:bc50840:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 10);
1:bc50840:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:bc50840:         } else {
1:c247315:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
1:c247315:                        false);
1:bc50840:         }
1:bc50840:         
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Creates a Map of the values in the ResultSet. 
1:bc50840:      * The key object in the map, is the postion in the 
1:bc50840:      * ResultSet (Integer 1..n), while the value is a
1:bc50840:      * concatenation of the strings for all columns in the row.
1:bc50840:      */
1:e18f54b:     private Map<Integer, String> createRowMap(final ResultSet rs)
1:bc50840:         throws SQLException
1:bc50840:     {
1:e18f54b:         final Map<Integer, String> rows = new HashMap<Integer, String>();
1:bc50840:         rs.beforeFirst();
1:bc50840:         assertTrue("Unexpected return from isBeforeFirst()",
1:bc50840:                    rs.isBeforeFirst());
1:bc50840:         
1:bc50840:         int i = 0;
1:bc50840:         int sum = 0;
1:bc50840:         int expectedSum = 0;
1:bc50840:         boolean checkSum = true;
1:bc50840:         while (rs.next()) {
1:bc50840:             expectedSum += i;
1:bc50840:             i++;
1:bc50840:             String row = getRowString(rs);
1:bc50840:             println(row);
1:e18f54b:             rows.put(i, row);
1:bc50840:             sum += rs.getInt(1);
1:bc50840:             if (rs.getInt(1) < 0) {
1:bc50840:                 checkSum = false;
1:bc50840:             }
1:bc50840:         }
1:bc50840:         if (i<SURDataModelSetup.recordCount) {
1:bc50840:             checkSum = false;
1:bc50840:         }
1:bc50840:         
1:bc50840:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:bc50840:         
1:bc50840:         if (checkSum) {
1:bc50840:             assertEquals("Sum for column 1 is not correct", expectedSum, sum);
1:bc50840:         }
1:bc50840:         
1:bc50840:         return rows;
1:bc50840:     }
1:bc50840: 
1:bc50840:     /**
1:bc50840:      * Create a random sample of rows
1:bc50840:      * @param rows Map to create sample from
1:bc50840:      * @param k number of rows in the sample
1:bc50840:      * @return a list containing k elements of rows
1:bc50840:      **/
1:e18f54b:     private List createRandomSample(final Map<Integer, String> rows, int k) {
1:bc50840:         Random r = new Random();
1:e18f54b:         ArrayList<Integer> sampledKeys = new ArrayList<Integer>();
1:bc50840:         int n = 0;        
1:e18f54b:         for (Integer key : rows.keySet()) {
1:bc50840:             n++;            
1:bc50840:             if (n<=k) {
1:bc50840:                 sampledKeys.add(key);
1:bc50840:             } else {
1:bc50840:                 // sampledKeys now has a size of k
1:bc50840:                 double d = r.nextDouble();
1:bc50840:                 // p = probability of going into the sample
1:bc50840:                 double p = (double) k / (double) n; 
1:bc50840:                 if (d<p) {
1:bc50840:                     // Replace a random value from the sample with the new value
1:de89be1:                     int keyToReplace = r.nextInt(k);
1:bc50840:                     sampledKeys.set(keyToReplace, key);
1:bc50840:                 }
1:bc50840:             }
1:bc50840:         }
1:bc50840:         return sampledKeys;
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Delete a random sample of n records in the resultset
1:bc50840:      * @param rs result set to be updated
1:bc50840:      * @param rows map of rows, will also be updated
1:bc50840:      * @param deletedRows set of rows being deleted (position in RS)
1:bc50840:      * @param k number of records to be deleted
1:bc50840:      */
1:bc50840:     private void deleteRandomSampleOfNRecords(final ResultSet rs, 
1:e18f54b:                                               final Map<Integer, String> rows,
1:e18f54b:                                               final Set<Integer> deletedRows,
1:bc50840:                                               final int k) 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         List sampledKeys = createRandomSample(rows, k);
1:bc50840:         println("Sampled keys:" + sampledKeys);
1:bc50840:         ResultSetMetaData meta = rs.getMetaData();
1:bc50840:         for (Iterator i = sampledKeys.iterator(); i.hasNext();) {
1:bc50840:             Integer key = (Integer) i.next();
1:bc50840:             rs.absolute(key.intValue());            
1:bc50840:             if (rs.rowDeleted()) continue; // skip deleting row if already deleted
1:bc50840:             if (positioned) {
1:ff65830:                 createStatement().executeUpdate
1:bc50840:                         ("DELETE FROM T1 WHERE CURRENT OF \"" + cursorName + 
1:bc50840:                          "\"");
1:bc50840:             } else {
1:bc50840:                 rs.deleteRow();
1:bc50840:             }
1:2700e3d:             rs.relative(0);
1:bc50840:             println("Deleted row " + key);
1:bc50840:             // Update the rows table
1:bc50840:             rows.put(key, getRowString(rs));
1:bc50840:             
1:bc50840:             // Update the updatedRows set
1:bc50840:             deletedRows.add(key);
1:bc50840:         }
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Update a random sample of n records in the resultset
1:bc50840:      * @param rs result set to be updated
1:bc50840:      * @param rows map of rows, will also be updated
1:bc50840:      * @param updatedRows set of being updated (position in RS)
1:bc50840:      * @param k number of records to be updated
1:bc50840:      */
1:bc50840:     private void updateRandomSampleOfNRecords(final ResultSet rs, 
1:e18f54b:                                               final Map<Integer, String> rows,
1:e18f54b:                                               final Set<Integer> updatedRows,
1:bc50840:                                               final int k) 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         List sampledKeys = createRandomSample(rows, k);
1:bc50840:         println("Sampled keys:" + sampledKeys);
1:bc50840:         ResultSetMetaData meta = rs.getMetaData();
1:bc50840:         for (Iterator i = sampledKeys.iterator(); i.hasNext();) {
1:bc50840:             Integer key = (Integer) i.next();
1:bc50840:             rs.absolute(key.intValue());            
1:bc50840:             
1:bc50840:             if (positioned) {
1:bc50840:                 updatePositioned(rs, meta);
2:bc50840:                 rs.relative(0); // If this call is not here, the old values are
2:bc50840:                                 // returned in rs.getXXX calls
1:bc50840:             } else {
1:bc50840:                 updateRow(rs, meta);
1:bc50840:             }
1:bc50840:             // Update the rows table
1:bc50840:             rows.put(key, getRowString(rs));
1:bc50840:             
1:bc50840:             // Update the updatedRows set
1:bc50840:             updatedRows.add(key);
1:bc50840:         }
1:bc50840:     }
1:bc50840: 
1:bc50840:     /**
1:bc50840:      * Updates the current row in the ResultSet using updateRow()
1:bc50840:      * @param rs ResultSet to be updated
1:bc50840:      * @param meta meta for the ResultSet
1:bc50840:      **/
1:bc50840:     private void updateRow(final ResultSet rs, final ResultSetMetaData meta) 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:bc50840:             if (meta.getColumnType(column)==Types.INTEGER) {
1:bc50840:                 // Set to negative value
1:bc50840:                 rs.updateInt(column, -rs.getInt(column));
1:bc50840:             } else {
1:bc50840:                 rs.updateString(column, "UPDATED_" + rs.getString(column));
1:bc50840:             }
1:bc50840:         }
1:bc50840:         rs.updateRow();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Updates the current row in the ResultSet using updateRow()
1:bc50840:      * @param rs ResultSet to be updated
1:bc50840:      * @param meta meta for the ResultSet
1:bc50840:      **/
1:bc50840:     private void updatePositioned(final ResultSet rs, 
1:bc50840:                                   final ResultSetMetaData meta) 
1:bc50840:         throws SQLException                          
1:bc50840:     {
1:bc50840:         StringBuffer sb = new StringBuffer();
1:bc50840:         sb.append("UPDATE T1 SET ");
1:bc50840:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:bc50840:             sb.append(meta.getColumnName(column));
1:bc50840:             sb.append("=?");
1:bc50840:             if (column<meta.getColumnCount()) {
1:bc50840:                 sb.append(",");
1:bc50840:             }
1:bc50840:         }
1:bc50840:         sb.append(" WHERE CURRENT OF \"");
1:bc50840:         sb.append(cursorName);
1:bc50840:         sb.append("\"");
1:bc50840:         println(sb.toString());
1:ff65830:         PreparedStatement ps = prepareStatement(sb.toString());
1:bc50840:         
1:bc50840:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:bc50840:            if (meta.getColumnType(column)==Types.INTEGER) {
1:bc50840:                 // Set to negative value
1:bc50840:                 ps.setInt(column, -rs.getInt(column));
1:bc50840:             } else {
1:bc50840:                 ps.setString(column, "UPDATED_" + rs.getString(column));
1:bc50840:             }
1:bc50840:         }
1:bc50840:         assertEquals("Expected one row to be updated", 1, ps.executeUpdate());        
1:bc50840:     }
1:bc50840:     
1:bc50840:     
1:bc50840:     /**
1:c247315:      * Tests navigation in ResultSet.
1:df4020d:      * @param rs ResultSet to test navigation of. 
1:c247315:      *                     Needs to be scrollable
1:df4020d:      * @param rows a sample of the rows which are in the ResultSet. Maps
1:c247315:      *                   position to a concatenation of the string values
1:df4020d:      * @param updatedRows a integer set of which rows that have been 
1:c247315:      *            updated. Used to test rowUpdated()
1:df4020d:      * @param deletedRows a integer set of which rows that have been
1:c247315:      *            deleted. Used to test rowDeleted()
1:bc50840:      */
1:bc50840:     private void testNavigation(final ResultSet rs, final Map rows, 
1:bc50840:                                 final Set updatedRows, final Set deletedRows) 
1:bc50840:         throws SQLException
1:bc50840:     {        
1:bc50840:         rs.afterLast();
1:bc50840:         {
1:bc50840:             int i = rows.size();
1:bc50840:             while (rs.previous()) {
1:bc50840:                 String rowString = getRowString(rs);
1:bc50840:                 assertEquals("Navigating with rs.previous(). The row is " +
1:bc50840:                              "different compared to the value when navigating " +
1:39b3237:                              "forward.", rows.get(i), rowString);
1:bc50840:                 
1:bc50840:                 
1:39b3237:                 if (checkRowUpdated && updatedRows.contains(i)) {
1:bc50840:                     assertTrue("Expected rs.rowUpdated() to return true on " + 
1:bc50840:                                "updated row " + rowString, rs.rowUpdated());
1:bc50840:                 } 
1:39b3237:                 if (checkRowDeleted && deletedRows.contains(i)) {
1:bc50840:                     assertTrue("Expected rs.rowDeleted() to return true on " + 
1:bc50840:                                "deleted row " + rowString, rs.rowDeleted());
1:bc50840:                 } 
1:bc50840:                 i--;
1:bc50840:             }
1:bc50840:         }
1:bc50840:         // Test absolute
1:bc50840:         for (int i = 1; i <= rows.size(); i++) {
1:bc50840:             assertTrue("Unexpected return from absolute()", rs.absolute(i));
1:bc50840:             String rowString = getRowString(rs);
1:bc50840:             assertEquals("Navigating with rs.absolute(). The row is " +
1:bc50840:                          "different compared to the value" +
1:bc50840:                          " when navigating forward.", 
1:39b3237:                          rows.get(i),
1:bc50840:                          rowString);
1:39b3237:             if (checkRowUpdated && updatedRows.contains(i)) {
1:bc50840:                 assertTrue("Expected rs.rowUpdated() to return true on " +
1:bc50840:                            "updated row " + rowString, rs.rowUpdated());
1:bc50840:             }
1:39b3237:             if (checkRowDeleted && deletedRows.contains(i)) {
1:bc50840:                 assertTrue("Expected rs.rowDeleted() to return true on " +
1:bc50840:                            "deleted row " + rowString, rs.rowDeleted());
1:bc50840:             }
1:bc50840:         }
1:bc50840:         assertFalse("Unexpected return from absolute()", rs.absolute(0));
1:bc50840:         assertTrue("Unexpected return from isBeforeFirst()", 
1:bc50840:                    rs.isBeforeFirst());
1:bc50840:         assertFalse("Unexpected return from absolute()", 
1:bc50840:                     rs.absolute(rows.size() + 1));
1:bc50840:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:bc50840:         assertTrue("Unexpected return from absolute()", rs.absolute(-1));
1:bc50840:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:bc50840:         assertTrue("Unexpected return from absolute()", rs.absolute(1));
1:bc50840:         assertTrue("Unexpected return from isFirst()", rs.isFirst());
1:bc50840:         
1:bc50840:         // Test relative
1:bc50840:         {
1:bc50840:             rs.beforeFirst();
1:bc50840:             assertTrue("Unexptected return from isBeforeFirst()", 
1:bc50840:                        rs.isBeforeFirst());
1:bc50840:             
1:bc50840:             int relativePos = rows.size();
1:bc50840:             assertTrue("Unexpected return from relative()", 
1:bc50840:                        rs.relative(relativePos)); 
1:bc50840:             
1:bc50840:             // Should now be on the last row
1:bc50840:             assertTrue("Unexptected return from isLast()", rs.isLast());
1:bc50840:             assertEquals("Navigating with rs.relative(+). " +
1:bc50840:                          "A tuple was different compared to the value" +
1:bc50840:                          " when navigating forward.", 
1:39b3237:                          rows.get(relativePos),
1:bc50840:                          getRowString(rs));
1:bc50840:             
1:bc50840:             assertTrue("Unexpected return from relative()", 
1:bc50840:                        rs.relative((-relativePos + 1))); 
1:bc50840:             
1:bc50840:             // Should now be on the first row
1:bc50840:             assertTrue("Unexptected return from isFirst()", rs.isFirst());
1:bc50840:             
1:bc50840:             assertEquals("Navigating with rs.relative(-). " + 
1:bc50840:                          "A tuple was different compared to the value" +
1:bc50840:                          " when navigating forward.", 
1:39b3237:                          rows.get(1),
1:bc50840:                          getRowString(rs));
1:bc50840:             
1:bc50840:         }
1:bc50840:         // Test navigation in the end of the ResultSet
1:bc50840:         rs.afterLast();
1:bc50840:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:bc50840:         assertTrue("Unexpected return from previous()", rs.previous());
1:bc50840:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:bc50840:         assertFalse("Unexpected return from next()", rs.next());
1:bc50840:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:bc50840:         rs.last();
1:bc50840:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:bc50840:         assertFalse("Unexpected return from next()", rs.next());
1:bc50840:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:bc50840: 
1:bc50840: 
1:bc50840:         // Test navigation in the beginning of the ResultSet
1:bc50840:         rs.beforeFirst();
1:bc50840:         assertTrue("Unexpected return from isBeforeFirst()", 
1:bc50840:                    rs.isBeforeFirst());
1:bc50840:         assertTrue("Unexpected return from next()", rs.next());
1:bc50840:         assertTrue("Unexpected return from isFirst", rs.isFirst());
1:bc50840:         assertFalse("Unexpected return from previous()", rs.previous());
1:bc50840:         assertTrue("Unexpected return from isBeforeFirst()", 
1:bc50840:                    rs.isBeforeFirst());
1:bc50840:         
1:bc50840:         rs.first();
1:bc50840:         assertTrue("Unexpected return from isFirst", rs.isFirst());
1:bc50840:         assertFalse("Unexpected return from previous()", rs.previous());
1:bc50840:         assertTrue("Unexpected return from isBeforeFirst()", 
1:bc50840:                    rs.isBeforeFirst());
1:bc50840:     }
1:bc50840: 
1:bc50840:     /**
1:bc50840:      * Get a concatenation of the values of the 
1:bc50840:      * current Row in the ResultSet
1:bc50840:      */
1:bc50840:     private String getRowString(final ResultSet rs) 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         int numberOfColumns = rs.getMetaData().getColumnCount();
1:bc50840:         StringBuffer sb = new StringBuffer();
1:bc50840:         if (rs.rowDeleted()) return "";
1:bc50840:         for (int i = 1; i <= numberOfColumns; i++) {
1:bc50840:             sb.append(rs.getString(i));
1:bc50840:             if (i < numberOfColumns) { 
1:bc50840:                 sb.append(','); 
1:bc50840:             }
1:bc50840:         }
1:bc50840:         return sb.toString();
1:bc50840:     }
1:bc50840:     
1:bc50840:     private final String query;
1:bc50840:     private final String cursorName;
1:bc50840:     private final boolean positioned;
1:bc50840:     private boolean checkRowUpdated;
1:bc50840:     private boolean checkRowDeleted;
1:bc50840:     
1:bc50840:     private final static String[] selectConditions = new String[] {
1:bc50840:         "WHERE c like 'T%'",
1:bc50840:         " ",        
1:bc50840:         "WHERE b > 5",
1:bc50840:         "WHERE id >= a",
1:bc50840:         "WHERE id > 1 and id < 900",
1:bc50840:         "WHERE id = 1",
1:bc50840:         "WHERE id in (1,3,4,600,900,955,966,977,978)",
1:bc50840:         "WHERE a in (1,3,4,600,9200,955,966,977,978)",
1:bc50840:         "WHERE a>2 and a<9000"
1:bc50840:     };
1:bc50840:     
1:bc50840:     private final static String[] projectConditions = new String[] {
1:bc50840:         "id,c,a,b",
1:bc50840:         "id,c",
1:bc50840:         "a,b",
1:bc50840:         "*",
1:bc50840:         "id,a,b,c",        
1:bc50840:         "id,a",           
1:bc50840:         "a,b,c",        
1:bc50840:         "a,c"
1:bc50840:     };
1:bc50840:     
1:1ae02c9:     private static BaseTestSuite createTestCases(final String modelName) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:bc50840:         for (int doPos = 0; doPos<2; doPos++) {
1:bc50840:             boolean positioned = doPos>0; // true if to use positioned updates
1:bc50840: 
1:bc50840:             for (int i = 0; i < selectConditions.length; i++) {
1:bc50840:                 for (int j = 0; j < projectConditions.length; j++) {
1:bc50840:                     final String cursorName = "cursor_" + i + "_" + j;
1:bc50840:                     
1:bc50840:                     final String stmtString = "SELECT " + projectConditions[j] +
1:bc50840:                             " FROM T1 " + selectConditions[i];
1:bc50840:                     suite.addTest(new SURQueryMixTest(modelName, stmtString, cursorName, 
1:bc50840:                                               positioned));
1:bc50840:                 }
1:bc50840:             }
1:bc50840:         }
1:bc50840:         return suite;
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:16c6f35:      * Run in client and embedded.
1:bc50840:      */
1:bc50840:     public static Test suite() 
1:bc50840:     {   
1:1ae02c9:         BaseTestSuite mainSuite = new BaseTestSuite("SURQueryMixTest suite");
1:bc50840:         
1:16c6f35:         mainSuite.addTest(baseSuite("SURQueryMixTest:embedded"));
1:16c6f35:         mainSuite.addTest(
1:16c6f35:                 TestConfiguration.clientServerDecorator(
1:16c6f35:                         baseSuite("SURQueryMixTest:client")));
1:16c6f35:         
1:16c6f35:         return mainSuite;
1:41c47be:         
1:41c47be:     }
1:16c6f35:   
1:16c6f35:     /**
1:16c6f35:      * The suite contains all testcases in this class running on different data models
1:16c6f35:      */
1:16c6f35:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite mainSuite = new BaseTestSuite(name);
1:16c6f35:       
1:bc50840:         // Iterate over all data models and decorate the tests:
1:bc50840:         for (Iterator i = SURDataModelSetup.SURDataModel.values().iterator();
1:bc50840:              i.hasNext();) {
1:16c6f35:             
1:bc50840:             SURDataModelSetup.SURDataModel model =
1:bc50840:                 (SURDataModelSetup.SURDataModel) i.next();
1:bc50840:             
1:1ae02c9:             BaseTestSuite suite = createTestCases(model.toString());
1:bc50840:             TestSetup decorator = new SURDataModelSetup(suite, model);
1:bc50840:             mainSuite.addTest(decorator);
1:bc50840:         }
1:d038483:         return mainSuite;
1:bc50840:     }
1:bc50840: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                              "forward.", rows.get(i), rowString);
1:                 if (checkRowUpdated && updatedRows.contains(i)) {
1:                 if (checkRowDeleted && deletedRows.contains(i)) {
/////////////////////////////////////////////////////////////////////////
1:                          rows.get(i),
1:             if (checkRowUpdated && updatedRows.contains(i)) {
1:             if (checkRowDeleted && deletedRows.contains(i)) {
/////////////////////////////////////////////////////////////////////////
1:                          rows.get(relativePos),
/////////////////////////////////////////////////////////////////////////
1:                          rows.get(1),
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     private static BaseTestSuite createTestCases(final String modelName) {
1:         BaseTestSuite suite = new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite = new BaseTestSuite("SURQueryMixTest suite");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = createTestCases(model.toString());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         Map<Integer, String> rows = createRowMap(rs);
1:         final Set<Integer> updatedRows = new HashSet<Integer>();
1:         final Set<Integer> deletedRows = new HashSet<Integer>();
/////////////////////////////////////////////////////////////////////////
1:     private Map<Integer, String> createRowMap(final ResultSet rs)
1:         final Map<Integer, String> rows = new HashMap<Integer, String>();
/////////////////////////////////////////////////////////////////////////
1:             rows.put(i, row);
/////////////////////////////////////////////////////////////////////////
1:     private List createRandomSample(final Map<Integer, String> rows, int k) {
1:         ArrayList<Integer> sampledKeys = new ArrayList<Integer>();
1:         for (Integer key : rows.keySet()) {
/////////////////////////////////////////////////////////////////////////
1:                                               final Map<Integer, String> rows,
1:                                               final Set<Integer> deletedRows,
/////////////////////////////////////////////////////////////////////////
1:                                               final Map<Integer, String> rows,
1:                                               final Set<Integer> updatedRows,
commit:de89be1
/////////////////////////////////////////////////////////////////////////
1:                     int keyToReplace = r.nextInt(k);
commit:41c47be
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         con = null;
1:     }
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1:             rs.relative(0);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client())
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      * @param model name of data model for this TestCase
/////////////////////////////////////////////////////////////////////////
1:      * @param rs ResultSet to test navigation of. 
1:      * @param rows a sample of the rows which are in the ResultSet. Maps
1:      * @param updatedRows a integer set of which rows that have been 
1:      * @param deletedRows a integer set of which rows that have been
/////////////////////////////////////////////////////////////////////////
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:16c6f35
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Run in client and embedded.
0:      * @return
/////////////////////////////////////////////////////////////////////////
1:         mainSuite.addTest(baseSuite("SURQueryMixTest:embedded"));
1:         mainSuite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         baseSuite("SURQueryMixTest:client")));
1:         
1:         return mainSuite;
1:         
1:     }
1:   
1:     /**
1:      * The suite contains all testcases in this class running on different data models
1:      */
1:     private static Test baseSuite(String name) {
0:         TestSuite mainSuite = new TestSuite(name);
1:       
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite mainSuite = new TestSuite("SURQueryMixTest suite");
commit:985662b
/////////////////////////////////////////////////////////////////////////
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:         DatabaseMetaData dbMeta = getConnection().getMetaData();
commit:ff65830
/////////////////////////////////////////////////////////////////////////
0:         DatabaseMetaData dbMeta = getXConnection().getMetaData();
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:                 createStatement().executeUpdate
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement(sb.toString());
commit:d038483
/////////////////////////////////////////////////////////////////////////
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
1:             return mainSuite;
1:   
1:         
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:4e091b6
/////////////////////////////////////////////////////////////////////////
0:                 if (checkRowUpdated && updatedRows.contains(new Integer(i))) {
/////////////////////////////////////////////////////////////////////////
0:             if (checkRowUpdated && updatedRows.contains(new Integer(i))) {
commit:c247315
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("ResultSet concurrency downgraded to CONCUR_READ_ONLY",
1:                        false);
/////////////////////////////////////////////////////////////////////////
1:      * Tests navigation in ResultSet.
0:      * @param ResultSet rs ResultSet to test navigation of. 
1:      *                     Needs to be scrollable
0:      * @param Map rows a sample of the rows which are in the ResultSet. Maps
1:      *                   position to a concatenation of the string values
0:      * @param Set updatedRows a integer set of which rows that have been 
1:      *            updated. Used to test rowUpdated()
0:      * @param Set deletedRows a integer set of which rows that have been
1:      *            deleted. Used to test rowDeleted()
/////////////////////////////////////////////////////////////////////////
0:                 if (checkRowUpdated && updatedRows.contains(new Integer(i)) &&
0:                         !deletedRows.contains(new Integer(i))) {
/////////////////////////////////////////////////////////////////////////
0:             if (checkRowUpdated && updatedRows.contains(new Integer(i)) &&
0:                     !deletedRows.contains(new Integer(i))) {
author:David Van Couvering
-------------------------------------------------------------------------------
commit:bc50840
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class SURQueryMixTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: import java.sql.DatabaseMetaData;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
0: import java.sql.PreparedStatement;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Random;
1: import java.util.Set;
1: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Tests for Scrollable Updatable ResultSet (SUR). This TestCase tests
1:  * scrolling (navigation), updates (using updateXXX() and updateRow() or
1:  * positioned updates), deletion of records (using deleteRow() or positioned 
1:  * deletes) of ResultSets.
0:  * @author Andreas Korneliussen
1:  */
1: public class SURQueryMixTest extends SURBaseTest
1: {
1:     /**
1:      * Constructor
0:      * @param name model name of data model for this TestCase
1:      * @param query to use for producing the resultset
1:      * @param cursorName name of cursor
1:      * @param positioned flag to determine if the Test should use positioned
1:      *        updates/deletes instead of updateRow() and deleteRow()
1:      */
1:     public SURQueryMixTest(final String model, final String query, 
1:                            final String cursorName, final boolean positioned) 
1:     {
1:         super("SURQueryMixTest{Model=" + model + ",Query=" +query + ",Cursor=" 
1:                 + cursorName + ",Positioned=" + positioned + "}");
1:         this.query = query;
1:         this.cursorName = cursorName;
1:         this.positioned = positioned;
1:         this.checkRowUpdated = false;
1:         this.checkRowDeleted = false;
1:     }
1: 
1:     /**
1:      * Test SUR properties of the query
1:      */
1:     public void runTest() 
1:         throws SQLException
1:     {
1:         println(query);
0:         DatabaseMetaData dbMeta = con.getMetaData();
1:                 
1:         if (dbMeta.ownDeletesAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE)) {
1:             checkRowDeleted = true;
1:         }
1:         
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         
1:         s.setCursorName(cursorName);
1:         ResultSet rs = s.executeQuery(query);
1: 
1:         checkRowUpdated = dbMeta.ownUpdatesAreVisible(rs.getType());        
1:         checkRowDeleted = dbMeta.ownDeletesAreVisible(rs.getType());
1:         
1:         // Create map with rows
0:         Map rows = createRowMap(rs);
1:         
1:         // Set of rows which are updated (contains Integer with position in RS)
0:         final Set updatedRows = new HashSet();
1:         
1:         // Set of rows which are deleted (contains Integer with position in RS)
0:         final Set deletedRows = new HashSet();
1:                 
1:         // Test navigation
1:         testNavigation(rs, rows, updatedRows, deletedRows);
1:         
1:         // Only test updatability if the ResultSet is updatable:
1:         // (Note: this enables the test do run successfully even if
1:         // scrollable updatable resultsets are not implemented. 
1:         // If SUR is not implemented, a well behaved JDBC driver will 
1:         // downgrade the concurrency mode to READ_ONLY).
1:         // SUR may be implemented incrementally, i.e first in embedded mode
1:         // then in the network driver.)
1:         if (rs.getConcurrency()==ResultSet.CONCUR_UPDATABLE) {
1:         
1:             // update a random sample of 2 records
1:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 2); 
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:             
1:             // update a random sample of 5 records
1:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 5); 
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:             
1:             // update a random sample of 10 records
1:             updateRandomSampleOfNRecords(rs, rows, updatedRows, 10); 
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:             
1:             // delete a random sample of 2 records
1:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 2);
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:             
1:             // delete a random sample of 5 records
1:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 5);
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:             
1:             // delete a random sample of 10 records
1:             deleteRandomSampleOfNRecords(rs, rows, deletedRows, 10);
1:             testNavigation(rs, rows, updatedRows, deletedRows); 
1:         } else {
0:             println("Skipped testing updatability");
1:         }
1:         
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Creates a Map of the values in the ResultSet. 
1:      * The key object in the map, is the postion in the 
1:      * ResultSet (Integer 1..n), while the value is a
1:      * concatenation of the strings for all columns in the row.
1:      */
0:     private Map createRowMap(final ResultSet rs) 
1:         throws SQLException
1:     {
0:         final Map rows = new HashMap();        
1:         rs.beforeFirst();
1:         assertTrue("Unexpected return from isBeforeFirst()",
1:                    rs.isBeforeFirst());
1:         
1:         int i = 0;
1:         int sum = 0;
1:         int expectedSum = 0;
1:         boolean checkSum = true;
1:         while (rs.next()) {
1:             expectedSum += i;
1:             i++;
1:             String row = getRowString(rs);
1:             println(row);
0:             rows.put(new Integer(i), row);
1:             sum += rs.getInt(1);
1:             if (rs.getInt(1) < 0) {
1:                 checkSum = false;
1:             }
1:         }
1:         if (i<SURDataModelSetup.recordCount) {
1:             checkSum = false;
1:         }
1:         
1:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:         
1:         if (checkSum) {
1:             assertEquals("Sum for column 1 is not correct", expectedSum, sum);
1:         }
1:         
1:         return rows;
1:     }
1: 
1:     /**
1:      * Create a random sample of rows
1:      * @param rows Map to create sample from
1:      * @param k number of rows in the sample
1:      * @return a list containing k elements of rows
1:      **/
0:     private List createRandomSample(final Map rows, int k) {
1:         Random r = new Random();
0:         ArrayList sampledKeys = new ArrayList();
1:         int n = 0;        
0:         for (Iterator i = rows.keySet().iterator(); i.hasNext();) {
0:             Object key = i.next();
1:             n++;            
1:             if (n<=k) {
1:                 sampledKeys.add(key);
1:             } else {
1:                 // sampledKeys now has a size of k
1:                 double d = r.nextDouble();
1:                 // p = probability of going into the sample
1:                 double p = (double) k / (double) n; 
1:                 if (d<p) {
1:                     // Replace a random value from the sample with the new value
0:                     int keyToReplace = Math.abs(r.nextInt())%k;                    
1:                     sampledKeys.set(keyToReplace, key);
1:                 }
1:             }
1:         }
1:         return sampledKeys;
1:     }
1:     
1:     /**
1:      * Delete a random sample of n records in the resultset
1:      * @param rs result set to be updated
1:      * @param rows map of rows, will also be updated
1:      * @param deletedRows set of rows being deleted (position in RS)
1:      * @param k number of records to be deleted
1:      */
1:     private void deleteRandomSampleOfNRecords(final ResultSet rs, 
0:                                               final Map rows,
0:                                               final Set deletedRows,
1:                                               final int k) 
1:         throws SQLException
1:     {
1:         List sampledKeys = createRandomSample(rows, k);
1:         println("Sampled keys:" + sampledKeys);
1:         ResultSetMetaData meta = rs.getMetaData();
1:         for (Iterator i = sampledKeys.iterator(); i.hasNext();) {
1:             Integer key = (Integer) i.next();
1:             rs.absolute(key.intValue());            
1:             if (rs.rowDeleted()) continue; // skip deleting row if already deleted
1:             if (positioned) {
0:                 con.createStatement().executeUpdate
1:                         ("DELETE FROM T1 WHERE CURRENT OF \"" + cursorName + 
1:                          "\"");
1:                 
1:                 rs.relative(0); // If this call is not here, the old values are
1:                                 // returned in rs.getXXX calls
1:             } else {
1:                 rs.deleteRow();
1:             }
1:             println("Deleted row " + key);
1:             // Update the rows table
1:             rows.put(key, getRowString(rs));
1:             
1:             // Update the updatedRows set
1:             deletedRows.add(key);
1:         }
1:     }
1:     
1:     /**
1:      * Update a random sample of n records in the resultset
1:      * @param rs result set to be updated
1:      * @param rows map of rows, will also be updated
1:      * @param updatedRows set of being updated (position in RS)
1:      * @param k number of records to be updated
1:      */
1:     private void updateRandomSampleOfNRecords(final ResultSet rs, 
0:                                               final Map rows,
0:                                               final Set updatedRows,
1:                                               final int k) 
1:         throws SQLException
1:     {
1:         List sampledKeys = createRandomSample(rows, k);
1:         println("Sampled keys:" + sampledKeys);
1:         ResultSetMetaData meta = rs.getMetaData();
1:         for (Iterator i = sampledKeys.iterator(); i.hasNext();) {
1:             Integer key = (Integer) i.next();
1:             rs.absolute(key.intValue());            
1:             
1:             if (positioned) {
1:                 updatePositioned(rs, meta);
1:                 rs.relative(0); // If this call is not here, the old values are
1:                                 // returned in rs.getXXX calls
1:             } else {
1:                 updateRow(rs, meta);
1:             }
1:             // Update the rows table
1:             rows.put(key, getRowString(rs));
1:             
1:             // Update the updatedRows set
1:             updatedRows.add(key);
1:         }
1:     }
1: 
1:     /**
1:      * Updates the current row in the ResultSet using updateRow()
1:      * @param rs ResultSet to be updated
1:      * @param meta meta for the ResultSet
1:      **/
1:     private void updateRow(final ResultSet rs, final ResultSetMetaData meta) 
1:         throws SQLException
1:     {
1:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:             if (meta.getColumnType(column)==Types.INTEGER) {
1:                 // Set to negative value
1:                 rs.updateInt(column, -rs.getInt(column));
1:             } else {
1:                 rs.updateString(column, "UPDATED_" + rs.getString(column));
1:             }
1:         }
1:         rs.updateRow();
1:     }
1:     
1:     /**
1:      * Updates the current row in the ResultSet using updateRow()
1:      * @param rs ResultSet to be updated
1:      * @param meta meta for the ResultSet
1:      **/
1:     private void updatePositioned(final ResultSet rs, 
1:                                   final ResultSetMetaData meta) 
1:         throws SQLException                          
1:     {
1:         StringBuffer sb = new StringBuffer();
1:         sb.append("UPDATE T1 SET ");
1:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:             sb.append(meta.getColumnName(column));
1:             sb.append("=?");
1:             if (column<meta.getColumnCount()) {
1:                 sb.append(",");
1:             }
1:         }
1:         sb.append(" WHERE CURRENT OF \"");
1:         sb.append(cursorName);
1:         sb.append("\"");
1:         println(sb.toString());
0:         PreparedStatement ps = con.prepareStatement(sb.toString());
1:         
1:         for (int column = 1; column<=meta.getColumnCount(); column++) {
1:            if (meta.getColumnType(column)==Types.INTEGER) {
1:                 // Set to negative value
1:                 ps.setInt(column, -rs.getInt(column));
1:             } else {
1:                 ps.setString(column, "UPDATED_" + rs.getString(column));
1:             }
1:         }
1:         assertEquals("Expected one row to be updated", 1, ps.executeUpdate());        
1:     }
1:     
1:     
1:     /**
0:      * Tests navigation in ResultSet. This test requires that the ResultSet
0:      * is not empty, and positioned before the first row. Also the 
0:      * ResultSet needs to contain column a or column id as the first column from
0:      * the SURDataModel (for checksum test)
0:      * @return a Map with all rows in the resultset (concatnated as a string)
1:      */
1:     private void testNavigation(final ResultSet rs, final Map rows, 
1:                                 final Set updatedRows, final Set deletedRows) 
1:         throws SQLException
1:     {        
1:         rs.afterLast();
1:         {
1:             int i = rows.size();
1:             while (rs.previous()) {
1:                 String rowString = getRowString(rs);
1:                 assertEquals("Navigating with rs.previous(). The row is " +
1:                              "different compared to the value when navigating " +
0:                              "forward.", rows.get(new Integer(i)), rowString);
1:                 
1:                 
0:                 if (checkRowUpdated && updatedRows.contains(new Integer(i))) {
1:                     assertTrue("Expected rs.rowUpdated() to return true on " + 
1:                                "updated row " + rowString, rs.rowUpdated());
1:                 } 
0:                 if (checkRowDeleted && deletedRows.contains(new Integer(i))) {
1:                     assertTrue("Expected rs.rowDeleted() to return true on " + 
1:                                "deleted row " + rowString, rs.rowDeleted());
1:                 } 
1:                 i--;
1:             }
1:         }
1:         // Test absolute
1:         for (int i = 1; i <= rows.size(); i++) {
1:             assertTrue("Unexpected return from absolute()", rs.absolute(i));
1:             String rowString = getRowString(rs);
1:             assertEquals("Navigating with rs.absolute(). The row is " +
1:                          "different compared to the value" +
1:                          " when navigating forward.", 
0:                          rows.get(new Integer(i)),
1:                          rowString);
0:             if (checkRowUpdated && updatedRows.contains(new Integer(i))) {
1:                 assertTrue("Expected rs.rowUpdated() to return true on " +
1:                            "updated row " + rowString, rs.rowUpdated());
1:             }
0:             if (checkRowDeleted && deletedRows.contains(new Integer(i))) {
1:                 assertTrue("Expected rs.rowDeleted() to return true on " +
1:                            "deleted row " + rowString, rs.rowDeleted());
1:             }
1:         }
1:         assertFalse("Unexpected return from absolute()", rs.absolute(0));
1:         assertTrue("Unexpected return from isBeforeFirst()", 
1:                    rs.isBeforeFirst());
1:         assertFalse("Unexpected return from absolute()", 
1:                     rs.absolute(rows.size() + 1));
1:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:         assertTrue("Unexpected return from absolute()", rs.absolute(-1));
1:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:         assertTrue("Unexpected return from absolute()", rs.absolute(1));
1:         assertTrue("Unexpected return from isFirst()", rs.isFirst());
1:         
1:         // Test relative
1:         {
1:             rs.beforeFirst();
1:             assertTrue("Unexptected return from isBeforeFirst()", 
1:                        rs.isBeforeFirst());
1:             
1:             int relativePos = rows.size();
1:             assertTrue("Unexpected return from relative()", 
1:                        rs.relative(relativePos)); 
1:             
1:             // Should now be on the last row
1:             assertTrue("Unexptected return from isLast()", rs.isLast());
1:             assertEquals("Navigating with rs.relative(+). " +
1:                          "A tuple was different compared to the value" +
1:                          " when navigating forward.", 
0:                          rows.get(new Integer(relativePos)),
1:                          getRowString(rs));
1:             
1:             assertTrue("Unexpected return from relative()", 
1:                        rs.relative((-relativePos + 1))); 
1:             
1:             // Should now be on the first row
1:             assertTrue("Unexptected return from isFirst()", rs.isFirst());
1:             
1:             assertEquals("Navigating with rs.relative(-). " + 
1:                          "A tuple was different compared to the value" +
1:                          " when navigating forward.", 
0:                          rows.get(new Integer(1)),
1:                          getRowString(rs));
1:             
1:         }
1:         // Test navigation in the end of the ResultSet
1:         rs.afterLast();
1:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:         assertTrue("Unexpected return from previous()", rs.previous());
1:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:         assertFalse("Unexpected return from next()", rs.next());
1:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1:         rs.last();
1:         assertTrue("Unexpected return from isLast()", rs.isLast());
1:         assertFalse("Unexpected return from next()", rs.next());
1:         assertTrue("Unexpected return from isAfterLast()", rs.isAfterLast());
1: 
1: 
1:         // Test navigation in the beginning of the ResultSet
1:         rs.beforeFirst();
1:         assertTrue("Unexpected return from isBeforeFirst()", 
1:                    rs.isBeforeFirst());
1:         assertTrue("Unexpected return from next()", rs.next());
1:         assertTrue("Unexpected return from isFirst", rs.isFirst());
1:         assertFalse("Unexpected return from previous()", rs.previous());
1:         assertTrue("Unexpected return from isBeforeFirst()", 
1:                    rs.isBeforeFirst());
1:         
1:         rs.first();
1:         assertTrue("Unexpected return from isFirst", rs.isFirst());
1:         assertFalse("Unexpected return from previous()", rs.previous());
1:         assertTrue("Unexpected return from isBeforeFirst()", 
1:                    rs.isBeforeFirst());
1:     }
1: 
1:     /**
1:      * Get a concatenation of the values of the 
1:      * current Row in the ResultSet
1:      */
1:     private String getRowString(final ResultSet rs) 
1:         throws SQLException
1:     {
1:         int numberOfColumns = rs.getMetaData().getColumnCount();
1:         StringBuffer sb = new StringBuffer();
1:         if (rs.rowDeleted()) return "";
1:         for (int i = 1; i <= numberOfColumns; i++) {
1:             sb.append(rs.getString(i));
1:             if (i < numberOfColumns) { 
1:                 sb.append(','); 
1:             }
1:         }
1:         return sb.toString();
1:     }
1:     
1:     private final String query;
1:     private final String cursorName;
1:     private final boolean positioned;
1:     private boolean checkRowUpdated;
1:     private boolean checkRowDeleted;
1:     
1:     private final static String[] selectConditions = new String[] {
1:         "WHERE c like 'T%'",
1:         " ",        
1:         "WHERE b > 5",
1:         "WHERE id >= a",
1:         "WHERE id > 1 and id < 900",
1:         "WHERE id = 1",
1:         "WHERE id in (1,3,4,600,900,955,966,977,978)",
1:         "WHERE a in (1,3,4,600,9200,955,966,977,978)",
1:         "WHERE a>2 and a<9000"
1:     };
1:     
1:     private final static String[] projectConditions = new String[] {
1:         "id,c,a,b",
1:         "id,c",
1:         "a,b",
1:         "*",
1:         "id,a,b,c",        
1:         "id,a",           
1:         "a,b,c",        
1:         "a,c"
1:     };
1:     
0:     private static TestSuite createTestCases(final String modelName) {
0:         TestSuite suite = new TestSuite();
1:         for (int doPos = 0; doPos<2; doPos++) {
1:             boolean positioned = doPos>0; // true if to use positioned updates
1: 
1:             for (int i = 0; i < selectConditions.length; i++) {
1:                 for (int j = 0; j < projectConditions.length; j++) {
1:                     final String cursorName = "cursor_" + i + "_" + j;
1:                     
1:                     final String stmtString = "SELECT " + projectConditions[j] +
1:                             " FROM T1 " + selectConditions[i];
1:                     suite.addTest(new SURQueryMixTest(modelName, stmtString, cursorName, 
1:                                               positioned));
1:                 }
1:             }
1:         }
1:         return suite;
1:     }
1:     
1:     /**
0:      * The suite contains all testcases in this class running on different data models
1:      */
1:     public static Test suite() 
1:     {   
0:         TestSuite mainSuite = new TestSuite();
1:         
1:         // Iterate over all data models and decorate the tests:
1:         for (Iterator i = SURDataModelSetup.SURDataModel.values().iterator();
1:              i.hasNext();) {
1:             
1:             SURDataModelSetup.SURDataModel model =
1:                 (SURDataModelSetup.SURDataModel) i.next();
1:             
0:             TestSuite suite = createTestCases(model.toString());
1:             TestSetup decorator = new SURDataModelSetup(suite, model);
1:             mainSuite.addTest(decorator);
1:         }
0:         return mainSuite;
1:     }
1:     
1:   
1: }
============================================================================