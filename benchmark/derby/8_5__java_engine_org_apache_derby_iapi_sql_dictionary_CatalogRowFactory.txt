1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.CatalogRowFactory
1:c2ff613: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
3:eac0369:  */
18:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
1:8bae7cf: import org.apache.derby.catalog.UUID;
1:8bae7cf: import org.apache.derby.iapi.error.StandardException;
1:8bae7cf: import org.apache.derby.iapi.reference.Property;
1:bc2c59e: import org.apache.derby.iapi.services.io.ArrayUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:8bae7cf: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:8bae7cf: import org.apache.derby.iapi.sql.execute.ExecRow;
1:8bae7cf: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:8bae7cf: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:8bae7cf: import org.apache.derby.iapi.types.DataValueFactory;
1:8bae7cf: 
3:eac0369: /**
1:eac0369:  * Superclass of all row factories.
1:eac0369:  *
1:eac0369:  *
1:eac0369:  * @version 0.2
1:eac0369:  */
1:eac0369: 
1:eac0369: public abstract	class CatalogRowFactory
6:eac0369: {
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATE
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected 	String[] 			indexNames;
1:eac0369: 	protected 	int[][] 			indexColumnPositions;
1:eac0369: 	protected	boolean[]			indexUniqueness;
1:eac0369: 
1:eac0369: 	protected	UUID				tableUUID;
1:eac0369: 	protected	UUID				heapUUID;
1:eac0369: 	protected	UUID[]				indexUUID;
1:eac0369: 
1:eac0369: 	protected	DataValueFactory    dvf;
1:eac0369: 	private     final ExecutionFactory    ef;
1:eac0369: 	private		UUIDFactory			uuidf;
1:eac0369: 
1:eac0369:     private     int indexCount;
1:eac0369: 	private     int columnCount;
1:eac0369: 	private     String catalogName;
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369:     public CatalogRowFactory(UUIDFactory uuidf,
1:eac0369: 							 ExecutionFactory ef,
1:6870e87: 							 DataValueFactory dvf)
1:eac0369: 								 
1:eac0369: 	{
1:eac0369: 		this.uuidf = uuidf;
1:eac0369: 		this.dvf = dvf;
1:eac0369: 		this.ef = ef;
6:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets a ExecutionFactory
1:eac0369: 	  *
1:eac0369: 	  *	@return	an execution factory
1:eac0369: 	  */
1:eac0369: 	public ExecutionFactory getExecutionFactory() {return ef;}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the UUID factory
1:eac0369: 	  *
1:eac0369: 	  *	@return	the UUID factory
1:eac0369: 	  */
1:eac0369: 	public	UUIDFactory	getUUIDFactory() { return uuidf; }
1:eac0369: 
1:eac0369: 	/* Override the following methods in sub-classes if they have any
1:eac0369: 	 * indexes.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	 /**
1:eac0369: 	   *	Get the UUID of this catalog. This is the hard-coded uuid for
1:eac0369: 	   *	this catalog that is generated for releases starting with Plato (1.3).
1:eac0369: 	   *	Earlier releases generated their own UUIDs for system objectss on
1:eac0369: 	   *	the fly.
1:eac0369: 	   *
1:eac0369: 	   * @return	the name of this catalog
1:eac0369: 	   */
1:eac0369:     public	UUID	getCanonicalTableUUID() { return tableUUID; }
1:eac0369: 
1:eac0369: 	 /**
1:eac0369: 	   *	Get the UUID of the heap underlying this catalog. See getCanonicalTableUUID()
1:eac0369: 	   *	for a description of canonical uuids.
1:eac0369: 	   *
1:eac0369: 	   * @return	the uuid of the heap
1:eac0369: 	   */
1:eac0369: 	public	UUID	getCanonicalHeapUUID()  { return heapUUID; }
1:eac0369: 
1:eac0369: 	 /**
1:eac0369: 	   *	Get the UUID of the numbered index. See getCanonicalTableUUID()
1:eac0369: 	   *	for a description of canonical uuids.
1:eac0369: 	   *
1:eac0369: 	   * @param	indexNumber	The (0-based) index number.
1:eac0369: 	   *
1:eac0369: 	   * @return	the uuid of the heap
1:eac0369: 	   */
1:eac0369: 	public	UUID	getCanonicalIndexUUID( int indexNumber )
1:eac0369: 	{
1:eac0369: 		return indexUUID[indexNumber];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of columns in the index for the specified index number.
1:eac0369: 	 *
2:eac0369: 	 * @param indexNum	The (0-based) index number.
1:eac0369: 	 *
1:eac0369: 	 * @return int		The number of columns in the index for the specifed index number.
1:eac0369: 	 */
1:eac0369: 	public int getIndexColumnCount(int indexNum)
1:eac0369: 	{
1:eac0369: 		return indexColumnPositions[indexNum].length;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name for the heap conglomerate underlying this catalog.
1:eac0369: 	 * See getCanonicalTableUUID() for a description of canonical uuids.
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name for the heap conglomerate.
1:eac0369: 	 */
1:6870e87: 	public String getCanonicalHeapName() { return catalogName + "_HEAP"; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name for the specified index number.
1:eac0369: 	 *
1:eac0369: 	 * @param indexNum	The (0-based) index number.
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name for the specified index number.
1:eac0369: 	 */
1:eac0369: 	public String getIndexName(int indexNum)
1:eac0369: 	{
1:eac0369: 		return indexNames[indexNum];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the specified index is unique.
1:eac0369: 	 *
1:6b50965: 	 * @param indexNumber	The (0-based) index number.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not the specified index is unique.
1:eac0369: 	 */
1:eac0369: 	public boolean isIndexUnique(int indexNumber)
1:eac0369: 	{
1:eac0369: 		return (indexUniqueness != null ? indexUniqueness[indexNumber] : true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets the DataValueFactory for this connection.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the data value factory for this connection
1:eac0369: 	  */
1:eac0369: 	public DataValueFactory	getDataValueFactory() { return dvf; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Generate an index name based on the index number.
1:eac0369: 	  *
1:eac0369: 	  *	@param	indexNumber		Number of index
1:eac0369: 	  *
1:eac0369: 	  *	@return	the following index name: CatalogName + "_INDEX" + (indexNumber+1)
1:eac0369: 	  */
1:eac0369: 	public	String	generateIndexName( int indexNumber )
1:eac0369: 	{
1:eac0369: 		indexNumber++;
1:6870e87: 		return	catalogName + "_INDEX" + indexNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** get the number of indexes on this catalog */
1:eac0369: 	public int getNumIndexes() { return indexCount; }
1:eac0369: 
1:eac0369: 	/** get the name of the catalog */
1:eac0369: 	public String getCatalogName() { return catalogName; };
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Initialize info, including array of index names and array of
1:eac0369: 	  * index column counts. Called at constructor time.
1:eac0369: 	  *
1:eac0369: 	  * @param  columnCount number of columns in the base table.
1:eac0369: 	  * @param  catalogName name of the catalog (the case might have to be converted).
1:eac0369: 	  * @param  indexColumnPositions 2 dim array of ints specifying the base
1:eac0369: 	  * column positions for each index.
1:eac0369: 	  *	@param	indexUniqueness		Uniqueness of the indices
1:eac0369: 	  *	@param	uuidStrings			Array of stringified UUIDs for table and its conglomerates
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	public	void	initInfo(int        columnCount,
1:eac0369: 							 String 	catalogName,
1:eac0369: 							 int[][] 	indexColumnPositions,
1:eac0369: 							 boolean[] 	indexUniqueness,
1:eac0369: 							 String[]	uuidStrings)
1:eac0369: 							 
1:eac0369: 	{
1:eac0369: 		indexCount = (indexColumnPositions != null) ? 
1:eac0369: 			                 indexColumnPositions.length : 0;
1:eac0369: 
1:6870e87: 		this.catalogName = catalogName;
1:eac0369: 		this.columnCount = columnCount;
1:eac0369: 
1:eac0369: 		UUIDFactory	uf = getUUIDFactory();
1:eac0369: 		this.tableUUID = uf.recreateUUID(uuidStrings[0] );
1:eac0369: 		this.heapUUID = uf.recreateUUID( uuidStrings[1] );
1:eac0369: 
1:eac0369: 		if (indexCount > 0)
1:eac0369: 		{
1:eac0369: 			indexNames = new String[indexCount];
1:eac0369: 			indexUUID = new UUID[indexCount];
1:eac0369: 			for (int ictr = 0; ictr < indexCount; ictr++)
1:eac0369: 			{
1:eac0369: 				indexNames[ictr] = generateIndexName(ictr);
1:eac0369: 				indexUUID[ictr] = uf.recreateUUID(uuidStrings[ictr + 2 ]);
1:eac0369: 			}
1:bc2c59e: 			this.indexColumnPositions = ArrayUtil.copy2( indexColumnPositions );
1:bc2c59e: 			this.indexUniqueness = ArrayUtil.copy( indexUniqueness );
1:c2ff613:  
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the heap.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the heap.
1:eac0369: 	 */
1:eac0369: 	public Properties getCreateHeapProperties()
1:eac0369: 	{
1:eac0369: 		Properties properties = new Properties();
1:eac0369: 		// default properties for system tables:
1:eac0369: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
1:eac0369: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
1:eac0369: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
1:eac0369: 		return properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the specified index.
1:eac0369: 	 *
1:eac0369: 	 * @param indexNumber	The specified index number.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the specified index.
1:eac0369: 	 */
1:eac0369: 	public Properties getCreateIndexProperties(int indexNumber)
1:eac0369: 	{
1:eac0369: 		Properties properties = new Properties();
1:eac0369: 		// default properties for system indexes:
1:eac0369: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
1:eac0369: 		return properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the index number for the primary key index on this catalog.
1:eac0369: 	  *
1:eac0369: 	  *	@return	a 0-based number
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	public	int	getPrimaryKeyIndexNumber()
1:eac0369: 	{
8:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.NOTREACHED();
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of columns in the heap.
1:eac0369: 	 *
1:eac0369: 	 * @return The number of columns in the heap.
1:eac0369: 	 */
1:d9878ca:     public int getHeapColumnCount() throws StandardException
1:eac0369: 	{
1:eac0369: 		return columnCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Return an empty row for this conglomerate. 
1:eac0369: 	 */
1:eac0369: 	public  ExecRow makeEmptyRow() throws StandardException
1:eac0369: 	{
1:eac0369:  		return	this.makeRow(null, null);
1:eac0369: 	}
1:eac0369: 
1:d9878ca:     /**
1:d9878ca:      * <p>
1:d9878ca:      * Create an empty row for this conglomerate, in the format that would
1:d9878ca:      * be used in a database that was created with, or hard upgraded to,
1:d9878ca:      * the currently running version. That is, even if the database is only
1:d9878ca:      * soft-upgraded, this method should return a row in the new format.
1:d9878ca:      * </p>
1:d9878ca:      *
1:d9878ca:      * <p>
1:d9878ca:      * This method is for use in code that creates the catalogs, or that
1:d9878ca:      * upgrades the format of the catalogs to the newest version. Other code
1:d9878ca:      * should call {@link #makeEmptyRow()}, which returns a row in the format
1:d9878ca:      * used in the old database version if the database is soft-upgraded.
1:d9878ca:      * </p>
1:d9878ca:      *
1:d9878ca:      * @return an empty row
1:d9878ca:      * @throws StandardException if an error happens when creating the row
1:d9878ca:      */
1:d9878ca:     public ExecRow makeEmptyRowForCurrentVersion() throws StandardException {
1:d9878ca:         return makeEmptyRow();
1:d9878ca:     }
1:d9878ca: 
1:eac0369: 	/**
1:eac0369: 	 * most subclasses should provide this method. One or two oddball cases in
1:eac0369: 	 * Replication and SysSTATEMENTSRowFactory don't. For those we call makeRow
1:eac0369: 	 * with the additional arguments.
1:eac0369: 	 */
1:eac0369: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) { SanityManager.THROWASSERT( "Should not get here." ); }
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// abstract classes that should be implemented by subclasses. 
1:eac0369: 
1:eac0369: 	/** builds a tuple descriptor from a row */
1:eac0369: 	public abstract TupleDescriptor 
1:eac0369: 		buildDescriptor(ExecRow row,
1:eac0369: 						TupleDescriptor parentTuple,
1:eac0369: 						DataDictionary	dataDictionary)
2:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/** builds a column list for the catalog */
1:2a5922a: 	public abstract SystemColumn[]	buildColumnList() throws StandardException;
1:eac0369: 
1:eac0369: 	/** Return the column positions for a given index number */
1:eac0369: 	public int[] getIndexColumnPositions(int indexNumber)
1:eac0369: 	{
1:eac0369: 		return indexColumnPositions[indexNumber];
1:eac0369: 	}	
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public int getHeapColumnCount() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Create an empty row for this conglomerate, in the format that would
1:      * be used in a database that was created with, or hard upgraded to,
1:      * the currently running version. That is, even if the database is only
1:      * soft-upgraded, this method should return a row in the new format.
1:      * </p>
1:      *
1:      * <p>
1:      * This method is for use in code that creates the catalogs, or that
1:      * upgrades the format of the catalogs to the newest version. Other code
1:      * should call {@link #makeEmptyRow()}, which returns a row in the format
1:      * used in the old database version if the database is soft-upgraded.
1:      * </p>
1:      *
1:      * @return an empty row
1:      * @throws StandardException if an error happens when creating the row
1:      */
1:     public ExecRow makeEmptyRowForCurrentVersion() throws StandardException {
1:         return makeEmptyRow();
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:bc2c59e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 			this.indexColumnPositions = ArrayUtil.copy2( indexColumnPositions );
1: 			this.indexUniqueness = ArrayUtil.copy( indexUniqueness );
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1: 	public abstract SystemColumn[]	buildColumnList() throws StandardException;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6870e87
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							 DataValueFactory dvf)
/////////////////////////////////////////////////////////////////////////
1: 	public String getCanonicalHeapName() { return catalogName + "_HEAP"; }
/////////////////////////////////////////////////////////////////////////
1: 		return	catalogName + "_INDEX" + indexNumber;
/////////////////////////////////////////////////////////////////////////
1: 		this.catalogName = catalogName;
/////////////////////////////////////////////////////////////////////////
commit:8bae7cf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
commit:7aa6fa8
/////////////////////////////////////////////////////////////////////////
commit:c2ff613
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.CatalogRowFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
1: import java.util.Properties;
1: 
1: /**
1:  * Superclass of all row factories.
1:  *
1:  *
1:  * @version 0.2
0:  * @author Rick Hillegas 
0:  * @author Manish Khettry
1:  */
1: 
1: public abstract	class CatalogRowFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	///////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	protected 	String[] 			indexNames;
1: 	protected 	int[][] 			indexColumnPositions;
0: 	protected   String[][]          indexColumnNames;
1: 	protected	boolean[]			indexUniqueness;
1: 
1: 	protected	UUID				tableUUID;
1: 	protected	UUID				heapUUID;
1: 	protected	UUID[]				indexUUID;
1: 
1: 	protected	DataValueFactory    dvf;
1: 	private     final ExecutionFactory    ef;
1: 	private		UUIDFactory			uuidf;
1: 
0:     private     boolean convertIdToLower;
1:     private     int indexCount;
1: 	private     int columnCount;
1: 	private     String catalogName;
1: 
1: 	///////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////
1: 
1:     public CatalogRowFactory(UUIDFactory uuidf,
1: 							 ExecutionFactory ef,
0: 							 DataValueFactory dvf,
0: 							 boolean convertIdToLower)
1: 								 
1: 	{
1: 		this.uuidf = uuidf;
1: 		this.dvf = dvf;
1: 		this.ef = ef;
0:         this.convertIdToLower = convertIdToLower;
1: 	}
1: 
1: 	/**
1: 	  *	Gets a ExecutionFactory
1: 	  *
1: 	  *	@return	an execution factory
1: 	  */
1: 	public ExecutionFactory getExecutionFactory() {return ef;}
1: 
1: 	/**
1: 	  *	Get the UUID factory
1: 	  *
1: 	  *	@return	the UUID factory
1: 	  */
1: 	public	UUIDFactory	getUUIDFactory() { return uuidf; }
1: 
1: 	/* Override the following methods in sub-classes if they have any
1: 	 * indexes.
1: 	 */
1: 
1: 	 /**
1: 	   *	Get the UUID of this catalog. This is the hard-coded uuid for
1: 	   *	this catalog that is generated for releases starting with Plato (1.3).
1: 	   *	Earlier releases generated their own UUIDs for system objectss on
1: 	   *	the fly.
1: 	   *
1: 	   * @return	the name of this catalog
1: 	   */
1:     public	UUID	getCanonicalTableUUID() { return tableUUID; }
1: 
1: 	 /**
1: 	   *	Get the UUID of the heap underlying this catalog. See getCanonicalTableUUID()
1: 	   *	for a description of canonical uuids.
1: 	   *
1: 	   * @return	the uuid of the heap
1: 	   */
1: 	public	UUID	getCanonicalHeapUUID()  { return heapUUID; }
1: 
1: 	 /**
1: 	   *	Get the UUID of the numbered index. See getCanonicalTableUUID()
1: 	   *	for a description of canonical uuids.
1: 	   *
1: 	   * @param	indexNumber	The (0-based) index number.
1: 	   *
1: 	   * @return	the uuid of the heap
1: 	   */
1: 	public	UUID	getCanonicalIndexUUID( int indexNumber )
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
1: 
1: 		return indexUUID[indexNumber];
1: 	}
1: 
1: 	/**
1: 	 * Get the number of columns in the index for the specified index number.
1: 	 *
1: 	 * @param indexNum	The (0-based) index number.
1: 	 *
1: 	 * @return int		The number of columns in the index for the specifed index number.
1: 	 */
1: 	public int getIndexColumnCount(int indexNum)
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNum);
1: 
1: 		return indexColumnPositions[indexNum].length;
1: 	}
1: 
1: 	/**
1: 	 * Get the name for the heap conglomerate underlying this catalog.
1: 	 * See getCanonicalTableUUID() for a description of canonical uuids.
1: 	 *
1: 	 * @return String	The name for the heap conglomerate.
1: 	 */
0: 	public String getCanonicalHeapName() { return catalogName + convertIdCase( "_HEAP"); }
1: 
1: 	/**
1: 	 * Get the name for the specified index number.
1: 	 *
1: 	 * @param indexNum	The (0-based) index number.
1: 	 *
1: 	 * @return String	The name for the specified index number.
1: 	 */
1: 	public String getIndexName(int indexNum)
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNum);
1: 
1: 		return indexNames[indexNum];
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the specified index is unique.
1: 	 *
1: 	 * @param indexNum	The (0-based) index number.
1: 	 *
1: 	 * @return boolean		Whether or not the specified index is unique.
1: 	 */
1: 	public boolean isIndexUnique(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
1: 
1: 		return (indexUniqueness != null ? indexUniqueness[indexNumber] : true);
1: 	}
1: 
1: 	/**
1: 	  *	Gets the DataValueFactory for this connection.
1: 	  *
1: 	  *	@return	the data value factory for this connection
1: 	  */
1: 	public DataValueFactory	getDataValueFactory() { return dvf; }
1: 
1: 	/**
1: 	  *	Generate an index name based on the index number.
1: 	  *
1: 	  *	@param	indexNumber		Number of index
1: 	  *
1: 	  *	@return	the following index name: CatalogName + "_INDEX" + (indexNumber+1)
1: 	  */
1: 	public	String	generateIndexName( int indexNumber )
1: 	{
1: 		indexNumber++;
0: 		return	catalogName + convertIdCase( "_INDEX") + indexNumber;
1: 	}
1: 
1: 	/** get the number of indexes on this catalog */
1: 	public int getNumIndexes() { return indexCount; }
1: 
1: 	/** get the name of the catalog */
1: 	public String getCatalogName() { return catalogName; };
1: 
1: 	/**
1: 	  *	Initialize info, including array of index names and array of
1: 	  * index column counts. Called at constructor time.
1: 	  *
1: 	  * @param  columnCount number of columns in the base table.
1: 	  * @param  catalogName name of the catalog (the case might have to be converted).
1: 	  * @param  indexColumnPositions 2 dim array of ints specifying the base
1: 	  * column positions for each index.
0: 	  * @param  indexColumnNames    2 dim array of Strings specifying the name
0: 	  * of the base column for each index.
1: 	  *	@param	indexUniqueness		Uniqueness of the indices
1: 	  *	@param	uuidStrings			Array of stringified UUIDs for table and its conglomerates
1: 	  *
1: 	  */
1: 	public	void	initInfo(int        columnCount,
1: 							 String 	catalogName,
1: 							 int[][] 	indexColumnPositions,
0: 							 String[][] indexColumnNames,
1: 							 boolean[] 	indexUniqueness,
1: 							 String[]	uuidStrings)
1: 							 
1: 	{
1: 		indexCount = (indexColumnPositions != null) ? 
1: 			                 indexColumnPositions.length : 0;
1: 
0: 		this.catalogName = convertIdCase(catalogName);
1: 		this.columnCount = columnCount;
1: 
1: 		UUIDFactory	uf = getUUIDFactory();
1: 		this.tableUUID = uf.recreateUUID(uuidStrings[0] );
1: 		this.heapUUID = uf.recreateUUID( uuidStrings[1] );
1: 
1: 		if (indexCount > 0)
1: 		{
1: 			indexNames = new String[indexCount];
1: 			indexUUID = new UUID[indexCount];
1: 			for (int ictr = 0; ictr < indexCount; ictr++)
1: 			{
1: 				indexNames[ictr] = generateIndexName(ictr);
1: 				indexUUID[ictr] = uf.recreateUUID(uuidStrings[ictr + 2 ]);
1: 			}
0: 			this.indexColumnPositions = indexColumnPositions;
0: 			this.indexColumnNames = indexColumnNames;
0: 			this.indexUniqueness = indexUniqueness;
1: 
1: 
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the heap.
1: 	 *
1: 	 * @return The Properties associated with creating the heap.
1: 	 */
1: 	public Properties getCreateHeapProperties()
1: 	{
1: 		Properties properties = new Properties();
1: 		// default properties for system tables:
1: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
1: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
1: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
1: 		return properties;
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the specified index.
1: 	 *
1: 	 * @param indexNumber	The specified index number.
1: 	 *
1: 	 * @return The Properties associated with creating the specified index.
1: 	 */
1: 	public Properties getCreateIndexProperties(int indexNumber)
1: 	{
1: 		Properties properties = new Properties();
1: 		// default properties for system indexes:
1: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
1: 		return properties;
1: 	}
1: 
1: 	/**
1: 	  *	Get the index number for the primary key index on this catalog.
1: 	  *
1: 	  *	@return	a 0-based number
1: 	  *
1: 	  */
1: 	public	int	getPrimaryKeyIndexNumber()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.NOTREACHED();
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Get the number of columns in the heap.
1: 	 *
1: 	 * @return The number of columns in the heap.
1: 	 */
0: 	public final int getHeapColumnCount()
1: 	{
1: 		return columnCount;
1: 	}
1: 
0:     protected String convertIdCase( String id)
1:     {
0:         if( convertIdToLower)
0:             return StringUtil.SQLToLowerCase(id);
0:         else
0:             return id;
1:     }
1:     
1: 
1: 	/** 
1: 	 * Return an empty row for this conglomerate. 
1: 	 */
1: 	public  ExecRow makeEmptyRow() throws StandardException
1: 	{
1:  		return	this.makeRow(null, null);
1: 	}
1: 
1: 	/**
1: 	 * most subclasses should provide this method. One or two oddball cases in
1: 	 * Replication and SysSTATEMENTSRowFactory don't. For those we call makeRow
1: 	 * with the additional arguments.
1: 	 */
1: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) { SanityManager.THROWASSERT( "Should not get here." ); }
1: 		return null;
1: 	}
1: 
1: 	// abstract classes that should be implemented by subclasses. 
1: 
1: 	/** builds a tuple descriptor from a row */
1: 	public abstract TupleDescriptor 
1: 		buildDescriptor(ExecRow row,
1: 						TupleDescriptor parentTuple,
1: 						DataDictionary	dataDictionary)
1: 		throws StandardException;
1: 
1: 	/** builds a column list for the catalog */
0: 	public abstract SystemColumn[]	buildColumnList();
1: 
1: 	/**
0: 	 * builds an empty row given for a given index number.
1: 	 */
0:   	public abstract ExecIndexRow	buildEmptyIndexRow(int indexNumber,
0: 													   RowLocation rowLocation) 
1:   		throws StandardException;
1: 
1: 	/** Return the column positions for a given index number */
1: 	public int[] getIndexColumnPositions(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
1: 
1: 		return indexColumnPositions[indexNumber];
1: 	}
1: 
0: 	/** Return the names of columns for a given index number */
0: 	public String[] getIndexColumnNames(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)		
0: 			checkIndexNumber(indexNumber);
1: 		
0: 		if (!convertIdToLower)
0: 			return indexColumnNames[indexNumber];
1: 
0: 		String[] s = new String[indexColumnNames[indexNumber].length];
0: 		for (int i = 0; i < s.length; i++)
0: 			s[i] = StringUtil.SQLToLowerCase(indexColumnNames[indexNumber][i]);
0: 		return s;
1: 	}	
1: 
0: 	protected void checkIndexNumber(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1:   		{
0:   			if (!(indexNumber < indexCount))
1:   			{
0:   				SanityManager.THROWASSERT("indexNumber (" + 
0: 										  indexNumber + ") expected to be < " + indexCount);
1:   			}
1:   		}
1: 	}		
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param indexNumber	The (0-based) index number.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: import java.util.Properties;
0: 
0: /**
0:  * Superclass of all row factories.
0:  *
0:  *
0:  * @version 0.2
0:  * @author Rick Hillegas 
0:  * @author Manish Khettry
0:  */
0: 
0: public abstract	class CatalogRowFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	///////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	protected 	String[] 			indexNames;
0: 	protected 	int[][] 			indexColumnPositions;
0: 	protected   String[][]          indexColumnNames;
0: 	protected	boolean[]			indexUniqueness;
0: 
0: 	protected	UUID				tableUUID;
0: 	protected	UUID				heapUUID;
0: 	protected	UUID[]				indexUUID;
0: 
0: 	protected	DataValueFactory    dvf;
0: 	private     final ExecutionFactory    ef;
0: 	private		UUIDFactory			uuidf;
0: 
0:     private     boolean convertIdToLower;
0:     private     int indexCount;
0: 	private     int columnCount;
0: 	private     String catalogName;
0: 
0: 	///////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////
0: 
0:     public CatalogRowFactory(UUIDFactory uuidf,
0: 							 ExecutionFactory ef,
0: 							 DataValueFactory dvf,
0: 							 boolean convertIdToLower)
0: 								 
0: 	{
0: 		this.uuidf = uuidf;
0: 		this.dvf = dvf;
0: 		this.ef = ef;
0:         this.convertIdToLower = convertIdToLower;
0: 	}
0: 
0: 	/**
0: 	  *	Gets a ExecutionFactory
0: 	  *
0: 	  *	@return	an execution factory
0: 	  */
0: 	public ExecutionFactory getExecutionFactory() {return ef;}
0: 
0: 	/**
0: 	  *	Get the UUID factory
0: 	  *
0: 	  *	@return	the UUID factory
0: 	  */
0: 	public	UUIDFactory	getUUIDFactory() { return uuidf; }
0: 
0: 	/* Override the following methods in sub-classes if they have any
0: 	 * indexes.
0: 	 */
0: 
0: 	 /**
0: 	   *	Get the UUID of this catalog. This is the hard-coded uuid for
0: 	   *	this catalog that is generated for releases starting with Plato (1.3).
0: 	   *	Earlier releases generated their own UUIDs for system objectss on
0: 	   *	the fly.
0: 	   *
0: 	   * @return	the name of this catalog
0: 	   */
0:     public	UUID	getCanonicalTableUUID() { return tableUUID; }
0: 
0: 	 /**
0: 	   *	Get the UUID of the heap underlying this catalog. See getCanonicalTableUUID()
0: 	   *	for a description of canonical uuids.
0: 	   *
0: 	   * @return	the uuid of the heap
0: 	   */
0: 	public	UUID	getCanonicalHeapUUID()  { return heapUUID; }
0: 
0: 	 /**
0: 	   *	Get the UUID of the numbered index. See getCanonicalTableUUID()
0: 	   *	for a description of canonical uuids.
0: 	   *
0: 	   * @param	indexNumber	The (0-based) index number.
0: 	   *
0: 	   * @return	the uuid of the heap
0: 	   */
0: 	public	UUID	getCanonicalIndexUUID( int indexNumber )
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
0: 
0: 		return indexUUID[indexNumber];
0: 	}
0: 
0: 	/**
0: 	 * Get the number of columns in the index for the specified index number.
0: 	 *
0: 	 * @param indexNum	The (0-based) index number.
0: 	 *
0: 	 * @return int		The number of columns in the index for the specifed index number.
0: 	 */
0: 	public int getIndexColumnCount(int indexNum)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNum);
0: 
0: 		return indexColumnPositions[indexNum].length;
0: 	}
0: 
0: 	/**
0: 	 * Get the name for the heap conglomerate underlying this catalog.
0: 	 * See getCanonicalTableUUID() for a description of canonical uuids.
0: 	 *
0: 	 * @return String	The name for the heap conglomerate.
0: 	 */
0: 	public String getCanonicalHeapName() { return catalogName + convertIdCase( "_HEAP"); }
0: 
0: 	/**
0: 	 * Get the name for the specified index number.
0: 	 *
0: 	 * @param indexNum	The (0-based) index number.
0: 	 *
0: 	 * @return String	The name for the specified index number.
0: 	 */
0: 	public String getIndexName(int indexNum)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNum);
0: 
0: 		return indexNames[indexNum];
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the specified index is unique.
0: 	 *
0: 	 * @param indexNum	The (0-based) index number.
0: 	 *
0: 	 * @return boolean		Whether or not the specified index is unique.
0: 	 */
0: 	public boolean isIndexUnique(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
0: 
0: 		return (indexUniqueness != null ? indexUniqueness[indexNumber] : true);
0: 	}
0: 
0: 	/**
0: 	  *	Gets the DataValueFactory for this connection.
0: 	  *
0: 	  *	@return	the data value factory for this connection
0: 	  */
0: 	public DataValueFactory	getDataValueFactory() { return dvf; }
0: 
0: 	/**
0: 	  *	Generate an index name based on the index number.
0: 	  *
0: 	  *	@param	indexNumber		Number of index
0: 	  *
0: 	  *	@return	the following index name: CatalogName + "_INDEX" + (indexNumber+1)
0: 	  */
0: 	public	String	generateIndexName( int indexNumber )
0: 	{
0: 		indexNumber++;
0: 		return	catalogName + convertIdCase( "_INDEX") + indexNumber;
0: 	}
0: 
0: 	/** get the number of indexes on this catalog */
0: 	public int getNumIndexes() { return indexCount; }
0: 
0: 	/** get the name of the catalog */
0: 	public String getCatalogName() { return catalogName; };
0: 
0: 	/**
0: 	  *	Initialize info, including array of index names and array of
0: 	  * index column counts. Called at constructor time.
0: 	  *
0: 	  * @param  columnCount number of columns in the base table.
0: 	  * @param  catalogName name of the catalog (the case might have to be converted).
0: 	  * @param  indexColumnPositions 2 dim array of ints specifying the base
0: 	  * column positions for each index.
0: 	  * @param  indexColumnNames    2 dim array of Strings specifying the name
0: 	  * of the base column for each index.
0: 	  *	@param	indexUniqueness		Uniqueness of the indices
0: 	  *	@param	uuidStrings			Array of stringified UUIDs for table and its conglomerates
0: 	  *
0: 	  */
0: 	public	void	initInfo(int        columnCount,
0: 							 String 	catalogName,
0: 							 int[][] 	indexColumnPositions,
0: 							 String[][] indexColumnNames,
0: 							 boolean[] 	indexUniqueness,
0: 							 String[]	uuidStrings)
0: 							 
0: 	{
0: 		indexCount = (indexColumnPositions != null) ? 
0: 			                 indexColumnPositions.length : 0;
0: 
0: 		this.catalogName = convertIdCase(catalogName);
0: 		this.columnCount = columnCount;
0: 
0: 		UUIDFactory	uf = getUUIDFactory();
0: 		this.tableUUID = uf.recreateUUID(uuidStrings[0] );
0: 		this.heapUUID = uf.recreateUUID( uuidStrings[1] );
0: 
0: 		if (indexCount > 0)
0: 		{
0: 			indexNames = new String[indexCount];
0: 			indexUUID = new UUID[indexCount];
0: 			for (int ictr = 0; ictr < indexCount; ictr++)
0: 			{
0: 				indexNames[ictr] = generateIndexName(ictr);
0: 				indexUUID[ictr] = uf.recreateUUID(uuidStrings[ictr + 2 ]);
0: 			}
0: 			this.indexColumnPositions = indexColumnPositions;
0: 			this.indexColumnNames = indexColumnNames;
0: 			this.indexUniqueness = indexUniqueness;
0: 
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the heap.
0: 	 *
0: 	 * @return The Properties associated with creating the heap.
0: 	 */
0: 	public Properties getCreateHeapProperties()
0: 	{
0: 		Properties properties = new Properties();
0: 		// default properties for system tables:
0: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
0: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
0: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
0: 		return properties;
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the specified index.
0: 	 *
0: 	 * @param indexNumber	The specified index number.
0: 	 *
0: 	 * @return The Properties associated with creating the specified index.
0: 	 */
0: 	public Properties getCreateIndexProperties(int indexNumber)
0: 	{
0: 		Properties properties = new Properties();
0: 		// default properties for system indexes:
0: 		properties.put(Property.PAGE_SIZE_PARAMETER,"1024");
0: 		return properties;
0: 	}
0: 
0: 	/**
0: 	  *	Get the index number for the primary key index on this catalog.
0: 	  *
0: 	  *	@return	a 0-based number
0: 	  *
0: 	  */
0: 	public	int	getPrimaryKeyIndexNumber()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.NOTREACHED();
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Get the number of columns in the heap.
0: 	 *
0: 	 * @return The number of columns in the heap.
0: 	 */
0: 	public final int getHeapColumnCount()
0: 	{
0: 		return columnCount;
0: 	}
0: 
0:     protected String convertIdCase( String id)
0:     {
0:         if( convertIdToLower)
0:             return StringUtil.SQLToLowerCase(id);
0:         else
0:             return id;
0:     }
0:     
0: 
0: 	/** 
0: 	 * Return an empty row for this conglomerate. 
0: 	 */
0: 	public  ExecRow makeEmptyRow() throws StandardException
0: 	{
0:  		return	this.makeRow(null, null);
0: 	}
0: 
0: 	/**
0: 	 * most subclasses should provide this method. One or two oddball cases in
0: 	 * Replication and SysSTATEMENTSRowFactory don't. For those we call makeRow
0: 	 * with the additional arguments.
0: 	 */
0: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) { SanityManager.THROWASSERT( "Should not get here." ); }
0: 		return null;
0: 	}
0: 
0: 	// abstract classes that should be implemented by subclasses. 
0: 
0: 	/** builds a tuple descriptor from a row */
0: 	public abstract TupleDescriptor 
0: 		buildDescriptor(ExecRow row,
0: 						TupleDescriptor parentTuple,
0: 						DataDictionary	dataDictionary)
0: 		throws StandardException;
0: 
0: 	/** builds a column list for the catalog */
0: 	public abstract SystemColumn[]	buildColumnList();
0: 
0: 	/**
0: 	 * builds an empty row given for a given index number.
0: 	 */
0:   	public abstract ExecIndexRow	buildEmptyIndexRow(int indexNumber,
0: 													   RowLocation rowLocation) 
0:   		throws StandardException;
0: 
0: 	/** Return the column positions for a given index number */
0: 	public int[] getIndexColumnPositions(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkIndexNumber(indexNumber);
0: 
0: 		return indexColumnPositions[indexNumber];
0: 	}
0: 
0: 	/** Return the names of columns for a given index number */
0: 	public String[] getIndexColumnNames(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)		
0: 			checkIndexNumber(indexNumber);
0: 		
0: 		if (!convertIdToLower)
0: 			return indexColumnNames[indexNumber];
0: 
0: 		String[] s = new String[indexColumnNames[indexNumber].length];
0: 		for (int i = 0; i < s.length; i++)
0: 			s[i] = StringUtil.SQLToLowerCase(indexColumnNames[indexNumber][i]);
0: 		return s;
0: 	}	
0: 
0: 	protected void checkIndexNumber(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0:   		{
0:   			if (!(indexNumber < indexCount))
0:   			{
0:   				SanityManager.THROWASSERT("indexNumber (" + 
0: 										  indexNumber + ") expected to be < " + indexCount);
0:   			}
0:   		}
0: 	}		
0: }
============================================================================