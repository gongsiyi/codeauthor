1:2bc809f: /*
5:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_QualifierTest
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.impl.store.access.conglomerate.*;
1:2bc809f: 
1:2bc809f: import java.util.Properties;
1:2bc809f: import java.util.HashSet;
1:bd34a3a: import java.util.List;
1:2bc809f: 
1:2bc809f: import java.io.PrintWriter;
1:2bc809f: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: import org.apache.derby.iapi.store.access.ConglomerateController;
1:2bc809f: import org.apache.derby.iapi.store.access.GroupFetchScanController;
1:2bc809f: import org.apache.derby.iapi.store.access.Qualifier;
1:2bc809f: import org.apache.derby.iapi.store.access.RowUtil;
1:2bc809f: import org.apache.derby.iapi.store.access.ScanController;
1:2bc809f: import org.apache.derby.iapi.store.access.TransactionController;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.DataValueDescriptor;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.Orderable;
1:2bc809f: import org.apache.derby.iapi.types.RowLocation;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.SQLLongint;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:2bc809f: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:2bc809f: import java.util.Enumeration;
1:2bc809f: 
1:2bc809f: public class T_QualifierTest 
1:2bc809f: {
1:2bc809f:     private String              init_conglomerate_type;
1:2bc809f:     private Properties          init_properties;
1:2bc809f:     private boolean             init_temporary;
1:2bc809f:     private HeaderPrintWriter   init_out;
1:2bc809f:     private int                 init_order = ORDER_NONE;
1:2bc809f: 
1:2bc809f:     public static final int ORDER_FORWARD  = 1;
1:2bc809f:     public static final int ORDER_BACKWARD = 2;
1:2bc809f:     public static final int ORDER_NONE     = 3;
1:2bc809f: 	public static final int ORDER_DESC = 4;  // ordered in descending order
1:2bc809f: 
1:2bc809f:     /* Constructor */
1:2bc809f:     public T_QualifierTest(
1:2bc809f:     String              conglomerate_type,
1:2bc809f:     Properties          properties,
1:2bc809f:     boolean             temporary,
1:2bc809f:     HeaderPrintWriter   out,
1:2bc809f:     int                 order)
1:2bc809f:     {
1:2bc809f:         this.init_conglomerate_type = conglomerate_type;
1:2bc809f:         this.init_properties        = properties;
1:2bc809f:         this.init_temporary         = temporary;
1:2bc809f:         this.init_out               = out;
1:2bc809f:         this.init_order             = order;
1:2bc809f: 
1:2bc809f:         return;
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**************************************************************************
1:2bc809f:      * Private/Protected methods of This class:
1:2bc809f:      **************************************************************************
1:2bc809f:      */
1:3f5c48a:     private static HashSet<Long> create_hash_set(
1:2bc809f:     int     expect_key,
1:2bc809f:     int     expect_numrows,
1:2bc809f: 	int 	order)
1:2bc809f:     {
1:3f5c48a:         HashSet<Long> set = new HashSet<Long>(10, 0.8f);
1:2bc809f: 
1:2bc809f:         int key_val = expect_key;
1:2bc809f:         for (int i = 0; i < expect_numrows; i++)
1:2bc809f:         {
1:39b3237:           set.add((long)key_val);
1:2bc809f: 			if (order == ORDER_DESC)
1:2bc809f: 				key_val--;
1:2bc809f: 			else
1:2bc809f: 				key_val++;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         return(set);
1:2bc809f:     }
1:2bc809f:     private static int flip_scan_op(int op)
1:2bc809f:     {
1:2bc809f:         int ret_op = -42;
1:2bc809f: 
1:2bc809f:         if (op == ScanController.GE)
1:2bc809f:             ret_op = ScanController.GT;
1:2bc809f:         else if (op == ScanController.GT)
1:2bc809f:             ret_op = ScanController.GE;
1:2bc809f: 
1:2bc809f:         return(ret_op);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test a single scan.
1:2bc809f:      */
1:2bc809f:     public static boolean t_scan(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	init_scan_template,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     lowest_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         boolean ret_val;
1:2bc809f: 
1:2bc809f:         // call scan which does next(), fetch(row)
1:2bc809f:         ret_val = t_scanNext(tc, conglomid, 
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does fetchNext(row), fetch(row)
1:2bc809f:         ret_val = t_scanFetchNext(tc, conglomid,  init_scan_template,
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does fetchNext(partial_row), fetch(partial_row)
1:2bc809f: 
1:2bc809f:         ret_val = t_scanFetchNextPartial(tc, conglomid, 
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does createBackingStoreHashtable()
1:2bc809f:         ret_val = t_scanFetchHashtable(tc, conglomid,
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does fetchNextGroup() - fetching 1 at a time.
1:2bc809f:         // this tests the edge case.
1:2bc809f:         ret_val = t_scanFetchNextGroup(tc, 1, conglomid, 
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does fetchNextGroup() - fetching 2 at a time.
1:2bc809f:         // this tests the general case of fetching N rows which is usually
1:2bc809f:         // less than the remaining rows in the result set.
1:2bc809f:         ret_val = t_scanFetchNextGroup(tc, 2, conglomid, 
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         // call scan which does fetchNextGroup() - fetching 1000 at a time.
1:2bc809f:         // this will get the entire result set in one fetch.
1:2bc809f:         ret_val = t_scanFetchNextGroup(tc, 1000, conglomid,
1:2bc809f:                 fetch_template, 
1:2bc809f:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:2bc809f:                 expect_numrows, lowest_expect_key, order);
1:2bc809f: 
1:2bc809f:         if (!ret_val)
1:2bc809f:             return(ret_val);
1:2bc809f: 
1:2bc809f:         return(ret_val);
1:2bc809f: 
1:2bc809f:     }
1:2bc809f:     private static boolean t_scanNext(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     input_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         HashSet set         = null;
1:2bc809f:         boolean ordered     = (order == T_QualifierTest.ORDER_FORWARD || 
1:2bc809f: 							   order == T_QualifierTest.ORDER_DESC);
1:2bc809f:         int     expect_key  = input_expect_key;
1:2bc809f: 
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Forward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         ScanController scan = 
1:2bc809f:             tc.openScan(
1:2bc809f:                 conglomid, false, 
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op);
1:2bc809f: 
1:2bc809f:         long key     = -42;
1:2bc809f:         int numrows = 0;
1:2bc809f: 
1:2bc809f:         while (scan.next())
1:2bc809f:         {
1:2bc809f:             scan.fetch(fetch_template);
1:2bc809f: 
1:2bc809f:             key = ((SQLLongint)(fetch_template[2])).getLong();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if (key != expect_key)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanNext) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f: 					if (order == ORDER_DESC)
1:2bc809f: 						expect_key--;
1:2bc809f: 					else
1:2bc809f: 						expect_key++;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:39b3237:                 if (!set.remove(key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanNext) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f: 
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanNext) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Backward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f:         /*
1:2bc809f: 
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // flip start and stop keys for backward scan and also flip 
1:2bc809f:         // start and stop operators (ie. GE->GT and GT->GE).
1:2bc809f:         scan = 
1:2bc809f:             tc.openBackwardScan(
1:2bc809f:                 conglomid, false, 
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 stop_key, flip_scan_op(stop_op),
1:2bc809f:                 qualifier,
1:2bc809f:                 start_key, flip_scan_op(start_op));
1:2bc809f: 
1:2bc809f:         key     = -42;
1:2bc809f:         numrows = 0;
1:2bc809f: 
1:2bc809f:         // rows are going to come back in reverse order in the ordered case.
1:2bc809f:         expect_key = input_expect_key + expect_numrows - 1;
1:2bc809f: 
1:2bc809f:         while (scan.next())
1:2bc809f:         {
1:2bc809f:             scan.fetch(fetch_template);
1:2bc809f: 
1:2bc809f:             key = ((SQLLongint)(fetch_template[2])).getLong();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if (key != expect_key)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanNext-backward) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f:                     expect_key--;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
7:2bc809f:                 if (!set.remove(new Long(key)))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanNext-backward) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanNext-backward) wrong num of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f:         */
1:2bc809f: 
1:2bc809f:         return(true);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test scan which does FetchNext with all of the fields.
1:2bc809f:      * <p>
1:2bc809f:      * FetchNext() may be optimized by the underlying scan code to try and
1:2bc809f:      * not do multiple fetches of the same row for the user, but if the user
1:2bc809f:      * asks for one column, but the stop position depends on the whole row
1:2bc809f:      * this optimization is not possible.
1:2bc809f:      * <p>
1:2bc809f:      *
1:2bc809f: 	 * @return Whether the test succeeded or not.
1:2bc809f:      *
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     public static boolean t_scanFetchNext(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	init_scan_template,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     input_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         HashSet set         = null;
1:2bc809f:         boolean ordered     = (order == ORDER_FORWARD || order == ORDER_DESC);
1:2bc809f: 
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Forward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         ScanController scan = 
1:2bc809f:             tc.openScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op);
1:2bc809f: 
1:2bc809f:         int  expect_key = input_expect_key;
1:2bc809f:         long key        = -42;
1:2bc809f:         long numrows    = 0;
1:2bc809f: 
1:2bc809f:         while (scan.fetchNext(fetch_template))
1:2bc809f:         {
1:2bc809f:             scan.fetch(init_scan_template);
1:2bc809f: 
1:2bc809f:             // make sure all columns from fetchNext() match subsequent fetch().
1:2bc809f:             for (int i = 0; i < init_scan_template.length; i++)
1:2bc809f:             {
1:2bc809f:                 if ((fetch_template[i]).compare(
1:2bc809f:                         (init_scan_template[i])) != 0)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                               fetch_template[i] + ")" + "but got (" + 
1:2bc809f:                               init_scan_template[i] + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f: 
1:2bc809f:             // see if we are getting the right keys.
1:2bc809f:             key = ((SQLLongint)(init_scan_template[2])).getLong();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if (key != expect_key)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f: 					if (order == ORDER_DESC)
1:2bc809f: 						expect_key--;
1:2bc809f: 					else
1:2bc809f: 						expect_key++;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:39b3237:                 if (!set.remove(key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f: 
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Backward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         /*
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan = 
1:2bc809f:             tc.openBackwardScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 stop_key, flip_scan_op(stop_op),
1:2bc809f:                 qualifier,
1:2bc809f:                 start_key, flip_scan_op(start_op));
1:2bc809f: 
1:2bc809f:         expect_key = input_expect_key + expect_numrows - 1;
1:2bc809f:         key        = -42;
1:2bc809f:         numrows    = 0;
1:2bc809f: 
1:2bc809f:         while (scan.fetchNext(fetch_template))
1:2bc809f:         {
1:2bc809f:             scan.fetch(init_scan_template);
1:2bc809f: 
1:2bc809f:             // make sure all columns from fetchNext() match subsequent fetch().
1:2bc809f:             for (int i = 0; i < init_scan_template.length; i++)
1:2bc809f:             {
1:2bc809f:                 if (((Orderable)fetch_template[i]).compare(
1:2bc809f:                         ((Orderable)init_scan_template[i])) != 0)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                               fetch_template[i] + ")" + "but got (" + 
1:2bc809f:                               init_scan_template[i] + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f: 
1:2bc809f:             // see if we are getting the right keys.
1:2bc809f:             key = ((SQLLongint)(init_scan_template[2])).getLong();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if (key != expect_key)
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f:                     expect_key--;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:2bc809f:                 if (!set.remove(new Long(key)))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                               expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f: 
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f:         */
1:2bc809f: 
1:2bc809f:         return(true);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test scan which does FetchNextGroup with all of the fields.
1:2bc809f:      * <p>
1:2bc809f:      *
1:2bc809f: 	 * @return Whether the test succeeded or not.
1:2bc809f:      *
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     public static boolean t_scanFetchNextGroup(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     int                     group_size,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     input_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         HashSet set = null;
1:2bc809f:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1:2bc809f: 
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Forward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         GroupFetchScanController scan = 
1:2bc809f:             tc.openGroupFetchScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op);
1:2bc809f: 
1:2bc809f:         // create an array of "group_size" rows to use in the fetch group call.
1:2bc809f:         DataValueDescriptor[][] row_array = 
1:2bc809f:             new DataValueDescriptor[group_size][];
1:2bc809f:         row_array[0] = TemplateRow.newRow(fetch_template);
1:2bc809f: 
1:2bc809f:         int  expect_key         = input_expect_key;
1:2bc809f:         long key                = -42;
1:2bc809f:         long numrows            = 0;
1:2bc809f:         int  group_row_count    = 0;
1:2bc809f: 
1:2bc809f:         // loop asking for "group_size" rows at a time.
1:2bc809f:         while ((group_row_count = 
1:2bc809f:                     scan.fetchNextGroup(row_array, (RowLocation[]) null)) != 0)
1:2bc809f:         {
1:2bc809f: 
1:2bc809f:             // loop through the rows returned into the row_array.
1:2bc809f:             for (int i = 0; i < group_row_count; i++)
1:2bc809f:             {
1:2bc809f:                 // see if we are getting the right keys.
1:2bc809f:                 key = ((SQLLongint)(row_array[i][2])).getLong();
1:2bc809f: 
1:2bc809f:                 if (ordered)
1:2bc809f:                 {
1:2bc809f:                     if (key != expect_key)
1:2bc809f:                     {
1:2bc809f:                         return(fail(
1:2bc809f:                             "(t_scanFetchNextGroup-forward) wrong key, expect (" + 
1:2bc809f:                             expect_key + ")" + "but got (" + key + 
1:2bc809f:                             "). num rows = " + numrows));
1:2bc809f:                     }
1:2bc809f:                     else
1:2bc809f:                     {
1:2bc809f: 						if (order == ORDER_DESC)
1:2bc809f: 							expect_key--;
1:2bc809f: 						else
1:2bc809f: 							expect_key++;
1:2bc809f:                     }
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:39b3237:                     if (!set.remove(key))
1:2bc809f:                     {
1:2bc809f:                         return(fail(
1:2bc809f:                             "(t_scanFetchNextGroup-forward) wrong key, expected (" + 
1:2bc809f:                             expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                     }
1:2bc809f:                 }
1:2bc809f:                 numrows++;
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(
1:2bc809f:                 fail("(t_scanFetchNextGroup-forward) wrong number of rows. Expected " +
1:2bc809f:                 expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Backward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         /*
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan = 
1:2bc809f:             tc.openGroupFetchBackwardScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 stop_key, flip_scan_op(stop_op),
1:2bc809f:                 qualifier,
1:2bc809f:                 start_key, flip_scan_op(start_op));
1:2bc809f: 
1:2bc809f:         // create an array of "group_size" rows to use in the fetch group call.
1:2bc809f:         expect_key      = input_expect_key + expect_numrows - 1;
1:2bc809f:         key             = -42;
1:2bc809f:         numrows         = 0;
1:2bc809f:         group_row_count = 0;
1:2bc809f: 
1:2bc809f:         // loop asking for "group_size" rows at a time.
1:2bc809f:         while ((group_row_count = 
1:2bc809f:                     scan.fetchNextGroup(row_array, (RowLocation[]) null)) != 0)
1:2bc809f:         {
1:2bc809f:             // loop through the rows returned into the row_array.
1:2bc809f:             for (int i = 0; i < group_row_count; i++)
1:2bc809f:             {
1:2bc809f:                 // see if we are getting the right keys.
1:2bc809f:                 key = ((SQLLongint)(row_array[i][2])).getLong();
1:2bc809f: 
1:2bc809f:                 if (ordered)
1:2bc809f:                 {
1:2bc809f:                     if (key != expect_key)
1:2bc809f:                     {
1:2bc809f:                         return(fail(
1:2bc809f:                             "(t_scanFetchNextGroup-backward) wrong key, expected (" + 
1:2bc809f:                             expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                     }
1:2bc809f:                     else
1:2bc809f:                     {
1:2bc809f:                         expect_key--;
1:2bc809f:                     }
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f:                     if (!set.remove(new Long(key)))
1:2bc809f:                     {
1:2bc809f:                         return(fail(
1:2bc809f:                             "(t_scanFetchNextGroup-backward) wrong key, expected (" + 
1:2bc809f:                             expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                     }
1:2bc809f:                 }
1:2bc809f:                 numrows++;
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(
1:2bc809f:                 fail("(t_scanFetchNextGroup-backward) wrong number of rows. Expected " +
1:2bc809f:                 expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         */
1:2bc809f: 
1:2bc809f:         return(true);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test scan which does FetchNext with subset of fields.
1:2bc809f:      * <p>
1:2bc809f:      * FetchNext() may be optimized by the underlying scan code to try and
1:2bc809f:      * not do multiple fetches of the same row for the user, but if the user
1:2bc809f:      * asks for one column, but the stop position depends on the whole row
1:2bc809f:      * this optimization is not possible.
1:2bc809f:      * <p>
1:2bc809f:      *
1:2bc809f: 	 * @return Whether the test succeeded or not.
1:2bc809f:      *
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     public static boolean t_scanFetchNextPartial(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     input_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         HashSet set = null;
1:2bc809f:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * setup shared by both.
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         // In the fetchNext call only ask the minimum set of columns 
1:2bc809f:         // necessary, which is the union of the "key" (col[2]) and other
1:2bc809f:         // columns referenced in the qualifier list.
1:2bc809f:         FormatableBitSet fetch_row_validColumns = RowUtil.getQualifierBitSet(qualifier);
1:2bc809f: 
1:2bc809f:         // now add in column 2, as we always need the key field.
1:2bc809f: 		fetch_row_validColumns.grow(3);// grow to length of 3 
1:2bc809f:         fetch_row_validColumns.set(2);
1:2bc809f: 
1:2bc809f:         // add in any fields in start and stop positions
1:2bc809f:         if (start_key != null)
1:2bc809f:         {
1:2bc809f:             for (int i = 0; i < start_key.length; i++)
1:2bc809f:             {
1:2bc809f:                 fetch_row_validColumns.set(i);
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f:         if (stop_key != null)
1:2bc809f:         {
1:2bc809f:             for (int i = 0; i < stop_key.length; i++)
1:2bc809f:             {
1:2bc809f:                 fetch_row_validColumns.set(i);
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // point key at the right column in the fetch_template
1:2bc809f:         SQLLongint key_column = (SQLLongint) fetch_template[2];
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Forward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         ScanController scan = 
1:2bc809f:             tc.openScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) fetch_row_validColumns, 
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op);
1:2bc809f: 
1:2bc809f:         int  expect_key = input_expect_key;
1:2bc809f:         long key        = -42;
1:2bc809f:         long key2       = -42;
1:2bc809f:         long numrows    = 0;
1:2bc809f: 
1:2bc809f:         while (scan.fetchNext(fetch_template))
1:2bc809f:         {
1:2bc809f:             // see if we are getting the right keys.
1:2bc809f:             key = key_column.getLong();
1:2bc809f: 
1:2bc809f:             // make sure a subsequent fetch also works.
1:2bc809f:             key_column.setValue(-42);
1:2bc809f: 
1:2bc809f:             scan.fetch(fetch_template);
1:2bc809f:             key2 = key_column.getLong();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if ((key != expect_key) || (key2 != expect_key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f: 					if (order == ORDER_DESC)
1:2bc809f: 						expect_key--;
1:2bc809f: 					else
1:2bc809f: 						expect_key++;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:39b3237:                 if (!set.remove(key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f: 
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         /**********************************************************************
1:2bc809f:          * Backward scan test case
1:2bc809f:          **********************************************************************
1:2bc809f:          */
1:2bc809f: 
1:2bc809f:         /*
1:2bc809f:         if (!ordered)
1:2bc809f:         {
1:2bc809f:             set = create_hash_set(expect_key, expect_numrows, order);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan = 
1:2bc809f:             tc.openBackwardScan(
1:2bc809f:                 conglomid, false,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) fetch_row_validColumns, 
1:2bc809f:                 stop_key, flip_scan_op(stop_op),
1:2bc809f:                 qualifier,
1:2bc809f:                 start_key, flip_scan_op(start_op));
1:2bc809f: 
1:2bc809f:         expect_key  = input_expect_key + expect_numrows - 1;
1:2bc809f:         key         = -42;
1:2bc809f:         key2        = -42;
1:2bc809f:         numrows     = 0;
1:2bc809f: 
1:2bc809f:         while (scan.fetchNext(fetch_template))
1:2bc809f:         {
1:2bc809f:             // see if we are getting the right keys.
1:2bc809f:             key = key_column.getValue();
1:2bc809f: 
1:2bc809f:             // make sure a subsequent fetch also works.
1:2bc809f:             key_column.setValue(-42);
1:2bc809f: 
1:2bc809f:             scan.fetch(fetch_template);
1:2bc809f:             key2 = key_column.getValue();
1:2bc809f: 
1:2bc809f:             if (ordered)
1:2bc809f:             {
1:2bc809f:                 if ((key != expect_key) || (key2 != expect_key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 else
1:2bc809f:                 {
1:2bc809f:                     expect_key--;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:2bc809f:                 if (!set.remove(new Long(key)))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:2bc809f:                              expect_key + ")" + "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             numrows++;
1:2bc809f: 
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         scan.close();
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f:         */
1:2bc809f: 
1:2bc809f:         return(true);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test scan which does FetchSet.
1:2bc809f:      * <p>
1:2bc809f:      * FetchSet() returns the entire result set in the hash table.
1:2bc809f:      * <p>
1:2bc809f:      *
1:2bc809f: 	 * @return Whether the test succeeded or not.
1:2bc809f:      *
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     public static boolean t_scanFetchHashtable(
1:2bc809f:     TransactionController   tc,
1:2bc809f:     long                    conglomid,
1:2bc809f:     DataValueDescriptor[]	fetch_template,
1:2bc809f:     DataValueDescriptor[]	start_key, 
1:2bc809f:     int                     start_op,
1:2bc809f:     Qualifier               qualifier[][],
1:2bc809f:     DataValueDescriptor[]	stop_key,
1:2bc809f:     int                     stop_op,
1:2bc809f:     int                     expect_numrows,
1:2bc809f:     int                     input_expect_key,
1:2bc809f:     int                     order)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         HashSet set = null;
1:2bc809f:         long    key;
1:2bc809f:         long numrows = 0;
1:2bc809f:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1:2bc809f: 
1:2bc809f:         set = create_hash_set(input_expect_key, expect_numrows, order);
1:2bc809f: 
1:2bc809f:         // select entire data set into a hash table, with first column key 
1:2bc809f: 		int[] keyColumns = new int[1];
1:2bc809f: 		keyColumns[0] = 0;
1:2bc809f: 
1:2bc809f:         BackingStoreHashtable result_set = 
1:2bc809f:             tc.createBackingStoreHashtableFromScan(
1:2bc809f:                 conglomid, 
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_TABLE,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op,
1:2bc809f:                 -1,             // no limit on total rows.
1:2bc809f:                 keyColumns,     // first column is hash key column
1:2bc809f:                 false,          // don't remove duplicates
1:2bc809f:                 -1,             // no estimate of rows
1:2bc809f:                 -1,             // put it all into memory
1:2bc809f:                 -1,             // use default initial capacity
1:2bc809f:                 -1,             // use default load factor
1:1e762f5:                 false,          // don't maintain runtime statistics
1:1e762f5:                 false,          // don't skip null key columns
1:e81e52c:                 false,          // don't keep after commit
1:e81e52c:                 false);         // don't include row locations
1:2bc809f: 
1:2bc809f:         // make sure the expected result set is the same as the actual result
1:2bc809f:         // set.
1:2bc809f: 
1:df4020d:         Enumeration e = result_set.elements();
1:2bc809f: 
1:df4020d:         while (e.hasMoreElements())
1:2bc809f:         {
1:2bc809f:             Object   obj;
1:2bc809f:             DataValueDescriptor[] row = null;
1:2bc809f: 
1:df4020d:             if ((obj = e.nextElement()) instanceof DataValueDescriptor[] )
1:2bc809f:             {
1:2bc809f:                 row = (DataValueDescriptor[] ) obj;
1:2bc809f:                 key = ((SQLLongint)(row[2])).getLong();
1:2bc809f: 
1:39b3237:                 if (!set.remove(key))
1:2bc809f:                 {
1:2bc809f:                     return(
1:2bc809f:                         fail("(t_scanFetchHashtable-obj) wrong key, expected (" + 
1:2bc809f:                               input_expect_key + ")" + 
1:2bc809f:                               "but got (" + key + ")."));
1:2bc809f:                 }
1:2bc809f:                 numrows++;
1:2bc809f:             }
1:bd34a3a:             else if (obj instanceof List)
1:2bc809f:             {
1:bd34a3a:                 List row_vect = (List) obj;
1:2bc809f: 
1:2bc809f:                 for (int i = 0; i < row_vect.size(); i++)
1:2bc809f:                 {
1:bd34a3a:                     row = (DataValueDescriptor[]) row_vect.get(i);
1:2bc809f: 
1:2bc809f:                     key = ((SQLLongint)(row[2])).getLong();
1:2bc809f: 
1:39b3237:                     if (!set.remove(key))
1:2bc809f:                     {
1:2bc809f:                         return(fail(
1:2bc809f:                             "(t_scanFetchHashtable-vector) wrong key, expected (" + 
1:2bc809f:                              input_expect_key + ")" + 
1:2bc809f:                              "but got (" + key + ")."));
1:2bc809f:                     }
1:2bc809f:                     numrows++;
1:2bc809f:                 }
1:2bc809f:             }
1:2bc809f:             else
1:2bc809f:             {
1:2bc809f:                 return(fail(
1:2bc809f:                     "(t_scanFetchHashtable) got bad type for data: " + obj));
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(
1:2bc809f:                 fail(
1:2bc809f:                     "(t_scanFetchHashtable) wrong number of rows. Expected " +
1:2bc809f:                      expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         result_set.close();
1:2bc809f: 
1:2bc809f:         // select entire data set into a hash table, with key being 
1:2bc809f:         // the third column, which is the unique id used to verify the
1:2bc809f:         // right result set is being returned.:
1:2bc809f: 
1:2bc809f:         // open a new scan
1:2bc809f: 		keyColumns[0] = 2;
1:2bc809f: 
1:2bc809f:         result_set = 
1:2bc809f:             tc.createBackingStoreHashtableFromScan(
1:2bc809f:                 conglomid,
1:2bc809f:                 0,
1:2bc809f:                 TransactionController.MODE_TABLE,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null,
1:2bc809f:                 start_key, start_op,
1:2bc809f:                 qualifier,
1:2bc809f:                 stop_key, stop_op,
1:2bc809f:                 -1,             // no limit on total rows.
1:2bc809f:                 keyColumns,              // third column is hash key column
1:2bc809f:                 false,          // don't remove duplicates
1:2bc809f:                 -1,             // no estimate of rows
1:2bc809f:                 -1,             // put it all into memory
1:2bc809f:                 -1,             // use default initial capacity
1:2bc809f:                 -1,             // use default load factor
2:2bc809f:                 false,         // don't maintain runtime statistics
1:1e762f5: 				false,			// don't skip null key columns
1:e81e52c:                 false,          // don't keep after commit
1:e81e52c:                 false);         // don't include row locations
1:2bc809f: 
1:2bc809f:         Object removed_obj;
1:2bc809f:         for (numrows = 0; numrows < expect_numrows; numrows++)
1:2bc809f:         {
1:2bc809f: 			long exp_key ;
1:2bc809f: 			if (order == ORDER_DESC)
1:2bc809f: 				exp_key = input_expect_key - numrows;
1:2bc809f: 			else
1:2bc809f: 				exp_key = input_expect_key + numrows;
1:2bc809f:             if ((removed_obj = 
1:2bc809f:                     result_set.remove(
1:2bc809f:                         new SQLLongint(exp_key))) == null)
1:2bc809f:             {
1:2bc809f:                 fail("(t_scanFetchHashtable-2-vector) wrong key, expected (" + 
1:2bc809f:                       (exp_key) + ")" + 
1:2bc809f:                       "but did not find it.");
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (numrows != expect_numrows)
1:2bc809f:         {
1:2bc809f:             return(fail("(t_scanFetchHashtable-2) wrong number of rows. Expected " +
1:2bc809f:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         return(true);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /* public methods of T_QualifierTest */
1:2bc809f: 
1:2bc809f:     public boolean t_testqual(TransactionController tc)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         boolean                 ret_val             = true;
1:2bc809f:         DataValueDescriptor[]   openscan_template   = null;
1:2bc809f:         DataValueDescriptor[]   fetch_template      = null;
1:2bc809f:         DataValueDescriptor[]   base_row            = null;
1:2bc809f:         T_SecondaryIndexRow     index_row           = null;
1:2bc809f:         long                    value               = -1;
1:2bc809f:         long        col1[]  = { 1,  3,  4,  4,  4,  5,  5,  5,  6,  7,  9};
1:2bc809f:         long        col2[]  = { 1,  1,  2,  4,  6,  2,  4,  6,  1,  1,  1};
1:2bc809f:         long        col3[]  = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
1:2bc809f:         long                    conglomid;
1:2bc809f:         long                    base_conglomid;
1:2bc809f:         long                    index_conglomid;
1:2bc809f:         ConglomerateController  base_cc             = null;
1:2bc809f:         ConglomerateController  index_cc            = null;
1:2bc809f:         RowLocation             base_rowloc         = null;
1:2bc809f: 
1:2bc809f:         base_row = TemplateRow.newU8Row(3);
1:2bc809f: 
1:2bc809f:         if (init_conglomerate_type.compareTo("BTREE") == 0)
1:2bc809f:         {
1:2bc809f:             base_conglomid = 
1:b61f876:                 tc.createConglomerate(
1:b61f876:                     "heap", base_row, null,  null, null, 
1:2bc809f:                     TransactionController.IS_DEFAULT);
1:2bc809f: 
1:2bc809f:             index_row = new T_SecondaryIndexRow();
1:2bc809f: 
1:2bc809f:             base_cc = 
1:2bc809f:                 tc.openConglomerate(
1:2bc809f:                     base_conglomid,
1:2bc809f:                     false,
1:2bc809f:                     TransactionController.OPENMODE_FORUPDATE,
1:2bc809f:                     TransactionController.MODE_RECORD,
1:2bc809f:                     TransactionController.ISOLATION_SERIALIZABLE);
1:2bc809f: 
1:2bc809f:             base_rowloc = base_cc.newRowLocationTemplate();
1:2bc809f: 
1:2bc809f:             index_row.init(base_row, base_rowloc, 4);
1:2bc809f: 
1:2bc809f:             index_conglomid = 
1:2bc809f:                 tc.createConglomerate(
1:2bc809f:                     init_conglomerate_type, index_row.getRow(), 
1:2bc809f:                     null,
1:b61f876:                     null,
2:2bc809f: 					init_properties,
2:2bc809f: 					init_temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT);
1:2bc809f: 
1:2bc809f:             index_cc =	
1:2bc809f:                 tc.openConglomerate(
1:2bc809f:                     index_conglomid,
1:2bc809f:                     false,
1:2bc809f:                     TransactionController.OPENMODE_FORUPDATE,
1:2bc809f:                     TransactionController.MODE_RECORD,
1:2bc809f:                     TransactionController.ISOLATION_SERIALIZABLE);
1:2bc809f: 
1:2bc809f:             conglomid = index_conglomid;
1:2bc809f:             openscan_template = index_row.getRow();
1:2bc809f: 
1:2bc809f:             // make another template
1:2bc809f:             T_SecondaryIndexRow fetch_index_row = new T_SecondaryIndexRow();
1:2bc809f:             fetch_index_row.init(
1:2bc809f:                 TemplateRow.newU8Row(3),
1:2bc809f:                 base_cc.newRowLocationTemplate(), 
1:2bc809f:                 4);
1:2bc809f:             fetch_template = fetch_index_row.getRow();
1:2bc809f:         }
1:2bc809f:         else
1:2bc809f:         {
1:2bc809f:             base_conglomid = 
1:2bc809f:                 tc.createConglomerate(
1:b61f876:                     init_conglomerate_type, 
1:b61f876:                     base_row, 
1:b61f876:                     null,                   // default order 
1:b61f876:                     null,                   // default collation
1:b61f876:                     init_properties,
1:b61f876:                     init_temporary ? 
1:b61f876:                         TransactionController.IS_TEMPORARY : 
1:b61f876:                         TransactionController.IS_DEFAULT);
1:2bc809f: 
1:2bc809f:             base_cc =	
1:2bc809f:                 tc.openConglomerate(
1:2bc809f:                     base_conglomid,
1:2bc809f:                     false,
1:2bc809f:                     TransactionController.OPENMODE_FORUPDATE,
1:2bc809f:                     TransactionController.MODE_RECORD,
1:2bc809f:                     TransactionController.ISOLATION_SERIALIZABLE);
1:2bc809f: 
1:2bc809f:             base_rowloc = base_cc.newRowLocationTemplate();
1:2bc809f: 
1:2bc809f:             conglomid = base_conglomid;
1:2bc809f:             openscan_template = base_row;
1:2bc809f:             fetch_template    = TemplateRow.newU8Row(3);
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // insert them in reverse order just to make sure btree is sorting them
1:2bc809f:         for (int i = col1.length - 1; i >= 0; i--)
1:2bc809f:         {
1:2bc809f:             ((SQLLongint)(base_row[0])).setValue(col1[i]);
1:2bc809f:             ((SQLLongint)(base_row[1])).setValue(col2[i]);
1:2bc809f:             ((SQLLongint)(base_row[2])).setValue(col3[i]);
1:2bc809f: 
1:2bc809f:             base_cc.insertAndFetchLocation(base_row, base_rowloc);
1:2bc809f: 
1:2bc809f:             if (init_conglomerate_type.compareTo("BTREE") == 0)
1:2bc809f:             {
1:2bc809f:                 index_cc.insert(index_row.getRow());
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         tc.commit();
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // run through a predicates as described in the openScan() interface,
1:2bc809f:         // and implement them in qualifiers rather than start and stop.
1:2bc809f:         //
1:2bc809f: 
1:2bc809f:         // Use the following SQLLongint's for qualifier values //
1:2bc809f:         SQLLongint qual_col1 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col2 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col3 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col4 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col5 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col6 = new SQLLongint(-1);
1:2bc809f:         SQLLongint qual_col7 = new SQLLongint(-1);
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // test predicate x = 5
1:2bc809f:         //
1:2bc809f:         //     result set should be: {5,2,16}, {5,4,17}, {5,6,18}
1:2bc809f:         //
1:2bc809f:         progress("qual scan (x = 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         Qualifier q1[][] = 
1:2bc809f:         {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                             false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA, 
1:2bc809f:                    q1,
1:2bc809f:                    null,  ScanController.NA,
1:2bc809f:                    3, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f:                    
1:2bc809f:         //  +---------------------------------------------------------+
1:2bc809f:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:2bc809f:         //  |      |value|op |value|op |              |(serialization)|
1:2bc809f:         //  +------+-----+---+-----+---+--------------+---------------+
1:2bc809f:         //  |x > 5 |{5}  |GT |null |   |{6,1} .. {9,1}|{5,6} .. {9,1} |
1:2bc809f:         //  +-----------------------------------------+---------------+
1:2bc809f:         progress("qual scan (x > 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         Qualifier q2[][] = 
1:2bc809f:         {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(
1:2bc809f:                     0, qual_col1, Orderable.ORDER_OP_LESSOREQUALS, 
1:2bc809f:                     true, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA, 
1:2bc809f:                    q2,
1:2bc809f:                    null,  ScanController.NA,
1:2bc809f:                    3, 19, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +---------------------------------------------------------+
1:2bc809f:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:2bc809f:         //  |      |value|op |value|op |              |(serialization)|
1:2bc809f:         //  +------+-----+---+-----+---+--------------+---------------+
1:2bc809f:         //  |x >= 5|{5}  |GE |null |   |{5,2} .. {9,1}|{4,6} .. {9,1} |
1:2bc809f:         //  +-----------------------------------------+---------------+
1:2bc809f:         progress("qual scan (x >= 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         Qualifier q3[][] = 
1:2bc809f:         {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                                 Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                                 true, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA, 
1:2bc809f:                    q3,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    6, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //
1:2bc809f:         //  +---------------------------------------------------------+
1:2bc809f:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:2bc809f:         //  |      |value|op |value|op |              |(serialization)|
1:2bc809f:         //  +------+-----+---+-----+---+--------------+---------------+
1:2bc809f:         //  |x <= 5|null |   |{5}  |GT |{1,1} .. {5,6}|first .. {5,6} |
1:2bc809f:         //  +-----------------------------------------+---------------+
1:2bc809f:         progress("qual scan (x <= 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         Qualifier q4[][] = 
1:2bc809f:         {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                                 Orderable.ORDER_OP_LESSOREQUALS, 
1:2bc809f:                                 false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA, 
1:2bc809f:                    q4,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    8, 11, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //
1:2bc809f:         //  +---------------------------------------------------------+
1:2bc809f:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:2bc809f:         //  |      |value|op |value|op |              |(serialization)|
1:2bc809f:         //  +------+-----+---+-----+---+--------------+---------------+
1:2bc809f:         // 	|x < 5 |null |   |{5}  |GE |{1,1} .. {4,6}|first .. {4,6} |
1:2bc809f:         //  +-----------------------------------------+---------------+
1:2bc809f:         progress("qual scan (x < 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         Qualifier q5[][] = 
1:2bc809f:         {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                                 Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                                 false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA, 
1:2bc809f:                    q5,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    5, 11, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f: 	    //  |x >= 5 and x <= 7|{5},  |GE|{7}  |GT|{5,2} .. {7,1}|{4,6} .. {7,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x >= 5 and x <= 7)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(7);
1:2bc809f:         Qualifier q6[][] = {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                             true, true, true),
1:2bc809f:                 new QualifierUtil(0, qual_col2,
1:2bc809f:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:2bc809f:                             false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q6,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    5, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // passing qualifier in q6[0][0], q6[0][1] should evaluate same as 
1:2bc809f:         // passing in q6[0][0], q6[1][0]
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f: 	    //  |x >= 5 and x <= 7|{5},  |GE|{7}  |GT|{5,2} .. {7,1}|{4,6} .. {7,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x >= 5 and x <= 7)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(7);
1:2bc809f:         Qualifier q6_2[][] = {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                             true, true, true)
1:2bc809f:             },
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col2,
1:2bc809f:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:2bc809f:                             false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q6_2,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    5, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f: 	    //  |x = 5 and y > 2  |{5,2} |GT|{5}  |GT|{5,4} .. {5,6}|{5,2} .. {9,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x = 5 and y > 2)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(2);
1:2bc809f:         Qualifier q7[][] = {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                             false, true, true),
1:2bc809f:                 new QualifierUtil(1, qual_col2,
1:2bc809f:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:2bc809f:                             true, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q7,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    2, 17, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f:         // 	|x = 5 and y >= 2 | {5,2}|GE| {5} |GT|{5,2} .. {5,6}|{4,6} .. {9,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x = 5 and y >= 2)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(2);
1:2bc809f:         Qualifier q8[][] = {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                             false, true, true),
1:2bc809f:                 new QualifierUtil(1, qual_col2,
1:2bc809f:                             Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                             true, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q8,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    3, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f:         // 	|x = 5 and y < 5  | {5}  |GE|{5,5}|GE|{5,2} .. {5,4}|{4,6} .. {5,4}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x = 5 and y < 5)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(5);
1:2bc809f:         Qualifier q9[][] = {
1:2bc809f:             { 
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                             false, true, true),
1:2bc809f:                 new QualifierUtil(1, qual_col1,
1:2bc809f:                             Orderable.ORDER_OP_LESSTHAN, 
1:2bc809f:                             false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q9,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    2, 16, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:2bc809f:         //  |                 |value|op |value|op |             |(serialized)  |
1:2bc809f:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:2bc809f:         // 	|x = 2            | {2}  |GE| {2} |GT|none          |{1,1} .. {1,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x = 2)");
1:2bc809f:         qual_col1.setValue(2);
1:2bc809f:         Qualifier q10[][] = {
1:2bc809f:             {
1:2bc809f:                 new QualifierUtil(0, qual_col1,
1:2bc809f:                                 Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                                 false, true, true)
1:2bc809f:             }
1:2bc809f:         };
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q10,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    0, 0, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:2bc809f:         //  |                |value|op |value|op |              |(serialized)  |
1:2bc809f:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:2bc809f:         // 	|x >= 5 or y = 6 | null|   | null|   |{4,6} .. {9,1}|{1,1} .. {9,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f:         progress("qual scan (x >= 5) or (y = 6)");
1:2bc809f:         qual_col1.setValue(5);
1:2bc809f:         qual_col2.setValue(6);
1:2bc809f:         Qualifier q11[][] =  new Qualifier[2][];
1:2bc809f:         q11[0] = new Qualifier[0];
1:2bc809f:         q11[1] = new Qualifier[2];
1:2bc809f: 
1:2bc809f:         q11[1][0] = 
1:2bc809f:                 new QualifierUtil(
1:2bc809f:                         0, qual_col1,
1:2bc809f:                         Orderable.ORDER_OP_GREATEROREQUALS, 
1:2bc809f:                         false, true, true);
1:2bc809f:         q11[1][1] = 
1:2bc809f:                 new QualifierUtil(
1:2bc809f:                         1, qual_col2,
1:2bc809f:                         Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                         false, true, true);
1:2bc809f:         
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q11,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    7, 15, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:2bc809f:         //  |                |value|op |value|op |              |(serialized)  |
1:2bc809f:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:2bc809f:         // 	|(x = 1 or y = 1 or y = 6)|
1:2bc809f:         // 	|     and        |
1:2bc809f:         // 	|(x > 5 or y = 1)|
1:2bc809f:         // 	|     and        |
1:2bc809f:         // 	|(x = 9 or x = 7)|null |   | null|   |{7,1} .. {9,1}|{1,1} .. {9,1}|
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f: 
1:2bc809f:         progress("qual scan (x = 1 or y = 1 or y = 6) and (x > 5 or y = 1) and (x = 9 or x = 7)");
1:2bc809f:         qual_col1.setValue(1);
1:2bc809f:         qual_col2.setValue(1);
1:2bc809f:         qual_col3.setValue(6);
1:2bc809f:         qual_col4.setValue(5);
1:2bc809f:         qual_col5.setValue(1);
1:2bc809f:         qual_col6.setValue(9);
1:2bc809f:         qual_col7.setValue(7);
1:2bc809f: 
1:2bc809f:         Qualifier q12[][] = new Qualifier[4][];
1:2bc809f:         q12[0] = new Qualifier[0];
1:2bc809f:         q12[1] = new Qualifier[3];
1:2bc809f:         q12[2] = new Qualifier[2];
1:2bc809f:         q12[3] = new Qualifier[2];
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         q12[1][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col1,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[1][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     1, qual_col2,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[1][2] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     1, qual_col3,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[2][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col4,
1:2bc809f:                     Orderable.ORDER_OP_GREATERTHAN, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[2][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     1, qual_col5,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[3][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col6,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q12[3][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col7,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f:         
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q12,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    2, 20, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         //  +------------------------------------------------------------------+
1:2bc809f:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:2bc809f:         //  |                |value|op |value|op |              |(serialized)  |
1:2bc809f:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:2bc809f:         // 	|(y = 4 or y = 1)|
1:2bc809f:         // 	|     and        |
1:2bc809f:         // 	|(x = 1 or x = 4 or x= 9)|
1:2bc809f:         // 	|     and        |
1:2bc809f:         // 	|(z = 15 or z = 14)|null |   | null|   |{4,4} .. {4,4}| ALL        |
1:2bc809f:         // 	+------------------------------------------------------------------+
1:2bc809f: 
1:2bc809f:         progress("qual scan (x = 1 or x = 4 or x= 9) and (y = 4 or y = 1) and (z = 15 or z = 14)");
1:2bc809f: 
1:2bc809f:         qual_col1.setValue(4);
1:2bc809f:         qual_col2.setValue(1);
1:2bc809f:         qual_col3.setValue(1);
1:2bc809f:         qual_col4.setValue(4);
1:2bc809f:         qual_col5.setValue(9);
1:2bc809f:         qual_col6.setValue(15);
1:2bc809f:         qual_col7.setValue(14);
1:2bc809f: 
1:2bc809f:         Qualifier q13[][] = new Qualifier[4][];
1:2bc809f:         q13[0] = new Qualifier[0];
1:2bc809f:         q13[1] = new Qualifier[2];
1:2bc809f:         q13[2] = new Qualifier[3];
1:2bc809f:         q13[3] = new Qualifier[2];
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         q13[1][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     1, qual_col1,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q13[1][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     1, qual_col2,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         q13[2][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col4,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q13[2][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col5,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q13[2][2] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     0, qual_col3,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q13[3][0] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     2, qual_col6,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f: 
1:2bc809f:         q13[3][1] = 
1:2bc809f:             new QualifierUtil(
1:2bc809f:                     2, qual_col7,
1:2bc809f:                     Orderable.ORDER_OP_EQUALS, 
1:2bc809f:                     false, true, true);
1:2bc809f:         
1:2bc809f:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    q13,
1:2bc809f:                    null, ScanController.NA,
1:2bc809f:                    1, 14, init_order))
1:2bc809f:         {
1:2bc809f:             ret_val = false;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         tc.commit();
1:2bc809f:         progress("Ending t_testqual");
1:2bc809f: 
1:2bc809f:         return(ret_val);
1:2bc809f:     }
1:2bc809f: 
1:2bc809f: 	private static boolean fail(String msg)
1:2bc809f:         throws T_Fail
1:2bc809f: 	{
1:2bc809f:         throw T_Fail.testFailMsg("T_QualifierTest failure: " + msg);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private void progress(String msg)
1:2bc809f: 	{
1:2bc809f: 		this.init_out.println("T_QualifierTest progress: " + msg);
1:2bc809f: 	}
1:2bc809f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:           set.add((long)key_val);
/////////////////////////////////////////////////////////////////////////
1:                 if (!set.remove(key))
/////////////////////////////////////////////////////////////////////////
1:                 if (!set.remove(key))
/////////////////////////////////////////////////////////////////////////
1:                     if (!set.remove(key))
/////////////////////////////////////////////////////////////////////////
1:                 if (!set.remove(key))
/////////////////////////////////////////////////////////////////////////
1:                 if (!set.remove(key))
/////////////////////////////////////////////////////////////////////////
1:                     if (!set.remove(key))
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1:                 false,          // don't keep after commit
1:                 false);         // don't include row locations
/////////////////////////////////////////////////////////////////////////
1:                 false,          // don't keep after commit
1:                 false);         // don't include row locations
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:     private static HashSet<Long> create_hash_set(
1:         HashSet<Long> set = new HashSet<Long>(10, 0.8f);
commit:bd34a3a
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             else if (obj instanceof List)
1:                 List row_vect = (List) obj;
1:                     row = (DataValueDescriptor[]) row_vect.get(i);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1e762f5
/////////////////////////////////////////////////////////////////////////
1:                 false,          // don't maintain runtime statistics
1:                 false,          // don't skip null key columns
0:                 false);         // don't keep after commit
/////////////////////////////////////////////////////////////////////////
1: 				false,			// don't skip null key columns
0:                 false);         // don't keep after commit
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:                     "heap", base_row, null,  null, null, 
/////////////////////////////////////////////////////////////////////////
1:                     null,
/////////////////////////////////////////////////////////////////////////
1:                 tc.createConglomerate(
1:                     init_conglomerate_type, 
1:                     base_row, 
1:                     null,                   // default order 
1:                     null,                   // default collation
1:                     init_properties,
1:                     init_temporary ? 
1:                         TransactionController.IS_TEMPORARY : 
1:                         TransactionController.IS_DEFAULT);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:         Enumeration e = result_set.elements();
1:         while (e.hasMoreElements())
1:             if ((obj = e.nextElement()) instanceof DataValueDescriptor[] )
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_QualifierTest
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.*;
1: 
1: import java.util.Properties;
1: import java.util.HashSet;
1: 
1: import java.io.PrintWriter;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.GroupFetchScanController;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.types.SQLLongint;
1: 
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import java.util.Enumeration;
0: import java.util.Vector;
1: 
1: public class T_QualifierTest 
1: {
1:     private String              init_conglomerate_type;
1:     private Properties          init_properties;
1:     private boolean             init_temporary;
1:     private HeaderPrintWriter   init_out;
1:     private int                 init_order = ORDER_NONE;
1: 
1:     public static final int ORDER_FORWARD  = 1;
1:     public static final int ORDER_BACKWARD = 2;
1:     public static final int ORDER_NONE     = 3;
1: 	public static final int ORDER_DESC = 4;  // ordered in descending order
1: 
1:     /* Constructor */
1:     public T_QualifierTest(
1:     String              conglomerate_type,
1:     Properties          properties,
1:     boolean             temporary,
1:     HeaderPrintWriter   out,
1:     int                 order)
1:     {
1:         this.init_conglomerate_type = conglomerate_type;
1:         this.init_properties        = properties;
1:         this.init_temporary         = temporary;
1:         this.init_out               = out;
1:         this.init_order             = order;
1: 
1:         return;
1:     }
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
0:     private static HashSet create_hash_set(
1:     int     expect_key,
1:     int     expect_numrows,
1: 	int 	order)
1:     {
0:         HashSet set = new HashSet(10, 0.8f);
1: 
1:         int key_val = expect_key;
1:         for (int i = 0; i < expect_numrows; i++)
1:         {
0:             set.add(new Long(key_val));
1: 			if (order == ORDER_DESC)
1: 				key_val--;
1: 			else
1: 				key_val++;
1:         }
1: 
1:         return(set);
1:     }
1:     private static int flip_scan_op(int op)
1:     {
1:         int ret_op = -42;
1: 
1:         if (op == ScanController.GE)
1:             ret_op = ScanController.GT;
1:         else if (op == ScanController.GT)
1:             ret_op = ScanController.GE;
1: 
1:         return(ret_op);
1:     }
1: 
1:     /**
1:      * Test a single scan.
1:      */
1:     public static boolean t_scan(
1:     TransactionController   tc,
1:     long                    conglomid,
1:     DataValueDescriptor[]	init_scan_template,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     lowest_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         boolean ret_val;
1: 
1:         // call scan which does next(), fetch(row)
1:         ret_val = t_scanNext(tc, conglomid, 
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does fetchNext(row), fetch(row)
1:         ret_val = t_scanFetchNext(tc, conglomid,  init_scan_template,
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does fetchNext(partial_row), fetch(partial_row)
1: 
1:         ret_val = t_scanFetchNextPartial(tc, conglomid, 
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does createBackingStoreHashtable()
1:         ret_val = t_scanFetchHashtable(tc, conglomid,
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does fetchNextGroup() - fetching 1 at a time.
1:         // this tests the edge case.
1:         ret_val = t_scanFetchNextGroup(tc, 1, conglomid, 
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does fetchNextGroup() - fetching 2 at a time.
1:         // this tests the general case of fetching N rows which is usually
1:         // less than the remaining rows in the result set.
1:         ret_val = t_scanFetchNextGroup(tc, 2, conglomid, 
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         // call scan which does fetchNextGroup() - fetching 1000 at a time.
1:         // this will get the entire result set in one fetch.
1:         ret_val = t_scanFetchNextGroup(tc, 1000, conglomid,
1:                 fetch_template, 
1:                 start_key, start_op, qualifier, stop_key, stop_op, 
1:                 expect_numrows, lowest_expect_key, order);
1: 
1:         if (!ret_val)
1:             return(ret_val);
1: 
1:         return(ret_val);
1: 
1:     }
1:     private static boolean t_scanNext(
1:     TransactionController   tc,
1:     long                    conglomid,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     input_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         HashSet set         = null;
1:         boolean ordered     = (order == T_QualifierTest.ORDER_FORWARD || 
1: 							   order == T_QualifierTest.ORDER_DESC);
1:         int     expect_key  = input_expect_key;
1: 
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         /**********************************************************************
1:          * Forward scan test case
1:          **********************************************************************
1:          */
1: 
1:         ScanController scan = 
1:             tc.openScan(
1:                 conglomid, false, 
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op);
1: 
1:         long key     = -42;
1:         int numrows = 0;
1: 
1:         while (scan.next())
1:         {
1:             scan.fetch(fetch_template);
1: 
1:             key = ((SQLLongint)(fetch_template[2])).getLong();
1: 
1:             if (ordered)
1:             {
1:                 if (key != expect_key)
1:                 {
1:                     return(
1:                         fail("(t_scanNext) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1: 					if (order == ORDER_DESC)
1: 						expect_key--;
1: 					else
1: 						expect_key++;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanNext) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1: 
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanNext) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         /**********************************************************************
1:          * Backward scan test case
1:          **********************************************************************
1:          */
1:         /*
1: 
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         // flip start and stop keys for backward scan and also flip 
1:         // start and stop operators (ie. GE->GT and GT->GE).
1:         scan = 
1:             tc.openBackwardScan(
1:                 conglomid, false, 
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 stop_key, flip_scan_op(stop_op),
1:                 qualifier,
1:                 start_key, flip_scan_op(start_op));
1: 
1:         key     = -42;
1:         numrows = 0;
1: 
1:         // rows are going to come back in reverse order in the ordered case.
1:         expect_key = input_expect_key + expect_numrows - 1;
1: 
1:         while (scan.next())
1:         {
1:             scan.fetch(fetch_template);
1: 
1:             key = ((SQLLongint)(fetch_template[2])).getLong();
1: 
1:             if (ordered)
1:             {
1:                 if (key != expect_key)
1:                 {
1:                     return(
1:                         fail("(t_scanNext-backward) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1:                     expect_key--;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanNext-backward) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1:         }
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanNext-backward) wrong num of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         scan.close();
1:         */
1: 
1:         return(true);
1:     }
1: 
1:     /**
1:      * Test scan which does FetchNext with all of the fields.
1:      * <p>
1:      * FetchNext() may be optimized by the underlying scan code to try and
1:      * not do multiple fetches of the same row for the user, but if the user
1:      * asks for one column, but the stop position depends on the whole row
1:      * this optimization is not possible.
1:      * <p>
1:      *
1: 	 * @return Whether the test succeeded or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static boolean t_scanFetchNext(
1:     TransactionController   tc,
1:     long                    conglomid,
1:     DataValueDescriptor[]	init_scan_template,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     input_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         HashSet set         = null;
1:         boolean ordered     = (order == ORDER_FORWARD || order == ORDER_DESC);
1: 
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         /**********************************************************************
1:          * Forward scan test case
1:          **********************************************************************
1:          */
1: 
1: 
1:         ScanController scan = 
1:             tc.openScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op);
1: 
1:         int  expect_key = input_expect_key;
1:         long key        = -42;
1:         long numrows    = 0;
1: 
1:         while (scan.fetchNext(fetch_template))
1:         {
1:             scan.fetch(init_scan_template);
1: 
1:             // make sure all columns from fetchNext() match subsequent fetch().
1:             for (int i = 0; i < init_scan_template.length; i++)
1:             {
1:                 if ((fetch_template[i]).compare(
1:                         (init_scan_template[i])) != 0)
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                               fetch_template[i] + ")" + "but got (" + 
1:                               init_scan_template[i] + ")."));
1:                 }
1:             }
1: 
1:             // see if we are getting the right keys.
1:             key = ((SQLLongint)(init_scan_template[2])).getLong();
1: 
1:             if (ordered)
1:             {
1:                 if (key != expect_key)
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1: 					if (order == ORDER_DESC)
1: 						expect_key--;
1: 					else
1: 						expect_key++;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1: 
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1: 
1:         /**********************************************************************
1:          * Backward scan test case
1:          **********************************************************************
1:          */
1: 
1:         /*
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         scan = 
1:             tc.openBackwardScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 stop_key, flip_scan_op(stop_op),
1:                 qualifier,
1:                 start_key, flip_scan_op(start_op));
1: 
1:         expect_key = input_expect_key + expect_numrows - 1;
1:         key        = -42;
1:         numrows    = 0;
1: 
1:         while (scan.fetchNext(fetch_template))
1:         {
1:             scan.fetch(init_scan_template);
1: 
1:             // make sure all columns from fetchNext() match subsequent fetch().
1:             for (int i = 0; i < init_scan_template.length; i++)
1:             {
1:                 if (((Orderable)fetch_template[i]).compare(
1:                         ((Orderable)init_scan_template[i])) != 0)
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                               fetch_template[i] + ")" + "but got (" + 
1:                               init_scan_template[i] + ")."));
1:                 }
1:             }
1: 
1:             // see if we are getting the right keys.
1:             key = ((SQLLongint)(init_scan_template[2])).getLong();
1: 
1:             if (ordered)
1:             {
1:                 if (key != expect_key)
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1:                     expect_key--;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                               expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1: 
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1:         */
1: 
1:         return(true);
1:     }
1: 
1:     /**
1:      * Test scan which does FetchNextGroup with all of the fields.
1:      * <p>
1:      *
1: 	 * @return Whether the test succeeded or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static boolean t_scanFetchNextGroup(
1:     TransactionController   tc,
1:     int                     group_size,
1:     long                    conglomid,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     input_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         HashSet set = null;
1:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1: 
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         /**********************************************************************
1:          * Forward scan test case
1:          **********************************************************************
1:          */
1: 
1:         GroupFetchScanController scan = 
1:             tc.openGroupFetchScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op);
1: 
1:         // create an array of "group_size" rows to use in the fetch group call.
1:         DataValueDescriptor[][] row_array = 
1:             new DataValueDescriptor[group_size][];
1:         row_array[0] = TemplateRow.newRow(fetch_template);
1: 
1:         int  expect_key         = input_expect_key;
1:         long key                = -42;
1:         long numrows            = 0;
1:         int  group_row_count    = 0;
1: 
1:         // loop asking for "group_size" rows at a time.
1:         while ((group_row_count = 
1:                     scan.fetchNextGroup(row_array, (RowLocation[]) null)) != 0)
1:         {
1: 
1:             // loop through the rows returned into the row_array.
1:             for (int i = 0; i < group_row_count; i++)
1:             {
1:                 // see if we are getting the right keys.
1:                 key = ((SQLLongint)(row_array[i][2])).getLong();
1: 
1:                 if (ordered)
1:                 {
1:                     if (key != expect_key)
1:                     {
1:                         return(fail(
1:                             "(t_scanFetchNextGroup-forward) wrong key, expect (" + 
1:                             expect_key + ")" + "but got (" + key + 
1:                             "). num rows = " + numrows));
1:                     }
1:                     else
1:                     {
1: 						if (order == ORDER_DESC)
1: 							expect_key--;
1: 						else
1: 							expect_key++;
1:                     }
1:                 }
1:                 else
1:                 {
1:                     if (!set.remove(new Long(key)))
1:                     {
1:                         return(fail(
1:                             "(t_scanFetchNextGroup-forward) wrong key, expected (" + 
1:                             expect_key + ")" + "but got (" + key + ")."));
1:                     }
1:                 }
1:                 numrows++;
1:             }
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(
1:                 fail("(t_scanFetchNextGroup-forward) wrong number of rows. Expected " +
1:                 expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         /**********************************************************************
1:          * Backward scan test case
1:          **********************************************************************
1:          */
1: 
1:         /*
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         scan = 
1:             tc.openGroupFetchBackwardScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 stop_key, flip_scan_op(stop_op),
1:                 qualifier,
1:                 start_key, flip_scan_op(start_op));
1: 
1:         // create an array of "group_size" rows to use in the fetch group call.
1:         expect_key      = input_expect_key + expect_numrows - 1;
1:         key             = -42;
1:         numrows         = 0;
1:         group_row_count = 0;
1: 
1:         // loop asking for "group_size" rows at a time.
1:         while ((group_row_count = 
1:                     scan.fetchNextGroup(row_array, (RowLocation[]) null)) != 0)
1:         {
1:             // loop through the rows returned into the row_array.
1:             for (int i = 0; i < group_row_count; i++)
1:             {
1:                 // see if we are getting the right keys.
1:                 key = ((SQLLongint)(row_array[i][2])).getLong();
1: 
1:                 if (ordered)
1:                 {
1:                     if (key != expect_key)
1:                     {
1:                         return(fail(
1:                             "(t_scanFetchNextGroup-backward) wrong key, expected (" + 
1:                             expect_key + ")" + "but got (" + key + ")."));
1:                     }
1:                     else
1:                     {
1:                         expect_key--;
1:                     }
1:                 }
1:                 else
1:                 {
1:                     if (!set.remove(new Long(key)))
1:                     {
1:                         return(fail(
1:                             "(t_scanFetchNextGroup-backward) wrong key, expected (" + 
1:                             expect_key + ")" + "but got (" + key + ")."));
1:                     }
1:                 }
1:                 numrows++;
1:             }
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(
1:                 fail("(t_scanFetchNextGroup-backward) wrong number of rows. Expected " +
1:                 expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         */
1: 
1:         return(true);
1:     }
1: 
1:     /**
1:      * Test scan which does FetchNext with subset of fields.
1:      * <p>
1:      * FetchNext() may be optimized by the underlying scan code to try and
1:      * not do multiple fetches of the same row for the user, but if the user
1:      * asks for one column, but the stop position depends on the whole row
1:      * this optimization is not possible.
1:      * <p>
1:      *
1: 	 * @return Whether the test succeeded or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static boolean t_scanFetchNextPartial(
1:     TransactionController   tc,
1:     long                    conglomid,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     input_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         HashSet set = null;
1:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1: 
1: 
1:         /**********************************************************************
1:          * setup shared by both.
1:          **********************************************************************
1:          */
1: 
1:         // In the fetchNext call only ask the minimum set of columns 
1:         // necessary, which is the union of the "key" (col[2]) and other
1:         // columns referenced in the qualifier list.
1:         FormatableBitSet fetch_row_validColumns = RowUtil.getQualifierBitSet(qualifier);
1: 
1:         // now add in column 2, as we always need the key field.
1: 		fetch_row_validColumns.grow(3);// grow to length of 3 
1:         fetch_row_validColumns.set(2);
1: 
1:         // add in any fields in start and stop positions
1:         if (start_key != null)
1:         {
1:             for (int i = 0; i < start_key.length; i++)
1:             {
1:                 fetch_row_validColumns.set(i);
1:             }
1:         }
1:         if (stop_key != null)
1:         {
1:             for (int i = 0; i < stop_key.length; i++)
1:             {
1:                 fetch_row_validColumns.set(i);
1:             }
1:         }
1: 
1:         // point key at the right column in the fetch_template
1:         SQLLongint key_column = (SQLLongint) fetch_template[2];
1: 
1:         /**********************************************************************
1:          * Forward scan test case
1:          **********************************************************************
1:          */
1: 
1:         if (!ordered)
1:         {
1:             set = create_hash_set(input_expect_key, expect_numrows, order);
1:         }
1: 
1:         ScanController scan = 
1:             tc.openScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) fetch_row_validColumns, 
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op);
1: 
1:         int  expect_key = input_expect_key;
1:         long key        = -42;
1:         long key2       = -42;
1:         long numrows    = 0;
1: 
1:         while (scan.fetchNext(fetch_template))
1:         {
1:             // see if we are getting the right keys.
1:             key = key_column.getLong();
1: 
1:             // make sure a subsequent fetch also works.
1:             key_column.setValue(-42);
1: 
1:             scan.fetch(fetch_template);
1:             key2 = key_column.getLong();
1: 
1:             if (ordered)
1:             {
1:                 if ((key != expect_key) || (key2 != expect_key))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1: 					if (order == ORDER_DESC)
1: 						expect_key--;
1: 					else
1: 						expect_key++;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1: 
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         /**********************************************************************
1:          * Backward scan test case
1:          **********************************************************************
1:          */
1: 
1:         /*
1:         if (!ordered)
1:         {
1:             set = create_hash_set(expect_key, expect_numrows, order);
1:         }
1: 
1:         scan = 
1:             tc.openBackwardScan(
1:                 conglomid, false,
1:                 0,
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) fetch_row_validColumns, 
1:                 stop_key, flip_scan_op(stop_op),
1:                 qualifier,
1:                 start_key, flip_scan_op(start_op));
1: 
1:         expect_key  = input_expect_key + expect_numrows - 1;
1:         key         = -42;
1:         key2        = -42;
1:         numrows     = 0;
1: 
1:         while (scan.fetchNext(fetch_template))
1:         {
1:             // see if we are getting the right keys.
1:             key = key_column.getValue();
1: 
1:             // make sure a subsequent fetch also works.
1:             key_column.setValue(-42);
1: 
1:             scan.fetch(fetch_template);
1:             key2 = key_column.getValue();
1: 
1:             if (ordered)
1:             {
1:                 if ((key != expect_key) || (key2 != expect_key))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:                 else
1:                 {
1:                     expect_key--;
1:                 }
1:             }
1:             else
1:             {
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchNext) wrong key, expected (" + 
1:                              expect_key + ")" + "but got (" + key + ")."));
1:                 }
1:             }
1:             numrows++;
1: 
1:         }
1: 
1:         scan.close();
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanFetchNext) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1:         */
1: 
1:         return(true);
1:     }
1: 
1:     /**
1:      * Test scan which does FetchSet.
1:      * <p>
1:      * FetchSet() returns the entire result set in the hash table.
1:      * <p>
1:      *
1: 	 * @return Whether the test succeeded or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static boolean t_scanFetchHashtable(
1:     TransactionController   tc,
1:     long                    conglomid,
1:     DataValueDescriptor[]	fetch_template,
1:     DataValueDescriptor[]	start_key, 
1:     int                     start_op,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]	stop_key,
1:     int                     stop_op,
1:     int                     expect_numrows,
1:     int                     input_expect_key,
1:     int                     order)
1:         throws StandardException, T_Fail
1:     {
1:         HashSet set = null;
1:         long    key;
1:         long numrows = 0;
1:         boolean ordered = (order == ORDER_FORWARD || order == ORDER_DESC);
1: 
1:         set = create_hash_set(input_expect_key, expect_numrows, order);
1: 
1:         // select entire data set into a hash table, with first column key 
1: 		int[] keyColumns = new int[1];
1: 		keyColumns[0] = 0;
1: 
1:         BackingStoreHashtable result_set = 
1:             tc.createBackingStoreHashtableFromScan(
1:                 conglomid, 
1:                 0,
1:                 TransactionController.MODE_TABLE,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op,
1:                 -1,             // no limit on total rows.
1:                 keyColumns,     // first column is hash key column
1:                 false,          // don't remove duplicates
1:                 -1,             // no estimate of rows
1:                 -1,             // put it all into memory
1:                 -1,             // use default initial capacity
1:                 -1,             // use default load factor
1:                 false,         // don't maintain runtime statistics
0: 				false);			// don't skip null key columns
1: 
1:         // make sure the expected result set is the same as the actual result
1:         // set.
1: 
0:         Enumeration enum = result_set.elements();
1: 
0:         while (enum.hasMoreElements())
1:         {
1:             Object   obj;
1:             DataValueDescriptor[] row = null;
1: 
0:             if ((obj = enum.nextElement()) instanceof DataValueDescriptor[] )
1:             {
1:                 row = (DataValueDescriptor[] ) obj;
1:                 key = ((SQLLongint)(row[2])).getLong();
1: 
1:                 if (!set.remove(new Long(key)))
1:                 {
1:                     return(
1:                         fail("(t_scanFetchHashtable-obj) wrong key, expected (" + 
1:                               input_expect_key + ")" + 
1:                               "but got (" + key + ")."));
1:                 }
1:                 numrows++;
1:             }
0:             else if (obj instanceof Vector)
1:             {
1: 
1: 
0:                 Vector row_vect = (Vector) obj;
1: 
1:                 for (int i = 0; i < row_vect.size(); i++)
1:                 {
0:                     row = (DataValueDescriptor[] ) row_vect.elementAt(i);
1: 
1:                     key = ((SQLLongint)(row[2])).getLong();
1: 
1:                     if (!set.remove(new Long(key)))
1:                     {
1:                         return(fail(
1:                             "(t_scanFetchHashtable-vector) wrong key, expected (" + 
1:                              input_expect_key + ")" + 
1:                              "but got (" + key + ")."));
1:                     }
1:                     numrows++;
1:                 }
1:             }
1:             else
1:             {
1:                 return(fail(
1:                     "(t_scanFetchHashtable) got bad type for data: " + obj));
1:             }
1:         }
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(
1:                 fail(
1:                     "(t_scanFetchHashtable) wrong number of rows. Expected " +
1:                      expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         result_set.close();
1: 
1:         // select entire data set into a hash table, with key being 
1:         // the third column, which is the unique id used to verify the
1:         // right result set is being returned.:
1: 
1:         // open a new scan
1: 		keyColumns[0] = 2;
1: 
1:         result_set = 
1:             tc.createBackingStoreHashtableFromScan(
1:                 conglomid,
1:                 0,
1:                 TransactionController.MODE_TABLE,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 start_key, start_op,
1:                 qualifier,
1:                 stop_key, stop_op,
1:                 -1,             // no limit on total rows.
1:                 keyColumns,              // third column is hash key column
1:                 false,          // don't remove duplicates
1:                 -1,             // no estimate of rows
1:                 -1,             // put it all into memory
1:                 -1,             // use default initial capacity
1:                 -1,             // use default load factor
1:                 false,         // don't maintain runtime statistics
0: 				false);			// don't skip null key columns
1: 
1: 
1:         Object removed_obj;
1:         for (numrows = 0; numrows < expect_numrows; numrows++)
1:         {
1: 			long exp_key ;
1: 			if (order == ORDER_DESC)
1: 				exp_key = input_expect_key - numrows;
1: 			else
1: 				exp_key = input_expect_key + numrows;
1:             if ((removed_obj = 
1:                     result_set.remove(
1:                         new SQLLongint(exp_key))) == null)
1:             {
1:                 fail("(t_scanFetchHashtable-2-vector) wrong key, expected (" + 
1:                       (exp_key) + ")" + 
1:                       "but did not find it.");
1:             }
1:         }
1: 
1:         if (numrows != expect_numrows)
1:         {
1:             return(fail("(t_scanFetchHashtable-2) wrong number of rows. Expected " +
1:                  expect_numrows + " rows, but got " + numrows + "rows."));
1:         }
1: 
1:         return(true);
1:     }
1: 
1:     /* public methods of T_QualifierTest */
1: 
1:     public boolean t_testqual(TransactionController tc)
1:         throws StandardException, T_Fail
1:     {
1:         boolean                 ret_val             = true;
1:         DataValueDescriptor[]   openscan_template   = null;
1:         DataValueDescriptor[]   fetch_template      = null;
1:         DataValueDescriptor[]   base_row            = null;
1:         T_SecondaryIndexRow     index_row           = null;
1:         long                    value               = -1;
1:         long        col1[]  = { 1,  3,  4,  4,  4,  5,  5,  5,  6,  7,  9};
1:         long        col2[]  = { 1,  1,  2,  4,  6,  2,  4,  6,  1,  1,  1};
1:         long        col3[]  = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
1:         long                    conglomid;
1:         long                    base_conglomid;
1:         long                    index_conglomid;
1:         ConglomerateController  base_cc             = null;
1:         ConglomerateController  index_cc            = null;
1:         RowLocation             base_rowloc         = null;
1: 
1:         base_row = TemplateRow.newU8Row(3);
1: 
1:         if (init_conglomerate_type.compareTo("BTREE") == 0)
1:         {
1:             base_conglomid = 
1:                 tc.createConglomerate(
0:                     "heap", base_row, null,  null, 
1:                     TransactionController.IS_DEFAULT);
1: 
1:             index_row = new T_SecondaryIndexRow();
1: 
1:             base_cc = 
1:                 tc.openConglomerate(
1:                     base_conglomid,
1:                     false,
1:                     TransactionController.OPENMODE_FORUPDATE,
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_SERIALIZABLE);
1: 
1:             base_rowloc = base_cc.newRowLocationTemplate();
1: 
1:             index_row.init(base_row, base_rowloc, 4);
1: 
1:             index_conglomid = 
1:                 tc.createConglomerate(
1:                     init_conglomerate_type, index_row.getRow(), 
1:                     null,
1: 					init_properties,
1: 					init_temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT);
1: 
1:             index_cc =	
1:                 tc.openConglomerate(
1:                     index_conglomid,
1:                     false,
1:                     TransactionController.OPENMODE_FORUPDATE,
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_SERIALIZABLE);
1: 
1:             conglomid = index_conglomid;
1:             openscan_template = index_row.getRow();
1: 
1:             // make another template
1:             T_SecondaryIndexRow fetch_index_row = new T_SecondaryIndexRow();
1:             fetch_index_row.init(
1:                 TemplateRow.newU8Row(3),
1:                 base_cc.newRowLocationTemplate(), 
1:                 4);
1:             fetch_template = fetch_index_row.getRow();
1:         }
1:         else
1:         {
1:             base_conglomid = 
0:                 tc.createConglomerate(init_conglomerate_type, base_row, null, 
1:                                       init_properties,
1: 									  init_temporary ? TransactionController.IS_TEMPORARY : TransactionController.IS_DEFAULT);
1: 
1:             base_cc =	
1:                 tc.openConglomerate(
1:                     base_conglomid,
1:                     false,
1:                     TransactionController.OPENMODE_FORUPDATE,
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_SERIALIZABLE);
1: 
1:             base_rowloc = base_cc.newRowLocationTemplate();
1: 
1:             conglomid = base_conglomid;
1:             openscan_template = base_row;
1:             fetch_template    = TemplateRow.newU8Row(3);
1:         }
1: 
1:         // insert them in reverse order just to make sure btree is sorting them
1:         for (int i = col1.length - 1; i >= 0; i--)
1:         {
1:             ((SQLLongint)(base_row[0])).setValue(col1[i]);
1:             ((SQLLongint)(base_row[1])).setValue(col2[i]);
1:             ((SQLLongint)(base_row[2])).setValue(col3[i]);
1: 
1:             base_cc.insertAndFetchLocation(base_row, base_rowloc);
1: 
1:             if (init_conglomerate_type.compareTo("BTREE") == 0)
1:             {
1:                 index_cc.insert(index_row.getRow());
1:             }
1:         }
1: 
1:         tc.commit();
1: 
1: 
1:         // run through a predicates as described in the openScan() interface,
1:         // and implement them in qualifiers rather than start and stop.
1:         //
1: 
1:         // Use the following SQLLongint's for qualifier values //
1:         SQLLongint qual_col1 = new SQLLongint(-1);
1:         SQLLongint qual_col2 = new SQLLongint(-1);
1:         SQLLongint qual_col3 = new SQLLongint(-1);
1:         SQLLongint qual_col4 = new SQLLongint(-1);
1:         SQLLongint qual_col5 = new SQLLongint(-1);
1:         SQLLongint qual_col6 = new SQLLongint(-1);
1:         SQLLongint qual_col7 = new SQLLongint(-1);
1: 
1: 
1:         // test predicate x = 5
1:         //
1:         //     result set should be: {5,2,16}, {5,4,17}, {5,6,18}
1:         //
1:         progress("qual scan (x = 5)");
1:         qual_col1.setValue(5);
1:         Qualifier q1[][] = 
1:         {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_EQUALS, 
1:                             false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA, 
1:                    q1,
1:                    null,  ScanController.NA,
1:                    3, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1:                    
1:         //  +---------------------------------------------------------+
1:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:         //  |      |value|op |value|op |              |(serialization)|
1:         //  +------+-----+---+-----+---+--------------+---------------+
1:         //  |x > 5 |{5}  |GT |null |   |{6,1} .. {9,1}|{5,6} .. {9,1} |
1:         //  +-----------------------------------------+---------------+
1:         progress("qual scan (x > 5)");
1:         qual_col1.setValue(5);
1:         Qualifier q2[][] = 
1:         {
1:             {
1:                 new QualifierUtil(
1:                     0, qual_col1, Orderable.ORDER_OP_LESSOREQUALS, 
1:                     true, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA, 
1:                    q2,
1:                    null,  ScanController.NA,
1:                    3, 19, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +---------------------------------------------------------+
1:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:         //  |      |value|op |value|op |              |(serialization)|
1:         //  +------+-----+---+-----+---+--------------+---------------+
1:         //  |x >= 5|{5}  |GE |null |   |{5,2} .. {9,1}|{4,6} .. {9,1} |
1:         //  +-----------------------------------------+---------------+
1:         progress("qual scan (x >= 5)");
1:         qual_col1.setValue(5);
1:         Qualifier q3[][] = 
1:         {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                                 Orderable.ORDER_OP_LESSTHAN, 
1:                                 true, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA, 
1:                    q3,
1:                    null, ScanController.NA,
1:                    6, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //
1:         //  +---------------------------------------------------------+
1:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:         //  |      |value|op |value|op |              |(serialization)|
1:         //  +------+-----+---+-----+---+--------------+---------------+
1:         //  |x <= 5|null |   |{5}  |GT |{1,1} .. {5,6}|first .. {5,6} |
1:         //  +-----------------------------------------+---------------+
1:         progress("qual scan (x <= 5)");
1:         qual_col1.setValue(5);
1:         Qualifier q4[][] = 
1:         {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                                 Orderable.ORDER_OP_LESSOREQUALS, 
1:                                 false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA, 
1:                    q4,
1:                    null, ScanController.NA,
1:                    8, 11, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //
1:         //  +---------------------------------------------------------+
1:         //  |pred  |start|key|stop |key|rows returned |rows locked    |
1:         //  |      |value|op |value|op |              |(serialization)|
1:         //  +------+-----+---+-----+---+--------------+---------------+
1:         // 	|x < 5 |null |   |{5}  |GE |{1,1} .. {4,6}|first .. {4,6} |
1:         //  +-----------------------------------------+---------------+
1:         progress("qual scan (x < 5)");
1:         qual_col1.setValue(5);
1:         Qualifier q5[][] = 
1:         {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                                 Orderable.ORDER_OP_LESSTHAN, 
1:                                 false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA, 
1:                    q5,
1:                    null, ScanController.NA,
1:                    5, 11, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1: 	    //  |x >= 5 and x <= 7|{5},  |GE|{7}  |GT|{5,2} .. {7,1}|{4,6} .. {7,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x >= 5 and x <= 7)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(7);
1:         Qualifier q6[][] = {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_LESSTHAN, 
1:                             true, true, true),
1:                 new QualifierUtil(0, qual_col2,
1:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:                             false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q6,
1:                    null, ScanController.NA,
1:                    5, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         // passing qualifier in q6[0][0], q6[0][1] should evaluate same as 
1:         // passing in q6[0][0], q6[1][0]
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1: 	    //  |x >= 5 and x <= 7|{5},  |GE|{7}  |GT|{5,2} .. {7,1}|{4,6} .. {7,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x >= 5 and x <= 7)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(7);
1:         Qualifier q6_2[][] = {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_LESSTHAN, 
1:                             true, true, true)
1:             },
1:             {
1:                 new QualifierUtil(0, qual_col2,
1:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:                             false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q6_2,
1:                    null, ScanController.NA,
1:                    5, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1: 	    //  |x = 5 and y > 2  |{5,2} |GT|{5}  |GT|{5,4} .. {5,6}|{5,2} .. {9,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x = 5 and y > 2)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(2);
1:         Qualifier q7[][] = {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_EQUALS, 
1:                             false, true, true),
1:                 new QualifierUtil(1, qual_col2,
1:                             Orderable.ORDER_OP_LESSOREQUALS, 
1:                             true, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q7,
1:                    null, ScanController.NA,
1:                    2, 17, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:         // 	|x = 5 and y >= 2 | {5,2}|GE| {5} |GT|{5,2} .. {5,6}|{4,6} .. {9,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x = 5 and y >= 2)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(2);
1:         Qualifier q8[][] = {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_EQUALS, 
1:                             false, true, true),
1:                 new QualifierUtil(1, qual_col2,
1:                             Orderable.ORDER_OP_LESSTHAN, 
1:                             true, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q8,
1:                    null, ScanController.NA,
1:                    3, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:         // 	|x = 5 and y < 5  | {5}  |GE|{5,5}|GE|{5,2} .. {5,4}|{4,6} .. {5,4}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x = 5 and y < 5)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(5);
1:         Qualifier q9[][] = {
1:             { 
1:                 new QualifierUtil(0, qual_col1,
1:                             Orderable.ORDER_OP_EQUALS, 
1:                             false, true, true),
1:                 new QualifierUtil(1, qual_col1,
1:                             Orderable.ORDER_OP_LESSTHAN, 
1:                             false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q9,
1:                    null, ScanController.NA,
1:                    2, 16, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred             |start|key|stop |key|rows returned|rows locked   |
1:         //  |                 |value|op |value|op |             |(serialized)  |
1:         //  +-----------------+------+--+-----+--+--------------+--------------+
1:         // 	|x = 2            | {2}  |GE| {2} |GT|none          |{1,1} .. {1,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x = 2)");
1:         qual_col1.setValue(2);
1:         Qualifier q10[][] = {
1:             {
1:                 new QualifierUtil(0, qual_col1,
1:                                 Orderable.ORDER_OP_EQUALS, 
1:                                 false, true, true)
1:             }
1:         };
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q10,
1:                    null, ScanController.NA,
1:                    0, 0, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:         //  |                |value|op |value|op |              |(serialized)  |
1:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:         // 	|x >= 5 or y = 6 | null|   | null|   |{4,6} .. {9,1}|{1,1} .. {9,1}|
1:         // 	+------------------------------------------------------------------+
1:         progress("qual scan (x >= 5) or (y = 6)");
1:         qual_col1.setValue(5);
1:         qual_col2.setValue(6);
1:         Qualifier q11[][] =  new Qualifier[2][];
1:         q11[0] = new Qualifier[0];
1:         q11[1] = new Qualifier[2];
1: 
1:         q11[1][0] = 
1:                 new QualifierUtil(
1:                         0, qual_col1,
1:                         Orderable.ORDER_OP_GREATEROREQUALS, 
1:                         false, true, true);
1:         q11[1][1] = 
1:                 new QualifierUtil(
1:                         1, qual_col2,
1:                         Orderable.ORDER_OP_EQUALS, 
1:                         false, true, true);
1:         
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q11,
1:                    null, ScanController.NA,
1:                    7, 15, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:         //  |                |value|op |value|op |              |(serialized)  |
1:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:         // 	|(x = 1 or y = 1 or y = 6)|
1:         // 	|     and        |
1:         // 	|(x > 5 or y = 1)|
1:         // 	|     and        |
1:         // 	|(x = 9 or x = 7)|null |   | null|   |{7,1} .. {9,1}|{1,1} .. {9,1}|
1:         // 	+------------------------------------------------------------------+
1: 
1:         progress("qual scan (x = 1 or y = 1 or y = 6) and (x > 5 or y = 1) and (x = 9 or x = 7)");
1:         qual_col1.setValue(1);
1:         qual_col2.setValue(1);
1:         qual_col3.setValue(6);
1:         qual_col4.setValue(5);
1:         qual_col5.setValue(1);
1:         qual_col6.setValue(9);
1:         qual_col7.setValue(7);
1: 
1:         Qualifier q12[][] = new Qualifier[4][];
1:         q12[0] = new Qualifier[0];
1:         q12[1] = new Qualifier[3];
1:         q12[2] = new Qualifier[2];
1:         q12[3] = new Qualifier[2];
1: 
1: 
1:         q12[1][0] = 
1:             new QualifierUtil(
1:                     0, qual_col1,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q12[1][1] = 
1:             new QualifierUtil(
1:                     1, qual_col2,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q12[1][2] = 
1:             new QualifierUtil(
1:                     1, qual_col3,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q12[2][0] = 
1:             new QualifierUtil(
1:                     0, qual_col4,
1:                     Orderable.ORDER_OP_GREATERTHAN, 
1:                     false, true, true);
1: 
1:         q12[2][1] = 
1:             new QualifierUtil(
1:                     1, qual_col5,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q12[3][0] = 
1:             new QualifierUtil(
1:                     0, qual_col6,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q12[3][1] = 
1:             new QualifierUtil(
1:                     0, qual_col7,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1:         
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q12,
1:                    null, ScanController.NA,
1:                    2, 20, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         //  +------------------------------------------------------------------+
1:         //  |pred            |start|key|stop |key|rows returned |rows locked   |
1:         //  |                |value|op |value|op |              |(serialized)  |
1:         //  +----------------+-----+---+-----+-- +--------------+--------------+
1:         // 	|(y = 4 or y = 1)|
1:         // 	|     and        |
1:         // 	|(x = 1 or x = 4 or x= 9)|
1:         // 	|     and        |
1:         // 	|(z = 15 or z = 14)|null |   | null|   |{4,4} .. {4,4}| ALL        |
1:         // 	+------------------------------------------------------------------+
1: 
1:         progress("qual scan (x = 1 or x = 4 or x= 9) and (y = 4 or y = 1) and (z = 15 or z = 14)");
1: 
1:         qual_col1.setValue(4);
1:         qual_col2.setValue(1);
1:         qual_col3.setValue(1);
1:         qual_col4.setValue(4);
1:         qual_col5.setValue(9);
1:         qual_col6.setValue(15);
1:         qual_col7.setValue(14);
1: 
1:         Qualifier q13[][] = new Qualifier[4][];
1:         q13[0] = new Qualifier[0];
1:         q13[1] = new Qualifier[2];
1:         q13[2] = new Qualifier[3];
1:         q13[3] = new Qualifier[2];
1: 
1: 
1:         q13[1][0] = 
1:             new QualifierUtil(
1:                     1, qual_col1,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q13[1][1] = 
1:             new QualifierUtil(
1:                     1, qual_col2,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1: 
1:         q13[2][0] = 
1:             new QualifierUtil(
1:                     0, qual_col4,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q13[2][1] = 
1:             new QualifierUtil(
1:                     0, qual_col5,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q13[2][2] = 
1:             new QualifierUtil(
1:                     0, qual_col3,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q13[3][0] = 
1:             new QualifierUtil(
1:                     2, qual_col6,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1: 
1:         q13[3][1] = 
1:             new QualifierUtil(
1:                     2, qual_col7,
1:                     Orderable.ORDER_OP_EQUALS, 
1:                     false, true, true);
1:         
1:         if (!t_scan(tc, conglomid, openscan_template, fetch_template,
1:                    null, ScanController.NA,
1:                    q13,
1:                    null, ScanController.NA,
1:                    1, 14, init_order))
1:         {
1:             ret_val = false;
1:         }
1: 
1:         tc.commit();
1:         progress("Ending t_testqual");
1: 
1:         return(ret_val);
1:     }
1: 
1: 	private static boolean fail(String msg)
1:         throws T_Fail
1: 	{
1:         throw T_Fail.testFailMsg("T_QualifierTest failure: " + msg);
1: 	}
1: 
1: 	private void progress(String msg)
1: 	{
1: 		this.init_out.println("T_QualifierTest progress: " + msg);
1: 	}
1: }
============================================================================