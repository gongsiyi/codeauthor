2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.CreateTableConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: 
1:7fd0c6e: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:7fd0c6e: import org.apache.derby.iapi.types.TypeId;
1:7fd0c6e: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:3c09be7: import org.apache.derby.catalog.DependableFinder;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369:  *	This class  describes actions that are ALWAYS performed for a
1:eac0369:  *	CREATE TABLE Statement at Execution time.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: class CreateTableConstantAction extends DDLConstantAction
6:eac0369: {
1:eac0369: 
1:eac0369: 	private char					lockGranularity;
1:eac0369: 	private boolean					onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	private boolean					onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
1:eac0369: 	private String					tableName;
1:eac0369: 	private String					schemaName;
1:eac0369: 	private int						tableType;
1:eac0369: 	private ColumnInfo[]			columnInfo;
1:eac0369: 	private CreateConstraintConstantAction[]	constraintActions;
1:eac0369: 	private Properties				properties;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a CREATE TABLE statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param schemaName	name for the schema that table lives in.
1:eac0369: 	 *  @param tableName	Name of table.
1:eac0369: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
1:eac0369: 	 *  @param columnInfo	Information on all the columns in the table.
1:eac0369: 	 *		 (REMIND tableDescriptor ignored)
1:eac0369: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
1:eac0369: 	 *  @param properties	Optional table properties
1:eac0369: 	 * @param lockGranularity	The lock granularity.
1:eac0369: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1:eac0369: 	 */
1:eac0369: 	CreateTableConstantAction(
1:eac0369: 								String			schemaName,
1:eac0369: 								String			tableName,
1:eac0369: 								int				tableType,
1:eac0369: 								ColumnInfo[]	columnInfo,
1:eac0369: 								CreateConstraintConstantAction[] constraintActions,
1:eac0369: 								Properties		properties,
1:eac0369: 								char			lockGranularity,
1:eac0369: 								boolean			onCommitDeleteRows,
1:eac0369: 								boolean			onRollbackDeleteRows)
1:eac0369: 	{
1:eac0369: 		this.schemaName = schemaName;
1:eac0369: 		this.tableName = tableName;
1:eac0369: 		this.tableType = tableType;
1:eac0369: 		this.columnInfo = columnInfo;
1:eac0369: 		this.constraintActions = constraintActions;
1:eac0369: 		this.properties = properties;
1:eac0369: 		this.lockGranularity = lockGranularity;
1:eac0369: 		this.onCommitDeleteRows = onCommitDeleteRows;
1:eac0369: 		this.onRollbackDeleteRows = onRollbackDeleteRows;
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (tableType == TableDescriptor.BASE_TABLE_TYPE && lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
1:eac0369: 				lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"Unexpected value for lockGranularity = " + lockGranularity);
6:eac0369: 			}
1:eac0369: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE && onRollbackDeleteRows == false)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"Unexpected value for onRollbackDeleteRows = " + onRollbackDeleteRows);
1:eac0369: 			}
1:eac0369: 			SanityManager.ASSERT(schemaName != null, "SchemaName is null");
1:eac0369: 		}
1:eac0369: 	}
1:3c09be7: 
1:eac0369: 	// OBJECT METHODS
1:eac0369: 
1:eac0369: 	public	String	toString()
1:eac0369: 	{
1:eac0369: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 			return constructToString("DECLARE GLOBAL TEMPORARY TABLE ", tableName);
1:318307e: 		else
1:eac0369: 			return constructToString("CREATE TABLE ", tableName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// INTERFACE METHODS
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	This is the guts of the Execution-time logic for CREATE TABLE.
1:eac0369: 	 *
1:eac0369: 	 *	@see ConstantAction#executeConstantAction
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public void	executeConstantAction( Activation activation )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		TableDescriptor 			td;
1:eac0369: 		UUID 						toid;
1:eac0369: 		SchemaDescriptor			schemaDescriptor;
1:eac0369: 		ColumnDescriptor			columnDescriptor;
1:eac0369: 		ExecRow						template;
1:eac0369: 
1:eac0369: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:eac0369: 		DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 		DependencyManager dm = dd.getDependencyManager();
1:eac0369: 		TransactionController tc = lcc.getTransactionExecute();
1:eac0369: 
1:eac0369: 		/* Mark the activation as being for create table */
1:eac0369: 		activation.setForCreateTable();
1:eac0369: 
1:b61f876:         // setup for create conglomerate call:
1:b61f876:         //   o create row template to tell the store what type of rows this
1:b61f876:         //     table holds.
1:b61f876:         //   o create array of collation id's to tell collation id of each
1:b61f876:         //     column in table.
1:b61f876: 		template            = RowUtil.getEmptyValueRow(columnInfo.length, lcc);
1:b61f876:         int[] collation_ids = new int[columnInfo.length];
1:eac0369: 
1:eac0369: 		for (int ix = 0; ix < columnInfo.length; ix++)
1:eac0369: 		{
1:b61f876:             ColumnInfo  col_info = columnInfo[ix];
1:b61f876: 
1:b61f876:             // Get a template value for each column
1:b61f876: 
1:b61f876: 			if (col_info.defaultValue != null)
1:b61f876:             {
1:b61f876:                 /* If there is a default value, use it, otherwise use null */
1:b61f876: 				template.setColumn(ix + 1, col_info.defaultValue);
1:b61f876:             }
2:eac0369: 			else
1:b61f876:             {
1:b61f876: 				template.setColumn(ix + 1, col_info.dataType.getNull());
1:b61f876:             }
1:b61f876: 
1:b61f876:             // get collation info for each column.
1:b61f876: 
1:b61f876:             collation_ids[ix] = col_info.dataType.getCollationType();
1:eac0369: 		}
1:b61f876: 
1:eac0369: 
1:eac0369: 		/* create the conglomerate to hold the table's rows
1:eac0369: 		 * RESOLVE - If we ever have a conglomerate creator
1:eac0369: 		 * that lets us specify the conglomerate number then
1:eac0369: 		 * we will need to handle it here.
1:eac0369: 		 */
1:eac0369: 		long conglomId = tc.createConglomerate(
1:eac0369: 				"heap", // we're requesting a heap conglomerate
1:eac0369: 				template.getRowArray(), // row template
1:eac0369: 				null, //column sort order - not required for heap
1:b61f876:                 collation_ids,
1:eac0369: 				properties, // properties
1:eac0369: 				tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE ?
1:b61f876:                     (TransactionController.IS_TEMPORARY | 
1:b61f876:                      TransactionController.IS_KEPT) : 
1:b61f876:                         TransactionController.IS_DEFAULT);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Inform the data dictionary that we are about to write to it.
1:eac0369: 		** There are several calls to data dictionary "get" methods here
1:eac0369: 		** that might be done in "read" mode in the data dictionary, but
1:eac0369: 		** it seemed safer to do this whole operation in "write" mode.
1:eac0369: 		**
1:eac0369: 		** We tell the data dictionary we're done writing at the end of
1:eac0369: 		** the transaction.
1:eac0369: 		*/
1:eac0369: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1:eac0369: 			dd.startWriting(lcc);
1:eac0369: 
1:eac0369: 		SchemaDescriptor sd;
1:eac0369: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:eac0369: 		else
1:eac0369: 			sd = DDLConstantAction.getSchemaDescriptorForCreate(dd, activation, schemaName);
1:eac0369: 
1:3c09be7: 		//
1:eac0369: 		// Create a new table descriptor.
1:eac0369: 		// 
1:eac0369: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1:eac0369: 
1:eac0369: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1:eac0369: 		{
1:eac0369: 			td = ddg.newTableDescriptor(tableName, sd, tableType, lockGranularity);
1:eac0369: 			dd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);
1:eac0369: 		} else
1:eac0369: 		{
1:eac0369: 			td = ddg.newTableDescriptor(tableName, sd, tableType, onCommitDeleteRows, onRollbackDeleteRows);
1:eac0369: 			td.setUUID(dd.getUUIDFactory().createUUID());
1:eac0369: 		}
1:eac0369: 		toid = td.getUUID();
1:eac0369: 
1:eac0369: 		// Save the TableDescriptor off in the Activation
1:eac0369: 		activation.setDDLTableDescriptor(td);
1:eac0369: 
1:eac0369: 		/* NOTE: We must write the columns out to the system
1:eac0369: 		 * tables before any of the conglomerates, including
1:eac0369: 		 * the heap, since we read the columns before the
1:eac0369: 		 * conglomerates when building a TableDescriptor.
1:eac0369: 		 * This will hopefully reduce the probability of
1:eac0369: 		 * a deadlock involving those system tables.
1:eac0369: 		 */
1:eac0369: 		
1:eac0369: 		// for each column, stuff system.column
1:eac0369: 		int index = 1;
1:eac0369: 
1:eac0369: 		ColumnDescriptor[] cdlArray = new ColumnDescriptor[columnInfo.length];
1:eac0369: 		for (int ix = 0; ix < columnInfo.length; ix++)
1:eac0369: 		{
1:eac0369: 			UUID defaultUUID = columnInfo[ix].newDefaultUUID;
1:eac0369: 
1:eac0369: 			/* Generate a UUID for the default, if one exists
1:eac0369: 			 * and there is no default id yet.
1:eac0369: 			 */
1:eac0369: 			if (columnInfo[ix].defaultInfo != null &&
1:eac0369: 				defaultUUID == null)
1:eac0369: 			{
1:eac0369: 				defaultUUID = dd.getUUIDFactory().createUUID();
1:eac0369: 			}
1:eac0369: 
1:318307e: 			if (columnInfo[ix].autoincInc != 0)//dealing with autoinc column
1:7fd0c6e:             {
1:7fd0c6e:                 columnDescriptor = new ColumnDescriptor
1:7fd0c6e:                     (
1:7fd0c6e:                      columnInfo[ix].name,
1:7fd0c6e:                      index++,
1:7fd0c6e:                      columnInfo[ix].dataType,
1:7fd0c6e:                      columnInfo[ix].defaultValue,
1:7fd0c6e:                      columnInfo[ix].defaultInfo,
1:7fd0c6e:                      td,
1:7fd0c6e:                      defaultUUID,
1:7fd0c6e:                      columnInfo[ix].autoincStart,
1:7fd0c6e:                      columnInfo[ix].autoincInc,
1:7fd0c6e:                      columnInfo[ix].autoinc_create_or_modify_Start_Increment
1:7fd0c6e:                      );
1:7fd0c6e: 
1:7fd0c6e:                 //
1:7fd0c6e:                 // If we're at level 10.11 or higher, we create a sequence generator
1:7fd0c6e:                 // for the auto-increment column. See derby-6542.
1:7fd0c6e:                 //
1:7fd0c6e:                 if ( dd.checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, null ) )
1:7fd0c6e:                 {
1:7fd0c6e:                     CreateSequenceConstantAction    csca = makeCSCA
1:7fd0c6e:                         ( columnInfo[ ix ], TableDescriptor.makeSequenceName( toid ) );
1:7fd0c6e:                     csca.executeConstantAction( activation );
1:7fd0c6e:                 }
1:7fd0c6e:             }
1:7fd0c6e:             else
1:7fd0c6e:             {
1:7fd0c6e: 				columnDescriptor = new ColumnDescriptor
1:7fd0c6e:                     (
1:7fd0c6e:                      columnInfo[ix].name,
1:7fd0c6e:                      index++,
1:7fd0c6e:                      columnInfo[ix].dataType,
1:7fd0c6e:                      columnInfo[ix].defaultValue,
1:7fd0c6e:                      columnInfo[ix].defaultInfo,
1:7fd0c6e:                      td,
1:7fd0c6e:                      defaultUUID,
1:7fd0c6e:                      columnInfo[ix].autoincStart,
1:7fd0c6e:                      columnInfo[ix].autoincInc
1:7fd0c6e:                      );
1:7fd0c6e:             }
1:eac0369: 
1:eac0369: 			cdlArray[ix] = columnDescriptor;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1:eac0369: 		{
1:eac0369: 			dd.addDescriptorArray(cdlArray, td,
1:eac0369: 							  DataDictionary.SYSCOLUMNS_CATALOG_NUM,
1:eac0369: 							  false, tc);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// now add the column descriptors to the table.
1:eac0369: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:eac0369: 		for (int i = 0; i < cdlArray.length; i++)
1:eac0369: 			cdl.add(cdlArray[i]);
1:eac0369: 				 
1:eac0369: 		//
1:eac0369: 		// Create a conglomerate desciptor with the conglomId filled in and
1:eac0369: 		// add it.
1:eac0369: 		//
1:eac0369: 		// RESOLVE: Get information from the conglomerate descriptor which
1:eac0369: 		//          was provided. 
1:eac0369: 		//
1:eac0369: 		ConglomerateDescriptor cgd =
1:eac0369: 			ddg.newConglomerateDescriptor(conglomId, null, false, null, false, null, toid,
1:eac0369: 										  sd.getUUID());
1:eac0369: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1:eac0369: 		{
1:eac0369: 			dd.addDescriptor(cgd, sd, DataDictionary.SYSCONGLOMERATES_CATALOG_NUM,
1:eac0369: 						 false, tc);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// add the newly added conglomerate to the table descriptor
1:eac0369: 		ConglomerateDescriptorList conglomList = td.getConglomerateDescriptorList();
1:eac0369: 		conglomList.add(cgd);
1:eac0369: 
1:eac0369: 		/* Create any constraints */
1:eac0369: 		if (constraintActions != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Do everything but FK constraints first,
1:eac0369: 			** then FK constraints on 2nd pass.
1:eac0369: 			*/
1:eac0369: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
1:eac0369: 			{
1:eac0369: 				// skip fks
1:eac0369: 				if (!constraintActions[conIndex].isForeignKeyConstraint())
1:eac0369: 				{
1:eac0369: 					constraintActions[conIndex].executeConstantAction(activation);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
1:eac0369: 			{
1:eac0369: 				// only foreign keys
1:eac0369: 				if (constraintActions[conIndex].isForeignKeyConstraint())
1:eac0369: 				{
1:eac0369: 					constraintActions[conIndex].executeConstantAction(activation);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:         //
1:3c09be7:         // Add dependencies. These can arise if a generated column depends
1:3c09be7:         // on a user created function.
1:3c09be7:         //
1:3c09be7: 		for (int ix = 0; ix < columnInfo.length; ix++)
1:3c09be7: 		{
1:3c09be7:             addColumnDependencies( lcc, dd, td, columnInfo[ ix ] );
1:3c09be7:         }
1:e126f58: 
1:e126f58:         //
1:e126f58:         // The table itself can depend on the user defined types of its columns.
1:e126f58:         //
1:b8c6110:         adjustUDTDependencies( lcc, dd, td, columnInfo, false );
1:3c09be7:         
1:eac0369: 		if ( tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1:eac0369: 		{
1:eac0369: 			lcc.addDeclaredGlobalTempTable(td);
1:eac0369: 		}
1:f1f66ff: 
1:f1f66ff: 		// Indicate that the CREATE TABLE statement itself depends on the
1:f1f66ff: 		// table it is creating. Normally such statement dependencies are
1:f1f66ff: 		// added during compilation, but here we have a bootstrapping issue
1:f1f66ff: 		// because the table doesn't exist until the CREATE TABLE statement
1:f1f66ff: 		// has been executed, so we had to defer the creation of this
1:f1f66ff: 		// dependency until now. (DERBY-4479)
1:f1f66ff: 		dd.getDependencyManager().addDependency(
1:f1f66ff: 			activation.getPreparedStatement(), td, lcc.getContextManager());
1:f1f66ff: 
1:eac0369: 	}
1:eac0369: 
1:7fd0c6e:     /** Create a sequence generator for an identity column */
1:7fd0c6e:     public  static CreateSequenceConstantAction    makeCSCA
1:7fd0c6e:         ( ColumnInfo info, String sequenceName )
1:7fd0c6e:         throws StandardException
1:7fd0c6e:     {
1:7fd0c6e:         DataTypeDescriptor  dtd = info.dataType;
1:7fd0c6e:         long[]      bounds = dtd.getNumericBounds();
1:7fd0c6e:         long    minValue = bounds[ DataTypeDescriptor.MIN_VALUE_IDX ];
1:7fd0c6e:         long    maxValue = bounds[ DataTypeDescriptor.MAX_VALUE_IDX ];
1:7fd0c6e: 
1:d055adb: 	boolean cycling=false;
1:d055adb: 
1:d055adb: 	if(info.autoincCycle==1)
1:d055adb: 		cycling=true;
1:d055adb: 	
1:7fd0c6e:         return new CreateSequenceConstantAction
1:7fd0c6e:             (
1:7fd0c6e:              SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME,
1:7fd0c6e:              sequenceName,
1:7fd0c6e:              dtd,
1:7fd0c6e:              info.autoincStart,
1:7fd0c6e:              info.autoincInc,
1:7fd0c6e:              maxValue,
1:7fd0c6e:              minValue,
1:d055adb:              cycling
1:7fd0c6e:              );
1:7fd0c6e:     }
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1: 	boolean cycling=false;
1: 
1: 	if(info.autoincCycle==1)
1: 		cycling=true;
1: 	
/////////////////////////////////////////////////////////////////////////
1:              cycling
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:f1f66ff
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Indicate that the CREATE TABLE statement itself depends on the
1: 		// table it is creating. Normally such statement dependencies are
1: 		// added during compilation, but here we have a bootstrapping issue
1: 		// because the table doesn't exist until the CREATE TABLE statement
1: 		// has been executed, so we had to defer the creation of this
1: 		// dependency until now. (DERBY-4479)
1: 		dd.getDependencyManager().addDependency(
1: 			activation.getPreparedStatement(), td, lcc.getContextManager());
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: 
/////////////////////////////////////////////////////////////////////////
1:             {
1:                 columnDescriptor = new ColumnDescriptor
1:                     (
1:                      columnInfo[ix].name,
1:                      index++,
1:                      columnInfo[ix].dataType,
1:                      columnInfo[ix].defaultValue,
1:                      columnInfo[ix].defaultInfo,
1:                      td,
1:                      defaultUUID,
1:                      columnInfo[ix].autoincStart,
1:                      columnInfo[ix].autoincInc,
1:                      columnInfo[ix].autoinc_create_or_modify_Start_Increment
1:                      );
1: 
1:                 //
1:                 // If we're at level 10.11 or higher, we create a sequence generator
1:                 // for the auto-increment column. See derby-6542.
1:                 //
1:                 if ( dd.checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, null ) )
1:                 {
1:                     CreateSequenceConstantAction    csca = makeCSCA
1:                         ( columnInfo[ ix ], TableDescriptor.makeSequenceName( toid ) );
1:                     csca.executeConstantAction( activation );
1:                 }
1:             }
1:             else
1:             {
1: 				columnDescriptor = new ColumnDescriptor
1:                     (
1:                      columnInfo[ix].name,
1:                      index++,
1:                      columnInfo[ix].dataType,
1:                      columnInfo[ix].defaultValue,
1:                      columnInfo[ix].defaultInfo,
1:                      td,
1:                      defaultUUID,
1:                      columnInfo[ix].autoincStart,
1:                      columnInfo[ix].autoincInc
1:                      );
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /** Create a sequence generator for an identity column */
1:     public  static CreateSequenceConstantAction    makeCSCA
1:         ( ColumnInfo info, String sequenceName )
1:         throws StandardException
1:     {
1:         DataTypeDescriptor  dtd = info.dataType;
1:         long[]      bounds = dtd.getNumericBounds();
1:         long    minValue = bounds[ DataTypeDescriptor.MIN_VALUE_IDX ];
1:         long    maxValue = bounds[ DataTypeDescriptor.MAX_VALUE_IDX ];
1: 
1:         return new CreateSequenceConstantAction
1:             (
1:              SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME,
1:              sequenceName,
1:              dtd,
1:              info.autoincStart,
1:              info.autoincInc,
1:              maxValue,
1:              minValue,
0:              false
1:              );
1:     }
commit:b8c6110
/////////////////////////////////////////////////////////////////////////
1:         adjustUDTDependencies( lcc, dd, td, columnInfo, false );
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // The table itself can depend on the user defined types of its columns.
1:         //
0:         adjustUDTDependencies( lcc, dd, td, columnInfo );
commit:3c09be7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.DependableFinder;
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // Add dependencies. These can arise if a generated column depends
1:         // on a user created function.
1:         //
1: 		for (int ix = 0; ix < columnInfo.length; ix++)
1: 		{
1:             addColumnDependencies( lcc, dd, td, columnInfo[ ix ] );
1:         }
1:         
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:         // setup for create conglomerate call:
1:         //   o create row template to tell the store what type of rows this
1:         //     table holds.
1:         //   o create array of collation id's to tell collation id of each
1:         //     column in table.
1: 		template            = RowUtil.getEmptyValueRow(columnInfo.length, lcc);
1:         int[] collation_ids = new int[columnInfo.length];
1:             ColumnInfo  col_info = columnInfo[ix];
1: 
1:             // Get a template value for each column
1: 
1: 			if (col_info.defaultValue != null)
1:             {
1:                 /* If there is a default value, use it, otherwise use null */
1: 				template.setColumn(ix + 1, col_info.defaultValue);
1:             }
1:             {
1: 				template.setColumn(ix + 1, col_info.dataType.getNull());
1:             }
1: 
1:             // get collation info for each column.
1: 
1:             collation_ids[ix] = col_info.dataType.getCollationType();
1: 
/////////////////////////////////////////////////////////////////////////
1:                 collation_ids,
1:                     (TransactionController.IS_TEMPORARY | 
1:                      TransactionController.IS_KEPT) : 
1:                         TransactionController.IS_DEFAULT);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
1: 			if (columnInfo[ix].autoincInc != 0)//dealing with autoinc column
/////////////////////////////////////////////////////////////////////////
1: 			else
0: 				columnDescriptor = new ColumnDescriptor(
0: 		                   columnInfo[ix].name,
0: 						   index++,
0: 						   columnInfo[ix].dataType,
0: 						   columnInfo[ix].defaultValue,
0: 						   columnInfo[ix].defaultInfo,
0: 						   td,
0: 						   defaultUUID,
0: 						   columnInfo[ix].autoincStart,
0: 						   columnInfo[ix].autoincInc
0: 					   );
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
0: 								   columnInfo[ix].autoincInc != 0,
0: 								   columnInfo[ix].autoinc_create_or_modify_Start_Increment
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.CreateTableConstantAction
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: 
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: 
1: import java.util.Properties;
1: 
1: /**
1:  *	This class  describes actions that are ALWAYS performed for a
1:  *	CREATE TABLE Statement at Execution time.
1:  *
0:  *	@author Rick Hillegas	Extracted code from CreateTableResultSet.
1:  */
1: 
1: class CreateTableConstantAction extends DDLConstantAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private char					lockGranularity;
1: 	private boolean					onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	private boolean					onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
1: 	private String					tableName;
1: 	private String					schemaName;
1: 	private int						tableType;
1: 	private ColumnInfo[]			columnInfo;
1: 	private CreateConstraintConstantAction[]	constraintActions;
1: 	private Properties				properties;
1: 	
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE TABLE statement.
1: 	 *
1: 	 *  @param schemaName	name for the schema that table lives in.
1: 	 *  @param tableName	Name of table.
1: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
1: 	 *  @param columnInfo	Information on all the columns in the table.
1: 	 *		 (REMIND tableDescriptor ignored)
1: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
1: 	 *  @param properties	Optional table properties
1: 	 * @param lockGranularity	The lock granularity.
1: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1: 	 */
1: 	CreateTableConstantAction(
1: 								String			schemaName,
1: 								String			tableName,
1: 								int				tableType,
1: 								ColumnInfo[]	columnInfo,
1: 								CreateConstraintConstantAction[] constraintActions,
1: 								Properties		properties,
1: 								char			lockGranularity,
1: 								boolean			onCommitDeleteRows,
1: 								boolean			onRollbackDeleteRows)
1: 	{
1: 		this.schemaName = schemaName;
1: 		this.tableName = tableName;
1: 		this.tableType = tableType;
1: 		this.columnInfo = columnInfo;
1: 		this.constraintActions = constraintActions;
1: 		this.properties = properties;
1: 		this.lockGranularity = lockGranularity;
1: 		this.onCommitDeleteRows = onCommitDeleteRows;
1: 		this.onRollbackDeleteRows = onRollbackDeleteRows;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (tableType == TableDescriptor.BASE_TABLE_TYPE && lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
1: 				lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Unexpected value for lockGranularity = " + lockGranularity);
1: 			}
1: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE && onRollbackDeleteRows == false)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Unexpected value for onRollbackDeleteRows = " + onRollbackDeleteRows);
1: 			}
1: 			SanityManager.ASSERT(schemaName != null, "SchemaName is null");
1: 		}
1: 	}
1: 
1: 	// OBJECT METHODS
1: 
1: 	public	String	toString()
1: 	{
1: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			return constructToString("DECLARE GLOBAL TEMPORARY TABLE ", tableName);
1: 		else
1: 			return constructToString("CREATE TABLE ", tableName);
1: 	}
1: 
1: 	// INTERFACE METHODS
1: 
1: 
1: 	/**
1: 	 *	This is the guts of the Execution-time logic for CREATE TABLE.
1: 	 *
1: 	 *	@see ConstantAction#executeConstantAction
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public void	executeConstantAction( Activation activation )
1: 		throws StandardException
1: 	{
1: 		TableDescriptor 			td;
1: 		UUID 						toid;
1: 		SchemaDescriptor			schemaDescriptor;
1: 		ColumnDescriptor			columnDescriptor;
1: 		ExecRow						template;
1: 
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 		DependencyManager dm = dd.getDependencyManager();
1: 		TransactionController tc = lcc.getTransactionExecute();
1: 
1: 		/* Mark the activation as being for create table */
1: 		activation.setForCreateTable();
1: 
1: 		/*
0: 		** Create a row template to tell the store what type of rows this table
0: 		** holds.
1: 		*/
0: 		template = RowUtil.getEmptyValueRow(columnInfo.length, lcc);
1: 
0: 		/* Get a template value for each column */
1: 		for (int ix = 0; ix < columnInfo.length; ix++)
1: 		{
0: 			/* If there is a default value, use it, otherwise use null */
0: 			if (columnInfo[ix].defaultValue != null)
0: 				template.setColumn(ix + 1, columnInfo[ix].defaultValue);
1: 			else
0: 				template.setColumn(ix + 1,
0: 									columnInfo[ix].dataType.getNull()
0: 								);
1: 		}
1: 
1: 		/* create the conglomerate to hold the table's rows
1: 		 * RESOLVE - If we ever have a conglomerate creator
1: 		 * that lets us specify the conglomerate number then
1: 		 * we will need to handle it here.
1: 		 */
1: 		long conglomId = tc.createConglomerate(
1: 				"heap", // we're requesting a heap conglomerate
1: 				template.getRowArray(), // row template
1: 				null, //column sort order - not required for heap
1: 				properties, // properties
1: 				tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE ?
0: 				(TransactionController.IS_TEMPORARY | TransactionController.IS_KEPT) : TransactionController.IS_DEFAULT);
1: 
1: 		/*
1: 		** Inform the data dictionary that we are about to write to it.
1: 		** There are several calls to data dictionary "get" methods here
1: 		** that might be done in "read" mode in the data dictionary, but
1: 		** it seemed safer to do this whole operation in "write" mode.
1: 		**
1: 		** We tell the data dictionary we're done writing at the end of
1: 		** the transaction.
1: 		*/
1: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1: 			dd.startWriting(lcc);
1: 
1: 		SchemaDescriptor sd;
1: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
1: 		else
1: 			sd = DDLConstantAction.getSchemaDescriptorForCreate(dd, activation, schemaName);
1: 
1: 		//
1: 		// Create a new table descriptor.
1: 		// 
1: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1: 
1: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1: 		{
1: 			td = ddg.newTableDescriptor(tableName, sd, tableType, lockGranularity);
1: 			dd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);
1: 		} else
1: 		{
1: 			td = ddg.newTableDescriptor(tableName, sd, tableType, onCommitDeleteRows, onRollbackDeleteRows);
1: 			td.setUUID(dd.getUUIDFactory().createUUID());
1: 		}
1: 		toid = td.getUUID();
1: 
1: 		// Save the TableDescriptor off in the Activation
1: 		activation.setDDLTableDescriptor(td);
1: 
1: 		/* NOTE: We must write the columns out to the system
1: 		 * tables before any of the conglomerates, including
1: 		 * the heap, since we read the columns before the
1: 		 * conglomerates when building a TableDescriptor.
1: 		 * This will hopefully reduce the probability of
1: 		 * a deadlock involving those system tables.
1: 		 */
1: 		
1: 		// for each column, stuff system.column
1: 		int index = 1;
1: 
1: 		ColumnDescriptor[] cdlArray = new ColumnDescriptor[columnInfo.length];
1: 		for (int ix = 0; ix < columnInfo.length; ix++)
1: 		{
1: 			UUID defaultUUID = columnInfo[ix].newDefaultUUID;
1: 
1: 			/* Generate a UUID for the default, if one exists
1: 			 * and there is no default id yet.
1: 			 */
1: 			if (columnInfo[ix].defaultInfo != null &&
1: 				defaultUUID == null)
1: 			{
1: 				defaultUUID = dd.getUUIDFactory().createUUID();
1: 			}
1: 
0: 			columnDescriptor = new ColumnDescriptor(
0: 				                   columnInfo[ix].name,
0: 								   index++,
0: 								   columnInfo[ix].dataType,
0: 								   columnInfo[ix].defaultValue,
0: 								   columnInfo[ix].defaultInfo,
0: 								   td,
0: 								   defaultUUID,
0: 								   columnInfo[ix].autoincStart,
0: 								   columnInfo[ix].autoincInc,
0: 								   columnInfo[ix].autoincInc != 0
0: 							   );
1: 
1: 			cdlArray[ix] = columnDescriptor;
1: 
0: 			if (columnInfo[ix].defaultInfo != null)
1: 			{
0: 				DefaultDescriptor defaultDescriptor = new DefaultDescriptor(dd, defaultUUID, td.getUUID(), ix + 1);
1: 
0: 				/* Create stored dependencies for each provider to default */
0: 				ProviderInfo[] providerInfo = ((DefaultInfoImpl) columnInfo[ix].defaultInfo).getProviderInfo();
0: 				int providerInfoLength = (providerInfo == null) ? 0 : providerInfo.length;
0: 				for (int provIndex = 0; provIndex < providerInfoLength; provIndex++)
1: 				{
0: 					Provider provider = null;
1: 
0: 					/* We should always be able to find the Provider */
0: 					try 
1: 					{
0: 						provider = (Provider) providerInfo[provIndex].
0: 												getDependableFinder().
0: 													getDependable(
0: 														providerInfo[provIndex].getObjectId());
1: 					}
0: 					catch(java.sql.SQLException te)
1: 					{
1: 						if (SanityManager.DEBUG)
1: 						{
0: 							SanityManager.THROWASSERT("unexpected java.sql.SQLException - " + te);
1: 						}
1: 					}
0: 					dm.addDependency(defaultDescriptor, provider, lcc.getContextManager());
1: 				}
1: 			}
1: 		}
1: 
1: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1: 		{
1: 			dd.addDescriptorArray(cdlArray, td,
1: 							  DataDictionary.SYSCOLUMNS_CATALOG_NUM,
1: 							  false, tc);
1: 		}
1: 
1: 		// now add the column descriptors to the table.
1: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1: 		for (int i = 0; i < cdlArray.length; i++)
1: 			cdl.add(cdlArray[i]);
1: 				 
1: 		//
1: 		// Create a conglomerate desciptor with the conglomId filled in and
1: 		// add it.
1: 		//
1: 		// RESOLVE: Get information from the conglomerate descriptor which
1: 		//          was provided. 
1: 		//
1: 		ConglomerateDescriptor cgd =
1: 			ddg.newConglomerateDescriptor(conglomId, null, false, null, false, null, toid,
1: 										  sd.getUUID());
1: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1: 		{
1: 			dd.addDescriptor(cgd, sd, DataDictionary.SYSCONGLOMERATES_CATALOG_NUM,
1: 						 false, tc);
1: 		}
1: 
1: 		// add the newly added conglomerate to the table descriptor
1: 		ConglomerateDescriptorList conglomList = td.getConglomerateDescriptorList();
1: 		conglomList.add(cgd);
1: 
1: 		/* Create any constraints */
1: 		if (constraintActions != null)
1: 		{
1: 			/*
1: 			** Do everything but FK constraints first,
1: 			** then FK constraints on 2nd pass.
1: 			*/
1: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
1: 			{
1: 				// skip fks
1: 				if (!constraintActions[conIndex].isForeignKeyConstraint())
1: 				{
1: 					constraintActions[conIndex].executeConstantAction(activation);
1: 				}
1: 			}
1: 
1: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
1: 			{
1: 				// only foreign keys
1: 				if (constraintActions[conIndex].isForeignKeyConstraint())
1: 				{
1: 					constraintActions[conIndex].executeConstantAction(activation);
1: 				}
1: 			}
1: 		}
1: 		if ( tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
1: 		{
1: 			lcc.addDeclaredGlobalTempTable(td);
1: 		}
1: 	}
1: 
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  *	This class  describes actions that are ALWAYS performed for a
0:  *	CREATE TABLE Statement at Execution time.
0:  *
0:  *	@author Rick Hillegas	Extracted code from CreateTableResultSet.
0:  */
0: 
0: class CreateTableConstantAction extends DDLConstantAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private char					lockGranularity;
0: 	private boolean					onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	private boolean					onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
0: 	private String					tableName;
0: 	private String					schemaName;
0: 	private int						tableType;
0: 	private ColumnInfo[]			columnInfo;
0: 	private CreateConstraintConstantAction[]	constraintActions;
0: 	private Properties				properties;
0: 	
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE TABLE statement.
0: 	 *
0: 	 *  @param schemaName	name for the schema that table lives in.
0: 	 *  @param tableName	Name of table.
0: 	 *  @param tableType	Type of table (e.g., BASE, global temporary table).
0: 	 *  @param columnInfo	Information on all the columns in the table.
0: 	 *		 (REMIND tableDescriptor ignored)
0: 	 *  @param constraintActions	CreateConstraintConstantAction[] for constraints
0: 	 *  @param properties	Optional table properties
0: 	 * @param lockGranularity	The lock granularity.
0: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
0: 	 */
0: 	CreateTableConstantAction(
0: 								String			schemaName,
0: 								String			tableName,
0: 								int				tableType,
0: 								ColumnInfo[]	columnInfo,
0: 								CreateConstraintConstantAction[] constraintActions,
0: 								Properties		properties,
0: 								char			lockGranularity,
0: 								boolean			onCommitDeleteRows,
0: 								boolean			onRollbackDeleteRows)
0: 	{
0: 		this.schemaName = schemaName;
0: 		this.tableName = tableName;
0: 		this.tableType = tableType;
0: 		this.columnInfo = columnInfo;
0: 		this.constraintActions = constraintActions;
0: 		this.properties = properties;
0: 		this.lockGranularity = lockGranularity;
0: 		this.onCommitDeleteRows = onCommitDeleteRows;
0: 		this.onRollbackDeleteRows = onRollbackDeleteRows;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (tableType == TableDescriptor.BASE_TABLE_TYPE && lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
0: 				lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"Unexpected value for lockGranularity = " + lockGranularity);
0: 			}
0: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE && onRollbackDeleteRows == false)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"Unexpected value for onRollbackDeleteRows = " + onRollbackDeleteRows);
0: 			}
0: 			SanityManager.ASSERT(schemaName != null, "SchemaName is null");
0: 		}
0: 	}
0: 
0: 	// OBJECT METHODS
0: 
0: 	public	String	toString()
0: 	{
0: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 			return constructToString("DECLARE GLOBAL TEMPORARY TABLE ", tableName);
0: 		else
0: 			return constructToString("CREATE TABLE ", tableName);
0: 	}
0: 
0: 	// INTERFACE METHODS
0: 
0: 
0: 	/**
0: 	 *	This is the guts of the Execution-time logic for CREATE TABLE.
0: 	 *
0: 	 *	@see ConstantAction#executeConstantAction
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void	executeConstantAction( Activation activation )
0: 		throws StandardException
0: 	{
0: 		TableDescriptor 			td;
0: 		UUID 						toid;
0: 		SchemaDescriptor			schemaDescriptor;
0: 		ColumnDescriptor			columnDescriptor;
0: 		ExecRow						template;
0: 
0: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
0: 		DataDictionary dd = lcc.getDataDictionary();
0: 		DependencyManager dm = dd.getDependencyManager();
0: 		TransactionController tc = lcc.getTransactionExecute();
0: 
0: 		/* Mark the activation as being for create table */
0: 		activation.setForCreateTable();
0: 
0: 		/*
0: 		** Create a row template to tell the store what type of rows this table
0: 		** holds.
0: 		*/
0: 		template = RowUtil.getEmptyValueRow(columnInfo.length, lcc);
0: 
0: 		/* Get a template value for each column */
0: 		for (int ix = 0; ix < columnInfo.length; ix++)
0: 		{
0: 			/* If there is a default value, use it, otherwise use null */
0: 			if (columnInfo[ix].defaultValue != null)
0: 				template.setColumn(ix + 1, columnInfo[ix].defaultValue);
0: 			else
0: 				template.setColumn(ix + 1,
0: 									columnInfo[ix].dataType.getNull()
0: 								);
0: 		}
0: 
0: 		/* create the conglomerate to hold the table's rows
0: 		 * RESOLVE - If we ever have a conglomerate creator
0: 		 * that lets us specify the conglomerate number then
0: 		 * we will need to handle it here.
0: 		 */
0: 		long conglomId = tc.createConglomerate(
0: 				"heap", // we're requesting a heap conglomerate
0: 				template.getRowArray(), // row template
0: 				null, //column sort order - not required for heap
0: 				properties, // properties
0: 				tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE ?
0: 				(TransactionController.IS_TEMPORARY | TransactionController.IS_KEPT) : TransactionController.IS_DEFAULT);
0: 
0: 		/*
0: 		** Inform the data dictionary that we are about to write to it.
0: 		** There are several calls to data dictionary "get" methods here
0: 		** that might be done in "read" mode in the data dictionary, but
0: 		** it seemed safer to do this whole operation in "write" mode.
0: 		**
0: 		** We tell the data dictionary we're done writing at the end of
0: 		** the transaction.
0: 		*/
0: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
0: 			dd.startWriting(lcc);
0: 
0: 		SchemaDescriptor sd;
0: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		else
0: 			sd = DDLConstantAction.getSchemaDescriptorForCreate(dd, activation, schemaName);
0: 
0: 		//
0: 		// Create a new table descriptor.
0: 		// 
0: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
0: 
0: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
0: 		{
0: 			td = ddg.newTableDescriptor(tableName, sd, tableType, lockGranularity);
0: 			dd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);
0: 		} else
0: 		{
0: 			td = ddg.newTableDescriptor(tableName, sd, tableType, onCommitDeleteRows, onRollbackDeleteRows);
0: 			td.setUUID(dd.getUUIDFactory().createUUID());
0: 		}
0: 		toid = td.getUUID();
0: 
0: 		// Save the TableDescriptor off in the Activation
0: 		activation.setDDLTableDescriptor(td);
0: 
0: 		/* NOTE: We must write the columns out to the system
0: 		 * tables before any of the conglomerates, including
0: 		 * the heap, since we read the columns before the
0: 		 * conglomerates when building a TableDescriptor.
0: 		 * This will hopefully reduce the probability of
0: 		 * a deadlock involving those system tables.
0: 		 */
0: 		
0: 		// for each column, stuff system.column
0: 		int index = 1;
0: 
0: 		ColumnDescriptor[] cdlArray = new ColumnDescriptor[columnInfo.length];
0: 		for (int ix = 0; ix < columnInfo.length; ix++)
0: 		{
0: 			UUID defaultUUID = columnInfo[ix].newDefaultUUID;
0: 
0: 			/* Generate a UUID for the default, if one exists
0: 			 * and there is no default id yet.
0: 			 */
0: 			if (columnInfo[ix].defaultInfo != null &&
0: 				defaultUUID == null)
0: 			{
0: 				defaultUUID = dd.getUUIDFactory().createUUID();
0: 			}
0: 
0: 			columnDescriptor = new ColumnDescriptor(
0: 				                   columnInfo[ix].name,
0: 								   index++,
0: 								   columnInfo[ix].dataType,
0: 								   columnInfo[ix].defaultValue,
0: 								   columnInfo[ix].defaultInfo,
0: 								   td,
0: 								   defaultUUID,
0: 								   columnInfo[ix].autoincStart,
0: 								   columnInfo[ix].autoincInc,
0: 								   columnInfo[ix].autoincInc != 0
0: 							   );
0: 
0: 			cdlArray[ix] = columnDescriptor;
0: 
0: 			if (columnInfo[ix].defaultInfo != null)
0: 			{
0: 				DefaultDescriptor defaultDescriptor = new DefaultDescriptor(dd, defaultUUID, td.getUUID(), ix + 1);
0: 
0: 				/* Create stored dependencies for each provider to default */
0: 				ProviderInfo[] providerInfo = ((DefaultInfoImpl) columnInfo[ix].defaultInfo).getProviderInfo();
0: 				int providerInfoLength = (providerInfo == null) ? 0 : providerInfo.length;
0: 				for (int provIndex = 0; provIndex < providerInfoLength; provIndex++)
0: 				{
0: 					Provider provider = null;
0: 
0: 					/* We should always be able to find the Provider */
0: 					try 
0: 					{
0: 						provider = (Provider) providerInfo[provIndex].
0: 												getDependableFinder().
0: 													getDependable(
0: 														providerInfo[provIndex].getObjectId());
0: 					}
0: 					catch(java.sql.SQLException te)
0: 					{
0: 						if (SanityManager.DEBUG)
0: 						{
0: 							SanityManager.THROWASSERT("unexpected java.sql.SQLException - " + te);
0: 						}
0: 					}
0: 					dm.addDependency(defaultDescriptor, provider, lcc.getContextManager());
0: 				}
0: 			}
0: 		}
0: 
0: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
0: 		{
0: 			dd.addDescriptorArray(cdlArray, td,
0: 							  DataDictionary.SYSCOLUMNS_CATALOG_NUM,
0: 							  false, tc);
0: 		}
0: 
0: 		// now add the column descriptors to the table.
0: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
0: 		for (int i = 0; i < cdlArray.length; i++)
0: 			cdl.add(cdlArray[i]);
0: 				 
0: 		//
0: 		// Create a conglomerate desciptor with the conglomId filled in and
0: 		// add it.
0: 		//
0: 		// RESOLVE: Get information from the conglomerate descriptor which
0: 		//          was provided. 
0: 		//
0: 		ConglomerateDescriptor cgd =
0: 			ddg.newConglomerateDescriptor(conglomId, null, false, null, false, null, toid,
0: 										  sd.getUUID());
0: 		if ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
0: 		{
0: 			dd.addDescriptor(cgd, sd, DataDictionary.SYSCONGLOMERATES_CATALOG_NUM,
0: 						 false, tc);
0: 		}
0: 
0: 		// add the newly added conglomerate to the table descriptor
0: 		ConglomerateDescriptorList conglomList = td.getConglomerateDescriptorList();
0: 		conglomList.add(cgd);
0: 
0: 		/* Create any constraints */
0: 		if (constraintActions != null)
0: 		{
0: 			/*
0: 			** Do everything but FK constraints first,
0: 			** then FK constraints on 2nd pass.
0: 			*/
0: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
0: 			{
0: 				// skip fks
0: 				if (!constraintActions[conIndex].isForeignKeyConstraint())
0: 				{
0: 					constraintActions[conIndex].executeConstantAction(activation);
0: 				}
0: 			}
0: 
0: 			for (int conIndex = 0; conIndex < constraintActions.length; conIndex++)
0: 			{
0: 				// only foreign keys
0: 				if (constraintActions[conIndex].isForeignKeyConstraint())
0: 				{
0: 					constraintActions[conIndex].executeConstantAction(activation);
0: 				}
0: 			}
0: 		}
0: 		if ( tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE )
0: 		{
0: 			lcc.addDeclaredGlobalTempTable(td);
0: 		}
0: 	}
0: 
0: 
0: }
============================================================================