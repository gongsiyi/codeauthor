1:fe77ca5: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.classfile.ClassHolder
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
6:fe77ca5: 
3:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package org.apache.derby.iapi.services.classfile;
1:fe77ca5: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: import java.io.InputStream;
1:fe77ca5: import java.io.OutputStream;
1:fe77ca5: import java.util.Enumeration;
1:fe77ca5: 
1:fe77ca5: import java.io.IOException;
1:fe77ca5: import java.util.Vector;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.util.ByteArray;
1:fe77ca5: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1:fe77ca5: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1:fe77ca5: 
1:fe77ca5: import java.util.Hashtable;
1:fe77ca5: import java.util.Vector;
1:fe77ca5: import java.util.Enumeration;
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: /** Based upon "THE class FILE FORMAT" chapter of "The Java Virtual Machine Specification"
1:fe77ca5:     corresponding to version 1.0.2 of the Java Virtual Machine and 1.0.2 of the
1:fe77ca5: 	Java Language Specification.
1:fe77ca5: 
1:fe77ca5:     ISBN  0-201-63452-X, September 1996.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: public class ClassHolder {
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Constants.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Fields
1:fe77ca5: 	*/
1:75f38ef:     
1:75f38ef:     /**
1:75f38ef:      * Minor class format number defaults to 
1:75f38ef:      * VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION
1:75f38ef:      * which currently corresponds to a really old (JDK 1.0.2) setting.
1:75f38ef:      * The default major and minor value is used by the generated code for Derby's
1:75f38ef:      * SQL statements. Currently there is no need to bump the version
1:75f38ef:      * number as the generated code does not take advantage of any of the
1:75f38ef:      * new elements in the class file format. If such a need exists then
1:75f38ef:      * this can be bumped. One issue is that the change in format numbers
1:75f38ef:      * is not well documented.
1:75f38ef:      */
1:75f38ef:     protected int minor_version = VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION;
1:fe77ca5: 
1:75f38ef:     /**
1:75f38ef:      * Minor class format number defaults to 
1:75f38ef:      * VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION
1:75f38ef:      */
1:75f38ef:     protected int major_version = VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION;
1:75f38ef:     
1:fe77ca5: 	protected int access_flags;
1:fe77ca5: 	protected int this_class;
1:fe77ca5: 	protected int super_class;
1:fe77ca5: 
1:fe77ca5: 	// protected InterfacesArray interfaces; // can be null
1:fe77ca5: 	protected int[] interfaces; //can be null
1:fe77ca5: 
1:fe77ca5: 	protected MemberTable field_info; // can be null
1:fe77ca5: 	protected MemberTable method_info;	// can be null
1:fe77ca5: 	protected Attributes attribute_info; // can be null
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Fields for Constant Pool Table
1:fe77ca5: 	*/
1:996ca72: 	protected Hashtable<Object,ConstantPoolEntry> cptHashTable;
1:996ca72: 	protected Vector<ConstantPoolEntry> cptEntries;
1:fe77ca5: 	private int cptEstimatedSize;
1:fe77ca5: 
3:fe77ca5: 	/**
1:fe77ca5: 		Used to search for index entries to avoid object allocation
1:fe77ca5: 		in the case a referecne already exists.
1:fe77ca5: 	*/
1:fe77ca5: 	private final CONSTANT_Index_info	searchIndex = new CONSTANT_Index_info(0, 0, 0);
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	**	Constructors.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	protected ClassHolder(int estimatedConstantPoolCount) {
1:fe77ca5: 		// Constant Pool Information
1:fe77ca5: 		// 100 is the estimate of the number of entries that will be generated
1:996ca72: 		cptEntries = new Vector<ConstantPoolEntry>(estimatedConstantPoolCount);
1:996ca72: 		cptHashTable = new Hashtable<Object,ConstantPoolEntry>(estimatedConstantPoolCount, (float)0.75);
1:fe77ca5: 
1:fe77ca5: 		// reserve the 0'th constant pool entry
1:fe77ca5: 		cptEntries.setSize(1);
4:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		This will not define a constructor -- it is up
1:fe77ca5: 		to the caller to add at least one.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	public ClassHolder(String fullyQualifiedName, String superClassName,
1:fe77ca5: 		int modifiers) {
1:fe77ca5: 
1:fe77ca5: 		this(100);
1:fe77ca5: 
1:fe77ca5: 		access_flags = modifiers | /* Modifier.SUPER */ 0x0020;
1:fe77ca5: 
1:fe77ca5: 		this_class = addClassReference(fullyQualifiedName);
1:fe77ca5: 		super_class = addClassReference(superClassName);
1:fe77ca5: 		method_info = new MemberTable(0);
1:fe77ca5: 	}
1:fe77ca5: 
1:a9b4b8d: 	private void put(ClassFormatOutput out) throws IOException {
1:fe77ca5: 
1:fe77ca5: 		/* Write out the header */
1:fe77ca5: 		out.putU4(VMDescriptor.JAVA_CLASS_FORMAT_MAGIC);
1:75f38ef: 		out.putU2(minor_version);
1:75f38ef: 		out.putU2(major_version);
1:fe77ca5: 
1:a9b4b8d: 		// special case checking that the number of constant
1:a9b4b8d: 		// pool entries does not exceed the limit of 65535
1:a9b4b8d: 		// (as it is stored as a U2).
1:a9b4b8d: 		// Special case to allow somewhat easier debugging
1:a9b4b8d: 		// of the resulting failure.
1:a9b4b8d: 		out.putU2("constant_pool", cptEntries.size());
1:fe77ca5: 		cptPut(out);
1:fe77ca5: 
1:fe77ca5: 		out.putU2(access_flags);
1:fe77ca5: 		out.putU2(this_class);
1:fe77ca5: 		out.putU2(super_class);
1:fe77ca5: 
1:fe77ca5: 		if (interfaces != null) {
1:fe77ca5: 			int ilen = interfaces.length;
1:fe77ca5: 			out.putU2(ilen);
1:fe77ca5: 			for (int i = 0; i < ilen; i++) {
1:fe77ca5: 				out.putU2(interfaces[i]);
1:fe77ca5: 			}
1:fe77ca5: 		} else {
1:fe77ca5: 			out.putU2(0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (field_info != null) {
1:fe77ca5: 			out.putU2(field_info.size());
1:fe77ca5: 			field_info.put(out);
1:fe77ca5: 		} else {
1:fe77ca5: 			out.putU2(0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (method_info != null) {
1:fe77ca5: 			out.putU2(method_info.size());
1:fe77ca5: 			method_info.put(out);
1:fe77ca5: 		} else {
1:fe77ca5: 			out.putU2(0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (attribute_info != null) {
1:fe77ca5: 			out.putU2(attribute_info.size());
1:fe77ca5: 			attribute_info.put(out);
1:fe77ca5: 		} else {
1:fe77ca5: 			out.putU2(0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	**	Public methods from ClassHolder.
1:fe77ca5: 	*/
1:fe77ca5: 
1:a9b4b8d: 	/**
1:a9b4b8d: 	 * Convert the object representation of the class into
1:a9b4b8d: 	 * its class file format.
1:a9b4b8d: 	 * @exception IOException error writing the class
1:a9b4b8d: 	 */
1:a9b4b8d: 	public ByteArray getFileFormat() throws IOException {
1:fe77ca5: 
1:fe77ca5: 		int classFileSize = 4 + (10 * 2);
1:fe77ca5: 		classFileSize += cptEstimatedSize;
1:fe77ca5: 
1:fe77ca5: 		if (interfaces != null)
1:fe77ca5: 			classFileSize += (interfaces.length * 2);
1:fe77ca5: 
1:fe77ca5: 		if (field_info != null)
1:fe77ca5: 			classFileSize += field_info.classFileSize();
1:fe77ca5: 
1:fe77ca5: 		if (method_info != null)
1:fe77ca5: 			classFileSize += method_info.classFileSize();
1:fe77ca5: 
1:fe77ca5: 		if (attribute_info != null)
1:fe77ca5: 			classFileSize += attribute_info.classFileSize();
1:a9b4b8d: 
1:fe77ca5: 	
1:a9b4b8d: 		ClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);
1:fe77ca5: 
1:a9b4b8d: 		put(cfo);
1:fe77ca5: 
1:a9b4b8d: 		return new ByteArray(cfo.getData(), 0, cfo.size());
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Public methods from ClassMember
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassMember
1:fe77ca5: 	*/
1:fe77ca5: 	public int getModifier() { return access_flags; }
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassMember
1:fe77ca5: 	*/
1:fe77ca5: 	public String getName() {
1:fe77ca5: 		return className(this_class).replace('/', '.');
1:fe77ca5: 	}
1:fe77ca5: 	/*
1:fe77ca5: 	**	Public methods from ClassHolder
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassHolder#addMember */
1:fe77ca5:  	public ClassMember addMember(String simpleName, String descriptor, int modifier)
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			if (descriptor.startsWith("(")) {
1:fe77ca5: 				if (method_info != null) {
1:fe77ca5: 					if (method_info.find(simpleName, descriptor) != null) {
1:fe77ca5: 						SanityManager.THROWASSERT("Method already exists " + simpleName + " " + descriptor);
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5: 			} else {
1:fe77ca5: 				if (field_info != null) {
1:fe77ca5: 					if (field_info.find(simpleName, descriptor) != null) {
1:fe77ca5: 						SanityManager.THROWASSERT("Field already exists " + simpleName + " " + descriptor);
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		CONSTANT_Utf8_info utf = addUtf8Entry(simpleName);
1:fe77ca5: 
1:fe77ca5: 		int nameIndex = utf.getIndex();
1:fe77ca5: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
1:fe77ca5: 
1:fe77ca5: 		ClassMember item = new ClassMember(this, modifier, nameIndex, descriptorIndex);
1:fe77ca5: 		MemberTable mt;
1:fe77ca5: 		if (descriptor.startsWith("(")) {
1:fe77ca5: 			mt = method_info;
1:fe77ca5: 			if (mt == null)
1:fe77ca5: 				mt = method_info = new MemberTable(0);
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			mt = field_info;
1:fe77ca5: 			if (mt == null)
1:fe77ca5: 				mt = field_info = new MemberTable(0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		mt.addEntry(item);
1:fe77ca5: 		return item;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassHolder#addFieldReference */
1:fe77ca5: 	public int addFieldReference(String className, String simpleName, String descriptor) {
1:fe77ca5: 		return addReference(VMDescriptor.CONSTANT_Fieldref, className, simpleName, descriptor);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	public int addFieldReference(ClassMember field) {
1:fe77ca5: 		return addReference(VMDescriptor.CONSTANT_Fieldref, (ClassMember) field);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassHolder#addMethodReference */
1:fe77ca5: 	public int addMethodReference(String className, String simpleName, String descriptor, boolean isInterface) {
1:fe77ca5: 
1:fe77ca5: 		int tag = isInterface ?	VMDescriptor.CONSTANT_InterfaceMethodref :
1:fe77ca5: 								VMDescriptor.CONSTANT_Methodref;
1:fe77ca5: 
1:fe77ca5: 		return addReference(tag, className, simpleName, descriptor); 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private int addReference(int tag, String className, String simpleName, String descriptor) {
1:fe77ca5: 
1:fe77ca5: 		int classIndex = addClassReference(className);
1:fe77ca5: 		int nameTypeIndex = addNameAndType(simpleName, descriptor);
1:fe77ca5: 
1:fe77ca5: 		return addIndexReference(tag, classIndex, nameTypeIndex);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private int addReference(int tag, ClassMember member) {
1:fe77ca5: 
1:fe77ca5: 		int nameTypeIndex = addIndexReference(VMDescriptor.CONSTANT_NameAndType,
1:fe77ca5: 							member.name_index, member.descriptor_index);
1:fe77ca5: 
1:fe77ca5: 		return addIndexReference(tag, this_class, nameTypeIndex);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassHolder#addConstant */
1:fe77ca5: 	public int addConstant(String value) {
1:fe77ca5: 
1:fe77ca5: 		return addString(value);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassHolder#addUtf8 */
1:fe77ca5: 	public int addUtf8(String value) {
1:fe77ca5: 
1:fe77ca5: 		return addUtf8Entry(value).getIndex();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:1cd0a14: 	/** @see ClassHolder#addConstant */
1:fe77ca5: 	public int addConstant(int value) {
1:fe77ca5: 		return addDirectEntry(new CONSTANT_Integer_info(value));
1:fe77ca5: 	}
1:fe77ca5: 
1:1cd0a14: 	/** @see ClassHolder#addConstant */
1:fe77ca5: 	public int addConstant(float value) {
1:fe77ca5: 		return addDirectEntry(new CONSTANT_Float_info(value));
1:fe77ca5: 	}
1:fe77ca5: 
1:1cd0a14: 	/** @see ClassHolder#addConstant */
1:fe77ca5: 	public int addConstant(long value) {
1:fe77ca5: 		return addDirectEntry(new CONSTANT_Long_info(value));
1:fe77ca5: 	}
1:fe77ca5: 
1:1cd0a14: 	/** @see ClassHolder#addConstant */
1:fe77ca5: 	public int addConstant(double value) {
1:fe77ca5: 		return addDirectEntry(new CONSTANT_Double_info(value));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/** @see ClassMember
1:fe77ca5: 	*/
1:fe77ca5: 	public int getConstantPoolIndex() { return this_class; }
1:fe77ca5: 
1:fe77ca5: 	public void addAttribute(String attributeName, ClassFormatOutput info) {
1:fe77ca5: 
1:fe77ca5: 		if (attribute_info == null)
1:fe77ca5: 			attribute_info = new Attributes(1);
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 		CONSTANT_Utf8_info autf = addUtf8Entry(attributeName);
1:fe77ca5: 
1:fe77ca5: 		int index = autf.getIndex();
1:fe77ca5: 
1:fe77ca5: 		attribute_info.addEntry(new AttributeEntry(index, info));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	public String getSuperClassName() {
1:fe77ca5: 		if (super_class == 0)
2:fe77ca5: 			return null;
1:fe77ca5: 		else
1:fe77ca5: 			return className(super_class).replace('/', '.');
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: /*
1:fe77ca5:     public ClassMember getMemberReference(String fullyQualifiedClassName, String simpleName, String descriptor) {
1:fe77ca5: 
1:fe77ca5: 		int classIndex;
1:fe77ca5: 
1:fe77ca5: 		if (fullyQualifiedClassName == null)
1:fe77ca5: 			 classIndex = this_class;
1:fe77ca5: 		else
1:fe77ca5: 			classIndex = constantPool.findClass(fullyQualifiedClassName);
1:fe77ca5: 
1:fe77ca5: 		if (classIndex < 0)
1:fe77ca5: 			return null;
1:fe77ca5: 
1:fe77ca5: 		int nameAndTypeIndex = constantPool.findNameAndType(simpleName, descriptor);
1:fe77ca5: 		if (nameAndTypeIndex < 0)
1:fe77ca5: 			return null;
1:fe77ca5: 
1:fe77ca5:         return constantPool.findReference(classIndex, nameAndTypeIndex);
1:fe77ca5: 	}
1:fe77ca5: */
1:fe77ca5: 	/*
1:fe77ca5: 	** Public methods from ClassRead
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Implementation specific methods.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Methods related to Constant Pool Table
1:fe77ca5: 	*/
1:fe77ca5: 	/**
1:fe77ca5: 		Generic add entry to constant pool. Includes the logic
1:fe77ca5: 		for an entry to occupy more than one slot (e.g. long).
1:fe77ca5: 
1:fe77ca5: 		@return The number of slots occupied by the entry.
1:fe77ca5: .
1:fe77ca5: 	*/
1:fe77ca5: 	protected int addEntry(Object key, ConstantPoolEntry item) {
1:fe77ca5: 
1:fe77ca5: 		item.setIndex(cptEntries.size());
1:fe77ca5: 		if (key != null)
1:fe77ca5: 			cptHashTable.put(key, item);
1:a32eb9f: 		cptEntries.add(item);
1:fe77ca5: 
1:fe77ca5: 		cptEstimatedSize += item.classFileSize();
1:fe77ca5: 
1:fe77ca5: 		if (item.doubleSlot()) {
1:a32eb9f: 			cptEntries.add(null);
1:fe77ca5: 			return 2;
1:fe77ca5: 		} else {
1:fe77ca5: 			return 1;
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 	
1:fe77ca5: 	/**
1:fe77ca5: 		Add an entry, but only if it doesn't exist.
1:fe77ca5: 
1:fe77ca5: 		@return the constant pool index of the added
1:fe77ca5: 		or existing item.
1:fe77ca5: 	*/
1:fe77ca5: 	private int addDirectEntry(ConstantPoolEntry item) {
1:fe77ca5: 		ConstantPoolEntry existingItem = findMatchingEntry(item);
1:fe77ca5: 		if (existingItem != null) {
1:fe77ca5: 			item = existingItem;
1:fe77ca5: 			//foundCount++;
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			addEntry(item.getKey(), item);
1:fe77ca5: 		}
1:fe77ca5: 		return item.getIndex();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Add an index reference.
1:fe77ca5: 	*/
1:fe77ca5: 	private int addIndexReference(int tag, int i1, int i2) {
1:fe77ca5: 
1:fe77ca5: 		// search for the item using the pre-allocated object 
1:fe77ca5: 		searchIndex.set(tag, i1, i2);
1:fe77ca5: 
1:fe77ca5: 		ConstantPoolEntry item = findMatchingEntry(searchIndex);
1:fe77ca5: 
1:fe77ca5: 		if (item == null) {
1:fe77ca5: 			item = new CONSTANT_Index_info(tag, i1, i2);
1:fe77ca5: 			addEntry(item.getKey(), item);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return item.getIndex();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Add a class entry to the pool.
1:fe77ca5: 	*/
1:fe77ca5: 	public int addClassReference(String fullyQualifiedName) {
1:fe77ca5: 		if (ClassHolder.isExternalClassName(fullyQualifiedName)) {
1:fe77ca5: 			fullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
1:fe77ca5: 			// System.out.println("addClassReference " + fullyQualifiedName);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		int name_index = addUtf8Entry(fullyQualifiedName).getIndex();
1:fe77ca5: 
1:fe77ca5: 		return addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Add a name and type entry
1:fe77ca5: 	*/
1:fe77ca5: 	private int addNameAndType(String name, String descriptor) {
1:fe77ca5: 		int nameIndex = addUtf8Entry(name).getIndex();
1:fe77ca5: 
1:fe77ca5: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
1:fe77ca5: 
1:fe77ca5: 		return addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Add a UTF8 into the pool and return the index to it.
1:fe77ca5: 	*/
1:fe77ca5: 	private CONSTANT_Utf8_info addUtf8Entry(String value) {
1:fe77ca5: 
1:fe77ca5: 		CONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);
1:fe77ca5: 
1:fe77ca5: 		if (item == null) {
1:fe77ca5: 
1:fe77ca5: 			item = new CONSTANT_Utf8_info(value);
1:fe77ca5: 			addEntry(value, item);
1:fe77ca5: 		}
1:fe77ca5: 		return item;
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 		Add an extra UTF8 into the pool 
1:fe77ca5: 	*/
1:fe77ca5: 	private CONSTANT_Utf8_info addExtraUtf8(String value) {
1:fe77ca5: 
1:fe77ca5: 		CONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);
1:fe77ca5: 		addEntry(null, item);
1:fe77ca5: 
1:fe77ca5: 		return item;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
2:fe77ca5: 		Add a string entry
1:fe77ca5: 	*/
1:fe77ca5: 	private int addString(String value) {
2:fe77ca5: 		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
1:fe77ca5: 		int valueIndex = sutf.setAsString();
1:fe77ca5: 		if (valueIndex == 0) {
1:fe77ca5: 			// string is already being used as code
1:fe77ca5: 			valueIndex = addExtraUtf8(value).getIndex();
1:fe77ca5: 			sutf.setAlternative(valueIndex);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:  	protected void cptPut(ClassFormatOutput out) throws IOException {
1:fe77ca5: 
1:996ca72: 		for (Enumeration<ConstantPoolEntry> e = cptEntries.elements(); e.hasMoreElements(); ) {
1:996ca72: 			ConstantPoolEntry item = e.nextElement();
1:fe77ca5: 			if (item == null) {
1:fe77ca5: 				continue;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			item.put(out);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Methods to convert indexes to constant pool entries and vice-versa.
1:fe77ca5: 	*/
1:fe77ca5: 
1:7e52071: 	public ConstantPoolEntry getEntry(int index) {
1:996ca72: 		return cptEntries.get(index);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Return the class name for an index to a CONSTANT_Class_info.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	protected String className(int classIndex) {
1:fe77ca5: 		CONSTANT_Index_info ci = (CONSTANT_Index_info) getEntry(classIndex);
1:fe77ca5: 
1:fe77ca5: 		return nameIndexToString(ci.getI1()).replace('/', '.');
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Methods to find specific types of constant pool entries.
1:fe77ca5: 	   In these methods we try to avoid using the ConstantPoolEntry.matchValue()
1:fe77ca5: 	   as that requires creating a new object for the search. The matchValue()
1:fe77ca5: 	   call is really intended for when objects are being added to the constant pool.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Return the index of a UTF entry or -1 if it doesn't exist.
1:fe77ca5: 	*/
1:fe77ca5: 	int findUtf8(String value) {
1:fe77ca5: 
1:fe77ca5: 		ConstantPoolEntry item = findMatchingEntry(value);
1:fe77ca5: 		if (item == null)
1:fe77ca5: 			return -1;
1:fe77ca5: 
1:fe77ca5: 		return item.getIndex();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Find a class descriptor (section 4.4.1) and return its
1:fe77ca5: 		index, returns -1 if not found.
1:fe77ca5: 	*/
1:fe77ca5: 	public int findClass(String fullyQualifiedName) {
1:fe77ca5: 		String internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
1:fe77ca5: 		int utf_index = findUtf8(internalName);
1:fe77ca5: 		if (utf_index < 0)
1:fe77ca5: 			return -1;
1:fe77ca5: 
1:fe77ca5: 		return findIndexIndex(VMDescriptor.CONSTANT_Class,
1:fe77ca5: 			utf_index, 0);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Find a name and type descriptor (section 4.4.6) and
1:1cd0a14: 		return it's index. 
1:1cd0a14:         <p>
1:1cd0a14:         returns -1 if not found.
1:fe77ca5: 	*/
1:fe77ca5: 	public int findNameAndType(String name, String descriptor) {
1:fe77ca5: 
1:fe77ca5: 		int name_index = findUtf8(name);
1:fe77ca5: 		if (name_index < 0)
1:fe77ca5: 			return -1;
1:fe77ca5: 		int descriptor_index = findUtf8(descriptor);
1:fe77ca5: 		if (descriptor_index < 0)
1:fe77ca5: 			return -1;
1:fe77ca5: 
1:fe77ca5: 		return findIndexIndex(VMDescriptor.CONSTANT_NameAndType,
1:fe77ca5: 			name_index, descriptor_index);
1:fe77ca5: 	}
1:fe77ca5: /*
1:fe77ca5: 	public ClassMember findReference(int classIndex, int nameAndTypeIndex) {
1:fe77ca5: 
1:fe77ca5: 		CONSTANT_Index_info item = findIndexEntry(VMDescriptor.CONSTANT_Methodref,
1:fe77ca5: 				classIndex, nameAndTypeIndex);
1:fe77ca5: 
1:fe77ca5: 		if (item == null) {
1:fe77ca5: 
1:fe77ca5: 			item = findIndexEntry(VMDescriptor.CONSTANT_InterfaceMethodref,
1:fe77ca5: 				classIndex, nameAndTypeIndex);
1:fe77ca5: 
1:fe77ca5: 			if (item == null) {
1:fe77ca5: 				item = findIndexEntry(VMDescriptor.CONSTANT_Fieldref,
1:fe77ca5: 					classIndex, nameAndTypeIndex);
1:fe77ca5: 
1:fe77ca5: 				if (item == null)
1:fe77ca5: 					return null;
1:fe77ca5: 
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return new ReferenceMember(this, item);
1:fe77ca5: 	}
1:fe77ca5: */
1:fe77ca5: 	protected CONSTANT_Index_info findIndexEntry(int tag, int i1, int i2) {
1:fe77ca5: 		// search for the item using the pre-allocated object 
1:fe77ca5: 		searchIndex.set(tag, i1, i2);
1:fe77ca5: 
1:fe77ca5: 		return (CONSTANT_Index_info) findMatchingEntry(searchIndex);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	protected int findIndexIndex(int tag, int i1, int i2) {
1:fe77ca5: 		CONSTANT_Index_info item = findIndexEntry(tag, i1, i2);
1:fe77ca5: 		if (item == null)
1:fe77ca5: 			return -1;
1:fe77ca5: 
1:fe77ca5: 		return item.getIndex();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	protected ConstantPoolEntry findMatchingEntry(Object key) {
1:996ca72: 		return cptHashTable.get(key);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** get a string (UTF) given a name_index into the constant pool
1:fe77ca5: 	   */
1:fe77ca5: 	String nameIndexToString(int index) {
1:fe77ca5: 
1:fe77ca5: 		return getEntry(index).toString();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** get the class name of a Class given the index of its CONSTANT_Class_info
1:fe77ca5: 	    entry in the Constant Pool.
1:fe77ca5: 		*/
1:fe77ca5: 
1:fe77ca5: 	protected String getClassName(int index) {
1:fe77ca5: 
1:fe77ca5: 		if (index == 0)
1:fe77ca5: 			return ""; // must be the super class of java.lang.Object, ie. nothing.
1:fe77ca5: 
1:fe77ca5: 		return 	nameIndexToString(getEntry(index).getI1());
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	 * Determine whether the class descriptor string is 
1:fe77ca5: 	 * in external format or not.  Assumes that to be in external
1:fe77ca5: 	 * format means it must have a '.' or end in an ']'.
1:fe77ca5: 	 * 
1:fe77ca5: 	 * @param className	the name of the class to check
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return true/false
1:fe77ca5: 	 */
1:fe77ca5: 	public static boolean isExternalClassName(String className)
1:fe77ca5: 	{
1:fe77ca5: 		int len;
1:fe77ca5: 		if (className.indexOf('.') != -1)
1:fe77ca5: 		{
1:fe77ca5: 			return true;
1:fe77ca5: 		}
1:fe77ca5: 		else if ((len = className.length()) == 0)
1:fe77ca5: 		{ 
1:fe77ca5: 			return false;
1:fe77ca5: 		}
1:fe77ca5: 		return (className.charAt(len - 1) == ']');
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	 * Convert a class name to the internal VM class name format.
1:fe77ca5: 	   See sections 4.3.2, 4.4.1 of the vm spec.
1:fe77ca5: 	 * The normal leading 'L' and trailing ';' are left
1:fe77ca5: 	 * off of objects.  This is intended primarily for
1:fe77ca5: 	 * the class manager.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * An example of a conversion would be java.lang.Double[]
1:fe77ca5: 	 * to "[Ljava/lang/Double;".
1:fe77ca5: 	 <BR>
1:fe77ca5: 	   java.lang.Double would be converted to "java/lang/Double"
1:fe77ca5: 
1:fe77ca5: 	<BR>
1:fe77ca5: 	Note that for array types the result of convertToInternalClassName()
1:fe77ca5: 	and convertToInternalDescriptor() are identical.
1:fe77ca5: 
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param the external name (cannot be null)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return the internal string
1:fe77ca5: 	 */
1:fe77ca5: 	public static String convertToInternalClassName(String externalName)
1:fe77ca5: 	{
1:fe77ca5: 		return convertToInternal(externalName, false);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	 * Convert a class name to internal JVM descriptor format.
1:fe77ca5: 	   See sections 4.3.2 of the vm spec.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * An example of a conversion would be "java.lang.Double[]"
1:fe77ca5: 	 * to "[Ljava/lang/Double;".
1:fe77ca5: 	 *
1:fe77ca5: 	 <BR>
1:fe77ca5: 	   java.lang.Double would be converted to "Ljava/lang/Double;"
1:fe77ca5: 
1:fe77ca5: 	<BR>
1:fe77ca5: 	Note that for array types the result of convertToInternalClassName()
1:fe77ca5: 	and convertToInternalDescriptor() are identical.
1:fe77ca5: 
1:fe77ca5: 	 * @param the external name (cannot be null)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return the internal string
1:fe77ca5: 	 */
1:fe77ca5: 	public static String convertToInternalDescriptor(String externalName)
1:fe77ca5: 	{
1:fe77ca5: 		return convertToInternal(externalName, true);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	** Workhorse method.  Convert to internal format.
1:fe77ca5: 
1:fe77ca5: 		@param descriptor True if converting to descriptor format, false if
1:fe77ca5: 		converting to class name format.
1:fe77ca5: 	**
1:fe77ca5: 	** Lifted from BCClass.java. 
1:fe77ca5: 	**
1:fe77ca5: 	** Returns the result string.
1:fe77ca5: 	*/
1:fe77ca5: 	private static String convertToInternal(String externalName, boolean descriptor)
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			SanityManager.ASSERT(externalName != null, "unexpected null");
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		int len = externalName.length();
1:fe77ca5: 
1:fe77ca5: 		String internalName;	
1:fe77ca5: 		String retVal = null;	
1:fe77ca5: 		int origLen = len;
1:fe77ca5: 		int arity = 0;
1:fe77ca5: 
1:fe77ca5: 		// first walk through all array-ness
1:fe77ca5: 		if (externalName.charAt(len-1) == ']')
1:fe77ca5: 		{
1:fe77ca5: 			while (len > 0
1:fe77ca5: 				&& externalName.charAt(len-1) == ']'
1:fe77ca5: 				&& externalName.charAt(len-2) == '[') 
1:fe77ca5: 			{
1:fe77ca5: 				len -= 2;
1:fe77ca5: 				arity++;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 		if (SanityManager.DEBUG) {
1:fe77ca5: 			SanityManager.ASSERT(len > 0);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		internalName = (origLen == len)? 
1:fe77ca5: 						  externalName 
1:fe77ca5: 						: externalName.substring(0,len);
1:fe77ca5: 
1:fe77ca5: 	    // then check for primitive types ... 
1:fe77ca5: 		// in length by expected frequency order
1:fe77ca5: 
1:fe77ca5: 		switch (len) {
1:fe77ca5: 			case 7 :
1:fe77ca5: 		        if ("boolean".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_BOOLEAN, arity);
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 			case 4 :
1:fe77ca5: 		        if ("void".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_VOID, arity);
1:fe77ca5: 				}
1:fe77ca5: 		        else if ("long".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_LONG, arity);
1:fe77ca5: 				}
1:fe77ca5: 		        else if ("byte".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_BYTE, arity);
1:fe77ca5: 				}
1:fe77ca5: 		        else if ("char".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_CHAR, arity);
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 			case 3 :
1:fe77ca5: 		        if ("int".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_INT, arity);
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 			case 6 :
1:fe77ca5: 		        if ("double".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_DOUBLE, arity);
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 			case 5 :
1:fe77ca5: 		        if ("short".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_SHORT, arity);
1:fe77ca5: 				}
1:fe77ca5: 		        else if ("float".equals(internalName)) {
1:fe77ca5: 					retVal = makeDesc(VMDescriptor.C_FLOAT, arity);
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// then it must be a Java class
1:fe77ca5: 		if (retVal == null)
1:fe77ca5: 			retVal = makeDesc(internalName, arity, descriptor);
1:fe77ca5: 
1:fe77ca5: 		return retVal;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		A helper to build a type description based on a built-in type
1:fe77ca5: 		and an array arity.
1:fe77ca5: 	 */
1:fe77ca5: 	static private String makeDesc (char builtin, int arity) {
1:fe77ca5: 		if (arity == 0)
1:fe77ca5: 			switch (builtin) {
1:fe77ca5: 				case VMDescriptor.C_BYTE : return VMDescriptor.BYTE;
1:fe77ca5: 				case VMDescriptor.C_CHAR : return VMDescriptor.CHAR;
1:fe77ca5: 				case VMDescriptor.C_DOUBLE : return VMDescriptor.DOUBLE;
1:fe77ca5: 				case VMDescriptor.C_FLOAT : return VMDescriptor.FLOAT;
1:fe77ca5: 				case VMDescriptor.C_INT : return VMDescriptor.INT;
1:fe77ca5: 				case VMDescriptor.C_LONG : return VMDescriptor.LONG;
1:fe77ca5: 				case VMDescriptor.C_SHORT : return VMDescriptor.SHORT;
1:fe77ca5: 				case VMDescriptor.C_BOOLEAN : return VMDescriptor.BOOLEAN;
1:fe77ca5: 				case VMDescriptor.C_VOID : return VMDescriptor.VOID;
1:fe77ca5: 				default: 
1:fe77ca5: 					if (SanityManager.DEBUG)
1:fe77ca5: 						SanityManager.THROWASSERT("No type match");
1:fe77ca5: 					return null;
1:fe77ca5: 			}
1:fe77ca5: 		else {
1:fe77ca5: 			StringBuffer desc = new StringBuffer(arity+3);
1:fe77ca5: 
1:fe77ca5: 			for (int i=0;i<arity;i++)
1:fe77ca5: 				desc.append(VMDescriptor.C_ARRAY);
1:fe77ca5: 
1:fe77ca5: 			desc.append(ClassHolder.makeDesc(builtin, 0));
1:fe77ca5: 
1:fe77ca5: 			return desc.toString();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		A helper to build a type description based on a Java class
1:fe77ca5: 		and an array arity.
1:fe77ca5: 
1:fe77ca5: 		If descriptor is true create a descriptor according to
1:fe77ca5: 		section 4.3.2 of the vm spec. If false create a class name
1:fe77ca5: 		according to sections 4.3.2 and 4.4.1 of the vm spec.
1:fe77ca5: 	
1:fe77ca5: 	 */
1:fe77ca5: 	static private String makeDesc (String className, int arity, boolean descriptor) {
1:fe77ca5: 
1:fe77ca5: 		if (!descriptor && (arity == 0)) {
1:fe77ca5: 			return className.replace('.','/');
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		StringBuffer desc = new StringBuffer(arity+2+className.length());
1:fe77ca5: 
1:fe77ca5: 		for (int i=0;i<arity;i++)
1:fe77ca5: 			desc.append(VMDescriptor.C_ARRAY);
1:fe77ca5: 
1:fe77ca5: 		desc.append(VMDescriptor.C_CLASS);
1:fe77ca5: 
1:fe77ca5: 		desc.append(className.replace('.','/'));
1:fe77ca5: 
1:fe77ca5: 		desc.append(VMDescriptor.C_ENDCLASS);
1:fe77ca5: 
1:fe77ca5: 		return desc.toString();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:996ca72
/////////////////////////////////////////////////////////////////////////
1: 	protected Hashtable<Object,ConstantPoolEntry> cptHashTable;
1: 	protected Vector<ConstantPoolEntry> cptEntries;
/////////////////////////////////////////////////////////////////////////
1: 		cptEntries = new Vector<ConstantPoolEntry>(estimatedConstantPoolCount);
1: 		cptHashTable = new Hashtable<Object,ConstantPoolEntry>(estimatedConstantPoolCount, (float)0.75);
/////////////////////////////////////////////////////////////////////////
1: 		for (Enumeration<ConstantPoolEntry> e = cptEntries.elements(); e.hasMoreElements(); ) {
1: 			ConstantPoolEntry item = e.nextElement();
/////////////////////////////////////////////////////////////////////////
1: 		return cptEntries.get(index);
/////////////////////////////////////////////////////////////////////////
1: 		return cptHashTable.get(key);
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1: 		cptEntries.add(item);
1: 			cptEntries.add(null);
/////////////////////////////////////////////////////////////////////////
0: 		return (ConstantPoolEntry) cptEntries.get(index);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:75f38ef
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Minor class format number defaults to 
1:      * VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION
1:      * which currently corresponds to a really old (JDK 1.0.2) setting.
1:      * The default major and minor value is used by the generated code for Derby's
1:      * SQL statements. Currently there is no need to bump the version
1:      * number as the generated code does not take advantage of any of the
1:      * new elements in the class file format. If such a need exists then
1:      * this can be bumped. One issue is that the change in format numbers
1:      * is not well documented.
1:      */
1:     protected int minor_version = VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION;
1:     /**
1:      * Minor class format number defaults to 
1:      * VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION
1:      */
1:     protected int major_version = VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION;
1:     
/////////////////////////////////////////////////////////////////////////
1: 		out.putU2(minor_version);
1: 		out.putU2(major_version);
commit:7e52071
/////////////////////////////////////////////////////////////////////////
1: 	public ConstantPoolEntry getEntry(int index) {
commit:a9b4b8d
/////////////////////////////////////////////////////////////////////////
1: 	private void put(ClassFormatOutput out) throws IOException {
1: 		// special case checking that the number of constant
1: 		// pool entries does not exceed the limit of 65535
1: 		// (as it is stored as a U2).
1: 		// Special case to allow somewhat easier debugging
1: 		// of the resulting failure.
1: 		out.putU2("constant_pool", cptEntries.size());
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Convert the object representation of the class into
1: 	 * its class file format.
1: 	 * @exception IOException error writing the class
1: 	 */
1: 	public ByteArray getFileFormat() throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 	
1: 		ClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);
1: 		put(cfo);
1: 		return new ByteArray(cfo.getData(), 0, cfo.size());
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.classfile.ClassHolder
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.classfile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.classfile;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: 
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.util.Enumeration;
1: 
1: import java.io.IOException;
1: import java.util.Vector;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
1: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1: 
1: import java.util.Hashtable;
1: import java.util.Vector;
1: import java.util.Enumeration;
1: 
1: 
1: /** Based upon "THE class FILE FORMAT" chapter of "The Java Virtual Machine Specification"
1:     corresponding to version 1.0.2 of the Java Virtual Machine and 1.0.2 of the
1: 	Java Language Specification.
1: 
1:     ISBN  0-201-63452-X, September 1996.
1: 	*/
1: 
1: public class ClassHolder {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1: 
1: 	/*
1: 	** Constants.
1: 	*/
1: 
1: 	/*
1: 	** Fields
1: 	*/
1: 
1: 	protected int access_flags;
1: 	protected int this_class;
1: 	protected int super_class;
1: 
1: 	// protected InterfacesArray interfaces; // can be null
1: 	protected int[] interfaces; //can be null
1: 
1: 	protected MemberTable field_info; // can be null
1: 	protected MemberTable method_info;	// can be null
1: 	protected Attributes attribute_info; // can be null
1: 
1: 	/*
1: 	** Fields for Constant Pool Table
1: 	*/
0: 	protected Hashtable cptHashTable;
0: 	protected Vector cptEntries;
1: 	private int cptEstimatedSize;
1: 
1: 	/**
1: 		Used to search for index entries to avoid object allocation
1: 		in the case a referecne already exists.
1: 	*/
1: 	private final CONSTANT_Index_info	searchIndex = new CONSTANT_Index_info(0, 0, 0);
1: 
1: 	/*
1: 	**	Constructors.
1: 	*/
1: 
1: 	protected ClassHolder(int estimatedConstantPoolCount) {
1: 		// Constant Pool Information
1: 		// 100 is the estimate of the number of entries that will be generated
0: 		cptEntries = new Vector(estimatedConstantPoolCount);
0: 		cptHashTable = new Hashtable(estimatedConstantPoolCount, (float)0.75);
1: 
1: 		// reserve the 0'th constant pool entry
1: 		cptEntries.setSize(1);
1: 	}
1: 
1: 
1: 	/**
1: 		This will not define a constructor -- it is up
1: 		to the caller to add at least one.
1: 	*/
1: 
1: 	public ClassHolder(String fullyQualifiedName, String superClassName,
1: 		int modifiers) {
1: 
1: 		this(100);
1: 
1: 		access_flags = modifiers | /* Modifier.SUPER */ 0x0020;
1: 
1: 		this_class = addClassReference(fullyQualifiedName);
1: 		super_class = addClassReference(superClassName);
1: 		method_info = new MemberTable(0);
1: 	}
1: 
0: 	public void put(ClassFormatOutput out) throws IOException {
1: 
1: 		/* Write out the header */
1: 		out.putU4(VMDescriptor.JAVA_CLASS_FORMAT_MAGIC);
0: 		out.putU2(VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION);
0: 		out.putU2(VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION);
1: 
0: 		out.putU2(cptEntries.size());
1: 		cptPut(out);
1: 
1: 		out.putU2(access_flags);
1: 		out.putU2(this_class);
1: 		out.putU2(super_class);
1: 
1: 		if (interfaces != null) {
1: 			int ilen = interfaces.length;
1: 			out.putU2(ilen);
1: 			for (int i = 0; i < ilen; i++) {
1: 				out.putU2(interfaces[i]);
1: 			}
1: 		} else {
1: 			out.putU2(0);
1: 		}
1: 
1: 		if (field_info != null) {
1: 			out.putU2(field_info.size());
1: 			field_info.put(out);
1: 		} else {
1: 			out.putU2(0);
1: 		}
1: 
1: 		if (method_info != null) {
1: 			out.putU2(method_info.size());
1: 			method_info.put(out);
1: 		} else {
1: 			out.putU2(0);
1: 		}
1: 
1: 		if (attribute_info != null) {
1: 			out.putU2(attribute_info.size());
1: 			attribute_info.put(out);
1: 		} else {
1: 			out.putU2(0);
1: 		}
1: 
1: 	}
1: 
1: 
1: 	/*
1: 	**	Public methods from ClassHolder.
1: 	*/
1: 
1: 
0: 	public ByteArray getFileFormat() {
1: 
1: 		int classFileSize = 4 + (10 * 2);
1: 		classFileSize += cptEstimatedSize;
1: 
1: 		if (interfaces != null)
1: 			classFileSize += (interfaces.length * 2);
1: 
1: 		if (field_info != null)
1: 			classFileSize += field_info.classFileSize();
1: 
1: 		if (method_info != null)
1: 			classFileSize += method_info.classFileSize();
1: 
1: 		if (attribute_info != null)
1: 			classFileSize += attribute_info.classFileSize();
1: 
0: 		try {
0: 			ClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);
1: 
0: 			put(cfo);
1: 
0: 			return new ByteArray(cfo.getData(), 0, cfo.size());
1: 
0: 		} catch (IOException e) {
1: 			return null;
1: 		}
1: 
1: 	}
1: 
1: 	/*
1: 	** Public methods from ClassMember
1: 	*/
1: 
1: 	/** @see ClassMember
1: 	*/
1: 	public int getModifier() { return access_flags; }
1: 
1: 	/** @see ClassMember
1: 	*/
1: 	public String getName() {
1: 		return className(this_class).replace('/', '.');
1: 	}
1: 	/*
1: 	**	Public methods from ClassHolder
1: 	*/
1: 
1: 	/** @see ClassHolder#addMember */
1:  	public ClassMember addMember(String simpleName, String descriptor, int modifier)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (descriptor.startsWith("(")) {
1: 				if (method_info != null) {
1: 					if (method_info.find(simpleName, descriptor) != null) {
1: 						SanityManager.THROWASSERT("Method already exists " + simpleName + " " + descriptor);
1: 					}
1: 				}
1: 
1: 			} else {
1: 				if (field_info != null) {
1: 					if (field_info.find(simpleName, descriptor) != null) {
1: 						SanityManager.THROWASSERT("Field already exists " + simpleName + " " + descriptor);
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		CONSTANT_Utf8_info utf = addUtf8Entry(simpleName);
1: 
1: 		int nameIndex = utf.getIndex();
1: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
1: 
1: 		ClassMember item = new ClassMember(this, modifier, nameIndex, descriptorIndex);
1: 		MemberTable mt;
1: 		if (descriptor.startsWith("(")) {
1: 			mt = method_info;
1: 			if (mt == null)
1: 				mt = method_info = new MemberTable(0);
1: 
1: 		}
1: 		else {
1: 			mt = field_info;
1: 			if (mt == null)
1: 				mt = field_info = new MemberTable(0);
1: 		}
1: 
1: 		mt.addEntry(item);
1: 		return item;
1: 	}
1: 
1: 	/** @see ClassHolder#addFieldReference */
1: 	public int addFieldReference(String className, String simpleName, String descriptor) {
1: 		return addReference(VMDescriptor.CONSTANT_Fieldref, className, simpleName, descriptor);
1: 	}
1: 
1: 	public int addFieldReference(ClassMember field) {
1: 		return addReference(VMDescriptor.CONSTANT_Fieldref, (ClassMember) field);
1: 	}
1: 
1: 	/** @see ClassHolder#addMethodReference */
1: 	public int addMethodReference(String className, String simpleName, String descriptor, boolean isInterface) {
1: 
1: 		int tag = isInterface ?	VMDescriptor.CONSTANT_InterfaceMethodref :
1: 								VMDescriptor.CONSTANT_Methodref;
1: 
1: 		return addReference(tag, className, simpleName, descriptor); 
1: 	}
1: 
1: 	private int addReference(int tag, String className, String simpleName, String descriptor) {
1: 
1: 		int classIndex = addClassReference(className);
1: 		int nameTypeIndex = addNameAndType(simpleName, descriptor);
1: 
1: 		return addIndexReference(tag, classIndex, nameTypeIndex);
1: 	}
1: 
1: 	private int addReference(int tag, ClassMember member) {
1: 
1: 		int nameTypeIndex = addIndexReference(VMDescriptor.CONSTANT_NameAndType,
1: 							member.name_index, member.descriptor_index);
1: 
1: 		return addIndexReference(tag, this_class, nameTypeIndex);
1: 	}
1: 
1: 	/** @see ClassHolder#addConstant */
1: 	public int addConstant(String value) {
1: 
1: 		return addString(value);
1: 	}
1: 
1: 	/** @see ClassHolder#addUtf8 */
1: 	public int addUtf8(String value) {
1: 
1: 		return addUtf8Entry(value).getIndex();
1: 	}
1: 
1: 
0: 	/** @see ClassHolder#addInteger */
1: 	public int addConstant(int value) {
1: 		return addDirectEntry(new CONSTANT_Integer_info(value));
1: 	}
1: 
0: 	/** @see ClassHolder#addFloat */
1: 	public int addConstant(float value) {
1: 		return addDirectEntry(new CONSTANT_Float_info(value));
1: 	}
1: 
0: 	/** @see ClassHolder#addLong */
1: 	public int addConstant(long value) {
1: 		return addDirectEntry(new CONSTANT_Long_info(value));
1: 	}
1: 
0: 	/** @see ClassHolder#addDouble */
1: 	public int addConstant(double value) {
1: 		return addDirectEntry(new CONSTANT_Double_info(value));
1: 	}
1: 
1: 
1: 	/** @see ClassMember
1: 	*/
1: 	public int getConstantPoolIndex() { return this_class; }
1: 
1: 	public void addAttribute(String attributeName, ClassFormatOutput info) {
1: 
1: 		if (attribute_info == null)
1: 			attribute_info = new Attributes(1);
1: 
1: 
1: 		CONSTANT_Utf8_info autf = addUtf8Entry(attributeName);
1: 
1: 		int index = autf.getIndex();
1: 
1: 		attribute_info.addEntry(new AttributeEntry(index, info));
1: 	}
1: 
1: 
1: 	public String getSuperClassName() {
1: 		if (super_class == 0)
1: 			return null;
1: 		else
1: 			return className(super_class).replace('/', '.');
1: 	}
1: 
1: 
1: /*
1:     public ClassMember getMemberReference(String fullyQualifiedClassName, String simpleName, String descriptor) {
1: 
1: 		int classIndex;
1: 
1: 		if (fullyQualifiedClassName == null)
1: 			 classIndex = this_class;
1: 		else
1: 			classIndex = constantPool.findClass(fullyQualifiedClassName);
1: 
1: 		if (classIndex < 0)
1: 			return null;
1: 
1: 		int nameAndTypeIndex = constantPool.findNameAndType(simpleName, descriptor);
1: 		if (nameAndTypeIndex < 0)
1: 			return null;
1: 
1:         return constantPool.findReference(classIndex, nameAndTypeIndex);
1: 	}
1: */
1: 	/*
1: 	** Public methods from ClassRead
1: 	*/
1: 
1: 
1: 
1: 	/*
1: 	** Implementation specific methods.
1: 	*/
1: 
1: 	/*
1: 	** Methods related to Constant Pool Table
1: 	*/
1: 	/**
1: 		Generic add entry to constant pool. Includes the logic
1: 		for an entry to occupy more than one slot (e.g. long).
1: 
1: 		@return The number of slots occupied by the entry.
1: .
1: 	*/
1: 	protected int addEntry(Object key, ConstantPoolEntry item) {
1: 
1: 		item.setIndex(cptEntries.size());
1: 		if (key != null)
1: 			cptHashTable.put(key, item);
0: 		cptEntries.addElement(item);
1: 
1: 		cptEstimatedSize += item.classFileSize();
1: 
1: 		if (item.doubleSlot()) {
0: 			cptEntries.addElement(null);
1: 			return 2;
1: 		} else {
1: 			return 1;
1: 		}
1: 	}
1: 	
1: 	/**
1: 		Add an entry, but only if it doesn't exist.
1: 
1: 		@return the constant pool index of the added
1: 		or existing item.
1: 	*/
1: 	private int addDirectEntry(ConstantPoolEntry item) {
1: 		ConstantPoolEntry existingItem = findMatchingEntry(item);
1: 		if (existingItem != null) {
1: 			item = existingItem;
1: 			//foundCount++;
1: 		}
1: 		else {
1: 			addEntry(item.getKey(), item);
1: 		}
1: 		return item.getIndex();
1: 	}
1: 
1: 	/**
1: 		Add an index reference.
1: 	*/
1: 	private int addIndexReference(int tag, int i1, int i2) {
1: 
1: 		// search for the item using the pre-allocated object 
1: 		searchIndex.set(tag, i1, i2);
1: 
1: 		ConstantPoolEntry item = findMatchingEntry(searchIndex);
1: 
1: 		if (item == null) {
1: 			item = new CONSTANT_Index_info(tag, i1, i2);
1: 			addEntry(item.getKey(), item);
1: 		}
1: 
1: 		return item.getIndex();
1: 	}
1: 
1: 	/**
1: 		Add a class entry to the pool.
1: 	*/
1: 	public int addClassReference(String fullyQualifiedName) {
1: 		if (ClassHolder.isExternalClassName(fullyQualifiedName)) {
1: 			fullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
1: 			// System.out.println("addClassReference " + fullyQualifiedName);
1: 		}
1: 
1: 		int name_index = addUtf8Entry(fullyQualifiedName).getIndex();
1: 
1: 		return addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);
1: 	}
1: 
1: 	/**
1: 		Add a name and type entry
1: 	*/
1: 	private int addNameAndType(String name, String descriptor) {
1: 		int nameIndex = addUtf8Entry(name).getIndex();
1: 
1: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
1: 
1: 		return addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);
1: 	}
1: 
1: 	/**
1: 		Add a UTF8 into the pool and return the index to it.
1: 	*/
1: 	private CONSTANT_Utf8_info addUtf8Entry(String value) {
1: 
1: 		CONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);
1: 
1: 		if (item == null) {
1: 
1: 			item = new CONSTANT_Utf8_info(value);
1: 			addEntry(value, item);
1: 		}
1: 		return item;
1: 	}
1: 	/**
1: 		Add an extra UTF8 into the pool 
1: 	*/
1: 	private CONSTANT_Utf8_info addExtraUtf8(String value) {
1: 
1: 		CONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);
1: 		addEntry(null, item);
1: 
1: 		return item;
1: 	}
1: 
1: 	/**
1: 		Add a string entry
1: 	*/
1: 	private int addString(String value) {
1: 		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
1: 		int valueIndex = sutf.setAsString();
1: 		if (valueIndex == 0) {
1: 			// string is already being used as code
1: 			valueIndex = addExtraUtf8(value).getIndex();
1: 			sutf.setAlternative(valueIndex);
1: 		}
1: 
1: 		return addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);
1: 	}
1: 
1: 	/**
1: 		Add a string entry
1: 	*/
0: 	private int addCodeUtf8(String value) {
1: 		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
0: 		int index = sutf.setAsCode();
0: 		if (index == 0) {
0: 			// code string is already being used as string
0: 			CONSTANT_Utf8_info eutf = addExtraUtf8(value);
0: 			eutf.setAsCode(); // ensure the replace will happen
0: 			index = eutf.getIndex();
0: 			sutf.setAlternative(index);
1: 		}
1: 
0: 		return index;
1: 	}
1:  	protected void cptPut(ClassFormatOutput out) throws IOException {
1: 
0: 		for (Enumeration e = cptEntries.elements(); e.hasMoreElements(); ) {
0: 			ConstantPoolEntry item = (ConstantPoolEntry) e.nextElement();
1: 			if (item == null) {
1: 				continue;
1: 			}
1: 
1: 			item.put(out);
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Methods to convert indexes to constant pool entries and vice-versa.
1: 	*/
1: 
0: 	ConstantPoolEntry getEntry(int index) {
0: 		return (ConstantPoolEntry) cptEntries.elementAt(index);
1: 	}
1: 
1: 	/**
1: 		Return the class name for an index to a CONSTANT_Class_info.
1: 	*/
1: 
1: 	protected String className(int classIndex) {
1: 		CONSTANT_Index_info ci = (CONSTANT_Index_info) getEntry(classIndex);
1: 
1: 		return nameIndexToString(ci.getI1()).replace('/', '.');
1: 
1: 	}
1: 
1: 	/*
1: 	** Methods to find specific types of constant pool entries.
1: 	   In these methods we try to avoid using the ConstantPoolEntry.matchValue()
1: 	   as that requires creating a new object for the search. The matchValue()
1: 	   call is really intended for when objects are being added to the constant pool.
1: 	*/
1: 
1: 	/**
1: 		Return the index of a UTF entry or -1 if it doesn't exist.
1: 	*/
1: 	int findUtf8(String value) {
1: 
1: 		ConstantPoolEntry item = findMatchingEntry(value);
1: 		if (item == null)
1: 			return -1;
1: 
1: 		return item.getIndex();
1: 	}
1: 
1: 	/**
1: 		Find a class descriptor (section 4.4.1) and return its
1: 		index, returns -1 if not found.
1: 	*/
1: 	public int findClass(String fullyQualifiedName) {
1: 		String internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
1: 		int utf_index = findUtf8(internalName);
1: 		if (utf_index < 0)
1: 			return -1;
1: 
1: 		return findIndexIndex(VMDescriptor.CONSTANT_Class,
1: 			utf_index, 0);
1: 	}
1: 
1: 
1: 	/**
1: 		Find a name and type descriptor (section 4.4.6) and
0: 		return ita index. returns -1 if not found.
1: 	*/
1: 	public int findNameAndType(String name, String descriptor) {
1: 
1: 		int name_index = findUtf8(name);
1: 		if (name_index < 0)
1: 			return -1;
1: 		int descriptor_index = findUtf8(descriptor);
1: 		if (descriptor_index < 0)
1: 			return -1;
1: 
1: 		return findIndexIndex(VMDescriptor.CONSTANT_NameAndType,
1: 			name_index, descriptor_index);
1: 	}
1: /*
1: 	public ClassMember findReference(int classIndex, int nameAndTypeIndex) {
1: 
1: 		CONSTANT_Index_info item = findIndexEntry(VMDescriptor.CONSTANT_Methodref,
1: 				classIndex, nameAndTypeIndex);
1: 
1: 		if (item == null) {
1: 
1: 			item = findIndexEntry(VMDescriptor.CONSTANT_InterfaceMethodref,
1: 				classIndex, nameAndTypeIndex);
1: 
1: 			if (item == null) {
1: 				item = findIndexEntry(VMDescriptor.CONSTANT_Fieldref,
1: 					classIndex, nameAndTypeIndex);
1: 
1: 				if (item == null)
1: 					return null;
1: 
1: 			}
1: 		}
1: 
1: 		return new ReferenceMember(this, item);
1: 	}
1: */
1: 	protected CONSTANT_Index_info findIndexEntry(int tag, int i1, int i2) {
1: 		// search for the item using the pre-allocated object 
1: 		searchIndex.set(tag, i1, i2);
1: 
1: 		return (CONSTANT_Index_info) findMatchingEntry(searchIndex);
1: 	}
1: 
1: 	protected int findIndexIndex(int tag, int i1, int i2) {
1: 		CONSTANT_Index_info item = findIndexEntry(tag, i1, i2);
1: 		if (item == null)
1: 			return -1;
1: 
1: 		return item.getIndex();
1: 	}
1: 
1: 	protected ConstantPoolEntry findMatchingEntry(Object key) {
0: 		return (ConstantPoolEntry) cptHashTable.get(key);
1: 	}
1: 
1: 	/** get a string (UTF) given a name_index into the constant pool
1: 	   */
1: 	String nameIndexToString(int index) {
1: 
1: 		return getEntry(index).toString();
1: 	}
1: 
1: 	/** get the class name of a Class given the index of its CONSTANT_Class_info
1: 	    entry in the Constant Pool.
1: 		*/
1: 
1: 	protected String getClassName(int index) {
1: 
1: 		if (index == 0)
1: 			return ""; // must be the super class of java.lang.Object, ie. nothing.
1: 
1: 		return 	nameIndexToString(getEntry(index).getI1());
1: 	}
1: 
1: 	/*
1: 	 * Determine whether the class descriptor string is 
1: 	 * in external format or not.  Assumes that to be in external
1: 	 * format means it must have a '.' or end in an ']'.
1: 	 * 
1: 	 * @param className	the name of the class to check
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	public static boolean isExternalClassName(String className)
1: 	{
1: 		int len;
1: 		if (className.indexOf('.') != -1)
1: 		{
1: 			return true;
1: 		}
1: 		else if ((len = className.length()) == 0)
1: 		{ 
1: 			return false;
1: 		}
1: 		return (className.charAt(len - 1) == ']');
1: 	}
1: 
1: 	/*
1: 	 * Convert a class name to the internal VM class name format.
1: 	   See sections 4.3.2, 4.4.1 of the vm spec.
1: 	 * The normal leading 'L' and trailing ';' are left
1: 	 * off of objects.  This is intended primarily for
1: 	 * the class manager.
1: 	 * <p>
1: 	 * An example of a conversion would be java.lang.Double[]
1: 	 * to "[Ljava/lang/Double;".
1: 	 <BR>
1: 	   java.lang.Double would be converted to "java/lang/Double"
1: 
1: 	<BR>
1: 	Note that for array types the result of convertToInternalClassName()
1: 	and convertToInternalDescriptor() are identical.
1: 
1: 	 *
1: 	 * @param the external name (cannot be null)
1: 	 *
1: 	 * @return the internal string
1: 	 */
1: 	public static String convertToInternalClassName(String externalName)
1: 	{
1: 		return convertToInternal(externalName, false);
1: 	}
1: 
1: 	/*
1: 	 * Convert a class name to internal JVM descriptor format.
1: 	   See sections 4.3.2 of the vm spec.
1: 	 * <p>
1: 	 * An example of a conversion would be "java.lang.Double[]"
1: 	 * to "[Ljava/lang/Double;".
1: 	 *
1: 	 <BR>
1: 	   java.lang.Double would be converted to "Ljava/lang/Double;"
1: 
1: 	<BR>
1: 	Note that for array types the result of convertToInternalClassName()
1: 	and convertToInternalDescriptor() are identical.
1: 
1: 	 * @param the external name (cannot be null)
1: 	 *
1: 	 * @return the internal string
1: 	 */
1: 	public static String convertToInternalDescriptor(String externalName)
1: 	{
1: 		return convertToInternal(externalName, true);
1: 	}
1: 
1: 	/*
1: 	** Workhorse method.  Convert to internal format.
1: 
1: 		@param descriptor True if converting to descriptor format, false if
1: 		converting to class name format.
1: 	**
1: 	** Lifted from BCClass.java. 
1: 	**
1: 	** Returns the result string.
1: 	*/
1: 	private static String convertToInternal(String externalName, boolean descriptor)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(externalName != null, "unexpected null");
1: 		}
1: 
1: 		int len = externalName.length();
1: 
1: 		String internalName;	
1: 		String retVal = null;	
1: 		int origLen = len;
1: 		int arity = 0;
1: 
1: 		// first walk through all array-ness
1: 		if (externalName.charAt(len-1) == ']')
1: 		{
1: 			while (len > 0
1: 				&& externalName.charAt(len-1) == ']'
1: 				&& externalName.charAt(len-2) == '[') 
1: 			{
1: 				len -= 2;
1: 				arity++;
1: 			}
1: 		}
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(len > 0);
1: 		}
1: 
1: 		internalName = (origLen == len)? 
1: 						  externalName 
1: 						: externalName.substring(0,len);
1: 
1: 	    // then check for primitive types ... 
1: 		// in length by expected frequency order
1: 
1: 		switch (len) {
1: 			case 7 :
1: 		        if ("boolean".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_BOOLEAN, arity);
1: 				}
1: 				break;
1: 			case 4 :
1: 		        if ("void".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_VOID, arity);
1: 				}
1: 		        else if ("long".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_LONG, arity);
1: 				}
1: 		        else if ("byte".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_BYTE, arity);
1: 				}
1: 		        else if ("char".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_CHAR, arity);
1: 				}
1: 				break;
1: 			case 3 :
1: 		        if ("int".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_INT, arity);
1: 				}
1: 				break;
1: 			case 6 :
1: 		        if ("double".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_DOUBLE, arity);
1: 				}
1: 				break;
1: 			case 5 :
1: 		        if ("short".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_SHORT, arity);
1: 				}
1: 		        else if ("float".equals(internalName)) {
1: 					retVal = makeDesc(VMDescriptor.C_FLOAT, arity);
1: 				}
1: 				break;
1: 		}
1: 
1: 		// then it must be a Java class
1: 		if (retVal == null)
1: 			retVal = makeDesc(internalName, arity, descriptor);
1: 
1: 		return retVal;
1: 	}
1: 
1: 	/**
1: 		A helper to build a type description based on a built-in type
1: 		and an array arity.
1: 	 */
1: 	static private String makeDesc (char builtin, int arity) {
1: 		if (arity == 0)
1: 			switch (builtin) {
1: 				case VMDescriptor.C_BYTE : return VMDescriptor.BYTE;
1: 				case VMDescriptor.C_CHAR : return VMDescriptor.CHAR;
1: 				case VMDescriptor.C_DOUBLE : return VMDescriptor.DOUBLE;
1: 				case VMDescriptor.C_FLOAT : return VMDescriptor.FLOAT;
1: 				case VMDescriptor.C_INT : return VMDescriptor.INT;
1: 				case VMDescriptor.C_LONG : return VMDescriptor.LONG;
1: 				case VMDescriptor.C_SHORT : return VMDescriptor.SHORT;
1: 				case VMDescriptor.C_BOOLEAN : return VMDescriptor.BOOLEAN;
1: 				case VMDescriptor.C_VOID : return VMDescriptor.VOID;
1: 				default: 
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.THROWASSERT("No type match");
1: 					return null;
1: 			}
1: 		else {
1: 			StringBuffer desc = new StringBuffer(arity+3);
1: 
1: 			for (int i=0;i<arity;i++)
1: 				desc.append(VMDescriptor.C_ARRAY);
1: 
1: 			desc.append(ClassHolder.makeDesc(builtin, 0));
1: 
1: 			return desc.toString();
1: 		}
1: 	}
1: 
1: 	/**
1: 		A helper to build a type description based on a Java class
1: 		and an array arity.
1: 
1: 		If descriptor is true create a descriptor according to
1: 		section 4.3.2 of the vm spec. If false create a class name
1: 		according to sections 4.3.2 and 4.4.1 of the vm spec.
1: 	
1: 	 */
1: 	static private String makeDesc (String className, int arity, boolean descriptor) {
1: 
1: 		if (!descriptor && (arity == 0)) {
1: 			return className.replace('.','/');
1: 		}
1: 
1: 		StringBuffer desc = new StringBuffer(arity+2+className.length());
1: 
1: 		for (int i=0;i<arity;i++)
1: 			desc.append(VMDescriptor.C_ARRAY);
1: 
1: 		desc.append(VMDescriptor.C_CLASS);
1: 
1: 		desc.append(className.replace('.','/'));
1: 
1: 		desc.append(VMDescriptor.C_ENDCLASS);
1: 
1: 		return desc.toString();
1: 	}
1: 
1: 
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:1cd0a14
/////////////////////////////////////////////////////////////////////////
1: 	/** @see ClassHolder#addConstant */
1: 	/** @see ClassHolder#addConstant */
1: 	/** @see ClassHolder#addConstant */
1: 	/** @see ClassHolder#addConstant */
/////////////////////////////////////////////////////////////////////////
1: 		return it's index. 
1:         <p>
1:         returns -1 if not found.
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.classfile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.classfile;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.util.Enumeration;
0: 
0: import java.io.IOException;
0: import java.util.Vector;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.classfile.VMDescriptor;
0: import org.apache.derby.iapi.services.classfile.VMDescriptor;
0: 
0: import java.util.Hashtable;
0: import java.util.Vector;
0: import java.util.Enumeration;
0: 
0: 
0: /** Based upon "THE class FILE FORMAT" chapter of "The Java Virtual Machine Specification"
0:     corresponding to version 1.0.2 of the Java Virtual Machine and 1.0.2 of the
0: 	Java Language Specification.
0: 
0:     ISBN  0-201-63452-X, September 1996.
0: 	*/
0: 
0: public class ClassHolder {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0: 
0: 	/*
0: 	** Constants.
0: 	*/
0: 
0: 	/*
0: 	** Fields
0: 	*/
0: 
0: 	protected int access_flags;
0: 	protected int this_class;
0: 	protected int super_class;
0: 
0: 	// protected InterfacesArray interfaces; // can be null
0: 	protected int[] interfaces; //can be null
0: 
0: 	protected MemberTable field_info; // can be null
0: 	protected MemberTable method_info;	// can be null
0: 	protected Attributes attribute_info; // can be null
0: 
0: 	/*
0: 	** Fields for Constant Pool Table
0: 	*/
0: 	protected Hashtable cptHashTable;
0: 	protected Vector cptEntries;
0: 	private int cptEstimatedSize;
0: 
0: 	/**
0: 		Used to search for index entries to avoid object allocation
0: 		in the case a referecne already exists.
0: 	*/
0: 	private final CONSTANT_Index_info	searchIndex = new CONSTANT_Index_info(0, 0, 0);
0: 
0: 	/*
0: 	**	Constructors.
0: 	*/
0: 
0: 	protected ClassHolder(int estimatedConstantPoolCount) {
0: 		// Constant Pool Information
0: 		// 100 is the estimate of the number of entries that will be generated
0: 		cptEntries = new Vector(estimatedConstantPoolCount);
0: 		cptHashTable = new Hashtable(estimatedConstantPoolCount, (float)0.75);
0: 
0: 		// reserve the 0'th constant pool entry
0: 		cptEntries.setSize(1);
0: 	}
0: 
0: 
0: 	/**
0: 		This will not define a constructor -- it is up
0: 		to the caller to add at least one.
0: 	*/
0: 
0: 	public ClassHolder(String fullyQualifiedName, String superClassName,
0: 		int modifiers) {
0: 
0: 		this(100);
0: 
0: 		access_flags = modifiers | /* Modifier.SUPER */ 0x0020;
0: 
0: 		this_class = addClassReference(fullyQualifiedName);
0: 		super_class = addClassReference(superClassName);
0: 		method_info = new MemberTable(0);
0: 	}
0: 
0: 	public void put(ClassFormatOutput out) throws IOException {
0: 
0: 		/* Write out the header */
0: 		out.putU4(VMDescriptor.JAVA_CLASS_FORMAT_MAGIC);
0: 		out.putU2(VMDescriptor.JAVA_CLASS_FORMAT_MINOR_VERSION);
0: 		out.putU2(VMDescriptor.JAVA_CLASS_FORMAT_MAJOR_VERSION);
0: 
0: 		out.putU2(cptEntries.size());
0: 		cptPut(out);
0: 
0: 		out.putU2(access_flags);
0: 		out.putU2(this_class);
0: 		out.putU2(super_class);
0: 
0: 		if (interfaces != null) {
0: 			int ilen = interfaces.length;
0: 			out.putU2(ilen);
0: 			for (int i = 0; i < ilen; i++) {
0: 				out.putU2(interfaces[i]);
0: 			}
0: 		} else {
0: 			out.putU2(0);
0: 		}
0: 
0: 		if (field_info != null) {
0: 			out.putU2(field_info.size());
0: 			field_info.put(out);
0: 		} else {
0: 			out.putU2(0);
0: 		}
0: 
0: 		if (method_info != null) {
0: 			out.putU2(method_info.size());
0: 			method_info.put(out);
0: 		} else {
0: 			out.putU2(0);
0: 		}
0: 
0: 		if (attribute_info != null) {
0: 			out.putU2(attribute_info.size());
0: 			attribute_info.put(out);
0: 		} else {
0: 			out.putU2(0);
0: 		}
0: 
0: 	}
0: 
0: 
0: 	/*
0: 	**	Public methods from ClassHolder.
0: 	*/
0: 
0: 
0: 	public ByteArray getFileFormat() {
0: 
0: 		int classFileSize = 4 + (10 * 2);
0: 		classFileSize += cptEstimatedSize;
0: 
0: 		if (interfaces != null)
0: 			classFileSize += (interfaces.length * 2);
0: 
0: 		if (field_info != null)
0: 			classFileSize += field_info.classFileSize();
0: 
0: 		if (method_info != null)
0: 			classFileSize += method_info.classFileSize();
0: 
0: 		if (attribute_info != null)
0: 			classFileSize += attribute_info.classFileSize();
0: 
0: 		try {
0: 			ClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);
0: 
0: 			put(cfo);
0: 
0: 			return new ByteArray(cfo.getData(), 0, cfo.size());
0: 
0: 		} catch (IOException e) {
0: 			return null;
0: 		}
0: 
0: 	}
0: 
0: 	/*
0: 	** Public methods from ClassMember
0: 	*/
0: 
0: 	/** @see ClassMember
0: 	*/
0: 	public int getModifier() { return access_flags; }
0: 
0: 	/** @see ClassMember
0: 	*/
0: 	public String getName() {
0: 		return className(this_class).replace('/', '.');
0: 	}
0: 	/*
0: 	**	Public methods from ClassHolder
0: 	*/
0: 
0: 	/** @see ClassHolder#addMember */
0:  	public ClassMember addMember(String simpleName, String descriptor, int modifier)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (descriptor.startsWith("(")) {
0: 				if (method_info != null) {
0: 					if (method_info.find(simpleName, descriptor) != null) {
0: 						SanityManager.THROWASSERT("Method already exists " + simpleName + " " + descriptor);
0: 					}
0: 				}
0: 
0: 			} else {
0: 				if (field_info != null) {
0: 					if (field_info.find(simpleName, descriptor) != null) {
0: 						SanityManager.THROWASSERT("Field already exists " + simpleName + " " + descriptor);
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		CONSTANT_Utf8_info utf = addUtf8Entry(simpleName);
0: 
0: 		int nameIndex = utf.getIndex();
0: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
0: 
0: 		ClassMember item = new ClassMember(this, modifier, nameIndex, descriptorIndex);
0: 		MemberTable mt;
0: 		if (descriptor.startsWith("(")) {
0: 			mt = method_info;
0: 			if (mt == null)
0: 				mt = method_info = new MemberTable(0);
0: 
0: 		}
0: 		else {
0: 			mt = field_info;
0: 			if (mt == null)
0: 				mt = field_info = new MemberTable(0);
0: 		}
0: 
0: 		mt.addEntry(item);
0: 		return item;
0: 	}
0: 
0: 	/** @see ClassHolder#addFieldReference */
0: 	public int addFieldReference(String className, String simpleName, String descriptor) {
0: 		return addReference(VMDescriptor.CONSTANT_Fieldref, className, simpleName, descriptor);
0: 	}
0: 
0: 	public int addFieldReference(ClassMember field) {
0: 		return addReference(VMDescriptor.CONSTANT_Fieldref, (ClassMember) field);
0: 	}
0: 
0: 	/** @see ClassHolder#addMethodReference */
0: 	public int addMethodReference(String className, String simpleName, String descriptor, boolean isInterface) {
0: 
0: 		int tag = isInterface ?	VMDescriptor.CONSTANT_InterfaceMethodref :
0: 								VMDescriptor.CONSTANT_Methodref;
0: 
0: 		return addReference(tag, className, simpleName, descriptor); 
0: 	}
0: 
0: 	private int addReference(int tag, String className, String simpleName, String descriptor) {
0: 
0: 		int classIndex = addClassReference(className);
0: 		int nameTypeIndex = addNameAndType(simpleName, descriptor);
0: 
0: 		return addIndexReference(tag, classIndex, nameTypeIndex);
0: 	}
0: 
0: 	private int addReference(int tag, ClassMember member) {
0: 
0: 		int nameTypeIndex = addIndexReference(VMDescriptor.CONSTANT_NameAndType,
0: 							member.name_index, member.descriptor_index);
0: 
0: 		return addIndexReference(tag, this_class, nameTypeIndex);
0: 	}
0: 
0: 	/** @see ClassHolder#addConstant */
0: 	public int addConstant(String value) {
0: 
0: 		return addString(value);
0: 	}
0: 
0: 	/** @see ClassHolder#addUtf8 */
0: 	public int addUtf8(String value) {
0: 
0: 		return addUtf8Entry(value).getIndex();
0: 	}
0: 
0: 
0: 	/** @see ClassHolder#addInteger */
0: 	public int addConstant(int value) {
0: 		return addDirectEntry(new CONSTANT_Integer_info(value));
0: 	}
0: 
0: 	/** @see ClassHolder#addFloat */
0: 	public int addConstant(float value) {
0: 		return addDirectEntry(new CONSTANT_Float_info(value));
0: 	}
0: 
0: 	/** @see ClassHolder#addLong */
0: 	public int addConstant(long value) {
0: 		return addDirectEntry(new CONSTANT_Long_info(value));
0: 	}
0: 
0: 	/** @see ClassHolder#addDouble */
0: 	public int addConstant(double value) {
0: 		return addDirectEntry(new CONSTANT_Double_info(value));
0: 	}
0: 
0: 
0: 	/** @see ClassMember
0: 	*/
0: 	public int getConstantPoolIndex() { return this_class; }
0: 
0: 	public void addAttribute(String attributeName, ClassFormatOutput info) {
0: 
0: 		if (attribute_info == null)
0: 			attribute_info = new Attributes(1);
0: 
0: 
0: 		CONSTANT_Utf8_info autf = addUtf8Entry(attributeName);
0: 
0: 		int index = autf.getIndex();
0: 
0: 		attribute_info.addEntry(new AttributeEntry(index, info));
0: 	}
0: 
0: 
0: 	public String getSuperClassName() {
0: 		if (super_class == 0)
0: 			return null;
0: 		else
0: 			return className(super_class).replace('/', '.');
0: 	}
0: 
0: 
0: /*
0:     public ClassMember getMemberReference(String fullyQualifiedClassName, String simpleName, String descriptor) {
0: 
0: 		int classIndex;
0: 
0: 		if (fullyQualifiedClassName == null)
0: 			 classIndex = this_class;
0: 		else
0: 			classIndex = constantPool.findClass(fullyQualifiedClassName);
0: 
0: 		if (classIndex < 0)
0: 			return null;
0: 
0: 		int nameAndTypeIndex = constantPool.findNameAndType(simpleName, descriptor);
0: 		if (nameAndTypeIndex < 0)
0: 			return null;
0: 
0:         return constantPool.findReference(classIndex, nameAndTypeIndex);
0: 	}
0: */
0: 	/*
0: 	** Public methods from ClassRead
0: 	*/
0: 
0: 
0: 
0: 	/*
0: 	** Implementation specific methods.
0: 	*/
0: 
0: 	/*
0: 	** Methods related to Constant Pool Table
0: 	*/
0: 	/**
0: 		Generic add entry to constant pool. Includes the logic
0: 		for an entry to occupy more than one slot (e.g. long).
0: 
0: 		@return The number of slots occupied by the entry.
0: .
0: 	*/
0: 	protected int addEntry(Object key, ConstantPoolEntry item) {
0: 
0: 		item.setIndex(cptEntries.size());
0: 		if (key != null)
0: 			cptHashTable.put(key, item);
0: 		cptEntries.addElement(item);
0: 
0: 		cptEstimatedSize += item.classFileSize();
0: 
0: 		if (item.doubleSlot()) {
0: 			cptEntries.addElement(null);
0: 			return 2;
0: 		} else {
0: 			return 1;
0: 		}
0: 	}
0: 	
0: 	/**
0: 		Add an entry, but only if it doesn't exist.
0: 
0: 		@return the constant pool index of the added
0: 		or existing item.
0: 	*/
0: 	private int addDirectEntry(ConstantPoolEntry item) {
0: 		ConstantPoolEntry existingItem = findMatchingEntry(item);
0: 		if (existingItem != null) {
0: 			item = existingItem;
0: 			//foundCount++;
0: 		}
0: 		else {
0: 			addEntry(item.getKey(), item);
0: 		}
0: 		return item.getIndex();
0: 	}
0: 
0: 	/**
0: 		Add an index reference.
0: 	*/
0: 	private int addIndexReference(int tag, int i1, int i2) {
0: 
0: 		// search for the item using the pre-allocated object 
0: 		searchIndex.set(tag, i1, i2);
0: 
0: 		ConstantPoolEntry item = findMatchingEntry(searchIndex);
0: 
0: 		if (item == null) {
0: 			item = new CONSTANT_Index_info(tag, i1, i2);
0: 			addEntry(item.getKey(), item);
0: 		}
0: 
0: 		return item.getIndex();
0: 	}
0: 
0: 	/**
0: 		Add a class entry to the pool.
0: 	*/
0: 	public int addClassReference(String fullyQualifiedName) {
0: 		if (ClassHolder.isExternalClassName(fullyQualifiedName)) {
0: 			fullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
0: 			// System.out.println("addClassReference " + fullyQualifiedName);
0: 		}
0: 
0: 		int name_index = addUtf8Entry(fullyQualifiedName).getIndex();
0: 
0: 		return addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);
0: 	}
0: 
0: 	/**
0: 		Add a name and type entry
0: 	*/
0: 	private int addNameAndType(String name, String descriptor) {
0: 		int nameIndex = addUtf8Entry(name).getIndex();
0: 
0: 		int descriptorIndex = addUtf8Entry(descriptor).getIndex();
0: 
0: 		return addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);
0: 	}
0: 
0: 	/**
0: 		Add a UTF8 into the pool and return the index to it.
0: 	*/
0: 	private CONSTANT_Utf8_info addUtf8Entry(String value) {
0: 
0: 		CONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);
0: 
0: 		if (item == null) {
0: 
0: 			item = new CONSTANT_Utf8_info(value);
0: 			addEntry(value, item);
0: 		}
0: 		return item;
0: 	}
0: 	/**
0: 		Add an extra UTF8 into the pool 
0: 	*/
0: 	private CONSTANT_Utf8_info addExtraUtf8(String value) {
0: 
0: 		CONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);
0: 		addEntry(null, item);
0: 
0: 		return item;
0: 	}
0: 
0: 	/**
0: 		Add a string entry
0: 	*/
0: 	private int addString(String value) {
0: 		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
0: 		int valueIndex = sutf.setAsString();
0: 		if (valueIndex == 0) {
0: 			// string is already being used as code
0: 			valueIndex = addExtraUtf8(value).getIndex();
0: 			sutf.setAlternative(valueIndex);
0: 		}
0: 
0: 		return addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);
0: 	}
0: 
0: 	/**
0: 		Add a string entry
0: 	*/
0: 	private int addCodeUtf8(String value) {
0: 		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
0: 		int index = sutf.setAsCode();
0: 		if (index == 0) {
0: 			// code string is already being used as string
0: 			CONSTANT_Utf8_info eutf = addExtraUtf8(value);
0: 			eutf.setAsCode(); // ensure the replace will happen
0: 			index = eutf.getIndex();
0: 			sutf.setAlternative(index);
0: 		}
0: 
0: 		return index;
0: 	}
0:  	protected void cptPut(ClassFormatOutput out) throws IOException {
0: 
0: 		for (Enumeration e = cptEntries.elements(); e.hasMoreElements(); ) {
0: 			ConstantPoolEntry item = (ConstantPoolEntry) e.nextElement();
0: 			if (item == null) {
0: 				continue;
0: 			}
0: 
0: 			item.put(out);
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Methods to convert indexes to constant pool entries and vice-versa.
0: 	*/
0: 
0: 	ConstantPoolEntry getEntry(int index) {
0: 		return (ConstantPoolEntry) cptEntries.elementAt(index);
0: 	}
0: 
0: 	/**
0: 		Return the class name for an index to a CONSTANT_Class_info.
0: 	*/
0: 
0: 	protected String className(int classIndex) {
0: 		CONSTANT_Index_info ci = (CONSTANT_Index_info) getEntry(classIndex);
0: 
0: 		return nameIndexToString(ci.getI1()).replace('/', '.');
0: 
0: 	}
0: 
0: 	/*
0: 	** Methods to find specific types of constant pool entries.
0: 	   In these methods we try to avoid using the ConstantPoolEntry.matchValue()
0: 	   as that requires creating a new object for the search. The matchValue()
0: 	   call is really intended for when objects are being added to the constant pool.
0: 	*/
0: 
0: 	/**
0: 		Return the index of a UTF entry or -1 if it doesn't exist.
0: 	*/
0: 	int findUtf8(String value) {
0: 
0: 		ConstantPoolEntry item = findMatchingEntry(value);
0: 		if (item == null)
0: 			return -1;
0: 
0: 		return item.getIndex();
0: 	}
0: 
0: 	/**
0: 		Find a class descriptor (section 4.4.1) and return its
0: 		index, returns -1 if not found.
0: 	*/
0: 	public int findClass(String fullyQualifiedName) {
0: 		String internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
0: 		int utf_index = findUtf8(internalName);
0: 		if (utf_index < 0)
0: 			return -1;
0: 
0: 		return findIndexIndex(VMDescriptor.CONSTANT_Class,
0: 			utf_index, 0);
0: 	}
0: 
0: 
0: 	/**
0: 		Find a name and type descriptor (section 4.4.6) and
0: 		return ita index. returns -1 if not found.
0: 	*/
0: 	public int findNameAndType(String name, String descriptor) {
0: 
0: 		int name_index = findUtf8(name);
0: 		if (name_index < 0)
0: 			return -1;
0: 		int descriptor_index = findUtf8(descriptor);
0: 		if (descriptor_index < 0)
0: 			return -1;
0: 
0: 		return findIndexIndex(VMDescriptor.CONSTANT_NameAndType,
0: 			name_index, descriptor_index);
0: 	}
0: /*
0: 	public ClassMember findReference(int classIndex, int nameAndTypeIndex) {
0: 
0: 		CONSTANT_Index_info item = findIndexEntry(VMDescriptor.CONSTANT_Methodref,
0: 				classIndex, nameAndTypeIndex);
0: 
0: 		if (item == null) {
0: 
0: 			item = findIndexEntry(VMDescriptor.CONSTANT_InterfaceMethodref,
0: 				classIndex, nameAndTypeIndex);
0: 
0: 			if (item == null) {
0: 				item = findIndexEntry(VMDescriptor.CONSTANT_Fieldref,
0: 					classIndex, nameAndTypeIndex);
0: 
0: 				if (item == null)
0: 					return null;
0: 
0: 			}
0: 		}
0: 
0: 		return new ReferenceMember(this, item);
0: 	}
0: */
0: 	protected CONSTANT_Index_info findIndexEntry(int tag, int i1, int i2) {
0: 		// search for the item using the pre-allocated object 
0: 		searchIndex.set(tag, i1, i2);
0: 
0: 		return (CONSTANT_Index_info) findMatchingEntry(searchIndex);
0: 	}
0: 
0: 	protected int findIndexIndex(int tag, int i1, int i2) {
0: 		CONSTANT_Index_info item = findIndexEntry(tag, i1, i2);
0: 		if (item == null)
0: 			return -1;
0: 
0: 		return item.getIndex();
0: 	}
0: 
0: 	protected ConstantPoolEntry findMatchingEntry(Object key) {
0: 		return (ConstantPoolEntry) cptHashTable.get(key);
0: 	}
0: 
0: 	/** get a string (UTF) given a name_index into the constant pool
0: 	   */
0: 	String nameIndexToString(int index) {
0: 
0: 		return getEntry(index).toString();
0: 	}
0: 
0: 	/** get the class name of a Class given the index of its CONSTANT_Class_info
0: 	    entry in the Constant Pool.
0: 		*/
0: 
0: 	protected String getClassName(int index) {
0: 
0: 		if (index == 0)
0: 			return ""; // must be the super class of java.lang.Object, ie. nothing.
0: 
0: 		return 	nameIndexToString(getEntry(index).getI1());
0: 	}
0: 
0: 	/*
0: 	 * Determine whether the class descriptor string is 
0: 	 * in external format or not.  Assumes that to be in external
0: 	 * format means it must have a '.' or end in an ']'.
0: 	 * 
0: 	 * @param className	the name of the class to check
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public static boolean isExternalClassName(String className)
0: 	{
0: 		int len;
0: 		if (className.indexOf('.') != -1)
0: 		{
0: 			return true;
0: 		}
0: 		else if ((len = className.length()) == 0)
0: 		{ 
0: 			return false;
0: 		}
0: 		return (className.charAt(len - 1) == ']');
0: 	}
0: 
0: 	/*
0: 	 * Convert a class name to the internal VM class name format.
0: 	   See sections 4.3.2, 4.4.1 of the vm spec.
0: 	 * The normal leading 'L' and trailing ';' are left
0: 	 * off of objects.  This is intended primarily for
0: 	 * the class manager.
0: 	 * <p>
0: 	 * An example of a conversion would be java.lang.Double[]
0: 	 * to "[Ljava/lang/Double;".
0: 	 <BR>
0: 	   java.lang.Double would be converted to "java/lang/Double"
0: 
0: 	<BR>
0: 	Note that for array types the result of convertToInternalClassName()
0: 	and convertToInternalDescriptor() are identical.
0: 
0: 	 *
0: 	 * @param the external name (cannot be null)
0: 	 *
0: 	 * @return the internal string
0: 	 */
0: 	public static String convertToInternalClassName(String externalName)
0: 	{
0: 		return convertToInternal(externalName, false);
0: 	}
0: 
0: 	/*
0: 	 * Convert a class name to internal JVM descriptor format.
0: 	   See sections 4.3.2 of the vm spec.
0: 	 * <p>
0: 	 * An example of a conversion would be "java.lang.Double[]"
0: 	 * to "[Ljava/lang/Double;".
0: 	 *
0: 	 <BR>
0: 	   java.lang.Double would be converted to "Ljava/lang/Double;"
0: 
0: 	<BR>
0: 	Note that for array types the result of convertToInternalClassName()
0: 	and convertToInternalDescriptor() are identical.
0: 
0: 	 * @param the external name (cannot be null)
0: 	 *
0: 	 * @return the internal string
0: 	 */
0: 	public static String convertToInternalDescriptor(String externalName)
0: 	{
0: 		return convertToInternal(externalName, true);
0: 	}
0: 
0: 	/*
0: 	** Workhorse method.  Convert to internal format.
0: 
0: 		@param descriptor True if converting to descriptor format, false if
0: 		converting to class name format.
0: 	**
0: 	** Lifted from BCClass.java. 
0: 	**
0: 	** Returns the result string.
0: 	*/
0: 	private static String convertToInternal(String externalName, boolean descriptor)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(externalName != null, "unexpected null");
0: 		}
0: 
0: 		int len = externalName.length();
0: 
0: 		String internalName;	
0: 		String retVal = null;	
0: 		int origLen = len;
0: 		int arity = 0;
0: 
0: 		// first walk through all array-ness
0: 		if (externalName.charAt(len-1) == ']')
0: 		{
0: 			while (len > 0
0: 				&& externalName.charAt(len-1) == ']'
0: 				&& externalName.charAt(len-2) == '[') 
0: 			{
0: 				len -= 2;
0: 				arity++;
0: 			}
0: 		}
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(len > 0);
0: 		}
0: 
0: 		internalName = (origLen == len)? 
0: 						  externalName 
0: 						: externalName.substring(0,len);
0: 
0: 	    // then check for primitive types ... 
0: 		// in length by expected frequency order
0: 
0: 		switch (len) {
0: 			case 7 :
0: 		        if ("boolean".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_BOOLEAN, arity);
0: 				}
0: 				break;
0: 			case 4 :
0: 		        if ("void".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_VOID, arity);
0: 				}
0: 		        else if ("long".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_LONG, arity);
0: 				}
0: 		        else if ("byte".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_BYTE, arity);
0: 				}
0: 		        else if ("char".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_CHAR, arity);
0: 				}
0: 				break;
0: 			case 3 :
0: 		        if ("int".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_INT, arity);
0: 				}
0: 				break;
0: 			case 6 :
0: 		        if ("double".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_DOUBLE, arity);
0: 				}
0: 				break;
0: 			case 5 :
0: 		        if ("short".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_SHORT, arity);
0: 				}
0: 		        else if ("float".equals(internalName)) {
0: 					retVal = makeDesc(VMDescriptor.C_FLOAT, arity);
0: 				}
0: 				break;
0: 		}
0: 
0: 		// then it must be a Java class
0: 		if (retVal == null)
0: 			retVal = makeDesc(internalName, arity, descriptor);
0: 
0: 		return retVal;
0: 	}
0: 
0: 	/**
0: 		A helper to build a type description based on a built-in type
0: 		and an array arity.
0: 	 */
0: 	static private String makeDesc (char builtin, int arity) {
0: 		if (arity == 0)
0: 			switch (builtin) {
0: 				case VMDescriptor.C_BYTE : return VMDescriptor.BYTE;
0: 				case VMDescriptor.C_CHAR : return VMDescriptor.CHAR;
0: 				case VMDescriptor.C_DOUBLE : return VMDescriptor.DOUBLE;
0: 				case VMDescriptor.C_FLOAT : return VMDescriptor.FLOAT;
0: 				case VMDescriptor.C_INT : return VMDescriptor.INT;
0: 				case VMDescriptor.C_LONG : return VMDescriptor.LONG;
0: 				case VMDescriptor.C_SHORT : return VMDescriptor.SHORT;
0: 				case VMDescriptor.C_BOOLEAN : return VMDescriptor.BOOLEAN;
0: 				case VMDescriptor.C_VOID : return VMDescriptor.VOID;
0: 				default: 
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.THROWASSERT("No type match");
0: 					return null;
0: 			}
0: 		else {
0: 			StringBuffer desc = new StringBuffer(arity+3);
0: 
0: 			for (int i=0;i<arity;i++)
0: 				desc.append(VMDescriptor.C_ARRAY);
0: 
0: 			desc.append(ClassHolder.makeDesc(builtin, 0));
0: 
0: 			return desc.toString();
0: 		}
0: 	}
0: 
0: 	/**
0: 		A helper to build a type description based on a Java class
0: 		and an array arity.
0: 
0: 		If descriptor is true create a descriptor according to
0: 		section 4.3.2 of the vm spec. If false create a class name
0: 		according to sections 4.3.2 and 4.4.1 of the vm spec.
0: 	
0: 	 */
0: 	static private String makeDesc (String className, int arity, boolean descriptor) {
0: 
0: 		if (!descriptor && (arity == 0)) {
0: 			return className.replace('.','/');
0: 		}
0: 
0: 		StringBuffer desc = new StringBuffer(arity+2+className.length());
0: 
0: 		for (int i=0;i<arity;i++)
0: 			desc.append(VMDescriptor.C_ARRAY);
0: 
0: 		desc.append(VMDescriptor.C_CLASS);
0: 
0: 		desc.append(className.replace('.','/'));
0: 
0: 		desc.append(VMDescriptor.C_ENDCLASS);
0: 
0: 		return desc.toString();
0: 	}
0: 
0: 
0: }
============================================================================