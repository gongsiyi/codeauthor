1:782dbe1: /*
1:782dbe1: 
1:782dbe1:    Derby - Class org.apache.derby.impl.sql.execute.xplain.XPLAINUtil
1:782dbe1: 
1:782dbe1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:782dbe1:    contributor license agreements.  See the NOTICE file distributed with
1:782dbe1:    this work for additional information regarding copyright ownership.
1:782dbe1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:782dbe1:    (the "License"); you may not use this file except in compliance with
1:782dbe1:    the License.  You may obtain a copy of the License at
1:782dbe1: 
1:782dbe1:       http://www.apache.org/licenses/LICENSE-2.0
1:782dbe1: 
1:782dbe1:    Unless required by applicable law or agreed to in writing, software
1:782dbe1:    distributed under the License is distributed on an "AS IS" BASIS,
1:782dbe1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:782dbe1:    See the License for the specific language governing permissions and
1:782dbe1:    limitations under the License.
1:782dbe1: 
1:782dbe1:  */
1:782dbe1: 
1:48a9884: package org.apache.derby.impl.sql.execute.xplain;
1:48a9884: 
1:48a9884: import java.util.Properties;
1:48a9884: 
1:48a9884: import org.apache.derby.iapi.reference.SQLState;
1:48a9884: import org.apache.derby.iapi.services.i18n.MessageService;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINScanPropsDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINSortPropsDescriptor;
1:48a9884: /**
1:48a9884:  * This class contains helper methods, which support the System Table Visitor. 
1:48a9884:  *
1:48a9884:  */
1:48a9884: public class XPLAINUtil {
1:48a9884:      
1:48a9884:      /** isolation level codes */
1:48a9884:      public static final String ISOLATION_READ_UNCOMMITED     =   "RU"; // 0
1:48a9884:      public static final String ISOLATION_READ_COMMIT         =   "RC"; // 1
1:48a9884:      public static final String ISOLATION_REPEAT_READ         =   "RR"; // 2
1:48a9884:      public static final String ISOLATION_SERIALIZABLE        =   "SE"; // 3
1:48a9884:      
1:48a9884:      
1:48a9884:      /** lock  modes */
1:48a9884:      public static final String LOCK_MODE_EXCLUSIVE              =   "EX";
1:48a9884:      public static final String LOCK_MODE_INSTANTENOUS_EXCLUSIVE =   "IX";
1:48a9884: 
1:48a9884:      public static final String LOCK_MODE_SHARE                  =   "SH";
1:48a9884:      public static final String LOCK_MODE_INSTANTENOUS_SHARE     =   "IS";
1:48a9884: 
1:48a9884:      /** lock granularity */
1:48a9884:      public static final String LOCK_GRANULARITY_TABLE           =   "T";
1:48a9884:      public static final String LOCK_GRANULARITY_ROW             =   "R";
1:48a9884:      
1:48a9884:      /** the rs operator codes */
1:48a9884:      // scan operations
1:48a9884:      // ---------------
1:48a9884:      public static final String OP_TABLESCAN                  =   "TABLESCAN";
1:48a9884:      public static final String OP_INDEXSCAN                  =   "INDEXSCAN";
1:48a9884:      public static final String OP_HASHSCAN                   =   "HASHSCAN";
1:48a9884:      public static final String OP_DISTINCTSCAN               =   "DISTINCTSCAN";
1:48a9884:      public static final String OP_LASTINDEXKEYSCAN           =   "LASTINDEXKEYSCAN";
1:48a9884:      public static final String OP_HASHTABLE                  =   "HASHTABLE";
1:48a9884:      public static final String OP_ROWIDSCAN                  =   "ROWIDSCAN";
1:48a9884:      public static final String OP_CONSTRAINTSCAN             =   "CONSTRAINTSCAN";
1:48a9884:      
1:48a9884:      // join operations
1:48a9884:      // ---------------
1:48a9884:      public static final String OP_JOIN_NL                    =   "NLJOIN";
1:48a9884:      public static final String OP_JOIN_HASH                  =   "HASHJOIN";
1:48a9884:      public static final String OP_JOIN_NL_LO                 =   "LONLJOIN";
1:48a9884:      public static final String OP_JOIN_HASH_LO               =   "LOHASHJOIN";
1:48a9884:      public static final String OP_UNION                      =   "UNION";
1:48a9884:      public static final String OP_SET                        =   "SET";
1:48a9884:      
1:48a9884:      // set operation details
1:48a9884:      public static final String OP_SET_INTERSECT              =   "EXCEPT";
1:48a9884:      public static final String OP_SET_EXCEPT                 =   "INTERSECT";
1:48a9884:      
1:48a9884:      // dml write operations
1:48a9884:      // --------------------
1:48a9884:      // basic operations
1:48a9884:      public static final String OP_INSERT                     =   "INSERT";
1:48a9884:      public static final String OP_UPDATE                     =   "UPDATE";
1:48a9884:      public static final String OP_DELETE                     =   "DELETE";
1:48a9884:      
1:48a9884:      // specialized op_details
1:48a9884:      public static final String OP_CASCADE                    =   "CASCADE";
1:48a9884:      public static final String OP_VTI                        =   "VTI";
1:48a9884:      public static final String OP_BULK                       =   "BULK";
1:48a9884:      public static final String OP_DISTINCT                   =   "DISTINCT";
1:48a9884:      
1:48a9884:      // other operations
1:48a9884:      // ----------------
1:48a9884:      public static final String OP_NORMALIZE                  =   "NORMALIZE";
1:48a9884:      public static final String OP_ANY                        =   "ANY";     
1:48a9884:      public static final String OP_SCROLL                     =   "SCROLL";     
1:48a9884:      public static final String OP_MATERIALIZE                =   "MATERIALIZE";     
1:48a9884:      public static final String OP_ONCE                       =   "ONCE";     
1:48a9884:      public static final String OP_VTI_RS                     =   "VTI";     
1:48a9884:      public static final String OP_ROW                        =   "ROW";     
1:48a9884:      public static final String OP_PROJECT                    =   "PROJECTION";     
1:48a9884:      public static final String OP_FILTER                     =   "FILTER";     
1:48a9884:      public static final String OP_AGGREGATE                  =   "AGGREGATION";     
1:48a9884:      public static final String OP_PROJ_RESTRICT              =   "PROJECT-FILTER";
1:48a9884:      // sort operations
1:48a9884:      // ----------------
1:48a9884:      public static final String OP_SORT                       =   "SORT";     
1:48a9884:      public static final String OP_GROUP                      =   "GROUPBY";     
1:48a9884:      public static final String OP_CURRENT_OF                 =   "CURRENT-OF";
1:48a9884:      public static final String OP_ROW_COUNT                  =   "ROW-COUNT";
1:48a9884:      public static final String OP_WINDOW                     =   "WINDOW";
1:48a9884:      
1:48a9884:      /** the scan info codes */
1:48a9884:      public static final String SCAN_HEAP                     =   "HEAP";
1:48a9884:      public static final String SCAN_BTREE                    =   "BTREE";
1:48a9884:      public static final String SCAN_SORT                     =   "SORT";
1:48a9884:      public static final String SCAN_BITSET_ALL               =   "ALL";
1:48a9884:      
1:48a9884:      /** the different statement type constants */
1:48a9884:      public static final String SELECT_STMT_TYPE             = "S";
1:48a9884:      public static final String SELECT_APPROXIMATE_STMT_TYPE = "SA";
1:48a9884:      public static final String INSERT_STMT_TYPE             = "I";
1:48a9884:      public static final String UPDATE_STMT_TYPE             = "U";
1:48a9884:      public static final String DELETE_STMT_TYPE             = "D";
1:48a9884:      public static final String CALL_STMT_TYPE               = "C";
1:48a9884:      public static final String DDL_STMT_TYPE                = "DDL";
1:48a9884:      
1:48a9884:      /** the explain type constants */
1:48a9884:      public static final String XPLAIN_ONLY                  = "O";
1:48a9884:      public static final String XPLAIN_FULL                  = "F";
1:48a9884:      
1:48a9884:      /** sort info properties */ 
1:48a9884:      public static final String SORT_EXTERNAL                = "EX";
1:48a9884:      public static final String SORT_INTERNAL                = "IN";
1:48a9884:      
1:48a9884:      /** yes no codes */ 
1:48a9884:      public static final String YES_CODE                     = "Y";
1:48a9884:      public static final String NO_CODE                      = "N";
1:48a9884:      
1:48a9884:      // ---------------------------------------------
1:48a9884:      // utility functions 
1:48a9884:      // ---------------------------------------------
1:48a9884:      
1:48a9884:      public static String getYesNoCharFromBoolean(boolean test){
1:48a9884:          if(test){
1:48a9884:              return YES_CODE;
1:48a9884:          } else {
1:48a9884:              return NO_CODE;
1:48a9884:          }
1:48a9884:      }
1:48a9884:      
1:48a9884:      public static String getHashKeyColumnNumberString(int[] hashKeyColumns){
1:48a9884:         // original derby encoding
1:48a9884:         String hashKeyColumnString;
1:48a9884:         if (hashKeyColumns.length == 1)
1:48a9884:         {
1:48a9884:             hashKeyColumnString = MessageService.getTextMessage(
1:48a9884:                                                         SQLState.RTS_HASH_KEY) +
1:48a9884:                                     " " + hashKeyColumns[0];
1:48a9884:         }
1:48a9884:         else
1:48a9884:         {
1:48a9884:             hashKeyColumnString = MessageService.getTextMessage(
1:48a9884:                                                     SQLState.RTS_HASH_KEYS) +
1:48a9884:                                     " (" + hashKeyColumns[0];
1:48a9884:             for (int index = 1; index < hashKeyColumns.length; index++)
1:48a9884:             {
1:48a9884:                 hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];
1:48a9884:             }
1:48a9884:             hashKeyColumnString = hashKeyColumnString + ")";
1:48a9884:         }
1:48a9884:          return hashKeyColumnString;
1:48a9884:      }
1:48a9884:      
1:48a9884:      
1:48a9884:      /** util function, to resolve the lock mode, and return a lock mode code */
1:48a9884:      public static String getLockModeCode(String lockString){
1:48a9884:          lockString = lockString.toUpperCase();
1:48a9884:          if(lockString.startsWith("EXCLUSIVE")){
1:48a9884:              return LOCK_MODE_EXCLUSIVE;
1:48a9884:          } else
1:48a9884:          if(lockString.startsWith("SHARE")){
1:48a9884:              return LOCK_MODE_SHARE;
1:48a9884:          } else
1:48a9884:          if(lockString.startsWith("INSTANTANEOUS")){
1:48a9884:              int start = "INSTANTANEOUS".length();
1:48a9884:              int length = lockString.length();
1:48a9884:              String sub = lockString.substring(start+1, length);
1:48a9884:              if (sub.startsWith("EXCLUSIVE")){
1:48a9884:                  return LOCK_MODE_INSTANTENOUS_EXCLUSIVE;
1:48a9884:              } else 
1:48a9884:              if (sub.startsWith("SHARE")){
1:48a9884:                  return LOCK_MODE_INSTANTENOUS_SHARE;
1:48a9884:              } else 
1:48a9884:              return null;
1:48a9884:          } else
1:48a9884:          return null;
1:48a9884:      }
1:48a9884: 
1:48a9884:      /** util function, to resolve the isolation level and return a isolation level code */
1:48a9884:      public static String getIsolationLevelCode(String isolationLevel){
1:48a9884:          if(isolationLevel==null) return null;
1:48a9884:          if(isolationLevel.equals(MessageService.getTextMessage(
1:48a9884:                  SQLState.LANG_SERIALIZABLE))){
1:48a9884:              return ISOLATION_SERIALIZABLE;    // 3
1:48a9884:          } else 
1:48a9884:          if(isolationLevel.equals(MessageService.getTextMessage(
1:48a9884:                  SQLState.LANG_REPEATABLE_READ))){
1:48a9884:              return ISOLATION_REPEAT_READ;     // 2
1:48a9884:          } else 
1:48a9884:          if(isolationLevel.equals(MessageService.getTextMessage(
1:48a9884:                  SQLState.LANG_READ_COMMITTED))){
1:48a9884:              return ISOLATION_READ_COMMIT;     // 1
1:48a9884:          } else 
1:48a9884:          if(isolationLevel.equals(MessageService.getTextMessage(
1:48a9884:                  SQLState.LANG_READ_UNCOMMITTED))){
1:48a9884:              return ISOLATION_READ_UNCOMMITED; // 0
1:48a9884:          } else
1:48a9884:          return null;
1:48a9884:    
1:48a9884:      }
1:48a9884:      
1:48a9884:      
1:48a9884:      /** util function, to resolve the lock granularity and return a lock granularity code */
1:48a9884:      public static String getLockGranularityCode(String lockString){
1:48a9884:          lockString = lockString.toUpperCase();
1:48a9884:          if(lockString.endsWith("TABLE")){
1:48a9884:              return LOCK_GRANULARITY_TABLE;
1:48a9884:          } else {
1:48a9884:              return LOCK_GRANULARITY_ROW;
1:48a9884:          }
1:48a9884:      }
1:48a9884:      /**
1:48a9884:       * This method helps to figure out the statement type and returns
1:48a9884:       * an appropriate return code, characterizing the stmt type.
1:48a9884:       */
1:48a9884:      public static String getStatementType(String SQLText){
1:48a9884:          String type = "";
1:48a9884:          String text = SQLText.toUpperCase().trim();
1:48a9884:          if (text.startsWith("CALL")){
1:48a9884:              type = CALL_STMT_TYPE;
1:48a9884:          } else 
1:48a9884:          if (text.startsWith("SELECT")){
1:48a9884:              if (text.indexOf("~")>-1){
1:48a9884:                  type = SELECT_APPROXIMATE_STMT_TYPE;
1:48a9884:              } else {
1:48a9884:                  type = SELECT_STMT_TYPE;
1:48a9884:              }
1:48a9884:          } else
1:48a9884:          if (text.startsWith("DELETE")){
1:48a9884:              type = DELETE_STMT_TYPE;
1:48a9884:          } else
1:48a9884:          if (text.startsWith("INSERT")){
1:48a9884:              type = INSERT_STMT_TYPE;
1:48a9884:          } else
1:48a9884:          if (text.startsWith("UPDATE")){
1:48a9884:              type = UPDATE_STMT_TYPE;
1:48a9884:          } else
1:48a9884:          if (text.startsWith("CREATE") ||
1:48a9884:              text.startsWith("ALTER")  ||
1:48a9884:              text.startsWith("DROP")     ){
1:48a9884:              type = DDL_STMT_TYPE;
1:48a9884:          }
1:48a9884:          return type;
1:48a9884:      }
1:48a9884:      
1:48a9884:      /** helper method which extracts the right (non-internationalzed) scan
1:48a9884:       *  properties of the scan info properties 
1:48a9884:       * @param descriptor the descriptor to fill with properties
1:48a9884:       * @param scanProps the provided scan props
1:48a9884:       * @return the filled descriptor
1:48a9884:       */
1:48a9884:      public static XPLAINScanPropsDescriptor extractScanProps(
1:48a9884:                      XPLAINScanPropsDescriptor descriptor,
1:48a9884:                      Properties scanProps){
1:48a9884: 
1:48a9884:          
1:48a9884:          // Heap Scan Info Properties
1:48a9884:          // extract scan type with the help of the international message service 
1:48a9884:          String scan_type = "";
1:48a9884:          String scan_type_property = scanProps.getProperty(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_SCAN_TYPE));
1:48a9884:          if (scan_type_property!=null){
1:48a9884:              if(scan_type_property.equalsIgnoreCase(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_HEAP))){
1:48a9884:                  scan_type = SCAN_HEAP;
1:48a9884:              } else 
1:48a9884:              if(scan_type_property.equalsIgnoreCase(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_SORT))){
1:48a9884:                  scan_type = SCAN_SORT;
1:48a9884:              } else 
1:48a9884:              if(scan_type_property.equalsIgnoreCase(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_BTREE))){
1:48a9884:                  scan_type = SCAN_BTREE;
1:48a9884:              }             
1:48a9884:          } else {
1:48a9884:              scan_type = null;
1:48a9884:          }
1:48a9884:          descriptor.setScan_type(scan_type);
1:48a9884:          
1:48a9884:          // extract the number of visited pages 
1:48a9884:          String vp_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_PAGES_VISITED));
1:48a9884:          if(vp_property!=null){
1:ce40a31:              descriptor.setNo_visited_pages(Integer.parseInt(vp_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the number of visited rows 
1:48a9884:          String vr_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_VISITED));
1:48a9884:          if(vr_property!=null){
1:ce40a31:              descriptor.setNo_visited_rows(Integer.parseInt(vr_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the number of qualified rows 
1:48a9884:          String qr_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_QUALIFIED));
1:48a9884:          if(qr_property!=null){
1:ce40a31:              descriptor.setNo_qualified_rows(Integer.parseInt(qr_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the number of fetched columns 
1:48a9884:          String fc_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_COLUMNS_FETCHED));
1:48a9884:          if(fc_property!=null){
1:ce40a31:              descriptor.setNo_fetched_columns(Integer.parseInt(fc_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the number of deleted visited rows 
1:48a9884:          String dvr_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_DELETED_ROWS_VISITED));
1:48a9884:          if(dvr_property!=null){
1:ce40a31:              descriptor.setNo_visited_deleted_rows(Integer.parseInt(dvr_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the btree height 
1:48a9884:          String bth_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_TREE_HEIGHT));
1:48a9884:          if(bth_property!=null){
1:ce40a31:              descriptor.setBtree_height(Integer.parseInt(bth_property));
1:48a9884:          }
1:48a9884:          
1:48a9884:          // extract the fetched bit set 
1:48a9884:          String bs_property = scanProps.getProperty(
1:48a9884:             MessageService.getTextMessage(SQLState.STORE_RTS_COLUMNS_FETCHED_BIT_SET));
1:48a9884:          if(bs_property!=null){
1:48a9884:              if (bs_property.equalsIgnoreCase(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_ALL))){
1:48a9884:                  descriptor.setBitset_of_fetched_columns(SCAN_BITSET_ALL);
1:48a9884:              } else {
1:48a9884:                  descriptor.setBitset_of_fetched_columns(bs_property);
1:48a9884:                  
1:48a9884:              }
1:48a9884:          }
1:48a9884:          
1:48a9884:          // return the filled descriptor
1:48a9884:          return descriptor;
1:48a9884:          
1:48a9884:      }
1:48a9884: 
1:48a9884:      /** helper method which extracts the right (non-internationalzed) sort
1:48a9884:       *  properties of the sort info properties object 
1:48a9884:       * @param descriptor the descriptor to fill with properties
1:48a9884:       * @param sortProps the provided sort props
1:48a9884:       * @return the filled descriptor
1:48a9884:       */
1:48a9884:      public static XPLAINSortPropsDescriptor extractSortProps(
1:48a9884:              XPLAINSortPropsDescriptor descriptor,
1:48a9884:              Properties sortProps){
1:48a9884:          
1:48a9884:          String sort_type = null;
1:48a9884:          String sort_type_property = sortProps.getProperty(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_SORT_TYPE));
1:48a9884:          if(sort_type_property!=null){
1:48a9884:          if(sort_type_property.equalsIgnoreCase(
1:48a9884:              MessageService.getTextMessage(SQLState.STORE_RTS_EXTERNAL))){
1:48a9884:              sort_type = SORT_EXTERNAL;
1:48a9884:          } else {
1:48a9884:              sort_type = SORT_INTERNAL;
1:48a9884:          }}
1:48a9884:          descriptor.setSort_type(sort_type);
1:48a9884: 
1:48a9884:          
1:48a9884:          String ir_property = sortProps.getProperty(
1:48a9884:                  MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_INPUT));
1:48a9884:          if(ir_property!=null){
1:ce40a31:              descriptor.setNo_input_rows(Integer.parseInt(ir_property));
1:48a9884:          }
1:48a9884: 
1:48a9884:           String or_property = sortProps.getProperty(
1:48a9884:                   MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_OUTPUT));
1:48a9884:           if(or_property!=null){
1:ce40a31:               descriptor.setNo_output_rows(Integer.parseInt(or_property));
1:48a9884:           }
1:48a9884:               
1:48a9884:           if (sort_type == SORT_EXTERNAL){
1:48a9884:               String nomr_property = sortProps.getProperty(
1:48a9884:               MessageService.getTextMessage(SQLState.STORE_RTS_NUM_MERGE_RUNS));
1:48a9884:               
1:48a9884:               if(nomr_property!=null){
1:ce40a31:                   descriptor.setNo_merge_runs(Integer.parseInt(nomr_property));
1:48a9884:               }
1:48a9884:              
1:48a9884:               String nomrd_property = sortProps.getProperty(
1:48a9884:               MessageService.getTextMessage(SQLState.STORE_RTS_MERGE_RUNS_SIZE));
1:48a9884:               
1:48a9884:               if(nomrd_property!=null){
1:48a9884:                   descriptor.setMerge_run_details(nomrd_property);
1:48a9884:               }
1:48a9884:           
1:48a9884:          }
1:48a9884:          
1:48a9884:          return descriptor;
1:48a9884:      }
1:48a9884:      /**
1:48a9884:        * Compute average, avoiding divide-by-zero problems.
1:48a9884:        *
1:48a9884:       * @param dividend the long value for the dividend (the whole next time)
1:48a9884:       * @param divisor the long value for the divisor (the sum of all rows seen)
1:48a9884:       * @return the quotient or null
1:48a9884:       */
1:48a9884:      public static Long getAVGNextTime(long dividend, long divisor){
1:48a9884:          if(divisor==0) return null;
1:ce40a31:          if(dividend==0) return (long) 0;
1:ce40a31:          return dividend/divisor;
1:48a9884:      }
1:48a9884: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:              descriptor.setNo_visited_pages(Integer.parseInt(vp_property));
1:              descriptor.setNo_visited_rows(Integer.parseInt(vr_property));
1:              descriptor.setNo_qualified_rows(Integer.parseInt(qr_property));
1:              descriptor.setNo_fetched_columns(Integer.parseInt(fc_property));
1:              descriptor.setNo_visited_deleted_rows(Integer.parseInt(dvr_property));
1:              descriptor.setBtree_height(Integer.parseInt(bth_property));
/////////////////////////////////////////////////////////////////////////
1:              descriptor.setNo_input_rows(Integer.parseInt(ir_property));
1:               descriptor.setNo_output_rows(Integer.parseInt(or_property));
/////////////////////////////////////////////////////////////////////////
1:                   descriptor.setNo_merge_runs(Integer.parseInt(nomr_property));
/////////////////////////////////////////////////////////////////////////
1:          if(dividend==0) return (long) 0;
1:          return dividend/divisor;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:782dbe1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.xplain.XPLAINUtil
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.sql.execute.xplain;
1: 
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.impl.sql.catalog.XPLAINScanPropsDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINSortPropsDescriptor;
1: /**
1:  * This class contains helper methods, which support the System Table Visitor. 
1:  *
1:  */
1: public class XPLAINUtil {
1:      
1:      /** isolation level codes */
1:      public static final String ISOLATION_READ_UNCOMMITED     =   "RU"; // 0
1:      public static final String ISOLATION_READ_COMMIT         =   "RC"; // 1
1:      public static final String ISOLATION_REPEAT_READ         =   "RR"; // 2
1:      public static final String ISOLATION_SERIALIZABLE        =   "SE"; // 3
1:      
1:      
1:      /** lock  modes */
1:      public static final String LOCK_MODE_EXCLUSIVE              =   "EX";
1:      public static final String LOCK_MODE_INSTANTENOUS_EXCLUSIVE =   "IX";
1: 
1:      public static final String LOCK_MODE_SHARE                  =   "SH";
1:      public static final String LOCK_MODE_INSTANTENOUS_SHARE     =   "IS";
1: 
1:      /** lock granularity */
1:      public static final String LOCK_GRANULARITY_TABLE           =   "T";
1:      public static final String LOCK_GRANULARITY_ROW             =   "R";
1:      
1:      /** the rs operator codes */
1:      // scan operations
1:      // ---------------
1:      public static final String OP_TABLESCAN                  =   "TABLESCAN";
1:      public static final String OP_INDEXSCAN                  =   "INDEXSCAN";
1:      public static final String OP_HASHSCAN                   =   "HASHSCAN";
1:      public static final String OP_DISTINCTSCAN               =   "DISTINCTSCAN";
1:      public static final String OP_LASTINDEXKEYSCAN           =   "LASTINDEXKEYSCAN";
1:      public static final String OP_HASHTABLE                  =   "HASHTABLE";
1:      public static final String OP_ROWIDSCAN                  =   "ROWIDSCAN";
1:      public static final String OP_CONSTRAINTSCAN             =   "CONSTRAINTSCAN";
1:      
1:      // join operations
1:      // ---------------
1:      public static final String OP_JOIN_NL                    =   "NLJOIN";
1:      public static final String OP_JOIN_HASH                  =   "HASHJOIN";
1:      public static final String OP_JOIN_NL_LO                 =   "LONLJOIN";
1:      public static final String OP_JOIN_HASH_LO               =   "LOHASHJOIN";
1:      public static final String OP_UNION                      =   "UNION";
1:      public static final String OP_SET                        =   "SET";
1:      
1:      // set operation details
1:      public static final String OP_SET_INTERSECT              =   "EXCEPT";
1:      public static final String OP_SET_EXCEPT                 =   "INTERSECT";
1:      
1:      // dml write operations
1:      // --------------------
1:      // basic operations
1:      public static final String OP_INSERT                     =   "INSERT";
1:      public static final String OP_UPDATE                     =   "UPDATE";
1:      public static final String OP_DELETE                     =   "DELETE";
1:      
1:      // specialized op_details
1:      public static final String OP_CASCADE                    =   "CASCADE";
1:      public static final String OP_VTI                        =   "VTI";
1:      public static final String OP_BULK                       =   "BULK";
1:      public static final String OP_DISTINCT                   =   "DISTINCT";
1:      
1:      // other operations
1:      // ----------------
1:      public static final String OP_NORMALIZE                  =   "NORMALIZE";
1:      public static final String OP_ANY                        =   "ANY";     
1:      public static final String OP_SCROLL                     =   "SCROLL";     
1:      public static final String OP_MATERIALIZE                =   "MATERIALIZE";     
1:      public static final String OP_ONCE                       =   "ONCE";     
1:      public static final String OP_VTI_RS                     =   "VTI";     
1:      public static final String OP_ROW                        =   "ROW";     
1:      public static final String OP_PROJECT                    =   "PROJECTION";     
1:      public static final String OP_FILTER                     =   "FILTER";     
1:      public static final String OP_AGGREGATE                  =   "AGGREGATION";     
1:      public static final String OP_PROJ_RESTRICT              =   "PROJECT-FILTER";
1:      // sort operations
1:      // ----------------
1:      public static final String OP_SORT                       =   "SORT";     
1:      public static final String OP_GROUP                      =   "GROUPBY";     
1:      public static final String OP_CURRENT_OF                 =   "CURRENT-OF";
1:      public static final String OP_ROW_COUNT                  =   "ROW-COUNT";
1:      public static final String OP_WINDOW                     =   "WINDOW";
1:      
1:      /** the scan info codes */
1:      public static final String SCAN_HEAP                     =   "HEAP";
1:      public static final String SCAN_BTREE                    =   "BTREE";
1:      public static final String SCAN_SORT                     =   "SORT";
1:      public static final String SCAN_BITSET_ALL               =   "ALL";
1:      
1:      /** the different statement type constants */
1:      public static final String SELECT_STMT_TYPE             = "S";
1:      public static final String SELECT_APPROXIMATE_STMT_TYPE = "SA";
1:      public static final String INSERT_STMT_TYPE             = "I";
1:      public static final String UPDATE_STMT_TYPE             = "U";
1:      public static final String DELETE_STMT_TYPE             = "D";
1:      public static final String CALL_STMT_TYPE               = "C";
1:      public static final String DDL_STMT_TYPE                = "DDL";
1:      
1:      /** the explain type constants */
1:      public static final String XPLAIN_ONLY                  = "O";
1:      public static final String XPLAIN_FULL                  = "F";
1:      
1:      /** sort info properties */ 
1:      public static final String SORT_EXTERNAL                = "EX";
1:      public static final String SORT_INTERNAL                = "IN";
1:      
1:      /** yes no codes */ 
1:      public static final String YES_CODE                     = "Y";
1:      public static final String NO_CODE                      = "N";
1:      
1:      // ---------------------------------------------
1:      // utility functions 
1:      // ---------------------------------------------
1:      
1:      public static String getYesNoCharFromBoolean(boolean test){
1:          if(test){
1:              return YES_CODE;
1:          } else {
1:              return NO_CODE;
1:          }
1:      }
1:      
1:      public static String getHashKeyColumnNumberString(int[] hashKeyColumns){
1:         // original derby encoding
1:         String hashKeyColumnString;
1:         if (hashKeyColumns.length == 1)
1:         {
1:             hashKeyColumnString = MessageService.getTextMessage(
1:                                                         SQLState.RTS_HASH_KEY) +
1:                                     " " + hashKeyColumns[0];
1:         }
1:         else
1:         {
1:             hashKeyColumnString = MessageService.getTextMessage(
1:                                                     SQLState.RTS_HASH_KEYS) +
1:                                     " (" + hashKeyColumns[0];
1:             for (int index = 1; index < hashKeyColumns.length; index++)
1:             {
1:                 hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];
1:             }
1:             hashKeyColumnString = hashKeyColumnString + ")";
1:         }
1:          return hashKeyColumnString;
1:      }
1:      
1:      
1:      /** util function, to resolve the lock mode, and return a lock mode code */
1:      public static String getLockModeCode(String lockString){
1:          lockString = lockString.toUpperCase();
1:          if(lockString.startsWith("EXCLUSIVE")){
1:              return LOCK_MODE_EXCLUSIVE;
1:          } else
1:          if(lockString.startsWith("SHARE")){
1:              return LOCK_MODE_SHARE;
1:          } else
1:          if(lockString.startsWith("INSTANTANEOUS")){
1:              int start = "INSTANTANEOUS".length();
1:              int length = lockString.length();
1:              String sub = lockString.substring(start+1, length);
1:              if (sub.startsWith("EXCLUSIVE")){
1:                  return LOCK_MODE_INSTANTENOUS_EXCLUSIVE;
1:              } else 
1:              if (sub.startsWith("SHARE")){
1:                  return LOCK_MODE_INSTANTENOUS_SHARE;
1:              } else 
1:              return null;
1:          } else
1:          return null;
1:      }
1: 
1:      /** util function, to resolve the isolation level and return a isolation level code */
1:      public static String getIsolationLevelCode(String isolationLevel){
1:          if(isolationLevel==null) return null;
1:          if(isolationLevel.equals(MessageService.getTextMessage(
1:                  SQLState.LANG_SERIALIZABLE))){
1:              return ISOLATION_SERIALIZABLE;    // 3
1:          } else 
1:          if(isolationLevel.equals(MessageService.getTextMessage(
1:                  SQLState.LANG_REPEATABLE_READ))){
1:              return ISOLATION_REPEAT_READ;     // 2
1:          } else 
1:          if(isolationLevel.equals(MessageService.getTextMessage(
1:                  SQLState.LANG_READ_COMMITTED))){
1:              return ISOLATION_READ_COMMIT;     // 1
1:          } else 
1:          if(isolationLevel.equals(MessageService.getTextMessage(
1:                  SQLState.LANG_READ_UNCOMMITTED))){
1:              return ISOLATION_READ_UNCOMMITED; // 0
1:          } else
1:          return null;
1:    
1:      }
1:      
1:      
1:      /** util function, to resolve the lock granularity and return a lock granularity code */
1:      public static String getLockGranularityCode(String lockString){
1:          lockString = lockString.toUpperCase();
1:          if(lockString.endsWith("TABLE")){
1:              return LOCK_GRANULARITY_TABLE;
1:          } else {
1:              return LOCK_GRANULARITY_ROW;
1:          }
1:      }
1:      /**
1:       * This method helps to figure out the statement type and returns
1:       * an appropriate return code, characterizing the stmt type.
1:       */
1:      public static String getStatementType(String SQLText){
1:          String type = "";
1:          String text = SQLText.toUpperCase().trim();
1:          if (text.startsWith("CALL")){
1:              type = CALL_STMT_TYPE;
1:          } else 
1:          if (text.startsWith("SELECT")){
1:              if (text.indexOf("~")>-1){
1:                  type = SELECT_APPROXIMATE_STMT_TYPE;
1:              } else {
1:                  type = SELECT_STMT_TYPE;
1:              }
1:          } else
1:          if (text.startsWith("DELETE")){
1:              type = DELETE_STMT_TYPE;
1:          } else
1:          if (text.startsWith("INSERT")){
1:              type = INSERT_STMT_TYPE;
1:          } else
1:          if (text.startsWith("UPDATE")){
1:              type = UPDATE_STMT_TYPE;
1:          } else
1:          if (text.startsWith("CREATE") ||
1:              text.startsWith("ALTER")  ||
1:              text.startsWith("DROP")     ){
1:              type = DDL_STMT_TYPE;
1:          }
1:          return type;
1:      }
1:      
1:      /** helper method which extracts the right (non-internationalzed) scan
1:       *  properties of the scan info properties 
1:       * @param descriptor the descriptor to fill with properties
1:       * @param scanProps the provided scan props
1:       * @return the filled descriptor
1:       */
1:      public static XPLAINScanPropsDescriptor extractScanProps(
1:                      XPLAINScanPropsDescriptor descriptor,
1:                      Properties scanProps){
1: 
1:          
1:          // Heap Scan Info Properties
1:          // extract scan type with the help of the international message service 
1:          String scan_type = "";
1:          String scan_type_property = scanProps.getProperty(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_SCAN_TYPE));
1:          if (scan_type_property!=null){
1:              if(scan_type_property.equalsIgnoreCase(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_HEAP))){
1:                  scan_type = SCAN_HEAP;
1:              } else 
1:              if(scan_type_property.equalsIgnoreCase(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_SORT))){
1:                  scan_type = SCAN_SORT;
1:              } else 
1:              if(scan_type_property.equalsIgnoreCase(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_BTREE))){
1:                  scan_type = SCAN_BTREE;
1:              }             
1:          } else {
1:              scan_type = null;
1:          }
1:          descriptor.setScan_type(scan_type);
1:          
1:          // extract the number of visited pages 
1:          String vp_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_PAGES_VISITED));
1:          if(vp_property!=null){
0:              descriptor.setNo_visited_pages(new Integer(vp_property));
1:          }
1:          
1:          // extract the number of visited rows 
1:          String vr_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_VISITED));
1:          if(vr_property!=null){
0:              descriptor.setNo_visited_rows(new Integer(vr_property));
1:          }
1:          
1:          // extract the number of qualified rows 
1:          String qr_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_QUALIFIED));
1:          if(qr_property!=null){
0:              descriptor.setNo_qualified_rows(new Integer(qr_property));
1:          }
1:          
1:          // extract the number of fetched columns 
1:          String fc_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_COLUMNS_FETCHED));
1:          if(fc_property!=null){
0:              descriptor.setNo_fetched_columns(new Integer(fc_property));
1:          }
1:          
1:          // extract the number of deleted visited rows 
1:          String dvr_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_NUM_DELETED_ROWS_VISITED));
1:          if(dvr_property!=null){
0:              descriptor.setNo_visited_deleted_rows(new Integer(dvr_property));
1:          }
1:          
1:          // extract the btree height 
1:          String bth_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_TREE_HEIGHT));
1:          if(bth_property!=null){
0:              descriptor.setBtree_height(new Integer(bth_property));
1:          }
1:          
1:          // extract the fetched bit set 
1:          String bs_property = scanProps.getProperty(
1:             MessageService.getTextMessage(SQLState.STORE_RTS_COLUMNS_FETCHED_BIT_SET));
1:          if(bs_property!=null){
1:              if (bs_property.equalsIgnoreCase(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_ALL))){
1:                  descriptor.setBitset_of_fetched_columns(SCAN_BITSET_ALL);
1:              } else {
1:                  descriptor.setBitset_of_fetched_columns(bs_property);
1:                  
1:              }
1:          }
1:          
1:          // return the filled descriptor
1:          return descriptor;
1:          
1:      }
1: 
1:      /** helper method which extracts the right (non-internationalzed) sort
1:       *  properties of the sort info properties object 
1:       * @param descriptor the descriptor to fill with properties
1:       * @param sortProps the provided sort props
1:       * @return the filled descriptor
1:       */
1:      public static XPLAINSortPropsDescriptor extractSortProps(
1:              XPLAINSortPropsDescriptor descriptor,
1:              Properties sortProps){
1:          
1:          String sort_type = null;
1:          String sort_type_property = sortProps.getProperty(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_SORT_TYPE));
1:          if(sort_type_property!=null){
1:          if(sort_type_property.equalsIgnoreCase(
1:              MessageService.getTextMessage(SQLState.STORE_RTS_EXTERNAL))){
1:              sort_type = SORT_EXTERNAL;
1:          } else {
1:              sort_type = SORT_INTERNAL;
1:          }}
1:          descriptor.setSort_type(sort_type);
1: 
1:          
1:          String ir_property = sortProps.getProperty(
1:                  MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_INPUT));
1:          if(ir_property!=null){
0:               descriptor.setNo_input_rows(new Integer(ir_property));
1:          }
1: 
1:           String or_property = sortProps.getProperty(
1:                   MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_OUTPUT));
1:           if(or_property!=null){
0:                descriptor.setNo_output_rows(new Integer(or_property));
1:           }
1:               
1:           if (sort_type == SORT_EXTERNAL){
1:               String nomr_property = sortProps.getProperty(
1:               MessageService.getTextMessage(SQLState.STORE_RTS_NUM_MERGE_RUNS));
1:               
1:               if(nomr_property!=null){
0:                  descriptor.setNo_merge_runs(new Integer(nomr_property));
1:               }
1:              
1:               String nomrd_property = sortProps.getProperty(
1:               MessageService.getTextMessage(SQLState.STORE_RTS_MERGE_RUNS_SIZE));
1:               
1:               if(nomrd_property!=null){
1:                   descriptor.setMerge_run_details(nomrd_property);
1:               }
1:           
1:          }
1:          
1:          return descriptor;
1:      }
1:      /**
1:        * Compute average, avoiding divide-by-zero problems.
1:        *
1:       * @param dividend the long value for the dividend (the whole next time)
1:       * @param divisor the long value for the divisor (the sum of all rows seen)
1:       * @return the quotient or null
1:       */
1:      public static Long getAVGNextTime(long dividend, long divisor){
1:          if(divisor==0) return null;
0:          if(dividend==0) return new Long(0);
0:          return new Long(dividend/divisor);
1:      }
1: }
============================================================================