1:4cc0287: /*
1:4cc0287: 
1:4cc0287:  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForeignKeysDeferrableTest
1:4cc0287: 
1:4cc0287:  Licensed to the Apache Software Foundation (ASF) under one or more
1:4cc0287:  contributor license agreements.  See the NOTICE file distributed with
1:4cc0287:  this work for additional information regarding copyright ownership.
1:4cc0287:  The ASF licenses this file to You under the Apache License, Version 2.0
1:4cc0287:  (the "License"); you may not use this file except in compliance with
1:4cc0287:  the License.  You may obtain a copy of the License at
1:4cc0287: 
1:4cc0287:  http://www.apache.org/licenses/LICENSE-2.0
1:4cc0287: 
1:4cc0287:  Unless required by applicable law or agreed to in writing, software
1:4cc0287:  distributed under the License is distributed on an "AS IS" BASIS,
1:4cc0287:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4cc0287:  See the License for the specific language governing permissions and
1:4cc0287:  limitations under the License.
1:4cc0287: 
1:4cc0287:  */
1:4cc0287: 
1:4cc0287: package org.apache.derbyTesting.functionTests.tests.lang;
1:4cc0287: 
1:64b6308: import java.sql.Connection;
1:9179199: import java.sql.ResultSet;
1:4cc0287: import java.sql.SQLException;
1:4cc0287: import java.sql.Statement;
1:4cc0287: import junit.framework.Test;
1:4cc0287: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:4cc0287: import org.apache.derbyTesting.junit.JDBC;
1:4cc0287: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:d02bb72: import org.apache.derby.shared.common.error.DerbySQLIntegrityConstraintViolationException;
1:4cc0287: import static org.apache.derbyTesting.junit.TestConfiguration.clientServerSuite;
1:4cc0287: import static org.apache.derbyTesting.junit.TestConfiguration.embeddedSuite;
1:4cc0287: 
1:4cc0287: /**
1:4cc0287:  * Test deferrable foreign key constraints.
1:4cc0287:  *
1:4cc0287:  * NOTE: In contrast to constraint checking, the <em>referential actions</em>
1:4cc0287:  * specified by a referential constraint are never deferred.
1:4cc0287:  * (SQL 2011: section 4.18.2).
1:4cc0287:  * <p/>
1:4cc0287:  * Section 4.18.3.3:
1:4cc0287:  * An {@code <update rule>} that does not contain NO ACTION specifies a
1:4cc0287:  * referential update action. A {@code <delete rule>} that does not specify NO
1:4cc0287:  * ACTION specifies a referential delete action. Referential update
1:4cc0287:  * actions and referential delete actions are collectively called
1:4cc0287:  * referential actions. Referential actions are carried out before, and
1:4cc0287:  * are not part of, the checking of a referential constraint. Deferring a
1:4cc0287:  * referential constraint defers the checking of the {@code <search condition>}
1:4cc0287:  * of the constraint (a {@code <match predicate>}) but does not defer the
1:4cc0287:  * referential actions of the referential constraint.
1:4cc0287:  * <p/>
1:43aa7cd:  * NOTE 52 - For example, if a referential update action such as ON UPDATE
1:4cc0287:  * CASCADE is specified, then any UPDATE operation on the referenced table will
1:4cc0287:  * be cascaded to the referencing table as part of the UPDATE operation, even
1:4cc0287:  * if the referential constraint is deferred. Consequently, the referential
1:4cc0287:  * constraint cannot become violated by the UPDATE statement. On the other
1:4cc0287:  * hand, ON UPDATE SET DEFAULT could result in a violation of the referential
1:4cc0287:  * constraint if there is no matching row after the referencing column is set
1:4cc0287:  * to its default value. In addition, INSERT and UPDATE operations on the
1:4cc0287:  * referencing table do not entail any automatic enforcement of the referential
1:4cc0287:  * constraint. Any such violations of the constraint will be detected when the
1:4cc0287:  * referential constraint is eventually checked, at or before a commit.
1:4cc0287:  * <p/>
1:43aa7cd:  * NOTE 53 - Even if constraint checking is not deferred, ON UPDATE
1:4cc0287:  * RESTRICT is a stricter condition than ON UPDATE NO ACTION. ON UPDATE
1:4cc0287:  * RESTRICT prohibits an update to a particular row if there are any
1:4cc0287:  * matching rows; ON UPDATE NO ACTION does not perform its constraint
1:9179199:  * check until the entire set of rows to be updated has been processed.
1:9179199:  * <p/>
1:4cc0287:  * NOTE 54 - Ditto for DELETE.
1:4cc0287:  * <p/>
1:4cc0287:  * Line numbers in the comments refer to svn revision 1580845 of Derby trunk.
1:4cc0287:  */
1:4cc0287: public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
1:4cc0287: {
1:2db96c5:     private static final String  LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T
1:2db96c5:                                                                     = "23506";
1:4cc0287:     private static final String  LANG_DEFERRED_FK_CONSTRAINT_T = "23516";
1:4cc0287:     private static final String  LANG_DEFERRED_FK_CONSTRAINT_S = "23517";
1:4cc0287:     private static final String  LANG_ADD_FK_CONSTRAINT_VIOLATION = "X0Y45";
1:4cc0287:     private static final String  LANG_FK_VIOLATION = "23503";
1:4cc0287: 
1:4cc0287: 
1:4cc0287:     private static String expImpDataFile;  // file used to perform
1:4cc0287:                                            // import/export
1:4cc0287:     private static boolean exportFilesCreatedEmbedded = false;
1:4cc0287:     private static boolean exportFilesCreatedClient = false;
1:4cc0287: 
1:4cc0287: 
1:4cc0287:     public ForeignKeysDeferrableTest(String name) {
1:4cc0287:         super(name);
3:4cc0287:     }
1:18a6fb2: 
1:4cc0287: 
1:4cc0287:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:4cc0287:         suite.addTest(new SupportFilesSetup(
1:4cc0287:                 embeddedSuite(ForeignKeysDeferrableTest.class)));
1:4cc0287:         suite.addTest(new SupportFilesSetup(
1:4cc0287:                 clientServerSuite(ForeignKeysDeferrableTest.class)));
1:4cc0287: 
1:4cc0287:         return suite;
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     @Override
1:4cc0287:     protected void setUp() throws Exception {
1:4cc0287:         super.setUp();
1:4cc0287: 
1:4cc0287:         Statement s = createStatement();
1:4cc0287: 
1:4cc0287:         // <table_name> ::= <role>_<statementType>_<action>
1:4cc0287:         // where:
1:4cc0287:         // <role> ::=  "ref"   /* a referenced table */
1:4cc0287:         //           | "t"     /* a referencing table: carries the FK */
5:4cc0287:         //
1:4cc0287:         // <statement type> ::= "d"  /* delete */
1:4cc0287:         //                    | "u"  /* update */
1:18a6fb2:         //
1:4cc0287:         // <action> ::= "r"  /* restrict */
1:4cc0287:         //            | "c"  /* cascade */
1:4cc0287:         //            | "na" /* no action */
1:4cc0287:         //            | "nu" /* set null */
1:4cc0287:         //
1:4cc0287:         // Insert statements borrow the "d" tables.  The constraint names use
1:4cc0287:         // similar semantics, e.g. "c_d_c": constraint, delete table set,
1:4cc0287:         // cascade.
1:4cc0287: 
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_d_r(i int primary key, j int default 2)");
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_d_c(i int primary key, j int default 2)");
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_d_na(i int primary key, j int default 2)");
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_d_nu(i int primary key, j int default 2)");
1:4cc0287: 
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_u_r(i int primary key, j int default 2)");
1:18a6fb2:         s.executeUpdate(
1:4cc0287:                 "create table ref_u_na(i int primary key, j int default 2)");
1:4cc0287: 
1:4cc0287:         s.executeUpdate("insert into ref_d_r values (1, default)");
1:4cc0287:         s.executeUpdate("insert into ref_d_c values (1, default)");
1:4cc0287:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:4cc0287:         s.executeUpdate("insert into ref_d_nu values (1, default)");
1:4cc0287: 
1:4cc0287:         s.executeUpdate("insert into ref_u_r values (1, default)");
1:4cc0287:         s.executeUpdate("insert into ref_u_na values (1, default)");
1:4cc0287: 
1:4cc0287: 
1:4cc0287:         // Tables for testing delete with {CASCADE, RESTRICT, SET NULL,
1:4cc0287:         // NOACTION}
1:18a6fb2:         s.executeUpdate(
1:4cc0287:             "create table t_d_r(i int, j int default 2," +
1:4cc0287:             "   constraint c_d_r foreign key (i) references ref_d_r(i) " +
1:4cc0287:             "   on delete restrict " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
1:9179199:         s.executeUpdate(
1:4cc0287:             "create table t_d_c(i int, j int default 2," +
1:4cc0287:             "   constraint c_d_c foreign key (i) references ref_d_c(i) " +
1:4cc0287:             "   on delete cascade " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
1:9179199:         s.executeUpdate(
1:4cc0287:             "create table t_d_na(i int, j int default 2," +
1:4cc0287:             "   constraint c_d_na foreign key (i) references ref_d_na(i) " +
1:4cc0287:             "   on delete no action " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
10:4cc0287:         s.executeUpdate(
1:4cc0287:             "create table t_d_nu(i int, j int default 2," +
1:4cc0287:             "   constraint c_d_nu foreign key (i) references ref_d_nu(i) " +
1:4cc0287:             "   on delete set null " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
1:4cc0287:         // Tables for testing update with {RESTRICT, NOACTION}
1:4cc0287:         s.executeUpdate(
1:4cc0287:             "create table t_u_r(i int, j int default 2," +
1:4cc0287:             "   constraint c_u_r foreign key (i) references ref_u_r(i) " +
1:4cc0287:             "   on update restrict " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
1:4cc0287:         s.executeUpdate(
1:4cc0287:             "create table t_u_na(i int, j int default 2," +
1:4cc0287:             "   constraint c_u_na foreign key (i) references ref_u_na(i) " +
1:4cc0287:             "   on update no action " +
1:4cc0287:             "deferrable initially immediate)");
1:4cc0287: 
1:4cc0287:         s.executeUpdate("insert into t_d_r   values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_d_c   values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_d_na  values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_d_nu  values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_u_r   values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_u_na  values (1, default)");
1:4cc0287: 
1:4cc0287:         if ((usingEmbedded() && !exportFilesCreatedEmbedded) ||
1:4cc0287:             (usingDerbyNetClient() && !exportFilesCreatedClient)) {
1:4cc0287: 
1:4cc0287:             // We have to do this once for embedded and once for client/server
1:4cc0287:             if (usingEmbedded()) {
1:4cc0287:                 exportFilesCreatedEmbedded = true;
1:4cc0287:             } else {
1:4cc0287:                 exportFilesCreatedClient = true;
1:4cc0287:             }
1:4cc0287: 
1:4cc0287:             // Create a file for import that contains rows for which the
1:4cc0287:             // foreign key constraint doesn't hold.
1:4cc0287:             expImpDataFile =
1:4cc0287:                 SupportFilesSetup.getReadWrite("t.data").getPath();
1:4cc0287:             s.executeUpdate("create table t(i int, j int)");
1:4cc0287:             s.executeUpdate("insert into t values (1,2),(2,2)");
1:4cc0287:             s.executeUpdate(
1:4cc0287:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE (" +
1:4cc0287:                 "    'APP' , 'T' , '" + expImpDataFile + "'," +
1:4cc0287:                 "    null, null , null)");
1:4cc0287:             s.executeUpdate("drop table t");
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         setAutoCommit(false);
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     @Override
1:4cc0287:     protected void tearDown() throws Exception {
1:4cc0287:         rollback();
1:4cc0287:         setAutoCommit(true);
1:4cc0287:         Statement s = createStatement();
1:0493010:         dropTable("t_d_r");
1:0493010:         dropTable("t_d_c");
1:0493010:         dropTable("t_d_na");
1:0493010:         dropTable("t_d_nu");
1:0493010:         dropTable("t_u_r");
1:0493010:         dropTable("t_u_na");
1:4cc0287: 
1:0493010:         dropTable("ref_d_r");
1:0493010:         dropTable("ref_d_c");
1:0493010:         dropTable("ref_d_na");
1:0493010:         dropTable("ref_d_nu");
1:4cc0287: 
1:0493010:         dropTable("ref_u_r");
1:0493010:         dropTable("ref_u_na");
1:4cc0287: 
1:4cc0287:         super.tearDown();
1:4cc0287:     }
1:4cc0287: 
1:9179199:     /**
1:4cc0287:      * Insert row in non-deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      * It doesn't matter what constraint action we have on a FK when inserting,
1:4cc0287:      * it is always in "NO ACTION" mode, i.e. the constraint can be
1:4cc0287:      * deferred. In this example, we use the {t,ref}_d_r table pair, but it
1:4cc0287:      * could have been any of the others.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testInsertDirect() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287:         final String DIRECT_INSERT_SQL =
1:4cc0287:                 "insert into t_d_r values (2, default)";
1:4cc0287: 
1:4cc0287:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:4cc0287:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:4cc0287:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:4cc0287:         // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1028)
1:4cc0287: 
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, DIRECT_INSERT_SQL);
1:d02bb72: 	
1:d02bb72: 	// Test the DERBY-6773 support:
1:d02bb72:         try {
1:d02bb72:             s.execute( DIRECT_INSERT_SQL );
1:d02bb72:             fail();
1:d02bb72:         }
1:d02bb72:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:d02bb72:             assertSQLState(LANG_FK_VIOLATION, dsicve);
1:d02bb72:             assertEquals( "T_D_R", dsicve.getTableName() );
1:d02bb72:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:d02bb72:         }
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DIRECT_INSERT_SQL);
1:4cc0287: 
1:d02bb72:         // Use the slightly wordier form of:
1:d02bb72:         //assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:d02bb72:         // to exercise the DERBY-6773 support:
1:d02bb72:         try {
1:d02bb72:             getConnection().commit();
1:d02bb72:             fail();
1:d02bb72:         }
1:d02bb72:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:d02bb72:             assertSQLState(LANG_DEFERRED_FK_CONSTRAINT_T, dsicve);
1:d02bb72:             assertEquals( "\"APP\".\"T_D_R\"", dsicve.getTableName() );
1:d02bb72:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:d02bb72:         }
1:4cc0287: 
1:4cc0287:         // Now see deferred check succeed by actually adding referenced key
1:4cc0287:         // *after* the insert of the referencing row. Also check that setting
1:4cc0287:         // immediate constraint mode throws a statement level error.
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DIRECT_INSERT_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:4cc0287:         s.executeUpdate("insert into ref_d_r values (2, default)");
1:9179199:         commit();
1:45da2f5: 
1:4cc0287:         // Now see deferred check of we after inserting the referencing row
1:4cc0287:         // delete it again before commit. Also check that setting immediate
1:4cc0287:         // constraint mode throws a statement level error.
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DIRECT_INSERT_SQL.replaceAll("2", "3"));
1:4cc0287: 
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:d02bb72: 	// Test the DERBY-6773 support:
1:d02bb72:         try {
1:d02bb72:             s.execute( "set constraints c_d_r immediate" );
1:d02bb72:             fail();
1:d02bb72:         }
1:d02bb72:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:d02bb72:             assertSQLState(LANG_DEFERRED_FK_CONSTRAINT_S, dsicve);
1:d02bb72:             assertEquals( "\"APP\".\"T_D_R\"", dsicve.getTableName() );
1:d02bb72:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:d02bb72:         }
1:d02bb72: 
1:4cc0287: 
1:4cc0287:         s.executeUpdate("delete from t_d_r where i=3");
1:9179199:         commit();
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Insert row in deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      * It doesn't matter what constraint action we have on a FK when inserting,
1:4cc0287:      * it is always in "NO ACTION" mode, i.e. the constraint can be
1:4cc0287:      * deferred. In this example, we use the {t,ref}_d_r table pair, but it
1:4cc0287:      * could have been any of the others.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testInsertDeferred() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287:         final String DEFERRED_INSERT_SQL =
1:4cc0287:                 "insert into t_d_r select i+1,j from t_d_r";
1:4cc0287: 
1:4cc0287:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:4cc0287:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:4cc0287:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:4cc0287:         // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1205)
1:4cc0287:         // ...InsertResultSet.open(InsertResultSet.java:497)
1:4cc0287: 
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, DEFERRED_INSERT_SQL);
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DEFERRED_INSERT_SQL);
1:4cc0287: 
1:4cc0287:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287: 
1:4cc0287:         // Now see deferred check succeed by actually adding referenced key
1:4cc0287:         // *after* the insert of the referencing row. Also check that setting
1:4cc0287:         // immediate constraint mode throws a statement level error.
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DEFERRED_INSERT_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:4cc0287:         s.executeUpdate("insert into ref_d_r values (2, default)");
1:9179199:         commit();
1:4cc0287: 
1:4cc0287:         // Now see deferred check of we after inserting the referencing row
1:4cc0287:         // delete it again before commit. Also check that setting immediate
1:4cc0287:         // constraint mode throws a statement level error.
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         s.executeUpdate(DEFERRED_INSERT_SQL);
1:4cc0287: 
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_r immediate");
1:4cc0287: 
1:4cc0287:         s.executeUpdate("delete from t_d_r where i=3");
7:4cc0287:         commit();
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Update row in non-deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testUpdateDirect() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287: 
1:4cc0287:         // Child:
1:4cc0287: 
1:4cc0287:         final String RESTRICTED_UPDATE_CHILD_SQL =
1:4cc0287:             "update t_u_r set i=2 where j=2";
1:4cc0287: 
1:4cc0287:         final String NO_ACTION_UPDATE_CHILD_SQL =
1:4cc0287:             "update t_u_na set i=2 where j=2";
1:4cc0287: 
1:4cc0287:         // NO ACTION: This should be deferred in deferred mode
1:4cc0287:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:4cc0287:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:4cc0287:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:4cc0287:         // ...UpdateResultSet.collectAffectedRows(UpdateResultSet.java:614)
1:4cc0287:         // ...UpdateResultSet.open(UpdateResultSet.java:259)
1:4cc0287: 
1:4cc0287:         //   N O   A C T I O N,     R E S T R I C T
1:4cc0287:         // Both are treated as NO ACTION since we are updating the child, not
1:4cc0287:         // the parent here.
1:4cc0287:         String[] constraint = new String[]{"c_u_r", "c_u_na"};
1:4cc0287:         String[] sql = new String[]{RESTRICTED_UPDATE_CHILD_SQL,
1:4cc0287:                                     NO_ACTION_UPDATE_CHILD_SQL};
1:4cc0287: 
1:4cc0287:         for (int i = 0; i < 2; i++) {
1:4cc0287:             assertStatementError(LANG_FK_VIOLATION, s, sql[i]);
1:4cc0287:             final String setDeferred =
1:4cc0287:                     "set constraints " + constraint[i] + " deferred";
1:4cc0287:             final String setImmediate =
1:4cc0287:                     "set constraints " + constraint[i] + " immediate";
1:4cc0287:             s.executeUpdate(setDeferred);
1:4cc0287:             s.executeUpdate(sql[i]);
1:4cc0287:             assertStatementError(
1:4cc0287:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:4cc0287:             assertStatementError(
1:4cc0287:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:4cc0287:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         //   C A S C A D E,    S E T   N U L L
1:4cc0287:         //   Not applicable for update (Derby restriction). But if they had been
1:4cc0287:         //   implemented, the behavior should be as for NO ACTION above.
1:4cc0287: 
1:4cc0287:         // Parent:
1:4cc0287: 
1:4cc0287:         // Always performed deferred update mode, cf. this this explanation in
1:4cc0287:         // TableDescriptor#getAllRelevantConstraints: "For update, if we are
1:4cc0287:         // updating a referenced key, then we have to do it in deferred mode
1:4cc0287:         // (in case we update multiple rows)".
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Update row in deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testUpdateDeferred() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287: 
1:4cc0287:         // Update child
1:4cc0287: 
1:4cc0287:         final String RESTRICTED_UPDATE_CHILD_SQL =
1:4cc0287:             "update t_u_r set i=2 where i=1";
1:4cc0287: 
1:4cc0287:         final String NO_ACTION_UPDATE_CHILD_SQL =
1:4cc0287:             "update t_u_na set i=2 where i=1";
1:4cc0287: 
1:4cc0287:         final String RESTRICTED_UPDATE_PARENT_SQL =
1:4cc0287:             "update ref_u_r set i = 2 where i = 1";
1:4cc0287: 
1:4cc0287:         final String NO_ACTION_UPDATE_PARENT_SQL =
1:4cc0287:             "update ref_u_na set i = 2 where i = 1";
1:4cc0287: 
1:4cc0287:         // RESTRICT and NO ACTION. Since we are updating the child, we
1:4cc0287:         // run implicitly in NO ACTION mode, so can be deferred
1:18a6fb2:         //
1:4cc0287:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:4cc0287:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:4cc0287:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:1005)
1:4cc0287:         // ...UpdateResultSet.open(UpdateResultSet.java:274)
1:4cc0287: 
1:4cc0287:         //   N O   A C T I O N,     R E S T R I C T
1:4cc0287:         // Both are treated as NO ACTION since we are updating the child, not
1:4cc0287:         // the parent here.
1:4cc0287: 
1:4cc0287:         String[] constraint = new String[]{"c_u_r", "c_u_na"};
1:4cc0287:         String[] sql = new String[]{RESTRICTED_UPDATE_CHILD_SQL,
1:4cc0287:                                     NO_ACTION_UPDATE_CHILD_SQL};
1:4cc0287: 
1:4cc0287:         for (int i = 0; i < 2; i++) {
1:4cc0287:             assertStatementError(LANG_FK_VIOLATION, s, sql[i]);
1:4cc0287:             final String setDeferred =
1:4cc0287:                     "set constraints " + constraint[i] + " deferred";
1:4cc0287:             final String setImmediate =
1:4cc0287:                     "set constraints " + constraint[i] + " immediate";
1:4cc0287:             s.executeUpdate(setDeferred);
1:4cc0287:             s.executeUpdate(sql[i]);
1:4cc0287:             assertStatementError(
1:4cc0287:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:4cc0287:             assertStatementError(
1:4cc0287:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:4cc0287:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287:         }
1:4cc0287: 
1:4cc0287: 
1:4cc0287: 
1:4cc0287:         // Parent, RESTRICT Should *never* be deferred.
1:4cc0287:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:4cc0287:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:4cc0287:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:961)
1:4cc0287:         // ...UpdateResultSet.open(UpdateResultSet.java:269)
1:18a6fb2:         assertStatementError(LANG_FK_VIOLATION, s,
1:4cc0287:                              RESTRICTED_UPDATE_PARENT_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is RESTRICT, deferred constraint doesn't help:
1:4cc0287:         s.executeUpdate("set constraints c_u_r deferred");
2:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s,
1:4cc0287:                              RESTRICTED_UPDATE_PARENT_SQL);
1:4cc0287: 
1:4cc0287: 
1:4cc0287:         // Parent, NO ACTION (different code path, cf. line 269 vs 274).
1:4cc0287:         // Should be deferred if constraint mode is deferred.
1:18a6fb2:         //
1:4cc0287:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:4cc0287:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:4cc0287:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:961)
1:4cc0287:         // ...UpdateResultSet.open(UpdateResultSet.java:274) <-- Note:difference
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_UPDATE_PARENT_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is NO ACTION, deferral should work
1:4cc0287:         s.executeUpdate("set constraints c_u_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_UPDATE_PARENT_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_u_na immediate");
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_u_na immediate");
1:4cc0287:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287: 
1:4cc0287:         // Resolve by resetting the value in the referenced row
1:4cc0287:         s.executeUpdate("set constraints c_u_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_UPDATE_PARENT_SQL);
1:4cc0287:         s.executeUpdate("update ref_u_na set i=1 where i=2");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         // Resolve by resetting the referencing row
1:4cc0287:         s.executeUpdate("set constraints c_u_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_UPDATE_CHILD_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_u_na immediate");
1:4cc0287:         s.executeUpdate("update t_u_na set i=1 where i=2");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Delete row in non-deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testDeleteDirect() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287: 
1:9179199:         // Delete of child row is trivial, parent not affected.
1:4cc0287: 
1:4cc0287:         // Parent
1:4cc0287: 
1:4cc0287:         final String RESTRICTED_DELETE_SQL = "delete from ref_d_r where i = 1";
1:4cc0287:         final String NO_ACTION_DELETE_SQL = "delete from ref_d_na where i = 1";
1:4cc0287:         final String CASCADE_DELETE_SQL = "delete from ref_d_c where i = 1";
1:4cc0287:         final String SET_NULL_DELETE_SQL = "delete from ref_d_nu where i = 1";
1:4cc0287: 
1:4cc0287:         // RESTRICT and NO ACTION: As far as triggers, there is no difference
1:4cc0287:         // when the execution of checking happens here, since in the presence
1:4cc0287:         // of triggers, row processing is deferred. But for deferred constraints
1:4cc0287:         // we need to treat these two differently: The RESTRICT code path
1:4cc0287:         // should check even in the presence of deferred FK constraints,
1:4cc0287:         // the NO ACTION code path should wait.
1:18a6fb2:         //
1:4cc0287:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:4cc0287:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:4cc0287:         // ...DeleteResultSet.collectAffectedRows(DeleteResultSet.java:392)
1:4cc0287:         // ...DeleteResultSet.open(DeleteResultSet.java:136)
1:4cc0287: 
1:4cc0287:         //   R E S T R I C T
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is RESTRICT, deferred constraint doesn't help.
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         //   N O   A C T I O N
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is NO ACTION, deferral should work
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287: 
1:4cc0287:         // Resolve by removing the referencing row
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         s.executeUpdate("delete from t_d_na where i=1");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         // Resolve by re-inserting the referenced row
1:4cc0287:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_d_na values (1, default)");
1:4cc0287:         commit();
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         //   C A S C A D E : not impacted by deferred
1:4cc0287:         s.executeUpdate(CASCADE_DELETE_SQL);
1:4cc0287:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:4cc0287:         rollback();
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_c deferred");
1:4cc0287:         s.executeUpdate(CASCADE_DELETE_SQL);
1:4cc0287:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         //   S E T   N U L L : not impacted by deferred
1:4cc0287:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:4cc0287:         assertResults(
1:4cc0287:                 s.executeQuery("select i from t_d_nu"),
1:4cc0287:                 new String[][]{{null}},
1:4cc0287:                 false);
1:4cc0287:         rollback();
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_nu deferred");
1:4cc0287:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:4cc0287:         assertResults(
1:4cc0287:                 s.executeQuery("select i from t_d_nu"),
1:4cc0287:                 new String[][]{{null}},
1:4cc0287:                 false);
1:4cc0287:         commit();
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Delete row in deferred code path. Note that this use of "deferred"
1:4cc0287:      * refers to the insert processing, not the deferrable constraint.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:         public void testDeleteDeferred() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:9179199:         // Delete of child row is trivial, parent not affected.
1:4cc0287: 
1:4cc0287:         // Parent
1:4cc0287: 
1:4cc0287:         final String RESTRICTED_DELETE_SQL =
1:4cc0287:                 "delete from ref_d_r where i = 1 and " +
1:4cc0287:                 "    i in (select i from ref_d_r)";
1:4cc0287: 
1:4cc0287:         final String NO_ACTION_DELETE_SQL =
1:4cc0287:                 "delete from ref_d_na where i = 1 and " +
1:4cc0287:                 "    i in (select i from ref_d_na)";
1:4cc0287: 
1:4cc0287:         final String CASCADE_DELETE_SQL =
1:4cc0287:                 "delete from ref_d_c where i = 1 and " +
1:4cc0287:                 "    i in (select i from ref_d_c)";
1:4cc0287: 
1:4cc0287:         final String SET_NULL_DELETE_SQL =
1:4cc0287:                 "delete from ref_d_nu where i = 1 and " +
1:4cc0287:                 "    i in (select i from ref_d_nu)";
1:4cc0287: 
1:4cc0287: 
1:4cc0287:         // RESTRICT - This checking should *never* be deferred
1:4cc0287:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:4cc0287:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:4cc0287:         // ...DeleteResultSet.runFkChecker(DeleteResultSet.java:559)
1:4cc0287:         // ...DeleteResultSet.open(DeleteResultSet.java:151)
1:4cc0287: 
1:4cc0287:         //   R E S T R I C T
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is RESTRICT, deferred constraint doesn't help.
1:4cc0287:         s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         // NO ACTION - This checking should be deferred in deferred mode
1:4cc0287:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:4cc0287:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:4cc0287:         // ...DeleteResultSet.runFkChecker(DeleteResultSet.java:559)
1:4cc0287:         // ...DeleteResultSet.open(DeleteResultSet.java:154) <-- Note:difference
1:4cc0287: 
1:4cc0287:         //   N O   A C T I O N
1:4cc0287:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_DELETE_SQL);
1:4cc0287: 
1:4cc0287:         // Since the action is NO ACTION, deferral should work
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287: 
1:4cc0287:         // Resolve by removing the referencing row
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         s.executeUpdate("delete from t_d_na where i=1");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         // Resolve by re-inserting the referenced row
1:4cc0287:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:4cc0287:         s.executeUpdate("insert into t_d_na values (1, default)");
1:4cc0287:         commit();
1:4cc0287:         s.executeUpdate("set constraints c_d_na deferred");
1:4cc0287:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:4cc0287:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:4cc0287:                              "set constraints c_d_na immediate");
1:4cc0287:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         //   C A S C A D E : not impacted by deferred
1:4cc0287:         s.executeUpdate(CASCADE_DELETE_SQL);
1:4cc0287:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:4cc0287:         rollback();
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_c deferred");
1:4cc0287:         s.executeUpdate(CASCADE_DELETE_SQL);
1:4cc0287:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:4cc0287:         commit();
1:4cc0287: 
1:4cc0287:         //   S E T   N U L L : not impacted by deferred
1:4cc0287:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:4cc0287:         assertResults(
1:4cc0287:                 s.executeQuery("select i from t_d_nu"),
1:4cc0287:                 new String[][]{{null}},
1:4cc0287:                 false);
1:4cc0287:         rollback();
1:4cc0287: 
1:4cc0287:         s.executeUpdate("set constraints c_d_nu deferred");
1:4cc0287:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:4cc0287:         assertResults(
1:4cc0287:                 s.executeQuery("select i from t_d_nu"),
1:4cc0287:                 new String[][]{{null}},
1:4cc0287:                 false);
1:4cc0287:         commit();
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:9179199:      * Insert using bulk insert code path, i.e. IMPORT. Since IMPORT
1:4cc0287:      * always performs a commit at the end, we strictly do no need to do
1:4cc0287:      * extra processing for deferrable constraints, but we do so
1:4cc0287:      * anyway to prepare for possible future lifting of this restriction to
1:9179199:      * IMPORT. This behavior can not be observed externally, but we include
1:4cc0287:      * the test here anyway as a baseline.
1:4cc0287:      *
1:4cc0287:      * @throws SQLException
1:4cc0287:      */
1:4cc0287:     public void testBulkInsert() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287: 
1:4cc0287:         // Try the test cases below with both "replace" and "append"
1:4cc0287:         // semantics. It doesn't matter what constraint action
1:4cc0287:         // we have on a FK when inserting, it is always in "NO ACTION" mode,
1:4cc0287:         // i.e. the constraint can be deferred. In this example, we
1:4cc0287:         // use the {t,ref}_d_r table pair, but it could have been any of the
1:4cc0287:         // others.
1:4cc0287:         for (int addOrReplace = 0; addOrReplace < 2; addOrReplace++) {
1:4cc0287:             // import and implicit commit leads to checking
1:4cc0287: 
1:4cc0287:             // ADD:
1:4cc0287:             // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:4cc0287:             // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:4cc0287:             // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:4cc0287:             // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1028)
1:4cc0287:             // ...InsertResultSet.open(InsertResultSet.java:497)
1:4cc0287: 
1:4cc0287:             // REPLACE:
1:4cc0287:             // ...InsertResultSet.bulkValidateForeignKeysCore(
1:4cc0287:             //         InsertResultSet.java:1726)
1:4cc0287:             // ...InsertResultSet.bulkValidateForeignKeys(
1:4cc0287:             //         InsertResultSet.java:1594)
1:4cc0287:             // ...InsertResultSet.open(InsertResultSet.java:490)
1:4cc0287: 
1:4cc0287:             assertStatementError(
1:4cc0287:                 LANG_FK_VIOLATION,
1:18a6fb2:                 s,
1:4cc0287:                 "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (" +
1:4cc0287:                 "    'APP' , 'T_D_R' , '" + expImpDataFile + "'," +
1:4cc0287:                 "    null, null , null, " + addOrReplace + ")");
1:4cc0287: 
1:4cc0287:             s.executeUpdate("set constraints c_d_r deferred");
1:4cc0287:             assertStatementError(
1:4cc0287:                 LANG_DEFERRED_FK_CONSTRAINT_T,
2:4cc0287:                 s,
1:4cc0287:                 "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (" +
1:4cc0287:                 "    'APP' , 'T_D_R' , '" + expImpDataFile + "'," +
1:4cc0287:                 "    null, null , null, " + addOrReplace + ")");
1:4cc0287:         }
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     public void testAddConstraint() throws SQLException {
1:4cc0287:         Statement s = createStatement();
1:4cc0287:         s.executeUpdate("create table t2(i int)");
1:4cc0287: 
1:18a6fb2:         try {
1:4cc0287:             s.executeUpdate("insert into t2 values 1,2");
1:18a6fb2:             commit();
1:4cc0287: 
1:4cc0287:             // First, try with immediate checking
1:4cc0287:             assertStatementError(LANG_ADD_FK_CONSTRAINT_VIOLATION, s,
1:4cc0287:                     "alter table t2 add constraint " +
1:4cc0287:                     "    c2 foreign key(i) references ref_d_r(i)");
1:4cc0287:             s.executeUpdate("delete from t2 where i=2");
1:4cc0287: 
1:4cc0287:             // Delete the row with 2 should make it OK to add the constraint:
1:4cc0287:             s.executeUpdate("alter table t2 add constraint " +
1:4cc0287:                     "c2 foreign key(i) references ref_d_r(i)");
1:4cc0287: 
1:4cc0287:             rollback();
1:4cc0287:             s.executeUpdate("delete from t2");
1:4cc0287: 
1:4cc0287:             // Now try with deferred constraint
1:4cc0287:             s.executeUpdate("insert into t2 values 1,2");
1:18a6fb2:             commit();
1:4cc0287: 
1:4cc0287:             s.executeUpdate("alter table t2 add constraint " +
1:4cc0287:                     "    c2 foreign key(i) references ref_d_r(i) " +
1:4cc0287:                     "    initially deferred");
1:4cc0287: 
1:4cc0287:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:4cc0287: 
1:4cc0287: 
1:4cc0287:         } finally {
1:0493010:             dropTable("t2");
1:9179199:             commit();
1:4cc0287:         }
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:9179199:      * The referenced constraint (in the referenced table) is a deferred unique
1:9179199:      * or primary key constraint. This test concerns what happens if this is
1:9179199:      * deferred, i.e. duplicate keys are allowed temporarily, and one or more
1:18a6fb2:      * of them is deleted or updated.  The foreign key constraint itself could
1:18a6fb2:      * be deferred or not. If this is also deferred, we'd have no issue,
1:18a6fb2:      * cf. the explanation in DERBY-6559, as all checking happens later,
1:18a6fb2:      * typically at commit.  But if it is <em>not</em> deferred, we needed to
1:18a6fb2:      * adjust FK checking at delete/update time to <b>not</b> throw foreign key
1:18a6fb2:      * violation exception if a duplicate exists; otherwise we'd throw a
1:18a6fb2:      * foreign key violation where none exists. The remaining row(s) will
1:18a6fb2:      * fulfill the requirement. We will only check if the last such row is
1:18a6fb2:      * deleted or its key modified.
1:18a6fb2:      *
1:18a6fb2:      * Complicating this processing is that the delete result set has two code
1:18a6fb2:      * paths, with with deferred row processing, and one with direct row
1:18a6fb2:      * processing.  Update result sets are again handled differently, but these
1:18a6fb2:      * are only ever deferred row processing in the presence of a FK on the
1:18a6fb2:      * row. The test cases below try to exhaust these code paths.  See {@link
1:18a6fb2:      * org.apache.derby.impl.sql.execute.ReferencedKeyRIChecker#doCheck} and
1:18a6fb2:      * {@link
1:18a6fb2:      * org.apache.derby.impl.sql.execute.ReferencedKeyRIChecker#postCheck}.
1:9179199:      *
1:9179199:      * @throws SQLException
1:9179199:      */
1:9179199:     public void testFKPlusUnique() throws SQLException {
1:9179199:         Statement s = createStatement(
1:18a6fb2:             ResultSet.TYPE_FORWARD_ONLY,
1:18a6fb2:             ResultSet.CONCUR_UPDATABLE);
1:18a6fb2: 
1:18a6fb2:         ResultSet rs = null;
1:9179199: 
1:18a6fb2:         try {
1:45da2f5:             // RESTRICT and NO ACTION will throw in different
1:45da2f5:             // code paths, but in practice, in Derby presently, the
1:45da2f5:             // behavior is the same since we do not support SQL in before
1:45da2f5:             // triggers, so test both with the same fixtures.
1:45da2f5:             // CASCADE is tested separately later.
1:45da2f5:             final String[] refActions = {
1:45da2f5:                 "ON DELETE NO ACTION ON UPDATE NO ACTION",
1:45da2f5:                 "ON DELETE RESTRICT ON UPDATE RESTRICT" };
1:9179199: 
1:45da2f5:             /*   N O   A C T I O N,   R E S T R I C T   (d i r e c t) */
1:4cc0287: 
1:45da2f5:             for (String refAct: refActions) {
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table ref_t(i int, j int, constraint ct " +
1:45da2f5:                     "    primary key(i) deferrable initially deferred)");
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table t(i int unique not null, c char(1)," +
1:45da2f5:                     "    constraint c foreign key (i) references ref_t(i) " +
1:45da2f5:                     refAct + ")");
1:9179199: 
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,2),(1,3),(1,4)");
1:45da2f5:                 s.executeUpdate("insert into t values (1, 'c')");
1:9179199: 
1:45da2f5:                 // Now, the child (referencing table) is referencing one of the
1:45da2f5:                 // the rows in the primary table whose value is 1, so the
1:45da2f5:                 // reference is ok.
1:9179199: 
1:45da2f5:                 // What happens when we delete one copy before commit?  Even
1:45da2f5:                 // though we have ON DELETE restrict action, there is another
1:45da2f5:                 // row that would satisfy the constraint.
1:45da2f5:                 rs = s.executeQuery("select * from ref_t");
1:45da2f5:                 rs.next();
4:9179199:                 rs.deleteRow();
1:45da2f5:                 rs.next();
1:45da2f5:                 rs.deleteRow();
1:45da2f5:                 // Now there should be only one left, so the referenced table
1:45da2f5:                 // is OK.
1:45da2f5:                 commit();
1:9179199: 
1:45da2f5:                 // Try again, but this time with normal delete, not using
1:45da2f5:                 // cursors
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,5),(1,6)");
1:45da2f5:                 s.executeUpdate("delete from ref_t where j > 4 ");
1:45da2f5:                 commit();
1:9179199: 
1:45da2f5:                 // Try again, but this time delete both duplicate rows. The
1:45da2f5:                 // second delete should fail.
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,3)");
1:45da2f5:                 rs = s.executeQuery("select * from ref_t");
1:45da2f5:                 rs.next();
1:45da2f5:                 rs.deleteRow();
1:45da2f5:                 rs.next();
1:9179199: 
1:45da2f5:                 try {
1:45da2f5:                     rs.deleteRow();
1:45da2f5:                     fail();
1:45da2f5:                 } catch (SQLException e) {
1:45da2f5:                     assertSQLState(LANG_FK_VIOLATION, e);
1:45da2f5:                 }
1:18a6fb2: 
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,4), (1,5)");
1:18a6fb2: 
1:45da2f5:                 // direct delete code path
1:45da2f5:                 assertStatementError(LANG_FK_VIOLATION, s, "delete from ref_t");
1:45da2f5: 
1:45da2f5:                 // deferred delete code path: not ok
1:45da2f5:                 assertStatementError(LANG_FK_VIOLATION, s,
1:45da2f5:                                      "delete from ref_t where i = 1 and " +
1:45da2f5:                                      "    i in (select i from ref_t)");
1:45da2f5: 
1:45da2f5:                 // deferred code path: OK
1:45da2f5:                 s.executeUpdate("delete from ref_t where i = 1 and " +
1:45da2f5:                                 "    i in (select i from ref_t) and j >= 4");
1:45da2f5: 
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,4), (1,5)");
1:45da2f5:                 s.executeUpdate("delete from ref_t where j >= 4");
1:45da2f5:                 JDBC.assertFullResultSet(
1:9179199:                     s.executeQuery("select * from ref_t"),
1:9179199:                     new String[][]{{"1", "3"}});
1:18a6fb2: 
1:45da2f5:                 commit();
1:18a6fb2: 
1:45da2f5:                 //
1:45da2f5:                 // Try similar with update rather than delete. In this
1:45da2f5:                 // case there is only ever a deferred code path, so separate
1:45da2f5:                 // teste cases as for delete (above) are not relevant.
1:45da2f5:                 //
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,4)");
1:45da2f5:                 s.executeUpdate("update ref_t set i = 2 where j = 4");
1:45da2f5:                 s.executeUpdate("insert into ref_t values (1,4)");
1:45da2f5:                 assertStatementError(LANG_FK_VIOLATION,
1:45da2f5:                                      s,
1:45da2f5:                                      "update ref_t set i = 2");
1:18a6fb2: 
1:45da2f5:                 rs = s.executeQuery("select * from ref_t");
1:45da2f5:                 rs.next();
1:45da2f5:                 rs.updateInt(1, 3);
1:45da2f5:                 rs.updateRow();
1:45da2f5:                 rs.close();
1:45da2f5:                 commit();
1:18a6fb2: 
1:45da2f5:                 dropTable("t");
1:45da2f5:                 dropTable("ref_t");
1:45da2f5:                 commit();
1:45da2f5:             }
1:18a6fb2: 
1:45da2f5:             /*   N O   A C T I O N,   R E S T R I C T   (d e f e r r e d) */
1:18a6fb2: 
1:45da2f5:             for (String refAct : refActions) {
1:45da2f5:                 // Delete (deferred processing code path) with more complex FKs
1:45da2f5:                 // and more dups with different keys, so we can execise the
1:45da2f5:                 // postCheck mechanism in ReferencedKeyRIChecker including
1:45da2f5:                 // row/key mappings
1:18a6fb2: 
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table ref_t(c char(1), i int, j int, k int," +
1:45da2f5:                     "    constraint c primary key (k, i) initially deferred)");
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                     "    constraint c2 foreign key(i,k) " +
1:45da2f5:                     "    references ref_t(k, i)" + refAct + ")");
1:18a6fb2: 
1:45da2f5:                 // key (1, 100) has 3 dups, key (3,100) has two dups
1:45da2f5:                 s.executeUpdate("insert into ref_t values " +
1:45da2f5:                                 "('a', 100, -1, 1)," +
1:45da2f5:                                 "('a', 100, -2, 1)," +
1:45da2f5:                                 "('a', 100, -3, 1)," +
1:45da2f5:                                 "('a', 100, -1, 2)," +
1:45da2f5:                                 "('a', 100, -2, 3)," +
1:45da2f5:                                 "('a', 100, -3, 3)");
1:45da2f5: 
1:45da2f5:                 s.executeUpdate("insert into t values " +
1:45da2f5:                                 "(-11, 1, -4, 100)," +
1:45da2f5:                                 "(-12, 2, -5, 100)," +
1:45da2f5:                                 "(-13, 3, -6, 100)");
1:45da2f5: 
1:45da2f5:                 // This should throw using the postCheck mechanism.
1:45da2f5:                 try {
1:45da2f5:                     s.executeUpdate(
1:45da2f5:                         "delete from ref_t where j < -1 and " +
1:45da2f5:                         "    k in (select k from ref_t)");
1:45da2f5:                     fail();
1:45da2f5:                 } catch (SQLException e) {
1:45da2f5:                     assertSQLState(LANG_FK_VIOLATION, e);
1:45da2f5:                     String expected =
1:45da2f5:                         "DELETE on table 'REF_T' caused a violation" +
1:45da2f5:                         " of foreign key constraint 'C2' for key (3,100).  " +
1:45da2f5:                         "The statement has been rolled back.";
1:45da2f5:                     assertEquals(expected, e.getMessage());
1:45da2f5:                 }
1:45da2f5: 
1:45da2f5:                 // These should be ok (using the postCheck mechanism), since
1:45da2f5:                 // they both leave one row in ref_t to satisfy the constraint.
1:45da2f5:                 s.executeUpdate(
1:18a6fb2:                     "delete from ref_t where j < -1 and " +
1:45da2f5:                     "    k in (select k from ref_t where k < 3)");
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "delete from ref_t where j < -2 and " +
1:45da2f5:                     "    k in (select k from ref_t where k >= 3)");
1:45da2f5: 
1:45da2f5:                 commit();
1:45da2f5: 
1:45da2f5:                 //
1:45da2f5:                 // Do the same exercise but now with update instead of delete
1:45da2f5:                 //
1:45da2f5:                 dropTable("t");
1:45da2f5:                 dropTable("ref_t");
1:45da2f5:                 commit();
1:45da2f5: 
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table ref_t(c char(1), i int, j int, k int," +
1:45da2f5:                     "    constraint c primary key (k, i) initially deferred)");
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                     "    constraint c2 foreign key(i,k) " +
1:45da2f5:                     "    references ref_t(k, i)" + refAct + ")");
1:45da2f5: 
1:45da2f5:                 // key (1, 100) has 3 dups, key (3,100) has two dups
1:45da2f5:                 s.executeUpdate("insert into ref_t values " +
1:45da2f5:                                 "('a', 100, -1, 1)," +
1:45da2f5:                                 "('a', 100, -2, 1)," +
1:45da2f5:                                 "('a', 100, -3, 1)," +
1:45da2f5:                                 "('a', 100, -1, 2)," +
1:45da2f5:                                 "('a', 100, -2, 3)," +
1:45da2f5:                                 "('a', 100, -3, 3)");
1:45da2f5: 
1:45da2f5:                 s.executeUpdate("insert into t values " +
1:45da2f5:                                 "(-11, 1, -4, 100)," +
1:45da2f5:                                 "(-12, 2, -5, 100)," +
1:45da2f5:                                 "(-13, 3, -6, 100)");
1:45da2f5: 
1:45da2f5:                 // This should throw using the postCheck mechanism.
1:45da2f5:                 try {
1:18a6fb2:                     s.executeUpdate(
1:45da2f5:                         "update ref_t set k=k*100 where j < -1 and " +
1:45da2f5:                         "    k in (select k from ref_t)");
1:45da2f5:                     fail();
1:45da2f5:                 } catch (SQLException e) {
1:45da2f5:                     assertSQLState(LANG_FK_VIOLATION, e);
1:45da2f5:                     String expected =
1:45da2f5:                         "UPDATE on table 'REF_T' caused a violation" +
1:45da2f5:                         " of foreign key constraint 'C2' for key (3,100).  " +
1:45da2f5:                         "The statement has been rolled back.";
1:45da2f5:                     assertEquals(expected, e.getMessage());
1:45da2f5:                 }
1:45da2f5: 
1:45da2f5:                 // These should be ok (using the postCheck mechanism), since
1:45da2f5:                 // they both leave one row in ref_t to satisfy the constraint.
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "update ref_t set k=k*100 where j < -1 and " +
1:45da2f5:                     "    k in (select k from ref_t where k < 3)");
1:45da2f5:                 s.executeUpdate(
1:45da2f5:                     "update ref_t set k=k*100 where j < -2 and " +
1:45da2f5:                     "    k in (select k from ref_t where k >= 3)");
1:45da2f5: 
1:45da2f5:                 dropTable("t");
1:45da2f5:                 dropTable("ref_t");
1:45da2f5:                 commit();
1:18a6fb2:             }
1:18a6fb2: 
1:45da2f5:             /*  C A S C A D E  */
1:45da2f5: 
1:45da2f5:             // CASCADE delete with deferred row code path (not deferred
1:45da2f5:             // constraint) should still
1:45da2f5:             // not fail. Test since we messed with code path.
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table ref_t(c char(1), i int, j int, k int," +
1:45da2f5:                 "    constraint c primary key (k, i))");
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:45da2f5:                 "    on delete cascade)");
1:45da2f5: 
1:45da2f5:             s.executeUpdate("insert into ref_t values " +
1:45da2f5:                             "('a', 100, -3, 3)");
1:45da2f5:             s.executeUpdate("insert into t values " +
1:45da2f5:                             "(-11, 3, -4, 100)");
1:18a6fb2:             s.executeUpdate(
1:18a6fb2:                 "delete from ref_t where j < -1 and " +
1:45da2f5:                 "    k in (select k from ref_t)");
1:18a6fb2: 
1:45da2f5:             JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
1:45da2f5:             JDBC.assertEmpty(s.executeQuery("select * from t"));
1:18a6fb2: 
1:18a6fb2:             dropTable("t");
1:18a6fb2:             dropTable("ref_t");
1:18a6fb2:             commit();
1:18a6fb2: 
1:45da2f5:             // Deferred PK constraint, this time with delete with CASCADE,
1:45da2f5:             // should not fail
1:18a6fb2:             s.executeUpdate(
2:18a6fb2:                 "create table ref_t(c char(1), i int, j int, k int," +
2:18a6fb2:                 "    constraint c primary key (k, i) initially deferred)");
1:45da2f5: 
1:45da2f5:             // Not yet implemented
1:45da2f5:             assertStatementError("X0Y47", s,
2:18a6fb2:                 "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:45da2f5:                 "    on delete cascade)");
1:18a6fb2: 
1:45da2f5:             dropTable("t");
1:45da2f5:             dropTable("ref_t");
1:18a6fb2: 
1:18a6fb2:             commit();
1:18a6fb2: 
1:45da2f5:             /*  S E T   N U L L  */
1:45da2f5: 
1:45da2f5:             // SET NULL  delete with deferred row code path should still
1:45da2f5:             // not fail. Test since we messed with code path.
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table ref_t(c char(1), i int, j int, k int," +
1:45da2f5:                 "    constraint c primary key (k, i))");
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:45da2f5:                 "    on delete set null)");
1:45da2f5: 
1:45da2f5:             s.executeUpdate("insert into ref_t values " +
1:45da2f5:                             "('a', 100, -3, 3)");
1:45da2f5:             s.executeUpdate("insert into t values " +
1:45da2f5:                             "(-11, 3, -4, 100)");
1:45da2f5:             s.executeUpdate("delete from ref_t");
1:45da2f5: 
1:45da2f5:             JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
1:45da2f5:             JDBC.assertFullResultSet(s.executeQuery("select * from t"),
1:45da2f5:                     new String[][]{{"-11", null, "-4", null}});
1:45da2f5: 
1:45da2f5:             dropTable("t");
1:45da2f5:             dropTable("ref_t");
1:45da2f5:             commit();
1:45da2f5: 
1:45da2f5:             // Deferred constraint PK, delete with SET NULL should not
1:45da2f5:             // fail
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table ref_t(c char(1), i int, j int, k int," +
1:45da2f5:                 "    constraint c primary key (k, i) initially deferred)");
1:45da2f5: 
1:45da2f5:             // Not yet implemented
1:45da2f5:             assertStatementError("X0Y47", s,
1:45da2f5:                "create table t(l bigint, i int, j int, k int," +
1:45da2f5:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:45da2f5:                 "    on delete set null)");
1:45da2f5: 
1:45da2f5:             commit();
1:9179199:         } finally {
1:18a6fb2:             if (rs != null) {
2:18a6fb2:                 rs.close();
1:18a6fb2:             }
1:18a6fb2:             dropTable("t");
1:18a6fb2:             dropTable("ref_t");
1:18a6fb2:             commit();
1:18a6fb2:         }
1:9179199:     }
1:18a6fb2: 
1:45da2f5:     public void testSelfReferential() throws SQLException {
1:45da2f5:         Statement s = createStatement();
1:45da2f5:         try {
1:45da2f5: 
1:45da2f5:             s.executeUpdate(
1:45da2f5:                 "create table t(name varchar(10) primary key " +
1:45da2f5:                 "                   deferrable initially deferred," +
1:45da2f5:                 "               boss varchar(10) references t(name) " +
1:45da2f5:                 "                   on delete restrict, i int)");
1:45da2f5: 
1:45da2f5:             s.executeUpdate("insert into t values ('daisy', null, 1)");
1:45da2f5:             s.executeUpdate("insert into t values ('daisy', null, 2)");
1:45da2f5:             s.executeUpdate("insert into t values ('donald', 'daisy', 3)");
1:45da2f5: 
1:45da2f5:             s.executeUpdate("delete from t where name like 'daisy%' and i = 1");
1:45da2f5:             JDBC.assertFullResultSet(s.executeQuery("select * from t"),
1:45da2f5:                     new String[][]{
1:45da2f5:                         {"daisy", null, "2"},
1:45da2f5:                         {"donald", "daisy", "3"}});
1:45da2f5:             commit();
1:45da2f5: 
1:45da2f5:             s.executeUpdate(
1:45da2f5:                     "create table employees(name char(40), " +
1:45da2f5:                     "    constraint ec primary key(name) initially deferred, " +
1:45da2f5:                     "    address char(40))");
1:45da2f5: 
1:45da2f5:             // Not yet implemented.
1:45da2f5:             assertStatementError("X0Y47", s,
1:45da2f5:                 "create table teammember(" +
1:45da2f5:                 "name char(40) primary key " +
1:45da2f5:                         "references employees(name) on delete cascade, " +
1:45da2f5:                 "boss char(40) " +
1:45da2f5:                         "references teammember(name) on delete cascade)");
1:45da2f5: 
1:45da2f5: 
1:45da2f5:         } finally {
1:45da2f5:             dropTable("t");
1:45da2f5:             dropTable("employees");
1:45da2f5:             dropTable("teammember");
1:45da2f5:             commit();
1:45da2f5:         }
1:45da2f5:     }
1:18a6fb2: 
1:f65be8f:     public void testInsertTrigger() throws SQLException {
1:f65be8f:         setAutoCommit(false);
1:f65be8f:         Statement s = createStatement();
1:f65be8f:         s.execute("create table d6664_t1(pk int primary key)");
1:f65be8f:         s.execute("create table d6664_t2(x int references d6664_t1 "
1:f65be8f:                 + "initially deferred)");
1:f65be8f:         s.execute("create table d6664_t3(y int)");
1:f65be8f:         s.execute("create trigger d6664_tr after insert on d6664_t3 "
1:f65be8f:                 + "referencing new as new for each row "
1:f65be8f:                 + "insert into d6664_t2 values new.y");
1:9179199: 
1:f65be8f:         // Used to fail with "Schema 'null' does not exist" before DERBY-6664.
1:f65be8f:         s.execute("insert into d6664_t3 values 1");
1:9179199: 
1:f65be8f:         // Verify that the trigger fired.
1:f65be8f:         JDBC.assertSingleValueResultSet(
1:f65be8f:                 s.executeQuery("select * from d6664_t2"), "1");
1:9179199: 
1:f65be8f:         // Trigger caused violation in deferred foreign key. Should be
1:f65be8f:         // detected on commit.
1:4cc0287:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:9179199:     }
1:9179199: 
1:64b6308:     /**
1:64b6308:      * Test that truncate table is not allowed on a referenced table.
1:64b6308:      * See DERBY-6668.
1:64b6308:      */
1:64b6308:     public  void    test_6668() throws Exception
1:64b6308:     {
1:64b6308:         Connection  conn = getConnection();
1:4cc0287: 
1:64b6308:         goodStatement
1:64b6308:             (
1:64b6308:              conn,
1:64b6308:              "create table tunique_6668\n" +
1:64b6308:              "(\n" +
1:64b6308:              "  a int not null unique\n" +
1:64b6308:              ")\n"
1:64b6308:              );
1:64b6308:         goodStatement
1:64b6308:             (
1:64b6308:              conn,
1:64b6308:              "create table tref_6668\n" +
1:64b6308:              "(\n" +
1:64b6308:              "  a int references tunique_6668( a ) initially deferred\n" +
1:64b6308:              ")\n"
1:64b6308:              );
3:64b6308: 
1:64b6308:         assertStatementError
1:64b6308:             (
1:64b6308:              "XCL48",
1:64b6308:              conn.prepareStatement( "truncate table tunique_6668" )
1:64b6308:              );
1:9179199:     }
1:64b6308:     
1:2db96c5:     /**
1:2db96c5:      * Regression test case for DERBY-6665. The prevention of shared physical
1:2db96c5:      * conglomerates in the presence of the deferrable constraint
1:2db96c5:      * characteristic failed for foreign keys sometimes.  This sometimes made
1:2db96c5:      * the deferred check of constraints miss violations if two deferred
1:2db96c5:      * constraints erroneously shared a physical conglomerate.
1:2db96c5:      */
1:2db96c5:     public void testSharedConglomerates() throws SQLException {
1:2db96c5:         setAutoCommit(false);
1:2db96c5:         Statement s = createStatement();
1:2db96c5:         s.execute("create table d6665_t1(x int primary key)");
1:2db96c5:         s.execute("create table d6665_t2(x int primary key)");
1:2db96c5: 
1:2db96c5:         // Create a table with two foreign keys - they would share one
1:2db96c5:         // conglomerate since they are declared on the same column and the hole
1:2db96c5:         // in the sharing avoidance logic.
1:2db96c5:         s.execute("create table d6665_t3(x int "
1:2db96c5:                 + "references d6665_t1 initially deferred "
1:2db96c5:                 + "references d6665_t2 initially deferred)");
1:2db96c5: 
1:2db96c5:         s.execute("insert into d6665_t1 values 1");
1:2db96c5: 
1:2db96c5:         // This violates the second foreign key, since T2 doesn't contain 1.
1:2db96c5:         // No error here since the constraint is deferred.
1:2db96c5:         s.execute("insert into d6665_t3 values 1");
1:2db96c5: 
1:2db96c5:         // Now we're no longer violating the foreign key.
1:2db96c5:         s.execute("insert into d6665_t2 values 1");
1:2db96c5: 
1:2db96c5:         // Introduce a violation of the first foreign key. No error because
1:2db96c5:         // the checking is deferred.
1:2db96c5:         s.execute("delete from d6665_t1");
1:2db96c5: 
1:2db96c5:         // Commit. Should fail because of the violation introduced by the
1:2db96c5:         // delete statement above. Was not detected before DERBY-6665.
1:2db96c5:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:2db96c5: 
1:2db96c5:         // Another example: A PRIMARY KEY constraint and a FOREIGN KEY
1:2db96c5:         // constraint erroneously share a conglomerate.
1:2db96c5: 
1:2db96c5:         s.execute("create table d6665_t4(x int primary key)");
1:2db96c5:         s.execute("create table d6665_t5(x int "
1:2db96c5:                 + "primary key initially deferred "
1:2db96c5:                 + "references d6665_t4 initially deferred)");
1:2db96c5: 
1:2db96c5:         // First violate the foreign key. No error, since it is deferred.
1:2db96c5:         s.execute("insert into d6665_t5 values 1");
1:2db96c5: 
1:2db96c5:         // No longer in violation of the foreign key after this statement.
1:2db96c5:         s.execute("insert into d6665_t4 values 1");
1:2db96c5: 
1:2db96c5:         // Violate the PRIMARY KEY constraint on T5.X.
1:2db96c5:         s.execute("insert into d6665_t5 values 1");
1:2db96c5: 
1:2db96c5:         // Commit. Should fail because the PRIMARY KEY constraint of T5
1:2db96c5:         // is violated. Was not detected before DERBY-6665.
1:d02bb72: 	// Test the DERBY-6773 support, too.
1:d02bb72:         try {
1:d02bb72:             getConnection().commit();
1:d02bb72:             fail();
1:d02bb72:         }
1:d02bb72:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:d02bb72:             assertSQLState(LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T, dsicve);
1:d02bb72:             assertEquals( "D6665_T5", dsicve.getTableName() );
1:d02bb72:             assertTrue( dsicve.getConstraintName().startsWith( "SQL" ) );
1:d02bb72:         }
1:2db96c5:     }
1:4cc0287: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d02bb72
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.DerbySQLIntegrityConstraintViolationException;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	// Test the DERBY-6773 support:
1:         try {
1:             s.execute( DIRECT_INSERT_SQL );
1:             fail();
1:         }
1:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:             assertSQLState(LANG_FK_VIOLATION, dsicve);
1:             assertEquals( "T_D_R", dsicve.getTableName() );
1:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:         }
1:         // Use the slightly wordier form of:
1:         //assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:         // to exercise the DERBY-6773 support:
1:         try {
1:             getConnection().commit();
1:             fail();
1:         }
1:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:             assertSQLState(LANG_DEFERRED_FK_CONSTRAINT_T, dsicve);
1:             assertEquals( "\"APP\".\"T_D_R\"", dsicve.getTableName() );
1:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:         }
/////////////////////////////////////////////////////////////////////////
1: 	// Test the DERBY-6773 support:
1:         try {
1:             s.execute( "set constraints c_d_r immediate" );
1:             fail();
1:         }
1:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:             assertSQLState(LANG_DEFERRED_FK_CONSTRAINT_S, dsicve);
1:             assertEquals( "\"APP\".\"T_D_R\"", dsicve.getTableName() );
1:             assertEquals( "C_D_R", dsicve.getConstraintName() );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	// Test the DERBY-6773 support, too.
1:         try {
1:             getConnection().commit();
1:             fail();
1:         }
1:         catch ( DerbySQLIntegrityConstraintViolationException dsicve ) {
1:             assertSQLState(LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T, dsicve);
1:             assertEquals( "D6665_T5", dsicve.getTableName() );
1:             assertTrue( dsicve.getConstraintName().startsWith( "SQL" ) );
1:         }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2db96c5
/////////////////////////////////////////////////////////////////////////
1:     private static final String  LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T
1:                                                                     = "23506";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-6665. The prevention of shared physical
1:      * conglomerates in the presence of the deferrable constraint
1:      * characteristic failed for foreign keys sometimes.  This sometimes made
1:      * the deferred check of constraints miss violations if two deferred
1:      * constraints erroneously shared a physical conglomerate.
1:      */
1:     public void testSharedConglomerates() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.execute("create table d6665_t1(x int primary key)");
1:         s.execute("create table d6665_t2(x int primary key)");
1: 
1:         // Create a table with two foreign keys - they would share one
1:         // conglomerate since they are declared on the same column and the hole
1:         // in the sharing avoidance logic.
1:         s.execute("create table d6665_t3(x int "
1:                 + "references d6665_t1 initially deferred "
1:                 + "references d6665_t2 initially deferred)");
1: 
1:         s.execute("insert into d6665_t1 values 1");
1: 
1:         // This violates the second foreign key, since T2 doesn't contain 1.
1:         // No error here since the constraint is deferred.
1:         s.execute("insert into d6665_t3 values 1");
1: 
1:         // Now we're no longer violating the foreign key.
1:         s.execute("insert into d6665_t2 values 1");
1: 
1:         // Introduce a violation of the first foreign key. No error because
1:         // the checking is deferred.
1:         s.execute("delete from d6665_t1");
1: 
1:         // Commit. Should fail because of the violation introduced by the
1:         // delete statement above. Was not detected before DERBY-6665.
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Another example: A PRIMARY KEY constraint and a FOREIGN KEY
1:         // constraint erroneously share a conglomerate.
1: 
1:         s.execute("create table d6665_t4(x int primary key)");
1:         s.execute("create table d6665_t5(x int "
1:                 + "primary key initially deferred "
1:                 + "references d6665_t4 initially deferred)");
1: 
1:         // First violate the foreign key. No error, since it is deferred.
1:         s.execute("insert into d6665_t5 values 1");
1: 
1:         // No longer in violation of the foreign key after this statement.
1:         s.execute("insert into d6665_t4 values 1");
1: 
1:         // Violate the PRIMARY KEY constraint on T5.X.
1:         s.execute("insert into d6665_t5 values 1");
1: 
1:         // Commit. Should fail because the PRIMARY KEY constraint of T5
1:         // is violated. Was not detected before DERBY-6665.
0:         assertCommitError(LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T,
0:                           getConnection());
1:     }
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
commit:45da2f5
/////////////////////////////////////////////////////////////////////////
1:             // RESTRICT and NO ACTION will throw in different
1:             // code paths, but in practice, in Derby presently, the
1:             // behavior is the same since we do not support SQL in before
1:             // triggers, so test both with the same fixtures.
1:             // CASCADE is tested separately later.
1:             final String[] refActions = {
1:                 "ON DELETE NO ACTION ON UPDATE NO ACTION",
1:                 "ON DELETE RESTRICT ON UPDATE RESTRICT" };
1:             /*   N O   A C T I O N,   R E S T R I C T   (d i r e c t) */
1:             for (String refAct: refActions) {
1:                 s.executeUpdate(
1:                     "create table ref_t(i int, j int, constraint ct " +
1:                     "    primary key(i) deferrable initially deferred)");
1:                 s.executeUpdate(
1:                     "create table t(i int unique not null, c char(1)," +
1:                     "    constraint c foreign key (i) references ref_t(i) " +
1:                     refAct + ")");
1:                 s.executeUpdate("insert into ref_t values (1,2),(1,3),(1,4)");
1:                 s.executeUpdate("insert into t values (1, 'c')");
1:                 // Now, the child (referencing table) is referencing one of the
1:                 // the rows in the primary table whose value is 1, so the
1:                 // reference is ok.
1:                 // What happens when we delete one copy before commit?  Even
1:                 // though we have ON DELETE restrict action, there is another
1:                 // row that would satisfy the constraint.
1:                 rs = s.executeQuery("select * from ref_t");
1:                 rs.next();
1:                 rs.next();
1:                 rs.deleteRow();
1:                 // Now there should be only one left, so the referenced table
1:                 // is OK.
1:                 commit();
1:                 // Try again, but this time with normal delete, not using
1:                 // cursors
1:                 s.executeUpdate("insert into ref_t values (1,5),(1,6)");
1:                 s.executeUpdate("delete from ref_t where j > 4 ");
1:                 commit();
1:                 // Try again, but this time delete both duplicate rows. The
1:                 // second delete should fail.
1:                 s.executeUpdate("insert into ref_t values (1,3)");
1:                 rs = s.executeQuery("select * from ref_t");
1:                 rs.next();
1:                 rs.deleteRow();
1:                 rs.next();
1:                 try {
1:                     rs.deleteRow();
1:                     fail();
1:                 } catch (SQLException e) {
1:                     assertSQLState(LANG_FK_VIOLATION, e);
1:                 }
1:                 s.executeUpdate("insert into ref_t values (1,4), (1,5)");
1:                 // direct delete code path
1:                 assertStatementError(LANG_FK_VIOLATION, s, "delete from ref_t");
1: 
1:                 // deferred delete code path: not ok
1:                 assertStatementError(LANG_FK_VIOLATION, s,
1:                                      "delete from ref_t where i = 1 and " +
1:                                      "    i in (select i from ref_t)");
1: 
1:                 // deferred code path: OK
1:                 s.executeUpdate("delete from ref_t where i = 1 and " +
1:                                 "    i in (select i from ref_t) and j >= 4");
1: 
1:                 s.executeUpdate("insert into ref_t values (1,4), (1,5)");
1:                 s.executeUpdate("delete from ref_t where j >= 4");
1:                 JDBC.assertFullResultSet(
1:                 commit();
1:                 //
1:                 // Try similar with update rather than delete. In this
1:                 // case there is only ever a deferred code path, so separate
1:                 // teste cases as for delete (above) are not relevant.
1:                 //
1:                 s.executeUpdate("insert into ref_t values (1,4)");
1:                 s.executeUpdate("update ref_t set i = 2 where j = 4");
1:                 s.executeUpdate("insert into ref_t values (1,4)");
1:                 assertStatementError(LANG_FK_VIOLATION,
1:                                      s,
1:                                      "update ref_t set i = 2");
1:                 rs = s.executeQuery("select * from ref_t");
1:                 rs.next();
1:                 rs.updateInt(1, 3);
1:                 rs.updateRow();
1:                 rs.close();
1:                 commit();
1:                 dropTable("t");
1:                 dropTable("ref_t");
1:                 commit();
1:             }
1:             /*   N O   A C T I O N,   R E S T R I C T   (d e f e r r e d) */
1:             for (String refAct : refActions) {
1:                 // Delete (deferred processing code path) with more complex FKs
1:                 // and more dups with different keys, so we can execise the
1:                 // postCheck mechanism in ReferencedKeyRIChecker including
1:                 // row/key mappings
1:                 s.executeUpdate(
1:                     "create table ref_t(c char(1), i int, j int, k int," +
1:                     "    constraint c primary key (k, i) initially deferred)");
1:                 s.executeUpdate(
1:                     "create table t(l bigint, i int, j int, k int," +
1:                     "    constraint c2 foreign key(i,k) " +
1:                     "    references ref_t(k, i)" + refAct + ")");
1:                 // key (1, 100) has 3 dups, key (3,100) has two dups
1:                 s.executeUpdate("insert into ref_t values " +
1:                                 "('a', 100, -1, 1)," +
1:                                 "('a', 100, -2, 1)," +
1:                                 "('a', 100, -3, 1)," +
1:                                 "('a', 100, -1, 2)," +
1:                                 "('a', 100, -2, 3)," +
1:                                 "('a', 100, -3, 3)");
1: 
1:                 s.executeUpdate("insert into t values " +
1:                                 "(-11, 1, -4, 100)," +
1:                                 "(-12, 2, -5, 100)," +
1:                                 "(-13, 3, -6, 100)");
1: 
1:                 // This should throw using the postCheck mechanism.
1:                 try {
1:                     s.executeUpdate(
1:                         "delete from ref_t where j < -1 and " +
1:                         "    k in (select k from ref_t)");
1:                     fail();
1:                 } catch (SQLException e) {
1:                     assertSQLState(LANG_FK_VIOLATION, e);
1:                     String expected =
1:                         "DELETE on table 'REF_T' caused a violation" +
1:                         " of foreign key constraint 'C2' for key (3,100).  " +
1:                         "The statement has been rolled back.";
1:                     assertEquals(expected, e.getMessage());
1:                 }
1: 
1:                 // These should be ok (using the postCheck mechanism), since
1:                 // they both leave one row in ref_t to satisfy the constraint.
1:                     "    k in (select k from ref_t where k < 3)");
1:                 s.executeUpdate(
1:                     "delete from ref_t where j < -2 and " +
1:                     "    k in (select k from ref_t where k >= 3)");
1: 
1:                 commit();
1: 
1:                 //
1:                 // Do the same exercise but now with update instead of delete
1:                 //
1:                 dropTable("t");
1:                 dropTable("ref_t");
1:                 commit();
1: 
1:                 s.executeUpdate(
1:                     "create table ref_t(c char(1), i int, j int, k int," +
1:                     "    constraint c primary key (k, i) initially deferred)");
1:                 s.executeUpdate(
1:                     "create table t(l bigint, i int, j int, k int," +
1:                     "    constraint c2 foreign key(i,k) " +
1:                     "    references ref_t(k, i)" + refAct + ")");
1: 
1:                 // key (1, 100) has 3 dups, key (3,100) has two dups
1:                 s.executeUpdate("insert into ref_t values " +
1:                                 "('a', 100, -1, 1)," +
1:                                 "('a', 100, -2, 1)," +
1:                                 "('a', 100, -3, 1)," +
1:                                 "('a', 100, -1, 2)," +
1:                                 "('a', 100, -2, 3)," +
1:                                 "('a', 100, -3, 3)");
1: 
1:                 s.executeUpdate("insert into t values " +
1:                                 "(-11, 1, -4, 100)," +
1:                                 "(-12, 2, -5, 100)," +
1:                                 "(-13, 3, -6, 100)");
1: 
1:                 // This should throw using the postCheck mechanism.
1:                 try {
1:                     s.executeUpdate(
1:                         "update ref_t set k=k*100 where j < -1 and " +
1:                         "    k in (select k from ref_t)");
1:                     fail();
1:                 } catch (SQLException e) {
1:                     assertSQLState(LANG_FK_VIOLATION, e);
1:                     String expected =
1:                         "UPDATE on table 'REF_T' caused a violation" +
1:                         " of foreign key constraint 'C2' for key (3,100).  " +
1:                         "The statement has been rolled back.";
1:                     assertEquals(expected, e.getMessage());
1:                 }
1: 
1:                 // These should be ok (using the postCheck mechanism), since
1:                 // they both leave one row in ref_t to satisfy the constraint.
1:                 s.executeUpdate(
1:                     "update ref_t set k=k*100 where j < -1 and " +
1:                     "    k in (select k from ref_t where k < 3)");
1:                 s.executeUpdate(
1:                     "update ref_t set k=k*100 where j < -2 and " +
1:                     "    k in (select k from ref_t where k >= 3)");
1: 
1:                 dropTable("t");
1:                 dropTable("ref_t");
1:                 commit();
1:             /*  C A S C A D E  */
1: 
1:             // CASCADE delete with deferred row code path (not deferred
1:             // constraint) should still
1:             // not fail. Test since we messed with code path.
1:             s.executeUpdate(
1:                 "create table ref_t(c char(1), i int, j int, k int," +
1:                 "    constraint c primary key (k, i))");
1:             s.executeUpdate(
1:                 "create table t(l bigint, i int, j int, k int," +
1:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:                 "    on delete cascade)");
1: 
1:             s.executeUpdate("insert into ref_t values " +
1:                             "('a', 100, -3, 3)");
1:             s.executeUpdate("insert into t values " +
1:                             "(-11, 3, -4, 100)");
1:                 "    k in (select k from ref_t)");
1:             JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
1:             JDBC.assertEmpty(s.executeQuery("select * from t"));
1:             // Deferred PK constraint, this time with delete with CASCADE,
1:             // should not fail
1: 
1:             // Not yet implemented
1:             assertStatementError("X0Y47", s,
1:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:                 "    on delete cascade)");
1:             dropTable("t");
1:             dropTable("ref_t");
1:             /*  S E T   N U L L  */
1: 
1:             // SET NULL  delete with deferred row code path should still
1:             // not fail. Test since we messed with code path.
1:             s.executeUpdate(
1:                 "create table ref_t(c char(1), i int, j int, k int," +
1:                 "    constraint c primary key (k, i))");
1:             s.executeUpdate(
1:                 "create table t(l bigint, i int, j int, k int," +
1:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:                 "    on delete set null)");
1: 
1:             s.executeUpdate("insert into ref_t values " +
1:                             "('a', 100, -3, 3)");
1:             s.executeUpdate("insert into t values " +
1:                             "(-11, 3, -4, 100)");
1:             s.executeUpdate("delete from ref_t");
1: 
1:             JDBC.assertEmpty(s.executeQuery("select * from ref_t"));
1:             JDBC.assertFullResultSet(s.executeQuery("select * from t"),
1:                     new String[][]{{"-11", null, "-4", null}});
1: 
1:             dropTable("t");
1:             dropTable("ref_t");
1:             commit();
1: 
1:             // Deferred constraint PK, delete with SET NULL should not
1:             // fail
1:             s.executeUpdate(
1:                 "create table ref_t(c char(1), i int, j int, k int," +
1:                 "    constraint c primary key (k, i) initially deferred)");
1: 
1:             // Not yet implemented
1:             assertStatementError("X0Y47", s,
1:                "create table t(l bigint, i int, j int, k int," +
1:                 "    constraint c2 foreign key(i,k) references ref_t(k, i) " +
1:                 "    on delete set null)");
1: 
1:             commit();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testSelfReferential() throws SQLException {
1:         Statement s = createStatement();
1:         try {
1: 
1:             s.executeUpdate(
1:                 "create table t(name varchar(10) primary key " +
1:                 "                   deferrable initially deferred," +
1:                 "               boss varchar(10) references t(name) " +
1:                 "                   on delete restrict, i int)");
1: 
1:             s.executeUpdate("insert into t values ('daisy', null, 1)");
1:             s.executeUpdate("insert into t values ('daisy', null, 2)");
1:             s.executeUpdate("insert into t values ('donald', 'daisy', 3)");
1: 
1:             s.executeUpdate("delete from t where name like 'daisy%' and i = 1");
1:             JDBC.assertFullResultSet(s.executeQuery("select * from t"),
1:                     new String[][]{
1:                         {"daisy", null, "2"},
1:                         {"donald", "daisy", "3"}});
1:             commit();
1: 
1:             s.executeUpdate(
1:                     "create table employees(name char(40), " +
1:                     "    constraint ec primary key(name) initially deferred, " +
1:                     "    address char(40))");
1: 
1:             // Not yet implemented.
1:             assertStatementError("X0Y47", s,
1:                 "create table teammember(" +
1:                 "name char(40) primary key " +
1:                         "references employees(name) on delete cascade, " +
1:                 "boss char(40) " +
1:                         "references teammember(name) on delete cascade)");
1: 
1: 
1:         } finally {
1:             dropTable("t");
1:             dropTable("employees");
1:             dropTable("teammember");
1:             commit();
1:         }
1:     }
commit:18a6fb2
/////////////////////////////////////////////////////////////////////////
1:      * of them is deleted or updated.  The foreign key constraint itself could
1:      * be deferred or not. If this is also deferred, we'd have no issue,
1:      * cf. the explanation in DERBY-6559, as all checking happens later,
1:      * typically at commit.  But if it is <em>not</em> deferred, we needed to
1:      * adjust FK checking at delete/update time to <b>not</b> throw foreign key
1:      * violation exception if a duplicate exists; otherwise we'd throw a
1:      * foreign key violation where none exists. The remaining row(s) will
1:      * fulfill the requirement. We will only check if the last such row is
1:      * deleted or its key modified.
1:      *
1:      * Complicating this processing is that the delete result set has two code
1:      * paths, with with deferred row processing, and one with direct row
1:      * processing.  Update result sets are again handled differently, but these
1:      * are only ever deferred row processing in the presence of a FK on the
1:      * row. The test cases below try to exhaust these code paths.  See {@link
1:      * org.apache.derby.impl.sql.execute.ReferencedKeyRIChecker#doCheck} and
1:      * {@link
1:      * org.apache.derby.impl.sql.execute.ReferencedKeyRIChecker#postCheck}.
1:             ResultSet.TYPE_FORWARD_ONLY,
1:             ResultSet.CONCUR_UPDATABLE);
1: 
1:         ResultSet rs = null;
/////////////////////////////////////////////////////////////////////////
0:             rs = s.executeQuery("select * from ref_t");
/////////////////////////////////////////////////////////////////////////
0:             s.executeUpdate("insert into ref_t values (1,4), (1,5)");
1: 
0:             // direct delete code path
0:             assertStatementError(LANG_FK_VIOLATION, s, "delete from ref_t");
1: 
0:             // deferred delete code path: not ok
1:             assertStatementError(LANG_FK_VIOLATION, s,
0:                     "delete from ref_t where i = 1 and " +
0:                     "    i in (select i from ref_t)");
1: 
0:             // deferred code path: OK
0:             s.executeUpdate("delete from ref_t where i = 1 and " +
0:                     "    i in (select i from ref_t) and j >= 4");
1: 
0:             s.executeUpdate("insert into ref_t values (1,4), (1,5)");
0:             s.executeUpdate("delete from ref_t where j >= 4");
1:             //
0:             // Try similar with update rather than delete. In this
0:             // case there is only ever a deferred code path, so separate
0:             // teste cases as for delete (above) are not relevant.
1:             //
0:             s.executeUpdate("insert into ref_t values (1,4)");
0:             s.executeUpdate("update ref_t set i = 2 where j = 4");
0:             s.executeUpdate("insert into ref_t values (1,4)");
0:             assertStatementError(LANG_FK_VIOLATION,
1:                                  s,
0:                                  "update ref_t set i = 2");
1: 
0:             rs = s.executeQuery("select * from ref_t");
0:             rs.next();
0:             rs.updateInt(1, 3);
0:             rs.updateRow();
1:             rs.close();
1:             commit();
1: 
1:             dropTable("t");
1:             dropTable("ref_t");
1:             commit();
1: 
0:             // Delete (deferred processing code path) with more complex FKs and
0:             // more dups with different keys, so we can execise the postCheck
0:             // mechanism in ReferencedKeyRIChecker including row/key mappings
1:             s.executeUpdate(
1:                 "create table ref_t(c char(1), i int, j int, k int," +
1:                 "    constraint c primary key (k, i) initially deferred)");
1:             s.executeUpdate(
1:                 "create table t(l bigint, i int, j int, k int," +
0:                 "    constraint c2 foreign key(i,k) references ref_t(k, i))");
1: 
0:             // key (1, 100) has 3 dups, key (3,100) has two dups
0:             s.executeUpdate("insert into ref_t values " +
0:                             "('a', 100, -1, 1)," +
0:                             "('a', 100, -2, 1)," +
0:                             "('a', 100, -3, 1)," +
0:                             "('a', 100, -1, 2)," +
0:                             "('a', 100, -2, 3)," +
0:                             "('a', 100, -3, 3)");
1: 
0:             s.executeUpdate("insert into t values " +
0:                             "(-11, 1, -4, 100)," +
0:                             "(-12, 2, -5, 100)," +
0:                             "(-13, 3, -6, 100)");
1: 
0:             // This should throw using the postCheck mechanism.
1:             try {
1:                 s.executeUpdate(
1:                     "delete from ref_t where j < -1 and " +
0:                     "    k in (select k from ref_t)");
0:                 fail();
0:             } catch (SQLException e) {
0:                 assertSQLState(LANG_FK_VIOLATION, e);
0:                 String expected =
0:                     "DELETE on table 'REF_T' caused a violation" +
0:                     " of foreign key constraint 'C2' for key (3,100).  " +
0:                     "The statement has been rolled back.";
0:                 assertEquals(expected, e.getMessage());
1:             }
1: 
0:             // These should be ok (using the postCheck mechanism), since they
0:             // both leave one row in ref_t to satisfy the constraint.
1:             s.executeUpdate(
1:                 "delete from ref_t where j < -1 and " +
0:                 "    k in (select k from ref_t where k < 3)");
1:             s.executeUpdate(
0:                 "delete from ref_t where j < -2 and " +
0:                 "    k in (select k from ref_t where k >= 3)");
1: 
1:             commit();
1: 
1:             //
0:             // Do the same exercise but now with update instead of delete
1:             //
1:             dropTable("t");
1:             dropTable("ref_t");
1:             commit();
1: 
1:             s.executeUpdate(
1:                 "create table ref_t(c char(1), i int, j int, k int," +
1:                 "    constraint c primary key (k, i) initially deferred)");
1:             s.executeUpdate(
1:                 "create table t(l bigint, i int, j int, k int," +
0:                 "    constraint c2 foreign key(i,k) references ref_t(k, i))");
1: 
0:             // key (1, 100) has 3 dups, key (3,100) has two dups
0:             s.executeUpdate("insert into ref_t values " +
0:                             "('a', 100, -1, 1)," +
0:                             "('a', 100, -2, 1)," +
0:                             "('a', 100, -3, 1)," +
0:                             "('a', 100, -1, 2)," +
0:                             "('a', 100, -2, 3)," +
0:                             "('a', 100, -3, 3)");
1: 
0:             s.executeUpdate("insert into t values " +
0:                             "(-11, 1, -4, 100)," +
0:                             "(-12, 2, -5, 100)," +
0:                             "(-13, 3, -6, 100)");
1: 
0:             // This should throw using the postCheck mechanism.
1:             try {
1:                 s.executeUpdate(
0:                     "update ref_t set k=k*100 where j < -1 and " +
0:                     "    k in (select k from ref_t)");
0:                 fail();
0:             } catch (SQLException e) {
0:                 assertSQLState(LANG_FK_VIOLATION, e);
0:                 String expected =
0:                     "UPDATE on table 'REF_T' caused a violation" +
0:                     " of foreign key constraint 'C2' for key (3,100).  " +
0:                     "The statement has been rolled back.";
0:                 assertEquals(expected, e.getMessage());
1:             }
1: 
0:             // These should be ok (using the postCheck mechanism), since they
0:             // both leave one row in ref_t to satisfy the constraint.
1:             s.executeUpdate(
0:                 "update ref_t set k=k*100 where j < -1 and " +
0:                 "    k in (select k from ref_t where k < 3)");
1:             s.executeUpdate(
0:                 "update ref_t set k=k*100 where j < -2 and " +
0:                 "    k in (select k from ref_t where k >= 3)");
1: 
1:             commit();
1: 
1:             if (rs != null) {
1:                 rs.close();
1:             }
commit:0493010
/////////////////////////////////////////////////////////////////////////
1:         dropTable("t_d_r");
1:         dropTable("t_d_c");
1:         dropTable("t_d_na");
1:         dropTable("t_d_nu");
1:         dropTable("t_u_r");
1:         dropTable("t_u_na");
1:         dropTable("ref_d_r");
1:         dropTable("ref_d_c");
1:         dropTable("ref_d_na");
1:         dropTable("ref_d_nu");
1:         dropTable("ref_u_r");
1:         dropTable("ref_u_na");
/////////////////////////////////////////////////////////////////////////
1:             dropTable("t2");
/////////////////////////////////////////////////////////////////////////
0:             dropTable("t");
0:             dropTable("ref_t");
commit:9179199
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:  * check until the entire set of rows to be updated has been processed.
1:  * <p/>
/////////////////////////////////////////////////////////////////////////
1:         // Delete of child row is trivial, parent not affected.
/////////////////////////////////////////////////////////////////////////
1:         // Delete of child row is trivial, parent not affected.
/////////////////////////////////////////////////////////////////////////
1:      * Insert using bulk insert code path, i.e. IMPORT. Since IMPORT
1:      * IMPORT. This behavior can not be observed externally, but we include
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The referenced constraint (in the referenced table) is a deferred unique
1:      * or primary key constraint. This test concerns what happens if this is
1:      * deferred, i.e. duplicate keys are allowed temporarily, and one or more
0:      * of them is deleted.  The foreign key constraint itself could be deferred
0:      * or not. If this is also deferred, we'd have no issue, cf. the
0:      * explanation in DERBY-6559, as all checking happens later, typically at
0:      * commit.  But it is is <em>not</em> deferred, we needed to adjust FK
0:      * checking at delete/update time to <b>not</b> throw foreign key violation
0:      * exception if a duplicate exists; otherwise we'd throw a foreign key
0:      * violation where none exists. The remaining row(s) will fulfill the
0:      * requirement. We will only check if the last such row is deleted or its
0:      * key modified.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testFKPlusUnique() throws SQLException {
1:         Statement s = createStatement(
0:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1: 
0:         try {
1:             s.executeUpdate(
0:                 "create table ref_t(i int, j int, constraint ct " +
0:                 "    primary key(i) deferrable initially deferred)");
1:             s.executeUpdate(
0:                 "create table t(i int unique not null, c char(1)," +
0:                 "    constraint c foreign key (i) references ref_t(i))");
1: 
0:             s.executeUpdate("insert into ref_t values (1,2),(1,3),(1,4)");
0:             s.executeUpdate("insert into t values (1, 'c')");
1: 
0:             // Now, the child (referencing table) is referencing one of the the
0:             // rows in the primary table whose value is 1, so the reference is
0:             // ok.
1: 
0:             // What happens when we delete one copy before commit?
0:             // Even though we have ON DELETE restrict action, there is another
0:             // row that would satisfy the constraint.
0:             ResultSet rs = s.executeQuery("select * from ref_t");
0:             rs.next();
1:             rs.deleteRow();
0:             rs.next();
1:             rs.deleteRow();
0:             // Now there should be only one left, so the referenced table is
0:             // OK.
1:             commit();
1: 
0:             // Try again, but this time with normal delete, not using cursors
0:             s.executeUpdate("insert into ref_t values (1,5),(1,6)");
0:             s.executeUpdate("delete from ref_t where j > 4 ");
1:             commit();
1: 
0:             // Try again, but this time delete both duplicate rows. The second
0:             // delete should fail.
0:             s.executeUpdate("insert into ref_t values (1,3)");
0:             rs = s.executeQuery("select * from ref_t");
0:             rs.next();
1:             rs.deleteRow();
0:             rs.next();
1: 
0:             try {
1:                 rs.deleteRow();
0:                 fail();
0:             } catch (SQLException e) {
0:                 assertSQLState(LANG_FK_VIOLATION, e);
1:             }
1: 
0:             JDBC.assertFullResultSet(
1:                     s.executeQuery("select * from ref_t"),
1:                     new String[][]{{"1", "3"}});
1: 
1:             commit();
1: 
1:         } finally {
0:             dontThrow(s, "drop table t");
0:             dontThrow(s, "drop table ref_t");
1:             commit();
1:         }
1: 
1:     }
1: 
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForeignKeysDeferrableTest
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import static org.apache.derbyTesting.junit.BaseJDBCTestCase.usingDerbyNetClient;
0: import static org.apache.derbyTesting.junit.BaseJDBCTestCase.usingEmbedded;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import static org.apache.derbyTesting.junit.TestConfiguration.clientServerSuite;
1: import static org.apache.derbyTesting.junit.TestConfiguration.embeddedSuite;
1: 
1: /**
1:  * Test deferrable foreign key constraints.
1:  *
1:  * NOTE: In contrast to constraint checking, the <em>referential actions</em>
1:  * specified by a referential constraint are never deferred.
1:  * (SQL 2011: section 4.18.2).
1:  * <p/>
1:  * Section 4.18.3.3:
1:  * An {@code <update rule>} that does not contain NO ACTION specifies a
1:  * referential update action. A {@code <delete rule>} that does not specify NO
1:  * ACTION specifies a referential delete action. Referential update
1:  * actions and referential delete actions are collectively called
1:  * referential actions. Referential actions are carried out before, and
1:  * are not part of, the checking of a referential constraint. Deferring a
1:  * referential constraint defers the checking of the {@code <search condition>}
1:  * of the constraint (a {@code <match predicate>}) but does not defer the
1:  * referential actions of the referential constraint.
1:  * <p/>
0:  * NOTE 52 ? For example, if a referential update action such as ON UPDATE
1:  * CASCADE is specified, then any UPDATE operation on the referenced table will
1:  * be cascaded to the referencing table as part of the UPDATE operation, even
1:  * if the referential constraint is deferred. Consequently, the referential
1:  * constraint cannot become violated by the UPDATE statement. On the other
1:  * hand, ON UPDATE SET DEFAULT could result in a violation of the referential
1:  * constraint if there is no matching row after the referencing column is set
1:  * to its default value. In addition, INSERT and UPDATE operations on the
1:  * referencing table do not entail any automatic enforcement of the referential
1:  * constraint. Any such violations of the constraint will be detected when the
1:  * referential constraint is eventually checked, at or before a commit.
1:  * <p/>
0:  * NOTE 53 ? Even if constraint checking is not deferred, ON UPDATE
1:  * RESTRICT is a stricter condition than ON UPDATE NO ACTION. ON UPDATE
1:  * RESTRICT prohibits an update to a particular row if there are any
1:  * matching rows; ON UPDATE NO ACTION does not perform its constraint
1:  * NOTE 54 - Ditto for DELETE.
1:  * <p/>
1:  * Line numbers in the comments refer to svn revision 1580845 of Derby trunk.
1:  */
1: public class ForeignKeysDeferrableTest extends BaseJDBCTestCase
1: {
1:     private static final String  LANG_DEFERRED_FK_CONSTRAINT_T = "23516";
1:     private static final String  LANG_DEFERRED_FK_CONSTRAINT_S = "23517";
1:     private static final String  LANG_ADD_FK_CONSTRAINT_VIOLATION = "X0Y45";
1:     private static final String  LANG_FK_VIOLATION = "23503";
1: 
1: 
1:     private static String expImpDataFile;  // file used to perform
1:                                            // import/export
1:     private static boolean exportFilesCreatedEmbedded = false;
1:     private static boolean exportFilesCreatedClient = false;
1: 
1: 
1:     public ForeignKeysDeferrableTest(String name) {
1:         super(name);
1:     }
1: 
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         suite.addTest(new SupportFilesSetup(
1:                 embeddedSuite(ForeignKeysDeferrableTest.class)));
1:         suite.addTest(new SupportFilesSetup(
1:                 clientServerSuite(ForeignKeysDeferrableTest.class)));
1: 
1:         return suite;
1:     }
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         super.setUp();
1: 
1:         Statement s = createStatement();
1: 
1:         // <table_name> ::= <role>_<statementType>_<action>
1:         // where:
1:         // <role> ::=  "ref"   /* a referenced table */
1:         //           | "t"     /* a referencing table: carries the FK */
1:         //
1:         // <statement type> ::= "d"  /* delete */
1:         //                    | "u"  /* update */
1:         //
1:         // <action> ::= "r"  /* restrict */
1:         //            | "c"  /* cascade */
1:         //            | "na" /* no action */
1:         //            | "nu" /* set null */
1:         //
1:         // Insert statements borrow the "d" tables.  The constraint names use
1:         // similar semantics, e.g. "c_d_c": constraint, delete table set,
1:         // cascade.
1: 
1:         s.executeUpdate(
1:                 "create table ref_d_r(i int primary key, j int default 2)");
1:         s.executeUpdate(
1:                 "create table ref_d_c(i int primary key, j int default 2)");
1:         s.executeUpdate(
1:                 "create table ref_d_na(i int primary key, j int default 2)");
1:         s.executeUpdate(
1:                 "create table ref_d_nu(i int primary key, j int default 2)");
1: 
1:         s.executeUpdate(
1:                 "create table ref_u_r(i int primary key, j int default 2)");
1:         s.executeUpdate(
1:                 "create table ref_u_na(i int primary key, j int default 2)");
1: 
1:         s.executeUpdate("insert into ref_d_r values (1, default)");
1:         s.executeUpdate("insert into ref_d_c values (1, default)");
1:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:         s.executeUpdate("insert into ref_d_nu values (1, default)");
1: 
1:         s.executeUpdate("insert into ref_u_r values (1, default)");
1:         s.executeUpdate("insert into ref_u_na values (1, default)");
1: 
1: 
1:         // Tables for testing delete with {CASCADE, RESTRICT, SET NULL,
1:         // NOACTION}
1:         s.executeUpdate(
1:             "create table t_d_r(i int, j int default 2," +
1:             "   constraint c_d_r foreign key (i) references ref_d_r(i) " +
1:             "   on delete restrict " +
1:             "deferrable initially immediate)");
1: 
1:         s.executeUpdate(
1:             "create table t_d_c(i int, j int default 2," +
1:             "   constraint c_d_c foreign key (i) references ref_d_c(i) " +
1:             "   on delete cascade " +
1:             "deferrable initially immediate)");
1: 
1:         s.executeUpdate(
1:             "create table t_d_na(i int, j int default 2," +
1:             "   constraint c_d_na foreign key (i) references ref_d_na(i) " +
1:             "   on delete no action " +
1:             "deferrable initially immediate)");
1: 
1:         s.executeUpdate(
1:             "create table t_d_nu(i int, j int default 2," +
1:             "   constraint c_d_nu foreign key (i) references ref_d_nu(i) " +
1:             "   on delete set null " +
1:             "deferrable initially immediate)");
1: 
1:         // Tables for testing update with {RESTRICT, NOACTION}
1:         s.executeUpdate(
1:             "create table t_u_r(i int, j int default 2," +
1:             "   constraint c_u_r foreign key (i) references ref_u_r(i) " +
1:             "   on update restrict " +
1:             "deferrable initially immediate)");
1: 
1:         s.executeUpdate(
1:             "create table t_u_na(i int, j int default 2," +
1:             "   constraint c_u_na foreign key (i) references ref_u_na(i) " +
1:             "   on update no action " +
1:             "deferrable initially immediate)");
1: 
1:         s.executeUpdate("insert into t_d_r   values (1, default)");
1:         s.executeUpdate("insert into t_d_c   values (1, default)");
1:         s.executeUpdate("insert into t_d_na  values (1, default)");
1:         s.executeUpdate("insert into t_d_nu  values (1, default)");
1:         s.executeUpdate("insert into t_u_r   values (1, default)");
1:         s.executeUpdate("insert into t_u_na  values (1, default)");
1: 
1:         if ((usingEmbedded() && !exportFilesCreatedEmbedded) ||
1:             (usingDerbyNetClient() && !exportFilesCreatedClient)) {
1: 
1:             // We have to do this once for embedded and once for client/server
1:             if (usingEmbedded()) {
1:                 exportFilesCreatedEmbedded = true;
1:             } else {
1:                 exportFilesCreatedClient = true;
1:             }
1: 
1:             // Create a file for import that contains rows for which the
1:             // foreign key constraint doesn't hold.
1:             expImpDataFile =
1:                 SupportFilesSetup.getReadWrite("t.data").getPath();
1:             s.executeUpdate("create table t(i int, j int)");
1:             s.executeUpdate("insert into t values (1,2),(2,2)");
1:             s.executeUpdate(
1:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE (" +
1:                 "    'APP' , 'T' , '" + expImpDataFile + "'," +
1:                 "    null, null , null)");
1:             s.executeUpdate("drop table t");
1:         }
1: 
1:         setAutoCommit(false);
1:     }
1: 
1:     @Override
1:     protected void tearDown() throws Exception {
1:         rollback();
1:         setAutoCommit(true);
1:         Statement s = createStatement();
0:         dontThrow(s, "drop table t_d_r   ");
0:         dontThrow(s, "drop table t_d_c   ");
0:         dontThrow(s, "drop table t_d_na  ");
0:         dontThrow(s, "drop table t_d_nu  ");
0:         dontThrow(s, "drop table t_u_r   ");
0:         dontThrow(s, "drop table t_u_na  ");
1: 
0:         dontThrow(s, "drop table ref_d_r");
0:         dontThrow(s, "drop table ref_d_c");
0:         dontThrow(s, "drop table ref_d_na");
0:         dontThrow(s, "drop table ref_d_nu");
1: 
0:         dontThrow(s, "drop table ref_u_r");
0:         dontThrow(s, "drop table ref_u_na");
1: 
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * Insert row in non-deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      * It doesn't matter what constraint action we have on a FK when inserting,
1:      * it is always in "NO ACTION" mode, i.e. the constraint can be
1:      * deferred. In this example, we use the {t,ref}_d_r table pair, but it
1:      * could have been any of the others.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testInsertDirect() throws SQLException {
1:         Statement s = createStatement();
1:         final String DIRECT_INSERT_SQL =
1:                 "insert into t_d_r values (2, default)";
1: 
1:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:         // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1028)
1: 
1:         assertStatementError(LANG_FK_VIOLATION, s, DIRECT_INSERT_SQL);
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DIRECT_INSERT_SQL);
1: 
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Now see deferred check succeed by actually adding referenced key
1:         // *after* the insert of the referencing row. Also check that setting
1:         // immediate constraint mode throws a statement level error.
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DIRECT_INSERT_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1:         s.executeUpdate("insert into ref_d_r values (2, default)");
1:         commit();
1: 
1:         // Now see deferred check of we after inserting the referencing row
1:         // delete it again before commit. Also check that setting immediate
1:         // constraint mode throws a statement level error.
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DIRECT_INSERT_SQL.replaceAll("2", "3"));
1: 
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1: 
1:         s.executeUpdate("delete from t_d_r where i=3");
1:         commit();
1:     }
1: 
1:     /**
1:      * Insert row in deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      * It doesn't matter what constraint action we have on a FK when inserting,
1:      * it is always in "NO ACTION" mode, i.e. the constraint can be
1:      * deferred. In this example, we use the {t,ref}_d_r table pair, but it
1:      * could have been any of the others.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testInsertDeferred() throws SQLException {
1:         Statement s = createStatement();
1:         final String DEFERRED_INSERT_SQL =
1:                 "insert into t_d_r select i+1,j from t_d_r";
1: 
1:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:         // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1205)
1:         // ...InsertResultSet.open(InsertResultSet.java:497)
1: 
1:         assertStatementError(LANG_FK_VIOLATION, s, DEFERRED_INSERT_SQL);
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DEFERRED_INSERT_SQL);
1: 
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Now see deferred check succeed by actually adding referenced key
1:         // *after* the insert of the referencing row. Also check that setting
1:         // immediate constraint mode throws a statement level error.
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DEFERRED_INSERT_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1:         s.executeUpdate("insert into ref_d_r values (2, default)");
1:         commit();
1: 
1:         // Now see deferred check of we after inserting the referencing row
1:         // delete it again before commit. Also check that setting immediate
1:         // constraint mode throws a statement level error.
1: 
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         s.executeUpdate(DEFERRED_INSERT_SQL);
1: 
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_r immediate");
1: 
1:         s.executeUpdate("delete from t_d_r where i=3");
1:         commit();
1:     }
1: 
1:     /**
1:      * Update row in non-deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testUpdateDirect() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Child:
1: 
1:         final String RESTRICTED_UPDATE_CHILD_SQL =
1:             "update t_u_r set i=2 where j=2";
1: 
1:         final String NO_ACTION_UPDATE_CHILD_SQL =
1:             "update t_u_na set i=2 where j=2";
1: 
1:         // NO ACTION: This should be deferred in deferred mode
1:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:         // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:         // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:         // ...UpdateResultSet.collectAffectedRows(UpdateResultSet.java:614)
1:         // ...UpdateResultSet.open(UpdateResultSet.java:259)
1: 
1:         //   N O   A C T I O N,     R E S T R I C T
1:         // Both are treated as NO ACTION since we are updating the child, not
1:         // the parent here.
1:         String[] constraint = new String[]{"c_u_r", "c_u_na"};
1:         String[] sql = new String[]{RESTRICTED_UPDATE_CHILD_SQL,
1:                                     NO_ACTION_UPDATE_CHILD_SQL};
1: 
1:         for (int i = 0; i < 2; i++) {
1:             assertStatementError(LANG_FK_VIOLATION, s, sql[i]);
1:             final String setDeferred =
1:                     "set constraints " + constraint[i] + " deferred";
1:             final String setImmediate =
1:                     "set constraints " + constraint[i] + " immediate";
1:             s.executeUpdate(setDeferred);
1:             s.executeUpdate(sql[i]);
1:             assertStatementError(
1:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:             assertStatementError(
1:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:         }
1: 
1:         //   C A S C A D E,    S E T   N U L L
1:         //   Not applicable for update (Derby restriction). But if they had been
1:         //   implemented, the behavior should be as for NO ACTION above.
1: 
1:         // Parent:
1: 
1:         // Always performed deferred update mode, cf. this this explanation in
1:         // TableDescriptor#getAllRelevantConstraints: "For update, if we are
1:         // updating a referenced key, then we have to do it in deferred mode
1:         // (in case we update multiple rows)".
1:     }
1: 
1:     /**
1:      * Update row in deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testUpdateDeferred() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Update child
1: 
1:         final String RESTRICTED_UPDATE_CHILD_SQL =
1:             "update t_u_r set i=2 where i=1";
1: 
1:         final String NO_ACTION_UPDATE_CHILD_SQL =
1:             "update t_u_na set i=2 where i=1";
1: 
1:         final String RESTRICTED_UPDATE_PARENT_SQL =
1:             "update ref_u_r set i = 2 where i = 1";
1: 
1:         final String NO_ACTION_UPDATE_PARENT_SQL =
1:             "update ref_u_na set i = 2 where i = 1";
1: 
1:         // RESTRICT and NO ACTION. Since we are updating the child, we
1:         // run implicitly in NO ACTION mode, so can be deferred
1:         //
1:         // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:1005)
1:         // ...UpdateResultSet.open(UpdateResultSet.java:274)
1: 
1:         //   N O   A C T I O N,     R E S T R I C T
1:         // Both are treated as NO ACTION since we are updating the child, not
1:         // the parent here.
1: 
1:         String[] constraint = new String[]{"c_u_r", "c_u_na"};
1:         String[] sql = new String[]{RESTRICTED_UPDATE_CHILD_SQL,
1:                                     NO_ACTION_UPDATE_CHILD_SQL};
1: 
1:         for (int i = 0; i < 2; i++) {
1:             assertStatementError(LANG_FK_VIOLATION, s, sql[i]);
1:             final String setDeferred =
1:                     "set constraints " + constraint[i] + " deferred";
1:             final String setImmediate =
1:                     "set constraints " + constraint[i] + " immediate";
1:             s.executeUpdate(setDeferred);
1:             s.executeUpdate(sql[i]);
1:             assertStatementError(
1:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:             assertStatementError(
1:                     LANG_DEFERRED_FK_CONSTRAINT_S, s, setImmediate);
1:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1:         }
1: 
1: 
1: 
1:         // Parent, RESTRICT Should *never* be deferred.
1:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:961)
1:         // ...UpdateResultSet.open(UpdateResultSet.java:269)
1:         assertStatementError(LANG_FK_VIOLATION, s,
1:                              RESTRICTED_UPDATE_PARENT_SQL);
1: 
1:         // Since the action is RESTRICT, deferred constraint doesn't help:
1:         s.executeUpdate("set constraints c_u_r deferred");
1:         assertStatementError(LANG_FK_VIOLATION, s,
1:                              RESTRICTED_UPDATE_PARENT_SQL);
1: 
1: 
1:         // Parent, NO ACTION (different code path, cf. line 269 vs 274).
1:         // Should be deferred if constraint mode is deferred.
1:         //
1:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:         // ...RISetChecker.doRICheck(RISetChecker.java:151)
1:         // ...UpdateResultSet.runChecker(UpdateResultSet.java:961)
1:         // ...UpdateResultSet.open(UpdateResultSet.java:274) <-- Note:difference
1:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_UPDATE_PARENT_SQL);
1: 
1:         // Since the action is NO ACTION, deferral should work
1:         s.executeUpdate("set constraints c_u_na deferred");
1:         s.executeUpdate(NO_ACTION_UPDATE_PARENT_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_u_na immediate");
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_u_na immediate");
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Resolve by resetting the value in the referenced row
1:         s.executeUpdate("set constraints c_u_na deferred");
1:         s.executeUpdate(NO_ACTION_UPDATE_PARENT_SQL);
1:         s.executeUpdate("update ref_u_na set i=1 where i=2");
1:         commit();
1: 
1:         // Resolve by resetting the referencing row
1:         s.executeUpdate("set constraints c_u_na deferred");
1:         s.executeUpdate(NO_ACTION_UPDATE_CHILD_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_u_na immediate");
1:         s.executeUpdate("update t_u_na set i=1 where i=2");
1:         commit();
1: 
1:     }
1: 
1:     /**
1:      * Delete row in non-deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testDeleteDirect() throws SQLException {
1:         Statement s = createStatement();
1: 
0:         // Delete of child row is trivial, parent no affected.
1: 
1:         // Parent
1: 
1:         final String RESTRICTED_DELETE_SQL = "delete from ref_d_r where i = 1";
1:         final String NO_ACTION_DELETE_SQL = "delete from ref_d_na where i = 1";
1:         final String CASCADE_DELETE_SQL = "delete from ref_d_c where i = 1";
1:         final String SET_NULL_DELETE_SQL = "delete from ref_d_nu where i = 1";
1: 
1:         // RESTRICT and NO ACTION: As far as triggers, there is no difference
1:         // when the execution of checking happens here, since in the presence
1:         // of triggers, row processing is deferred. But for deferred constraints
1:         // we need to treat these two differently: The RESTRICT code path
1:         // should check even in the presence of deferred FK constraints,
1:         // the NO ACTION code path should wait.
1:         //
1:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:         // ...DeleteResultSet.collectAffectedRows(DeleteResultSet.java:392)
1:         // ...DeleteResultSet.open(DeleteResultSet.java:136)
1: 
1:         //   R E S T R I C T
1:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1: 
1:         // Since the action is RESTRICT, deferred constraint doesn't help.
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1: 
1:         //   N O   A C T I O N
1:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_DELETE_SQL);
1: 
1:         // Since the action is NO ACTION, deferral should work
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Resolve by removing the referencing row
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         s.executeUpdate("delete from t_d_na where i=1");
1:         commit();
1: 
1:         // Resolve by re-inserting the referenced row
1:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:         s.executeUpdate("insert into t_d_na values (1, default)");
1:         commit();
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:         commit();
1: 
1:         //   C A S C A D E : not impacted by deferred
1:         s.executeUpdate(CASCADE_DELETE_SQL);
1:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:         rollback();
1: 
1:         s.executeUpdate("set constraints c_d_c deferred");
1:         s.executeUpdate(CASCADE_DELETE_SQL);
1:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:         commit();
1: 
1:         //   S E T   N U L L : not impacted by deferred
1:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:         assertResults(
1:                 s.executeQuery("select i from t_d_nu"),
1:                 new String[][]{{null}},
1:                 false);
1:         rollback();
1: 
1:         s.executeUpdate("set constraints c_d_nu deferred");
1:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:         assertResults(
1:                 s.executeQuery("select i from t_d_nu"),
1:                 new String[][]{{null}},
1:                 false);
1:         commit();
1:     }
1: 
1:     /**
1:      * Delete row in deferred code path. Note that this use of "deferred"
1:      * refers to the insert processing, not the deferrable constraint.
1:      *
1:      * @throws SQLException
1:      */
1:         public void testDeleteDeferred() throws SQLException {
1:         Statement s = createStatement();
0:         // Delete of child row is trivial, parent no affected.
1: 
1:         // Parent
1: 
1:         final String RESTRICTED_DELETE_SQL =
1:                 "delete from ref_d_r where i = 1 and " +
1:                 "    i in (select i from ref_d_r)";
1: 
1:         final String NO_ACTION_DELETE_SQL =
1:                 "delete from ref_d_na where i = 1 and " +
1:                 "    i in (select i from ref_d_na)";
1: 
1:         final String CASCADE_DELETE_SQL =
1:                 "delete from ref_d_c where i = 1 and " +
1:                 "    i in (select i from ref_d_c)";
1: 
1:         final String SET_NULL_DELETE_SQL =
1:                 "delete from ref_d_nu where i = 1 and " +
1:                 "    i in (select i from ref_d_nu)";
1: 
1: 
1:         // RESTRICT - This checking should *never* be deferred
1:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:         // ...DeleteResultSet.runFkChecker(DeleteResultSet.java:559)
1:         // ...DeleteResultSet.open(DeleteResultSet.java:151)
1: 
1:         //   R E S T R I C T
1:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1: 
1:         // Since the action is RESTRICT, deferred constraint doesn't help.
1:         s.executeUpdate("set constraints c_d_r deferred");
1:         assertStatementError(LANG_FK_VIOLATION, s, RESTRICTED_DELETE_SQL);
1: 
1:         // NO ACTION - This checking should be deferred in deferred mode
1:         // ...ReferencedKeyRIChecker.doCheck(ReferencedKeyRIChecker.java:108)
1:         // ...RISetChecker.doPKCheck(RISetChecker.java:97)
1:         // ...DeleteResultSet.runFkChecker(DeleteResultSet.java:559)
1:         // ...DeleteResultSet.open(DeleteResultSet.java:154) <-- Note:difference
1: 
1:         //   N O   A C T I O N
1:         assertStatementError(LANG_FK_VIOLATION, s, NO_ACTION_DELETE_SQL);
1: 
1:         // Since the action is NO ACTION, deferral should work
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1:         // Resolve by removing the referencing row
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         s.executeUpdate("delete from t_d_na where i=1");
1:         commit();
1: 
1:         // Resolve by re-inserting the referenced row
1:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:         s.executeUpdate("insert into t_d_na values (1, default)");
1:         commit();
1:         s.executeUpdate("set constraints c_d_na deferred");
1:         s.executeUpdate(NO_ACTION_DELETE_SQL);
1:         assertStatementError(LANG_DEFERRED_FK_CONSTRAINT_S, s,
1:                              "set constraints c_d_na immediate");
1:         s.executeUpdate("insert into ref_d_na values (1, default)");
1:         commit();
1: 
1:         //   C A S C A D E : not impacted by deferred
1:         s.executeUpdate(CASCADE_DELETE_SQL);
1:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:         rollback();
1: 
1:         s.executeUpdate("set constraints c_d_c deferred");
1:         s.executeUpdate(CASCADE_DELETE_SQL);
1:         JDBC.assertEmpty(s.executeQuery("select * from t_d_c"));
1:         commit();
1: 
1:         //   S E T   N U L L : not impacted by deferred
1:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:         assertResults(
1:                 s.executeQuery("select i from t_d_nu"),
1:                 new String[][]{{null}},
1:                 false);
1:         rollback();
1: 
1:         s.executeUpdate("set constraints c_d_nu deferred");
1:         s.executeUpdate(SET_NULL_DELETE_SQL);
1:         assertResults(
1:                 s.executeQuery("select i from t_d_nu"),
1:                 new String[][]{{null}},
1:                 false);
1:         commit();
1:     }
1: 
1:     /**
0:      * Insert using bulk import code path, i.e. IMPORT. Since IMPORT
1:      * always performs a commit at the end, we strictly do no need to do
1:      * extra processing for deferrable constraints, but we do so
1:      * anyway to prepare for possible future lifting of this restriction to
0:      * IMPORT. This behavior can no be observed externally, but we include
1:      * the test here anyway as a baseline.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testBulkInsert() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Try the test cases below with both "replace" and "append"
1:         // semantics. It doesn't matter what constraint action
1:         // we have on a FK when inserting, it is always in "NO ACTION" mode,
1:         // i.e. the constraint can be deferred. In this example, we
1:         // use the {t,ref}_d_r table pair, but it could have been any of the
1:         // others.
1:         for (int addOrReplace = 0; addOrReplace < 2; addOrReplace++) {
1:             // import and implicit commit leads to checking
1: 
1:             // ADD:
1:             // ...ForeignKeyRIChecker.doCheck(ForeignKeyRIChecker.java:99)
1:             // ...GenericRIChecker.doCheck(GenericRIChecker.java:91)
1:             // ...RISetChecker.doFKCheck(RISetChecker.java:121)
1:             // ...InsertResultSet.normalInsertCore(InsertResultSet.java:1028)
1:             // ...InsertResultSet.open(InsertResultSet.java:497)
1: 
1:             // REPLACE:
1:             // ...InsertResultSet.bulkValidateForeignKeysCore(
1:             //         InsertResultSet.java:1726)
1:             // ...InsertResultSet.bulkValidateForeignKeys(
1:             //         InsertResultSet.java:1594)
1:             // ...InsertResultSet.open(InsertResultSet.java:490)
1: 
1:             assertStatementError(
1:                 LANG_FK_VIOLATION,
1:                 s,
1:                 "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (" +
1:                 "    'APP' , 'T_D_R' , '" + expImpDataFile + "'," +
1:                 "    null, null , null, " + addOrReplace + ")");
1: 
1:             s.executeUpdate("set constraints c_d_r deferred");
1:             assertStatementError(
1:                 LANG_DEFERRED_FK_CONSTRAINT_T,
1:                 s,
1:                 "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (" +
1:                 "    'APP' , 'T_D_R' , '" + expImpDataFile + "'," +
1:                 "    null, null , null, " + addOrReplace + ")");
1:         }
1:     }
1: 
1:     public void testAddConstraint() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t2(i int)");
1: 
0:         try {
1:             s.executeUpdate("insert into t2 values 1,2");
1:             commit();
1: 
1:             // First, try with immediate checking
1:             assertStatementError(LANG_ADD_FK_CONSTRAINT_VIOLATION, s,
1:                     "alter table t2 add constraint " +
1:                     "    c2 foreign key(i) references ref_d_r(i)");
1:             s.executeUpdate("delete from t2 where i=2");
1: 
1:             // Delete the row with 2 should make it OK to add the constraint:
1:             s.executeUpdate("alter table t2 add constraint " +
1:                     "c2 foreign key(i) references ref_d_r(i)");
1: 
1:             rollback();
1:             s.executeUpdate("delete from t2");
1: 
1:             // Now try with deferred constraint
1:             s.executeUpdate("insert into t2 values 1,2");
1:             commit();
1: 
1:             s.executeUpdate("alter table t2 add constraint " +
1:                     "    c2 foreign key(i) references ref_d_r(i) " +
1:                     "    initially deferred");
1: 
1:             assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
1: 
1: 
1:         } finally {
0:             dontThrow(s, "drop table t2");
1:             commit();
1:         }
1:     }
1: 
0:     private void dontThrow(Statement st, String stm) {
0:         try {
0:             st.executeUpdate(stm);
0:         } catch (SQLException e) {
0:             // ignore, best effort here
0:             println("\"" + stm+ "\"failed: " + e);
1:         }
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:64b6308
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that truncate table is not allowed on a referenced table.
1:      * See DERBY-6668.
1:      */
1:     public  void    test_6668() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         goodStatement
1:             (
1:              conn,
1:              "create table tunique_6668\n" +
1:              "(\n" +
1:              "  a int not null unique\n" +
1:              ")\n"
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              "create table tref_6668\n" +
1:              "(\n" +
1:              "  a int references tunique_6668( a ) initially deferred\n" +
1:              ")\n"
1:              );
1: 
1:         assertStatementError
1:             (
1:              "XCL48",
1:              conn.prepareStatement( "truncate table tunique_6668" )
1:              );
0:     }
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f65be8f
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testInsertTrigger() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.execute("create table d6664_t1(pk int primary key)");
1:         s.execute("create table d6664_t2(x int references d6664_t1 "
1:                 + "initially deferred)");
1:         s.execute("create table d6664_t3(y int)");
1:         s.execute("create trigger d6664_tr after insert on d6664_t3 "
1:                 + "referencing new as new for each row "
1:                 + "insert into d6664_t2 values new.y");
0: 
1:         // Used to fail with "Schema 'null' does not exist" before DERBY-6664.
1:         s.execute("insert into d6664_t3 values 1");
0: 
1:         // Verify that the trigger fired.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from d6664_t2"), "1");
0: 
1:         // Trigger caused violation in deferred foreign key. Should be
1:         // detected on commit.
0:         assertCommitError(LANG_DEFERRED_FK_CONSTRAINT_T, getConnection());
0:     }
commit:43aa7cd
/////////////////////////////////////////////////////////////////////////
1:  * NOTE 52 - For example, if a referential update action such as ON UPDATE
/////////////////////////////////////////////////////////////////////////
1:  * NOTE 53 - Even if constraint checking is not deferred, ON UPDATE
============================================================================