1:eac0369: /*
4:eac0369: 
1:345de35:    Derby - Class org.apache.derby.catalog.types.IndexDescriptorImpl
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.catalog.types;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.IndexDescriptor;
1:eac0369: 
1:57465ef: import org.apache.derby.iapi.services.io.ArrayUtil;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableHashtable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1:6b50965: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:eac0369: 
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:0c5bc3a: /**
1:0c5bc3a:  * See also {@link org.apache.derby.iapi.sql.dictionary.IndexRowGenerator}.
1:0c5bc3a:  * <p>
1:0c5bc3a:  * For a description of how deferrable and non-deferrable constraints
1:0c5bc3a:  * are backed differently, including the meaning of the
1:0c5bc3a:  * boolean attributes used here, see {@link
1:0c5bc3a:  * org.apache.derby.catalog.IndexDescriptor}.
1:0c5bc3a:  */
1:eac0369: public class IndexDescriptorImpl implements IndexDescriptor, Formatable
2:eac0369: {
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. That means that it
1:eac0369: 	**	can write itself to and from a formatted stream. If
1:eac0369: 	**	you add more fields to this class, make sure that you
1:eac0369: 	**	also write/read them with the writeExternal()/readExternal()
1:eac0369: 	**	methods.
1:eac0369: 	**
1:0c5bc3a:     **  If, in between releases, you add more fields to this class,
1:eac0369: 	**	then you should bump the version number emitted by the getTypeFormatId()
1:eac0369: 	**	method.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:eac0369: 
1:eac0369: 	private boolean		isUnique;
1:eac0369: 	private int[]		baseColumnPositions;
1:eac0369: 	private boolean[]	isAscending;
1:eac0369: 	private int			numberOfOrderedColumns;
1:eac0369: 	private String		indexType;
1:28e234d: 	//attribute to indicate the indicates allows duplicate only in
1:28e234d: 	//case of non null keys. This attribute has no effect if the isUnique
1:28e234d:     //is true. If isUnique is false and isUniqueWithDuplicateNulls is set 
1:28e234d:     //to true the index will allow duplicate nulls but for non null keys 
1:28e234d:     //will act like a unique index.
1:28e234d: 	private boolean     isUniqueWithDuplicateNulls;
1:eac0369: 
1:0c5bc3a:     /**
1:0c5bc3a:      * The index represents a PRIMARY KEY or a UNIQUE NOT NULL constraint which
1:0c5bc3a:      * is deferrable.
1:0c5bc3a:      * {@code true} implies {@code isUnique == false} and
1:0c5bc3a:      * {@code isUniqueWithDuplicateNulls == false} and
1:0c5bc3a:      * {@code hasDeferrableChecking == true}.
1:0c5bc3a:      */
1:0c5bc3a:     private boolean     isUniqueDeferrable;
1:0c5bc3a: 
1:0c5bc3a:     /**
1:0c5bc3a:      * The index represents a constraint which is deferrable.
1:0c5bc3a:      */
1:0c5bc3a:     private boolean     hasDeferrableChecking;
1:0c5bc3a: 
2:eac0369: 	/**
1:28e234d:      * Constructor for an IndexDescriptorImpl
1:28e234d:      * 
1:28e234d:      * @param indexType		The type of index
1:28e234d:      * @param isUnique		True means the index is unique
1:28e234d:      * @param isUniqueWithDuplicateNulls True means the index will be unique
1:28e234d:      *                              for non null values but duplicate nulls
1:28e234d:      *                              will be allowed.
1:28e234d:      *                              This parameter has no effect if the isUnique
1:28e234d:      *                              is true. If isUnique is false and 
1:28e234d:      *                              isUniqueWithDuplicateNulls is set to true the
1:28e234d:      *                              index will allow duplicate nulls but for
1:28e234d:      *                              non null keys will act like a unique index.
1:0c5bc3a:      * @param isUniqueDeferrable    True means the index represents a PRIMARY
1:0c5bc3a:      *                              KEY or a UNIQUE NOT NULL constraint which
1:0c5bc3a:      *                              is deferrable.
1:0c5bc3a:      * @param hasDeferrableChecking True if this index supports a deferrable
1:0c5bc3a:      *                              constraint.
1:28e234d:      * @param baseColumnPositions	An array of column positions in the base
1:28e234d:      * 								table.  Each index column corresponds to a
1:28e234d:      * 								column position in the base table.
1:28e234d:      * @param isAscending	An array of booleans telling asc/desc on each
1:28e234d:      * 						column.
1:28e234d:      * @param numberOfOrderedColumns	In the future, it will be possible
1:28e234d:      * 									to store non-ordered columns in an
1:28e234d:      * 									index.  These will be useful for
1:28e234d:      * 									covered queries.
1:28e234d:      */
1:eac0369: 	public IndexDescriptorImpl(String indexType,
1:eac0369: 								boolean isUnique,
1:28e234d: 								boolean isUniqueWithDuplicateNulls,
1:0c5bc3a:                                 boolean isUniqueDeferrable,
1:0c5bc3a:                                 boolean hasDeferrableChecking,
1:eac0369: 								int[] baseColumnPositions,
1:eac0369: 								boolean[] isAscending,
1:eac0369: 								int numberOfOrderedColumns)
1:eac0369: 	{
1:eac0369: 		this.indexType = indexType;
1:eac0369: 		this.isUnique = isUnique;
1:28e234d: 		this.isUniqueWithDuplicateNulls = isUniqueWithDuplicateNulls;
1:0c5bc3a:         this.isUniqueDeferrable = isUniqueDeferrable;
1:0c5bc3a:         this.hasDeferrableChecking = hasDeferrableChecking;
1:57465ef: 		this.baseColumnPositions = ArrayUtil.copy( baseColumnPositions );
1:57465ef: 		this.isAscending = ArrayUtil.copy( isAscending );
1:eac0369: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
2:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Zero-argument constructor for Formatable interface */
1:eac0369: 	public IndexDescriptorImpl()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:28e234d: 	/**
1:28e234d:      * 
1:28e234d:      * 
1:28e234d:      * @see IndexDescriptor#isUniqueWithDuplicateNulls
1:28e234d:      */
1:28e234d: 	public boolean isUniqueWithDuplicateNulls()
1:28e234d: 	{
1:28e234d: 		return isUniqueWithDuplicateNulls;
1:28e234d: 	}
1:28e234d: 
1:0c5bc3a:     /**
1:0c5bc3a:      *
1:0c5bc3a:      * @return  {@code true} is the index supports a deferrable constraint
1:0c5bc3a:      */
1:0c5bc3a:     public boolean hasDeferrableChecking()
1:0c5bc3a:     {
1:0c5bc3a:         return hasDeferrableChecking;
1:0c5bc3a:     }
1:0c5bc3a: 
1:0c5bc3a:     /**
1:0c5bc3a:      * The index represents a PRIMARY KEY or a UNIQUE NOT NULL constraint which
1:0c5bc3a:      * is deferrable.
1:0c5bc3a:      * {@code true} implies {@code #isUnique() == false} and
1:0c5bc3a:      * {@code #isUniqueWithDuplicateNulls() == false} and
1:0c5bc3a:      * {@code #hasDeferrableChecking() == true}.
1:0c5bc3a:      *
1:0c5bc3a:      * @return {@code true} is the index supports such a constraint
1:0c5bc3a:      */
1:0c5bc3a:     public boolean isUniqueDeferrable()
1:0c5bc3a:     {
1:0c5bc3a:         return isUniqueDeferrable;
1:0c5bc3a:     }
1:0c5bc3a: 
1:eac0369: 	/** @see IndexDescriptor#isUnique */
1:eac0369: 	public boolean isUnique()
1:eac0369: 	{
1:eac0369: 		return isUnique;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#baseColumnPositions */
1:eac0369: 	public int[] baseColumnPositions()
1:eac0369: 	{
1:57465ef:         return ArrayUtil.copy( baseColumnPositions );
1:eac0369: 	}
1:eac0369: 
2:eac0369: 	/** @see IndexDescriptor#getKeyColumnPosition */
1:eac0369: 	public int getKeyColumnPosition(int heapColumnPosition)
1:eac0369: 	{
1:eac0369: 		/* Return 0 if column is not in the key */
1:eac0369: 		int keyPosition = 0;
1:eac0369: 
1:eac0369: 		for (int index = 0; index < baseColumnPositions.length; index++)
1:eac0369: 		{
1:eac0369: 			/* Return 1-based key column position if column is in the key */
1:eac0369: 			if (baseColumnPositions[index] == heapColumnPosition)
1:eac0369: 			{
1:eac0369: 				keyPosition = index + 1;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return keyPosition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#numberOfOrderedColumns */
1:eac0369: 	public int numberOfOrderedColumns()
1:eac0369: 	{
1:eac0369: 		return numberOfOrderedColumns;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#indexType */
1:eac0369: 	public String indexType()
1:eac0369: 	{
1:eac0369: 		return indexType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isAscending */
1:eac0369: 	public boolean			isAscending(Integer keyColumnPosition)
1:eac0369: 	{
1:eac0369: 		int i = keyColumnPosition.intValue() - 1;
1:eac0369: 		if (i < 0 || i >= baseColumnPositions.length)
1:eac0369: 			return false;
1:eac0369: 		return isAscending[i];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isDescending */
1:eac0369: 	public boolean			isDescending(Integer keyColumnPosition)
1:eac0369: 	{
1:eac0369: 		int i = keyColumnPosition.intValue() - 1;
1:eac0369: 		if (i < 0 || i >= baseColumnPositions.length)
1:eac0369: 			return false;
1:eac0369: 		return ! isAscending[i];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isAscending */
1:eac0369: 	public boolean[]		isAscending()
1:eac0369: 	{
1:57465ef:         return ArrayUtil.copy( isAscending );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setBaseColumnPositions */
1:eac0369: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
1:eac0369: 	{
1:57465ef: 		this.baseColumnPositions = ArrayUtil.copy( baseColumnPositions );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setIsAscending */
1:eac0369: 	public void		setIsAscending(boolean[] isAscending)
1:eac0369: 	{
1:57465ef: 		this.isAscending = ArrayUtil.copy( isAscending );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
1:eac0369: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
1:eac0369: 	{
1:eac0369: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:b69f59c:         StringBuilder   sb = new StringBuilder(60);
1:eac0369: 
1:0c5bc3a:         if (isUnique || isUniqueDeferrable)
1:eac0369: 			sb.append("UNIQUE ");
1:28e234d: 		else if (isUniqueWithDuplicateNulls)
1:0c5bc3a:             sb.append ("UNIQUE WITH DUPLICATE NULLS ");
1:0c5bc3a: 
1:0c5bc3a:         if (hasDeferrableChecking) {
1:0c5bc3a:             sb.append(" DEFERRABLE CHECKING ");
1:0c5bc3a:         }
1:eac0369: 
1:eac0369: 		sb.append(indexType);
1:eac0369: 
1:eac0369: 		sb.append(" (");
1:eac0369: 
1:eac0369: 
1:eac0369: 		for (int i = 0; i < baseColumnPositions.length; i++)
1:eac0369: 		{
1:eac0369: 			if (i > 0)
1:eac0369: 				sb.append(", ");
1:eac0369: 			sb.append(baseColumnPositions[i]);
1:eac0369: 			if (! isAscending[i])
1:eac0369: 				sb.append(" DESC");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		sb.append(")");
1:eac0369: 
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Externalizable interface */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
2:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on read error
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		FormatableHashtable fh = (FormatableHashtable)in.readObject();
1:eac0369: 		isUnique = fh.getBoolean("isUnique");
1:eac0369: 		int bcpLength = fh.getInt("keyLength");
1:eac0369: 		baseColumnPositions = new int[bcpLength];
1:eac0369: 		isAscending = new boolean[bcpLength];
1:eac0369: 		for (int i = 0; i < bcpLength; i++)
1:eac0369: 		{
1:eac0369: 			baseColumnPositions[i] = fh.getInt("bcp" + i);
1:eac0369: 			isAscending[i] = fh.getBoolean("isAsc" + i);
1:eac0369: 		}
1:eac0369: 		numberOfOrderedColumns = fh.getInt("orderedColumns");
1:eac0369: 		indexType = (String)fh.get("indexType");
1:28e234d: 		//isUniqueWithDuplicateNulls attribute won't be present if the index
1:28e234d: 		//was created in older versions  
1:28e234d: 		if (fh.containsKey("isUniqueWithDuplicateNulls"))
1:28e234d: 			isUniqueWithDuplicateNulls = fh.getBoolean(
1:28e234d:                                     "isUniqueWithDuplicateNulls");
1:28e234d: 		else
1:28e234d: 			isUniqueWithDuplicateNulls = false;
1:0c5bc3a: 
1:0c5bc3a:         // hasDeferrableChecking won't be present if the index
1:0c5bc3a:         // was created in old versions (< 10_11).
1:0c5bc3a:         if (fh.containsKey("hasDeferrableChecking")) {
1:0c5bc3a:             hasDeferrableChecking = fh.getBoolean("hasDeferrableChecking");
1:0c5bc3a:         } else {
1:0c5bc3a:             hasDeferrableChecking = false;
1:0c5bc3a:         }
1:0c5bc3a: 
1:0c5bc3a:         // isUniqueDeferrable won't be present if the index
1:0c5bc3a:         // was created in old versions (< 10_11).
1:0c5bc3a:         if (fh.containsKey("isUniqueDeferrable")) {
1:0c5bc3a:             isUniqueDeferrable = fh.getBoolean("isUniqueDeferrable");
1:0c5bc3a:         } else {
1:0c5bc3a:             isUniqueDeferrable = false;
1:0c5bc3a:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#writeExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on write error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		FormatableHashtable fh = new FormatableHashtable();
1:eac0369: 		fh.putBoolean("isUnique", isUnique);
1:eac0369: 		fh.putInt("keyLength", baseColumnPositions.length);
1:eac0369: 		for (int i = 0; i < baseColumnPositions.length; i++)
1:eac0369: 		{
1:eac0369: 			fh.putInt("bcp" + i, baseColumnPositions[i]);
1:eac0369: 			fh.putBoolean("isAsc" + i, isAscending[i]);
1:eac0369: 		}
1:eac0369: 		fh.putInt("orderedColumns", numberOfOrderedColumns);
1:eac0369: 		fh.put("indexType", indexType);
1:28e234d: 		//write the new attribut older versions will simply ignore it
1:28e234d: 		fh.putBoolean("isUniqueWithDuplicateNulls", 
1:28e234d:                                         isUniqueWithDuplicateNulls);
1:0c5bc3a:         fh.putBoolean("hasDeferrableChecking", hasDeferrableChecking);
1:0c5bc3a:         fh.putBoolean("isUniqueDeferrable", isUniqueDeferrable);
1:28e234d:         out.writeObject(fh);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* TypedFormat interface */
1:eac0369: 	public int getTypeFormatId()
1:eac0369: 	{
1:eac0369: 		return StoredFormatIds.INDEX_DESCRIPTOR_IMPL_V02_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Test for value equality
1:eac0369: 	 *
1:eac0369: 	 * @param other		The other indexrowgenerator to compare this one with
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this indexrowgenerator has the same value as other
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public boolean equals(Object other)
1:eac0369: 	{
1:eac0369: 		/* Assume not equal until we know otherwise */
1:eac0369: 		boolean retval = false;
1:eac0369: 
1:eac0369: 		/* Equal only if comparing the same class */
1:eac0369: 		if (other instanceof IndexDescriptorImpl)
1:eac0369: 		{
1:eac0369: 			IndexDescriptorImpl id = (IndexDescriptorImpl) other;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Check all the fields for equality except for the array
1:eac0369: 			** elements (this is hardest, so save for last)
1:eac0369: 			*/
1:0efe521: 			if ((id.isUnique == this.isUnique)       &&
1:0efe521:                 (id.isUniqueWithDuplicateNulls == 
1:0efe521:                     this.isUniqueWithDuplicateNulls) &&
1:0efe521:                 (id.baseColumnPositions.length ==
1:0efe521:                     this.baseColumnPositions.length) &&
1:0efe521:                 (id.numberOfOrderedColumns     == 
1:0efe521:                     this.numberOfOrderedColumns)     &&
1:0efe521:                 (id.indexType.equals(this.indexType)))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** Everything but array elements known to be true -
1:eac0369: 				** Assume equal, and check whether array elements are equal.
1:eac0369: 				*/
1:eac0369: 				retval = true;
1:eac0369: 
1:eac0369: 				for (int i = 0; i < this.baseColumnPositions.length; i++)
1:eac0369: 				{
1:eac0369: 					/* If any array element is not equal, return false */
1:eac0369: 					if ((id.baseColumnPositions[i] !=
1:0efe521: 						 this.baseColumnPositions[i]) || 
1:0efe521:                         (id.isAscending[i] != this.isAscending[i]))
1:eac0369: 					{
1:eac0369: 						retval = false;
1:eac0369: 						break;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see java.lang.Object#hashCode
1:eac0369: 	  */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		int	retval;
1:eac0369: 
1:eac0369: 		retval = isUnique ? 1 : 2;
1:eac0369: 		retval *= numberOfOrderedColumns;
1:eac0369: 		for (int i = 0; i < baseColumnPositions.length; i++)
1:eac0369: 		{
1:eac0369: 			retval *= baseColumnPositions[i];
1:eac0369: 		}
1:eac0369: 		retval *= indexType.hashCode();
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b69f59c
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder   sb = new StringBuilder(60);
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * See also {@link org.apache.derby.iapi.sql.dictionary.IndexRowGenerator}.
1:  * <p>
1:  * For a description of how deferrable and non-deferrable constraints
1:  * are backed differently, including the meaning of the
1:  * boolean attributes used here, see {@link
1:  * org.apache.derby.catalog.IndexDescriptor}.
1:  */
/////////////////////////////////////////////////////////////////////////
1:     **  If, in between releases, you add more fields to this class,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The index represents a PRIMARY KEY or a UNIQUE NOT NULL constraint which
1:      * is deferrable.
1:      * {@code true} implies {@code isUnique == false} and
1:      * {@code isUniqueWithDuplicateNulls == false} and
1:      * {@code hasDeferrableChecking == true}.
1:      */
1:     private boolean     isUniqueDeferrable;
1: 
1:     /**
1:      * The index represents a constraint which is deferrable.
1:      */
1:     private boolean     hasDeferrableChecking;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param isUniqueDeferrable    True means the index represents a PRIMARY
1:      *                              KEY or a UNIQUE NOT NULL constraint which
1:      *                              is deferrable.
1:      * @param hasDeferrableChecking True if this index supports a deferrable
1:      *                              constraint.
/////////////////////////////////////////////////////////////////////////
1:                                 boolean isUniqueDeferrable,
1:                                 boolean hasDeferrableChecking,
/////////////////////////////////////////////////////////////////////////
1:         this.isUniqueDeferrable = isUniqueDeferrable;
1:         this.hasDeferrableChecking = hasDeferrableChecking;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *
1:      * @return  {@code true} is the index supports a deferrable constraint
1:      */
1:     public boolean hasDeferrableChecking()
1:     {
1:         return hasDeferrableChecking;
1:     }
1: 
1:     /**
1:      * The index represents a PRIMARY KEY or a UNIQUE NOT NULL constraint which
1:      * is deferrable.
1:      * {@code true} implies {@code #isUnique() == false} and
1:      * {@code #isUniqueWithDuplicateNulls() == false} and
1:      * {@code #hasDeferrableChecking() == true}.
1:      *
1:      * @return {@code true} is the index supports such a constraint
1:      */
1:     public boolean isUniqueDeferrable()
1:     {
1:         return isUniqueDeferrable;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isUnique || isUniqueDeferrable)
1:             sb.append ("UNIQUE WITH DUPLICATE NULLS ");
1: 
1:         if (hasDeferrableChecking) {
1:             sb.append(" DEFERRABLE CHECKING ");
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         // hasDeferrableChecking won't be present if the index
1:         // was created in old versions (< 10_11).
1:         if (fh.containsKey("hasDeferrableChecking")) {
1:             hasDeferrableChecking = fh.getBoolean("hasDeferrableChecking");
1:         } else {
1:             hasDeferrableChecking = false;
1:         }
1: 
1:         // isUniqueDeferrable won't be present if the index
1:         // was created in old versions (< 10_11).
1:         if (fh.containsKey("isUniqueDeferrable")) {
1:             isUniqueDeferrable = fh.getBoolean("isUniqueDeferrable");
1:         } else {
1:             isUniqueDeferrable = false;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         fh.putBoolean("hasDeferrableChecking", hasDeferrableChecking);
1:         fh.putBoolean("isUniqueDeferrable", isUniqueDeferrable);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:57465ef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 		this.baseColumnPositions = ArrayUtil.copy( baseColumnPositions );
1: 		this.isAscending = ArrayUtil.copy( isAscending );
/////////////////////////////////////////////////////////////////////////
1:         return ArrayUtil.copy( baseColumnPositions );
/////////////////////////////////////////////////////////////////////////
1:         return ArrayUtil.copy( isAscending );
1: 		this.baseColumnPositions = ArrayUtil.copy( baseColumnPositions );
1: 		this.isAscending = ArrayUtil.copy( isAscending );
commit:5c04fbc
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:0efe521
/////////////////////////////////////////////////////////////////////////
0: 			sb.append ("UNIQUE WITH DUPLICATE NULLS");
/////////////////////////////////////////////////////////////////////////
1: 			if ((id.isUnique == this.isUnique)       &&
1:                 (id.isUniqueWithDuplicateNulls == 
1:                     this.isUniqueWithDuplicateNulls) &&
1:                 (id.baseColumnPositions.length ==
1:                     this.baseColumnPositions.length) &&
1:                 (id.numberOfOrderedColumns     == 
1:                     this.numberOfOrderedColumns)     &&
1:                 (id.indexType.equals(this.indexType)))
/////////////////////////////////////////////////////////////////////////
1: 						 this.baseColumnPositions[i]) || 
1:                         (id.isAscending[i] != this.isAscending[i]))
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1: 	//attribute to indicate the indicates allows duplicate only in
1: 	//case of non null keys. This attribute has no effect if the isUnique
1:     //is true. If isUnique is false and isUniqueWithDuplicateNulls is set 
1:     //to true the index will allow duplicate nulls but for non null keys 
1:     //will act like a unique index.
1: 	private boolean     isUniqueWithDuplicateNulls;
1:      * Constructor for an IndexDescriptorImpl
1:      * 
1:      * @param indexType		The type of index
1:      * @param isUnique		True means the index is unique
1:      * @param isUniqueWithDuplicateNulls True means the index will be unique
1:      *                              for non null values but duplicate nulls
1:      *                              will be allowed.
1:      *                              This parameter has no effect if the isUnique
1:      *                              is true. If isUnique is false and 
1:      *                              isUniqueWithDuplicateNulls is set to true the
1:      *                              index will allow duplicate nulls but for
1:      *                              non null keys will act like a unique index.
1:      * @param baseColumnPositions	An array of column positions in the base
1:      * 								table.  Each index column corresponds to a
1:      * 								column position in the base table.
1:      * @param isAscending	An array of booleans telling asc/desc on each
1:      * 						column.
1:      * @param numberOfOrderedColumns	In the future, it will be possible
1:      * 									to store non-ordered columns in an
1:      * 									index.  These will be useful for
1:      * 									covered queries.
1:      */
1: 								boolean isUniqueWithDuplicateNulls,
1: 		this.isUniqueWithDuplicateNulls = isUniqueWithDuplicateNulls;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1:      * 
1:      * 
1:      * @see IndexDescriptor#isUniqueWithDuplicateNulls
1:      */
1: 	public boolean isUniqueWithDuplicateNulls()
1: 	{
1: 		return isUniqueWithDuplicateNulls;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		else if (isUniqueWithDuplicateNulls)
0: 			sb.append ("ALMOST UNIQUE");
/////////////////////////////////////////////////////////////////////////
1: 		//isUniqueWithDuplicateNulls attribute won't be present if the index
1: 		//was created in older versions  
1: 		if (fh.containsKey("isUniqueWithDuplicateNulls"))
1: 			isUniqueWithDuplicateNulls = fh.getBoolean(
1:                                     "isUniqueWithDuplicateNulls");
1: 		else
1: 			isUniqueWithDuplicateNulls = false;
/////////////////////////////////////////////////////////////////////////
1: 		//write the new attribut older versions will simply ignore it
1: 		fh.putBoolean("isUniqueWithDuplicateNulls", 
1:                                         isUniqueWithDuplicateNulls);
1:         out.writeObject(fh);
/////////////////////////////////////////////////////////////////////////
0: 				(id.isUnique == this.isUnique) &&
0: 					(id.indexType.equals(this.indexType)))
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:48d2629
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.catalog.types.IndexDescriptorImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.catalog.types;
1: 
1: import org.apache.derby.catalog.IndexDescriptor;
1: 
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.io.FormatableHashtable;
1: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1: 
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.io.IOException;
1: 
0: /** @see IndexRowGenerator */
1: public class IndexDescriptorImpl implements IndexDescriptor, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. That means that it
1: 	**	can write itself to and from a formatted stream. If
1: 	**	you add more fields to this class, make sure that you
1: 	**	also write/read them with the writeExternal()/readExternal()
1: 	**	methods.
1: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
1: 	**	then you should bump the version number emitted by the getTypeFormatId()
1: 	**	method.
1: 	**
1: 	********************************************************/
1: 
1: 	private boolean		isUnique;
1: 	private int[]		baseColumnPositions;
1: 	private boolean[]	isAscending;
1: 	private int			numberOfOrderedColumns;
1: 	private String		indexType;
1: 
1: 	/**
0: 	 * Constructor for an IndexDescriptorImpl
1: 	 *
0: 	 * @param indexType		The type of index
0: 	 * @param isUnique		True means the index is unique
0: 	 * @param baseColumnPositions	An array of column positions in the base
0: 	 *								table.  Each index column corresponds to a
0: 	 *								column position in the base table.
0: 	 * @param isAscending	An array of booleans telling asc/desc on each
0: 	 *						column.
0: 	 * @param numberOfOrderedColumns	In the future, it will be possible
0: 	 *									to store non-ordered columns in an
0: 	 *									index.  These will be useful for
0: 	 *									covered queries.
1: 	 */
1: 	public IndexDescriptorImpl(String indexType,
1: 								boolean isUnique,
1: 								int[] baseColumnPositions,
1: 								boolean[] isAscending,
1: 								int numberOfOrderedColumns)
1: 	{
1: 		this.indexType = indexType;
1: 		this.isUnique = isUnique;
0: 		this.baseColumnPositions = baseColumnPositions;
0: 		this.isAscending = isAscending;
1: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
1: 	}
1: 
1: 	/** Zero-argument constructor for Formatable interface */
1: 	public IndexDescriptorImpl()
1: 	{
1: 	}
1: 
1: 	/** @see IndexDescriptor#isUnique */
1: 	public boolean isUnique()
1: 	{
1: 		return isUnique;
1: 	}
1: 
1: 	/** @see IndexDescriptor#baseColumnPositions */
1: 	public int[] baseColumnPositions()
1: 	{
0: 		return baseColumnPositions;
1: 	}
1: 
1: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public Integer getKeyColumnPosition(Integer heapColumnPosition)
1: 	{
0: 		return new Integer(getKeyColumnPosition(heapColumnPosition.intValue()));
1: 	}
1: 
1: 	/** @see IndexDescriptor#getKeyColumnPosition */
1: 	public int getKeyColumnPosition(int heapColumnPosition)
1: 	{
1: 		/* Return 0 if column is not in the key */
1: 		int keyPosition = 0;
1: 
1: 		for (int index = 0; index < baseColumnPositions.length; index++)
1: 		{
1: 			/* Return 1-based key column position if column is in the key */
1: 			if (baseColumnPositions[index] == heapColumnPosition)
1: 			{
1: 				keyPosition = index + 1;
1: 				break;
1: 			}
1: 		}
1: 
1: 		return keyPosition;
1: 	}
1: 
1: 	/** @see IndexDescriptor#numberOfOrderedColumns */
1: 	public int numberOfOrderedColumns()
1: 	{
1: 		return numberOfOrderedColumns;
1: 	}
1: 
1: 	/** @see IndexDescriptor#indexType */
1: 	public String indexType()
1: 	{
1: 		return indexType;
1: 	}
1: 
1: 	/** @see IndexDescriptor#isAscending */
1: 	public boolean			isAscending(Integer keyColumnPosition)
1: 	{
1: 		int i = keyColumnPosition.intValue() - 1;
1: 		if (i < 0 || i >= baseColumnPositions.length)
1: 			return false;
1: 		return isAscending[i];
1: 	}
1: 
1: 	/** @see IndexDescriptor#isDescending */
1: 	public boolean			isDescending(Integer keyColumnPosition)
1: 	{
1: 		int i = keyColumnPosition.intValue() - 1;
1: 		if (i < 0 || i >= baseColumnPositions.length)
1: 			return false;
1: 		return ! isAscending[i];
1: 	}
1: 
1: 	/** @see IndexDescriptor#isAscending */
1: 	public boolean[]		isAscending()
1: 	{
0: 		return isAscending;
1: 	}
1: 
1: 	/** @see IndexDescriptor#setBaseColumnPositions */
1: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
1: 	{
0: 		this.baseColumnPositions = baseColumnPositions;
1: 	}
1: 
1: 	/** @see IndexDescriptor#setIsAscending */
1: 	public void		setIsAscending(boolean[] isAscending)
1: 	{
0: 		this.isAscending = isAscending;
1: 	}
1: 
1: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
1: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
1: 	{
1: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
1: 	}
1: 
1: 	public String toString()
1: 	{
0: 		String	uniqueness;
0: 		String	cols;
1: 
0: 		StringBuffer	sb = new StringBuffer(60);
1: 
0: 		if (isUnique)
1: 			sb.append("UNIQUE ");
1: 
1: 		sb.append(indexType);
1: 
1: 		sb.append(" (");
1: 
1: 
1: 		for (int i = 0; i < baseColumnPositions.length; i++)
1: 		{
1: 			if (i > 0)
1: 				sb.append(", ");
1: 			sb.append(baseColumnPositions[i]);
1: 			if (! isAscending[i])
1: 				sb.append(" DESC");
1: 		}
1: 
1: 		sb.append(")");
1: 
1: 		return sb.toString();
1: 	}
1: 
1: 	/* Externalizable interface */
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on read error
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
1: 	{
1: 		FormatableHashtable fh = (FormatableHashtable)in.readObject();
1: 		isUnique = fh.getBoolean("isUnique");
1: 		int bcpLength = fh.getInt("keyLength");
1: 		baseColumnPositions = new int[bcpLength];
1: 		isAscending = new boolean[bcpLength];
1: 		for (int i = 0; i < bcpLength; i++)
1: 		{
1: 			baseColumnPositions[i] = fh.getInt("bcp" + i);
1: 			isAscending[i] = fh.getBoolean("isAsc" + i);
1: 		}
1: 		numberOfOrderedColumns = fh.getInt("orderedColumns");
1: 		indexType = (String)fh.get("indexType");
1: 	}
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#writeExternal
1: 	 *
1: 	 * @exception IOException	Thrown on write error
1: 	 */
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 		FormatableHashtable fh = new FormatableHashtable();
1: 		fh.putBoolean("isUnique", isUnique);
1: 		fh.putInt("keyLength", baseColumnPositions.length);
1: 		for (int i = 0; i < baseColumnPositions.length; i++)
1: 		{
1: 			fh.putInt("bcp" + i, baseColumnPositions[i]);
1: 			fh.putBoolean("isAsc" + i, isAscending[i]);
1: 		}
1: 		fh.putInt("orderedColumns", numberOfOrderedColumns);
1: 		fh.put("indexType", indexType);
0: 		out.writeObject(fh);
1: 	}
1: 
1: 	/* TypedFormat interface */
1: 	public int getTypeFormatId()
1: 	{
1: 		return StoredFormatIds.INDEX_DESCRIPTOR_IMPL_V02_ID;
1: 	}
1: 
1: 	/**
1: 	 * Test for value equality
1: 	 *
1: 	 * @param other		The other indexrowgenerator to compare this one with
1: 	 *
1: 	 * @return	true if this indexrowgenerator has the same value as other
1: 	 */
1: 
1: 	public boolean equals(Object other)
1: 	{
1: 		/* Assume not equal until we know otherwise */
1: 		boolean retval = false;
1: 
1: 		/* Equal only if comparing the same class */
1: 		if (other instanceof IndexDescriptorImpl)
1: 		{
1: 			IndexDescriptorImpl id = (IndexDescriptorImpl) other;
1: 
1: 			/*
1: 			** Check all the fields for equality except for the array
1: 			** elements (this is hardest, so save for last)
1: 			*/
0: 			if ((id.isUnique == this.isUnique) &&
0: 				(id.baseColumnPositions.length ==
0: 										this.baseColumnPositions.length) &&
0: 				(id.numberOfOrderedColumns == this.numberOfOrderedColumns) &&
0: 				(id.indexType.equals(this.indexType)))
1: 			{
1: 				/*
1: 				** Everything but array elements known to be true -
1: 				** Assume equal, and check whether array elements are equal.
1: 				*/
1: 				retval = true;
1: 
1: 				for (int i = 0; i < this.baseColumnPositions.length; i++)
1: 				{
1: 					/* If any array element is not equal, return false */
1: 					if ((id.baseColumnPositions[i] !=
0: 						this.baseColumnPositions[i]) || (id.isAscending[i] !=
0: 						this.isAscending[i]))
1: 					{
1: 						retval = false;
1: 						break;
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	  @see java.lang.Object#hashCode
1: 	  */
1: 	public int hashCode()
1: 	{
1: 		int	retval;
1: 
1: 		retval = isUnique ? 1 : 2;
1: 		retval *= numberOfOrderedColumns;
1: 		for (int i = 0; i < baseColumnPositions.length; i++)
1: 		{
1: 			retval *= baseColumnPositions[i];
1: 		}
1: 		retval *= indexType.hashCode();
1: 
1: 		return retval;
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: /** @see org.apache.derby.iapi.sql.dictionary.IndexRowGenerator */
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.catalog.types;
0: 
0: import org.apache.derby.catalog.IndexDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: 
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.io.IOException;
0: 
0: /** @see IndexRowGenerator */
0: public class IndexDescriptorImpl implements IndexDescriptor, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. That means that it
0: 	**	can write itself to and from a formatted stream. If
0: 	**	you add more fields to this class, make sure that you
0: 	**	also write/read them with the writeExternal()/readExternal()
0: 	**	methods.
0: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
0: 	**	then you should bump the version number emitted by the getTypeFormatId()
0: 	**	method.
0: 	**
0: 	********************************************************/
0: 
0: 	private boolean		isUnique;
0: 	private int[]		baseColumnPositions;
0: 	private boolean[]	isAscending;
0: 	private int			numberOfOrderedColumns;
0: 	private String		indexType;
0: 
0: 	/**
0: 	 * Constructor for an IndexDescriptorImpl
0: 	 *
0: 	 * @param indexType		The type of index
0: 	 * @param isUnique		True means the index is unique
0: 	 * @param baseColumnPositions	An array of column positions in the base
0: 	 *								table.  Each index column corresponds to a
0: 	 *								column position in the base table.
0: 	 * @param isAscending	An array of booleans telling asc/desc on each
0: 	 *						column.
0: 	 * @param numberOfOrderedColumns	In the future, it will be possible
0: 	 *									to store non-ordered columns in an
0: 	 *									index.  These will be useful for
0: 	 *									covered queries.
0: 	 */
0: 	public IndexDescriptorImpl(String indexType,
0: 								boolean isUnique,
0: 								int[] baseColumnPositions,
0: 								boolean[] isAscending,
0: 								int numberOfOrderedColumns)
0: 	{
0: 		this.indexType = indexType;
0: 		this.isUnique = isUnique;
0: 		this.baseColumnPositions = baseColumnPositions;
0: 		this.isAscending = isAscending;
0: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
0: 	}
0: 
0: 	/** Zero-argument constructor for Formatable interface */
0: 	public IndexDescriptorImpl()
0: 	{
0: 	}
0: 
0: 	/** @see IndexDescriptor#isUnique */
0: 	public boolean isUnique()
0: 	{
0: 		return isUnique;
0: 	}
0: 
0: 	/** @see IndexDescriptor#baseColumnPositions */
0: 	public int[] baseColumnPositions()
0: 	{
0: 		return baseColumnPositions;
0: 	}
0: 
0: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public Integer getKeyColumnPosition(Integer heapColumnPosition)
0: 	{
0: 		return new Integer(getKeyColumnPosition(heapColumnPosition.intValue()));
0: 	}
0: 
0: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public int getKeyColumnPosition(int heapColumnPosition)
0: 	{
0: 		/* Return 0 if column is not in the key */
0: 		int keyPosition = 0;
0: 
0: 		for (int index = 0; index < baseColumnPositions.length; index++)
0: 		{
0: 			/* Return 1-based key column position if column is in the key */
0: 			if (baseColumnPositions[index] == heapColumnPosition)
0: 			{
0: 				keyPosition = index + 1;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return keyPosition;
0: 	}
0: 
0: 	/** @see IndexDescriptor#numberOfOrderedColumns */
0: 	public int numberOfOrderedColumns()
0: 	{
0: 		return numberOfOrderedColumns;
0: 	}
0: 
0: 	/** @see IndexDescriptor#indexType */
0: 	public String indexType()
0: 	{
0: 		return indexType;
0: 	}
0: 
0: 	/** @see IndexDescriptor#isAscending */
0: 	public boolean			isAscending(Integer keyColumnPosition)
0: 	{
0: 		int i = keyColumnPosition.intValue() - 1;
0: 		if (i < 0 || i >= baseColumnPositions.length)
0: 			return false;
0: 		return isAscending[i];
0: 	}
0: 
0: 	/** @see IndexDescriptor#isDescending */
0: 	public boolean			isDescending(Integer keyColumnPosition)
0: 	{
0: 		int i = keyColumnPosition.intValue() - 1;
0: 		if (i < 0 || i >= baseColumnPositions.length)
0: 			return false;
0: 		return ! isAscending[i];
0: 	}
0: 
0: 	/** @see IndexDescriptor#isAscending */
0: 	public boolean[]		isAscending()
0: 	{
0: 		return isAscending;
0: 	}
0: 
0: 	/** @see IndexDescriptor#setBaseColumnPositions */
0: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
0: 	{
0: 		this.baseColumnPositions = baseColumnPositions;
0: 	}
0: 
0: 	/** @see IndexDescriptor#setIsAscending */
0: 	public void		setIsAscending(boolean[] isAscending)
0: 	{
0: 		this.isAscending = isAscending;
0: 	}
0: 
0: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
0: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
0: 	{
0: 		this.numberOfOrderedColumns = numberOfOrderedColumns;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		String	uniqueness;
0: 		String	cols;
0: 
0: 		StringBuffer	sb = new StringBuffer(60);
0: 
0: 		if (isUnique)
0: 			sb.append("UNIQUE ");
0: 
0: 		sb.append(indexType);
0: 
0: 		sb.append(" (");
0: 
0: 
0: 		for (int i = 0; i < baseColumnPositions.length; i++)
0: 		{
0: 			if (i > 0)
0: 				sb.append(", ");
0: 			sb.append(baseColumnPositions[i]);
0: 			if (! isAscending[i])
0: 				sb.append(" DESC");
0: 		}
0: 
0: 		sb.append(")");
0: 
0: 		return sb.toString();
0: 	}
0: 
0: 	/* Externalizable interface */
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on read error
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
0: 	{
0: 		FormatableHashtable fh = (FormatableHashtable)in.readObject();
0: 		isUnique = fh.getBoolean("isUnique");
0: 		int bcpLength = fh.getInt("keyLength");
0: 		baseColumnPositions = new int[bcpLength];
0: 		isAscending = new boolean[bcpLength];
0: 		for (int i = 0; i < bcpLength; i++)
0: 		{
0: 			baseColumnPositions[i] = fh.getInt("bcp" + i);
0: 			isAscending[i] = fh.getBoolean("isAsc" + i);
0: 		}
0: 		numberOfOrderedColumns = fh.getInt("orderedColumns");
0: 		indexType = (String)fh.get("indexType");
0: 	}
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#writeExternal
0: 	 *
0: 	 * @exception IOException	Thrown on write error
0: 	 */
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 		FormatableHashtable fh = new FormatableHashtable();
0: 		fh.putBoolean("isUnique", isUnique);
0: 		fh.putInt("keyLength", baseColumnPositions.length);
0: 		for (int i = 0; i < baseColumnPositions.length; i++)
0: 		{
0: 			fh.putInt("bcp" + i, baseColumnPositions[i]);
0: 			fh.putBoolean("isAsc" + i, isAscending[i]);
0: 		}
0: 		fh.putInt("orderedColumns", numberOfOrderedColumns);
0: 		fh.put("indexType", indexType);
0: 		out.writeObject(fh);
0: 	}
0: 
0: 	/* TypedFormat interface */
0: 	public int getTypeFormatId()
0: 	{
0: 		return StoredFormatIds.INDEX_DESCRIPTOR_IMPL_V02_ID;
0: 	}
0: 
0: 	/**
0: 	 * Test for value equality
0: 	 *
0: 	 * @param other		The other indexrowgenerator to compare this one with
0: 	 *
0: 	 * @return	true if this indexrowgenerator has the same value as other
0: 	 */
0: 
0: 	public boolean equals(Object other)
0: 	{
0: 		/* Assume not equal until we know otherwise */
0: 		boolean retval = false;
0: 
0: 		/* Equal only if comparing the same class */
0: 		if (other instanceof IndexDescriptorImpl)
0: 		{
0: 			IndexDescriptorImpl id = (IndexDescriptorImpl) other;
0: 
0: 			/*
0: 			** Check all the fields for equality except for the array
0: 			** elements (this is hardest, so save for last)
0: 			*/
0: 			if ((id.isUnique == this.isUnique) &&
0: 				(id.baseColumnPositions.length ==
0: 										this.baseColumnPositions.length) &&
0: 				(id.numberOfOrderedColumns == this.numberOfOrderedColumns) &&
0: 				(id.indexType.equals(this.indexType)))
0: 			{
0: 				/*
0: 				** Everything but array elements known to be true -
0: 				** Assume equal, and check whether array elements are equal.
0: 				*/
0: 				retval = true;
0: 
0: 				for (int i = 0; i < this.baseColumnPositions.length; i++)
0: 				{
0: 					/* If any array element is not equal, return false */
0: 					if ((id.baseColumnPositions[i] !=
0: 						this.baseColumnPositions[i]) || (id.isAscending[i] !=
0: 						this.isAscending[i]))
0: 					{
0: 						retval = false;
0: 						break;
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	  @see java.lang.Object#hashCode
0: 	  */
0: 	public int hashCode()
0: 	{
0: 		int	retval;
0: 
0: 		retval = isUnique ? 1 : 2;
0: 		retval *= numberOfOrderedColumns;
0: 		for (int i = 0; i < baseColumnPositions.length; i++)
0: 		{
0: 			retval *= baseColumnPositions[i];
0: 		}
0: 		retval *= indexType.hashCode();
0: 
0: 		return retval;
0: 	}
0: }
============================================================================