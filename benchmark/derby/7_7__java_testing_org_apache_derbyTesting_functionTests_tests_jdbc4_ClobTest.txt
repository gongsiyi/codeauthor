3:125c328: /*
1:a4846de: 
1:67f1fdd:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ClobTest
1:a4846de: 
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:a4846de: 
1:a4846de:       http://www.apache.org/licenses/LICENSE-2.0
1:a4846de: 
1:a4846de:    Unless required by applicable law or agreed to in writing, software
1:a4846de:    distributed under the License is distributed on an "AS IS" BASIS,
1:a4846de:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a4846de:    See the License for the specific language governing permissions and
1:a4846de:    limitations under the License.
1:a4846de: 
1:a4846de:  */
1:a4846de: 
1:a4846de: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:a4846de: 
1:a4846de: import junit.framework.*;
1:a4846de: 
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:a4846de: 
1:a4846de: import java.sql.*;
1:125c328: import java.io.*;
1:125c328: import java.lang.reflect.*;
1:125c328: import java.util.*;
1:125c328: 
1:125c328: /* This class is used to store the details of the methods that
1:125c328:  * throw a SQLFeatureNotSupportedException in the implementation
1:125c328:  * of java.sql.Clob.
1:125c328:  *
1:125c328:  * It store the following information about the methods
1:125c328:  *
1:125c328:  * a) Name
1:125c328:  * b) Method Parameters
1:125c328:  * c) Whether the method is exempted in the Embedded Sever
1:125c328:  * d) Whether the method is exempted in the NetworkClient
1:125c328:  *
1:125c328:  */
1:aeb4325: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:f697326: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:f697326: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:125c328: class ExemptClobMD {
1:67f1fdd:     /** The Name of the method. */
1:125c328:     private String methodName_;
1:125c328: 
1:67f1fdd:     /** The parameters of the method. */
1:125c328:     private Class [] params_;
1:125c328: 
1:67f1fdd:     /** Tells if exempted in the client framework. */
1:125c328:     private boolean isClientFramework_;
1:67f1fdd:     /** Tells if exempted in the embedded framework. */
1:125c328:     private boolean isEmbeddedFramework_;
1:125c328: 
1:125c328:     /**
1:125c328:      * The Constructor for the ExemptClobMD class that
1:125c328:      * initialized the object with the details of the
1:125c328:      * methods that have been exempted
1:125c328:      *
1:125c328:      * @param methodName          A String that contains the name of the method
1:125c328:      *                            that has been exempted.
1:125c328:      * @param params              A array of Class that contains the parameters
1:125c328:      *                            of the methods.
1:125c328:      * @param isClientFramework   true if the method is exempted in the
1:125c328:      *                            Client framework.
1:125c328:      * @param isEmbeddedFramework true if the method is exempted in the
1:125c328:      *                            Embedded framework.
1:125c328:      */
1:125c328:     public ExemptClobMD(String methodName,Class [] params,
1:125c328:                             boolean isClientFramework,
1:125c328:                             boolean isEmbeddedFramework) {
1:125c328:         methodName_ = methodName;
1:125c328:         params_ = params;
1:125c328:         isClientFramework_ = isClientFramework;
1:125c328:         isEmbeddedFramework_ = isEmbeddedFramework;
1:125c328:     }
1:125c328: 
1:125c328:     /**
1:125c328:      *
1:125c328:      * Returns the name of the method.
1:125c328:      *
1:125c328:      * @return A String containing the name of the method.
1:125c328:      *
1:125c328:      */
1:125c328:     public String getMethodName() { return methodName_; }
1:125c328: 
1:125c328:     /**
1:125c328:      * Returns a array of Class containing the type of the parameters
1:125c328:      * of this method.
1:125c328:      *
1:125c328:      * @return A array of Class containing the type of the parameters
1:125c328:      *         of the method.
1:125c328:      */
1:125c328:     public Class [] getParams() { return params_; }
1:125c328: 
1:125c328:     /**
1:125c328:      * Returns if the method is exempted from the Client Framework.
1:125c328:      *
1:125c328:      * @return true if the method is exempted from the Client Framework.
1:125c328:      */
1:125c328:     public boolean getIfClientFramework() { return isClientFramework_; }
1:125c328: 
1:125c328:     /**
1:125c328:      * Returns if the method is exempted from the Embedded Framework.
1:125c328:      *
1:125c328:      * @return true if the method is exempted from the Embedded Framework.
1:125c328:      */
1:125c328:     public boolean getIfEmbeddedFramework() { return isEmbeddedFramework_; }
1:125c328: }
1:125c328: 
1:125c328: /*
1:a4846de:  * Tests of the JDBC 4.0 specific <code>Clob</code> methods.
1:a4846de:  */
1:a4846de: public class ClobTest
1:a4846de:     extends BaseJDBCTestCase {
1:a4846de: 
1:a4846de:     /** Default Clob object used by the tests. */
1:a4846de:     private Clob clob = null;
1:a4846de: 
1:125c328:     // Initialize with the details of the method that are exempted from
1:125c328:     //throwing a SQLException when they are called after calling free()
1:125c328:     //on a LOB.
1:125c328: 
1:9b52936:     private static final ExemptClobMD [] emd = new ExemptClobMD [] {
1:67f1fdd:         new ExemptClobMD( "getCharacterStream",
1:67f1fdd:                 new Class[] { long.class, long.class } ,true,true),
1:67f1fdd:         new ExemptClobMD( "setString",
1:67f1fdd:                 new Class[] { long.class, String.class } ,false,true),
1:67f1fdd:         new ExemptClobMD( "truncate",
1:67f1fdd:                 new Class[] { long.class },false,true),
1:67f1fdd:         new ExemptClobMD( "free",
1:67f1fdd:                 null,true,true)
1:125c328:     };
1:125c328: 
1:125c328:     // An HashMap that is indexed by the Method which facilitated easy
1:125c328:     //search for whether the given method has been exempted from the
1:125c328:     //LOB interface.
1:125c328: 
1:125c328:     private HashMap<Method,ExemptClobMD> excludedMethodSet =
1:125c328:                             new HashMap<Method,ExemptClobMD>();
1:125c328: 
1:125c328:     /**
1:a4846de:      * Create the test with the given name.
1:125c328:      *
1:a4846de:      * @param name name of the test.
1:a4846de:      */
1:a4846de:     public ClobTest(String name) {
1:a4846de:         super(name);
1:a4846de:     }
1:a4846de: 
1:a4846de:     public void setUp()
1:125c328:         throws SQLException {
1:d3e6a71:         // Life span of Clob objects are limited by the transaction.  Need
1:d3e6a71:         // autocommit off so Clob objects survive closing of result set.
1:d3e6a71:         getConnection().setAutoCommit(false);
1:a4846de:     }
1:125c328: 
1:9b52936:     protected void tearDown() throws Exception {
1:f697326:         if (clob != null) {
1:9b52936:             clob.free();
1:a4846de:             clob = null;
1:a4846de:         }
1:9b52936:         excludedMethodSet = null;
1:9b52936:         super.tearDown();
1:a4846de:     }
1:a4846de: 
1:a4846de:     /**
1:125c328:      * Builds the HashSet which will be used to test whether the given methods
1:125c328:      * can be exempted or not
1:125c328:      */
1:125c328:     void buildHashSet() {
1:0f26c83:         Class<Clob> iface = Clob.class;
1:125c328:         for(int i=0;i<emd.length;i++) {
1:125c328:             try {
1:125c328:                 Method m = iface.getMethod(emd[i].getMethodName()
1:125c328:                                                 ,emd[i].getParams());
1:125c328:                 excludedMethodSet.put(m,emd[i]);
1:125c328:             }
1:125c328:             catch(NoSuchMethodException nsme) {
1:125c328:                 fail("The method could not be found in the interface");
1:125c328:             }
1:a4846de:         }
1:a4846de:     }
1:a4846de: 
1:125c328:     /**
1:45a4a1d:      * Tests free() after implicit free
1:125c328:      *
1:45a4a1d:      * @throws SQLException if an error occurs during free
1:a4846de:      *        
1:45a4a1d:      */
1:45a4a1d:     public void testFreeAfterImplicitFree()  throws SQLException
1:45a4a1d:     {
1:45a4a1d:         Connection conn = getConnection();
1:45a4a1d:         clob = BlobClobTestSetup.getSampleClob(conn);
1:45a4a1d:         conn.commit();
1:45a4a1d:         // DERBY-5605
1:45a4a1d:         // free should not throw an exception even though it was 
1:45a4a1d:         // implicitly freed with the commit.
1:a4846de:         clob.free();
1:a4846de:         
1:a4846de:     }
1:a4846de: 
1:a4846de:     /**
1:125c328:      * Tests the implementation for the free() method in the
1:125c328:      * Clob interface.
1:125c328:      *
1:125c328:      * @throws SQLException if an error occurs during releasing
1:125c328:      *         the Clob resources
1:125c328:      *
1:125c328:      */
1:125c328:     public void testFreeandMethodsAfterCallingFree()
1:67f1fdd:           throws IllegalAccessException, InvocationTargetException, SQLException
1:f697326:     {
1:f697326:         clob = BlobClobTestSetup.getSampleClob(getConnection());
1:a4846de: 
1:125c328:         //call the buildHashSetMethod to initialize the
1:125c328:         //HashSet with the method signatures that are exempted
1:125c328:         //from throwing a SQLException after free has been called
1:125c328:         //on the Clob object.
1:125c328:         buildHashSet();
1:a4846de: 
1:125c328:         InputStream asciiStream = clob.getAsciiStream();
1:f697326:         Reader charStream = clob.getCharacterStream();
1:125c328:         clob.free();
1:125c328:         //testing the idempotence of the free() method
1:125c328:         //the method can be called multiple times on
1:125c328: 
1:125c328:         //the first are treated as no-ops
1:125c328:         clob.free();
1:125c328: 
1:125c328: 
1:125c328:         //to the free method so testing calling
1:125c328:         //a method on this invalid object should throw
1:125c328:         //an SQLException
1:125c328:         buildMethodList(clob);
1:125c328:     }
1:125c328: 
1:45a4a1d:     /**
1:125c328:      * Enumerate the methods of the Clob interface and
1:125c328:      * get the list of methods present in the interface
1:125c328:      * @param LOB an instance of the Clob interface implementation
1:125c328:      */
1:a78e683:     void buildMethodList(Object LOB)
1:a78e683:             throws IllegalAccessException, InvocationTargetException {
1:125c328:         //If the given method throws the correct exception
1:125c328:         //set this to true and add it to the
1:125c328:         boolean valid = true;
1:125c328: 
1:125c328:         //create a list of the methods that fail the test
1:125c328:         Vector<Method> methodList = new Vector<Method>();
1:125c328: 
1:125c328:         //The class whose methods are to be verified
1:125c328:         Class clazz = Clob.class;
1:125c328: 
1:125c328:         //The list of the methods in the class that need to be invoked
1:125c328:         //and verified
1:125c328:         Method [] methods = clazz.getMethods();
1:125c328: 
1:125c328:         //Check each of the methods to ensure that
1:125c328:         //they throw the required exception
1:125c328:         for(int i=0;i<methods.length;i++) {
1:125c328:             if(!checkIfExempted(methods[i])) {
1:125c328:                 valid = checkIfMethodThrowsSQLException(LOB,methods[i]);
1:125c328: 
1:125c328:                 //add the method to the list if the method does
1:125c328:                 //not throw the required exception
1:125c328:                 if(valid == false) methodList.add(methods[i]);
1:125c328: 
1:125c328:                 //reset valid
1:125c328:                 valid = true;
1:125c328:             }
1:125c328:         }
1:125c328: 
1:125c328:         if(!methodList.isEmpty()) {
1:125c328:             int c=0;
1:125c328:             String failureMessage = "The Following methods don't throw " +
1:125c328:                 "required exception - ";
1:125c328:             for (Method m : methodList) {
1:125c328:                 c = c + 1;
1:125c328:                 if(c == methodList.size() && c != 1)
1:125c328:                     failureMessage += " & ";
1:125c328:                 else if(c != 1)
1:125c328:                     failureMessage += " , ";
1:125c328:                 failureMessage += m.getName();
1:125c328:             }
1:125c328:             fail(failureMessage);
1:125c328:         }
1:125c328:     }
1:125c328: 
1:125c328:     /**
1:a78e683:      * Checks if the method is to be exempted from testing or not.
1:125c328:      *
1:a78e683:      * @param m the method to check for exemption
1:a78e683:      * @return <code>false</code> if the method shall be tested,
1:a78e683:      *      <code>true</code> if the method is exempted and shall not be tested.
1:125c328:      */
1:125c328:     boolean checkIfExempted(Method m) {
1:125c328:         ExemptClobMD md = excludedMethodSet.get(m);
1:a78e683:         boolean isExempted = false;
1:a78e683:         if (md != null) {
1:a78e683:             if (usingDerbyNetClient()) {
1:a78e683:                 isExempted = md.getIfClientFramework();
1:a78e683:             } else if (usingEmbedded()) {
1:a78e683:                 isExempted = md.getIfEmbeddedFramework();
1:125c328:             } else {
1:a78e683:                 fail("Unknown test environment/framework");
1:125c328:             }
1:125c328:         }
1:a78e683:         return isExempted;
1:125c328:     }
1:125c328: 
1:67f1fdd:     /**
1:125c328:      * Checks if the invocation of the method throws a SQLExceptio
1:125c328:      * as expected.
1:125c328:      * @param LOB    the Object that implements the Blob interface
1:125c328:      * @param method the method that needs to be tested to ensure
1:125c328:      *               that it throws the correct exception
1:125c328:      * @return true  If the method throws the SQLException required
1:125c328:      *               after the free method has been called on the
1:125c328:      *               LOB object
1:125c328:      */
1:a78e683:     boolean checkIfMethodThrowsSQLException(Object LOB,Method method)
1:a78e683:             throws IllegalAccessException, InvocationTargetException {
1:125c328:         try {
1:125c328:             method.invoke(LOB,getNullValues(method.getParameterTypes()));
1:a78e683:         } catch (InvocationTargetException ite) {
1:a78e683:             Throwable cause = ite.getCause();
1:125c328:             if (cause instanceof SQLException ) {
1:a78e683:                 return ((SQLException)cause).getSQLState().equals("XJ215");
1:125c328:             }
1:a78e683:             throw ite;
1:125c328:         }
6:125c328:         return false;
1:125c328:     }
1:125c328: 
1:67f1fdd:     /**
1:125c328:      * Return a array of objects containing the default values for
1:125c328:      * the objects passed in as parameters
1:125c328:      *
1:a7362f0:      * @param params an array containing the types of the parames to the method
1:125c328:      * @return an array of Objects containing the null values for the
1:125c328:      *         parameter inputs
1:125c328:      */
1:125c328: 
1:125c328:     Object[] getNullValues(Class<?> [] params) {
1:125c328:         Object[] args = new Object[params.length];
1:125c328:         for (int i = 0; i < params.length; i++) {
1:125c328:             args[i] = getNullValueForType(params[i]);
1:125c328:         }
1:125c328:         return args;
1:125c328:     }
1:125c328: 
1:67f1fdd:     /**
1:125c328:      * Returns the null value for the specific type
1:125c328:      *
1:125c328:      * @param type the type of the parameter for which the null
1:125c328:      *             value is required
1:125c328:      * @return the null value for the specific type
1:125c328:      */
1:67f1fdd:      Object getNullValueForType(Class type) {
1:125c328:         if (!type.isPrimitive()) {
1:125c328:             return null;
1:125c328:         }
1:125c328:         if (type == Boolean.TYPE) {
1:125c328:             return Boolean.FALSE;
1:125c328:         }
1:125c328:         if (type == Character.TYPE) {
1:39b3237:             return (char) 0;
1:125c328:         }
1:125c328:         if (type == Byte.TYPE) {
1:39b3237:             return (byte) 0;
1:125c328:         }
1:125c328:         if (type == Short.TYPE) {
1:39b3237:             return (short) 0;
1:125c328:         }
1:125c328:         if (type == Integer.TYPE) {
1:39b3237:             return 0;
1:125c328:         }
1:125c328:         if (type == Long.TYPE) {
1:39b3237:             return 0L;
1:125c328:         }
1:125c328:         if (type == Float.TYPE) {
1:39b3237:             return 0f;
1:125c328:         }
1:125c328:         if (type == Double.TYPE) {
1:39b3237:             return 0d;
1:125c328:         }
1:125c328:         fail("Don't know how to handle type " + type);
1:125c328:         return null;            // unreachable statement
1:125c328:     }
1:125c328: 
1:c9382f0:     /**
1:cd727e7:      * Tests the implementation of getCharacterStream(long pos, long length).
1:125c328:      *
1:c9382f0:      * @throws Exception
1:c9382f0:      */
1:cd727e7:     public void testGetCharacterStreamLong()
1:c9382f0:     throws Exception {
1:c9382f0:         String str1 = "This is a test String. This is a test String";
1:a4846de: 
1:c9382f0:         Reader r1 = new java.io.StringReader(str1);
1:45a4a1d: 
1:c9382f0:         PreparedStatement ps = prepareStatement(
1:c9382f0:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:c9382f0:         int id = BlobClobTestSetup.getID();
1:c9382f0:         ps.setInt(1,id);
1:c9382f0:         ps.setCharacterStream(2,r1);
1:c9382f0:         ps.execute();
1:c9382f0:         ps.close();
1:45a4a1d: 
1:c9382f0:         Statement st = createStatement();
1:d3e6a71: 
1:c9382f0:         ResultSet rs = st.executeQuery("select CLOBDATA from " +
1:c9382f0:             "BLOBCLOB where ID="+id);
1:c9382f0:         rs.next();
1:c9382f0:         Clob clob = rs.getClob(1);
1:9b52936: 
1:c9382f0:         Reader r_1 = clob.getCharacterStream(2L,5L);
1:c9382f0:         String str2 = str1.substring(1,6);
1:c9382f0:         Reader r_2 = new java.io.StringReader(str2);
1:c9382f0: 
1:d3e6a71:         assertEquals(r_2,r_1);
1:d3e6a71: 
1:c9382f0:         rs.close();
1:c9382f0:         st.close();
1:125c328:     }
1:c9382f0: 
1:c9382f0:     /**
1:aeb4325:      * Obtains streams from the Clob reading portions of the content, always
1:aeb4325:      * including the last character in the Clob.
1:aeb4325:      * <p>
1:aeb4325:      * This case fills the Clob with latin lowercase characters.
1:c9382f0:      */
1:aeb4325:     public void testGetCharacterStreamLongLastCharLatin()
1:aeb4325:             throws IOException, SQLException {
1:aeb4325:         CharAlphabet alphabet = CharAlphabet.modernLatinLowercase();
1:aeb4325:         // Insert a Clob
1:aeb4325:         int length = 5000;
1:aeb4325:         PreparedStatement ps = prepareStatement(
1:aeb4325:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:aeb4325:         int id = BlobClobTestSetup.getID();
1:aeb4325:         ps.setInt(1, id);
1:aeb4325:         ps.setCharacterStream(2,
1:aeb4325:                 new LoopingAlphabetReader(length, alphabet), length);
1:aeb4325:         ps.execute();
1:aeb4325:         ps.close();
1:aeb4325:         // Perform the actual test.
1:aeb4325:         getCharacterStreamLongLastChar(id, length, alphabet);
1:a4846de:     }
1:c9382f0: 
1:aeb4325:     /**
1:aeb4325:      * Obtains streams from the Clob reading portions of the content, always
1:aeb4325:      * including the last character in the Clob.
1:aeb4325:      * <p>
1:aeb4325:      * This case fills the Clob with Chinese/Japanese/Korean characters.
1:aeb4325:      */
1:aeb4325:     public void testGetCharacterStreamLongLastCharCJK()
1:aeb4325:             throws IOException, SQLException {
1:aeb4325:         CharAlphabet alphabet = CharAlphabet.cjkSubset();
1:aeb4325:         // Insert a Clob
1:aeb4325:         int length = 9001;
1:aeb4325:         PreparedStatement ps = prepareStatement(
1:aeb4325:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:aeb4325:         int id = BlobClobTestSetup.getID();
1:aeb4325:         ps.setInt(1, id);
1:aeb4325:         ps.setCharacterStream(2,
1:aeb4325:                 new LoopingAlphabetReader(length, alphabet), length);
1:aeb4325:         ps.execute();
1:aeb4325:         ps.close();
1:aeb4325:         // Perform the actual test.
1:aeb4325:         getCharacterStreamLongLastChar(id, length, alphabet);
1:45a4a1d:     }
1:c9382f0: 
1:aeb4325:     /**
1:aeb4325:      * Obtains streams from the Clob and makes sure we can always read the
1:aeb4325:      * last char in the Clob.
1:aeb4325:      * <p>
1:aeb4325:      * See DERBY-4060.
1:125c328:      *
1:aeb4325:      * @param id id of the Clob to use
1:aeb4325:      * @param length the length of the Clob
1:aeb4325:      * @param alphabet the alphabet used to create the content
1:aeb4325:      * @throws IOException if reading from a stream fails
1:aeb4325:      * @throws SQLException if something goes wrong
1:aeb4325:      */
1:aeb4325:     private void getCharacterStreamLongLastChar(int id, int length,
1:aeb4325:                                                 CharAlphabet alphabet)
1:aeb4325:             throws IOException, SQLException {
1:aeb4325:         // Get last char from the source stream.
1:aeb4325:         Reader cmpReader = new LoopingAlphabetReader(length, alphabet);
1:aeb4325:         cmpReader.skip(length -1);
1:aeb4325:         char srcLastChar = (char)cmpReader.read();
1:aeb4325:         assertTrue(cmpReader.read() == -1);
1:c9382f0: 
1:aeb4325:         PreparedStatement ps = prepareStatement(
1:aeb4325:                 "select CLOBDATA from BLOBCLOB where ID=?");
1:aeb4325:         ps.setInt(1, id);
1:aeb4325:         // Read everything first.
1:aeb4325:         int charsToRead = length;
1:aeb4325:         ResultSet rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         Reader reader = rs.getClob(1).getCharacterStream(
1:aeb4325:                                         length - charsToRead +1, charsToRead);
1:aeb4325:         // Drain the stream, and make sure we are able to read the last char.
1:aeb4325:         char lastCharRead = getLastCharInStream(reader, charsToRead);
1:aeb4325:         assertEquals(srcLastChar, lastCharRead);
1:aeb4325:         reader.close();
1:aeb4325:         rs.close();
1:c9382f0: 
1:aeb4325:         // Read a portion of the stream.
1:aeb4325:         charsToRead = length / 4;
1:aeb4325:         rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         reader = rs.getClob(1).getCharacterStream(
1:aeb4325:                                         length - charsToRead +1, charsToRead);
1:aeb4325:         lastCharRead = getLastCharInStream(reader, charsToRead);
1:aeb4325:         assertEquals(srcLastChar, lastCharRead);
1:aeb4325:         reader.close();
1:aeb4325:         rs.close();
1:c9382f0: 
1:aeb4325:         // Read a very small portion of the stream.
1:aeb4325:         charsToRead = 1;
1:aeb4325:         rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         reader = rs.getClob(1).getCharacterStream(
1:aeb4325:                                         length - charsToRead +1, charsToRead);
1:aeb4325:         lastCharRead = getLastCharInStream(reader, charsToRead);
1:aeb4325:         assertEquals(srcLastChar, lastCharRead);
1:aeb4325:         reader.close();
1:aeb4325:         rs.close();
1:9b52936:     }
1:c9382f0: 
1:aeb4325:     /**
1:5b41e45:      * Test that <code>Clob.getCharacterStream(long,long)</code> works on CLOBs
1:5b41e45:      * that are streamed from store. (DERBY-2891)
1:5b41e45:      */
1:5b41e45:     public void testGetCharacterStreamLongOnLargeClob() throws Exception {
1:5b41e45:         getConnection().setAutoCommit(false);
1:5b41e45: 
1:5b41e45:         // create large (>32k) clob that can be read from store
1:5b41e45:         final int size = 33000;
1:5b41e45:         StringBuilder sb = new StringBuilder(size);
1:5b41e45:         for (int i = 0; i < size; i += 10) {
1:5b41e45:             sb.append("1234567890");
1:5b41e45:         }
1:5b41e45: 
1:5b41e45:         final int id = BlobClobTestSetup.getID();
1:5b41e45:         PreparedStatement ps = prepareStatement(
1:5b41e45:             "insert into blobclob(id, clobdata) values (?,cast(? as clob))");
1:5b41e45:         ps.setInt(1, id);
1:5b41e45:         ps.setString(2, sb.toString());
1:5b41e45:         ps.executeUpdate();
1:5b41e45:         ps.close();
1:5b41e45: 
1:5b41e45:         Statement s = createStatement();
1:5b41e45:         ResultSet rs = s.executeQuery(
1:5b41e45:             "select clobdata from blobclob where id = " + id);
1:5b41e45:         assertTrue(rs.next());
1:5b41e45:         Clob c = rs.getClob(1);
1:5b41e45: 
1:5b41e45:         // request a small region of the clob
1:5b41e45:         BufferedReader r = new BufferedReader(c.getCharacterStream(4L, 3L));
1:5b41e45:         assertEquals("456", r.readLine());
1:5b41e45: 
1:5b41e45:         r.close();
1:5b41e45:         c.free();
1:5b41e45:         rs.close();
1:5b41e45:         s.close();
1:5b41e45:         rollback();
1:5b41e45:     }
1:5b41e45: 
1:5b41e45:     /**
1:c9382f0:      * Tests the exceptions thrown by the getCharacterStream
1:c9382f0:      * (long pos, long length) for the following conditions
1:dbed020:      * a) pos &lt;= 0
1:dbed020:      * b) pos &gt; (length of LOB)
1:dbed020:      * c) length &lt; 0
1:dbed020:      * d) pos + length &gt; (length of LOB).
1:45a4a1d:      *
1:c9382f0:      * @throws SQLException
1:c9382f0:      */
1:cd727e7:     public void testGetCharacterStreamLongExceptionConditions()
4:a4846de:     throws SQLException {
1:c9382f0:         String str1 = "This is a test String. This is a test String";
1:c9382f0: 
1:c9382f0:         Reader r1 = new java.io.StringReader(str1);
1:c9382f0: 
1:c9382f0:         PreparedStatement ps = prepareStatement(
1:c9382f0:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:c9382f0:         int id = BlobClobTestSetup.getID();
1:c9382f0:         ps.setInt(1,id);
1:c9382f0:         ps.setCharacterStream(2,r1);
1:c9382f0:         ps.execute();
1:c9382f0:         ps.close();
1:c9382f0: 
1:c9382f0:         Statement st = createStatement();
1:c9382f0: 
1:c9382f0:         ResultSet rs = st.executeQuery("select CLOBDATA from " +
1:c9382f0:             "BLOBCLOB where ID="+id);
1:c9382f0:         rs.next();
1:c9382f0:         Clob clob = rs.getClob(1);
1:c9382f0:         // check the case where pos <= 0
1:a4846de:         try {
1:c9382f0:             // set pos as negative
1:c9382f0:             clob.getCharacterStream(-2L,5L);
1:c9382f0:             //Should not come here. The exception has to be thrown.
1:c9382f0:             fail("FAIL: Expected SQLException for pos being negative " +
1:c9382f0:                     "not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when pos <= 0 is XJ070
1:c9382f0:             assertSQLState("XJ070", sqle);
1:c9382f0:         }
1:c9382f0: 
1:c9382f0:         // check for the case pos > length of clob
1:a4846de:         try {
1:c9382f0:             // set the pos to any value greater than the Clob length
1:c9382f0:             clob.getCharacterStream(clob.length()+1, 5L);
1:c9382f0:             //Should not come here. The exception has to be thrown.
1:c9382f0:             fail("FAIL: Expected SQLException for position being greater than " +
1:c9382f0:                     "length of LOB not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when pos > length of Clob
1:c9382f0:             // is XJ076
1:9c7c512:             assertSQLState("XJ087", sqle);
1:c9382f0:         }
1:a8908bd: 
1:c9382f0:         //check for the case when length < 0
2:c9382f0:         try {
1:c9382f0:             // set length as negative
1:c9382f0:             clob.getCharacterStream(2L, -5L);
1:c9382f0:             // Should not come here. The exception has to be thrown.
1:c9382f0:             fail("Fail: expected exception for the length being negative " +
1:c9382f0:                     "not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when length < 0 of Clob
1:c9382f0:             // is XJ071
1:c9382f0:             assertSQLState("XJ071", sqle);
1:c9382f0:         }
1:c9382f0: 
1:c9382f0:         //check for the case when pos + length > length of Clob
1:c9382f0:         try {
1:c9382f0:             // set pos + length > length of Clob
1:c9382f0:             clob.getCharacterStream((clob.length() - 4), 10L);
1:c9382f0:             // Should not come here. The exception has to be thrown.
1:c9382f0:             fail("Fail: expected exception for the sum of position and length" +
1:c9382f0:                     " being greater than the LOB size not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when length < 0 of Clob
1:c9382f0:             // is XJ087
1:c9382f0:             assertSQLState("XJ087", sqle);
1:c9382f0:         }
1:c9382f0:     }
1:c9382f0: 
1:a8908bd:     /**
1:a8908bd:      * Tests that the InputStream got from
1:a8908bd:      * a empty Clob reflects new data in the
1:a8908bd:      * underlying Clob.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetAsciiStreamCreateClob() throws Exception {
1:a8908bd:          //The String that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Clob.
1:a8908bd:          String str = "Hi I am the insert String";
1:a8908bd: 
1:a8908bd:          //Create the InputStream that will
1:a8908bd:          //be used for comparing the Stream
1:a8908bd:          //that is obtained from the Blob after
1:a8908bd:          //the update.
1:a8908bd:          ByteArrayInputStream str_is = new ByteArrayInputStream
1:335eb23:                  (str.getBytes("US-ASCII"));
1:a8908bd: 
1:a8908bd:          //create the empty Clob.
1:a8908bd:          Clob clob = getConnection().createClob();
1:a8908bd: 
1:a8908bd:          //Get the InputStream from this
1:a8908bd:          //Clob
1:a8908bd:          InputStream is = clob.getAsciiStream();
1:a8908bd: 
1:a8908bd:          //set the String into the clob.
1:a8908bd:          clob.setString(1, str);
1:a8908bd: 
1:a8908bd:          //Ensure that the Stream obtained from
1:a8908bd:          //the clob contains the expected bytes
1:a8908bd:          assertEquals(str_is, is);
1:a8908bd:      }
1:a8908bd: 
1:a8908bd:      /**
1:a8908bd:      * Tests that the Reader got from
1:a8908bd:      * a empty Clob reflects new data in the
1:a8908bd:      * underlying Clob.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetCharacterStreamCreateClob() throws Exception {
1:a8908bd:          //The String that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Clob.
1:a8908bd:          String str = "Hi I am the insert String";
1:a8908bd: 
1:a8908bd:          //The string reader corresponding to this
1:a8908bd:          //string that will be used in the comparison.
1:a8908bd:          StringReader r_string = new StringReader(str);
1:a8908bd: 
1:a8908bd:          //create the empty Clob.
1:a8908bd:          Clob clob = getConnection().createClob();
1:a8908bd: 
1:a8908bd:          //Get the Reader from this
1:a8908bd:          //Clob
1:a8908bd:          Reader r_clob = clob.getCharacterStream();
1:a8908bd: 
1:a8908bd:          //set the String into the clob.
1:a8908bd:          clob.setString(1, str);
1:a8908bd: 
1:a8908bd:          //Now compare the reader corresponding
1:a8908bd:          //to the string and the reader obtained
1:a8908bd:          //form the clob to see if they match.
1:a8908bd:          assertEquals(r_string, r_clob);
1:a8908bd:      }
1:a8908bd: 
1:a8908bd:     /**
1:a8908bd:      * Tests that the data updated in a Clob
1:a8908bd:      * is always reflected in the InputStream
1:a8908bd:      * got. Here the updates into the Clob are
1:a8908bd:      * done using both an OutputStream obtained
1:a8908bd:      * from this Clob as well as using Clob.setString.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetAsciiStreamClobUpdates() throws Exception {
1:a8908bd:          //The String that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Clob.
1:a8908bd:          String str1 = "Hi I am the insert string";
1:a8908bd: 
1:a8908bd:          //Stores the byte array representation of
1:a8908bd:          //the insert string.
1:a8908bd:          byte[] str1_bytes = str1.getBytes();
1:a8908bd: 
1:a8908bd:          //The String that will be used in the
1:a8908bd:          //second series of updates
1:a8908bd:          String str2 = "Hi I am the update string";
1:a8908bd: 
1:a8908bd:          //create the empty Clob.
1:a8908bd:          Clob clob = getConnection().createClob();
1:a8908bd: 
1:a8908bd:          //Get the InputStream from this
1:a8908bd:          //Clob before any writes happen.
1:a8908bd:          InputStream is_BeforeWrite = clob.getAsciiStream();
1:a8908bd: 
1:a8908bd:          //Get an OutputStream from this Clob
1:a8908bd:          //into which the data can be written
1:a8908bd:          OutputStream os = clob.setAsciiStream(1);
1:a8908bd:          os.write(str1_bytes);
1:a8908bd: 
1:a8908bd:          //Doing a setString now on the Clob
1:a8908bd:          //should reflect the same extension
1:a8908bd:          //in the InputStream also.
1:a8908bd:          clob.setString((str1_bytes.length)+1, str2);
1:a8908bd: 
1:a8908bd:          //Get the input stream from the
1:a8908bd:          //Clob after the update
1:a8908bd:          InputStream is_AfterWrite = clob.getAsciiStream();
1:a8908bd: 
1:a8908bd:          //Now check if the two InputStreams
1:a8908bd:          //match
1:a8908bd:          assertEquals(is_BeforeWrite, is_AfterWrite);
1:a8908bd:      }
1:a8908bd: 
1:a8908bd:     /**
1:a8908bd:      * Tests that the data updated in a Clob
1:a8908bd:      * is always reflected in the Reader
1:a8908bd:      * got. Here the updates are done using
1:a8908bd:      * both a Writer obtained from this Clob
1:a8908bd:      * and using Clob.setString.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetCharacterStreamClobUpdates() throws Exception {
1:a8908bd:          //The String that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Clob.
1:a8908bd:          String str1 = "Hi I am the insert string";
1:a8908bd: 
1:a8908bd:          //The String that will be used in the
1:a8908bd:          //second series of updates
1:a8908bd:          String str2 = "Hi I am the update string";
1:a8908bd: 
1:a8908bd:          //create the empty Clob.
1:a8908bd:          Clob clob = getConnection().createClob();
1:a8908bd: 
1:a8908bd:          //Get the Reader from this
1:a8908bd:          //Clob
1:a8908bd:          Reader r_BeforeWrite = clob.getCharacterStream();
1:a8908bd: 
1:a8908bd:          //Get a writer from this Clob
1:a8908bd:          //into which the data can be written
1:a8908bd:          Writer w = clob.setCharacterStream(1);
1:a8908bd:          char [] chars_str1 = new char[str1.length()];
1:a8908bd:          str2.getChars(0, str1.length(), chars_str1, 0);
1:a8908bd:          w.write(chars_str1);
1:a8908bd: 
1:a8908bd:          //Doing a setString now on the Clob
1:a8908bd:          //should reflect the same extension
1:a8908bd:          //in the InputStream also.
1:c3ff1bd:          clob.setString((str1.length())+1, str2);
1:a8908bd: 
1:a8908bd:          //Now get the reader from the Clob after
1:a8908bd:          //the update has been done.
1:a8908bd:          Reader r_AfterWrite = clob.getCharacterStream();
1:a8908bd: 
1:a8908bd:          //Now compare the two readers to see that they
1:a8908bd:          //contain the same data.
1:a8908bd:          assertEquals(r_BeforeWrite, r_AfterWrite);
1:a8908bd:      }
1:c9382f0: 
1:c9382f0: 
1:c9382f0:     /**
1:f697326:      * Test that a lock held on the corresponding row is released when free() is
1:f697326:      * called on the Clob object.
1:67f1fdd:      * @throws java.sql.SQLException
1:aeb4325:      */
1:f697326:     public void testLockingAfterFree() throws SQLException
1:125c328:     {
1:f697326:         int id = initializeLongClob();  // Opens clob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:c9382f0: 
1:f697326:         // Test that update goes through after the clob is closed
1:45a4a1d:         clob.free();
1:f697326:         executeParallelUpdate(id, false);
1:c9382f0: 
1:f697326:         commit();
1:c9382f0:     }
1:c9382f0: 
1:67f1fdd:     /**
1:f697326:      * Test that a lock held on the corresponding row is NOT released when
1:f697326:      * free() is called on the Clob object if the isolation level is
1:f697326:      * Repeatable Read
4:f697326:      * @throws java.sql.SQLException
2:f697326:      */
1:f697326:     public void testLockingAfterFreeWithRR() throws SQLException
2:f697326:     {
1:f697326:         getConnection().
1:f697326:                 setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:f697326:         int id = initializeLongClob(); // Opens clob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:aeb4325: 
1:f697326:         // Test that update still times out after the clob is closed
1:f697326:         clob.free();
1:f697326:         executeParallelUpdate(id, true);
1:aeb4325: 
1:f697326:         // Test that the update goes through after the transaction has committed
1:f697326:         commit();
1:f697326:         executeParallelUpdate(id, false);
1:aeb4325:     }
1:aeb4325: 
1:aeb4325: 
2:f697326:      /**
1:f697326:      * Test that a lock held on the corresponding row is released when
1:f697326:      * free() is called on the Clob object if the isolation level is
1:f697326:      * Read Uncommitted
1:f697326:      * @throws java.sql.SQLException
1:f697326:      */
1:f697326:     public void testLockingAfterFreeWithDirtyReads() throws SQLException
1:f697326:     {
1:f697326:         getConnection().
1:f697326:                 setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:f697326:         int id = initializeLongClob(); // Opens clob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:aeb4325: 
1:f697326:        // Test that update goes through after the clob is closed
2:f697326:         clob.free();
1:f697326:         executeParallelUpdate(id, false);
1:aeb4325: 
1:f697326:         commit();
1:aeb4325:     }
1:67f1fdd: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchZeroLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(0);
1:aeb4325:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchVerySmall()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(7);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchSmall()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(1587);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchMedium()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(32000);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchMediumPlus()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(64000);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchLarge()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(128022);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:7af6726:     public void testInsertAndFetchLarger()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertAndFetchTest(3*1024*1024);
1:7af6726:     }
1:67f1fdd: 
1:f697326:     /**
1:7af6726:      * Inserts a Clob with the specified length, using a stream source, then
1:7af6726:      * fetches it from the database and checks the length.
1:45a4a1d:      *
1:7af6726:      * @param length number of characters in the Clob
1:7af6726:      * @throws IOException if reading from the source fails
1:7af6726:      * @throws SQLException if something goes wrong
1:7af6726:      */
1:7af6726:     private void insertAndFetchTest(long length)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         PreparedStatement ps = prepareStatement(
1:7af6726:                 "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:7af6726:         int id = BlobClobTestSetup.getID();
1:7af6726:         ps.setInt(1, id);
1:7af6726:         ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:7af6726:         long tsStart = System.currentTimeMillis();
1:7af6726:         ps.execute();
1:7af6726:         println("Inserted " + length + " chars (length specified) in " +
1:7af6726:                 (System.currentTimeMillis() - tsStart) + " ms");
1:7af6726:         Statement stmt = createStatement();
1:7af6726:         tsStart = System.currentTimeMillis();
1:7af6726:         ResultSet rs = stmt.executeQuery(
1:7af6726:                 "select CLOBDATA from BLOBCLOB where id = " + id);
1:7af6726:         assertTrue("Clob not inserted", rs.next());
1:7af6726:         Clob aClob = rs.getClob(1);
1:7af6726:         assertEquals("Invalid length", length, aClob.length());
1:7af6726:         println("Fetched length (" + length + ") in " +
1:7af6726:                 (System.currentTimeMillis() - tsStart) + " ms");
1:7af6726:         rs.close();
1:7af6726: 
1:7af6726:         // Insert same Clob again, using the lengthless override.
1:7af6726:         id = BlobClobTestSetup.getID();
1:7af6726:         ps.setInt(1, id);
1:7af6726:         ps.setCharacterStream(2, new LoopingAlphabetReader(length));
1:7af6726:         tsStart = System.currentTimeMillis();
1:7af6726:         ps.executeUpdate();
1:7af6726:         println("Inserted " + length + " chars (length unspecified) in " +
1:7af6726:                 (System.currentTimeMillis() - tsStart) + " ms");
1:7af6726:         rs = stmt.executeQuery(
1:7af6726:                 "select CLOBDATA from BLOBCLOB where id = " + id);
1:7af6726:         assertTrue("Clob not inserted", rs.next());
1:7af6726:         aClob = rs.getClob(1);
1:7af6726:         assertEquals("Invalid length", length, aClob.length());
1:7af6726:         println("Fetched length (" + length + ") in " +
1:7af6726:                 (System.currentTimeMillis() - tsStart) + " ms");
1:7af6726:         rs.close();
1:7af6726: 
1:7af6726:         rollback();
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Insert a row with a large clob into the test table.  Read the row from 
1:f697326:      * the database and assign the clob value to <code>clob</code>.
1:f697326:      * @return The id of the row that was inserted
1:67f1fdd:      * @throws java.sql.SQLException
1:f697326:      */
1:f697326:     private int initializeLongClob() throws SQLException
1:f697326:     {
1:67f1fdd:         // Clob needs to be larger than one page for locking to occur
1:f697326:         final int lobLength = 40000;
1:67f1fdd: 
1:f697326:         // Insert a long Clob
1:f697326:         PreparedStatement ps = prepareStatement(
1:f697326:                 "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:f697326:         int id = BlobClobTestSetup.getID();
1:f697326:         ps.setInt(1,id);
1:f697326:         ps.setCharacterStream(2, new LoopingAlphabetReader(lobLength), lobLength);
1:f697326:         ps.execute();
1:f697326:         ps.close();
1:f697326:         commit();
1:67f1fdd: 
1:f697326:         // Fetch the Clob object from the database
1:f697326:         Statement st = createStatement();
1:67f1fdd:         ResultSet rs =
1:f697326:                 st.executeQuery("select CLOBDATA from BLOBCLOB where ID=" + id);
1:f697326:         rs.next();
1:f697326:         clob = rs.getClob(1);
1:f697326:         rs.close();
1:f697326:         st.close();
1:67f1fdd: 
1:f697326:         return id;
1:7af6726:     }
1:67f1fdd: 
1:67f1fdd: 
1:f697326:     /**
1:67f1fdd:      * Try to update the row with the given error.  Flag a failure if a
1:f697326:      * timeout occurs when not expected, and vice versa.
1:f697326:      * @param id The id of the row to be updated
1:f697326:      * @param timeoutExpected true if it is expected that the update times out
1:67f1fdd:      * @throws java.sql.SQLException
1:f697326:      */
1:67f1fdd:     private void executeParallelUpdate(int id, boolean timeoutExpected)
1:f697326:             throws SQLException
1:f697326:     {
1:f697326:         Connection conn2 = openDefaultConnection();
1:f697326:         Statement stmt2 = conn2.createStatement();
1:67f1fdd: 
1:c9382f0:         try {
1:f697326:             stmt2.executeUpdate("update BLOBCLOB set BLOBDATA = " +
1:f697326:                                 "cast(X'FFFFFF' as blob) where ID=" + id);
1:f697326:             stmt2.close();
1:f697326:             conn2.commit();
1:f697326:             conn2.close();
1:f697326:             if (timeoutExpected) {
1:f697326:                 fail("FAIL - should have gotten lock timeout");
1:a78e683:             }
1:f697326:          } catch (SQLException se) {
1:f697326:             stmt2.close();
1:f697326:             conn2.rollback();
1:f697326:             conn2.close();
1:f697326:             if (timeoutExpected) {
1:f697326:                 assertSQLState(LOCK_TIMEOUT, se);
1:67f1fdd:             } else {
1:f697326:                 throw se;
1:f697326:             }
7:f697326:         }
1:f697326:     }
1:67f1fdd: 
1:f697326:     /**
1:aeb4325:      * Drains the stream and returns the last char read from the stream.
1:c9382f0:      *
1:aeb4325:      * @param reader stream to drain
1:aeb4325:      * @param expectedCount expected number of chars (remaining) in the stream
1:aeb4325:      * @return The last char read.
1:aeb4325:      * @throws AssertionError if there are too many/few chars in the stream
1:aeb4325:      * @throws IOException if reading from the stream fails
1:aeb4325:      */
1:aeb4325:     public static char getLastCharInStream(Reader reader, int expectedCount)
1:aeb4325:             throws IOException {
1:aeb4325:         int read = 0;
1:aeb4325:         final char[] buf = new char[256];
1:aeb4325:         assertTrue(buf.length > 0); // Do not allow an infinite loop here.
1:aeb4325:         while (true) {
1:aeb4325:             int readThisTime = reader.read(buf, 0, buf.length);
1:aeb4325:             // -1 is expected, but catch all cases with a negative return value.
1:aeb4325:             if (readThisTime < 0) {
1:aeb4325:                 assertEquals("Invalid return value from stream",
1:aeb4325:                         -1, readThisTime);
1:aeb4325:                 fail("Reached EOF prematurely, expected " + expectedCount +
1:aeb4325:                         ", got " + read);
1:aeb4325:             } else if (readThisTime == 0) {
1:aeb4325:                 // Another special case that should not happen.
1:aeb4325:                 fail("Stream breaks contract, read zero chars: " + reader);
1:aeb4325:             }
1:aeb4325:             read += readThisTime;
1:aeb4325:             if (read == expectedCount) {
1:aeb4325:                 return buf[readThisTime -1];
1:aeb4325:             } else if (read > expectedCount) {
1:aeb4325:                 fail("Too many chars in stream, expected " + expectedCount +
1:aeb4325:                         "have " + read + "(EOF not reached/confirmed)");
1:aeb4325:             }
1:aeb4325:         }
1:aeb4325:     }
1:aeb4325: 
1:aeb4325:     /**
1:a4846de:      * Create test suite for this test.
1:a4846de:      */
1:f697326:     public static Test suite()
1:f697326:     {
1:f697326:         return new BlobClobTestSetup(
1:f697326:                 // Reduce lock timeouts so lock test case does not take too long
1:f697326:                 DatabasePropertyTestSetup.setLockTimeouts(
1:67f1fdd:                         TestConfiguration.defaultSuite(ClobTest.class, false),
1:67f1fdd:                         2,
1:f697326:                         4));
1:a4846de:     }
1:a4846de: 
1:f697326:     private static final String LOCK_TIMEOUT = "40XL1";
1:a4846de: } // End class ClobTest
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * a) pos &lt;= 0
1:      * b) pos &gt; (length of LOB)
1:      * c) length &lt; 0
1:      * d) pos + length &gt; (length of LOB).
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             return (char) 0;
1:             return (byte) 0;
1:             return (short) 0;
1:             return 0;
1:             return 0L;
1:             return 0f;
1:             return 0d;
commit:a8908bd
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Tests that the InputStream got from
1:      * a empty Clob reflects new data in the
1:      * underlying Clob.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetAsciiStreamCreateClob() throws Exception {
1:          //The String that will be used
1:          //to do the inserts into the
1:          //Clob.
1:          String str = "Hi I am the insert String";
1:          
1:          //Create the InputStream that will
1:          //be used for comparing the Stream
1:          //that is obtained from the Blob after
1:          //the update.
1:          ByteArrayInputStream str_is = new ByteArrayInputStream
0:                  (str.getBytes());
1:          
1:          //create the empty Clob.
1:          Clob clob = getConnection().createClob();
1:          
1:          //Get the InputStream from this
1:          //Clob
1:          InputStream is = clob.getAsciiStream();
1:          
1:          //set the String into the clob.
1:          clob.setString(1, str);
1:          
1:          //Ensure that the Stream obtained from
1:          //the clob contains the expected bytes
1:          assertEquals(str_is, is);
1:      }
1:      
1:      /**
1:      * Tests that the Reader got from
1:      * a empty Clob reflects new data in the
1:      * underlying Clob.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetCharacterStreamCreateClob() throws Exception {
1:          //The String that will be used
1:          //to do the inserts into the
1:          //Clob.
1:          String str = "Hi I am the insert String";
1: 
1:          //The string reader corresponding to this
1:          //string that will be used in the comparison.
1:          StringReader r_string = new StringReader(str);
1:          
1:          //create the empty Clob.
1:          Clob clob = getConnection().createClob();
1:          
1:          //Get the Reader from this
1:          //Clob
1:          Reader r_clob = clob.getCharacterStream();
1:          
1:          //set the String into the clob.
1:          clob.setString(1, str);
1:          
1:          //Now compare the reader corresponding
1:          //to the string and the reader obtained
1:          //form the clob to see if they match.
1:          assertEquals(r_string, r_clob);
1:      }
1:      
1:     /**
1:      * Tests that the data updated in a Clob
1:      * is always reflected in the InputStream
1:      * got. Here the updates into the Clob are
1:      * done using both an OutputStream obtained
1:      * from this Clob as well as using Clob.setString.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetAsciiStreamClobUpdates() throws Exception {
1:          //The String that will be used
1:          //to do the inserts into the
1:          //Clob.
1:          String str1 = "Hi I am the insert string";
1:          
1:          //Stores the byte array representation of 
1:          //the insert string.
1:          byte[] str1_bytes = str1.getBytes();
1:          
1:          //The String that will be used in the
1:          //second series of updates
1:          String str2 = "Hi I am the update string";
1:          
1:          //create the empty Clob.
1:          Clob clob = getConnection().createClob();
1:          
1:          //Get the InputStream from this
1:          //Clob before any writes happen.
1:          InputStream is_BeforeWrite = clob.getAsciiStream();
1:          
1:          //Get an OutputStream from this Clob
1:          //into which the data can be written
1:          OutputStream os = clob.setAsciiStream(1);
1:          os.write(str1_bytes);
1:          
1:          //Doing a setString now on the Clob
1:          //should reflect the same extension
1:          //in the InputStream also.
1:          clob.setString((str1_bytes.length)+1, str2);
1:          
1:          //Get the input stream from the
1:          //Clob after the update
1:          InputStream is_AfterWrite = clob.getAsciiStream();
1:          
1:          //Now check if the two InputStreams
1:          //match
1:          assertEquals(is_BeforeWrite, is_AfterWrite);
1:      }
1:      
1:     /**
1:      * Tests that the data updated in a Clob
1:      * is always reflected in the Reader
1:      * got. Here the updates are done using
1:      * both a Writer obtained from this Clob
1:      * and using Clob.setString.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetCharacterStreamClobUpdates() throws Exception {
1:          //The String that will be used
1:          //to do the inserts into the
1:          //Clob.
1:          String str1 = "Hi I am the insert string";
1:          
1:          //The String that will be used in the
1:          //second series of updates
1:          String str2 = "Hi I am the update string";
1:          
1:          //create the empty Clob.
1:          Clob clob = getConnection().createClob();
1:          
1:          //Get the Reader from this
1:          //Clob
1:          Reader r_BeforeWrite = clob.getCharacterStream();
1:          
1:          //Get a writer from this Clob
1:          //into which the data can be written
1:          Writer w = clob.setCharacterStream(1);
1:          char [] chars_str1 = new char[str1.length()];
1:          str2.getChars(0, str1.length(), chars_str1, 0);
1:          w.write(chars_str1);
1:          
1:          //Doing a setString now on the Clob
1:          //should reflect the same extension
1:          //in the InputStream also.
0:          clob.setString((str1.getBytes().length)+1, str2);
1:          
1:          //Now get the reader from the Clob after
1:          //the update has been done.
1:          Reader r_AfterWrite = clob.getCharacterStream();
1:          
1:          //Now compare the two readers to see that they
1:          //contain the same data.
1:          assertEquals(r_BeforeWrite, r_AfterWrite);
1:      }
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:125c328
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
1: import java.lang.reflect.*;
1: import java.util.*;
1: 
1: /* This class is used to store the details of the methods that
1:  * throw a SQLFeatureNotSupportedException in the implementation
1:  * of java.sql.Clob.
1:  *
1:  * It store the following information about the methods
1:  *
1:  * a) Name
1:  * b) Method Parameters
1:  * c) Whether the method is exempted in the Embedded Sever
1:  * d) Whether the method is exempted in the NetworkClient
1:  *
1:  */
1: class ExemptClobMD {
0:     // The Name of the method
1:     private String methodName_;
1:     
0:     // The parameters of the method
1:     private Class [] params_;
1:     
0:     //Whether it is exempted in the 
0:     //Client or the Embedded framework
1:     private boolean isClientFramework_;
1:     private boolean isEmbeddedFramework_;
1:     
1:     /**
1:      * The Constructor for the ExemptClobMD class that
1:      * initialized the object with the details of the 
1:      * methods that have been exempted
1:      *
1:      * @param methodName          A String that contains the name of the method
1:      *                            that has been exempted.
1:      * @param params              A array of Class that contains the parameters 
1:      *                            of the methods.
1:      * @param isClientFramework   true if the method is exempted in the 
1:      *                            Client framework.
1:      * @param isEmbeddedFramework true if the method is exempted in the 
1:      *                            Embedded framework.
1:      *
1:      */
1:     public ExemptClobMD(String methodName,Class [] params,
1:                             boolean isClientFramework,
1:                             boolean isEmbeddedFramework) {
1:         methodName_ = methodName;
1:         params_ = params;
1:         isClientFramework_ = isClientFramework;
1:         isEmbeddedFramework_ = isEmbeddedFramework;
1:     }
1:     
1:     /**
1:      *
1:      * Returns the name of the method.
1:      *
1:      * @return A String containing the name of the method.
1:      *
1:      */
1:     public String getMethodName() { return methodName_; }
1:     
1:     /**
1:      * Returns a array of Class containing the type of the parameters
1:      * of this method. 
1:      *
1:      * @return A array of Class containing the type of the parameters 
1:      *         of the method.
1:      */
1:     public Class [] getParams() { return params_; }
1:     
1:     /**
1:      * Returns if the method is exempted from the Client Framework.
1:      *
1:      * @return true if the method is exempted from the Client Framework.
1:      */
1:     public boolean getIfClientFramework() { return isClientFramework_; }
1:     
1:     /**
1:      * Returns if the method is exempted from the Embedded Framework.
1:      *
1:      * @return true if the method is exempted from the Embedded Framework.
1:      */
1:     public boolean getIfEmbeddedFramework() { return isEmbeddedFramework_; }
1: }
/////////////////////////////////////////////////////////////////////////
1:     // Initialize with the details of the method that are exempted from 
1:     //throwing a SQLException when they are called after calling free()
1:     //on a LOB.
1:     
0:     private ExemptClobMD [] emd = new ExemptClobMD [] {
0:         new ExemptClobMD( "getCharacterStream", new Class[] { long.class, long.class } ,true,true),
0:         new ExemptClobMD( "setAsciiStream",     new Class[] { long.class } ,false,true),
0: 	new ExemptClobMD( "setCharacterStream", new Class[] { long.class } ,true,true),
0: 	new ExemptClobMD( "setString",          new Class[] { long.class, String.class } ,false,true),
0: 	new ExemptClobMD( "setString",          new Class[] { long.class, String.class, int.class, int.class},false,true),
0: 	new ExemptClobMD( "truncate",           new Class[] { long.class },false,true),
0:         new ExemptClobMD( "free",               null,true,true)
1:     };
1:     
1:     // An HashMap that is indexed by the Method which facilitated easy
1:     //search for whether the given method has been exempted from the
1:     //LOB interface.
1:     
1:     private HashMap<Method,ExemptClobMD> excludedMethodSet = 
1:                             new HashMap<Method,ExemptClobMD>();
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call the buildHashSetMethod to initialize the 
1:         //HashSet with the method signatures that are exempted 
1:         //from throwing a SQLException after free has been called
1:         //on the Clob object.
1:         buildHashSet();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Builds the HashSet which will be used to test whether the given methods
1:      * can be exempted or not
1:      */
1:     void buildHashSet() {
0:         Class iface = Clob.class;
1:         for(int i=0;i<emd.length;i++) {
1:             try {
1:                 Method m = iface.getMethod(emd[i].getMethodName()
1:                                                 ,emd[i].getParams());
1:                 excludedMethodSet.put(m,emd[i]);
1:             }
1:             catch(NoSuchMethodException nsme) {
1:                 fail("The method could not be found in the interface");
1:             }
1:     /**
1:      * Tests the implementation for the free() method in the
1:      * Clob interface.
1:      * 
1:      * @throws SQLException if an error occurs during releasing
1:      *         the Clob resources
1:      *
1:      */
1:     public void testFreeandMethodsAfterCallingFree()
1:         throws SQLException {
1:             InputStream asciiStream = clob.getAsciiStream();
0:             Reader charStream  = clob.getCharacterStream();
1:             clob.free();
1:             //testing the idempotence of the free() method
1:             //the method can be called multiple times on
0:             //the same instance. subsequent calls after 
1:             //the first are treated as no-ops
1:             clob.free();
1:             
0:             //clob becomes invalid after the first call 
1:             //to the free method so testing calling
1:             //a method on this invalid object should throw
1:             //an SQLException
1:             buildMethodList(clob);
1:     }
1:     
1:     /*
1:      * 
1:      * Enumerate the methods of the Clob interface and 
1:      * get the list of methods present in the interface
1:      * @param LOB an instance of the Clob interface implementation
1:      */
0:     void buildMethodList(Object LOB) {
1:         //If the given method throws the correct exception
1:         //set this to true and add it to the 
1:         boolean valid = true;
1:         
1:         //create a list of the methods that fail the test
1:         Vector<Method> methodList = new Vector<Method>();
1:         
1:         //The class whose methods are to be verified
1:         Class clazz = Clob.class;
1:         
1:         //The list of the methods in the class that need to be invoked
1:         //and verified
1:         Method [] methods = clazz.getMethods();
1:         
1:         //Check each of the methods to ensure that
1:         //they throw the required exception
1:         for(int i=0;i<methods.length;i++) {
1:             if(!checkIfExempted(methods[i])) {
1:                 valid = checkIfMethodThrowsSQLException(LOB,methods[i]);
1:                 
1:                 //add the method to the list if the method does
1:                 //not throw the required exception
1:                 if(valid == false) methodList.add(methods[i]);
1:                 
1:                 //reset valid
1:                 valid = true;
1:             }
1:         }
1:         
1:         if(!methodList.isEmpty()) {
1:             int c=0;
1:             String failureMessage = "The Following methods don't throw " +
1:                 "required exception - ";
1:             for (Method m : methodList) {
1:                 c = c + 1;
1:                 if(c == methodList.size() && c != 1) 
1:                     failureMessage += " & ";
1:                 else if(c != 1)
1:                     failureMessage += " , ";
1:                 failureMessage += m.getName();
1:             }
1:             fail(failureMessage);
1:         }
1:     }
1:     
1:     /**
0:      *Checks if the method throws a SQLFeatureNotSupportedException
0:      *@param m The method object that needs to be verified to see if it 
0:      *         is exempted
0:      *@return true if the given method does not throw the required SQLException
1:      *
1:      */
1:     boolean checkIfExempted(Method m) {
1:         ExemptClobMD md = excludedMethodSet.get(m);
1:         
0:         if(md != null && usingDerbyNetClient()) { 
0:             if(md.getIfClientFramework()) 
0:                 return true;
0:             else
1:                 return false;
1:         } 
0:         if(md != null && usingEmbedded()) {
0:             if(md.getIfEmbeddedFramework())
0:                 return true;
0:             else
1:                 return false;
1:         }
1:         return false;
1:     }
1:     
1:     /*
1:      * Checks if the invocation of the method throws a SQLExceptio
1:      * as expected.
1:      * @param LOB    the Object that implements the Blob interface
1:      * @param method the method that needs to be tested to ensure
1:      *               that it throws the correct exception
1:      * @return true  If the method throws the SQLException required
1:      *               after the free method has been called on the
1:      *               LOB object
1:      *
1:      */
0:     boolean checkIfMethodThrowsSQLException(Object LOB,Method method) {
1:         try {
1:             method.invoke(LOB,getNullValues(method.getParameterTypes()));
0:         } catch(Throwable e) {
0:             if(e instanceof InvocationTargetException) {
0:                 Throwable cause = e.getCause();
1:                 if (cause instanceof SQLException ) {
0:                     SQLException sqle = (SQLException)cause;
0:                     if(sqle.getSQLState().equals("XJ215"))
0:                         return true;
0:                     else
1:                         return false;
1:                 } else {
1:                     return false;
1:                 }
1:                 
1:             }
1:         }
1:         return false;
1:     }
1:     
1:     /*
1:      * Return a array of objects containing the default values for
1:      * the objects passed in as parameters
1:      * 
0:      * @param parameterTypes an array containing the types of the parameter 
0:      *                       to the method
1:      * @return an array of Objects containing the null values for the 
1:      *         parameter inputs
1:      */
1:     
1:     Object[] getNullValues(Class<?> [] params) {
1:         Object[] args = new Object[params.length];
1:         for (int i = 0; i < params.length; i++) {
1:             args[i] = getNullValueForType(params[i]);
1:         }
1:         return args;
1:     }
1:     
1:     /*
1:      * Returns the null value for the specific type
1:      * 
1:      * @param type the type of the parameter for which the null
1:      *             value is required
1:      * @return the null value for the specific type
1:      * 
1:      */
0:      Object getNullValueForType(Class type)
1: 	{
1:         if (!type.isPrimitive()) {
1:             return null;
1:         }
1:         if (type == Boolean.TYPE) {
1:             return Boolean.FALSE;
1:         }
1:         if (type == Character.TYPE) {
0:             return new Character((char) 0);
1:         }
1:         if (type == Byte.TYPE) {
0:             return new Byte((byte) 0);
1:         }
1:         if (type == Short.TYPE) {
0:             return new Short((short) 0);
1:         }
1:         if (type == Integer.TYPE) {
0:             return new Integer(0);
1:         }
1:         if (type == Long.TYPE) {
0:             return new Long(0L);
1:         }
1:         if (type == Float.TYPE) {
0:             return new Float(0f);
1:         }
1:         if (type == Double.TYPE) {
0:             return new Double(0d);
1:         }
1:         fail("Don't know how to handle type " + type);
1:         return null;            // unreachable statement
1:     }
1:     
commit:a4846de
/////////////////////////////////////////////////////////////////////////
1: 
0: /*
1:  
0:    Derby - Class ClobTest
1:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
1: import java.sql.*;
1: 
0: /*
1:  * Tests of the JDBC 4.0 specific <code>Clob</code> methods.
1:  */
1: public class ClobTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** Default Clob object used by the tests. */
1:     private Clob clob = null;
0:     /** Default connection used by the tests. */
0:     private Connection con = null;
1:     
1:     /**
1:      * Create the test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public ClobTest(String name) {
1:         super(name);
1:     }
1:     
1:     public void setUp() 
1:         throws SQLException {
0:         con = getConnection();
0:         clob = BlobClobTestSetup.getSampleClob(con);
1:     }
1: 
0:     public void tearDown()
1:         throws SQLException {
1:         clob = null;
0:         if (con != null && !con.isClosed()) {
0:             con.rollback();
0:             con.close();
1:         }
0:         con = null;
1:     }
1: 
0:     public void testFreeNotImplemented()
1:         throws SQLException {
1:         try {
1:             clob.free();
0:             fail("Clob.free() should not be implemented");
0:         } catch (SQLFeatureNotSupportedException sfnse) {
0:             // Do nothing, we are fine
1:         }
1:     }
1:     
0:     public void testGetCharacterStreamLongNotImplemented()
1:         throws SQLException {
1:         try {
0:             clob.getCharacterStream(5l, 10l);
0:             fail("Clob.getCharacterStream(long,long)" +
0:                  "should not be implemented");
0:         } catch (SQLFeatureNotSupportedException sfnse) {
0:             // Do nothing, we are fine
1:         }
1:     }
1: 
1:     /**
1:      * Create test suite for this test.
1:      */
0:     public static Test suite() {
0:         return new BlobClobTestSetup(new TestSuite(ClobTest.class,
0:                                                    "ClobTest suite"));
1:     }
1: 
1: } // End class ClobTest
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:45a4a1d
/////////////////////////////////////////////////////////////////////////
1:      * Tests free() after implicit free
1:      *
1:      * @throws SQLException if an error occurs during free
1:      *        
1:      */
1:     public void testFreeAfterImplicitFree()  throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         clob = BlobClobTestSetup.getSampleClob(conn);
1:         conn.commit();
1:         // DERBY-5605
1:         // free should not throw an exception even though it was 
1:         // implicitly freed with the commit.
1:         clob.free();
1:         
1:     }
1: 
1:     /**
commit:c3ff1bd
/////////////////////////////////////////////////////////////////////////
1:          clob.setString((str1.length())+1, str2);
commit:335eb23
/////////////////////////////////////////////////////////////////////////
1:                  (str.getBytes("US-ASCII"));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0f26c83
/////////////////////////////////////////////////////////////////////////
1:         Class<Clob> iface = Clob.class;
commit:5b41e45
/////////////////////////////////////////////////////////////////////////
1:      * Test that <code>Clob.getCharacterStream(long,long)</code> works on CLOBs
1:      * that are streamed from store. (DERBY-2891)
1:      */
1:     public void testGetCharacterStreamLongOnLargeClob() throws Exception {
1:         getConnection().setAutoCommit(false);
1: 
1:         // create large (>32k) clob that can be read from store
1:         final int size = 33000;
1:         StringBuilder sb = new StringBuilder(size);
1:         for (int i = 0; i < size; i += 10) {
1:             sb.append("1234567890");
1:         }
1: 
1:         final int id = BlobClobTestSetup.getID();
1:         PreparedStatement ps = prepareStatement(
1:             "insert into blobclob(id, clobdata) values (?,cast(? as clob))");
1:         ps.setInt(1, id);
1:         ps.setString(2, sb.toString());
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery(
1:             "select clobdata from blobclob where id = " + id);
1:         assertTrue(rs.next());
1:         Clob c = rs.getClob(1);
1: 
1:         // request a small region of the clob
1:         BufferedReader r = new BufferedReader(c.getCharacterStream(4L, 3L));
1:         assertEquals("456", r.readLine());
1: 
1:         r.close();
1:         c.free();
1:         rs.close();
1:         s.close();
1:         rollback();
1:     }
1: 
1:     /**
commit:d3e6a71
/////////////////////////////////////////////////////////////////////////
1:         // Life span of Clob objects are limited by the transaction.  Need
1:         // autocommit off so Clob objects survive closing of result set.
1:         getConnection().setAutoCommit(false);
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(r_2,r_1);
1: 
commit:9b52936
/////////////////////////////////////////////////////////////////////////
1:     private static final ExemptClobMD [] emd = new ExemptClobMD [] {
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void tearDown() throws Exception {
1:         clob.free();
0:         clob = null;
1:         excludedMethodSet = null;
1:         super.tearDown();
1:     }
commit:9c7c512
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XJ087", sqle);
commit:c9382f0
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Tests the getCharacterStream(long pos, long length) on the
0:      * Embedded side.
1:      *
1:      * @throws SQLException
1:      */
0:     public void embeddedTestGetCharacterStreamLongNotImplemented()
0:     throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:      * Tests the implementation of getCharacterStream(long pos, long length)
0:      * in the NetworkClient.
1:      * @throws Exception
1:      */
0:     public void clientTestGetCharacterStreamLong()
1:     throws Exception {
1:         String str1 = "This is a test String. This is a test String";
1: 
1:         Reader r1 = new java.io.StringReader(str1);
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1,id);
1:         ps.setCharacterStream(2,r1);
1:         ps.execute();
1:         ps.close();
1: 
1:         Statement st = createStatement();
1: 
1:         ResultSet rs = st.executeQuery("select CLOBDATA from " +
1:             "BLOBCLOB where ID="+id);
1:         rs.next();
1:         Clob clob = rs.getClob(1);
1: 
1:         Reader r_1 = clob.getCharacterStream(2L,5L);
1:         String str2 = str1.substring(1,6);
1:         Reader r_2 = new java.io.StringReader(str2);
1: 
1:         rs.close();
1:         st.close();
1: 
0:         assertEquals(r_2,r_1);
1:     }
1: 
1:     /**
1:      * Tests the exceptions thrown by the getCharacterStream
1:      * (long pos, long length) for the following conditions
0:      * a) pos <= 0
0:      * b) pos > (length of LOB)
0:      * c) length < 0
0:      * d) pos + length > (length of LOB).
0:      *
0:      * @throws SQLException.
1:      */
0:     public void clientTestGetCharacterStreamLongExceptionConditions()
0:     throws SQLException {
1:         String str1 = "This is a test String. This is a test String";
1: 
1:         Reader r1 = new java.io.StringReader(str1);
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1,id);
1:         ps.setCharacterStream(2,r1);
1:         ps.execute();
1:         ps.close();
1: 
1:         Statement st = createStatement();
1: 
1:         ResultSet rs = st.executeQuery("select CLOBDATA from " +
1:             "BLOBCLOB where ID="+id);
1:         rs.next();
1:         Clob clob = rs.getClob(1);
1:         // check the case where pos <= 0
1:         try {
1:             // set pos as negative
1:             clob.getCharacterStream(-2L,5L);
1:             //Should not come here. The exception has to be thrown.
1:             fail("FAIL: Expected SQLException for pos being negative " +
1:                     "not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when pos <= 0 is XJ070
1:             assertSQLState("XJ070", sqle);
1:         }
1: 
1:         // check for the case pos > length of clob
1:         try {
1:             // set the pos to any value greater than the Clob length
1:             clob.getCharacterStream(clob.length()+1, 5L);
1:             //Should not come here. The exception has to be thrown.
1:             fail("FAIL: Expected SQLException for position being greater than " +
1:                     "length of LOB not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when pos > length of Clob
1:             // is XJ076
0:             assertSQLState("XJ076", sqle);
1:         }
1: 
1:         //check for the case when length < 0
1:         try {
1:             // set length as negative
1:             clob.getCharacterStream(2L, -5L);
1:             // Should not come here. The exception has to be thrown.
1:             fail("Fail: expected exception for the length being negative " +
1:                     "not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when length < 0 of Clob
1:             // is XJ071
1:             assertSQLState("XJ071", sqle);
1:         }
1: 
1:         //check for the case when pos + length > length of Clob
1:         try {
1:             // set pos + length > length of Clob
1:             clob.getCharacterStream((clob.length() - 4), 10L);
1:             // Should not come here. The exception has to be thrown.
1:             fail("Fail: expected exception for the sum of position and length" +
1:                     " being greater than the LOB size not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when length < 0 of Clob
1:             // is XJ087
1:             assertSQLState("XJ087", sqle);
1:         }
1:     }
1: 
1: 
1:     /**
0:         TestSuite ctSuite = new TestSuite("ClobTest suite");
1: 
0:         TestSuite embedded = new TestSuite("ClobTest:embedded");
0:         embedded.addTestSuite(ClobTest.class);
0:         embedded.addTest(new ClobTest(
0:                     "embeddedTestGetCharacterStreamLongNotImplemented"));
0:         ctSuite.addTest(new BlobClobTestSetup(embedded));
1: 
0:         TestSuite client = new TestSuite("ClobTest:client");
0:         client.addTestSuite(ClobTest.class);
0:         client.addTest(new ClobTest("clientTestGetCharacterStreamLong"));
0:         client.addTest(new ClobTest("clientTestGetCharacterStreamLong" +
0:                  "ExceptionConditions"));
0:         ctSuite.addTest(TestConfiguration.clientServerDecorator(
0:             new BlobClobTestSetup(client)));
1: 
0:         return ctSuite;
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("ClobTest suite");
0:         suite.addTest(new BlobClobTestSetup(
0:             new TestSuite(ClobTest.class, "ClobTest:embedded")));
0:         suite.addTest(TestConfiguration.clientServerDecorator(
0:             new BlobClobTestSetup(new TestSuite(ClobTest.class,
0:                                                 "ClobTest:client"))));
0:         return suite;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aeb4325
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
/////////////////////////////////////////////////////////////////////////
1:      * Obtains streams from the Clob reading portions of the content, always
1:      * including the last character in the Clob.
1:      * <p>
1:      * This case fills the Clob with latin lowercase characters.
1:      */
1:     public void testGetCharacterStreamLongLastCharLatin()
1:             throws IOException, SQLException {
1:         CharAlphabet alphabet = CharAlphabet.modernLatinLowercase();
1:         // Insert a Clob
1:         int length = 5000;
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setCharacterStream(2,
1:                 new LoopingAlphabetReader(length, alphabet), length);
1:         ps.execute();
1:         ps.close();
1:         // Perform the actual test.
1:         getCharacterStreamLongLastChar(id, length, alphabet);
1:     }
1: 
1:     /**
1:      * Obtains streams from the Clob reading portions of the content, always
1:      * including the last character in the Clob.
1:      * <p>
1:      * This case fills the Clob with Chinese/Japanese/Korean characters.
1:      */
1:     public void testGetCharacterStreamLongLastCharCJK()
1:             throws IOException, SQLException {
1:         CharAlphabet alphabet = CharAlphabet.cjkSubset();
1:         // Insert a Clob
1:         int length = 9001;
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setCharacterStream(2,
1:                 new LoopingAlphabetReader(length, alphabet), length);
1:         ps.execute();
1:         ps.close();
1:         // Perform the actual test.
1:         getCharacterStreamLongLastChar(id, length, alphabet);
1:     }
1: 
1:     /**
1:      * Obtains streams from the Clob and makes sure we can always read the
1:      * last char in the Clob.
1:      * <p>
1:      * See DERBY-4060.
0:      *
1:      * @param id id of the Clob to use
1:      * @param length the length of the Clob
1:      * @param alphabet the alphabet used to create the content
1:      * @throws IOException if reading from a stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void getCharacterStreamLongLastChar(int id, int length,
1:                                                 CharAlphabet alphabet)
1:             throws IOException, SQLException {
1:         // Get last char from the source stream.
1:         Reader cmpReader = new LoopingAlphabetReader(length, alphabet);
1:         cmpReader.skip(length -1);
1:         char srcLastChar = (char)cmpReader.read();
1:         assertTrue(cmpReader.read() == -1);
1: 
1:         PreparedStatement ps = prepareStatement(
1:                 "select CLOBDATA from BLOBCLOB where ID=?");
1:         ps.setInt(1, id);
1:         // Read everything first.
1:         int charsToRead = length;
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         Reader reader = rs.getClob(1).getCharacterStream(
1:                                         length - charsToRead +1, charsToRead);
1:         // Drain the stream, and make sure we are able to read the last char.
1:         char lastCharRead = getLastCharInStream(reader, charsToRead);
1:         assertEquals(srcLastChar, lastCharRead);
1:         reader.close();
1:         rs.close();
1: 
1:         // Read a portion of the stream.
1:         charsToRead = length / 4;
1:         rs = ps.executeQuery();
1:         rs.next();
1:         reader = rs.getClob(1).getCharacterStream(
1:                                         length - charsToRead +1, charsToRead);
1:         lastCharRead = getLastCharInStream(reader, charsToRead);
1:         assertEquals(srcLastChar, lastCharRead);
1:         reader.close();
1:         rs.close();
1: 
1:         // Read a very small portion of the stream.
1:         charsToRead = 1;
1:         rs = ps.executeQuery();
1:         rs.next();
1:         reader = rs.getClob(1).getCharacterStream(
1:                                         length - charsToRead +1, charsToRead);
1:         lastCharRead = getLastCharInStream(reader, charsToRead);
1:         assertEquals(srcLastChar, lastCharRead);
1:         reader.close();
1:         rs.close();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Drains the stream and returns the last char read from the stream.
0:      *
1:      * @param reader stream to drain
1:      * @param expectedCount expected number of chars (remaining) in the stream
1:      * @return The last char read.
1:      * @throws AssertionError if there are too many/few chars in the stream
1:      * @throws IOException if reading from the stream fails
1:      */
1:     public static char getLastCharInStream(Reader reader, int expectedCount)
1:             throws IOException {
1:         int read = 0;
1:         final char[] buf = new char[256];
1:         assertTrue(buf.length > 0); // Do not allow an infinite loop here.
1:         while (true) {
1:             int readThisTime = reader.read(buf, 0, buf.length);
1:             // -1 is expected, but catch all cases with a negative return value.
1:             if (readThisTime < 0) {
1:                 assertEquals("Invalid return value from stream",
1:                         -1, readThisTime);
1:                 fail("Reached EOF prematurely, expected " + expectedCount +
1:                         ", got " + read);
1:             } else if (readThisTime == 0) {
1:                 // Another special case that should not happen.
1:                 fail("Stream breaks contract, read zero chars: " + reader);
1:             }
1:             read += readThisTime;
1:             if (read == expectedCount) {
1:                 return buf[readThisTime -1];
1:             } else if (read > expectedCount) {
1:                 fail("Too many chars in stream, expected " + expectedCount +
1:                         "have " + read + "(EOF not reached/confirmed)");
1:             }
1:         }
1:     }
1: 
1:     /**
commit:a7362f0
/////////////////////////////////////////////////////////////////////////
1:      * @param params an array containing the types of the parames to the method
commit:7af6726
/////////////////////////////////////////////////////////////////////////
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchZeroLength()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(0);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchVerySmall()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(7);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchSmall()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(1587);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchMedium()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(32000);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchMediumPlus()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(64000);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchLarge()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(128022);
1:     }
1: 
1:     /** Inserts, fetches and checks the length of a Clob using a stream. */
1:     public void testInsertAndFetchLarger()
1:             throws IOException, SQLException {
1:         insertAndFetchTest(3*1024*1024);
1:     }
1:      * Inserts a Clob with the specified length, using a stream source, then
1:      * fetches it from the database and checks the length.
0:      *
1:      * @param length number of characters in the Clob
1:      * @throws IOException if reading from the source fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void insertAndFetchTest(long length)
1:             throws IOException, SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:         long tsStart = System.currentTimeMillis();
1:         ps.execute();
1:         println("Inserted " + length + " chars (length specified) in " +
1:                 (System.currentTimeMillis() - tsStart) + " ms");
1:         Statement stmt = createStatement();
1:         tsStart = System.currentTimeMillis();
1:         ResultSet rs = stmt.executeQuery(
1:                 "select CLOBDATA from BLOBCLOB where id = " + id);
1:         assertTrue("Clob not inserted", rs.next());
1:         Clob aClob = rs.getClob(1);
1:         assertEquals("Invalid length", length, aClob.length());
1:         println("Fetched length (" + length + ") in " +
1:                 (System.currentTimeMillis() - tsStart) + " ms");
1:         rs.close();
1: 
1:         // Insert same Clob again, using the lengthless override.
1:         id = BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setCharacterStream(2, new LoopingAlphabetReader(length));
1:         tsStart = System.currentTimeMillis();
1:         ps.executeUpdate();
1:         println("Inserted " + length + " chars (length unspecified) in " +
1:                 (System.currentTimeMillis() - tsStart) + " ms");
1:         rs = stmt.executeQuery(
1:                 "select CLOBDATA from BLOBCLOB where id = " + id);
1:         assertTrue("Clob not inserted", rs.next());
1:         aClob = rs.getClob(1);
1:         assertEquals("Invalid length", length, aClob.length());
1:         println("Fetched length (" + length + ") in " +
1:                 (System.currentTimeMillis() - tsStart) + " ms");
1:         rs.close();
1: 
1:         rollback();
1:     }
1: 
1:     /**
1:      * Insert a row with a large clob into the test table.  Read the row from 
commit:67f1fdd
/////////////////////////////////////////////////////////////////////////
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ClobTest
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** The Name of the method. */
1: 
1:     /** The parameters of the method. */
1: 
1:     /** Tells if exempted in the client framework. */
1:     /** Tells if exempted in the embedded framework. */
1: 
0:      * initialized the object with the details of the
0:      * @param params              A array of Class that contains the parameters
0:      * @param isClientFramework   true if the method is exempted in the
0:      * @param isEmbeddedFramework true if the method is exempted in the
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 
0:      * of this method.
0:      * @return A array of Class containing the type of the parameters
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     // Initialize with the details of the method that are exempted from
0: 
1:         new ExemptClobMD( "getCharacterStream",
1:                 new Class[] { long.class, long.class } ,true,true),
1:         new ExemptClobMD( "setString",
1:                 new Class[] { long.class, String.class } ,false,true),
1:         new ExemptClobMD( "truncate",
1:                 new Class[] { long.class },false,true),
1:         new ExemptClobMD( "free",
1:                 null,true,true)
0: 
0: 
0:     private HashMap<Method,ExemptClobMD> excludedMethodSet =
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void setUp()
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:      *
1:           throws IllegalAccessException, InvocationTargetException, SQLException
0: 
0:         //call the buildHashSetMethod to initialize the
0:         //HashSet with the method signatures that are exempted
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
0:      * Enumerate the methods of the Clob interface and
0:         //set this to true and add it to the
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0:                 if(c == methodList.size() && c != 1)
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      *
0:      * @param parameterTypes an array containing the types of the parameter
0:      * @return an array of Objects containing the null values for the
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
0:      *
1:      Object getNullValueForType(Class type) {
/////////////////////////////////////////////////////////////////////////
0: 
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:          //Stores the byte array representation of
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.sql.SQLException
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:      * Insert a row with a large clob into the test table.  Read the row from
1:      * @throws java.sql.SQLException
1:         // Clob needs to be larger than one page for locking to occur
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:         ResultSet rs =
0: 
0: 
1:      * Try to update the row with the given error.  Flag a failure if a
1:      * @throws java.sql.SQLException
1:     private void executeParallelUpdate(int id, boolean timeoutExpected)
/////////////////////////////////////////////////////////////////////////
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:                         TestConfiguration.defaultSuite(ClobTest.class, false),
1:                         2,
0: 
commit:a78e683
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         throws IllegalAccessException, InvocationTargetException, SQLException {
/////////////////////////////////////////////////////////////////////////
1:     void buildMethodList(Object LOB)
1:             throws IllegalAccessException, InvocationTargetException {
/////////////////////////////////////////////////////////////////////////
1:      * Checks if the method is to be exempted from testing or not.
1:      * @param m the method to check for exemption
1:      * @return <code>false</code> if the method shall be tested,
1:      *      <code>true</code> if the method is exempted and shall not be tested.
1:         boolean isExempted = false;
1:         if (md != null) {
1:             if (usingDerbyNetClient()) {
1:                 isExempted = md.getIfClientFramework();
1:             } else if (usingEmbedded()) {
1:                 isExempted = md.getIfEmbeddedFramework();
0:             } else {
1:                 fail("Unknown test environment/framework");
1:             }
1:         return isExempted;
0: 
/////////////////////////////////////////////////////////////////////////
1:     boolean checkIfMethodThrowsSQLException(Object LOB,Method method)
1:             throws IllegalAccessException, InvocationTargetException {
1:         } catch (InvocationTargetException ite) {
1:             Throwable cause = ite.getCause();
0:             if (cause instanceof SQLException ) {
1:                 return ((SQLException)cause).getSQLState().equals("XJ215");
1:             throw ite;
0: 
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f697326
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         if (clob != null) {
1:             clob.free();
0:             clob = null;
1:         }
/////////////////////////////////////////////////////////////////////////
0:           throws IllegalAccessException, InvocationTargetException, SQLException 
1:     {
1:         clob = BlobClobTestSetup.getSampleClob(getConnection());
0:         
0:         //call the buildHashSetMethod to initialize the 
0:         //HashSet with the method signatures that are exempted 
0:         //from throwing a SQLException after free has been called
0:         //on the Clob object.
0:         buildHashSet();
0:         
0:         InputStream asciiStream = clob.getAsciiStream();
1:         Reader charStream = clob.getCharacterStream();
1:         clob.free();
0:         //testing the idempotence of the free() method
0:         //the method can be called multiple times on
0: 
0:         //the first are treated as no-ops
1:         clob.free();
0: 
0: 
0:         //to the free method so testing calling
0:         //a method on this invalid object should throw
0:         //an SQLException
0:         buildMethodList(clob);
/////////////////////////////////////////////////////////////////////////
0:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * Test that a lock held on the corresponding row is released when free() is
1:      * called on the Clob object.
1:      * @throws java.sql.SQLException 
1:     public void testLockingAfterFree() throws SQLException
1:     {
1:         int id = initializeLongClob();  // Opens clob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
0:         
1:         // Test that update goes through after the clob is closed
0:         clob.free();
1:         executeParallelUpdate(id, false);
0:         
1:         commit();
1:     }
0:     
0:     
1:     /**
1:      * Test that a lock held on the corresponding row is NOT released when
1:      * free() is called on the Clob object if the isolation level is
1:      * Repeatable Read
1:      * @throws java.sql.SQLException
1:      */
1:     public void testLockingAfterFreeWithRR() throws SQLException
1:     {
1:         getConnection().
1:                 setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:         int id = initializeLongClob(); // Opens clob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
0:         
1:         // Test that update still times out after the clob is closed
0:         clob.free();
1:         executeParallelUpdate(id, true);
0:         
1:         // Test that the update goes through after the transaction has committed
1:         commit();
1:         executeParallelUpdate(id, false);
0:     
1:      /**
1:      * Test that a lock held on the corresponding row is released when
1:      * free() is called on the Clob object if the isolation level is
1:      * Read Uncommitted
1:      * @throws java.sql.SQLException
1:      */
1:     public void testLockingAfterFreeWithDirtyReads() throws SQLException
1:     {
1:         getConnection().
1:                 setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         int id = initializeLongClob(); // Opens clob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
0:         
1:        // Test that update goes through after the clob is closed
0:         clob.free();
1:         executeParallelUpdate(id, false);
0:         
1:         commit();
1:     }
0: 
0: 
1:     /**
0:      * Insert a row with a large clob into the test table.  Read the row from 
1:      * the database and assign the clob value to <code>clob</code>.
1:      * @return The id of the row that was inserted
1:      * @throws java.sql.SQLException 
1:      */
1:     private int initializeLongClob() throws SQLException
1:     {
0:         // Clob needs to be larger than one page for locking to occur 
1:         final int lobLength = 40000;
0:  
1:         // Insert a long Clob
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into BLOBCLOB(ID, CLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1,id);
1:         ps.setCharacterStream(2, new LoopingAlphabetReader(lobLength), lobLength);
1:         ps.execute();
1:         ps.close();
1:         commit();
0:         
1:         // Fetch the Clob object from the database
1:         Statement st = createStatement();
0:         ResultSet rs = 
1:                 st.executeQuery("select CLOBDATA from BLOBCLOB where ID=" + id);
1:         rs.next();
1:         clob = rs.getClob(1);
1:         rs.close();
1:         st.close();
0:        
1:         return id;
1:     }
0:      
0: 
1:     /**
0:      * Try to update the row with the given error.  Flag a failure if a 
1:      * timeout occurs when not expected, and vice versa.
1:      * @param id The id of the row to be updated
1:      * @param timeoutExpected true if it is expected that the update times out
1:      * @throws java.sql.SQLException 
1:      */
0:     private void executeParallelUpdate(int id, boolean timeoutExpected) 
1:             throws SQLException
1:     {
1:         Connection conn2 = openDefaultConnection();
1:         Statement stmt2 = conn2.createStatement();
0: 
0:         try {
1:             stmt2.executeUpdate("update BLOBCLOB set BLOBDATA = " +
1:                                 "cast(X'FFFFFF' as blob) where ID=" + id);
1:             stmt2.close();
1:             conn2.commit();
1:             conn2.close();
1:             if (timeoutExpected) {
1:                 fail("FAIL - should have gotten lock timeout");
1:             }
1:          } catch (SQLException se) {
1:             stmt2.close();
1:             conn2.rollback();
1:             conn2.close();
1:             if (timeoutExpected) {
1:                 assertSQLState(LOCK_TIMEOUT, se);
0:             } else {               
1:                 throw se;
1:             }
1:         }
1:     }
0: 
0:     
1:     /**
0:      * Create test suite for this test.
1:      */
1:     public static Test suite()
1:     {
1:         return new BlobClobTestSetup(
1:                 // Reduce lock timeouts so lock test case does not take too long
1:                 DatabasePropertyTestSetup.setLockTimeouts(
0:                         TestConfiguration.defaultSuite(ClobTest.class, false), 
0:                         2, 
1:                         4));
1:     }
0:     
1:     private static final String LOCK_TIMEOUT = "40XL1";
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:cd727e7
/////////////////////////////////////////////////////////////////////////
1:      * Tests the implementation of getCharacterStream(long pos, long length).
0:      * 
1:     public void testGetCharacterStreamLong()
/////////////////////////////////////////////////////////////////////////
1:     public void testGetCharacterStreamLongExceptionConditions()
/////////////////////////////////////////////////////////////////////////
0:         return  new BlobClobTestSetup(
0:                 TestConfiguration.defaultSuite(
0:                 ClobTest.class,
0:                 false));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
0:         clob = BlobClobTestSetup.getSampleClob(getConnection());
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         clob = BlobClobTestSetup.getSampleClob(getXConnection());
/////////////////////////////////////////////////////////////////////////
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================