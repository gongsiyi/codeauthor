1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CurrentOfNode
1:020c39e: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
23:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * The CurrentOf operator is used by positioned DELETE 
1:eac0369:  * and UPDATE to get the current row and location
1:eac0369:  * for the target cursor.  The bind() operations for 
1:eac0369:  * positioned DELETE and UPDATE add a column to 
1:eac0369:  * the select list under the statement for the row location 
1:eac0369:  * accessible from this node.
6:eac0369:  *
1:eac0369:  * This node is placed in the from clause of the select
1:eac0369:  * generated for the delete or update operation. It acts
1:eac0369:  * much like a FromBaseTable, using the information about
1:eac0369:  * the target table of the cursor to provide information.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public final class CurrentOfNode extends FromTable {
1:eac0369: 
1:eac0369: 	private String	 				cursorName;
1:eac0369: 	private ExecPreparedStatement	 preStmt;
1:eac0369: 	private TableName 				exposedTableName;
1:eac0369: 	private TableName 				baseTableName;
1:eac0369: 	private CostEstimate 			singleScanCostEstimate;
1:eac0369: 
1:508a010:     // dummy variables for compiling a CurrentOfNode in the DELETE action of a MERGE statement
1:508a010:     private FromBaseTable       dummyTargetTable;
1:508a010: 
3:eac0369: 	//
1:eac0369: 	// initializers
1:eac0369: 	//
1:3bb140c:     CurrentOfNode(String correlationName,
1:3bb140c:                   String cursor,
1:3bb140c:                   Properties tableProperties,
1:3bb140c:                   ContextManager cm)
2:eac0369: 	{
1:3bb140c:         super(correlationName, tableProperties, cm);
1:3bb140c:         cursorName = cursor;
3:eac0369: 	}
1:eac0369: 
1:508a010:     /**
1:508a010:      * <p>
1:508a010:      * Construct a dummy CurrentOfNode just for compiling the DELETE action of a MERGE
1:508a010:      * statement.
1:508a010:      * </p>
1:508a010:      */
1:508a010:     static  CurrentOfNode   makeForMerge
1:508a010:         (
1:508a010:          String cursorName,
1:508a010:          FromBaseTable  dummyTargetTable,
1:508a010:          ContextManager cm
1:508a010:          )
1:508a010:     {
1:508a010:         CurrentOfNode   node = new CurrentOfNode( null, cursorName, null, cm );
1:508a010:         node.dummyTargetTable = dummyTargetTable;
1:508a010: 
1:508a010:         return node;
1:508a010:     }
1:508a010: 
1:eac0369: 	/*
1:eac0369: 	 * Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#estimateCost
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1:eac0369: 									ConglomerateDescriptor cd,
1:eac0369: 									CostEstimate outerCost,
1:eac0369: 									Optimizer optimizer,
1:eac0369: 									RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Get the cost of a single scan of this result set.
1:eac0369: 		**
1:eac0369: 		** Assume for now that the cost of a CURRENT OF is zero, with one row
1:eac0369: 		** fetched.  Is this true, and if not, does it make a difference?
1:eac0369: 		** CURRENT OF can only occur when there is only one table in the
1:eac0369: 		** FROM list, and when the only "predicate" is the WHERE CURRENT OF,
1:eac0369: 		** so there's nothing to optimize in this case.
1:eac0369: 		*/
1:eac0369: 		if (singleScanCostEstimate == null)
1:eac0369: 		{
1:6a270cb: 			singleScanCostEstimate = getOptimizerFactory().getCostEstimate();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		singleScanCostEstimate.setCost(0.0d, 1.0d, 1.0d);
1:eac0369: 		getBestAccessPath().setCostEstimate(singleScanCostEstimate);
1:eac0369: 		getBestSortAvoidancePath().setCostEstimate(singleScanCostEstimate);
1:eac0369: 
1:eac0369: 		return singleScanCostEstimate;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// FromTable interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Binding this FromTable means finding the prepared statement
1:eac0369: 	 * for the cursor and creating the result columns (the columns
1:eac0369: 	 * updatable on that cursor).
1:eac0369: 	 * 
1:eac0369: 	 * We expect someone else to verify that the target table
1:eac0369: 	 * of the positioned update or delete is the table under this cursor.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for binding
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode		Returns this.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
1:eac0369: 						   FromList fromListParam) 
2:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		// verify that the cursor exists
1:eac0369: 
1:eac0369: 		preStmt = getCursorStatement();
1:eac0369: 
1:eac0369: 		if (preStmt == null) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_FOUND, 
1:eac0369: 						cursorName);
1:eac0369: 		}
1:eac0369: 		
1:4793bcc:         preStmt.rePrepare(getLanguageConnectionContext());
1:eac0369: 
1:eac0369: 		// verify that the cursor is updatable (UPDATE is responsible
1:eac0369: 		// for checking that the right columns are updatable)
1:eac0369: 		if (preStmt.getUpdateMode() != CursorNode.UPDATE)
1:eac0369: 		{
1:eac0369: 			String printableString = (cursorName == null) ? "" : cursorName;
1:eac0369: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_UPDATABLE, printableString);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ExecCursorTableReference refTab = preStmt.getTargetTable();
1:eac0369: 		String schemaName = refTab.getSchemaName();
1:eac0369: 		exposedTableName = makeTableName(null, refTab.getExposedName());
1:eac0369: 		baseTableName = makeTableName(schemaName,
1:eac0369: 									  refTab.getBaseName());
1:3bb140c:         SchemaDescriptor tableSchema =
1:3bb140c:                 getSchemaDescriptor(refTab.getSchemaName());
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** This will only happen when we are binding against a publication
1:eac0369: 		** dictionary w/o the schema we are interested in.
1:eac0369: 		*/
1:eac0369: 		if (tableSchema == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_SCHEMA_DOES_NOT_EXIST, refTab.getSchemaName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Create dependency on target table, in case table not named in 
1:eac0369: 		 * positioned update/delete.  Make sure we find the table descriptor,
1:eac0369: 		 * we may fail to find it if we are binding a publication.
1:eac0369: 		 */
1:eac0369: 		TableDescriptor td = getTableDescriptor(refTab.getBaseName(), tableSchema);
1:eac0369: 
1:eac0369: 		if (td == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, refTab.getBaseName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Add all the result columns from the target table.
1:eac0369: 		** For now, all updatable cursors have all columns
1:eac0369: 		** from the target table.  In the future, we should
1:eac0369: 		** relax this so that the cursor may do a partial
1:eac0369: 		** read and then the current of should make sure that
1:eac0369: 		** it can go to the base table to get all of the 
1:eac0369: 		** columns needed by the referencing positioned
1:eac0369: 		** DML.  In the future, we'll probably need to get
1:eac0369: 		** the result columns from preparedStatement and
1:eac0369: 		** turn them into an RCL that we can run with.
1:eac0369: 		*/
1:11f7ee3:         setResultColumns( new ResultColumnList(getContextManager()) );
1:eac0369: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:eac0369: 		int					 cdlSize = cdl.size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < cdlSize; index++)
1:eac0369: 		{
1:eac0369: 			/* Build a ResultColumn/BaseColumnNode pair for the column */
1:3bb140c:             ColumnDescriptor colDesc = cdl.elementAt(index);
1:eac0369: 
1:3bb140c:             BaseColumnNode bcn = new BaseColumnNode(
1:3bb140c:                                             colDesc.getColumnName(),
1:eac0369: 									  		exposedTableName,
1:eac0369: 											colDesc.getType(),
3:eac0369: 											getContextManager());
1:3bb140c:             ResultColumn rc = new ResultColumn(
1:3bb140c:                 colDesc, bcn, getContextManager());
1:eac0369: 
1:eac0369: 			/* Build the ResultColumnList to return */
1:11f7ee3: 			getResultColumns().addResultColumn(rc);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Assign the tableNumber */
1:eac0369: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1:eac0369: 			tableNumber = getCompilerContext().getNextTableNumber();
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in this ResultSetNode.  This means binding the
1:eac0369: 	 * sub-expressions, as well as figuring out what the return type is for
1:eac0369: 	 * each expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressions(FromList fromListParam)
1:eac0369: 	{
1:eac0369: 		/* No expressions to bind for a CurrentOfNode.
1:eac0369: 		 * NOTE - too involved to optimize so that this method
1:eac0369: 		 * doesn't get called, so just do nothing.
1:eac0369: 		 */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Try to find a ResultColumn in the table represented by this CurrentOfNode
1:eac0369: 	 * that matches the name in the given ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @param columnReference	The columnReference whose name we're looking
1:eac0369: 	 *				for in the given table.
1:eac0369: 	 *
1:eac0369: 	 * @return	A ResultColumn whose expression is the ColumnNode
1:eac0369: 	 *			that matches the ColumnReference.
1:eac0369: 	 *		Returns null if there is no match.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultColumn getMatchingColumn(ColumnReference columnReference)
1:eac0369: 						throws StandardException {
1:eac0369: 
1:508a010:         // if this is a dummy CurrentOfNode cooked up to compile a DELETE action
1:508a010:         // of a MERGE statement, then short-circuit the matching column lookup
1:508a010:         if ( dummyTargetTable != null ) { return dummyTargetTable.getMatchingColumn( columnReference ); }
1:508a010: 
1:eac0369: 		ResultColumn	resultColumn = null;
1:eac0369: 		TableName		columnsTableName;
1:eac0369: 
1:b0456a0: 		columnsTableName = columnReference.getQualifiedTableName();
1:eac0369: 
1:eab88ec:         if (columnsTableName != null
1:eab88ec:                 && columnsTableName.getSchemaName() == null
1:eab88ec:                 && correlationName == null) {
1:eab88ec:             columnsTableName.bind();
1:eab88ec:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(preStmt!=null, "must have prepared statement");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * We use the base table name of the target table.
1:eac0369: 		 * This is necessary since we will be comparing with the table in
1:eac0369: 		 * the delete or update statement which doesn't have a correlation
1:eac0369: 		 * name.  The select for which this column is created might have a
1:eac0369: 		 * correlation name and so we won't find it if we look for exposed names
1:eac0369: 		 * We shouldn't have to worry about multiple table since there should be
1:eac0369: 		 * only one table. Beetle 4419
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(baseTableName!=null,"no name on target table");
1:eac0369: 		}
1:020c39e: 
1:eab88ec:         if (baseTableName != null
1:eab88ec:                 && baseTableName.getSchemaName() == null
1:eab88ec:                 && correlationName == null) {
1:eab88ec:             baseTableName.bind();
1:eab88ec:         }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * If the column did not specify a name, or the specified name
1:eac0369: 		 * matches the table we're looking at, see whether the column
1:eac0369: 		 * is in this table, and also whether it is in the for update list.
1:eac0369: 		*/
1:444aa52: 		if (
1:444aa52: 			   (columnsTableName == null) ||
1:444aa52: 			   (columnsTableName.getFullTableName().equals(baseTableName.getFullTableName())) ||
1:444aa52: 			   ((correlationName != null) && correlationName.equals( columnsTableName.getTableName()))
1:444aa52: 		   )
1:eac0369: 		{
1:3bb140c:             boolean notfound;
1:eac0369: 
1:eac0369: 			resultColumn =
1:11f7ee3: 				getResultColumns().getResultColumn(columnReference.getColumnName());
1:eac0369: 
1:eac0369: 			if (resultColumn != null) 
1:eac0369: 			{
1:fdd3167: 				// If we found the ResultColumn, set the ColumnReference's
1:fdd3167: 				// table number accordingly.  Note: we used to only set
1:fdd3167: 				// the tableNumber for correlated references (as part of
1:fdd3167: 				// changes for DERBY-171) but inspection of code (esp.
1:fdd3167: 				// the comments in FromList.bindColumnReferences() and
1:fdd3167: 				// the getMatchingColumn() methods on other FromTables)
1:fdd3167: 				// suggests that we should always set the table number
1:fdd3167: 				// if we've found the ResultColumn.  So we do that here.
1:444aa52: 				columnReference.setTableNumber( tableNumber );
1:ee21e7c:                 columnReference.setColumnNumber(
1:ee21e7c:                    resultColumn.getColumnPosition());
1:eac0369: 
1:eac0369: 				// If there is a result column, are we really updating it?
1:eac0369: 				// If so, verify that the column is updatable as well
1:eac0369: 				notfound = 
1:eac0369: 					(resultColumn.updatableByCursor() &&
1:dda453e:                      !preStmt.isUpdateColumn(columnReference.getColumnName()));
1:eac0369: 			}
1:eac0369: 			else 
1:eac0369: 			{
1:eac0369: 				notfound = true;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (notfound)
1:eac0369: 			{
1:eac0369: 				String printableString = (cursorName == null) ? "" : cursorName;
1:eac0369: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR, 
1:eac0369: 						 columnReference.getColumnName(), printableString);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return resultColumn;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess a CurrentOfNode.  For a CurrentOfNode, this simply means allocating
1:eac0369: 	 * a referenced table map to avoid downstream NullPointerExceptions.
1:eac0369: 	 * NOTE: There are no bits set in the referenced table map.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode at top of preprocessed tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Generate an empty referenced table map */
1:11f7ee3: 		setReferencedTableMap( new JBitSet(numTables) );
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**			
1:eac0369: 	 * Optimize this CurrentOfNode.  Nothing to do.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:eac0369: 	 * @param predicateList		The PredicateList to optimize.  This should
2:eac0369: 	 *				be a single-table predicate with the table
2:eac0369: 	 *				the same as the table in this FromTable.
1:eac0369: 	 * @param outerRows			The number of outer joining rows
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The top of the optimized subtree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:eac0369: 					     PredicateList predicateList,
1:eac0369: 						 double outerRows) 
1:6a270cb: 						throws StandardException
1:6a270cb:     {
1:eac0369: 		/* Assume there is no cost associated with fetching the current row */
1:6a270cb:         bestCostEstimate = getOptimizerFactory().getCostEstimate();
1:eac0369: 		bestCostEstimate.setCost(0.0d, outerRows, outerRows);
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generation on a CurrentOfNode creates a scan on the
1:eac0369: 	 * cursor, CurrentOfResultSet.
1:eac0369: 	 * <p>
1:eac0369: 	 * This routine will generate and return a call of the form:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 	ResultSetFactory.getCurrentOfResultSet(cursorName)
1:eac0369: 	   </verbatim></pre>
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT(!isStatementResultSet(), 
1:eac0369: 			"CurrentOfNode not expected to be statement node");
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:eac0369: 		mb.pushThis(); // for the putField
1:eac0369: 
1:eac0369: 		// The generated java returned by this method is the expression:
1:eac0369: 		// ResultSetFactory.getCurrentOfResultSet(
1:eac0369: 		//		#cursorName(), this, resultSetNumber)
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		  mb.push(cursorName);
1:eac0369: 		  acb.pushThisAsActivation(mb);
1:11f7ee3: 		  mb.push(getResultSetNumber());
1:eac0369: 		
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCurrentOfResultSet",
1:ec08288: 						ClassName.NoPutResultSet, 3);
1:eac0369: 
1:eac0369: 		mb.cast(ClassName.CursorResultSet);
1:eac0369: 
1:eac0369:         // the current of scan generator is what we return
1:eac0369: 		/* This table is the target of an update or a delete, so we must 
1:eac0369: 		 * wrap the Expression up in an assignment expression before 
1:eac0369: 		 * returning. Delete or update use the field that is set
1:eac0369: 		 * to calculate the CurrentRowLocation value.
1:eac0369: 		 * NOTE - scanExpress is a ResultSet.  We will need to cast it to the
1:eac0369: 		 * appropriate subclass.
1:eac0369: 		 * For example, for a DELETE, instead of returning a call to the 
1:eac0369: 		 * ResultSetFactory, we will generate and return:
1:eac0369: 		 *		this.SCANRESULTSET = (cast to appropriate ResultSet type) 
1:eac0369: 		 * The outer cast back to ResultSet is needed so that
1:eac0369: 		 * we invoke the appropriate method in the call to the ResultSetFactory
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		mb.putField((String) null, acb.getRowLocationScanResultSetName(), ClassName.CursorResultSet);
1:eac0369: 		mb.cast(ClassName.NoPutResultSet);
1:eac0369: 
1:eac0369: 		// add a check at activation reset time to see if the cursor has
1:eac0369: 		// changed underneath us. Doing it in the constructor allows the
1:eac0369: 		// compilation to happen 
1:eac0369: 		MethodBuilder rmb = acb.startResetMethod();
1:eac0369: 
1:eac0369: 		rmb.pushThis();
1:eac0369: 		rmb.push(cursorName);
1:eac0369: 		rmb.push(preStmt.getObjectName());
1:eac0369: 		rmb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "checkPositionedStatement",
1:eac0369: 						"void", 2);
1:eac0369: 
1:eac0369: 		rmb.methodReturn();
1:eac0369: 		rmb.complete();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth) {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			printLabel(depth, "cursor: ");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			return "preparedStatement: " +
1:eac0369: 		    	(preStmt == null? "no prepared statement yet\n" :
1:eac0369: 			 	preStmt.toString() + "\n")+
1:eac0369: 				cursorName + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		} else {
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     String  getExposedName()
1:eac0369: 	{
1:508a010:         // short-circuit for dummy CurrentOfNode cooked up to support
1:508a010:         // the DELETE action of a MERGE statement
1:508a010:         if ( dummyTargetTable != null ) { return dummyTargetTable.getExposedName(); }
1:508a010:         
1:eac0369: 		return exposedTableName.getFullTableName();
1:eac0369: 	}
1:3bb140c: 
1:3bb140c:     /**
1:3bb140c:      * Get the lock mode for this table as the target of an update statement
1:3bb140c:      * (a delete or update).  This is implemented only for base tables and
1:3bb140c:      * CurrentOfNodes.
1:3bb140c:      *
1:3bb140c:      * @see TransactionController
1:3bb140c:      *
1:3bb140c:      * @return  The lock mode
1:3bb140c:      */
1:3bb140c:     @Override
1:3bb140c:     public int updateTargetLockMode()
1:3bb140c:     {
1:3bb140c:         /* Do row locking for positioned update/delete */
1:3bb140c:         return TransactionController.MODE_RECORD;
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     //
1:3bb140c:     // class interface
1:3bb140c:     //
1:3bb140c:     TableName  getExposedTableName()
1:eac0369: 	{
1:eac0369: 		return exposedTableName;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     TableName  getBaseCursorTargetTableName()
1:eac0369: 	{
1:eac0369: 		return baseTableName;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     String getCursorName()
1:eac0369: 	{
1:eac0369: 		return cursorName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the CursorNode associated with a positioned update/delete.
1:eac0369: 	 * 
1:eac0369: 	 * @return CursorNode	The associated CursorNode.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	ExecPreparedStatement getCursorStatement()
1:eac0369: 	{
1:eac0369: 		Activation activation = getLanguageConnectionContext().lookupCursorActivation(cursorName);
1:eac0369: 
1:eac0369: 		if (activation == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		return activation.getPreparedStatement();
1:eac0369: 	}
1:69f8afa: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (exposedTableName != null) {
1:69f8afa:             exposedTableName = (TableName) exposedTableName.accept(v);
1:69f8afa:         }
1:69f8afa: 
1:69f8afa:         if (baseTableName != null) {
1:69f8afa:             baseTableName = (TableName) baseTableName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:eab88ec
/////////////////////////////////////////////////////////////////////////
1:         if (columnsTableName != null
1:                 && columnsTableName.getSchemaName() == null
1:                 && correlationName == null) {
1:             columnsTableName.bind();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (baseTableName != null
1:                 && baseTableName.getSchemaName() == null
1:                 && correlationName == null) {
1:             baseTableName.bind();
1:         }
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (exposedTableName != null) {
1:             exposedTableName = (TableName) exposedTableName.accept(v);
1:         }
1: 
1:         if (baseTableName != null) {
1:             baseTableName = (TableName) baseTableName.accept(v);
1:         }
1:     }
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:dda453e
/////////////////////////////////////////////////////////////////////////
1:                      !preStmt.isUpdateColumn(columnReference.getColumnName()));
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( new ResultColumnList(getContextManager()) );
/////////////////////////////////////////////////////////////////////////
1: 			getResultColumns().addResultColumn(rc);
/////////////////////////////////////////////////////////////////////////
1: 				getResultColumns().getResultColumn(columnReference.getColumnName());
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( new JBitSet(numTables) );
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(!isStatementResultSet(), 
/////////////////////////////////////////////////////////////////////////
1: 		  mb.push(getResultSetNumber());
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 		columnsTableName = columnReference.getQualifiedTableName();
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:     // dummy variables for compiling a CurrentOfNode in the DELETE action of a MERGE statement
1:     private FromBaseTable       dummyTargetTable;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Construct a dummy CurrentOfNode just for compiling the DELETE action of a MERGE
1:      * statement.
1:      * </p>
1:      */
1:     static  CurrentOfNode   makeForMerge
1:         (
1:          String cursorName,
1:          FromBaseTable  dummyTargetTable,
1:          ContextManager cm
1:          )
1:     {
1:         CurrentOfNode   node = new CurrentOfNode( null, cursorName, null, cm );
1:         node.dummyTargetTable = dummyTargetTable;
1: 
1:         return node;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // if this is a dummy CurrentOfNode cooked up to compile a DELETE action
1:         // of a MERGE statement, then short-circuit the matching column lookup
1:         if ( dummyTargetTable != null ) { return dummyTargetTable.getMatchingColumn( columnReference ); }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // short-circuit for dummy CurrentOfNode cooked up to support
1:         // the DELETE action of a MERGE statement
1:         if ( dummyTargetTable != null ) { return dummyTargetTable.getExposedName(); }
1:         
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
1: 			singleScanCostEstimate = getOptimizerFactory().getCostEstimate();
/////////////////////////////////////////////////////////////////////////
1: 						throws StandardException
1:     {
1:         bestCostEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
0:                          (RequiredRowOrdering) null,
0:                          null );
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
1:     CurrentOfNode(String correlationName,
1:                   String cursor,
1:                   Properties tableProperties,
1:                   ContextManager cm)
1:         super(correlationName, tableProperties, cm);
0:         setNodeType(C_NodeTypes.CURRENT_OF_NODE);
1:         cursorName = cursor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:         SchemaDescriptor tableSchema =
1:                 getSchemaDescriptor(refTab.getSchemaName());
/////////////////////////////////////////////////////////////////////////
0:         resultColumns = new ResultColumnList(getContextManager());
1:             ColumnDescriptor colDesc = cdl.elementAt(index);
1:             BaseColumnNode bcn = new BaseColumnNode(
1:                                             colDesc.getColumnName(),
1:             ResultColumn rc = new ResultColumn(
1:                 colDesc, bcn, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressions(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultColumn getMatchingColumn(ColumnReference columnReference)
/////////////////////////////////////////////////////////////////////////
1:             boolean notfound;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
0:         Optimizer opt =
0:             getOptimizer(new FromList(
0:                              getOptimizerFactory().doJoinOrderOptimization(),
0:                              this,
0:                              getContextManager()),
0:                          predicateList,
0:                          dataDictionary,
0:                          (RequiredRowOrdering) null);
0:         bestCostEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String  getExposedName()
1: 
1:     /**
1:      * Get the lock mode for this table as the target of an update statement
1:      * (a delete or update).  This is implemented only for base tables and
1:      * CurrentOfNodes.
1:      *
1:      * @see TransactionController
1:      *
1:      * @return  The lock mode
1:      */
1:     @Override
1:     public int updateTargetLockMode()
1:     {
1:         /* Do row locking for positioned update/delete */
1:         return TransactionController.MODE_RECORD;
1:     }
1: 
1:     //
1:     // class interface
1:     //
1:     TableName  getExposedTableName()
1:     TableName  getBaseCursorTargetTableName()
1:     String getCursorName()
/////////////////////////////////////////////////////////////////////////
commit:ee21e7c
/////////////////////////////////////////////////////////////////////////
1:                 columnReference.setColumnNumber(
1:                    resultColumn.getColumnPosition());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4793bcc
/////////////////////////////////////////////////////////////////////////
1:         preStmt.rePrepare(getLanguageConnectionContext());
/////////////////////////////////////////////////////////////////////////
commit:ec08288
/////////////////////////////////////////////////////////////////////////
1: 						ClassName.NoPutResultSet, 3);
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
0: 		if (preStmt!=null) {
0: 			preStmt.rePrepare(getLanguageConnectionContext());
commit:020c39e
/////////////////////////////////////////////////////////////////////////
0:         if(columnsTableName != null)
0:             if(columnsTableName.getSchemaName() == null && correlationName == null)
0:                 columnsTableName.bind(this.getDataDictionary());
1: 
/////////////////////////////////////////////////////////////////////////
0:         if(baseTableName != null)
0:             if(baseTableName.getSchemaName() == null && correlationName == null)
0:                 baseTableName.bind(this.getDataDictionary());
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CurrentOfNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
1: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * The CurrentOf operator is used by positioned DELETE 
1:  * and UPDATE to get the current row and location
1:  * for the target cursor.  The bind() operations for 
1:  * positioned DELETE and UPDATE add a column to 
1:  * the select list under the statement for the row location 
1:  * accessible from this node.
1:  *
1:  * This node is placed in the from clause of the select
1:  * generated for the delete or update operation. It acts
1:  * much like a FromBaseTable, using the information about
1:  * the target table of the cursor to provide information.
1:  *
0:  * @author ames
1:  */
1: public final class CurrentOfNode extends FromTable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private String	 				cursorName;
1: 	private ExecPreparedStatement	 preStmt;
1: 	private TableName 				exposedTableName;
1: 	private TableName 				baseTableName;
1: 	private CostEstimate 			singleScanCostEstimate;
1: 
1: 	//
1: 	// initializers
1: 	//
0: 	public void init(Object cursor, Object tableProperties)
1: 	{
0: 		super.init(null, tableProperties);
0: 		cursorName = (String) cursor;
1: 	}
1: 
1: 	/*
1: 	 * Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see Optimizable#estimateCost
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1: 									ConglomerateDescriptor cd,
1: 									CostEstimate outerCost,
1: 									Optimizer optimizer,
1: 									RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		/*
1: 		** Get the cost of a single scan of this result set.
1: 		**
1: 		** Assume for now that the cost of a CURRENT OF is zero, with one row
1: 		** fetched.  Is this true, and if not, does it make a difference?
1: 		** CURRENT OF can only occur when there is only one table in the
1: 		** FROM list, and when the only "predicate" is the WHERE CURRENT OF,
1: 		** so there's nothing to optimize in this case.
1: 		*/
1: 		if (singleScanCostEstimate == null)
1: 		{
0: 			singleScanCostEstimate = optimizer.newCostEstimate();
1: 		}
1: 
1: 		singleScanCostEstimate.setCost(0.0d, 1.0d, 1.0d);
1: 		getBestAccessPath().setCostEstimate(singleScanCostEstimate);
1: 		getBestSortAvoidancePath().setCostEstimate(singleScanCostEstimate);
1: 
1: 		return singleScanCostEstimate;
1: 	}
1: 
1: 	//
1: 	// FromTable interface
1: 	//
1: 
1: 	/**
1: 	 * Binding this FromTable means finding the prepared statement
1: 	 * for the cursor and creating the result columns (the columns
1: 	 * updatable on that cursor).
1: 	 * 
1: 	 * We expect someone else to verify that the target table
1: 	 * of the positioned update or delete is the table under this cursor.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for binding
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode		Returns this.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
1: 						   FromList fromListParam) 
1: 		throws StandardException {
1: 
1: 		// verify that the cursor exists
0: 		// and create a dependency on it
1: 
1: 		preStmt = getCursorStatement();
0: 		if ((preStmt!=null) && (! preStmt.upToDate())) {
0: 			preStmt.makeValid(getLanguageConnectionContext()); // need to have the query tree
0: 			if (! preStmt.isValid()) // can't make it valid, say not found
0: 				preStmt = null;
1: 		}
1: 
1: 		if (preStmt == null) {
1: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_FOUND, 
1: 						cursorName);
1: 		}
1: 		
1: 
1: 		// verify that the cursor is updatable (UPDATE is responsible
1: 		// for checking that the right columns are updatable)
1: 		if (preStmt.getUpdateMode() != CursorNode.UPDATE)
1: 		{
1: 			String printableString = (cursorName == null) ? "" : cursorName;
1: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_UPDATABLE, printableString);
1: 		}
1: 
0: 		getCompilerContext().createDependency(preStmt);
1: 
1: 		ExecCursorTableReference refTab = preStmt.getTargetTable();
1: 		String schemaName = refTab.getSchemaName();
1: 		exposedTableName = makeTableName(null, refTab.getExposedName());
1: 		baseTableName = makeTableName(schemaName,
1: 									  refTab.getBaseName());
0: 		SchemaDescriptor tableSchema = null;
0: 		tableSchema = getSchemaDescriptor(refTab.getSchemaName());
1: 
1: 		/*
1: 		** This will only happen when we are binding against a publication
1: 		** dictionary w/o the schema we are interested in.
1: 		*/
1: 		if (tableSchema == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_SCHEMA_DOES_NOT_EXIST, refTab.getSchemaName());
1: 		}
1: 
1: 		/* Create dependency on target table, in case table not named in 
1: 		 * positioned update/delete.  Make sure we find the table descriptor,
1: 		 * we may fail to find it if we are binding a publication.
1: 		 */
1: 		TableDescriptor td = getTableDescriptor(refTab.getBaseName(), tableSchema);
1: 
1: 		if (td == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, refTab.getBaseName());
1: 		}
1: 
1: 
1: 		/*
1: 		** Add all the result columns from the target table.
1: 		** For now, all updatable cursors have all columns
1: 		** from the target table.  In the future, we should
1: 		** relax this so that the cursor may do a partial
1: 		** read and then the current of should make sure that
1: 		** it can go to the base table to get all of the 
1: 		** columns needed by the referencing positioned
1: 		** DML.  In the future, we'll probably need to get
1: 		** the result columns from preparedStatement and
1: 		** turn them into an RCL that we can run with.
1: 		*/
0: 		resultColumns = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
1: 											getContextManager());
1: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1: 		int					 cdlSize = cdl.size();
1: 
1: 		for (int index = 0; index < cdlSize; index++)
1: 		{
1: 			/* Build a ResultColumn/BaseColumnNode pair for the column */
0: 			ColumnDescriptor colDesc = (ColumnDescriptor) cdl.elementAt(index);
1: 
0: 			BaseColumnNode bcn = (BaseColumnNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BASE_COLUMN_NODE,
0: 											colDesc.getColumnName(),
1: 									  		exposedTableName,
1: 											colDesc.getType(),
1: 											getContextManager());
0: 			ResultColumn rc = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											colDesc,
0: 											bcn,
1: 											getContextManager());
1: 
1: 			/* Build the ResultColumnList to return */
0: 			resultColumns.addResultColumn(rc);
1: 		}
1: 
1: 		/* Assign the tableNumber */
1: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1: 			tableNumber = getCompilerContext().getNextTableNumber();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this ResultSetNode.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is for
1: 	 * each expression.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 */
0: 	public void bindExpressions(FromList fromListParam)
1: 	{
1: 		/* No expressions to bind for a CurrentOfNode.
1: 		 * NOTE - too involved to optimize so that this method
1: 		 * doesn't get called, so just do nothing.
1: 		 */
1: 	}
1: 
1: 	/**
1: 	 * Try to find a ResultColumn in the table represented by this CurrentOfNode
1: 	 * that matches the name in the given ColumnReference.
1: 	 *
1: 	 * @param columnReference	The columnReference whose name we're looking
1: 	 *				for in the given table.
1: 	 *
1: 	 * @return	A ResultColumn whose expression is the ColumnNode
1: 	 *			that matches the ColumnReference.
1: 	 *		Returns null if there is no match.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultColumn getMatchingColumn(ColumnReference columnReference) 
1: 						throws StandardException {
1: 
1: 		ResultColumn	resultColumn = null;
1: 		TableName		columnsTableName;
1: 
0: 		columnsTableName = columnReference.getTableNameNode();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(preStmt!=null, "must have prepared statement");
1: 		}
1: 
1: 		/*
1: 		 * We use the base table name of the target table.
1: 		 * This is necessary since we will be comparing with the table in
1: 		 * the delete or update statement which doesn't have a correlation
1: 		 * name.  The select for which this column is created might have a
1: 		 * correlation name and so we won't find it if we look for exposed names
1: 		 * We shouldn't have to worry about multiple table since there should be
1: 		 * only one table. Beetle 4419
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(baseTableName!=null,"no name on target table");
1: 		}
1: 
1: 		/*
1: 		 * If the column did not specify a name, or the specified name
1: 		 * matches the table we're looking at, see whether the column
1: 		 * is in this table, and also whether it is in the for update list.
1: 		*/
0: 		if (columnsTableName == null || columnsTableName.getFullTableName().equals(baseTableName.getFullTableName()))
1: 		{
0: 			boolean notfound = false;
1: 
1: 			resultColumn =
0: 				resultColumns.getResultColumn(columnReference.getColumnName());
1: 
1: 			if (resultColumn != null) 
1: 			{
1: 				// If there is a result column, are we really updating it?
1: 				// If so, verify that the column is updatable as well
1: 				notfound = 
1: 					(resultColumn.updatableByCursor() &&
0: 					!foundString(
0: 							preStmt.getUpdateColumns(), 
0: 							columnReference.getColumnName()));
1: 			}
1: 			else 
1: 			{
1: 				notfound = true;
1: 			}
1: 
1: 			if (notfound)
1: 			{
1: 				String printableString = (cursorName == null) ? "" : cursorName;
1: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR, 
1: 						 columnReference.getColumnName(), printableString);
1: 			}
1: 		}
1: 
1: 		return resultColumn;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess a CurrentOfNode.  For a CurrentOfNode, this simply means allocating
1: 	 * a referenced table map to avoid downstream NullPointerExceptions.
1: 	 * NOTE: There are no bits set in the referenced table map.
1: 	 *
1: 	 * @param numTables			The number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return ResultSetNode at top of preprocessed tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 		/* Generate an empty referenced table map */
0: 		referencedTableMap = new JBitSet(numTables);
1: 		return this;
1: 	}
1: 
1: 	/**			
1: 	 * Optimize this CurrentOfNode.  Nothing to do.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicate		The predicate to optimize.  This should
1: 	 *				be a single-table predicate with the table
1: 	 *				the same as the table in this FromTable.
1: 	 * @param predicateList		The PredicateList to optimize.  This should
1: 	 *				be a single-table predicate with the table
1: 	 *				the same as the table in this FromTable.
1: 	 * @param outerRows			The number of outer joining rows
1: 	 *
1: 	 * @return ResultSetNode	The top of the optimized subtree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 					     PredicateList predicateList,
1: 						 double outerRows) 
1: 						throws StandardException {
0: 		/* Get an optimizer so we can get a cost */
0: 		Optimizer optimizer = getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									this,
0: 									getContextManager()),
0: 								predicateList,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
1: 
1: 		/* Assume there is no cost associated with fetching the current row */
0: 		bestCostEstimate = optimizer.newCostEstimate();
1: 		bestCostEstimate.setCost(0.0d, outerRows, outerRows);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Generation on a CurrentOfNode creates a scan on the
1: 	 * cursor, CurrentOfResultSet.
1: 	 * <p>
1: 	 * This routine will generate and return a call of the form:
1: 	 * <pre><verbatim>
1: 	 	ResultSetFactory.getCurrentOfResultSet(cursorName)
1: 	   </verbatim></pre>
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The execute() method to be built
1: 	 *
0: 	 * @return		A compiled Expression that returns a ResultSet that
0: 	 *				scans the table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException {
1: 
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(!statementResultSet, 
1: 			"CurrentOfNode not expected to be statement node");
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 		mb.pushThis(); // for the putField
1: 
1: 		// The generated java returned by this method is the expression:
1: 		// ResultSetFactory.getCurrentOfResultSet(
1: 		//		#cursorName(), this, resultSetNumber)
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		  mb.push(cursorName);
1: 		  acb.pushThisAsActivation(mb);
0: 		  mb.push(resultSetNumber);
0: 		  mb.push(preStmt.getObjectName());
1: 		
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCurrentOfResultSet",
0: 						ClassName.NoPutResultSet, 4);
1: 
1: 		mb.cast(ClassName.CursorResultSet);
1: 
1:         // the current of scan generator is what we return
1: 		/* This table is the target of an update or a delete, so we must 
1: 		 * wrap the Expression up in an assignment expression before 
1: 		 * returning. Delete or update use the field that is set
1: 		 * to calculate the CurrentRowLocation value.
1: 		 * NOTE - scanExpress is a ResultSet.  We will need to cast it to the
1: 		 * appropriate subclass.
1: 		 * For example, for a DELETE, instead of returning a call to the 
1: 		 * ResultSetFactory, we will generate and return:
1: 		 *		this.SCANRESULTSET = (cast to appropriate ResultSet type) 
1: 		 * The outer cast back to ResultSet is needed so that
1: 		 * we invoke the appropriate method in the call to the ResultSetFactory
1: 		 */
1: 
1: 		mb.putField((String) null, acb.getRowLocationScanResultSetName(), ClassName.CursorResultSet);
1: 		mb.cast(ClassName.NoPutResultSet);
1: 
1: 		// add a check at activation reset time to see if the cursor has
1: 		// changed underneath us. Doing it in the constructor allows the
1: 		// compilation to happen 
1: 		MethodBuilder rmb = acb.startResetMethod();
1: 
1: 		rmb.pushThis();
1: 		rmb.push(cursorName);
1: 		rmb.push(preStmt.getObjectName());
1: 		rmb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "checkPositionedStatement",
1: 						"void", 2);
1: 
1: 		rmb.methodReturn();
1: 		rmb.complete();
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
0: 	public void printSubNodes(int depth) {
1: 		if (SanityManager.DEBUG) {
1: 			super.printSubNodes(depth);
1: 
1: 			printLabel(depth, "cursor: ");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 	public String toString() {
1: 		if (SanityManager.DEBUG) {
1: 			return "preparedStatement: " +
1: 		    	(preStmt == null? "no prepared statement yet\n" :
1: 			 	preStmt.toString() + "\n")+
1: 				cursorName + "\n" +
1: 				super.toString();
1: 		} else {
1: 			return "";
1: 		}
1: 	}
1: 
1: 	//
0: 	// class interface
1: 	//
1: 
0: 	public String  getExposedName()
1: 	{
1: 		return exposedTableName.getFullTableName();
1: 	}
0: 	public TableName  getExposedTableName()
1: 	{
1: 		return exposedTableName;
1: 	}
1: 
0: 	public TableName  getBaseCursorTargetTableName()
1: 	{
1: 		return baseTableName;
1: 	}
1: 
0: 	public String getCursorName() 
1: 	{
1: 		return cursorName;
1: 	}
1: 
1: 	/**
1: 	 * Return the CursorNode associated with a positioned update/delete.
1: 	 * 
1: 	 * @return CursorNode	The associated CursorNode.
1: 	 *
1: 	 */
1: 	ExecPreparedStatement getCursorStatement()
1: 	{
1: 		Activation activation = getLanguageConnectionContext().lookupCursorActivation(cursorName);
1: 
1: 		if (activation == null)
1: 			return null;
1: 
1: 		return activation.getPreparedStatement();
1: 	}
1: 
1: 	/**
0: 	 * Get the lock mode for this table as the target of an update statement
0: 	 * (a delete or update).  This is implemented only for base tables and
0: 	 * CurrentOfNodes.
1: 	 *
0: 	 * @see TransactionController
1: 	 *
0: 	 * @return	The lock mode
1: 	 */
0: 	public int updateTargetLockMode()
1: 	{
0: 		/* Do row locking for positioned update/delete */
0: 		return TransactionController.MODE_RECORD;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 	public void init( Object correlationName, Object cursor, Object tableProperties)
0: 		super.init(correlationName, tableProperties);
/////////////////////////////////////////////////////////////////////////
1: 		if (
1: 			   (columnsTableName == null) ||
1: 			   (columnsTableName.getFullTableName().equals(baseTableName.getFullTableName())) ||
1: 			   ((correlationName != null) && correlationName.equals( columnsTableName.getTableName()))
1: 		   )
/////////////////////////////////////////////////////////////////////////
0: 		/*
0: 		 * Patch up the table number for correlated references.
0: 		 * Part of the fix for bug 171.
0: 		 */
0: 		if ( (correlationName != null) && (columnReference.getTableNumber() < 0) )
0: 		{
1: 			columnReference.setTableNumber( tableNumber );
0: 		}
0: 		
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:fdd3167
/////////////////////////////////////////////////////////////////////////
1: 				// If we found the ResultColumn, set the ColumnReference's
1: 				// table number accordingly.  Note: we used to only set
1: 				// the tableNumber for correlated references (as part of
1: 				// changes for DERBY-171) but inspection of code (esp.
1: 				// the comments in FromList.bindColumnReferences() and
1: 				// the getMatchingColumn() methods on other FromTables)
1: 				// suggests that we should always set the table number
1: 				// if we've found the ResultColumn.  So we do that here.
0: 				columnReference.setTableNumber( tableNumber );
0: 
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * The CurrentOf operator is used by positioned DELETE 
0:  * and UPDATE to get the current row and location
0:  * for the target cursor.  The bind() operations for 
0:  * positioned DELETE and UPDATE add a column to 
0:  * the select list under the statement for the row location 
0:  * accessible from this node.
0:  *
0:  * This node is placed in the from clause of the select
0:  * generated for the delete or update operation. It acts
0:  * much like a FromBaseTable, using the information about
0:  * the target table of the cursor to provide information.
0:  *
0:  * @author ames
0:  */
0: public final class CurrentOfNode extends FromTable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private String	 				cursorName;
0: 	private ExecPreparedStatement	 preStmt;
0: 	private TableName 				exposedTableName;
0: 	private TableName 				baseTableName;
0: 	private CostEstimate 			singleScanCostEstimate;
0: 
0: 	//
0: 	// initializers
0: 	//
0: 	public void init(Object cursor, Object tableProperties)
0: 	{
0: 		super.init(null, tableProperties);
0: 		cursorName = (String) cursor;
0: 	}
0: 
0: 	/*
0: 	 * Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see Optimizable#estimateCost
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
0: 									ConglomerateDescriptor cd,
0: 									CostEstimate outerCost,
0: 									Optimizer optimizer,
0: 									RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** Get the cost of a single scan of this result set.
0: 		**
0: 		** Assume for now that the cost of a CURRENT OF is zero, with one row
0: 		** fetched.  Is this true, and if not, does it make a difference?
0: 		** CURRENT OF can only occur when there is only one table in the
0: 		** FROM list, and when the only "predicate" is the WHERE CURRENT OF,
0: 		** so there's nothing to optimize in this case.
0: 		*/
0: 		if (singleScanCostEstimate == null)
0: 		{
0: 			singleScanCostEstimate = optimizer.newCostEstimate();
0: 		}
0: 
0: 		singleScanCostEstimate.setCost(0.0d, 1.0d, 1.0d);
0: 		getBestAccessPath().setCostEstimate(singleScanCostEstimate);
0: 		getBestSortAvoidancePath().setCostEstimate(singleScanCostEstimate);
0: 
0: 		return singleScanCostEstimate;
0: 	}
0: 
0: 	//
0: 	// FromTable interface
0: 	//
0: 
0: 	/**
0: 	 * Binding this FromTable means finding the prepared statement
0: 	 * for the cursor and creating the result columns (the columns
0: 	 * updatable on that cursor).
0: 	 * 
0: 	 * We expect someone else to verify that the target table
0: 	 * of the positioned update or delete is the table under this cursor.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode		Returns this.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
0: 						   FromList fromListParam) 
0: 		throws StandardException {
0: 
0: 		// verify that the cursor exists
0: 		// and create a dependency on it
0: 
0: 		preStmt = getCursorStatement();
0: 		if ((preStmt!=null) && (! preStmt.upToDate())) {
0: 			preStmt.makeValid(getLanguageConnectionContext()); // need to have the query tree
0: 			if (! preStmt.isValid()) // can't make it valid, say not found
0: 				preStmt = null;
0: 		}
0: 
0: 		if (preStmt == null) {
0: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_FOUND, 
0: 						cursorName);
0: 		}
0: 		
0: 
0: 		// verify that the cursor is updatable (UPDATE is responsible
0: 		// for checking that the right columns are updatable)
0: 		if (preStmt.getUpdateMode() != CursorNode.UPDATE)
0: 		{
0: 			String printableString = (cursorName == null) ? "" : cursorName;
0: 			throw StandardException.newException(SQLState.LANG_CURSOR_NOT_UPDATABLE, printableString);
0: 		}
0: 
0: 		getCompilerContext().createDependency(preStmt);
0: 
0: 		ExecCursorTableReference refTab = preStmt.getTargetTable();
0: 		String schemaName = refTab.getSchemaName();
0: 		exposedTableName = makeTableName(null, refTab.getExposedName());
0: 		baseTableName = makeTableName(schemaName,
0: 									  refTab.getBaseName());
0: 		SchemaDescriptor tableSchema = null;
0: 		tableSchema = getSchemaDescriptor(refTab.getSchemaName());
0: 
0: 		/*
0: 		** This will only happen when we are binding against a publication
0: 		** dictionary w/o the schema we are interested in.
0: 		*/
0: 		if (tableSchema == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_SCHEMA_DOES_NOT_EXIST, refTab.getSchemaName());
0: 		}
0: 
0: 		/* Create dependency on target table, in case table not named in 
0: 		 * positioned update/delete.  Make sure we find the table descriptor,
0: 		 * we may fail to find it if we are binding a publication.
0: 		 */
0: 		TableDescriptor td = getTableDescriptor(refTab.getBaseName(), tableSchema);
0: 
0: 		if (td == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, refTab.getBaseName());
0: 		}
0: 
0: 
0: 		/*
0: 		** Add all the result columns from the target table.
0: 		** For now, all updatable cursors have all columns
0: 		** from the target table.  In the future, we should
0: 		** relax this so that the cursor may do a partial
0: 		** read and then the current of should make sure that
0: 		** it can go to the base table to get all of the 
0: 		** columns needed by the referencing positioned
0: 		** DML.  In the future, we'll probably need to get
0: 		** the result columns from preparedStatement and
0: 		** turn them into an RCL that we can run with.
0: 		*/
0: 		resultColumns = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
0: 											getContextManager());
0: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
0: 		int					 cdlSize = cdl.size();
0: 
0: 		for (int index = 0; index < cdlSize; index++)
0: 		{
0: 			/* Build a ResultColumn/BaseColumnNode pair for the column */
0: 			ColumnDescriptor colDesc = (ColumnDescriptor) cdl.elementAt(index);
0: 
0: 			BaseColumnNode bcn = (BaseColumnNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BASE_COLUMN_NODE,
0: 											colDesc.getColumnName(),
0: 									  		exposedTableName,
0: 											colDesc.getType(),
0: 											getContextManager());
0: 			ResultColumn rc = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											colDesc,
0: 											bcn,
0: 											getContextManager());
0: 
0: 			/* Build the ResultColumnList to return */
0: 			resultColumns.addResultColumn(rc);
0: 		}
0: 
0: 		/* Assign the tableNumber */
0: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
0: 			tableNumber = getCompilerContext().getNextTableNumber();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this ResultSetNode.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is for
0: 	 * each expression.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 */
0: 	public void bindExpressions(FromList fromListParam)
0: 	{
0: 		/* No expressions to bind for a CurrentOfNode.
0: 		 * NOTE - too involved to optimize so that this method
0: 		 * doesn't get called, so just do nothing.
0: 		 */
0: 	}
0: 
0: 	/**
0: 	 * Try to find a ResultColumn in the table represented by this CurrentOfNode
0: 	 * that matches the name in the given ColumnReference.
0: 	 *
0: 	 * @param columnReference	The columnReference whose name we're looking
0: 	 *				for in the given table.
0: 	 *
0: 	 * @return	A ResultColumn whose expression is the ColumnNode
0: 	 *			that matches the ColumnReference.
0: 	 *		Returns null if there is no match.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultColumn getMatchingColumn(ColumnReference columnReference) 
0: 						throws StandardException {
0: 
0: 		ResultColumn	resultColumn = null;
0: 		TableName		columnsTableName;
0: 
0: 		columnsTableName = columnReference.getTableNameNode();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(preStmt!=null, "must have prepared statement");
0: 		}
0: 
0: 		/*
0: 		 * We use the base table name of the target table.
0: 		 * This is necessary since we will be comparing with the table in
0: 		 * the delete or update statement which doesn't have a correlation
0: 		 * name.  The select for which this column is created might have a
0: 		 * correlation name and so we won't find it if we look for exposed names
0: 		 * We shouldn't have to worry about multiple table since there should be
0: 		 * only one table. Beetle 4419
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(baseTableName!=null,"no name on target table");
0: 		}
0: 
0: 		/*
0: 		 * If the column did not specify a name, or the specified name
0: 		 * matches the table we're looking at, see whether the column
0: 		 * is in this table, and also whether it is in the for update list.
0: 		*/
0: 		if (columnsTableName == null || columnsTableName.getFullTableName().equals(baseTableName.getFullTableName()))
0: 		{
0: 			boolean notfound = false;
0: 
0: 			resultColumn =
0: 				resultColumns.getResultColumn(columnReference.getColumnName());
0: 
0: 			if (resultColumn != null) 
0: 			{
0: 				// If there is a result column, are we really updating it?
0: 				// If so, verify that the column is updatable as well
0: 				notfound = 
0: 					(resultColumn.updatableByCursor() &&
0: 					!foundString(
0: 							preStmt.getUpdateColumns(), 
0: 							columnReference.getColumnName()));
0: 			}
0: 			else 
0: 			{
0: 				notfound = true;
0: 			}
0: 
0: 			if (notfound)
0: 			{
0: 				String printableString = (cursorName == null) ? "" : cursorName;
0: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR, 
0: 						 columnReference.getColumnName(), printableString);
0: 			}
0: 		}
0: 
0: 		return resultColumn;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess a CurrentOfNode.  For a CurrentOfNode, this simply means allocating
0: 	 * a referenced table map to avoid downstream NullPointerExceptions.
0: 	 * NOTE: There are no bits set in the referenced table map.
0: 	 *
0: 	 * @param numTables			The number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return ResultSetNode at top of preprocessed tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		/* Generate an empty referenced table map */
0: 		referencedTableMap = new JBitSet(numTables);
0: 		return this;
0: 	}
0: 
0: 	/**			
0: 	 * Optimize this CurrentOfNode.  Nothing to do.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicate		The predicate to optimize.  This should
0: 	 *				be a single-table predicate with the table
0: 	 *				the same as the table in this FromTable.
0: 	 * @param predicateList		The PredicateList to optimize.  This should
0: 	 *				be a single-table predicate with the table
0: 	 *				the same as the table in this FromTable.
0: 	 * @param outerRows			The number of outer joining rows
0: 	 *
0: 	 * @return ResultSetNode	The top of the optimized subtree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 					     PredicateList predicateList,
0: 						 double outerRows) 
0: 						throws StandardException {
0: 		/* Get an optimizer so we can get a cost */
0: 		Optimizer optimizer = getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									this,
0: 									getContextManager()),
0: 								predicateList,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
0: 
0: 		/* Assume there is no cost associated with fetching the current row */
0: 		bestCostEstimate = optimizer.newCostEstimate();
0: 		bestCostEstimate.setCost(0.0d, outerRows, outerRows);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Generation on a CurrentOfNode creates a scan on the
0: 	 * cursor, CurrentOfResultSet.
0: 	 * <p>
0: 	 * This routine will generate and return a call of the form:
0: 	 * <pre><verbatim>
0: 	 	ResultSetFactory.getCurrentOfResultSet(cursorName)
0: 	   </verbatim></pre>
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The execute() method to be built
0: 	 *
0: 	 * @return		A compiled Expression that returns a ResultSet that
0: 	 *				scans the table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException {
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(!statementResultSet, 
0: 			"CurrentOfNode not expected to be statement node");
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		mb.pushThis(); // for the putField
0: 
0: 		// The generated java returned by this method is the expression:
0: 		// ResultSetFactory.getCurrentOfResultSet(
0: 		//		#cursorName(), this, resultSetNumber)
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		  mb.push(cursorName);
0: 		  acb.pushThisAsActivation(mb);
0: 		  mb.push(resultSetNumber);
0: 		  mb.push(preStmt.getObjectName());
0: 		
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getCurrentOfResultSet",
0: 						ClassName.NoPutResultSet, 4);
0: 
0: 		mb.cast(ClassName.CursorResultSet);
0: 
0:         // the current of scan generator is what we return
0: 		/* This table is the target of an update or a delete, so we must 
0: 		 * wrap the Expression up in an assignment expression before 
0: 		 * returning. Delete or update use the field that is set
0: 		 * to calculate the CurrentRowLocation value.
0: 		 * NOTE - scanExpress is a ResultSet.  We will need to cast it to the
0: 		 * appropriate subclass.
0: 		 * For example, for a DELETE, instead of returning a call to the 
0: 		 * ResultSetFactory, we will generate and return:
0: 		 *		this.SCANRESULTSET = (cast to appropriate ResultSet type) 
0: 		 * The outer cast back to ResultSet is needed so that
0: 		 * we invoke the appropriate method in the call to the ResultSetFactory
0: 		 */
0: 
0: 		mb.putField((String) null, acb.getRowLocationScanResultSetName(), ClassName.CursorResultSet);
0: 		mb.cast(ClassName.NoPutResultSet);
0: 
0: 		// add a check at activation reset time to see if the cursor has
0: 		// changed underneath us. Doing it in the constructor allows the
0: 		// compilation to happen 
0: 		MethodBuilder rmb = acb.startResetMethod();
0: 
0: 		rmb.pushThis();
0: 		rmb.push(cursorName);
0: 		rmb.push(preStmt.getObjectName());
0: 		rmb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "checkPositionedStatement",
0: 						"void", 2);
0: 
0: 		rmb.methodReturn();
0: 		rmb.complete();
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 */
0: 	public void printSubNodes(int depth) {
0: 		if (SanityManager.DEBUG) {
0: 			super.printSubNodes(depth);
0: 
0: 			printLabel(depth, "cursor: ");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 	public String toString() {
0: 		if (SanityManager.DEBUG) {
0: 			return "preparedStatement: " +
0: 		    	(preStmt == null? "no prepared statement yet\n" :
0: 			 	preStmt.toString() + "\n")+
0: 				cursorName + "\n" +
0: 				super.toString();
0: 		} else {
0: 			return "";
0: 		}
0: 	}
0: 
0: 	//
0: 	// class interface
0: 	//
0: 
0: 	public String  getExposedName()
0: 	{
0: 		return exposedTableName.getFullTableName();
0: 	}
0: 	public TableName  getExposedTableName()
0: 	{
0: 		return exposedTableName;
0: 	}
0: 
0: 	public TableName  getBaseCursorTargetTableName()
0: 	{
0: 		return baseTableName;
0: 	}
0: 
0: 	public String getCursorName() 
0: 	{
0: 		return cursorName;
0: 	}
0: 
0: 	/**
0: 	 * Return the CursorNode associated with a positioned update/delete.
0: 	 * 
0: 	 * @return CursorNode	The associated CursorNode.
0: 	 *
0: 	 */
0: 	ExecPreparedStatement getCursorStatement()
0: 	{
0: 		Activation activation = getLanguageConnectionContext().lookupCursorActivation(cursorName);
0: 
0: 		if (activation == null)
0: 			return null;
0: 
0: 		return activation.getPreparedStatement();
0: 	}
0: 
0: 	/**
0: 	 * Get the lock mode for this table as the target of an update statement
0: 	 * (a delete or update).  This is implemented only for base tables and
0: 	 * CurrentOfNodes.
0: 	 *
0: 	 * @see TransactionController
0: 	 *
0: 	 * @return	The lock mode
0: 	 */
0: 	public int updateTargetLockMode()
0: 	{
0: 		/* Do row locking for positioned update/delete */
0: 		return TransactionController.MODE_RECORD;
0: 	}
0: }
============================================================================