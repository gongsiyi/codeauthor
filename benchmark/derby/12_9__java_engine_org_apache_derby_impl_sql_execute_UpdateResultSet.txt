2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.UpdateResultSet
1:6ab1083: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
8:eac0369:  */
24:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:1e2aae0: 
1:af1c18c: import java.util.ArrayList;
1:aa302c3: import java.util.Arrays;
1:af1c18c: import java.util.List;
1:1e2aae0: import java.util.Properties;
1:a826375: import java.util.Vector;
1:a826375: 
1:af1c18c: import org.apache.derby.catalog.UUID;
1:1e2aae0: import org.apache.derby.iapi.db.TriggerExecutionContext;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.reference.SQLState;
1:1e2aae0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:1e2aae0: import org.apache.derby.iapi.services.io.StreamStorable;
1:1e2aae0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:1e2aae0: import org.apache.derby.iapi.sql.Activation;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultDescription;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.RowChanger;
1:91f376c: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:1e2aae0: import org.apache.derby.iapi.types.BooleanDataValue;
1:1e2aae0: import org.apache.derby.iapi.types.DataValueDescriptor;
1:a826375: import org.apache.derby.iapi.types.NumberDataValue;
1:1e2aae0: import org.apache.derby.iapi.types.RowLocation;
1:af1c18c: import org.apache.derby.iapi.types.SQLBoolean;
1:af1c18c: import org.apache.derby.iapi.types.SQLRef;
1:4cc0287: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory.CheckInfo;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:aa302c3: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:a826375: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:aa302c3: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
5:eac0369: /**
1:eac0369:  * Update the rows from the specified
1:eac0369:  * base table. This will cause constraints to be checked
1:eac0369:  * and triggers to be executed based on the c's and t's
1:eac0369:  * compiled into the update plan.
5:eac0369:  *
1:eac0369:  */
1:a826375: class UpdateResultSet extends DMLWriteGeneratedColumnsResultSet
24:eac0369: {
1:6bc9897: 	private TransactionController 	tc;
1:6bc9897: 	private ExecRow					newBaseRow;
1:6bc9897: 	private ExecRow 					row;
1:6bc9897: 	private ExecRow 					deferredSparseRow;
1:6bc9897: 	UpdateConstantAction		constants;
1:aa302c3: 	
1:6bc9897: 	NoPutResultSet			savedSource;
1:eac0369: 	private RowChanger				rowChanger;
1:aa302c3: 
1:eac0369: 	protected ConglomerateController	deferredBaseCC;
1:eac0369: 
1:eac0369: 	protected long[]				deferredUniqueCIDs;
1:eac0369: 	protected boolean[]				deferredUniqueCreated;
1:eac0369: 	protected ConglomerateController	deferredUniqueCC[];
1:eac0369: 	protected ScanController[]		deferredUniqueScans;
1:eac0369: 
1:eac0369: 	private	TemporaryRowHolderImpl	deletedRowHolder;
1:eac0369: 	private	TemporaryRowHolderImpl	insertedRowHolder;
1:eac0369: 
1:eac0369: 	// cached 
1:eac0369: 	private RISetChecker			riChecker;
1:eac0369: 	private	TriggerInfo				triggerInfo;
1:eac0369: 	private TriggerEventActivator	triggerActivator;
1:eac0369: 	private boolean					updatingReferencedKey;
1:eac0369: 	private boolean					updatingForeignKey;
1:eac0369: 	private	int						numOpens;
1:eac0369: 	private long					heapConglom; 
1:eac0369: 	private FKInfo[]				fkInfoArray;
1:eac0369: 	private FormatableBitSet 				baseRowReadList;
1:ca28065:     private GeneratedMethod         generationClauses;
1:eac0369: 	private GeneratedMethod			checkGM;
1:eac0369: 	private int						resultWidth;
1:eac0369: 	private int						numberOfBaseColumns;
1:eac0369: 	private ExecRow					deferredTempRow;
1:eac0369: 	private ExecRow					deferredBaseRow;
1:eac0369: 	private ExecRow					oldDeletedRow;
1:c69c8b0: 	private ResultDescription		triggerResultDescription;
1:eac0369: 
1:eac0369: 	int lockMode;
1:eac0369: 	boolean deferred;
1:eac0369: 	boolean beforeUpdateCopyRequired = false;
1:eac0369: 
1:af1c18c:     private List<UUID>              violatingCheckConstraints;
1:af1c18c:     private BackingStoreHashtable   deferredChecks; // cached ref.
1:aa302c3:     /*
1:eac0369:      * class interface
1:eac0369:      *
1:aa302c3:      */
1:c69c8b0:     /**
1:eac0369: 	 * @param source update rows come from source
1:ca28065: 	 * @param generationClauses	Generated method for computed generation clauses
1:eac0369: 	 * @param checkGM	Generated method for enforcing check constraints
1:45da2f5:      * @param activation The activation
1:eac0369: 	 * @exception StandardException thrown on error
1:c69c8b0:      */
1:6bc9897:     UpdateResultSet(NoPutResultSet source,
1:ca28065: 						   GeneratedMethod generationClauses,
1:eac0369: 						   GeneratedMethod checkGM,
1:eac0369: 						   Activation activation)
1:18a6fb2:       throws StandardException
1:aa302c3:     {
1:ca28065: 		this(source, generationClauses, checkGM , activation, activation.getConstantAction(),null);
1:aa302c3: 	}
1:aa302c3: 
1:eac0369:     /*
1:eac0369:      * class interface
1:854dd10:      *
1:eac0369:      */
1:af1c18c:     /**
1:eac0369: 	 * @param source update rows come from source
1:ca28065: 	 * @param generationClauses	Generated method for computed generation clauses
1:eac0369: 	 * @param checkGM	Generated method for enforcing check constraints
1:eac0369: 	 * @param activation Activation
1:45da2f5:      * @param constantActionItem  id of the update constant action saved object
1:eac0369: 	 * @param rsdItem  id of the Result Description saved object
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369:      */
1:6bc9897:     UpdateResultSet(NoPutResultSet source,
1:ca28065: 						   GeneratedMethod generationClauses,
1:eac0369: 						   GeneratedMethod checkGM,
1:eac0369: 						   Activation activation, 
1:eac0369: 						   int constantActionItem,
1:eac0369: 						   int rsdItem)
1:eac0369:       throws StandardException
1:aa302c3:     {
1:ca28065: 		this(source, generationClauses, checkGM , activation,
1:eac0369: 			  ((ConstantAction)activation.getPreparedStatement().getSavedObject(constantActionItem)),
1:eac0369: 			 (ResultDescription) activation.getPreparedStatement().getSavedObject(rsdItem));
1:af1c18c: 	
1:eac0369: 		// In case of referential action update, we do a deferred updates
1:eac0369: 		deferred = true;
1:aa302c3: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /*
1:eac0369:      * class interface
1:eac0369:      *
1:eac0369:      */
1:eac0369:     /**
1:eac0369: 	 * @param source update rows come from source
1:ca28065: 	 * @param generationClauses	Generated method for computed generation clauses
1:eac0369: 	 * @param checkGM	Generated method for enforcing check constraints
1:45da2f5:      * @param activation
1:45da2f5:      * @param passedInConstantAction
1:45da2f5:      * @param passedInRsd
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369:      */
1:6bc9897:     UpdateResultSet(NoPutResultSet source,
1:ca28065: 						   GeneratedMethod generationClauses,
1:eac0369: 						   GeneratedMethod checkGM,
1:eac0369: 						   Activation activation,
1:eac0369: 						   ConstantAction passedInConstantAction,
1:eac0369: 						   ResultDescription passedInRsd)
1:eac0369:       throws StandardException
1:c69c8b0:     {
1:eac0369: 		super(activation, passedInConstantAction);
1:6bc9897: 
1:6bc9897: 		// Get the current transaction controller
1:eac0369:         tc = activation.getTransactionController();
1:a826375:         this.sourceResultSet = source;
1:ca28065:         this.generationClauses = generationClauses;
1:eac0369: 		this.checkGM = checkGM;
1:eac0369: 
1:eac0369: 		constants = (UpdateConstantAction) constantAction;
1:4119c42: 		fkInfoArray = constants.getFKInfo();
1:4119c42: 		triggerInfo = constants.getTriggerInfo();
1:eac0369: 
1:eac0369: 		heapConglom = constants.conglomId;
1:eac0369: 
1:eac0369: 		baseRowReadList = constants.getBaseRowReadList();
1:eac0369: 		if(passedInRsd ==null)
1:c69c8b0: 			resultDescription = source.getResultDescription();
6:eac0369: 		else
1:eac0369: 			resultDescription = passedInRsd;
1:eac0369: 		/*
1:eac0369: 		** We NEED a result description when we are going to
1:eac0369: 		** to have to kick off a trigger.  In a replicated environment
1:eac0369: 		** we don't get a result description when we are replaying
1:eac0369: 		** source xacts on the target, which should never be the
1:eac0369: 		** case for an UpdateResultSet.
1:eac0369: 		*/
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (resultDescription == null)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(triggerInfo == null, "triggers need a result description to pass to result sets given to users");
1:aa302c3: 			}
1:aa302c3: 		}
1:eac0369: 
1:eac0369: 		if (fkInfoArray != null)
1:eac0369: 		{
1:45da2f5:             for (FKInfo fkInfo : fkInfoArray) {
1:45da2f5:                 if (fkInfo.type == FKInfo.REFERENCED_KEY) {
1:45da2f5:                     updatingReferencedKey = true;
1:45da2f5:                     if (SanityManager.DEBUG)
1:45da2f5:                     {
1:45da2f5:                         SanityManager.ASSERT(
1:45da2f5:                             constants.deferred,
1:45da2f5:                             "updating referenced key but update not " +
1:45da2f5:                                 "deferred, wuzzup?");
1:45da2f5:                     }
1:45da2f5:                 } else {
1:45da2f5:                     updatingForeignKey = true;
1:45da2f5:                 }
1:45da2f5:             }
1:c69c8b0: 		}
1:eac0369: 
1:eac0369: 		/* Get the # of columns in the ResultSet */
1:eac0369: 		resultWidth = resultDescription.getColumnCount();
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** Calculate the # of columns in the base table.  The result set
1:eac0369: 		** contains the before columns, the after columns, and the RowLocation,
1:eac0369: 		** so the number of base columns is half of the number of result set
1:eac0369: 		** columns, after subtracting one for the row location column.
1:eac0369: 		*/
1:eac0369: 		numberOfBaseColumns = (resultWidth - 1) / 2;
1:eac0369: 		
1:eac0369: 		/* Get the new base row */
1:eac0369: 		newBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
1:eac0369: 
1:eac0369: 		deferred = constants.deferred;
1:eac0369: 		
1:eac0369: 		//update can be marked for deferred mode because the scan is being done
1:eac0369: 		//using index. But it is not necesary  to keep the before copy
1:eac0369: 		//of the row in the temporary row holder (deletedRowHolder) unless
1:eac0369: 		//there are RI constraint or Triggers.(beetle:5301)
1:eac0369: 		if(triggerInfo != null || fkInfoArray !=null){
1:eac0369: 			beforeUpdateCopyRequired = true;
25:eac0369: 		}
1:eac0369: 		
1:a826375:         identitySequenceUUIDString = constants.identitySequenceUUIDString;
1:a826375:         initializeAIcache(constants.getAutoincRowLocation());
1:eac0369: 	}
1:eac0369: 	/**
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:45da2f5:     @Override
1:eac0369: 	public void open() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		setup();
1:aa302c3: 		autoincrementGenerated = false;
1:eac0369: 		collectAffectedRows();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If this is a deferred update, read the new rows and RowLocations
1:eac0369: 		** from the temporary conglomerate and update the base table using
1:eac0369: 		** the RowChanger.
1:eac0369: 		*/
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 
1:45da2f5:             runChecker(true); // check for only RESTRICT referential
1:18a6fb2:                                     // action rule violations
1:eac0369: 			fireBeforeTriggers();
1:45da2f5:             updateDeferredRows();
1:eac0369: 			/* Apply deferred inserts to unique indexes */
1:eac0369: 			rowChanger.finish();
1:45da2f5:             runChecker(false); // check for all  violations
1:eac0369: 			fireAfterTriggers();
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		else{
1:eac0369: 		/* Apply deferred inserts to unique indexes */
1:eac0369: 		rowChanger.finish();
1:eac0369: 		}
1:eac0369: 
1:a826375: 		saveAIcacheInformation(constants.getSchemaName(), 
1:a826375: 			constants.getTableName(), constants.getColumnNames());
1:eac0369: 		cleanUp();
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:45da2f5:     @Override
1:eac0369: 	void setup() throws StandardException
1:eac0369: 	{
1:6369b54: 		super.setup();
1:6369b54: 
1:6369b54: 		/* decode lock mode */
1:6369b54: 		lockMode = decodeLockMode(constants.lockMode);
1:6369b54: 
1:eac0369: 		boolean firstOpen = (rowChanger == null);
1:eac0369: 
1:7fb9956: 		rowCount = 0L;
1:eac0369: 		
1:eac0369: 		/* Cache query plan text for source, before it gets blown away */
1:eac0369: 		if (lcc.getRunTimeStatisticsMode())
1:eac0369: 		{
1:eac0369: 			/* savedSource nulled after run time statistics generation */
1:a826375: 			savedSource = sourceResultSet;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Get or re-use the row changer.
1:eac0369: 		 */
1:eac0369: 		if (firstOpen)
1:eac0369: 		{
1:eac0369: 			rowChanger = lcc.getLanguageConnectionFactory().getExecutionFactory()
1:eac0369: 				             .getRowChanger( heapConglom, 
1:eac0369: 										 constants.heapSCOCI, 
1:eac0369: 										 heapDCOCI,
1:eac0369: 										 constants.irgs,
1:eac0369: 										 constants.indexCIDS,
1:eac0369: 										 constants.indexSCOCIs,
1:eac0369: 										 indexDCOCIs,
1:eac0369: 										 constants.numColumns,
2:eac0369: 										 tc,
1:eac0369: 										 constants.changedColumnIds,
1:eac0369: 										 constants.getBaseRowReadList(),
1:eac0369: 										 constants.getBaseRowReadMap(),
1:eac0369: 										 constants.getStreamStorableHeapColIds(),
1:eac0369: 										 activation);
1:eac0369: 			rowChanger.setIndexNames(constants.indexNames);
1:eac0369: 		}
1:eac0369: 
1:aa302c3: 		verifyAutoGeneratedRScolumnsList(constants.targetUUID);
1:eac0369: 
1:eac0369: 		/* Open the RowChanger before the source ResultSet so that
1:eac0369: 		 * the store will see the RowChanger's lock as a covering lock
1:eac0369: 		 * if it is a table lock.
1:eac0369: 		 */
1:eac0369: 		rowChanger.open(lockMode);
1:eac0369: 
1:eac0369: 		if (numOpens++ == 0)
1:eac0369: 		{
1:a826375: 			sourceResultSet.openCore();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:a826375: 			sourceResultSet.reopenCore();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* The source does not know whether or not we are doing a
1:eac0369: 		 * deferred mode update.  If we are, then we must clear the
1:eac0369: 		 * index scan info from the activation so that the row changer
1:eac0369: 		 * does not re-use that information (which won't be valid for
1:eac0369: 		 * a deferred mode update).
1:eac0369: 		 */
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 			activation.clearIndexScanInfo();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (fkInfoArray != null)
1:eac0369: 		{
1:eac0369: 			if (riChecker == null)
1:eac0369: 			{
1:4cc0287:                 riChecker = new RISetChecker(lcc, tc, fkInfoArray);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				riChecker.reopen();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 			/* Allocate the temporary rows and get result description
1:eac0369: 			 * if this is the 1st time that we are executing.
1:eac0369: 			 */
1:eac0369: 			if (firstOpen)
1:eac0369: 			{
1:eac0369: 				deferredTempRow = RowUtil.getEmptyValueRow(numberOfBaseColumns+1, lcc);
1:eac0369: 				oldDeletedRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
1:c69c8b0: 				triggerResultDescription = (resultDescription != null) ?
1:c69c8b0: 									resultDescription.truncateColumns(numberOfBaseColumns+1) :
1:c69c8b0: 									null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			Properties properties = new Properties();
1:eac0369: 
1:eac0369: 			// Get the properties on the heap
1:eac0369: 			rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
1:eac0369: 			if(beforeUpdateCopyRequired){
1:81b9853: 				deletedRowHolder =
1:c69c8b0: 					new TemporaryRowHolderImpl(activation, properties,
1:c69c8b0: 											   triggerResultDescription);
1:eac0369: 			}
1:81b9853: 			insertedRowHolder =
1:c69c8b0: 				new TemporaryRowHolderImpl(activation, properties,
1:c69c8b0: 										   triggerResultDescription);
1:eac0369: 
1:eac0369: 			rowChanger.setRowHolder(insertedRowHolder);
1:eac0369: 		}
1:eac0369: 
1:aa302c3: 		firstExecuteSpecialHandlingAutoGen(firstOpen, rowChanger, constants.targetUUID);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/* Following 2 methods are for checking and make sure we don't have one un-objectified stream
1:eac0369: 	 * to be inserted into 2 temp table rows for deferred update.  Otherwise it would cause problem
1:eac0369: 	 * when writing to disk using the stream a second time.  In other cases we don't want to
1:eac0369: 	 * unnecessarily objectify the stream. beetle 4896.
1:eac0369: 	 */
1:eac0369: 	private FormatableBitSet checkStreamCols()
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] cols = row.getRowArray();
1:eac0369: 		FormatableBitSet streamCols = null;
1:eac0369: 		for (int i = 0; i < numberOfBaseColumns; i++)
1:eac0369: 		{
1:eac0369: 			if (cols[i+numberOfBaseColumns] instanceof StreamStorable)  //check new values
1:eac0369: 			{
1:eac0369: 				if (streamCols == null) streamCols = new FormatableBitSet(numberOfBaseColumns);
1:eac0369: 				streamCols.set(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return streamCols;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void objectifyStream(ExecRow tempRow, FormatableBitSet streamCols) throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] cols = tempRow.getRowArray();
1:eac0369: 		for (int i = 0; i < numberOfBaseColumns; i++)
1:eac0369: 		{
1:eac0369: 			if (cols[i] != null && streamCols.get(i))
1:eac0369: 				((StreamStorable)cols[i]).loadStream();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:af1c18c:      * Run check constraints against the current row. Raise an error if
1:af1c18c:      * a check constraint is violated, unless all the offending checks are
1:af1c18c:      * deferred, in which case a false value will be returned. A NULL value
1:af1c18c:      * will be interpreted as success (not violation).
1:af1c18c:      *
1:af1c18c:      * @exception StandardException thrown on error
1:af1c18c:      */
1:af1c18c:     private boolean evaluateCheckConstraints() throws StandardException     {
1:af1c18c:         boolean result = true;
1:af1c18c: 
1:af1c18c:         if (checkGM != null) {
1:af1c18c:             // Evaluate the check constraints. If all check constraint modes are
1:af1c18c:             // immediate, a check error will throw rather than return a false
1:af1c18c:             // value.
1:af1c18c:             SQLBoolean allOk =
1:af1c18c:                     (SQLBoolean)checkGM.invoke(activation);
1:af1c18c:             result = allOk.isNull() || allOk.getBoolean();
1:af1c18c:         }
1:af1c18c: 
1:af1c18c:         return result;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c: 
1:eac0369: 	public boolean collectAffectedRows() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		boolean rowsFound = false;
1:a826375: 		row = getNextRowCore(sourceResultSet);
1:aa302c3: 
1:eac0369: 		if (row!=null)
1:eac0369: 			rowsFound = true;
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			activation.addWarning(
1:eac0369: 						StandardException.newWarning(
1:eac0369: 							SQLState.LANG_NO_ROW_FOUND));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//beetle 3865, update cursor use index.
1:eac0369: 		TableScanResultSet tableScan = (TableScanResultSet) activation.getForUpdateIndexScan();
1:91f376c: 		boolean notifyCursor = (tableScan != null);
1:eac0369: 		boolean checkStream = (deferred && rowsFound && ! constants.singleRowSource);
1:eac0369: 		FormatableBitSet streamCols = (checkStream ? checkStreamCols() : null);
1:eac0369: 		checkStream = (streamCols != null);
1:eac0369: 
1:eac0369:         while ( row != null )
1:aa302c3:         {
1:a826375:             evaluateGenerationClauses( generationClauses, activation, sourceResultSet, row, true );
1:eac0369: 
1:eac0369: 			/* By convention, the last column in the result set for an
1:eac0369: 			 * update contains a SQLRef containing the RowLocation of
1:eac0369: 			 * the row to be updated.
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we're doing deferred update, write the new row and row
1:eac0369: 			** location to the temporary conglomerate.  If we're not doing
1:eac0369: 			** deferred update, update the permanent conglomerates now
1:eac0369: 			** using the RowChanger.
1:eac0369: 			*/
1:eac0369: 			if (deferred)
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** If we have a before trigger, we must evaluate the 
1:eac0369: 				** check constraint after we have executed the trigger.
1:eac0369: 				** Note that we have compiled checkGM accordingly (to
1:eac0369: 				** handle the different row shape if we are evaluating
1:eac0369: 				** against the input result set or a temporary row holder
1:eac0369: 				** result set).
1:eac0369: 				*/
1:eac0369: 				if (triggerInfo == null)
1:eac0369: 				{
1:af1c18c:                     boolean allOk = evaluateCheckConstraints();
1:af1c18c:                     if (!allOk) {
1:af1c18c:                         DataValueDescriptor[] rw = row.getRowArray();
1:af1c18c:                         SQLRef r = (SQLRef)rw[rw.length - 1];
1:af1c18c:                         RowLocation baseRowLocation =
1:af1c18c:                             (RowLocation)r.getObject();
1:af1c18c: 
1:af1c18c:                         deferredChecks =
1:af1c18c:                             DeferredConstraintsMemory.rememberCheckViolations(
1:af1c18c:                                 lcc,
1:f6d02c9:                                 constants.targetUUID,
1:af1c18c:                                 constants.getSchemaName(),
1:af1c18c:                                 constants.getTableName(),
1:af1c18c:                                 deferredChecks,
1:af1c18c:                                 violatingCheckConstraints,
1:4cc0287:                                 baseRowLocation,
1:4cc0287:                                 new CheckInfo[1]);
1:eac0369:                     }
1:eac0369: 				}
1:af1c18c: 
1:eac0369: 				/*
1:eac0369: 				** We are going to only save off the updated
1:eac0369: 				** columns and the RID.  For a trigger, all columns
1:eac0369: 				** were marked as needed so we'll copy them all.
1:eac0369: 				*/
1:eac0369: 				RowUtil.copyRefColumns(deferredTempRow,
1:eac0369: 											row,
1:eac0369: 											numberOfBaseColumns,
1:eac0369: 											numberOfBaseColumns + 1);
1:eac0369: 				if (checkStream)
1:eac0369: 					objectifyStream(deferredTempRow, streamCols);
1:eac0369: 
1:eac0369: 				insertedRowHolder.insert(deferredTempRow); 
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Grab a copy of the row to delete.  We are
1:eac0369: 				** going to use this for deferred RI checks.
1:eac0369: 				*/
1:eac0369: 				if(beforeUpdateCopyRequired)
1:eac0369: 				{
1:eac0369: 					RowUtil.copyRefColumns(oldDeletedRow,
1:eac0369: 										   row,
1:eac0369: 										   numberOfBaseColumns);
1:eac0369: 
1:eac0369: 					deletedRowHolder.insert(oldDeletedRow);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If we haven't already, lets get a template to
1:eac0369: 				** use as a template for our rescan of the base table.
1:eac0369: 				** Do this now while we have a real row to use
1:eac0369: 				** as a copy.
1:eac0369: 				**
1:eac0369: 				** There is one less column in the base row than
1:eac0369: 				** there is in source row, because the base row
1:eac0369: 				** doesn't contain the row location.
1:eac0369: 				*/
1:eac0369: 				if (deferredBaseRow == null)
1:eac0369: 				{
1:eac0369: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
1:eac0369: 			
1:eac0369: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
1:eac0369: 											numberOfBaseColumns);
1:eac0369: 
1:eac0369: 					/*
1:eac0369: 					** While we're here, let's also create a sparse row for
1:eac0369: 					** fetching from the store.
1:eac0369: 					*/
1:eac0369: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
1:eac0369: 																baseRowReadList,
1:eac0369: 																lcc);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:af1c18c:                 boolean allOk = evaluateCheckConstraints();
1:eac0369: 
1:af1c18c:                 /* Get the RowLocation to update
1:eac0369: 			 	* NOTE - Column #s in the Row are 1 based.
1:eac0369: 			 	*/
1:eac0369: 				RowLocation baseRowLocation = (RowLocation)
1:eac0369: 					(row.getColumn(resultWidth)).getObject();
1:af1c18c: 
1:af1c18c:                 if (!allOk) {
1:af1c18c:                     deferredChecks =
1:af1c18c:                         DeferredConstraintsMemory.rememberCheckViolations(
1:af1c18c:                             lcc,
1:f6d02c9:                             constants.targetUUID,
1:af1c18c:                             constants.getSchemaName(),
1:af1c18c:                             constants.getTableName(),
1:af1c18c:                             deferredChecks,
1:af1c18c:                             violatingCheckConstraints,
1:4cc0287:                             baseRowLocation,
1:4cc0287:                             new CheckInfo[1]);
1:af1c18c:                 }
1:eac0369: 
1:eac0369: 				RowUtil.copyRefColumns(newBaseRow,
1:eac0369: 										row,
1:eac0369: 										numberOfBaseColumns,
1:eac0369: 										numberOfBaseColumns);
1:eac0369: 
1:eac0369: 				if (riChecker != null)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** Make sure all foreign keys in the new row
1:eac0369: 					** are maintained.  Note that we don't bother 
1:eac0369: 					** checking primary/unique keys that are referenced
1:eac0369: 					** here.  The reason is that if we are updating
1:eac0369: 					** a referenced key, we'll be updating in deferred
1:eac0369: 					** mode, so we wont get here.
1:eac0369: 					*/
1:4cc0287:                     riChecker.doFKCheck(activation, newBaseRow);
1:eac0369: 				}
1:eac0369: 
1:a826375: 				sourceResultSet.updateRow(newBaseRow, rowChanger);
1:eac0369: 				rowChanger.updateRow(row,newBaseRow,baseRowLocation);
1:eac0369: 
1:eac0369: 				//beetle 3865, update cursor use index.
1:eac0369: 				if (notifyCursor)
1:eac0369: 					notifyForUpdateCursor(row.getRowArray(),newBaseRow.getRowArray(),baseRowLocation,
1:eac0369: 											tableScan);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			rowCount++;
1:eac0369: 
1:eac0369: 			// No need to do a next on a single row source
1:eac0369: 			if (constants.singleRowSource)
1:eac0369: 			{
1:eac0369: 				row = null;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:a826375: 				row = getNextRowCore(sourceResultSet);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369:         
1:aa302c3:         if(rowCount==1 && constants.hasAutoincrement()) 
1:aa302c3: 			lcc.setIdentityValue(identityVal);
1:eac0369: 
1:eac0369: 		return rowsFound;
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     @Override
1:6ab1083: 	protected ExecRow getNextRowCore( NoPutResultSet source )
1:6ab1083: 		throws StandardException
1:6ab1083: 	{
1:45da2f5:         ExecRow nextRow = super.getNextRowCore( source );
1:6ab1083: 
1:45da2f5:         if ( (nextRow != null) && constants.underMerge() ) {
1:45da2f5:             nextRow = processMergeRow( source, nextRow );
1:45da2f5:         }
1:6ab1083: 
1:45da2f5:         return nextRow;
1:6ab1083: 	}
1:6ab1083: 
1:6ab1083:     /**
1:6ab1083:      * <p>
1:6ab1083:      * Special handling if this is an UPDATE action of a MERGE statement.
1:6ab1083:      * </p>
1:6ab1083:      */
1:6ab1083: 	private ExecRow processMergeRow( NoPutResultSet sourceRS, ExecRow row )
1:6ab1083: 		throws StandardException
1:6ab1083: 	{
1:6ab1083:         //
1:6ab1083:         // After we fix derby-6414, we will need to handle the DEFAULT keyword
1:6ab1083:         // for identity columns, just as we do in InsertResultSet.processMergeRow().
1:6ab1083:         // For the moment, we just allow the bad behavior described by derby-6414.
1:6ab1083:         //
1:6ab1083:         return normalizeRow( sourceRS, row );
1:6ab1083: 	}
1:6ab1083: 
1:eac0369: 	/* beetle 3865, updateable cursor use index. If the row we are updating has new value that
1:eac0369: 	 * falls into the direction of the index scan of the cursor, we save this rid into a hash table
1:91f376c: 	 * (for fast search), so that when the cursor hits it again, it knows to skip it.
1:eac0369: 	 */
1:eac0369: 	private void notifyForUpdateCursor(DataValueDescriptor[] row, DataValueDescriptor[] newBaseRow,
1:eac0369: 										RowLocation rl, TableScanResultSet tableScan)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int[] indexCols = tableScan.indexCols;
1:eac0369: 		int[] changedCols = constants.changedColumnIds;
1:eac0369: 		boolean placedForward = false, ascending, decided = false, overlap = false;
1:eac0369: 		int basePos, k;
1:eac0369: 		/* first of all, we see if there's overlap between changed column ids and index key
1:eac0369: 		 * columns.  If so, we see if the new update value falls into the future range of the
1:eac0369: 		 * index scan, if so, we need to save it in hash table.
1:eac0369: 		 */
1:eac0369: 		for (int i = 0; i < indexCols.length; i++)
1:eac0369: 		{
1:eac0369: 			basePos = indexCols[i];
1:eac0369: 			if (basePos > 0)
1:eac0369: 				ascending = true;
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				ascending = false;
1:eac0369: 				basePos = -basePos;
1:eac0369: 			}
1:eac0369: 			for (int j = 0; j < changedCols.length; j++)
1:eac0369: 			{
1:eac0369: 				if (basePos == changedCols[j])
1:eac0369: 				{
1:eac0369: 					decided = true;		//we pretty much decided if new row falls in front
1:eac0369: 										//of the cursor or behind
1:eac0369: 					/* the row and newBaseRow we get are compact base row that only have
1:eac0369: 				 	 * referenced columns.  Our "basePos" is index in sparse heap row, so
1:eac0369: 					 * we need the BaseRowReadMap to map into the compact row.
1:eac0369: 					 */
1:eac0369: 					int[] map = constants.getBaseRowReadMap();
1:eac0369: 					if (map == null)
1:eac0369: 						k = basePos - 1;
1:eac0369: 					else
1:eac0369: 						k =  map[basePos - 1];
1:eac0369: 
1:91f376c: 					DataValueDescriptor key = row[k];
1:eac0369: 
1:eac0369: 					/* Starting from the first index key column forward, we see if the direction
1:eac0369: 					 * of the update change is consistent with the direction of index scan.
1:eac0369: 					 * If so, we save it in hash table.
1:eac0369: 					 */
1:eac0369: 					if ((ascending && key.greaterThan(newBaseRow[k], key).equals(true)) ||
1:eac0369: 						(!ascending && key.lessThan(newBaseRow[k], key).equals(true)))
1:eac0369: 						placedForward = true;
1:eac0369: 					else if (key.equals(newBaseRow[k], key).equals(true))
1:eac0369: 					{
1:eac0369: 						decided = false;
1:eac0369: 						overlap = true;
1:eac0369: 					}
1:aa302c3: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (decided)  // already decided if new row falls in front or behind
4:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 		/* If index row gets updated but key value didn't actually change, we still
1:eac0369: 		 * put it in hash table because it can either fall in front or behind.  This
1:eac0369: 		 * can happen if the update explicitly sets a value, but same as old.
1:eac0369: 		 */
1:eac0369: 		if (overlap && !decided)
1:eac0369: 			placedForward = true;
1:eac0369: 
1:eac0369: 		if (placedForward)		// add it to hash table
1:eac0369: 		{
1:eac0369: 			/* determining initial capacity of hash table from a few factors:
1:eac0369: 			 * (1) user specified MAX_MEMORY_PER_TABLE property, (2) min value 100
1:eac0369: 			 * (3) optimizer estimated row count.  We want to avoid re-hashing if
1:eac0369: 			 * possible, for performance reason, yet don't waste space.  If initial
1:eac0369: 			 * capacity is greater than max size divided by load factor, no rehash
1:eac0369: 			 * is ever needed.
1:eac0369: 			 */
1:eac0369: 			int maxCapacity = lcc.getOptimizerFactory().getMaxMemoryPerTable() / 16;
1:eac0369: 			if (maxCapacity < 100)
1:eac0369: 				maxCapacity = 100;
1:eac0369: 
1:eac0369: 			if (tableScan.past2FutureTbl == null)
1:eac0369: 			{
1:45da2f5:                 double rowCnt = tableScan.getEstimatedRowCount();
1:eac0369: 				int initCapacity = 32 * 1024;
1:45da2f5:                 if (rowCnt > 0.0)
1:eac0369: 				{
1:45da2f5:                     rowCnt = rowCnt / 0.75 + 1.0;   // load factor
1:45da2f5:                     if (rowCnt < initCapacity)
1:45da2f5:                         initCapacity = (int) rowCnt;
1:eac0369: 				}
1:eac0369: 				if (maxCapacity < initCapacity)
1:eac0369: 					initCapacity = maxCapacity;
1:eac0369: 
1:91f376c:                 tableScan.past2FutureTbl = new BackingStoreHashtable(
1:91f376c:                         tc, null, new int[]{0}, false, -1,
1:91f376c:                         maxCapacity, initCapacity, -1, false,
1:91f376c:                         tableScan.getActivation().getResultSetHoldability());
1:eac0369: 			}
1:eac0369: 
1:91f376c:             /* Add the row location to the hash table.
1:eac0369:              *
1:854dd10:              * Need to save a clone because when we get cached currentRow, "rl"
1:854dd10:              * shares the same reference, so is changed at the same time.
1:854dd10:              */
1:e81e52c:             tableScan.past2FutureTbl.putRow
1:e81e52c:                 (
1:e81e52c:                  false,
1:e81e52c:                  new DataValueDescriptor[] { rl.cloneValue(false) },
1:e81e52c:                  null
1:e81e52c:                  );
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void fireBeforeTriggers() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 			if (triggerInfo != null)
1:eac0369: 			{
1:a826375: 				Vector<AutoincrementCounter> v = null;
1:a826375: 				if (aiCache != null)
1:a826375: 				{
1:a826375: 					v = new Vector<AutoincrementCounter>();
1:a826375: 					for (int i = 0; i < aiCache.length; i++)
1:a826375: 					{
1:a826375: 						String s, t, c;
1:a826375: 						if (aiCache[i] == null)
1:a826375: 							continue;
1:a826375: 					
1:a826375: 						Long initialValue = 
1:a826375: 							lcc.lastAutoincrementValue(
1:a826375: 								(s = constants.getSchemaName()),
1:a826375: 								(t = constants.getTableName()),
1:a826375: 								(c = constants.getColumnName(i)));
1:a826375: 
1:a826375: 						AutoincrementCounter aic = 
1:a826375: 							new AutoincrementCounter(
1:a826375: 								 initialValue,
1:a826375: 								 constants.getAutoincIncrement(i),
1:a826375: 								 aiCache[i].getLong(),
1:a826375: 								 s, t, c, i + 1);
1:a826375: 						v.addElement(aic);
1:a826375: 					}
1:a826375: 				}
1:eac0369: 				if (triggerActivator == null)
1:eac0369: 				{
1:eac0369: 				triggerActivator = new TriggerEventActivator(lcc, 
1:f6d02c9: 											constants.targetUUID,
1:eac0369: 											triggerInfo,
1:eac0369: 											TriggerExecutionContext.UPDATE_EVENT,
1:a826375: 											activation, v);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					triggerActivator.reopen();
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// fire BEFORE trigger, do this before checking constraints
1:eac0369: 				triggerActivator.notifyEvent(TriggerEvents.BEFORE_UPDATE, 
1:eac0369: 												deletedRowHolder.getResultSet(),
1:d9d1bc8: 												insertedRowHolder.getResultSet(),
1:d9d1bc8: 												constants.getBaseRowReadMap());
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     void fireAfterTriggers() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 			if (triggerActivator != null)
1:eac0369: 			{
1:eac0369: 				triggerActivator.notifyEvent(TriggerEvents.AFTER_UPDATE, 
1:eac0369: 										deletedRowHolder.getResultSet(),
1:d9d1bc8: 										insertedRowHolder.getResultSet(),
1:d9d1bc8: 										constants.getBaseRowReadMap());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	void updateDeferredRows() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (deferred)
1:eac0369: 		{
1:eac0369: 			// we already have everything locked 
1:eac0369: 			deferredBaseCC = 
1:eac0369:                 tc.openCompiledConglomerate(
1:91f376c:                     false,
1:45da2f5:                     (TransactionController.OPENMODE_SECONDARY_LOCKED |
1:45da2f5:                      TransactionController.OPENMODE_FORUPDATE),
1:eac0369:                     lockMode,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE,
1:eac0369:                     constants.heapSCOCI,
1:eac0369:                     heapDCOCI);
1:eac0369: 			
1:eac0369: 			CursorResultSet rs = insertedRowHolder.getResultSet();
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** We need to do a fetch doing a partial row
1:eac0369: 				** read.  We need to shift our 1-based bit
1:eac0369: 				** set to a zero based bit set like the store
1:eac0369: 				** expects.
1:eac0369: 				*/
1:eac0369: 				FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
1:eac0369: 				ExecRow deferredTempRow2;
1:eac0369: 
1:eac0369: 				rs.open();
1:eac0369: 				while ((deferredTempRow2 = rs.getNextRow()) != null)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** Check the constraint now if we have triggers.
1:eac0369: 					** Otherwise we evaluated them as we read the
1:eac0369: 					** rows in from the source.
1:eac0369: 					*/
1:af1c18c:                     boolean allOk = true;
1:af1c18c: 
1:eac0369: 					if (triggerInfo != null)
1:eac0369: 					{
1:a826375: 						sourceResultSet.setCurrentRow(deferredTempRow);
1:af1c18c:                         allOk = evaluateCheckConstraints();
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					/* 
1:eac0369: 					** The last column is a Ref, which contains a 
1:eac0369: 					** RowLocation.
1:eac0369: 					*/
1:eac0369: 					DataValueDescriptor rlColumn = deferredTempRow2.getColumn(numberOfBaseColumns + 1);
1:eac0369: 					RowLocation baseRowLocation = 
1:eac0369: 							(RowLocation) (rlColumn).getObject();
1:af1c18c: 
1:af1c18c:                     if (!allOk) {
1:af1c18c:                         deferredChecks =
1:af1c18c:                             DeferredConstraintsMemory.rememberCheckViolations(
1:af1c18c:                                 lcc,
1:eac0369:                                 constants.targetUUID,
1:af1c18c:                                 constants.getSchemaName(),
1:af1c18c:                                 constants.getTableName(),
1:af1c18c:                                 deferredChecks,
1:af1c18c:                                 violatingCheckConstraints,
1:4cc0287:                                 baseRowLocation,
1:4cc0287:                                 new CheckInfo[1]);
1:af1c18c:                     }
1:eac0369: 
1:eac0369: 					/* Get the base row at the given RowLocation */
1:eac0369: 					boolean row_exists = 
1:eac0369: 						deferredBaseCC.fetch(
1:eac0369: 							baseRowLocation, deferredSparseRow.getRowArray(), 
1:eac0369: 							readBitSet);
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						SanityManager.ASSERT(row_exists, "did not find base row in deferred update");
1:eac0369: 					}
1:eac0369: 	
1:eac0369: 					/*
1:eac0369: 					** Copy the columns from the temp row to the base row.
1:eac0369: 					** The base row has fewer columns than the temp row,
1:eac0369: 					** because it doesn't contain the row location.
1:eac0369: 					*/
1:eac0369: 					RowUtil.copyRefColumns(newBaseRow,
1:eac0369: 											deferredTempRow2,
1:eac0369: 											numberOfBaseColumns);
1:eac0369: 
1:eac0369: 					rowChanger.updateRow(deferredBaseRow,
1:eac0369: 										newBaseRow,
1:af1c18c: 										baseRowLocation);
1:af1c18c: 				}
1:eac0369: 			} finally
1:eac0369: 			{
1:a826375: 				sourceResultSet.clearCurrentRow();
1:eac0369: 				rs.close();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:45da2f5:     void runChecker(boolean restrictCheckOnly)
1:eac0369:             throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** For a deferred update, make sure that there
1:eac0369: 		** aren't any primary keys that were removed which
1:eac0369: 		** are referenced.  
1:eac0369: 		*/
1:eac0369: 		if (deferred && updatingReferencedKey)
1:eac0369: 		{
1:eac0369: 			ExecRow	deletedRow;
1:eac0369: 			CursorResultSet deletedRows; 
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** For each referenced key that was modified
1:eac0369: 			*/
2:eac0369: 			for (int i = 0; i < fkInfoArray.length; i++)
1:eac0369: 			{
1:eac0369: 				if (fkInfoArray[i].type == FKInfo.FOREIGN_KEY)
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				deletedRows = deletedRowHolder.getResultSet();
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** For each delete row
1:eac0369: 					*/	
1:eac0369: 					deletedRows.open();
1:18a6fb2: 
1:eac0369: 					while ((deletedRow = deletedRows.getNextRow()) != null)
1:eac0369: 					{
1:eac0369: 						if (!foundRow(deletedRow, 
1:eac0369: 										fkInfoArray[i].colArray, 
1:eac0369: 										insertedRowHolder))
1:18a6fb2:                         {
1:18a6fb2:                             // Argument "1" below: If a PK referenced by an FK
1:18a6fb2:                             // is deferred, require at least one to be present
1:18a6fb2:                             // in the primary table since we have modified the
1:18a6fb2:                             // row's PK, unless postCheck == true, in which the
1:18a6fb2:                             // call to postChecks does the actual checking, and
1:18a6fb2:                             // we need at least one row intact to fulfill the
1:18a6fb2:                             // constraint.
1:18a6fb2:                            riChecker.doRICheck(
1:18a6fb2:                                     activation,
1:18a6fb2:                                     i,
1:18a6fb2:                                     deletedRow,
1:18a6fb2:                                     restrictCheckOnly,
1:18a6fb2:                                     1);
1:eac0369: 						}
1:eac0369: 					}	
1:18a6fb2: 
1:45da2f5:                     if (restrictCheckOnly) {
1:18a6fb2:                         riChecker.postCheck(i);
1:18a6fb2:                     }
1:eac0369: 				}
1:eac0369: 				finally
1:eac0369: 				{
1:eac0369: 					deletedRows.close();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** For a deferred update, make sure that there
1:eac0369: 		** aren't any foreign keys that were added that
1:eac0369:  		** aren't referenced.  
1:eac0369: 		*/
1:eac0369: 		if (deferred && updatingForeignKey)
1:eac0369: 		{
1:eac0369: 			ExecRow	insertedRow;
1:eac0369: 			CursorResultSet insertedRows; 
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** For each foreign key that was modified
1:eac0369: 			*/
1:eac0369: 			for (int i = 0; i < fkInfoArray.length; i++)
1:eac0369: 			{
2:eac0369: 				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				insertedRows = insertedRowHolder.getResultSet();
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** For each inserted row
1:eac0369: 					*/	
1:eac0369: 					insertedRows.open();
1:eac0369: 					while ((insertedRow = insertedRows.getNextRow()) != null)
1:eac0369: 					{
1:eac0369: 						if (!foundRow(insertedRow, 
1:eac0369: 										fkInfoArray[i].colArray, 
1:eac0369: 										deletedRowHolder))
1:eac0369: 						{
1:4cc0287:                             riChecker.doRICheck(
1:18a6fb2:                                 activation,
1:18a6fb2:                                 i,
1:18a6fb2:                                 insertedRow,
1:18a6fb2:                                 restrictCheckOnly,
1:18a6fb2:                                 0);        // N/A, not referenced key
1:18a6fb2: 						}
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 				finally
1:eac0369: 				{
1:eac0369: 					insertedRows.close();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static boolean foundRow
1:eac0369: 	(
1:eac0369: 		ExecRow					checkRow, 
1:eac0369: 		int[]					colsToCheck,
1:eac0369: 		TemporaryRowHolderImpl	rowHolder
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow				scanRow;
1:eac0369: 		boolean				foundMatch = false;
1:eac0369: 		Object[] 			checkRowArray = checkRow.getRowArray();
1:eac0369: 		DataValueDescriptor	checkCol;
1:eac0369: 		DataValueDescriptor	scanCol;
1:eac0369: 
1:eac0369: 		CursorResultSet rs = rowHolder.getResultSet();
1:eac0369: 		try
1:eac0369: 		{	
1:eac0369: 			/*
1:eac0369: 			** For each inserted row
1:eac0369: 			*/	
1:eac0369: 			rs.open();
1:eac0369: 			while ((scanRow = rs.getNextRow()) != null)
1:eac0369: 			{
1:eac0369: 				Object[] scanRowArray = scanRow.getRowArray();
1:eac0369: 				int i;
1:eac0369: 				for (i = 0; i < colsToCheck.length; i++)
1:eac0369: 				{
1:eac0369: 					checkCol = (DataValueDescriptor)checkRowArray[colsToCheck[i]-1];
1:eac0369: 					scanCol = (DataValueDescriptor)scanRowArray[colsToCheck[i]-1];
1:eac0369: 
1:eac0369: 					BooleanDataValue result = checkCol.equals(
1:eac0369: 											scanCol,
1:eac0369: 											checkCol); // result
1:eac0369: 					if (!result.getBoolean())
1:eac0369: 					{
1:eac0369: 						break;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				if (i == colsToCheck.length)
1:eac0369: 				{
1:eac0369: 					foundMatch = true;
1:eac0369: 					break;
1:eac0369: 				}	
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			rs.close();
1:eac0369: 		}
1:eac0369: 		return foundMatch;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#cleanUp
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:45da2f5:     @Override
1:eac0369: 	public void	cleanUp() throws StandardException
1:eac0369: 	{ 
1:eac0369: 		numOpens = 0;
1:eac0369: 
1:eac0369: 		/* Close down the source ResultSet tree */
1:a826375: 		if (sourceResultSet != null)
1:eac0369: 		{
1:a826375: 			sourceResultSet.close();
1:eac0369: 			// cache source across open()s
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (triggerActivator != null)
1:eac0369: 		{
1:eac0369: 			triggerActivator.cleanup();
1:eac0369: 			// cache triggerActivator across open()s
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rowChanger != null)
1:eac0369: 			rowChanger.close();
1:eac0369: 
1:eac0369: 		if (deferredBaseCC != null)
1:eac0369: 			deferredBaseCC.close();
1:eac0369: 		deferredBaseCC = null;
1:eac0369: 
1:eac0369: 		if (insertedRowHolder != null)
1:eac0369: 		{
1:eac0369: 			insertedRowHolder.close();
1:eac0369: 		}
1:eac0369: 	
1:eac0369: 		if (deletedRowHolder != null)
1:eac0369: 		{
1:eac0369: 			deletedRowHolder.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (riChecker != null)
1:eac0369: 		{
1:eac0369: 			riChecker.close();
1:eac0369: 			// cache riChecker across open()s
1:eac0369: 		}
1:eac0369: 
1:01632c2: 		close();
1:eac0369: 
1:eac0369: 		endTime = getCurrentTimeMillis();
1:eac0369: 	}
1:eac0369: 
1:6ab1083:     @Override
1:01632c2:     public void close() throws StandardException
1:01632c2:     {
1:45da2f5:         super.close( constants.underMerge() );
1:01632c2:     }
1:01632c2:                                
1:eac0369: 	void rowChangerFinish() throws StandardException
1:eac0369: 	{
1:eac0369: 		rowChanger.finish();
1:eac0369: 	}
1:eac0369: 
1:01632c2:     @Override
1:af1c18c:     public void rememberConstraint(UUID cid) throws StandardException {
1:af1c18c:         if (violatingCheckConstraints == null) {
1:af1c18c:             violatingCheckConstraints = new ArrayList<UUID>();
1:af1c18c:         }
1:af1c18c: 
1:af1c18c:         violatingCheckConstraints.add(cid);
1:af1c18c:     }
1:a826375: 
1:a826375:     /**
1:a826375:      * getSetAutoincrementValue will get the autoincrement value of the 
1:a826375:      * columnPosition specified for the target table. If increment is 
1:a826375:      * non-zero we will also update the autoincrement value. 
1:a826375:      *
1:a826375:      * @param columnPosition	position of the column in the table (1-based)
1:a826375:      * @param increment			amount of increment. 
1:a826375:      *
1:a826375:      * @exception StandardException if anything goes wrong.
1:a826375:      */
1:a826375:     public NumberDataValue
1:a826375:     	getSetAutoincrementValue(int columnPosition, long increment)
1:a826375:     	throws StandardException
1:a826375:     {
1:aa302c3:         autoincrementGenerated = true;
1:a826375:         int index = columnPosition - 1;	// all our indices are 0 based.
1:a826375:         NumberDataValue newValue;
1:a826375:         newValue = activation.getCurrentValueAndAdvance
1:a826375:                 ( identitySequenceUUIDString, aiCache[ index ].getTypeFormatId() );
1:a826375:         aiCache[index] = newValue;
1:aa302c3:         //Save the generated auto increment value for use by JDBC api and
1:aa302c3:         // IDENTITY_LOCAL_VAL function
1:aa302c3: 		identityVal = newValue.getLong();
1:a826375:         return (NumberDataValue) aiCache[index];
1:a826375:     }
1:a826375: 	
1:a826375:     /*
1:a826375:      * The implementation of this method is slightly different than the one
1:a826375:      *  in InsertResultSet. This code was originally written for insert but
1:a826375:      *  with DERBY-6414, we have started supporting update of auto generated
1:a826375:      *  column with keyword DEFAULT. The reason of different implementation is
1:a826375:      *  that the array used in InsertResultSet's implementation of this method,  
1:a826375:      *  ColumnDescriptors in resultDescription hold different entries for
1:a826375:      *  insert and update case. For insert case, the array holds the column
1:a826375:      *  descriptors of all the columns in the table. This is because all the
1:a826375:      *  columns in the table are going to get some value into them whether
1:a826375:      *  or not they were included directly in the actual INSERT statement.
1:a826375:      *  The 2nd array, rla has a spot for each of the columns in the table, 
1:a826375:      *  with non null value for auto generated column. But in case of Update,
1:a826375:      *  resultDescription does not include all the columns in the table. It
1:a826375:      *  only has the columns being touched by the Update statement(the rest of
1:a826375:      *  the columns in the table will retain their original values), and for 
1:a826375:      *  each of those touched columns, it has a duplicate entry in 
1:a826375:      *  resultDescription in order to have before and after values for the 
1:a826375:      *  changed column values. Lastly, it has a row location information for 
1:a826375:      *  the row being updated. This difference in array content of 
1:a826375:      *  resultDescription requires us to have separate implementation of this
1:a826375:      *  method for insert and update.
1:a826375:      */
1:a826375: 	protected void  initializeAIcache(RowLocation[] rla) 
1:a826375: 			throws StandardException{
1:a826375:         if (rla != null)
1:a826375:         {
1:a826375:         	aiCache = new DataValueDescriptor[ rla.length ];
1:a826375:         	ColumnDescriptorList columns = lcc.getDataDictionary().getTableDescriptor(constants.targetUUID).getColumnDescriptorList();
1:a826375:        		for (int i = 0; i < columns.size(); i++)
1:a826375:         	{
1:a826375:         		if (rla[i] == null)
1:a826375:         			continue;        		
1:a826375:         		aiCache[i] = columns.elementAt(i).getType().getNull();
1:a826375:     		}
1:a826375:         }
1:a826375: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:21044de
/////////////////////////////////////////////////////////////////////////
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 		autoincrementGenerated = false;
/////////////////////////////////////////////////////////////////////////
1: 		verifyAutoGeneratedRScolumnsList(constants.targetUUID);
/////////////////////////////////////////////////////////////////////////
1: 		firstExecuteSpecialHandlingAutoGen(firstOpen, rowChanger, constants.targetUUID);
/////////////////////////////////////////////////////////////////////////
0:             // Collect auto-generated keys if requested.
0:             // DERBY-5823: No need to collect them if there are no
0:             // auto-generated key columns.
0:             if (activation.getAutoGeneratedKeysResultsetMode() &&
0:                     autoGeneratedKeysColumnIndexes.length > 0) {
0:                 autoGeneratedKeysRowsHolder.insert(
0:                         getCompactRow(row, autoGeneratedKeysColumnIndexes));
1:                 /*
0:                  * find the value of the identity column. This could either
0:                  * have been generated by Derby or supplied by user(user's
0:                  * can supply value for "generated by default as identity").
0:                  * In both cases, the value can be found in the row. Save
0:                  * that value in identityVal. This locally saved value
0:                  * is made available to JDBC Statement.RETURN_GENERATED_KEYS 
0:                  * or IDENTITY_LOCAL_VAL function only if the UPDATE statement
0:                  * has updated only one row. This implementation is as per the
0:                  * JDBC spec
1:                  */
0:                 TableDescriptor td = lcc.getDataDictionary().getTableDescriptor(constants.targetUUID);
1:             		
0:                 int maxColumns = td.getMaxColumnID();
0:                 int col;
1:                     
0:                 for(col=1;col<=maxColumns;col++)
1:                 {
0:                     ColumnDescriptor cd = td.getColumnDescriptor(col);
0:                     if(cd.isAutoincrement())
1:                     {
1:                         break;
1:                     }
1:                 }
1:                     
0:                 if(col <= maxColumns)
1:                 {
0:                     DataValueDescriptor dvd = row.cloneColumn(col);
0:                     identityVal = dvd.getLong();
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:         
1:         if(rowCount==1 && constants.hasAutoincrement()) 
1: 			lcc.setIdentityValue(identityVal);
/////////////////////////////////////////////////////////////////////////
1:         autoincrementGenerated = true;
1:         //Save the generated auto increment value for use by JDBC api and
1:         // IDENTITY_LOCAL_VAL function
1: 		identityVal = newValue.getLong();
commit:a826375
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.NumberDataValue;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
1: class UpdateResultSet extends DMLWriteGeneratedColumnsResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         this.sourceResultSet = source;
/////////////////////////////////////////////////////////////////////////
1:         identitySequenceUUIDString = constants.identitySequenceUUIDString;
1:         initializeAIcache(constants.getAutoincRowLocation());
/////////////////////////////////////////////////////////////////////////
1: 		saveAIcacheInformation(constants.getSchemaName(), 
1: 			constants.getTableName(), constants.getColumnNames());
/////////////////////////////////////////////////////////////////////////
1: 			savedSource = sourceResultSet;
/////////////////////////////////////////////////////////////////////////
1: 			sourceResultSet.openCore();
1: 			sourceResultSet.reopenCore();
/////////////////////////////////////////////////////////////////////////
1: 		row = getNextRowCore(sourceResultSet);
/////////////////////////////////////////////////////////////////////////
1:             evaluateGenerationClauses( generationClauses, activation, sourceResultSet, row, true );
/////////////////////////////////////////////////////////////////////////
1: 				sourceResultSet.updateRow(newBaseRow, rowChanger);
/////////////////////////////////////////////////////////////////////////
1: 				row = getNextRowCore(sourceResultSet);
/////////////////////////////////////////////////////////////////////////
1: 				Vector<AutoincrementCounter> v = null;
1: 				if (aiCache != null)
1: 				{
1: 					v = new Vector<AutoincrementCounter>();
1: 					for (int i = 0; i < aiCache.length; i++)
1: 					{
1: 						String s, t, c;
1: 						if (aiCache[i] == null)
1: 							continue;
1: 					
1: 						Long initialValue = 
1: 							lcc.lastAutoincrementValue(
1: 								(s = constants.getSchemaName()),
1: 								(t = constants.getTableName()),
1: 								(c = constants.getColumnName(i)));
1: 
1: 						AutoincrementCounter aic = 
1: 							new AutoincrementCounter(
1: 								 initialValue,
1: 								 constants.getAutoincIncrement(i),
1: 								 aiCache[i].getLong(),
1: 								 s, t, c, i + 1);
1: 						v.addElement(aic);
1: 					}
1: 				}
1: 											activation, v);
/////////////////////////////////////////////////////////////////////////
1: 						sourceResultSet.setCurrentRow(deferredTempRow);
/////////////////////////////////////////////////////////////////////////
1: 				sourceResultSet.clearCurrentRow();
/////////////////////////////////////////////////////////////////////////
1: 		if (sourceResultSet != null)
1: 			sourceResultSet.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * getSetAutoincrementValue will get the autoincrement value of the 
1:      * columnPosition specified for the target table. If increment is 
1:      * non-zero we will also update the autoincrement value. 
1:      *
1:      * @param columnPosition	position of the column in the table (1-based)
1:      * @param increment			amount of increment. 
1:      *
1:      * @exception StandardException if anything goes wrong.
1:      */
1:     public NumberDataValue
1:     	getSetAutoincrementValue(int columnPosition, long increment)
1:     	throws StandardException
1:     {
1:         int index = columnPosition - 1;	// all our indices are 0 based.
1:         NumberDataValue newValue;
1:         newValue = activation.getCurrentValueAndAdvance
1:                 ( identitySequenceUUIDString, aiCache[ index ].getTypeFormatId() );
1:         aiCache[index] = newValue;
1:         return (NumberDataValue) aiCache[index];
1:     }
1: 	
1:     /*
1:      * The implementation of this method is slightly different than the one
1:      *  in InsertResultSet. This code was originally written for insert but
1:      *  with DERBY-6414, we have started supporting update of auto generated
1:      *  column with keyword DEFAULT. The reason of different implementation is
1:      *  that the array used in InsertResultSet's implementation of this method,  
1:      *  ColumnDescriptors in resultDescription hold different entries for
1:      *  insert and update case. For insert case, the array holds the column
1:      *  descriptors of all the columns in the table. This is because all the
1:      *  columns in the table are going to get some value into them whether
1:      *  or not they were included directly in the actual INSERT statement.
1:      *  The 2nd array, rla has a spot for each of the columns in the table, 
1:      *  with non null value for auto generated column. But in case of Update,
1:      *  resultDescription does not include all the columns in the table. It
1:      *  only has the columns being touched by the Update statement(the rest of
1:      *  the columns in the table will retain their original values), and for 
1:      *  each of those touched columns, it has a duplicate entry in 
1:      *  resultDescription in order to have before and after values for the 
1:      *  changed column values. Lastly, it has a row location information for 
1:      *  the row being updated. This difference in array content of 
1:      *  resultDescription requires us to have separate implementation of this
1:      *  method for insert and update.
1:      */
1: 	protected void  initializeAIcache(RowLocation[] rla) 
1: 			throws StandardException{
1:         if (rla != null)
1:         {
1:         	aiCache = new DataValueDescriptor[ rla.length ];
1:         	ColumnDescriptorList columns = lcc.getDataDictionary().getTableDescriptor(constants.targetUUID).getColumnDescriptorList();
1:        		for (int i = 0; i < columns.size(); i++)
1:         	{
1:         		if (rla[i] == null)
1:         			continue;        		
1:         		aiCache[i] = columns.elementAt(i).getType().getNull();
1:     		}
1:         }
1: 	}
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: 												insertedRowHolder.getResultSet(),
1: 												constants.getBaseRowReadMap());
/////////////////////////////////////////////////////////////////////////
1: 										insertedRowHolder.getResultSet(),
1: 										constants.getBaseRowReadMap());
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1:                                 constants.targetUUID,
/////////////////////////////////////////////////////////////////////////
1:                             constants.targetUUID,
/////////////////////////////////////////////////////////////////////////
1:                                 constants.targetUUID,
commit:45da2f5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
/////////////////////////////////////////////////////////////////////////
1:      * @param activation The activation
/////////////////////////////////////////////////////////////////////////
1:      * @param constantActionItem  id of the update constant action saved object
/////////////////////////////////////////////////////////////////////////
1:      * @param activation
1:      * @param passedInConstantAction
1:      * @param passedInRsd
/////////////////////////////////////////////////////////////////////////
1:             for (FKInfo fkInfo : fkInfoArray) {
1:                 if (fkInfo.type == FKInfo.REFERENCED_KEY) {
1:                     updatingReferencedKey = true;
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.ASSERT(
1:                             constants.deferred,
1:                             "updating referenced key but update not " +
1:                                 "deferred, wuzzup?");
1:                     }
1:                 } else {
1:                     updatingForeignKey = true;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             runChecker(true); // check for only RESTRICT referential
1:             updateDeferredRows();
1:             runChecker(false); // check for all  violations
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         ExecRow nextRow = super.getNextRowCore( source );
1:         if ( (nextRow != null) && constants.underMerge() ) {
1:             nextRow = processMergeRow( source, nextRow );
1:         }
1:         return nextRow;
/////////////////////////////////////////////////////////////////////////
1:                 double rowCnt = tableScan.getEstimatedRowCount();
1:                 if (rowCnt > 0.0)
1:                     rowCnt = rowCnt / 0.75 + 1.0;   // load factor
1:                     if (rowCnt < initCapacity)
1:                         initCapacity = (int) rowCnt;
/////////////////////////////////////////////////////////////////////////
1:                     (TransactionController.OPENMODE_SECONDARY_LOCKED |
1:                      TransactionController.OPENMODE_FORUPDATE),
/////////////////////////////////////////////////////////////////////////
1:     void runChecker(boolean restrictCheckOnly)
/////////////////////////////////////////////////////////////////////////
1:                     if (restrictCheckOnly) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         super.close( constants.underMerge() );
commit:18a6fb2
/////////////////////////////////////////////////////////////////////////
0:             runChecker(true, true); // check for only RESTRICT referential
1:                                     // action rule violations
0:             runChecker(false, false); // check for all  violations
/////////////////////////////////////////////////////////////////////////
0:     void runChecker(boolean restrictCheckOnly, boolean postCheck)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 
1:                         {
1:                             // Argument "1" below: If a PK referenced by an FK
1:                             // is deferred, require at least one to be present
1:                             // in the primary table since we have modified the
1:                             // row's PK, unless postCheck == true, in which the
1:                             // call to postChecks does the actual checking, and
1:                             // we need at least one row intact to fulfill the
1:                             // constraint.
1:                            riChecker.doRICheck(
1:                                     activation,
1:                                     i,
1:                                     deletedRow,
1:                                     restrictCheckOnly,
0:                                     postCheck,
1:                                     1);
1: 
0:                     if (postCheck) {
1:                         riChecker.postCheck(i);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                                 activation,
1:                                 i,
1:                                 insertedRow,
1:                                 restrictCheckOnly,
0:                                 postCheck, // N/A, not referenced key
1:                                 0);        // N/A, not referenced key
1:                     }
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory.CheckInfo;
/////////////////////////////////////////////////////////////////////////
1:                 riChecker = new RISetChecker(lcc, tc, fkInfoArray);
/////////////////////////////////////////////////////////////////////////
1:                                 baseRowLocation,
1:                                 new CheckInfo[1]);
/////////////////////////////////////////////////////////////////////////
1:                             baseRowLocation,
1:                             new CheckInfo[1]);
/////////////////////////////////////////////////////////////////////////
1:                     riChecker.doFKCheck(activation, newBaseRow);
/////////////////////////////////////////////////////////////////////////
1:                                 baseRowLocation,
1:                                 new CheckInfo[1]);
/////////////////////////////////////////////////////////////////////////
1:                             riChecker.doRICheck(
0:                                 activation, i, deletedRow, restrictCheckOnly);
/////////////////////////////////////////////////////////////////////////
0:                             riChecker.doRICheck(
0:                                 activation, i, insertedRow, restrictCheckOnly);
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLBoolean;
1: import org.apache.derby.iapi.types.SQLRef;
0: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     private List<UUID>              violatingCheckConstraints;
1:     private BackingStoreHashtable   deferredChecks; // cached ref.
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Run check constraints against the current row. Raise an error if
1:      * a check constraint is violated, unless all the offending checks are
1:      * deferred, in which case a false value will be returned. A NULL value
1:      * will be interpreted as success (not violation).
1:      *
1:      * @exception StandardException thrown on error
1:      */
1:     private boolean evaluateCheckConstraints() throws StandardException     {
1:         boolean result = true;
1: 
1:         if (checkGM != null) {
1:             // Evaluate the check constraints. If all check constraint modes are
1:             // immediate, a check error will throw rather than return a false
1:             // value.
1:             SQLBoolean allOk =
1:                     (SQLBoolean)checkGM.invoke(activation);
1:             result = allOk.isNull() || allOk.getBoolean();
1:         }
1: 
1:         return result;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     boolean allOk = evaluateCheckConstraints();
1:                     if (!allOk) {
1:                         DataValueDescriptor[] rw = row.getRowArray();
1:                         SQLRef r = (SQLRef)rw[rw.length - 1];
1:                         RowLocation baseRowLocation =
1:                             (RowLocation)r.getObject();
1: 
1:                         deferredChecks =
1:                             DeferredConstraintsMemory.rememberCheckViolations(
1:                                 lcc,
0:                                 heapConglom,
1:                                 constants.getSchemaName(),
1:                                 constants.getTableName(),
1:                                 deferredChecks,
1:                                 violatingCheckConstraints,
1:                                 baseRowLocation);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 boolean allOk = evaluateCheckConstraints();
1:                 /* Get the RowLocation to update
1:                 if (!allOk) {
1:                     deferredChecks =
1:                         DeferredConstraintsMemory.rememberCheckViolations(
1:                             lcc,
0:                             heapConglom,
1:                             constants.getSchemaName(),
1:                             constants.getTableName(),
1:                             deferredChecks,
1:                             violatingCheckConstraints,
0:                             baseRowLocation);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     boolean allOk = true;
1: 
1:                         allOk = evaluateCheckConstraints();
/////////////////////////////////////////////////////////////////////////
1: 
1:                     if (!allOk) {
1:                         deferredChecks =
1:                             DeferredConstraintsMemory.rememberCheckViolations(
1:                                 lcc,
0:                                 heapConglom,
1:                                 constants.getSchemaName(),
1:                                 constants.getTableName(),
1:                                 deferredChecks,
1:                                 violatingCheckConstraints,
0:                                 baseRowLocation);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void rememberConstraint(UUID cid) throws StandardException {
1:         if (violatingCheckConstraints == null) {
1:             violatingCheckConstraints = new ArrayList<UUID>();
1:         }
1: 
1:         violatingCheckConstraints.add(cid);
1:     }
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
0: 				source.updateRow(newBaseRow, rowChanger);
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 	protected ExecRow getNextRowCore( NoPutResultSet source )
1: 		throws StandardException
1: 	{
0: 		ExecRow row = super.getNextRowCore( source );
1: 
0:         if ( (row != null) && constants.underMerge() ) { row = processMergeRow( source, row ); }
1: 
0:         return row;
1: 	}
1: 
1:     /**
1:      * <p>
1:      * Special handling if this is an UPDATE action of a MERGE statement.
1:      * </p>
1:      */
1: 	private ExecRow processMergeRow( NoPutResultSet sourceRS, ExecRow row )
1: 		throws StandardException
1: 	{
1:         //
1:         // After we fix derby-6414, we will need to handle the DEFAULT keyword
1:         // for identity columns, just as we do in InsertResultSet.processMergeRow().
1:         // For the moment, we just allow the bad behavior described by derby-6414.
1:         //
1:         return normalizeRow( sourceRS, row );
1: 	}
1: 
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 		close();
1:     @Override
1:     public void close() throws StandardException
1:     {
0:         close( constants.underMerge() );
1:     }
1:                                
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1:             tableScan.past2FutureTbl.putRow
1:                 (
1:                  false,
1:                  new DataValueDescriptor[] { rl.cloneValue(false) },
1:                  null
1:                  );
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1: 		rowCount = 0L;
commit:ec4aa98
/////////////////////////////////////////////////////////////////////////
0:             evaluateGenerationClauses( generationClauses, activation, source, row, true );
commit:ca28065
/////////////////////////////////////////////////////////////////////////
1:     private GeneratedMethod         generationClauses;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param generationClauses	Generated method for computed generation clauses
1: 						   GeneratedMethod generationClauses,
1: 		this(source, generationClauses, checkGM , activation, activation.getConstantAction(),null);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param generationClauses	Generated method for computed generation clauses
/////////////////////////////////////////////////////////////////////////
1: 						   GeneratedMethod generationClauses,
1: 		this(source, generationClauses, checkGM , activation,
/////////////////////////////////////////////////////////////////////////
1: 	 * @param generationClauses	Generated method for computed generation clauses
1: 						   GeneratedMethod generationClauses,
/////////////////////////////////////////////////////////////////////////
1:         this.generationClauses = generationClauses;
/////////////////////////////////////////////////////////////////////////
0:             evaluateGenerationClauses( generationClauses, activation, source, row );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c67f5dd
/////////////////////////////////////////////////////////////////////////
commit:91f376c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
/////////////////////////////////////////////////////////////////////////
1: 		boolean notifyCursor = (tableScan != null);
/////////////////////////////////////////////////////////////////////////
1: 	 * (for fast search), so that when the cursor hits it again, it knows to skip it.
/////////////////////////////////////////////////////////////////////////
1: 					DataValueDescriptor key = row[k];
/////////////////////////////////////////////////////////////////////////
1:                 tableScan.past2FutureTbl = new BackingStoreHashtable(
1:                         tc, null, new int[]{0}, false, -1,
1:                         maxCapacity, initCapacity, -1, false,
1:                         tableScan.getActivation().getResultSetHoldability());
1:             /* Add the row location to the hash table.
0:             tableScan.past2FutureTbl.putRow(
1:                 false,
0:                 new DataValueDescriptor[] { rl.cloneValue(false) });
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
0:     private ResultDescription 		resultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	private ResultDescription		triggerResultDescription;
1: 	/**
0:      * Returns the description of the updated rows.
0:      * REVISIT: Do we want this to return NULL instead?
1: 	 */
0: 	public ResultDescription getResultDescription()
1: 	{
0: 	    return resultDescription;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 			resultDescription = source.getResultDescription();
/////////////////////////////////////////////////////////////////////////
1: 				triggerResultDescription = (resultDescription != null) ?
1: 									resultDescription.truncateColumns(numberOfBaseColumns+1) :
1: 									null;
/////////////////////////////////////////////////////////////////////////
1: 					new TemporaryRowHolderImpl(activation, properties,
1: 											   triggerResultDescription);
1: 				new TemporaryRowHolderImpl(activation, properties,
1: 										   triggerResultDescription);
/////////////////////////////////////////////////////////////////////////
0: 							(activation, null, null, 100, false, true);
commit:300bbeb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6369b54
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		super.setup();
1: 
1: 		/* decode lock mode */
1: 		lockMode = decodeLockMode(constants.lockMode);
1: 
/////////////////////////////////////////////////////////////////////////
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
0: 				source.updateRow(newBaseRow);
/////////////////////////////////////////////////////////////////////////
0: 					source.updateRow(newBaseRow);
commit:81b9853
/////////////////////////////////////////////////////////////////////////
1: 				deletedRowHolder =
0: 					new TemporaryRowHolderImpl(activation, properties,
0: 											   triggerResultDescription);
1: 			insertedRowHolder =
0: 				new TemporaryRowHolderImpl(activation, properties,
0: 										   triggerResultDescription);
/////////////////////////////////////////////////////////////////////////
0: 							(activation, null, null, 100, false, true);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
0:             /* If hash table is not full, we add it in.
0:              * The key of the hash entry is the string value of the RowLocation.
0:              * If the hash table is full, as the comments above this function
0:              * say, we scan forward.
1:              *
1:              * Need to save a clone because when we get cached currentRow, "rl"
1:              * shares the same reference, so is changed at the same time.
1:              */
0:             RowLocation updatedRL = (RowLocation) rl.cloneValue(false);
/////////////////////////////////////////////////////////////////////////
0:                 tableScan.lastCursorKey.setColumn(i, aCol.cloneValue(false));
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:24e3f7e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ResultDescription resultDescription;
0: 			resultDescription = activation.getResultDescription();
commit:51572c8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:88bb146
/////////////////////////////////////////////////////////////////////////
0: 					new TemporaryRowHolderImpl(activation, properties);
0: 				new TemporaryRowHolderImpl(activation, properties);
/////////////////////////////////////////////////////////////////////////
0: 							(activation, null, 100, false, true);
commit:4119c42
/////////////////////////////////////////////////////////////////////////
1: 		fkInfoArray = constants.getFKInfo();
1: 		triggerInfo = constants.getTriggerInfo();
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
0: import java.util.Hashtable;
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.db.TriggerExecutionContext;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.StreamStorable;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.types.BooleanDataValue;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
commit:6bc9897
/////////////////////////////////////////////////////////////////////////
0: class UpdateResultSet extends DMLWriteResultSet
1: 	private TransactionController 	tc;
1: 	private ExecRow					newBaseRow;
1: 	private ExecRow 					row;
1: 	private ExecRow 					deferredSparseRow;
1: 	UpdateConstantAction		constants;
1: 	NoPutResultSet			savedSource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     UpdateResultSet(NoPutResultSet source,
/////////////////////////////////////////////////////////////////////////
1:     UpdateResultSet(NoPutResultSet source,
/////////////////////////////////////////////////////////////////////////
1:     UpdateResultSet(NoPutResultSet source,
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Get the current transaction controller
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.UpdateResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: import org.apache.derby.iapi.services.io.StreamStorable;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: import java.util.Hashtable;
1: 
1: /**
1:  * Update the rows from the specified
1:  * base table. This will cause constraints to be checked
1:  * and triggers to be executed based on the c's and t's
1:  * compiled into the update plan.
1:  *
0:  * @author ames
1:  */
0: public class UpdateResultSet extends DMLWriteResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public TransactionController 	tc;
0: 	public ExecRow					newBaseRow;
0: 	public ExecRow 					row;
0: 	public ExecRow 					deferredSparseRow;
0: 	public UpdateConstantAction		constants;
1: 	
0:     private ResultDescription 		resultDescription;
0: 	private NoPutResultSet			source;
0: 	public	NoPutResultSet			savedSource;
1: 	private RowChanger				rowChanger;
1: 
1: 	protected ConglomerateController	deferredBaseCC;
1: 
1: 	protected long[]				deferredUniqueCIDs;
1: 	protected boolean[]				deferredUniqueCreated;
1: 	protected ConglomerateController	deferredUniqueCC[];
1: 	protected ScanController[]		deferredUniqueScans;
0: 	public	LanguageConnectionContext lcc;
1: 
1: 	private	TemporaryRowHolderImpl	deletedRowHolder;
1: 	private	TemporaryRowHolderImpl	insertedRowHolder;
1: 
1: 	// cached 
1: 	private RISetChecker			riChecker;
1: 	private	TriggerInfo				triggerInfo;
1: 	private TriggerEventActivator	triggerActivator;
1: 	private boolean					updatingReferencedKey;
1: 	private boolean					updatingForeignKey;
1: 	private	int						numOpens;
1: 	private long					heapConglom; 
1: 	private FKInfo[]				fkInfoArray;
1: 	private FormatableBitSet 				baseRowReadList;
1: 	private GeneratedMethod			checkGM;
1: 	private int						resultWidth;
1: 	private int						numberOfBaseColumns;
1: 	private ExecRow					deferredTempRow;
1: 	private ExecRow					deferredBaseRow;
1: 	private ExecRow					oldDeletedRow;
0: 	private ResultDescription		triggerResultDescription;
1: 
1: 	int lockMode;
1: 	boolean deferred;
1: 	boolean beforeUpdateCopyRequired = false;
1: 
1: 	/**
0:      * Returns the description of the updated rows.
0:      * REVISIT: Do we want this to return NULL instead?
1: 	 */
0: 	public ResultDescription getResultDescription()
1: 	{
0: 	    return resultDescription;
1: 	}
1: 
1:     /*
1:      * class interface
1:      *
1:      */
1:     /**
1: 	 * @param source update rows come from source
1: 	 * @param checkGM	Generated method for enforcing check constraints
0: 	 * @param compiledConstants constantAction for the update
1: 	 * @exception StandardException thrown on error
1:      */
0:     public UpdateResultSet(NoPutResultSet source,
1: 						   GeneratedMethod checkGM,
1: 						   Activation activation)
1:       throws StandardException
1:     {
0: 		this(source, checkGM , activation, activation.getConstantAction(),null);
1: 	}
1: 
1:     /*
1:      * class interface
1:      *
1:      */
1:     /**
1: 	 * @param source update rows come from source
1: 	 * @param checkGM	Generated method for enforcing check constraints
1: 	 * @param activation Activation
0: 	 * @param constantActionItem  id of the update constant action saved objec
1: 	 * @param rsdItem  id of the Result Description saved object
1: 	 * @exception StandardException thrown on error
1:      */
0:     public UpdateResultSet(NoPutResultSet source,
1: 						   GeneratedMethod checkGM,
1: 						   Activation activation, 
1: 						   int constantActionItem,
1: 						   int rsdItem)
1:       throws StandardException
1:     {
0: 		this(source, checkGM , activation,
1: 			  ((ConstantAction)activation.getPreparedStatement().getSavedObject(constantActionItem)),
1: 			 (ResultDescription) activation.getPreparedStatement().getSavedObject(rsdItem));
1: 	
1: 		// In case of referential action update, we do a deferred updates
1: 		deferred = true;
1: 	}
1: 
1: 
1:     /*
1:      * class interface
1:      *
1:      */
1:     /**
1: 	 * @param source update rows come from source
1: 	 * @param checkGM	Generated method for enforcing check constraints
0: 	 * @param compiledConstants constantAction for the update
1: 	 * @exception StandardException thrown on error
1:      */
0:     public UpdateResultSet(NoPutResultSet source,
1: 						   GeneratedMethod checkGM,
1: 						   Activation activation,
1: 						   ConstantAction passedInConstantAction,
1: 						   ResultDescription passedInRsd)
1:       throws StandardException
1:     {
1: 		super(activation, passedInConstantAction);
0: 		// find the language context.
0: 		lcc = activation.getLanguageConnectionContext();
0:         // Get the current transaction controller
1:         tc = activation.getTransactionController();
0: 		this.source = source;
1: 		this.checkGM = checkGM;
1: 
1: 		constants = (UpdateConstantAction) constantAction;
0: 		fkInfoArray = constants.getFKInfo( lcc.getExecutionContext() );
0: 		triggerInfo = constants.getTriggerInfo(lcc.getExecutionContext());
1: 
1: 		heapConglom = constants.conglomId;
1: 
1: 		baseRowReadList = constants.getBaseRowReadList();
1: 		if(passedInRsd ==null)
0: 			resultDescription = source.getResultDescription();
1: 		else
1: 			resultDescription = passedInRsd;
1: 		/*
1: 		** We NEED a result description when we are going to
1: 		** to have to kick off a trigger.  In a replicated environment
1: 		** we don't get a result description when we are replaying
1: 		** source xacts on the target, which should never be the
1: 		** case for an UpdateResultSet.
1: 		*/
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (resultDescription == null)
1: 			{
1: 				SanityManager.ASSERT(triggerInfo == null, "triggers need a result description to pass to result sets given to users");
1: 			}
1: 		}
1: 
1: 		if (fkInfoArray != null)
1: 		{
1: 			for (int i = 0; i < fkInfoArray.length; i++)
1: 			{
1: 				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
1: 				{
0: 					updatingReferencedKey = true;
1: 					if (SanityManager.DEBUG)
1: 					{
0: 						SanityManager.ASSERT(constants.deferred, "updating referenced key but update not deferred, wuzzup?");
1: 					}
1: 				}
1: 				else
1: 				{	
0: 					updatingForeignKey = true;
1: 				}
1: 			}
1: 		}
1: 
1: 		/* Get the # of columns in the ResultSet */
1: 		resultWidth = resultDescription.getColumnCount();
1: 		
1: 		/*
1: 		** Calculate the # of columns in the base table.  The result set
1: 		** contains the before columns, the after columns, and the RowLocation,
1: 		** so the number of base columns is half of the number of result set
1: 		** columns, after subtracting one for the row location column.
1: 		*/
1: 		numberOfBaseColumns = (resultWidth - 1) / 2;
1: 		
1: 		/* Get the new base row */
1: 		newBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
1: 
0: 		/* decode lock mode */
0: 		lockMode = decodeLockMode(lcc, constants.lockMode);
1: 		deferred = constants.deferred;
1: 		
1: 		//update can be marked for deferred mode because the scan is being done
1: 		//using index. But it is not necesary  to keep the before copy
1: 		//of the row in the temporary row holder (deletedRowHolder) unless
1: 		//there are RI constraint or Triggers.(beetle:5301)
1: 		if(triggerInfo != null || fkInfoArray !=null){
1: 			beforeUpdateCopyRequired = true;
1: 		}
1: 		
1: 	}
1: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public void open() throws StandardException
1: 	{
1: 
1: 		setup();
1: 		collectAffectedRows();
1: 
1: 		/*
1: 		** If this is a deferred update, read the new rows and RowLocations
1: 		** from the temporary conglomerate and update the base table using
1: 		** the RowChanger.
1: 		*/
1: 		if (deferred)
1: 		{
1: 
0: 			runChecker(true); //check for only RESTRICT referential action rule violations
1: 			fireBeforeTriggers();
0: 			updateDeferredRows();
1: 			/* Apply deferred inserts to unique indexes */
1: 			rowChanger.finish();
0: 			runChecker(false); //check for all  violations
1: 			fireAfterTriggers();
1: 
1: 		}
1: 		else{
1: 		/* Apply deferred inserts to unique indexes */
1: 		rowChanger.finish();
1: 		}
1: 
1: 		cleanUp();
1:     }
1: 
1: 
1: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	void setup() throws StandardException
1: 	{
1: 		boolean firstOpen = (rowChanger == null);
1: 
0: 		rowCount = 0;
1: 		
1: 		/* Cache query plan text for source, before it gets blown away */
1: 		if (lcc.getRunTimeStatisticsMode())
1: 		{
1: 			/* savedSource nulled after run time statistics generation */
0: 			savedSource = source;
1: 		}
1: 
1: 		/* Get or re-use the row changer.
0: 		 * NOTE: We need to set ourself as the top result set
0: 		 * if this is not the 1st execution.  (Done in constructor
0: 		 * for 1st execution.)
1: 		 */
1: 		if (firstOpen)
1: 		{
1: 			rowChanger = lcc.getLanguageConnectionFactory().getExecutionFactory()
1: 				             .getRowChanger( heapConglom, 
1: 										 constants.heapSCOCI, 
1: 										 heapDCOCI,
1: 										 constants.irgs,
1: 										 constants.indexCIDS,
1: 										 constants.indexSCOCIs,
1: 										 indexDCOCIs,
1: 										 constants.numColumns,
1: 										 tc,
1: 										 constants.changedColumnIds,
1: 										 constants.getBaseRowReadList(),
1: 										 constants.getBaseRowReadMap(),
1: 										 constants.getStreamStorableHeapColIds(),
1: 										 activation);
1: 			rowChanger.setIndexNames(constants.indexNames);
1: 		}
1: 		else
1: 		{
0: 			lcc.getStatementContext().setTopResultSet(this, subqueryTrackingArray);
1: 		}
1: 
1: 
1: 		/* Open the RowChanger before the source ResultSet so that
1: 		 * the store will see the RowChanger's lock as a covering lock
1: 		 * if it is a table lock.
1: 		 */
1: 		rowChanger.open(lockMode);
1: 
1: 		if (numOpens++ == 0)
1: 		{
0: 			source.openCore();
1: 		}
1: 		else
1: 		{
0: 			source.reopenCore();
1: 		}
1: 
1: 		/* The source does not know whether or not we are doing a
1: 		 * deferred mode update.  If we are, then we must clear the
1: 		 * index scan info from the activation so that the row changer
1: 		 * does not re-use that information (which won't be valid for
1: 		 * a deferred mode update).
1: 		 */
1: 		if (deferred)
1: 		{
1: 			activation.clearIndexScanInfo();
1: 		}
1: 
1: 		if (fkInfoArray != null)
1: 		{
1: 			if (riChecker == null)
1: 			{
0: 				riChecker = new RISetChecker(tc, fkInfoArray);
1: 			}
1: 			else
1: 			{
1: 				riChecker.reopen();
1: 			}
1: 		}
1: 
1: 		if (deferred)
1: 		{
1: 			/* Allocate the temporary rows and get result description
1: 			 * if this is the 1st time that we are executing.
1: 			 */
1: 			if (firstOpen)
1: 			{
1: 				deferredTempRow = RowUtil.getEmptyValueRow(numberOfBaseColumns+1, lcc);
1: 				oldDeletedRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
0: 				triggerResultDescription = (resultDescription != null) ?
0: 									resultDescription.truncateColumns(numberOfBaseColumns+1) :
0: 									null;
1: 			}
1: 
1: 			Properties properties = new Properties();
1: 
1: 			// Get the properties on the heap
1: 			rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
1: 			if(beforeUpdateCopyRequired){
0: 				deletedRowHolder = new TemporaryRowHolderImpl(tc, properties, triggerResultDescription);
1: 			}
0: 			insertedRowHolder = new TemporaryRowHolderImpl(tc, properties, triggerResultDescription);
1: 
1: 			rowChanger.setRowHolder(insertedRowHolder);
1: 		}
1: 
1: 	}	
1: 
1: 	/* Following 2 methods are for checking and make sure we don't have one un-objectified stream
1: 	 * to be inserted into 2 temp table rows for deferred update.  Otherwise it would cause problem
1: 	 * when writing to disk using the stream a second time.  In other cases we don't want to
1: 	 * unnecessarily objectify the stream. beetle 4896.
1: 	 */
1: 	private FormatableBitSet checkStreamCols()
1: 	{
1: 		DataValueDescriptor[] cols = row.getRowArray();
1: 		FormatableBitSet streamCols = null;
1: 		for (int i = 0; i < numberOfBaseColumns; i++)
1: 		{
1: 			if (cols[i+numberOfBaseColumns] instanceof StreamStorable)  //check new values
1: 			{
1: 				if (streamCols == null) streamCols = new FormatableBitSet(numberOfBaseColumns);
1: 				streamCols.set(i);
1: 			}
1: 		}
1: 		return streamCols;
1: 	}
1: 
1: 	private void objectifyStream(ExecRow tempRow, FormatableBitSet streamCols) throws StandardException
1: 	{
1: 		DataValueDescriptor[] cols = tempRow.getRowArray();
1: 		for (int i = 0; i < numberOfBaseColumns; i++)
1: 		{
1: 			if (cols[i] != null && streamCols.get(i))
1: 				((StreamStorable)cols[i]).loadStream();
1: 		}
1: 	}
1: 
1: 	public boolean collectAffectedRows() throws StandardException
1: 	{
1: 
1: 		boolean rowsFound = false;
0: 		row = getNextRowCore(source);
1: 		if (row!=null)
1: 			rowsFound = true;
1: 		else
1: 		{
1: 			activation.addWarning(
1: 						StandardException.newWarning(
1: 							SQLState.LANG_NO_ROW_FOUND));
1: 		}
1: 
1: 		//beetle 3865, update cursor use index.
1: 		TableScanResultSet tableScan = (TableScanResultSet) activation.getForUpdateIndexScan();
0: 		boolean notifyCursor = ((tableScan != null) && ! tableScan.sourceDrained);
1: 		boolean checkStream = (deferred && rowsFound && ! constants.singleRowSource);
1: 		FormatableBitSet streamCols = (checkStream ? checkStreamCols() : null);
1: 		checkStream = (streamCols != null);
1: 
1:         while ( row != null )
1:         {
1: 
1: 			/* By convention, the last column in the result set for an
1: 			 * update contains a SQLRef containing the RowLocation of
1: 			 * the row to be updated.
1: 			 */
1: 
1: 			/*
1: 			** If we're doing deferred update, write the new row and row
1: 			** location to the temporary conglomerate.  If we're not doing
1: 			** deferred update, update the permanent conglomerates now
1: 			** using the RowChanger.
1: 			*/
1: 			if (deferred)
1: 			{
1: 				/*
1: 				** If we have a before trigger, we must evaluate the 
1: 				** check constraint after we have executed the trigger.
1: 				** Note that we have compiled checkGM accordingly (to
1: 				** handle the different row shape if we are evaluating
1: 				** against the input result set or a temporary row holder
1: 				** result set).
1: 				*/
1: 				if (triggerInfo == null)
1: 				{
0: 					evaluateCheckConstraints( checkGM, activation );
1: 				}
1: 
1: 				/*
1: 				** We are going to only save off the updated
1: 				** columns and the RID.  For a trigger, all columns
1: 				** were marked as needed so we'll copy them all.
1: 				*/
1: 				RowUtil.copyRefColumns(deferredTempRow,
1: 											row,
1: 											numberOfBaseColumns,
1: 											numberOfBaseColumns + 1);
1: 				if (checkStream)
1: 					objectifyStream(deferredTempRow, streamCols);
1: 
1: 				insertedRowHolder.insert(deferredTempRow); 
1: 
1: 				/*
1: 				** Grab a copy of the row to delete.  We are
1: 				** going to use this for deferred RI checks.
1: 				*/
1: 				if(beforeUpdateCopyRequired)
1: 				{
1: 					RowUtil.copyRefColumns(oldDeletedRow,
1: 										   row,
1: 										   numberOfBaseColumns);
1: 
1: 					deletedRowHolder.insert(oldDeletedRow);
1: 				}
1: 
1: 				/*
1: 				** If we haven't already, lets get a template to
1: 				** use as a template for our rescan of the base table.
1: 				** Do this now while we have a real row to use
1: 				** as a copy.
1: 				**
1: 				** There is one less column in the base row than
1: 				** there is in source row, because the base row
1: 				** doesn't contain the row location.
1: 				*/
1: 				if (deferredBaseRow == null)
1: 				{
1: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
1: 			
1: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
1: 											numberOfBaseColumns);
1: 
1: 					/*
1: 					** While we're here, let's also create a sparse row for
1: 					** fetching from the store.
1: 					*/
1: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
1: 																baseRowReadList,
1: 																lcc);
1: 				}
1: 			}
1: 			else
1: 			{
0: 				evaluateCheckConstraints( checkGM, activation );
1: 
0: 				/* Get the RowLocation to update 
1: 			 	* NOTE - Column #s in the Row are 1 based.
1: 			 	*/
1: 				RowLocation baseRowLocation = (RowLocation)
1: 					(row.getColumn(resultWidth)).getObject();
1: 
1: 				RowUtil.copyRefColumns(newBaseRow,
1: 										row,
1: 										numberOfBaseColumns,
1: 										numberOfBaseColumns);
1: 
1: 				if (riChecker != null)
1: 				{
1: 					/*
1: 					** Make sure all foreign keys in the new row
1: 					** are maintained.  Note that we don't bother 
1: 					** checking primary/unique keys that are referenced
1: 					** here.  The reason is that if we are updating
1: 					** a referenced key, we'll be updating in deferred
1: 					** mode, so we wont get here.
1: 					*/
0: 					riChecker.doFKCheck(newBaseRow);
1: 				}
1: 
1: 				rowChanger.updateRow(row,newBaseRow,baseRowLocation);
1: 
1: 				//beetle 3865, update cursor use index.
1: 				if (notifyCursor)
1: 					notifyForUpdateCursor(row.getRowArray(),newBaseRow.getRowArray(),baseRowLocation,
1: 											tableScan);
1: 			}
1: 
1: 			rowCount++;
1: 
1: 			// No need to do a next on a single row source
1: 			if (constants.singleRowSource)
1: 			{
1: 				row = null;
1: 			}
1: 			else
1: 			{
0: 				row = getNextRowCore(source);
1: 			}
1: 		}
1: 
1: 		return rowsFound;
1: 	}
1: 
1: 	/* beetle 3865, updateable cursor use index. If the row we are updating has new value that
1: 	 * falls into the direction of the index scan of the cursor, we save this rid into a hash table
0: 	 * (for fast search), so that when the cursor hits it again, it knows to skip it.  When we get
0: 	 * to a point that the hash table is full, we scan forward the cursor until one of two things
0: 	 * happen: (1) we hit a record whose rid is in the hash table (we went through it already, so
0: 	 * skip it), we remove it from hash table, so that we can continue to use hash table. OR, (2) the scan
0: 	 * forward hit the end.  If (2) happens, we can de-reference the hash table to make it available
0: 	 * for garbage collection.  We save the future row id's in a virtual mem heap.  In any case,
0: 	 * next read will use a row id that we saved.
1: 	 */
1: 	private void notifyForUpdateCursor(DataValueDescriptor[] row, DataValueDescriptor[] newBaseRow,
1: 										RowLocation rl, TableScanResultSet tableScan)
1: 		throws StandardException
1: 	{
1: 		int[] indexCols = tableScan.indexCols;
1: 		int[] changedCols = constants.changedColumnIds;
1: 		boolean placedForward = false, ascending, decided = false, overlap = false;
1: 		int basePos, k;
1: 		/* first of all, we see if there's overlap between changed column ids and index key
1: 		 * columns.  If so, we see if the new update value falls into the future range of the
1: 		 * index scan, if so, we need to save it in hash table.
1: 		 */
1: 		for (int i = 0; i < indexCols.length; i++)
1: 		{
1: 			basePos = indexCols[i];
1: 			if (basePos > 0)
1: 				ascending = true;
1: 			else
1: 			{
1: 				ascending = false;
1: 				basePos = -basePos;
1: 			}
1: 			for (int j = 0; j < changedCols.length; j++)
1: 			{
1: 				if (basePos == changedCols[j])
1: 				{
1: 					decided = true;		//we pretty much decided if new row falls in front
1: 										//of the cursor or behind
1: 					/* the row and newBaseRow we get are compact base row that only have
1: 				 	 * referenced columns.  Our "basePos" is index in sparse heap row, so
1: 					 * we need the BaseRowReadMap to map into the compact row.
1: 					 */
1: 					int[] map = constants.getBaseRowReadMap();
1: 					if (map == null)
1: 						k = basePos - 1;
1: 					else
1: 						k =  map[basePos - 1];
1: 
0: 					DataValueDescriptor key;
0: 					/* We need to compare with saved most-forward cursor scan key if we
0: 					 * are reading records from the saved RowLocation temp table (instead
0: 					 * of the old column value) because we only care if new update value
0: 					 * jumps forward the most-forward scan key.
1: 					 */
0: 					if (tableScan.compareToLastKey)
0: 						key = tableScan.lastCursorKey.getColumn(i + 1);
1: 					else
0: 						key = row[k];
1: 
1: 					/* Starting from the first index key column forward, we see if the direction
1: 					 * of the update change is consistent with the direction of index scan.
1: 					 * If so, we save it in hash table.
1: 					 */
1: 					if ((ascending && key.greaterThan(newBaseRow[k], key).equals(true)) ||
1: 						(!ascending && key.lessThan(newBaseRow[k], key).equals(true)))
1: 						placedForward = true;
1: 					else if (key.equals(newBaseRow[k], key).equals(true))
1: 					{
1: 						decided = false;
1: 						overlap = true;
1: 					}
1: 					break;
1: 				}
1: 			}
1: 			if (decided)  // already decided if new row falls in front or behind
1: 				break;
1: 		}
1: 		/* If index row gets updated but key value didn't actually change, we still
1: 		 * put it in hash table because it can either fall in front or behind.  This
1: 		 * can happen if the update explicitly sets a value, but same as old.
1: 		 */
1: 		if (overlap && !decided)
1: 			placedForward = true;
1: 
1: 		if (placedForward)		// add it to hash table
1: 		{
1: 			/* determining initial capacity of hash table from a few factors:
1: 			 * (1) user specified MAX_MEMORY_PER_TABLE property, (2) min value 100
1: 			 * (3) optimizer estimated row count.  We want to avoid re-hashing if
1: 			 * possible, for performance reason, yet don't waste space.  If initial
1: 			 * capacity is greater than max size divided by load factor, no rehash
1: 			 * is ever needed.
1: 			 */
1: 			int maxCapacity = lcc.getOptimizerFactory().getMaxMemoryPerTable() / 16;
1: 			if (maxCapacity < 100)
1: 				maxCapacity = 100;
1: 
1: 			if (tableScan.past2FutureTbl == null)
1: 			{
0: 				double rowCount = tableScan.getEstimatedRowCount();
1: 				int initCapacity = 32 * 1024;
0: 				if (rowCount > 0.0)
1: 				{
0: 					rowCount = rowCount / 0.75 + 1.0;	// load factor
0: 					if (rowCount < initCapacity)
0: 						initCapacity = (int) rowCount;
1: 				}
1: 				if (maxCapacity < initCapacity)
1: 					initCapacity = maxCapacity;
1: 
0: 				tableScan.past2FutureTbl = new Hashtable(initCapacity);
1: 			}
1: 
0: 			Hashtable past2FutureTbl = tableScan.past2FutureTbl;
0: 			/* If hash table is not full, we add it in.  The key of the hash entry
0: 			 * is the string value of the RowLocation.  If the hash table is full,
0: 			 * as the comments above this function say, we scan forward.
1: 			 *
0: 			 * Need to save a clone because when we get cached currentRow, "rl" shares the
0: 			 * same reference, so is changed at the same time.
1: 			 */
0: 			RowLocation updatedRL = (RowLocation) rl.getClone();
1: 
0: 			if (past2FutureTbl.size() < maxCapacity)
0: 				past2FutureTbl.put(updatedRL, updatedRL);
1: 			else
1: 			{
0: 				tableScan.skipFutureRowHolder = true;
0: 				ExecRow rlRow = new ValueRow(1);
1: 
0: 				for (;;)
1: 				{
0: 					ExecRow aRow = tableScan.getNextRowCore();
0: 					if (aRow == null)
1: 					{
0: 						tableScan.sourceDrained = true;
0: 						tableScan.past2FutureTbl = null;	// de-reference for garbage coll.
1: 						break;
1: 					}
0: 					RowLocation rowLoc = (RowLocation) aRow.getColumn(aRow.nColumns());
1: 
0: 					if (updatedRL.equals(rowLoc))  //this row we are updating jumped forward
1: 					{
0: 						saveLastCusorKey(tableScan, aRow);
0: 						break;	// don't need to worry about adding this row to hash any more
1: 					}
1: 
0: 					if (tableScan.futureForUpdateRows == null)
1: 					{
0: 						// virtual memory heap. In-memory part size 100. With the co-operation
0: 						// of hash table and in-memory part of heap (hash table shrinks while
0: 						// in-memory heap grows), hopefully we never spill temp table to disk.
1: 
0: 						tableScan.futureForUpdateRows = new TemporaryRowHolderImpl
0: 							(tc, null, null, 100, false, true);
1: 					}
1: 
0: 					rlRow.setColumn(1, rowLoc);
0: 					tableScan.futureForUpdateRows.insert(rlRow);
0: 					if (past2FutureTbl.size() < maxCapacity) //we got space in the hash table now, stop!
1: 					{
0: 						past2FutureTbl.put(updatedRL, updatedRL);
0: 						saveLastCusorKey(tableScan, aRow);
1: 						break;
1: 					}
1: 				}
0: 				tableScan.skipFutureRowHolder = false;
1: 			}
1: 		}
1: 	}
1: 
0: 	private void saveLastCusorKey(TableScanResultSet tableScan, ExecRow aRow) throws StandardException
1: 	{
0: 		/* We save the most-forward cursor scan key where we are stopping, so
0: 		 * that next time when we decide if we need to put an updated row id into
0: 		 * hash table, we can compare with this key.  This is an optimization on
0: 		 * memory usage of the hash table, otherwise it may be "leaking".
1: 		 */
0: 		if (tableScan.lastCursorKey == null)
0: 			tableScan.lastCursorKey = new ValueRow(aRow.nColumns() - 1);
0: 		for (int i = 1; i <= tableScan.lastCursorKey.nColumns(); i++)
1: 		{
0: 			DataValueDescriptor aCol = aRow.getColumn(i);
0: 			if (aCol != null)
0: 				tableScan.lastCursorKey.setColumn(i, aCol.getClone());
1: 		}
1: 	}
1: 
1: 	void fireBeforeTriggers() throws StandardException
1: 	{
1: 		if (deferred)
1: 		{
1: 			if (triggerInfo != null)
1: 			{
1: 				if (triggerActivator == null)
1: 				{
1: 				triggerActivator = new TriggerEventActivator(lcc, 
1: 											tc, 
1: 											constants.targetUUID,
1: 											triggerInfo,
1: 											TriggerExecutionContext.UPDATE_EVENT,
0: 											activation, null);
1: 				}
1: 				else
1: 				{
1: 					triggerActivator.reopen();
1: 				}
1: 
1: 				// fire BEFORE trigger, do this before checking constraints
1: 				triggerActivator.notifyEvent(TriggerEvents.BEFORE_UPDATE, 
1: 												deletedRowHolder.getResultSet(),
0: 												insertedRowHolder.getResultSet());
1: 
1: 			}
1: 		}
1: 	}
1: 
1:     void fireAfterTriggers() throws StandardException
1: 	{
1: 		if (deferred)
1: 		{
1: 			if (triggerActivator != null)
1: 			{
1: 				triggerActivator.notifyEvent(TriggerEvents.AFTER_UPDATE, 
1: 										deletedRowHolder.getResultSet(),
0: 										insertedRowHolder.getResultSet());
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 
1: 	void updateDeferredRows() throws StandardException
1: 	{
1: 		if (deferred)
1: 		{
1: 			// we already have everything locked 
1: 			deferredBaseCC = 
1:                 tc.openCompiledConglomerate(
0:                     false,
0:                     tc.OPENMODE_FORUPDATE|tc.OPENMODE_SECONDARY_LOCKED,
1:                     lockMode,
1:                     TransactionController.ISOLATION_SERIALIZABLE,
1:                     constants.heapSCOCI,
1:                     heapDCOCI);
1: 			
1: 			CursorResultSet rs = insertedRowHolder.getResultSet();
1: 			try
1: 			{
1: 				/*
1: 				** We need to do a fetch doing a partial row
1: 				** read.  We need to shift our 1-based bit
1: 				** set to a zero based bit set like the store
1: 				** expects.
1: 				*/
1: 				FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
1: 				ExecRow deferredTempRow2;
1: 
1: 				rs.open();
1: 				while ((deferredTempRow2 = rs.getNextRow()) != null)
1: 				{
1: 					/*
1: 					** Check the constraint now if we have triggers.
1: 					** Otherwise we evaluated them as we read the
1: 					** rows in from the source.
1: 					*/
1: 					if (triggerInfo != null)
1: 					{
0: 						source.setCurrentRow(deferredTempRow);
0: 						evaluateCheckConstraints(checkGM, activation);
1: 					}
1: 
1: 					/* 
1: 					** The last column is a Ref, which contains a 
1: 					** RowLocation.
1: 					*/
1: 					DataValueDescriptor rlColumn = deferredTempRow2.getColumn(numberOfBaseColumns + 1);
1: 					RowLocation baseRowLocation = 
1: 							(RowLocation) (rlColumn).getObject();
1: 	
1: 					/* Get the base row at the given RowLocation */
1: 					boolean row_exists = 
1: 						deferredBaseCC.fetch(
1: 							baseRowLocation, deferredSparseRow.getRowArray(), 
1: 							readBitSet);
1: 
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						SanityManager.ASSERT(row_exists, "did not find base row in deferred update");
1: 					}
1: 	
1: 					/*
1: 					** Copy the columns from the temp row to the base row.
1: 					** The base row has fewer columns than the temp row,
1: 					** because it doesn't contain the row location.
1: 					*/
1: 					RowUtil.copyRefColumns(newBaseRow,
1: 											deferredTempRow2,
1: 											numberOfBaseColumns);
1: 
1: 					rowChanger.updateRow(deferredBaseRow,
1: 										newBaseRow,
0: 										baseRowLocation);
1: 				}
1: 			} finally
1: 			{
0: 				source.clearCurrentRow();
1: 				rs.close();
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	
0: 	void runChecker(boolean restrictCheckOnly) throws StandardException
1: 	{
1: 
1: 		/*
1: 		** For a deferred update, make sure that there
1: 		** aren't any primary keys that were removed which
1: 		** are referenced.  
1: 		*/
1: 		if (deferred && updatingReferencedKey)
1: 		{
1: 			ExecRow	deletedRow;
1: 			CursorResultSet deletedRows; 
1: 
1: 			/*
1: 			** For each referenced key that was modified
1: 			*/
1: 			for (int i = 0; i < fkInfoArray.length; i++)
1: 			{
1: 				if (fkInfoArray[i].type == FKInfo.FOREIGN_KEY)
1: 				{
1: 					continue;
1: 				}
1: 
1: 				deletedRows = deletedRowHolder.getResultSet();
1: 				try
1: 				{
1: 					/*
1: 					** For each delete row
1: 					*/	
1: 					deletedRows.open();
1: 					while ((deletedRow = deletedRows.getNextRow()) != null)
1: 					{
1: 						if (!foundRow(deletedRow, 
1: 										fkInfoArray[i].colArray, 
1: 										insertedRowHolder))
1: 						{
0: 							riChecker.doRICheck(i, deletedRow, restrictCheckOnly);
1: 						}
1: 					}	
1: 				}
1: 				finally
1: 				{
1: 					deletedRows.close();
1: 				}
1: 			}
1: 		}
1: 
1: 		/*
1: 		** For a deferred update, make sure that there
1: 		** aren't any foreign keys that were added that
1:  		** aren't referenced.  
1: 		*/
1: 		if (deferred && updatingForeignKey)
1: 		{
1: 			ExecRow	insertedRow;
1: 			CursorResultSet insertedRows; 
1: 
1: 			/*
1: 			** For each foreign key that was modified
1: 			*/
1: 			for (int i = 0; i < fkInfoArray.length; i++)
1: 			{
1: 				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
1: 				{
1: 					continue;
1: 				}
1: 
1: 				insertedRows = insertedRowHolder.getResultSet();
1: 				try
1: 				{
1: 					/*
1: 					** For each inserted row
1: 					*/	
1: 					insertedRows.open();
1: 					while ((insertedRow = insertedRows.getNextRow()) != null)
1: 					{
1: 						if (!foundRow(insertedRow, 
1: 										fkInfoArray[i].colArray, 
1: 										deletedRowHolder))
1: 						{
0: 							riChecker.doRICheck(i, insertedRow, restrictCheckOnly);
1: 						}
1: 					}	
1: 				}
1: 				finally
1: 				{
1: 					insertedRows.close();
1: 				}
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	public static boolean foundRow
1: 	(
1: 		ExecRow					checkRow, 
1: 		int[]					colsToCheck,
1: 		TemporaryRowHolderImpl	rowHolder
1: 	)
1: 		throws StandardException
1: 	{
1: 		ExecRow				scanRow;
1: 		boolean				foundMatch = false;
1: 		Object[] 			checkRowArray = checkRow.getRowArray();
1: 		DataValueDescriptor	checkCol;
1: 		DataValueDescriptor	scanCol;
1: 
1: 		CursorResultSet rs = rowHolder.getResultSet();
1: 		try
1: 		{	
1: 			/*
1: 			** For each inserted row
1: 			*/	
1: 			rs.open();
1: 			while ((scanRow = rs.getNextRow()) != null)
1: 			{
1: 				Object[] scanRowArray = scanRow.getRowArray();
1: 				int i;
1: 				for (i = 0; i < colsToCheck.length; i++)
1: 				{
1: 					checkCol = (DataValueDescriptor)checkRowArray[colsToCheck[i]-1];
1: 					scanCol = (DataValueDescriptor)scanRowArray[colsToCheck[i]-1];
1: 
1: 					BooleanDataValue result = checkCol.equals(
1: 											scanCol,
1: 											checkCol); // result
1: 					if (!result.getBoolean())
1: 					{
1: 						break;
1: 					}
1: 				}
1: 				if (i == colsToCheck.length)
1: 				{
1: 					foundMatch = true;
1: 					break;
1: 				}	
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			rs.close();
1: 		}
1: 		return foundMatch;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see ResultSet#cleanUp
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void	cleanUp() throws StandardException
1: 	{ 
1: 		numOpens = 0;
1: 
1: 		/* Close down the source ResultSet tree */
0: 		if (source != null)
1: 		{
0: 			source.close();
1: 			// cache source across open()s
1: 		}
1: 
1: 		if (triggerActivator != null)
1: 		{
1: 			triggerActivator.cleanup();
1: 			// cache triggerActivator across open()s
1: 		}
1: 
1: 		if (rowChanger != null)
1: 			rowChanger.close();
1: 
1: 		if (deferredBaseCC != null)
1: 			deferredBaseCC.close();
1: 		deferredBaseCC = null;
1: 
1: 		if (insertedRowHolder != null)
1: 		{
1: 			insertedRowHolder.close();
1: 		}
1: 	
1: 		if (deletedRowHolder != null)
1: 		{
1: 			deletedRowHolder.close();
1: 		}
1: 
1: 		if (riChecker != null)
1: 		{
1: 			riChecker.close();
1: 			// cache riChecker across open()s
1: 		}
1: 
0: 		super.close();
1: 
1: 		endTime = getCurrentTimeMillis();
1: 	}
1: 
1:     /**
0:      * Decode the update lock mode.
0:      * <p>
0:      * The value for update lock mode is in the 2nd 2 bytes for 
0:      * ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL isolation level.  Otherwise
0:      * (REPEATABLE READ, READ COMMITTED, and READ UNCOMMITTED) the lock mode is
0:      * located in the first 2 bytes.
0:      * <p>
0:      * This is done to override the optimizer choice to provide maximum 
0:      * concurrency of record level locking except in SERIALIZABLE where table
0:      * level locking is required in heap scans for correctness.
0:      * <p>
0:      * See Compilation!QueryTree!FromBaseTable for encoding of the lockmode.
0:      * <p>
1:      *
0: 	 * @return The lock mode (record or table) to use to open the result set.
1:      *
0:      * @param lcc       The context to look for current isolation level.
0:      * @param lockMode  The compiled encoded lock mode for this query.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected static int decodeLockMode(
0:     LanguageConnectionContext   lcc, 
0:     int                         lockMode)
1: 	{
0: 		if ((lockMode >>> 16) != 0)
1: 		{
0:             // Note that isolation level encoding from 
0:             // getCurrentIsolationLevel() returns 
0:             // ExecutionContext.*ISOLATION_LEVEL constants, not 
0:             // TransactionController.ISOLATION* constants.
1: 
0: 			int isolationLevel = lcc.getCurrentIsolationLevel();
1: 
0:             if (isolationLevel != ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
1:             {
0: 				lockMode = lockMode & 0xff;
1:             }
1:             else
1:             {
0: 				lockMode = lockMode >>> 16;
1:             }
1: 		}
0: 		return lockMode;
1: 	}
1: 
1: 	
1: 	void rowChangerFinish() throws StandardException
1: 	{
1: 		rowChanger.finish();
1: 	}
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:cfcbbae
/////////////////////////////////////////////////////////////////////////
0: 				rowChanger.updateRow(row,newBaseRow,baseRowLocation);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: import org.apache.derby.iapi.services.io.StreamStorable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: import java.util.Hashtable;
0: 
0: /**
0:  * Update the rows from the specified
0:  * base table. This will cause constraints to be checked
0:  * and triggers to be executed based on the c's and t's
0:  * compiled into the update plan.
0:  *
0:  * @author ames
0:  */
0: public class UpdateResultSet extends DMLWriteResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public TransactionController 	tc;
0: 	public ExecRow					newBaseRow;
0: 	public ExecRow 					row;
0: 	public ExecRow 					deferredSparseRow;
0: 	public UpdateConstantAction		constants;
0: 	
0:     private ResultDescription 		resultDescription;
0: 	private NoPutResultSet			source;
0: 	public	NoPutResultSet			savedSource;
0: 	private RowChanger				rowChanger;
0: 
0: 	protected ConglomerateController	deferredBaseCC;
0: 
0: 	protected long[]				deferredUniqueCIDs;
0: 	protected boolean[]				deferredUniqueCreated;
0: 	protected ConglomerateController	deferredUniqueCC[];
0: 	protected ScanController[]		deferredUniqueScans;
0: 	public	LanguageConnectionContext lcc;
0: 
0: 	private	TemporaryRowHolderImpl	deletedRowHolder;
0: 	private	TemporaryRowHolderImpl	insertedRowHolder;
0: 
0: 	// cached 
0: 	private RISetChecker			riChecker;
0: 	private	TriggerInfo				triggerInfo;
0: 	private TriggerEventActivator	triggerActivator;
0: 	private boolean					updatingReferencedKey;
0: 	private boolean					updatingForeignKey;
0: 	private	int						numOpens;
0: 	private long					heapConglom; 
0: 	private FKInfo[]				fkInfoArray;
0: 	private FormatableBitSet 				baseRowReadList;
0: 	private GeneratedMethod			checkGM;
0: 	private int						resultWidth;
0: 	private int						numberOfBaseColumns;
0: 	private ExecRow					deferredTempRow;
0: 	private ExecRow					deferredBaseRow;
0: 	private ExecRow					oldDeletedRow;
0: 	private ResultDescription		triggerResultDescription;
0: 
0: 	int lockMode;
0: 	boolean deferred;
0: 	boolean beforeUpdateCopyRequired = false;
0: 
0: 	/**
0:      * Returns the description of the updated rows.
0:      * REVISIT: Do we want this to return NULL instead?
0: 	 */
0: 	public ResultDescription getResultDescription()
0: 	{
0: 	    return resultDescription;
0: 	}
0: 
0:     /*
0:      * class interface
0:      *
0:      */
0:     /**
0: 	 * @param source update rows come from source
0: 	 * @param checkGM	Generated method for enforcing check constraints
0: 	 * @param compiledConstants constantAction for the update
0: 	 * @exception StandardException thrown on error
0:      */
0:     public UpdateResultSet(NoPutResultSet source,
0: 						   GeneratedMethod checkGM,
0: 						   Activation activation)
0:       throws StandardException
0:     {
0: 		this(source, checkGM , activation, activation.getConstantAction(),null);
0: 	}
0: 
0:     /*
0:      * class interface
0:      *
0:      */
0:     /**
0: 	 * @param source update rows come from source
0: 	 * @param checkGM	Generated method for enforcing check constraints
0: 	 * @param activation Activation
0: 	 * @param constantActionItem  id of the update constant action saved objec
0: 	 * @param rsdItem  id of the Result Description saved object
0: 	 * @exception StandardException thrown on error
0:      */
0:     public UpdateResultSet(NoPutResultSet source,
0: 						   GeneratedMethod checkGM,
0: 						   Activation activation, 
0: 						   int constantActionItem,
0: 						   int rsdItem)
0:       throws StandardException
0:     {
0: 		this(source, checkGM , activation,
0: 			  ((ConstantAction)activation.getPreparedStatement().getSavedObject(constantActionItem)),
0: 			 (ResultDescription) activation.getPreparedStatement().getSavedObject(rsdItem));
0: 	
0: 		// In case of referential action update, we do a deferred updates
0: 		deferred = true;
0: 	}
0: 
0: 
0:     /*
0:      * class interface
0:      *
0:      */
0:     /**
0: 	 * @param source update rows come from source
0: 	 * @param checkGM	Generated method for enforcing check constraints
0: 	 * @param compiledConstants constantAction for the update
0: 	 * @exception StandardException thrown on error
0:      */
0:     public UpdateResultSet(NoPutResultSet source,
0: 						   GeneratedMethod checkGM,
0: 						   Activation activation,
0: 						   ConstantAction passedInConstantAction,
0: 						   ResultDescription passedInRsd)
0:       throws StandardException
0:     {
0: 		super(activation, passedInConstantAction);
0: 		// find the language context.
0: 		lcc = activation.getLanguageConnectionContext();
0:         // Get the current transaction controller
0:         tc = activation.getTransactionController();
0: 		this.source = source;
0: 		this.checkGM = checkGM;
0: 
0: 		constants = (UpdateConstantAction) constantAction;
0: 		fkInfoArray = constants.getFKInfo( lcc.getExecutionContext() );
0: 		triggerInfo = constants.getTriggerInfo(lcc.getExecutionContext());
0: 
0: 		heapConglom = constants.conglomId;
0: 
0: 		baseRowReadList = constants.getBaseRowReadList();
0: 		if(passedInRsd ==null)
0: 			resultDescription = source.getResultDescription();
0: 		else
0: 			resultDescription = passedInRsd;
0: 		/*
0: 		** We NEED a result description when we are going to
0: 		** to have to kick off a trigger.  In a replicated environment
0: 		** we don't get a result description when we are replaying
0: 		** source xacts on the target, which should never be the
0: 		** case for an UpdateResultSet.
0: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (resultDescription == null)
0: 			{
0: 				SanityManager.ASSERT(triggerInfo == null, "triggers need a result description to pass to result sets given to users");
0: 			}
0: 		}
0: 
0: 		if (fkInfoArray != null)
0: 		{
0: 			for (int i = 0; i < fkInfoArray.length; i++)
0: 			{
0: 				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
0: 				{
0: 					updatingReferencedKey = true;
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						SanityManager.ASSERT(constants.deferred, "updating referenced key but update not deferred, wuzzup?");
0: 					}
0: 				}
0: 				else
0: 				{	
0: 					updatingForeignKey = true;
0: 				}
0: 			}
0: 		}
0: 
0: 		/* Get the # of columns in the ResultSet */
0: 		resultWidth = resultDescription.getColumnCount();
0: 		
0: 		/*
0: 		** Calculate the # of columns in the base table.  The result set
0: 		** contains the before columns, the after columns, and the RowLocation,
0: 		** so the number of base columns is half of the number of result set
0: 		** columns, after subtracting one for the row location column.
0: 		*/
0: 		numberOfBaseColumns = (resultWidth - 1) / 2;
0: 		
0: 		/* Get the new base row */
0: 		newBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
0: 
0: 		/* decode lock mode */
0: 		lockMode = decodeLockMode(lcc, constants.lockMode);
0: 		deferred = constants.deferred;
0: 		
0: 		//update can be marked for deferred mode because the scan is being done
0: 		//using index. But it is not necesary  to keep the before copy
0: 		//of the row in the temporary row holder (deletedRowHolder) unless
0: 		//there are RI constraint or Triggers.(beetle:5301)
0: 		if(triggerInfo != null || fkInfoArray !=null){
0: 			beforeUpdateCopyRequired = true;
0: 		}
0: 		
0: 	}
0: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public void open() throws StandardException
0: 	{
0: 
0: 		setup();
0: 		collectAffectedRows();
0: 
0: 		/*
0: 		** If this is a deferred update, read the new rows and RowLocations
0: 		** from the temporary conglomerate and update the base table using
0: 		** the RowChanger.
0: 		*/
0: 		if (deferred)
0: 		{
0: 
0: 			runChecker(true); //check for only RESTRICT referential action rule violations
0: 			fireBeforeTriggers();
0: 			updateDeferredRows();
0: 			/* Apply deferred inserts to unique indexes */
0: 			rowChanger.finish();
0: 			runChecker(false); //check for all  violations
0: 			fireAfterTriggers();
0: 
0: 		}
0: 		else{
0: 		/* Apply deferred inserts to unique indexes */
0: 		rowChanger.finish();
0: 		}
0: 
0: 		cleanUp();
0:     }
0: 
0: 
0: 	/**
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	void setup() throws StandardException
0: 	{
0: 		boolean firstOpen = (rowChanger == null);
0: 
0: 		rowCount = 0;
0: 		
0: 		/* Cache query plan text for source, before it gets blown away */
0: 		if (lcc.getRunTimeStatisticsMode())
0: 		{
0: 			/* savedSource nulled after run time statistics generation */
0: 			savedSource = source;
0: 		}
0: 
0: 		/* Get or re-use the row changer.
0: 		 * NOTE: We need to set ourself as the top result set
0: 		 * if this is not the 1st execution.  (Done in constructor
0: 		 * for 1st execution.)
0: 		 */
0: 		if (firstOpen)
0: 		{
0: 			rowChanger = lcc.getLanguageConnectionFactory().getExecutionFactory()
0: 				             .getRowChanger( heapConglom, 
0: 										 constants.heapSCOCI, 
0: 										 heapDCOCI,
0: 										 constants.irgs,
0: 										 constants.indexCIDS,
0: 										 constants.indexSCOCIs,
0: 										 indexDCOCIs,
0: 										 constants.numColumns,
0: 										 tc,
0: 										 constants.changedColumnIds,
0: 										 constants.getBaseRowReadList(),
0: 										 constants.getBaseRowReadMap(),
0: 										 constants.getStreamStorableHeapColIds(),
0: 										 activation);
0: 			rowChanger.setIndexNames(constants.indexNames);
0: 		}
0: 		else
0: 		{
0: 			lcc.getStatementContext().setTopResultSet(this, subqueryTrackingArray);
0: 		}
0: 
0: 
0: 		/* Open the RowChanger before the source ResultSet so that
0: 		 * the store will see the RowChanger's lock as a covering lock
0: 		 * if it is a table lock.
0: 		 */
0: 		rowChanger.open(lockMode);
0: 
0: 		if (numOpens++ == 0)
0: 		{
0: 			source.openCore();
0: 		}
0: 		else
0: 		{
0: 			source.reopenCore();
0: 		}
0: 
0: 		/* The source does not know whether or not we are doing a
0: 		 * deferred mode update.  If we are, then we must clear the
0: 		 * index scan info from the activation so that the row changer
0: 		 * does not re-use that information (which won't be valid for
0: 		 * a deferred mode update).
0: 		 */
0: 		if (deferred)
0: 		{
0: 			activation.clearIndexScanInfo();
0: 		}
0: 
0: 		if (fkInfoArray != null)
0: 		{
0: 			if (riChecker == null)
0: 			{
0: 				riChecker = new RISetChecker(tc, fkInfoArray);
0: 			}
0: 			else
0: 			{
0: 				riChecker.reopen();
0: 			}
0: 		}
0: 
0: 		if (deferred)
0: 		{
0: 			/* Allocate the temporary rows and get result description
0: 			 * if this is the 1st time that we are executing.
0: 			 */
0: 			if (firstOpen)
0: 			{
0: 				deferredTempRow = RowUtil.getEmptyValueRow(numberOfBaseColumns+1, lcc);
0: 				oldDeletedRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
0: 				triggerResultDescription = (resultDescription != null) ?
0: 									resultDescription.truncateColumns(numberOfBaseColumns+1) :
0: 									null;
0: 			}
0: 
0: 			Properties properties = new Properties();
0: 
0: 			// Get the properties on the heap
0: 			rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
0: 			if(beforeUpdateCopyRequired){
0: 				deletedRowHolder = new TemporaryRowHolderImpl(tc, properties, triggerResultDescription);
0: 			}
0: 			insertedRowHolder = new TemporaryRowHolderImpl(tc, properties, triggerResultDescription);
0: 
0: 			rowChanger.setRowHolder(insertedRowHolder);
0: 		}
0: 
0: 	}	
0: 
0: 	/* Following 2 methods are for checking and make sure we don't have one un-objectified stream
0: 	 * to be inserted into 2 temp table rows for deferred update.  Otherwise it would cause problem
0: 	 * when writing to disk using the stream a second time.  In other cases we don't want to
0: 	 * unnecessarily objectify the stream. beetle 4896.
0: 	 */
0: 	private FormatableBitSet checkStreamCols()
0: 	{
0: 		DataValueDescriptor[] cols = row.getRowArray();
0: 		FormatableBitSet streamCols = null;
0: 		for (int i = 0; i < numberOfBaseColumns; i++)
0: 		{
0: 			if (cols[i+numberOfBaseColumns] instanceof StreamStorable)  //check new values
0: 			{
0: 				if (streamCols == null) streamCols = new FormatableBitSet(numberOfBaseColumns);
0: 				streamCols.set(i);
0: 			}
0: 		}
0: 		return streamCols;
0: 	}
0: 
0: 	private void objectifyStream(ExecRow tempRow, FormatableBitSet streamCols) throws StandardException
0: 	{
0: 		DataValueDescriptor[] cols = tempRow.getRowArray();
0: 		for (int i = 0; i < numberOfBaseColumns; i++)
0: 		{
0: 			if (cols[i] != null && streamCols.get(i))
0: 				((StreamStorable)cols[i]).loadStream();
0: 		}
0: 	}
0: 
0: 	public boolean collectAffectedRows() throws StandardException
0: 	{
0: 
0: 		boolean rowsFound = false;
0: 		row = getNextRowCore(source);
0: 		if (row!=null)
0: 			rowsFound = true;
0: 		else
0: 		{
0: 			activation.addWarning(
0: 						StandardException.newWarning(
0: 							SQLState.LANG_NO_ROW_FOUND));
0: 		}
0: 
0: 		//beetle 3865, update cursor use index.
0: 		TableScanResultSet tableScan = (TableScanResultSet) activation.getForUpdateIndexScan();
0: 		boolean notifyCursor = ((tableScan != null) && ! tableScan.sourceDrained);
0: 		boolean checkStream = (deferred && rowsFound && ! constants.singleRowSource);
0: 		FormatableBitSet streamCols = (checkStream ? checkStreamCols() : null);
0: 		checkStream = (streamCols != null);
0: 
0:         while ( row != null )
0:         {
0: 
0: 			/* By convention, the last column in the result set for an
0: 			 * update contains a SQLRef containing the RowLocation of
0: 			 * the row to be updated.
0: 			 */
0: 
0: 			/*
0: 			** If we're doing deferred update, write the new row and row
0: 			** location to the temporary conglomerate.  If we're not doing
0: 			** deferred update, update the permanent conglomerates now
0: 			** using the RowChanger.
0: 			*/
0: 			if (deferred)
0: 			{
0: 				/*
0: 				** If we have a before trigger, we must evaluate the 
0: 				** check constraint after we have executed the trigger.
0: 				** Note that we have compiled checkGM accordingly (to
0: 				** handle the different row shape if we are evaluating
0: 				** against the input result set or a temporary row holder
0: 				** result set).
0: 				*/
0: 				if (triggerInfo == null)
0: 				{
0: 					evaluateCheckConstraints( checkGM, activation );
0: 				}
0: 
0: 				/*
0: 				** We are going to only save off the updated
0: 				** columns and the RID.  For a trigger, all columns
0: 				** were marked as needed so we'll copy them all.
0: 				*/
0: 				RowUtil.copyRefColumns(deferredTempRow,
0: 											row,
0: 											numberOfBaseColumns,
0: 											numberOfBaseColumns + 1);
0: 				if (checkStream)
0: 					objectifyStream(deferredTempRow, streamCols);
0: 
0: 				insertedRowHolder.insert(deferredTempRow); 
0: 
0: 				/*
0: 				** Grab a copy of the row to delete.  We are
0: 				** going to use this for deferred RI checks.
0: 				*/
0: 				if(beforeUpdateCopyRequired)
0: 				{
0: 					RowUtil.copyRefColumns(oldDeletedRow,
0: 										   row,
0: 										   numberOfBaseColumns);
0: 
0: 					deletedRowHolder.insert(oldDeletedRow);
0: 				}
0: 
0: 				/*
0: 				** If we haven't already, lets get a template to
0: 				** use as a template for our rescan of the base table.
0: 				** Do this now while we have a real row to use
0: 				** as a copy.
0: 				**
0: 				** There is one less column in the base row than
0: 				** there is in source row, because the base row
0: 				** doesn't contain the row location.
0: 				*/
0: 				if (deferredBaseRow == null)
0: 				{
0: 					deferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns, lcc);
0: 			
0: 					RowUtil.copyCloneColumns(deferredBaseRow, row, 
0: 											numberOfBaseColumns);
0: 
0: 					/*
0: 					** While we're here, let's also create a sparse row for
0: 					** fetching from the store.
0: 					*/
0: 					deferredSparseRow = makeDeferredSparseRow(deferredBaseRow,
0: 																baseRowReadList,
0: 																lcc);
0: 				}
0: 			}
0: 			else
0: 			{
0: 				evaluateCheckConstraints( checkGM, activation );
0: 
0: 				/* Get the RowLocation to update 
0: 			 	* NOTE - Column #s in the Row are 1 based.
0: 			 	*/
0: 				RowLocation baseRowLocation = (RowLocation)
0: 					(row.getColumn(resultWidth)).getObject();
0: 
0: 				RowUtil.copyRefColumns(newBaseRow,
0: 										row,
0: 										numberOfBaseColumns,
0: 										numberOfBaseColumns);
0: 
0: 				if (riChecker != null)
0: 				{
0: 					/*
0: 					** Make sure all foreign keys in the new row
0: 					** are maintained.  Note that we don't bother 
0: 					** checking primary/unique keys that are referenced
0: 					** here.  The reason is that if we are updating
0: 					** a referenced key, we'll be updating in deferred
0: 					** mode, so we wont get here.
0: 					*/
0: 					riChecker.doFKCheck(newBaseRow);
0: 				}
0: 
0: 				rowChanger.updateRow(row,newBaseRow,baseRowLocation);
0: 
0: 				//beetle 3865, update cursor use index.
0: 				if (notifyCursor)
0: 					notifyForUpdateCursor(row.getRowArray(),newBaseRow.getRowArray(),baseRowLocation,
0: 											tableScan);
0: 			}
0: 
0: 			rowCount++;
0: 
0: 			// No need to do a next on a single row source
0: 			if (constants.singleRowSource)
0: 			{
0: 				row = null;
0: 			}
0: 			else
0: 			{
0: 				row = getNextRowCore(source);
0: 			}
0: 		}
0: 
0: 		return rowsFound;
0: 	}
0: 
0: 	/* beetle 3865, updateable cursor use index. If the row we are updating has new value that
0: 	 * falls into the direction of the index scan of the cursor, we save this rid into a hash table
0: 	 * (for fast search), so that when the cursor hits it again, it knows to skip it.  When we get
0: 	 * to a point that the hash table is full, we scan forward the cursor until one of two things
0: 	 * happen: (1) we hit a record whose rid is in the hash table (we went through it already, so
0: 	 * skip it), we remove it from hash table, so that we can continue to use hash table. OR, (2) the scan
0: 	 * forward hit the end.  If (2) happens, we can de-reference the hash table to make it available
0: 	 * for garbage collection.  We save the future row id's in a virtual mem heap.  In any case,
0: 	 * next read will use a row id that we saved.
0: 	 */
0: 	private void notifyForUpdateCursor(DataValueDescriptor[] row, DataValueDescriptor[] newBaseRow,
0: 										RowLocation rl, TableScanResultSet tableScan)
0: 		throws StandardException
0: 	{
0: 		int[] indexCols = tableScan.indexCols;
0: 		int[] changedCols = constants.changedColumnIds;
0: 		boolean placedForward = false, ascending, decided = false, overlap = false;
0: 		int basePos, k;
0: 		/* first of all, we see if there's overlap between changed column ids and index key
0: 		 * columns.  If so, we see if the new update value falls into the future range of the
0: 		 * index scan, if so, we need to save it in hash table.
0: 		 */
0: 		for (int i = 0; i < indexCols.length; i++)
0: 		{
0: 			basePos = indexCols[i];
0: 			if (basePos > 0)
0: 				ascending = true;
0: 			else
0: 			{
0: 				ascending = false;
0: 				basePos = -basePos;
0: 			}
0: 			for (int j = 0; j < changedCols.length; j++)
0: 			{
0: 				if (basePos == changedCols[j])
0: 				{
0: 					decided = true;		//we pretty much decided if new row falls in front
0: 										//of the cursor or behind
0: 					/* the row and newBaseRow we get are compact base row that only have
0: 				 	 * referenced columns.  Our "basePos" is index in sparse heap row, so
0: 					 * we need the BaseRowReadMap to map into the compact row.
0: 					 */
0: 					int[] map = constants.getBaseRowReadMap();
0: 					if (map == null)
0: 						k = basePos - 1;
0: 					else
0: 						k =  map[basePos - 1];
0: 
0: 					DataValueDescriptor key;
0: 					/* We need to compare with saved most-forward cursor scan key if we
0: 					 * are reading records from the saved RowLocation temp table (instead
0: 					 * of the old column value) because we only care if new update value
0: 					 * jumps forward the most-forward scan key.
0: 					 */
0: 					if (tableScan.compareToLastKey)
0: 						key = tableScan.lastCursorKey.getColumn(i + 1);
0: 					else
0: 						key = row[k];
0: 
0: 					/* Starting from the first index key column forward, we see if the direction
0: 					 * of the update change is consistent with the direction of index scan.
0: 					 * If so, we save it in hash table.
0: 					 */
0: 					if ((ascending && key.greaterThan(newBaseRow[k], key).equals(true)) ||
0: 						(!ascending && key.lessThan(newBaseRow[k], key).equals(true)))
0: 						placedForward = true;
0: 					else if (key.equals(newBaseRow[k], key).equals(true))
0: 					{
0: 						decided = false;
0: 						overlap = true;
0: 					}
0: 					break;
0: 				}
0: 			}
0: 			if (decided)  // already decided if new row falls in front or behind
0: 				break;
0: 		}
0: 		/* If index row gets updated but key value didn't actually change, we still
0: 		 * put it in hash table because it can either fall in front or behind.  This
0: 		 * can happen if the update explicitly sets a value, but same as old.
0: 		 */
0: 		if (overlap && !decided)
0: 			placedForward = true;
0: 
0: 		if (placedForward)		// add it to hash table
0: 		{
0: 			/* determining initial capacity of hash table from a few factors:
0: 			 * (1) user specified MAX_MEMORY_PER_TABLE property, (2) min value 100
0: 			 * (3) optimizer estimated row count.  We want to avoid re-hashing if
0: 			 * possible, for performance reason, yet don't waste space.  If initial
0: 			 * capacity is greater than max size divided by load factor, no rehash
0: 			 * is ever needed.
0: 			 */
0: 			int maxCapacity = lcc.getOptimizerFactory().getMaxMemoryPerTable() / 16;
0: 			if (maxCapacity < 100)
0: 				maxCapacity = 100;
0: 
0: 			if (tableScan.past2FutureTbl == null)
0: 			{
0: 				double rowCount = tableScan.getEstimatedRowCount();
0: 				int initCapacity = 32 * 1024;
0: 				if (rowCount > 0.0)
0: 				{
0: 					rowCount = rowCount / 0.75 + 1.0;	// load factor
0: 					if (rowCount < initCapacity)
0: 						initCapacity = (int) rowCount;
0: 				}
0: 				if (maxCapacity < initCapacity)
0: 					initCapacity = maxCapacity;
0: 
0: 				tableScan.past2FutureTbl = new Hashtable(initCapacity);
0: 			}
0: 
0: 			Hashtable past2FutureTbl = tableScan.past2FutureTbl;
0: 			/* If hash table is not full, we add it in.  The key of the hash entry
0: 			 * is the string value of the RowLocation.  If the hash table is full,
0: 			 * as the comments above this function say, we scan forward.
0: 			 *
0: 			 * Need to save a clone because when we get cached currentRow, "rl" shares the
0: 			 * same reference, so is changed at the same time.
0: 			 */
0: 			RowLocation updatedRL = (RowLocation) rl.getClone();
0: 
0: 			if (past2FutureTbl.size() < maxCapacity)
0: 				past2FutureTbl.put(updatedRL, updatedRL);
0: 			else
0: 			{
0: 				tableScan.skipFutureRowHolder = true;
0: 				ExecRow rlRow = new ValueRow(1);
0: 
0: 				for (;;)
0: 				{
0: 					ExecRow aRow = tableScan.getNextRowCore();
0: 					if (aRow == null)
0: 					{
0: 						tableScan.sourceDrained = true;
0: 						tableScan.past2FutureTbl = null;	// de-reference for garbage coll.
0: 						break;
0: 					}
0: 					RowLocation rowLoc = (RowLocation) aRow.getColumn(aRow.nColumns());
0: 
0: 					if (updatedRL.equals(rowLoc))  //this row we are updating jumped forward
0: 					{
0: 						saveLastCusorKey(tableScan, aRow);
0: 						break;	// don't need to worry about adding this row to hash any more
0: 					}
0: 
0: 					if (tableScan.futureForUpdateRows == null)
0: 					{
0: 						// virtual memory heap. In-memory part size 100. With the co-operation
0: 						// of hash table and in-memory part of heap (hash table shrinks while
0: 						// in-memory heap grows), hopefully we never spill temp table to disk.
0: 
0: 						tableScan.futureForUpdateRows = new TemporaryRowHolderImpl
0: 							(tc, null, null, 100, false, true);
0: 					}
0: 
0: 					rlRow.setColumn(1, rowLoc);
0: 					tableScan.futureForUpdateRows.insert(rlRow);
0: 					if (past2FutureTbl.size() < maxCapacity) //we got space in the hash table now, stop!
0: 					{
0: 						past2FutureTbl.put(updatedRL, updatedRL);
0: 						saveLastCusorKey(tableScan, aRow);
0: 						break;
0: 					}
0: 				}
0: 				tableScan.skipFutureRowHolder = false;
0: 			}
0: 		}
0: 	}
0: 
0: 	private void saveLastCusorKey(TableScanResultSet tableScan, ExecRow aRow) throws StandardException
0: 	{
0: 		/* We save the most-forward cursor scan key where we are stopping, so
0: 		 * that next time when we decide if we need to put an updated row id into
0: 		 * hash table, we can compare with this key.  This is an optimization on
0: 		 * memory usage of the hash table, otherwise it may be "leaking".
0: 		 */
0: 		if (tableScan.lastCursorKey == null)
0: 			tableScan.lastCursorKey = new ValueRow(aRow.nColumns() - 1);
0: 		for (int i = 1; i <= tableScan.lastCursorKey.nColumns(); i++)
0: 		{
0: 			DataValueDescriptor aCol = aRow.getColumn(i);
0: 			if (aCol != null)
0: 				tableScan.lastCursorKey.setColumn(i, aCol.getClone());
0: 		}
0: 	}
0: 
0: 	void fireBeforeTriggers() throws StandardException
0: 	{
0: 		if (deferred)
0: 		{
0: 			if (triggerInfo != null)
0: 			{
0: 				if (triggerActivator == null)
0: 				{
0: 				triggerActivator = new TriggerEventActivator(lcc, 
0: 											tc, 
0: 											constants.targetUUID,
0: 											triggerInfo,
0: 											TriggerExecutionContext.UPDATE_EVENT,
0: 											activation, null);
0: 				}
0: 				else
0: 				{
0: 					triggerActivator.reopen();
0: 				}
0: 
0: 				// fire BEFORE trigger, do this before checking constraints
0: 				triggerActivator.notifyEvent(TriggerEvents.BEFORE_UPDATE, 
0: 												deletedRowHolder.getResultSet(),
0: 												insertedRowHolder.getResultSet());
0: 
0: 			}
0: 		}
0: 	}
0: 
0:     void fireAfterTriggers() throws StandardException
0: 	{
0: 		if (deferred)
0: 		{
0: 			if (triggerActivator != null)
0: 			{
0: 				triggerActivator.notifyEvent(TriggerEvents.AFTER_UPDATE, 
0: 										deletedRowHolder.getResultSet(),
0: 										insertedRowHolder.getResultSet());
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 
0: 	void updateDeferredRows() throws StandardException
0: 	{
0: 		if (deferred)
0: 		{
0: 			// we already have everything locked 
0: 			deferredBaseCC = 
0:                 tc.openCompiledConglomerate(
0:                     false,
0:                     tc.OPENMODE_FORUPDATE|tc.OPENMODE_SECONDARY_LOCKED,
0:                     lockMode,
0:                     TransactionController.ISOLATION_SERIALIZABLE,
0:                     constants.heapSCOCI,
0:                     heapDCOCI);
0: 			
0: 			CursorResultSet rs = insertedRowHolder.getResultSet();
0: 			try
0: 			{
0: 				/*
0: 				** We need to do a fetch doing a partial row
0: 				** read.  We need to shift our 1-based bit
0: 				** set to a zero based bit set like the store
0: 				** expects.
0: 				*/
0: 				FormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);
0: 				ExecRow deferredTempRow2;
0: 
0: 				rs.open();
0: 				while ((deferredTempRow2 = rs.getNextRow()) != null)
0: 				{
0: 					/*
0: 					** Check the constraint now if we have triggers.
0: 					** Otherwise we evaluated them as we read the
0: 					** rows in from the source.
0: 					*/
0: 					if (triggerInfo != null)
0: 					{
0: 						source.setCurrentRow(deferredTempRow);
0: 						evaluateCheckConstraints(checkGM, activation);
0: 					}
0: 
0: 					/* 
0: 					** The last column is a Ref, which contains a 
0: 					** RowLocation.
0: 					*/
0: 					DataValueDescriptor rlColumn = deferredTempRow2.getColumn(numberOfBaseColumns + 1);
0: 					RowLocation baseRowLocation = 
0: 							(RowLocation) (rlColumn).getObject();
0: 	
0: 					/* Get the base row at the given RowLocation */
0: 					boolean row_exists = 
0: 						deferredBaseCC.fetch(
0: 							baseRowLocation, deferredSparseRow.getRowArray(), 
0: 							readBitSet);
0: 
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						SanityManager.ASSERT(row_exists, "did not find base row in deferred update");
0: 					}
0: 	
0: 					/*
0: 					** Copy the columns from the temp row to the base row.
0: 					** The base row has fewer columns than the temp row,
0: 					** because it doesn't contain the row location.
0: 					*/
0: 					RowUtil.copyRefColumns(newBaseRow,
0: 											deferredTempRow2,
0: 											numberOfBaseColumns);
0: 
0: 					rowChanger.updateRow(deferredBaseRow,
0: 										newBaseRow,
0: 										baseRowLocation);
0: 				}
0: 			} finally
0: 			{
0: 				source.clearCurrentRow();
0: 				rs.close();
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	
0: 	void runChecker(boolean restrictCheckOnly) throws StandardException
0: 	{
0: 
0: 		/*
0: 		** For a deferred update, make sure that there
0: 		** aren't any primary keys that were removed which
0: 		** are referenced.  
0: 		*/
0: 		if (deferred && updatingReferencedKey)
0: 		{
0: 			ExecRow	deletedRow;
0: 			CursorResultSet deletedRows; 
0: 
0: 			/*
0: 			** For each referenced key that was modified
0: 			*/
0: 			for (int i = 0; i < fkInfoArray.length; i++)
0: 			{
0: 				if (fkInfoArray[i].type == FKInfo.FOREIGN_KEY)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				deletedRows = deletedRowHolder.getResultSet();
0: 				try
0: 				{
0: 					/*
0: 					** For each delete row
0: 					*/	
0: 					deletedRows.open();
0: 					while ((deletedRow = deletedRows.getNextRow()) != null)
0: 					{
0: 						if (!foundRow(deletedRow, 
0: 										fkInfoArray[i].colArray, 
0: 										insertedRowHolder))
0: 						{
0: 							riChecker.doRICheck(i, deletedRow, restrictCheckOnly);
0: 						}
0: 					}	
0: 				}
0: 				finally
0: 				{
0: 					deletedRows.close();
0: 				}
0: 			}
0: 		}
0: 
0: 		/*
0: 		** For a deferred update, make sure that there
0: 		** aren't any foreign keys that were added that
0:  		** aren't referenced.  
0: 		*/
0: 		if (deferred && updatingForeignKey)
0: 		{
0: 			ExecRow	insertedRow;
0: 			CursorResultSet insertedRows; 
0: 
0: 			/*
0: 			** For each foreign key that was modified
0: 			*/
0: 			for (int i = 0; i < fkInfoArray.length; i++)
0: 			{
0: 				if (fkInfoArray[i].type == FKInfo.REFERENCED_KEY)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				insertedRows = insertedRowHolder.getResultSet();
0: 				try
0: 				{
0: 					/*
0: 					** For each inserted row
0: 					*/	
0: 					insertedRows.open();
0: 					while ((insertedRow = insertedRows.getNextRow()) != null)
0: 					{
0: 						if (!foundRow(insertedRow, 
0: 										fkInfoArray[i].colArray, 
0: 										deletedRowHolder))
0: 						{
0: 							riChecker.doRICheck(i, insertedRow, restrictCheckOnly);
0: 						}
0: 					}	
0: 				}
0: 				finally
0: 				{
0: 					insertedRows.close();
0: 				}
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	public static boolean foundRow
0: 	(
0: 		ExecRow					checkRow, 
0: 		int[]					colsToCheck,
0: 		TemporaryRowHolderImpl	rowHolder
0: 	)
0: 		throws StandardException
0: 	{
0: 		ExecRow				scanRow;
0: 		boolean				foundMatch = false;
0: 		Object[] 			checkRowArray = checkRow.getRowArray();
0: 		DataValueDescriptor	checkCol;
0: 		DataValueDescriptor	scanCol;
0: 
0: 		CursorResultSet rs = rowHolder.getResultSet();
0: 		try
0: 		{	
0: 			/*
0: 			** For each inserted row
0: 			*/	
0: 			rs.open();
0: 			while ((scanRow = rs.getNextRow()) != null)
0: 			{
0: 				Object[] scanRowArray = scanRow.getRowArray();
0: 				int i;
0: 				for (i = 0; i < colsToCheck.length; i++)
0: 				{
0: 					checkCol = (DataValueDescriptor)checkRowArray[colsToCheck[i]-1];
0: 					scanCol = (DataValueDescriptor)scanRowArray[colsToCheck[i]-1];
0: 
0: 					BooleanDataValue result = checkCol.equals(
0: 											scanCol,
0: 											checkCol); // result
0: 					if (!result.getBoolean())
0: 					{
0: 						break;
0: 					}
0: 				}
0: 				if (i == colsToCheck.length)
0: 				{
0: 					foundMatch = true;
0: 					break;
0: 				}	
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			rs.close();
0: 		}
0: 		return foundMatch;
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see ResultSet#cleanUp
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	cleanUp() throws StandardException
0: 	{ 
0: 		numOpens = 0;
0: 
0: 		/* Close down the source ResultSet tree */
0: 		if (source != null)
0: 		{
0: 			source.close();
0: 			// cache source across open()s
0: 		}
0: 
0: 		if (triggerActivator != null)
0: 		{
0: 			triggerActivator.cleanup();
0: 			// cache triggerActivator across open()s
0: 		}
0: 
0: 		if (rowChanger != null)
0: 			rowChanger.close();
0: 
0: 		if (deferredBaseCC != null)
0: 			deferredBaseCC.close();
0: 		deferredBaseCC = null;
0: 
0: 		if (insertedRowHolder != null)
0: 		{
0: 			insertedRowHolder.close();
0: 		}
0: 	
0: 		if (deletedRowHolder != null)
0: 		{
0: 			deletedRowHolder.close();
0: 		}
0: 
0: 		if (riChecker != null)
0: 		{
0: 			riChecker.close();
0: 			// cache riChecker across open()s
0: 		}
0: 
0: 		super.close();
0: 
0: 		endTime = getCurrentTimeMillis();
0: 	}
0: 
0:     /**
0:      * Decode the update lock mode.
0:      * <p>
0:      * The value for update lock mode is in the 2nd 2 bytes for 
0:      * ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL isolation level.  Otherwise
0:      * (REPEATABLE READ, READ COMMITTED, and READ UNCOMMITTED) the lock mode is
0:      * located in the first 2 bytes.
0:      * <p>
0:      * This is done to override the optimizer choice to provide maximum 
0:      * concurrency of record level locking except in SERIALIZABLE where table
0:      * level locking is required in heap scans for correctness.
0:      * <p>
0:      * See Compilation!QueryTree!FromBaseTable for encoding of the lockmode.
0:      * <p>
0:      *
0: 	 * @return The lock mode (record or table) to use to open the result set.
0:      *
0:      * @param lcc       The context to look for current isolation level.
0:      * @param lockMode  The compiled encoded lock mode for this query.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected static int decodeLockMode(
0:     LanguageConnectionContext   lcc, 
0:     int                         lockMode)
0: 	{
0: 		if ((lockMode >>> 16) != 0)
0: 		{
0:             // Note that isolation level encoding from 
0:             // getCurrentIsolationLevel() returns 
0:             // ExecutionContext.*ISOLATION_LEVEL constants, not 
0:             // TransactionController.ISOLATION* constants.
0: 
0: 			int isolationLevel = lcc.getCurrentIsolationLevel();
0: 
0:             if (isolationLevel != ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
0:             {
0: 				lockMode = lockMode & 0xff;
0:             }
0:             else
0:             {
0: 				lockMode = lockMode >>> 16;
0:             }
0: 		}
0: 		return lockMode;
0: 	}
0: 
0: 	
0: 	void rowChangerFinish() throws StandardException
0: 	{
0: 		rowChanger.finish();
0: 	}
0: 
0: }
============================================================================