1:c774a1c: /*
20:c774a1c: 
1:c774a1c:    Derby - Class 
1:c774a1c:        org.apache.derbyTesting.functionTests.tests.jdbcapi.AuthenticationTest
1:c774a1c: 
1:c774a1c:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c774a1c:    contributor license agreements.  See the NOTICE file distributed with
1:c774a1c:    this work for additional information regarding copyright ownership.
1:c774a1c:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c774a1c:    (the "License"); you may not use this file except in compliance with
1:c774a1c:    the License.  You may obtain a copy of the License at
1:c774a1c: 
1:c774a1c:       http://www.apache.org/licenses/LICENSE-2.0
1:c774a1c: 
1:c774a1c:    Unless required by applicable law or agreed to in writing, software
1:c774a1c:    distributed under the License is distributed on an "AS IS" BASIS,
1:c774a1c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c774a1c:    See the License for the specific language governing permissions and
1:c774a1c:    limitations under the License.
1:c774a1c: 
1:c774a1c:  */
1:c774a1c: 
1:c774a1c: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:c774a1c: 
1:1eee305: import java.security.MessageDigest;
1:1eee305: import java.security.NoSuchAlgorithmException;
1:c774a1c: import java.sql.CallableStatement;
1:c774a1c: import java.sql.Connection;
1:72b93c5: import java.sql.PreparedStatement;
1:c774a1c: import java.sql.ResultSet;
1:c774a1c: import java.sql.SQLException;
1:c774a1c: import java.sql.Statement;
1:60edeb0: import java.util.HashSet;
1:2bbaf40: import java.util.Locale;
1:c774a1c: import java.util.Properties;
1:c774a1c: import javax.sql.DataSource;
1:c774a1c: import junit.framework.Test;
1:c774a1c: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:c774a1c: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:c774a1c: import org.apache.derbyTesting.junit.JDBC;
1:c774a1c: import org.apache.derbyTesting.junit.JDBCDataSource;
1:1b46090: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:c774a1c: import org.apache.derbyTesting.junit.TestConfiguration;
1:60edeb0: 
1:f178a86: /**
1:f178a86:  * Tests authentication and connection level authorization.
1:f178a86:  *
1:f178a86:  */
1:c774a1c: public class AuthenticationTest extends BaseJDBCTestCase {
1:c774a1c: 
1:f178a86:     private static final String PASSWORD_SUFFIX = "suf2ix";
1:f178a86:     private static final String USERS[] = 
1:2bbaf40:         {"APP","dan","kreg","jeff","ames","jerry","francois","jamie","howardR",
1:9fbf2cb:         "\"eVe\"","\"fred@derby.com\"", "\"123\"" };
1:c774a1c: 
1:f178a86:     private static final String zeus = "\u0396\u0395\u03A5\u03A3";
1:f178a86:     private static final String apollo = "\u0391\u09A0\u039F\u039B\u039B\u039A\u0390";
1:60edeb0: 
1:60edeb0:     private static final String BUILTIN_ALGO_PROP =
1:60edeb0:             "derby.authentication.builtin.algorithm";
1:60edeb0: 
1:1ede0a8:     private static final String BUILTIN_SALT_LENGTH_PROP =
1:1ede0a8:             "derby.authentication.builtin.saltLength";
1:1ede0a8: 
1:1ede0a8:     private static final String BUILTIN_ITERATIONS_PROP =
1:1ede0a8:             "derby.authentication.builtin.iterations";
1:1ede0a8: 
1:60edeb0:     private static final String USER_PREFIX = "derby.user.";
1:60edeb0: 
1:60edeb0:     private static final String NO_SUCH_ALGO = "XBCXW";
1:c774a1c:     
1:c774a1c:     /** Creates a new instance of the Test */
1:c774a1c:     public AuthenticationTest(String name) {
1:c774a1c:         super(name);
37:c774a1c:     }
1:006b542: 
1:006b542:     /**
1:f178a86:      * Ensure all connections are not in auto commit mode.
1:c774a1c:      */
1:f178a86:     protected void initializeConnection(Connection conn) throws SQLException {
1:f178a86:         conn.setAutoCommit(false);
1:c774a1c:     }
1:c33061f: 
1:c774a1c:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("AuthenticationTest");
1:c774a1c:         suite.addTest(baseSuite("AuthenticationTest:embedded"));
1:9174d61:         suite.addTest(TestConfiguration.clientServerDecorator(
1:c774a1c:                 baseSuite("AuthenticationTest:client")));
1:c774a1c:         return suite;
1:1b46090:     }
1:c774a1c:     
1:c774a1c:     public static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("AuthenticationTest");
1:4c5c16b:         
1:1b46090:         Test test = new AuthenticationTest(
1:1b46090:             "testConnectShutdownAuthentication");
1:1b46090:         setBaseProps(suite, test);
1:c774a1c:         
1:2bbaf40:         test = new AuthenticationTest("testUserCasing");
1:2bbaf40:         setBaseProps(suite, test);
1:2bbaf40:         
1:c774a1c:         test = new AuthenticationTest("testUserFunctions");
1:1b46090:         setBaseProps(suite, test);
1:c774a1c: 
1:c774a1c:         test = new AuthenticationTest("testNotFullAccessUsers");
1:1b46090:         setBaseProps(suite, test);
1:c774a1c:         
1:9cf7d23:         test = new AuthenticationTest("testUserAccessRoutines");
1:9cf7d23:         setBaseProps(suite, test);
1:9cf7d23:         
1:c774a1c:         test = new AuthenticationTest(
1:c774a1c:             "testChangePasswordAndDatabasePropertiesOnly");
1:1b46090:         setBaseProps(suite, test);
1:c774a1c: 
1:c774a1c:         // only part of this fixture runs with network server / client
1:c774a1c:         test = new AuthenticationTest("testGreekCharacters");
1:1b46090:         setBaseProps(suite, test);
1:1b46090: 
1:1b46090:         test = new AuthenticationTest("testSystemShutdown");
1:1b46090:         setBaseProps(suite, test);
1:60edeb0: 
1:8c305e2:         test = new AuthenticationTest("testDefaultHashAlgorithm");
1:8c305e2:         setBaseProps(suite, test);
1:8c305e2: 
1:006b542:         test = new AuthenticationTest("testDerby5507PlaintextPassword");
1:006b542:         setBaseProps(suite, test);
1:006b542: 
1:60edeb0:         // The test cases below test the configurable hash authentication
1:60edeb0:         // mechanism added in DERBY-4483. Set the property that specifies the
1:60edeb0:         // hash algorithm to some valid value for these tests. Not all tests
1:60edeb0:         // depend on the property being set prior to their invocation, but by
1:60edeb0:         // setting it in a decorator we ensure that it will be automatically
1:60edeb0:         // cleared on tear down, so that it will be safe for all of these tests
1:60edeb0:         // to change the property without worrying about resetting it later.
1:60edeb0:         Properties confHashProps = new Properties();
1:60edeb0:         confHashProps.setProperty(BUILTIN_ALGO_PROP, "MD5");
1:60edeb0: 
1:60edeb0:         test = new AuthenticationTest("testVariousBuiltinAlgorithms");
1:60edeb0:         setBaseProps(suite, test, confHashProps);
1:c774a1c:         
1:60edeb0:         test = new AuthenticationTest("testNoCollisionsWithConfigurableHash");
1:60edeb0:         setBaseProps(suite, test, confHashProps);
1:60edeb0: 
1:60edeb0:         test = new AuthenticationTest("testInvalidAlgorithmName");
1:60edeb0:         setBaseProps(suite, test, confHashProps);
1:60edeb0: 
1:c774a1c:         // This test needs to run in a new single use database as we're setting
1:c774a1c:         // a number of properties
1:c774a1c:         return TestConfiguration.singleUseDatabaseDecorator(suite);
1:c774a1c:     }
1:1b46090:     
1:1ae02c9:     protected static void setBaseProps(BaseTestSuite suite, Test test)
1:2bbaf40:     {
1:60edeb0:         setBaseProps(suite, test, null);
1:60edeb0:     }
1:60edeb0: 
1:60edeb0:     private static void setBaseProps(
1:1ae02c9:             BaseTestSuite suite, Test test, Properties extraDbProps)
1:60edeb0:     {
1:1b46090:         // Use DatabasePropertyTestSetup.builtinAuthentication decorator
1:1b46090:         // to set the user properties required by this test (and shutdown 
1:1b46090:         // the database for the property to take effect).
1:1b46090:         // DatabasePropertyTestSetup uses SYSCS_SET_DATABASE_PROPERTY
1:1b46090:         // so that is database level setting.
1:1b46090:         // Additionally use DatabasePropertyTestSetup to add some
1:1b46090:         // possibly useful settings
1:1b46090:         // Finally SystemPropertyTestSetup sets up system level users
1:f178a86:         Properties props = new Properties();
1:1b46090:         props.setProperty("derby.infolog.append", "true");
1:1b46090:         props.setProperty("derby.debug.true", "AuthenticationTrace");
1:60edeb0: 
1:60edeb0:         if (extraDbProps != null) {
1:60edeb0:             props.putAll(extraDbProps);
1:60edeb0:         }
1:60edeb0: 
1:f178a86:         Properties sysprops = new Properties();
1:1b46090:         sysprops.put("derby.user.system", "admin");
1:1b46090:         sysprops.put("derby.user.mickey", "mouse");
1:1b46090:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
1:1b46090:             USERS, PASSWORD_SUFFIX);
1:1b46090:         test = new DatabasePropertyTestSetup (test, props, true);
1:1b46090:         suite.addTest(new SystemPropertyTestSetup (test, sysprops));
1:1b46090:     }
1:1b46090:     
1:9fbf2cb:     protected void setUp() throws Exception {
1:9fbf2cb:         
1:9fbf2cb:         setDatabaseProperty("derby.database.defaultConnectionMode",
1:9fbf2cb:                 null, getConnection());
1:9fbf2cb:         setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:9fbf2cb:                 null, getConnection());
1:9fbf2cb:         setDatabaseProperty("derby.database.fullAccessUsers",
1:9fbf2cb:                 null, getConnection());
1:9fbf2cb:         
1:9fbf2cb:         commit();
1:9fbf2cb:         
1:9fbf2cb:     }
1:9fbf2cb:     
1:9fbf2cb:     protected void tearDown() throws Exception {
1:9fbf2cb:         removeSystemProperty("derby.connection.requireAuthentication");
1:9fbf2cb:         removeSystemProperty("derby.user." +apollo);
1:1b46090:         super.tearDown();
1:1b46090:     }
1:2bbaf40:     
1:2bbaf40:     /**
1:2bbaf40:      * Test how user names behave with casing.
1:2bbaf40:      * @throws SQLException
1:2bbaf40:      */
1:2bbaf40:     public void testUserCasing() throws SQLException
1:2bbaf40:     {
1:2bbaf40:         for (int i = 0; i < USERS.length; i++)
1:2bbaf40:         {          
1:2bbaf40:             String jdbcUserName = USERS[i];
1:2bbaf40:             boolean delimited = jdbcUserName.charAt(0) == '"';
1:2bbaf40:             String normalUserName;
1:2bbaf40:             if (delimited)
1:2bbaf40:             {
1:2bbaf40:                 normalUserName = jdbcUserName.substring(1,
1:2bbaf40:                         jdbcUserName.length() - 1);          
1:2bbaf40:             }
1:2bbaf40:             else
1:2bbaf40:             {
1:2bbaf40:                 normalUserName = jdbcUserName.toUpperCase(Locale.ENGLISH);
1:2bbaf40:             }
1:2bbaf40:              
1:2bbaf40:             String password = USERS[i] + PASSWORD_SUFFIX;
1:2bbaf40:             
1:2bbaf40:             userCasingTest(jdbcUserName, normalUserName, password);
1:2bbaf40:             
1:2bbaf40:             if (!delimited)
1:2bbaf40:             {
1:2bbaf40: 
1:2bbaf40:                 if (!normalUserName.equals(jdbcUserName))
1:2bbaf40:                 {
1:2bbaf40:                     // Test connecting via the normalized name
1:2bbaf40:                     // but only if it wasn't already tested.
1:2bbaf40:                     // E.g. connect as "DAN" for user DAN as opposed
1:2bbaf40:                     // to the user being defined as dan (regular identifier).
1:2bbaf40:                     
1:2bbaf40:                     // DERBY-3150 disable this test until bug is fixed.
1:2bbaf40:                     //userCasingTest(normalUserName, normalUserName, password);
1:2bbaf40:                 }
1:2bbaf40:                 
1:2bbaf40:                 // Test with the normalized name quoted as a delimited identifer.
1:2bbaf40:                 // E.g. connect as "DAN" for user DAN
1:2bbaf40:                 
1:2bbaf40:                 // DERBY-3150 disable this test until bug is fixed.
1:2bbaf40:                 // userCasingTest("\"" + normalUserName + "\"",
1:2bbaf40:                 //        normalUserName, password);
1:2bbaf40:             }
1:2bbaf40:             
1:2bbaf40:         }
1:2bbaf40:         
1:c33061f:         // Now test that setting the user connection authorizaton
1:c33061f:         // with the various names works correctly. Use the first user
1:c33061f:         // to set the access on others to avoid setting a user to read-only
1:c33061f:         // and then not being able to reset it.
1:c33061f:         
1:c33061f:         PreparedStatement psGetAccess = prepareStatement(
1:c33061f:             "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
1:c33061f:         CallableStatement csSetAccess = prepareCall(
1:c33061f:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)"); 
1:c33061f:         
1:c33061f:         setDatabaseProperty("derby.database.fullAccessUsers",
1:c33061f:                 USERS[0], getConnection());
1:c33061f:         setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:c33061f:                 null, getConnection());
1:c33061f:         commit();
1:c33061f:         
1:c33061f:         // Yes - skip the first user, see above.
1:c33061f:         for (int i = 1; i < USERS.length; i++)
1:c33061f:         {          
1:c33061f:             String jdbcUserName = USERS[i];
1:bbba1c7:             
1:c33061f:             boolean delimited = jdbcUserName.charAt(0) == '"';
1:c33061f:             String normalUserName;
1:c33061f:             if (delimited)
1:c33061f:             {
1:c33061f:                 normalUserName = jdbcUserName.substring(1,
1:c33061f:                         jdbcUserName.length() - 1);          
1:c33061f:             }
1:c33061f:             else
1:c33061f:             {
1:c33061f:                 normalUserName = jdbcUserName.toUpperCase(Locale.ENGLISH);
1:c33061f:             }
1:c33061f:              
1:c33061f:             String password = USERS[i] + PASSWORD_SUFFIX;
1:c33061f:             
1:c33061f:             // Set the access with the database property
1:c33061f:             setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:c33061f:                     jdbcUserName, getConnection());
1:c33061f:             commit();
1:c33061f:             
1:c33061f:             
1:c33061f:             Connection connUser = openDefaultConnection(jdbcUserName, password);
1:c33061f:             
1:c33061f:             // DERBY-2738 (network client always returns false for isReadOnly)
1:c33061f:             if (usingEmbedded())
1:c33061f:                 assertTrue(jdbcUserName + ":isReadOnly()",
1:c33061f:                     connUser.isReadOnly());
1:c33061f:             
1:c33061f:             
1:c33061f:             connUser.close();
1:c33061f:             
1:c33061f:             psGetAccess.setString(1, normalUserName);
1:bbba1c7:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:bbba1c7:                     "READONLYACCESS");
1:c33061f:             commit();
1:c33061f:             
1:c33061f:             // clear the property.
1:c33061f:             setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:c33061f:                     null, getConnection());
1:c33061f:             commit();
1:c33061f:             
1:c33061f:             // Test it was reset back
1:c33061f:             connUser = openDefaultConnection(jdbcUserName, password);
1:c33061f:             assertFalse(connUser.isReadOnly());
1:c33061f:             connUser.close(); 
1:c33061f:             
1:c33061f:             psGetAccess.setString(1, normalUserName);
1:bbba1c7:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:bbba1c7:                     "FULLACCESS");
1:c33061f:             commit();
1:c33061f:             
1:c33061f:             
1:c33061f:             // Set to be read-only via the procedure which uses
1:c33061f:             // the normal user name.
1:c33061f:             csSetAccess.setString(1, normalUserName);
1:c33061f:             csSetAccess.setString(2, "READONLYACCESS");
1:c33061f:             csSetAccess.executeUpdate();
1:c33061f:             commit();
1:c33061f:             
1:c33061f:             connUser = openDefaultConnection(jdbcUserName, password);
1:c33061f:             // DERBY-2738 (network client always returns false for isReadOnly)
1:c33061f:             if (usingEmbedded())
1:c33061f:                 assertTrue(jdbcUserName + ":isReadOnly()",
1:c33061f:                     connUser.isReadOnly());
1:c33061f: 
1:c33061f:             connUser.close();
1:c33061f:             
1:c33061f:             psGetAccess.setString(1, normalUserName);
1:bbba1c7:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:bbba1c7:                     "READONLYACCESS");
1:c33061f:             commit();           
1:c33061f: 
1:c33061f:         }
1:2bbaf40:     }
1:1b46090:     
1:2bbaf40:     /**
1:2bbaf40:      * Test the user casing obtaining connections a variety of ways.
1:2bbaf40:      * @param jdbcUserName User name to be used to obtain the connection via JDBC
1:2bbaf40:      * @param normalUserName Normalized form of the user connection.
1:2bbaf40:      * @param password Password for the user.
1:2bbaf40:      * @throws SQLException
1:2bbaf40:      */
1:2bbaf40:     private void userCasingTest(String jdbcUserName, String normalUserName,
1:2bbaf40:             String password) throws SQLException
1:2bbaf40:     {
1:2bbaf40:         // Default test mechanism to get a connection.
1:2bbaf40:         userCasingTest(jdbcUserName, normalUserName,
1:2bbaf40:                 openDefaultConnection(jdbcUserName, password));
1:2bbaf40:         
1:2bbaf40:         
1:2bbaf40:         DataSource ds = JDBCDataSource.getDataSource();
1:2bbaf40:         
1:2bbaf40:         // DataSource using explict user
1:2bbaf40:         userCasingTest(jdbcUserName, normalUserName,
1:2bbaf40:                 ds.getConnection(jdbcUserName, password));
1:2bbaf40:         
1:2bbaf40:         JDBCDataSource.setBeanProperty(ds, "user", jdbcUserName);
1:2bbaf40:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:2bbaf40:         userCasingTest(jdbcUserName, normalUserName,
1:2bbaf40:                 ds.getConnection());        
1:2bbaf40:     }
1:2bbaf40:     
1:2bbaf40:     /**
1:2bbaf40:      * 
1:2bbaf40:      * @param jdbcUserName User name as passed into the JDBC connection request.
1:2bbaf40:      * @param normalUserName Normalized user name.
1:2bbaf40:      * @param connUser Connection for the user, closed by this method.
1:2bbaf40:      * @throws SQLException 
1:2bbaf40:      */
1:2bbaf40:     private void userCasingTest(String jdbcUserName, String normalUserName,
1:2bbaf40:             Connection connUser) throws SQLException
1:ce018f3:     {        
1:2bbaf40:         assertNormalUserName(normalUserName, connUser);
1:2bbaf40:         
1:3b5204b:         // DatabaseMetaData.getUserName() returns the user name used
1:3b5204b:         // to make the request via JDBC.
1:3b5204b:         assertEquals("DatabaseMetaData.getUserName()",
1:ce018f3:                 jdbcUserName, connUser.getMetaData().getUserName());
1:ce018f3:         
1:ce018f3:         
1:ce018f3:         Statement s = connUser.createStatement();
1:ce018f3:           
1:ce018f3:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(" +
1:ce018f3:                 "CURRENT_USER, 'FULLACCESS')");
1:ce018f3:         
1:ce018f3:         s.close();
1:3b5204b:         
1:2bbaf40:         JDBC.cleanup(connUser);
1:2bbaf40:     }
1:2bbaf40:     
1:2bbaf40:     /**
1:2bbaf40:      * Assert that the user name returned by various mechanisms
1:2bbaf40:      * matches the normal user name.
1:2bbaf40:      * @param normalUserName
1:288915e:      * @param connUser
1:2bbaf40:      * @throws SQLException
1:2bbaf40:      */
1:2bbaf40:     private void assertNormalUserName(String normalUserName, Connection connUser)
1:2bbaf40:         throws SQLException
1:3b5204b:     {      
1:2bbaf40:         Statement s = connUser.createStatement();
1:2bbaf40:         
1:2bbaf40:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES CURRENT_USER"),
1:2bbaf40:                 normalUserName);
1:2bbaf40:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES SESSION_USER"),
1:2bbaf40:                 normalUserName);
1:2bbaf40:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES {fn user()}"),
1:2bbaf40:                 normalUserName);
1:2bbaf40:         s.close();
1:2bbaf40:         
1:2bbaf40:     }
1:2bbaf40: 
1:c774a1c:     
1:c774a1c:     // roughly based on old functionTests test users.sql, except that
1:c774a1c:     // test used 2 databases. Possibly that was on the off-chance that
1:c774a1c:     // a second database would not work correctly - but that will not
1:c774a1c:     // be tested now.
1:c774a1c:     public void testConnectShutdownAuthentication() throws SQLException {
1:c774a1c:         
1:c774a1c:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:c774a1c:         
1:c774a1c:         // check connections while fullAccess (default) is set
1:c774a1c:         // note that builtinAuthentication has been set, as well as
1:c774a1c:         // authentication=true.
1:c774a1c:         
1:c774a1c:         // first try connection without user password
1:c774a1c:         assertConnectionFail(dbName);
1:c774a1c:         assertConnectionOK(dbName, "system", ("admin"));
1:c774a1c:         assertConnectionWOUPOK(dbName, "system", ("admin"));
1:c774a1c:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         assertConnectionWOUPOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:ca5edbb:         // try shutdown as non-owner
1:ca5edbb:         assertShutdownOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:ca5edbb:         assertConnectionOK(dbName, "system", ("admin"));
1:ca5edbb:         assertShutdownWOUPOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:ca5edbb:         assertConnectionOK(dbName, "system", ("admin"));
1:ca5edbb:         assertShutdownOK(dbName, "system", "admin");
1:ca5edbb:         assertConnectionOK(dbName, "system", ("admin"));
1:ca5edbb:         assertShutdownWOUPOK(dbName, "system", "admin");
1:ca5edbb:         assertConnectionOK(dbName, "system", ("admin"));
1:ca5edbb:         // try shutdown as owner
1:14ed86a:         assertShutdownUsingConnAttrsOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:c774a1c:         
1:c774a1c:         // ensure that a password is encrypted
1:c774a1c:         Connection conn1 = openDefaultConnection(
1:c774a1c:             "dan", ("dan" + PASSWORD_SUFFIX));
3:c774a1c:         Statement stmt = conn1.createStatement();
1:c774a1c:         ResultSet rs = stmt.executeQuery(
1:c774a1c:             "values SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.user.dan')");
1:c774a1c:         rs.next();
1:c774a1c:         assertNotSame(("dan"+PASSWORD_SUFFIX), rs.getString(1));
3:c774a1c:         conn1.commit();
2:c774a1c:         conn1.close();
1:c774a1c: 
1:c774a1c:         // specify full-access users.
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.fullAccessUsers", 
1:c774a1c:             "APP,system,nomen,francois,jeff", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:c774a1c:         conn1.commit();
1:f178a86:         conn1.close();
1:c774a1c: 
1:c774a1c:         // check the system wide user
1:c774a1c:         assertConnectionOK(dbName, "system", "admin"); 
1:c774a1c:         // check the non-existent, but allowed user
1:c774a1c:         assertConnectionFail("08004", dbName, "nomen", "nescio");
1:c774a1c:         assertConnectionWOUPFail("08004", dbName, "nomen", "nescio");
1:ca5edbb:         // attempt to shutdown db as one of the allowed users, but not db owner
1:ca5edbb:         assertShutdownOK(dbName, "francois", ("francois" + PASSWORD_SUFFIX));
1:ca5edbb:         // attempt shutdown as db owner
1:ca5edbb:         assertConnectionOK(dbName, "system", "admin");
1:c774a1c:         assertShutdownWOUPOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:c774a1c:         // check simple connect ok as another allowed user, also revive db
1:c774a1c:         assertConnectionOK(dbName, "jeff", ("jeff" + PASSWORD_SUFFIX));
1:c774a1c:         // but dan wasn't on the list
1:8f3b0b9:         assertConnectionFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:8f3b0b9:         assertShutdownFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c: 
1:c774a1c:         // now change fullAccessUsers & test again
1:c774a1c:         conn1 = 
1:c774a1c:             openDefaultConnection("francois", ("francois" + PASSWORD_SUFFIX));
2:c774a1c:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:c774a1c:             "jeff,dan,francois,jamie", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         conn1.close();
1:ca5edbb:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:ca5edbb:         assertShutdownOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX)); 
1:ca5edbb:          // but dbo was not on list...
1:8f3b0b9:         assertShutdownFail("08004", dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:c774a1c:         // now add dbo back in...
1:c774a1c:         conn1 = openDefaultConnection("francois", ("francois" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.fullAccessUsers", 
1:c774a1c:             "APP,jeff,dan,francois,jamie", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         conn1.close();
1:c774a1c: 
1:c774a1c:         // Invalid logins
1:c774a1c:         // bad user
1:c774a1c:         assertConnectionFail("08004", dbName, "badUser", "badPwd");
1:c774a1c:         // just checking that it's still not working if we try again
1:c774a1c:         assertConnectionFail("08004", dbName, "badUser", "badPwd");
1:c774a1c:         // system is not on the list...
1:8f3b0b9:         assertConnectionFail("08004", dbName, "system", "admin");
1:c774a1c:         // dan's on the list, but this isn't the pwd
1:c774a1c:         assertConnectionFail("08004", dbName, "dan", "badPwd");
1:c774a1c:         assertConnectionFail("08004", dbName, "jamie", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         // check some shutdowns
1:8f3b0b9:         assertShutdownFail("08004", dbName, "system", "admin");
1:c774a1c:         assertShutdownFail("08004", dbName, "badUser", "badPwd");
1:c774a1c:         assertShutdownFail("08004", dbName, "dan", "badPwd");
1:c774a1c:         assertShutdownFail("08004", dbName, "badUser", ("dan" + PASSWORD_SUFFIX));
1:1b46090: 
1:1b46090:         // try some system shutdowns. Note, that all these work, because
1:1b46090:         // we have not set require authentication at system level.
1:1b46090:         // try system shutdown with wrong user - should work
1:1b46090:         assertSystemShutdownOK("", "badUser", ("dan" + PASSWORD_SUFFIX));
1:f178a86:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:1b46090:         // with 'allowed' user but bad pwd - will succeed
1:1b46090:         assertSystemShutdownOK("", "dan", ("jeff" + PASSWORD_SUFFIX));
1:f178a86:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:1b46090:         // dbo, but bad pwd - will succeed
1:1b46090:         assertSystemShutdownOK("", "APP", ("POO"));
1:f178a86:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:1b46090:         // allowed user but not dbo - will also succeed
1:1b46090:         assertSystemShutdownOK("", "dan", ("dan" + PASSWORD_SUFFIX));
1:f178a86:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:c774a1c:         // expect Derby system shutdown, which gives XJ015 error.
1:c774a1c:         assertSystemShutdownOK("", "APP", ("APP" + PASSWORD_SUFFIX));
1:1b46090: 
1:c774a1c:         // so far so good. set back security properties
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.connection.requireAuthentication","false", conn1);
1:c774a1c:         conn1.commit();
2:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:1b46090:     }
1:f178a86: 
1:c774a1c:     // Experiment using USER, CURRENT_USER, etc.
1:c774a1c:     // also tests actual write activity
1:c774a1c:     public void testUserFunctions() throws SQLException
1:2bbaf40:     {
1:c774a1c:         // use valid user/pwd to set the full accessusers.
1:c774a1c:         Connection conn1 = openDefaultConnection(
1:c774a1c:             "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.fullAccessUsers", 
1:c774a1c:             "francois,jeff,ames,jerry,jamie,dan,system", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:c774a1c:         conn1.commit();
1:7206fbc: 
1:c774a1c:         // we should still be connected as dan
1:c774a1c:         Statement stmt = conn1.createStatement();
2:c774a1c:         assertUpdateCount(stmt, 0, 
1:c774a1c:             "create table APP.t1(c1 varchar(30) check (UPPER(c1) <> 'JAMIE'))");
2:c774a1c:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:9cf7d23:       
1:f178a86:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c: 
1:c774a1c:         useUserValue(1, "jeff", "insert into APP.t1 values CURRENT_USER");
1:c774a1c:         useUserValue(1, "ames", "insert into APP.t1 values SESSION_USER");
1:c774a1c:         useUserValue(1, "jerry", "insert into APP.t1 values {fn user()}");
1:c774a1c:         assertUserValue(new String[] {"DAN","JEFF","AMES","JERRY"},
1:c774a1c:             "dan", "select * from APP.t1");
1:c774a1c:         // attempt some usage in where clause
1:c774a1c:         useUserValue(1,
1:c774a1c:             "dan", "update APP.t1 set c1 = 'edward' where c1 = USER");
1:c774a1c:         assertUserValue(new String[] {"JEFF"},"jeff",
2:c774a1c:             "select * from APP.t1 where c1 like CURRENT_USER");
1:c774a1c:         useUserValue(1, "ames", 
1:c774a1c:             "update APP.t1 set c1 = 'sema' where SESSION_USER = c1");
1:c774a1c:         useUserValue(1, "jerry", 
1:c774a1c:             "update APP.t1 set c1 = 'yrrej' where c1 like {fn user()}");
1:c774a1c:         assertUserValue(new String[] {"edward","JEFF","sema","yrrej"},
1:c774a1c:             "dan", "select * from APP.t1");
1:c774a1c:         useUserValue(4, "francois", "update APP.T1 set c1 = USER");
1:c774a1c:         assertUserValue(
1:c774a1c:             new String[] {"FRANCOIS","FRANCOIS","FRANCOIS","FRANCOIS"},
1:c774a1c:             "dan", "select * from APP.t1");
1:c774a1c: 
1:c774a1c:         // check that attempt to insert 'jamie' gives a check violation
1:c774a1c:         conn1 = openDefaultConnection("jamie", ("jamie" + PASSWORD_SUFFIX));
1:b005ffa:         stmt = conn1.createStatement();
1:1b46090:         try {
1:c774a1c:             stmt.execute("insert into APP.t1 values CURRENT_USER");
1:c774a1c:         } catch (SQLException sqle) {
1:c774a1c:             assertSQLState("23513", sqle);
1:1b46090:         }
1:c774a1c:         stmt.close();
1:f178a86:         conn1.rollback();
1:c774a1c:         conn1.close();
1:c774a1c: 
1:c774a1c:         // Note: there is not much point in attempting to write with an invalid
1:c774a1c:         // user, that's already tested in the testConnectionShutdown fixture
1:c774a1c: 
1:c774a1c:         // reset
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.connection.requireAuthentication","false", conn1);
1:c774a1c:         stmt = conn1.createStatement();
1:c774a1c:         assertUpdateCount(stmt, 0, "drop table APP.t1");
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:1b46090:     }
1:c774a1c: 
1:c774a1c:     public void testChangePasswordAndDatabasePropertiesOnly() 
1:c774a1c:     throws SQLException
1:1b46090:     {
1:c774a1c:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:c774a1c: 
1:c774a1c:         // use valid user/pwd to set the full accessusers.
1:c774a1c:         Connection conn1 = openDefaultConnection(
1:c774a1c:             "dan", ("dan" + PASSWORD_SUFFIX));
1:9cf7d23:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:c774a1c:             "dan,jeff,system", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:                 "derby.database.requireAuthentication","true", conn1);
1:0d4b400:         
1:c774a1c:         conn1.commit();
1:72b93c5:         
1:c774a1c:         // check the system wide user
1:c774a1c:         assertConnectionOK(dbName, "system", "admin"); 
1:c774a1c:         assertConnectionFail("08004", dbName, "system", "otherSysPwd");
1:c774a1c:         assertConnectionOK(dbName, "jeff", ("jeff" + PASSWORD_SUFFIX));
1:c774a1c:         assertConnectionFail("08004", dbName, "jeff", "otherPwd");
1:c774a1c:         setDatabaseProperty("derby.user.jeff", "otherPwd", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         // should have changed ok.
1:c774a1c:         assertConnectionOK(dbName, "jeff", "otherPwd");
1:c774a1c: 
1:c774a1c:         // note: if we do this:
1:c774a1c:         //  setDatabaseProperty("derby.user.system", "scndSysPwd", conn1);
1:c774a1c:         //  conn1.commit();
1:c774a1c:         // i.e. adding the same user (but different pwd) at database level,
1:c774a1c:         // then we cannot connect anymore using that user name, not with
1:c774a1c:         // either password.
1:c774a1c: 
1:c774a1c:         // force database props only
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.propertiesOnly","true", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         
1:c774a1c:         // now, should not be able to logon as system user
1:c774a1c:         assertConnectionFail("08004", dbName, "system", "admin");
1:c774a1c: 
1:c774a1c:         // reset propertiesOnly
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.propertiesOnly","false", conn1);
1:c774a1c:         conn1.commit();
1:f178a86:         conn1.close();
1:c774a1c:         assertConnectionOK(dbName, "system", "admin");
1:c774a1c:         
1:c774a1c:         // try changing system's pwd
1:f178a86:         setSystemProperty("derby.user.system", "thrdSysPwd");
1:c774a1c: 
1:c774a1c:         // can we get in as system user with changed pwd
1:c774a1c:         assertConnectionOK(dbName, "system", "thrdSysPwd");
1:c774a1c:         
1:c774a1c:         // reset
1:c774a1c:         // first change system's pwd back
1:f178a86:         setSystemProperty("derby.user.system", "admin");
1:f178a86: 
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.connection.requireAuthentication","false", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:                 "derby.database.propertiesOnly","false", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         conn1.close();
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     public void testNotFullAccessUsers() throws SQLException
1:1b46090:     {
1:c774a1c:         // use valid user/pwd to set the full accessusers.
1:c774a1c:         Connection conn1 = openDefaultConnection(
1:c774a1c:             "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         
1:7206fbc:         // Test duplicates on the list of users
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:7206fbc:                     "dan,jamie,dan", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:7206fbc:                     "dan,jamie,DaN", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:7206fbc:                     "dan,jamie,\"DAN\"", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:7206fbc:                     "\"dan\",jamie,\"dan\"", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:7206fbc:                     "dan,jamie,dan", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:7206fbc:                     "dan,jamie,DaN", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:7206fbc:                     "dan,jamie,\"DAN\"", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         try {
1:7206fbc:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:7206fbc:                     "\"dan\",jamie,\"dan\"", conn1);
1:7206fbc:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:7206fbc:         } catch (SQLException e) {
1:7206fbc:             assertSQLState("4250D", e);
1:7206fbc:         }
1:7206fbc:         
1:c774a1c:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:c774a1c:             "dan,jamie,system", conn1);
1:c774a1c:         // cannot set a user to both full and readonly access...
1:c774a1c:         assertFailSetDatabaseProperty(
1:c774a1c:                 "derby.database.readOnlyAccessUsers", "jamie", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:                 "derby.database.readOnlyAccessUsers", "ames,mickey", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:                 "derby.database.requireAuthentication","true", conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         
1:c774a1c:         
1:72b93c5:         PreparedStatement psGetAccess = conn1.prepareStatement(
1:72b93c5:                 "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
1:bbba1c7:         psGetAccess.setString(1, "JAMIE");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:72b93c5:         
1:72b93c5:         psGetAccess.setString(1, "DAN");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:72b93c5:         
1:bbba1c7:         psGetAccess.setString(1, "SYSTEM");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:72b93c5:         
1:72b93c5:         psGetAccess.setString(1, "AMES");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:72b93c5:         
1:bbba1c7:         psGetAccess.setString(1, "MICKEY");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:72b93c5: 
1:72b93c5:         // unknown user
1:72b93c5:         psGetAccess.setString(1, "hagrid");
1:72b93c5:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1:0d4b400:         
1:0d4b400:         conn1.commit();
1:0d4b400:         
1:0d4b400:         // now add/switch some names using the utility method
1:0d4b400:         CallableStatement csSetAccess = conn1.prepareCall(
1:0d4b400:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)");
1:0d4b400:         
1:0d4b400:         // Change AMES, everyone else is unchanged
1:0d4b400:         csSetAccess.setString(1, "AMES");
2:0d4b400:         csSetAccess.setString(2, "FULLACCESS");
1:9174d61:         csSetAccess.execute();
1:9174d61:         
1:0d4b400:         psGetAccess.setString(1, "AMES");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:0d4b400:         
1:bbba1c7:         psGetAccess.setString(1, "MICKEY");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:bbba1c7:         psGetAccess.setString(1, "JAMIE");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");       
1:0d4b400:         psGetAccess.setString(1, "DAN");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");        
1:bbba1c7:         psGetAccess.setString(1, "SYSTEM");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:0d4b400: 
1:0d4b400:         // and change AMES back again
1:0d4b400:         csSetAccess.setString(1, "AMES");
1:0d4b400:         csSetAccess.setString(2, "READONLYACCESS");
1:0d4b400:         csSetAccess.execute();
1:0d4b400:         
1:0d4b400:         psGetAccess.setString(1, "AMES");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:0d4b400:         
1:bbba1c7:         psGetAccess.setString(1, "MICKEY");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:bbba1c7:         psGetAccess.setString(1, "JAMIE");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");       
1:0d4b400:         psGetAccess.setString(1, "DAN");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");        
1:bbba1c7:         psGetAccess.setString(1, "SYSTEM");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:0d4b400: 
1:0d4b400:         // add a new users in
1:0d4b400:         csSetAccess.setString(1, "BOND");
1:9174d61:         csSetAccess.setString(2, "FULLACCESS");
1:0d4b400:         csSetAccess.execute(); 
1:0d4b400:         csSetAccess.setString(1, "JAMES");
1:0d4b400:         csSetAccess.setString(2, "READONLYACCESS");
1:0d4b400:         csSetAccess.execute();
1:0d4b400:         conn1.commit();
1:0d4b400:         
1:0d4b400:         psGetAccess.setString(1, "BOND");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:0d4b400:         psGetAccess.setString(1, "JAMES");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:0d4b400:         conn1.commit();
1:0d4b400:         
1:0d4b400:         // and remove them
1:0d4b400:         csSetAccess.setString(1, "BOND");
1:0d4b400:         csSetAccess.setString(2, null);
1:0d4b400:         csSetAccess.execute(); 
1:0d4b400:         csSetAccess.setString(1, "JAMES");
1:0d4b400:         csSetAccess.setString(2, null);
1:0d4b400:         csSetAccess.execute(); 
1:0d4b400:         conn1.commit();
1:0d4b400:         
1:0d4b400:         psGetAccess.setString(1, "BOND");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1:0d4b400:         psGetAccess.setString(1, "JAMES");
1:0d4b400:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1:0d4b400:         conn1.commit();
1:0d4b400:          
1:0d4b400:         
1:72b93c5:         psGetAccess.close();
1:0d4b400:         csSetAccess.close();
1:0d4b400:         
1:72b93c5:   
1:c774a1c:         // we should still be connected as dan
1:c774a1c:         Statement stmt = conn1.createStatement();
1:c774a1c:         assertUpdateCount(stmt, 0, 
1:c774a1c:             "create table APP.t1(c1 varchar(30) check (UPPER(c1) <> 'JAMIE'))");
1:c774a1c:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:72b93c5:       
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:72b93c5: 
1:c774a1c:         // check full access system level user can update
1:c774a1c:         conn1 = openDefaultConnection("system", "admin");
1:c774a1c:         stmt = conn1.createStatement();
1:c774a1c:         assertUpdateCount(stmt, 1, "update APP.t1 set c1 = USER");
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c:         
1:c774a1c:         // read only users
1:c774a1c:         assertUserValue(new String[] {"SYSTEM"},"ames", 
1:c774a1c:             "select * from APP.t1"); // should succeed
1:c774a1c:         conn1 = openDefaultConnection("ames", ("ames"+PASSWORD_SUFFIX));
1:cca0f77:         
1:cca0f77:         // DERBY-2738 (network client always returns false for isReadOnly)
1:cca0f77:         if (usingEmbedded())
1:cca0f77:             assertTrue(conn1.isReadOnly());
1:c774a1c:         stmt = conn1.createStatement();
1:c774a1c:         assertStatementError(
1:c774a1c:             "25502", stmt, "delete from APP.t1 where c1 = 'SYSTEM'");
1:c774a1c:         assertStatementError("25502", stmt, "insert into APP.t1 values USER");
1:c774a1c:         assertStatementError(
1:c774a1c:             "25502", stmt, "update APP.t1 set c1 = USER where c1 = 'SYSTEM'");
1:c774a1c:         assertStatementError("25503", stmt, "create table APP.t2 (c1 int)");
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:cca0f77:         conn1.close();
1:cca0f77:         
1:c774a1c:         // read-only system level user
1:c774a1c:         conn1 = openDefaultConnection("mickey", "mouse");
1:cca0f77:         // DERBY-2738 (network client always returns false for isReadOnly)
1:cca0f77:         if (usingEmbedded())
1:cca0f77:             assertTrue(conn1.isReadOnly());
1:c774a1c:         stmt = conn1.createStatement();
1:c774a1c:         assertStatementError(
1:c774a1c:             "25502", stmt, "delete from APP.t1 where c1 = 'SYSTEM'");
1:f178a86:         conn1.rollback();
1:c774a1c:         conn1.close();
1:c774a1c: 
1:c774a1c:         // reset
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.connection.requireAuthentication","false", conn1);
1:c774a1c:         stmt = conn1.createStatement();
1:c774a1c:         assertUpdateCount(stmt, 0, "drop table APP.t1");
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c:     }
1:c774a1c:     
1:9cf7d23:     /**
1:9cf7d23:      * Test the procedure and function that provide short-cuts
1:9cf7d23:      * to setting and getting connection level access.
1:9cf7d23:      * @throws SQLException
1:9cf7d23:      */
1:9cf7d23:     public void testUserAccessRoutines() throws SQLException
1:9cf7d23:     {
1:9cf7d23:         // use valid user/pwd to set the full accessusers.
1:9cf7d23:         Connection conn1 = openDefaultConnection(
1:9cf7d23:             "dan", ("dan" + PASSWORD_SUFFIX));
1:9cf7d23:         
1:9cf7d23:         PreparedStatement psGetAccess = conn1.prepareStatement(
1:9cf7d23:             "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
1:9cf7d23:         CallableStatement csSetAccess = conn1.prepareCall(
1:9cf7d23:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)"); 
1:9cf7d23:         
1:bbba1c7:         csSetAccess.setString(1, "DAN");
1:9cf7d23:         csSetAccess.setString(2, "FULLACCESS");
1:0d4b400:         csSetAccess.execute();
1:9cf7d23: 
1:9174d61:         // Invalid users
1:9174d61:         csSetAccess.setString(1, null);
1:9174d61:         csSetAccess.setString(2, "FULLACCESS");
2:9174d61:         assertStatementError("28502", csSetAccess);
1:9174d61:         
1:c774a1c: 
1:9cf7d23:         // Random user will now have only READONLYACCESS
1:9cf7d23:         setDatabaseProperty(
1:9cf7d23:                 "derby.database.defaultConnectionMode","READONLYACCESS", conn1);       
1:9cf7d23:         conn1.commit();             
1:9cf7d23:         psGetAccess.setString(1, "TONYBLAIR");
1:9cf7d23:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:9cf7d23:         conn1.commit();
1:9174d61: 
1:9cf7d23:         // Random user will now have FULLACCESS
1:9cf7d23:         setDatabaseProperty(
1:9cf7d23:                 "derby.database.defaultConnectionMode","FULLACCESS", conn1);       
1:9cf7d23:         conn1.commit();             
1:9cf7d23:         psGetAccess.setString(1, "TONYBLAIR");
1:9cf7d23:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:9cf7d23:         conn1.commit();
1:9cf7d23:         
1:9cf7d23:         // and still full access
1:9cf7d23:         setDatabaseProperty(
1:9cf7d23:                 "derby.database.defaultConnectionMode", null, conn1);       
1:9cf7d23:         conn1.commit();             
1:9cf7d23:         psGetAccess.setString(1, "TONYBLAIR");
1:9cf7d23:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:9cf7d23:         conn1.commit();
1:9cf7d23:         
1:9174d61:         conn1.close();
1:9cf7d23:            
1:9cf7d23:     }
1:9cf7d23:     
1:c774a1c:     public void testGreekCharacters() throws SQLException {
1:f178a86:         
1:c774a1c:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:c774a1c:         
1:f178a86:         setSystemProperty("derby.user." + apollo, zeus);
1:c774a1c: 
1:c774a1c:         Connection conn1 = openDefaultConnection(
1:c774a1c:                 "dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         // add a database level user
1:c774a1c:         setDatabaseProperty(("derby.user." + zeus), apollo, conn1);
1:c774a1c:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:c774a1c:                 ("dan,system,APP" + zeus + "," + apollo) , conn1);
1:c774a1c:         conn1.commit();
1:c774a1c:         conn1.close();
1:c774a1c:         
1:c774a1c: 
1:b005ffa:         assertConnectionOK(dbName, zeus, apollo);
1:b005ffa:         assertConnectionFail("08004", dbName, apollo, apollo);
1:ca5edbb:         // shutdown as non-dbo
1:ca5edbb:         assertShutdownOK(dbName, zeus, apollo);
2:b005ffa:         assertConnectionOK(dbName, apollo, zeus);
1:ca5edbb:         // wrong credentials
1:b005ffa:         assertShutdownFail("08004", dbName, zeus, zeus);
1:ca5edbb:          // shutdown as non-dbo
1:ca5edbb:         assertShutdownOK(dbName, apollo, zeus);
1:ca5edbb:         assertConnectionOK(dbName, apollo, zeus);
1:ca5edbb:         // shutdown as dbo
1:b005ffa:         assertShutdownUsingSetShutdownOK(
1:b005ffa:             dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:b005ffa: 
1:b005ffa:         conn1 = openDefaultConnection(zeus, apollo);
1:b005ffa:         Statement stmt = conn1.createStatement();
1:b005ffa:         assertUpdateCount(stmt, 0, 
1:b005ffa:         "create table APP.t1(c1 varchar(30))");
1:b005ffa:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:b005ffa:         conn1.commit();
1:b005ffa:         assertUserValue(new String[] {zeus}, zeus, apollo,
1:b005ffa:         "select * from APP.t1 where c1 like CURRENT_USER");
1:b005ffa:         stmt.close();
1:b005ffa:         conn1.close();
1:c774a1c:         
1:c774a1c:         // reset
1:c774a1c:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:c774a1c:         setDatabaseProperty(
1:c774a1c:             "derby.connection.requireAuthentication","false", conn1);
1:c774a1c:         stmt = conn1.createStatement();
5:c774a1c:         if (usingEmbedded())
1:c774a1c:             assertUpdateCount(stmt, 0, "drop table APP.t1");
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c:     }
1:c774a1c:     
1:1b46090:     // tests system shutdown with setting required authentication at
1:1b46090:     // system level
1:1b46090:     public void testSystemShutdown() throws SQLException
1:1b46090:     {
1:1b46090:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:1b46090:         
1:1b46090:         // just for the setting the stage, recheck connections while fullAccess
1:1b46090:         // (default) is set at database level. 
1:1b46090:         
1:1b46090:         // first try connection with valid user/password
1:1b46090:         assertConnectionOK(dbName, "system", ("admin"));
1:1b46090:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:1b46090: 
1:1b46090:         // try ensuring system level is set for authentication
1:f178a86:         setSystemProperty("derby.connection.requireAuthentication", "true");
1:f178a86: 
1:1b46090:         // bring down the database
1:14ed86a:         assertShutdownUsingSetShutdownOK(
1:14ed86a:             dbName, "APP", "APP" + PASSWORD_SUFFIX);
1:1b46090:         // recheck
1:1b46090:         assertConnectionOK(dbName, "system", "admin");
1:1b46090:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:1b46090:         // bring down server to ensure settings take effect 
1:1b46090:         assertSystemShutdownOK("", "badUser", ("dan" + PASSWORD_SUFFIX));
1:f178a86:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:1b46090: 
1:1b46090:         // try system shutdown with wrong user
1:1b46090:         assertSystemShutdownFail("08004", "", "badUser", ("dan" + PASSWORD_SUFFIX));
1:1b46090:         // with 'allowed' user but bad pwd
1:1b46090:         assertSystemShutdownFail("08004", "", "dan", ("jeff" + PASSWORD_SUFFIX));
1:1b46090:         // APP, but bad pwd
1:1b46090:         assertSystemShutdownFail("08004", "", "APP", ("POO"));
1:1b46090:         // note: we don't have a database, so no point checking for dbo.
1:1b46090:         // expect Derby system shutdown, which gives XJ015 error.
1:1b46090:         assertSystemShutdownOK("", "system", "admin");
1:1b46090:         
1:1b46090:         // reset.
1:1b46090:         Connection conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:1b46090:         setDatabaseProperty(
1:1b46090:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:1b46090:         setDatabaseProperty(
1:1b46090:             "derby.connection.requireAuthentication","false", conn1);
1:1b46090:         
1:f178a86:         setSystemProperty("derby.connection.requireAuthentication", "false");
1:f178a86: 
1:1b46090:         conn1.commit();
1:1b46090:         conn1.close();
1:f178a86:         openDefaultConnection("system", "admin").close();
1:14ed86a:         assertShutdownUsingSetShutdownOK(
1:14ed86a:             dbName, "APP", "APP" + PASSWORD_SUFFIX);
1:1b46090:         assertSystemShutdownOK("", "system", "admin");
1:f178a86:         openDefaultConnection("system", "admin").close(); // just so teardown works.
1:1b46090:     }
1:60edeb0: 
1:60edeb0:     /**
1:8c305e2:      * DERBY-4483: Test that the database by default has the configurable
1:8c305e2:      * hash authentication scheme enabled.
1:8c305e2:      */
1:8c305e2:     public void testDefaultHashAlgorithm() throws SQLException {
1:1eee305:         // SHA-256 should be the default hash algorithm now, if it's supported
1:1eee305:         // on the platform. Otherwise, we fall back to SHA-1.
1:1eee305:         String expected = supportsAlgorithm("SHA-256") ? "SHA-256" : "SHA-1";
1:1eee305:         assertEquals(expected, getDatabaseProperty(BUILTIN_ALGO_PROP));
1:1eee305:     }
1:1eee305: 
1:1eee305:     /**
1:1eee305:      * Check if a message digest algorithm is supported on this platform.
1:1eee305:      *
1:1eee305:      * @param algorithm the algorithm to check
1:1eee305:      * @return true if the algorithm is supported, false otherwise
1:1eee305:      */
1:1eee305:     private boolean supportsAlgorithm(String algorithm) {
1:1eee305:         try {
1:1eee305:             MessageDigest.getInstance(algorithm);
1:1eee305:             return true;
1:1eee305:         } catch (NoSuchAlgorithmException nsae) {
1:1eee305:             return false;
1:1eee305:         }
1:8c305e2:     }
1:8c305e2: 
1:8c305e2:     /**
1:60edeb0:      * DERBY-4483: Test that setting the property
1:60edeb0:      * {@code derby.authentication.builtin.algorithm} changes which hash
1:60edeb0:      * algorithm is used to protect the stored password token.
1:60edeb0:      */
1:60edeb0:     public void testVariousBuiltinAlgorithms() throws SQLException {
1:60edeb0:         setAutoCommit(true);
1:60edeb0:         String[] algorithms = { null, "MD5", "SHA-1", "SHA-256", "SHA-512" };
1:60edeb0:         for (int i = 0; i < algorithms.length; i++) {
1:60edeb0:             String algo = algorithms[i];
1:1eee305: 
1:1eee305:             if (algo != null && !supportsAlgorithm(algo)) {
1:1eee305:                 // DERBY-4602: Skip algorithms not supported on this platform
1:1eee305:                 continue;
1:1eee305:             }
1:1eee305: 
1:1ede0a8:             // Test the algorithm with and without key stretching (added in
1:1ede0a8:             // DERBY-5539)
1:1ede0a8:             testVariousBuiltinAlgorithms(algo, true);
1:1ede0a8:             testVariousBuiltinAlgorithms(algo, false);
1:1ede0a8:         }
1:1ede0a8:     }
1:60edeb0: 
1:1ede0a8:     /**
1:1ede0a8:      * Worker method for {@link #testVariousBuiltinAlgorithms()}.
1:1ede0a8:      *
1:1ede0a8:      * @param algo the name of the hash algorithm to test
1:1ede0a8:      * @param keyStretching whether or not to use the authentication scheme that
1:1ede0a8:      *   performs key stretching
1:1ede0a8:      */
1:1ede0a8:     private void testVariousBuiltinAlgorithms(String algo, boolean keyStretching)
1:1ede0a8:             throws SQLException {
1:1ede0a8:         setDatabaseProperty(BUILTIN_ALGO_PROP, algo);
1:60edeb0: 
1:1ede0a8:         if (keyStretching) {
1:1ede0a8:             // Unset the properties specifying salt length and iterations, so
1:1ede0a8:             // we get the default scheme (with key stretching)
1:1ede0a8:             setDatabaseProperty(BUILTIN_SALT_LENGTH_PROP, null);
1:1ede0a8:             setDatabaseProperty(BUILTIN_ITERATIONS_PROP, null);
1:1ede0a8:         } else {
1:1ede0a8:             // Disable salt and use a single iteration
1:1ede0a8:             setDatabaseProperty(BUILTIN_SALT_LENGTH_PROP, "0");
1:1ede0a8:             setDatabaseProperty(BUILTIN_ITERATIONS_PROP, "1");
1:1ede0a8:         }
1:60edeb0: 
1:1ede0a8:         for (int i = 0; i < USERS.length; i++) {
1:1ede0a8:             String user = USERS[i];
1:1ede0a8:             String password = user + PASSWORD_SUFFIX;
1:1ede0a8:             String userProp = USER_PREFIX + user;
1:1ede0a8: 
1:1ede0a8:             // Set the password for the user
1:1ede0a8:             setDatabaseProperty(userProp, password);
1:1ede0a8: 
1:1ede0a8:             // Get the stored password token and verify that it
1:1ede0a8:             // hashed the way we expect it to be
1:1ede0a8:             String token = getDatabaseProperty(userProp);
1:1ede0a8:             if (algo == null) {
1:1ede0a8:                 assertTrue("Expected old authentication scheme: " + token,
1:1ede0a8:                            token.startsWith("3b60"));
1:1ede0a8:             } else {
1:1ede0a8:                 if (keyStretching) {
1:1ede0a8:                     assertTrue("Expected configurable hash scheme with "+
1:1ede0a8:                                "key stretching: " + token,
1:1ede0a8:                                token.startsWith("3b62"));
1:60edeb0:                 } else {
1:1ede0a8:                     assertTrue("Expected configurable hash scheme: " + token,
1:60edeb0:                                token.startsWith("3b61"));
1:60edeb0:                 }
1:1ede0a8:                 assertTrue("Expected algorithm " + algo + ":" + token,
1:1ede0a8:                            token.endsWith(":" + algo));
1:60edeb0:             }
1:1ede0a8: 
1:1ede0a8:             // Verify that we can still connect as that user
1:1ede0a8:             openDefaultConnection(user, password).close();
1:60edeb0:         }
1:60edeb0:     }
1:60edeb0: 
1:60edeb0:     /**
1:60edeb0:      * DERBY-4483: Test that slightly different passwords result in different
1:60edeb0:      * hashes, and also that using the same password for different users
1:60edeb0:      * results in a unique hashes with the configurable hash authentication
1:60edeb0:      * scheme.
1:60edeb0:      */
1:60edeb0:     public void testNoCollisionsWithConfigurableHash() throws SQLException {
1:60edeb0:         assertNotNull("hash algorithm not set up",
1:60edeb0:                       getDatabaseProperty(BUILTIN_ALGO_PROP));
1:60edeb0: 
1:60edeb0:         // Store a set of generated password tokens to detect collisions
1:e18f54b:         HashSet<String> tokens = new HashSet<String>();
1:60edeb0: 
1:60edeb0:         for (int i = 0; i < USERS.length; i++) {
1:60edeb0:             String user = USERS[i];
2:60edeb0:             String userProp = USER_PREFIX + user;
1:60edeb0:             assertNotNull("missing user " + user,
1:60edeb0:                           getDatabaseProperty(userProp));
1:60edeb0: 
1:60edeb0:             // Start with the password "testing", and then change one of the
1:60edeb0:             // characters
1:60edeb0:             char[] pw = new char[] { 't', 'e', 's', 't', 'i', 'n', 'g' };
1:60edeb0:             for (int j = 0; j < 100; j++) {
1:60edeb0:                 String pass = new String(pw);
1:60edeb0:                 setDatabaseProperty(userProp, pass);
1:60edeb0: 
1:60edeb0:                 assertTrue("collision detected",
1:60edeb0:                            tokens.add(getDatabaseProperty(userProp)));
1:60edeb0:                 pw[pw.length / 2]++;
1:60edeb0:             }
1:60edeb0:         }
1:60edeb0:     }
1:60edeb0: 
1:60edeb0:     /**
1:60edeb0:      * DERBY-4483: Test that we fail gracefully if an invalid algorithm name
1:60edeb0:      * is specified in {@code derby.authentication.builtin.algorithm}.
1:60edeb0:      */
1:60edeb0:     public void testInvalidAlgorithmName() throws SQLException {
1:60edeb0:         setDatabaseProperty(BUILTIN_ALGO_PROP, "not-a-valid-name");
1:60edeb0: 
1:60edeb0:         for (int i = 0; i < USERS.length; i++) {
1:60edeb0:             try {
1:60edeb0:                 setDatabaseProperty(USER_PREFIX + USERS[i], "abcdef");
1:60edeb0:                 fail();
1:60edeb0:             } catch (SQLException sqle) {
1:60edeb0:                 assertSQLState(NO_SUCH_ALGO, sqle);
1:60edeb0:             }
1:60edeb0:         }
1:60edeb0:     }
1:60edeb0: 
1:c774a1c:     /**
1:006b542:      * DERBY-5507: Setting a user's password as a database property, when
1:006b542:      * that user's password is already set as a system property, used to make
1:006b542:      * the password getting stored in plaintext in the database.
1:006b542:      */
1:006b542:     public void testDerby5507PlaintextPassword() throws SQLException {
1:006b542:         // This user account is defined in a system property
1:006b542:         String key = "derby.user.mickey";
1:006b542: 
1:006b542:         // Now define the account in a database property
1:006b542:         String pw = "M0u$e";
1:006b542:         setDatabaseProperty(key, pw);
1:006b542: 
1:006b542:         // This used to return the plaintext password, but it should
1:006b542:         // return a hashed token
1:006b542:         String pwToken = getDatabaseProperty(key);
1:006b542:         assertFalse("Password stored in plaintext", pwToken.equals(pw));
1:006b542:     }
1:c774a1c:     
1:c774a1c:     protected void assertFailSetDatabaseProperty(
1:c774a1c:         String propertyName, String value, Connection conn) 
2:c774a1c:     throws SQLException {
1:c774a1c:         CallableStatement setDBP =  conn.prepareCall(
1:c774a1c:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:c774a1c:         setDBP.setString(1, propertyName);
1:c774a1c:         setDBP.setString(2, value);
1:c774a1c:         // user jamie cannot be both readOnly and fullAccess
1:8f3b0b9:         assertStatementError("4250C", setDBP);
1:f178a86:         setDBP.close();
1:1b46090:     }
1:c774a1c:     
1:c774a1c:     protected void setDatabaseProperty(
1:c774a1c:         String propertyName, String value, Connection conn) 
1:c774a1c:     throws SQLException {
1:c774a1c:         CallableStatement setDBP =  conn.prepareCall(
1:c774a1c:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:c774a1c:         setDBP.setString(1, propertyName);
1:c774a1c:         setDBP.setString(2, value);
1:c774a1c:         setDBP.execute();
1:f178a86:         setDBP.close();
1:c774a1c:     }
1:60edeb0: 
1:60edeb0:     /**
1:60edeb0:      * Set a database property in the default connection.
1:60edeb0:      */
1:60edeb0:     void setDatabaseProperty(String propertyName, String value)
1:60edeb0:             throws SQLException
1:60edeb0:     {
1:60edeb0:         setDatabaseProperty(propertyName, value, getConnection());
1:60edeb0:     }
1:c774a1c:     
1:c774a1c:     protected void useUserValue(int expectedUpdateCount, String user, String sql)
1:c774a1c:     throws SQLException
17:c774a1c:     {
1:c774a1c:         Connection conn1 = openDefaultConnection(user, user + PASSWORD_SUFFIX);
1:c774a1c:         Statement stmt = conn1.createStatement();
1:c774a1c:         assertUpdateCount(stmt, expectedUpdateCount, sql);
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c:     }
1:c774a1c:     
1:afff7e0:     // verify that the return value is the expected value, and 
1:afff7e0:     // we have the expected number of rows returning from the query
1:afff7e0:     // in this test, it will be one of the user names through
1:afff7e0:     // use of CURRENT_USER, SESSION_USER etc.
1:c774a1c:     protected void assertUserValue(
1:c774a1c:         String[] expected, String user, String password, String sql)
1:c774a1c:     throws SQLException
1:c774a1c:     {
1:c774a1c:         Connection conn1 = openDefaultConnection(user, password);
1:c774a1c:         Statement stmt = conn1.createStatement();
1:c774a1c:         ResultSet rs = stmt.executeQuery(sql);
1:c774a1c:         int i = 0; 
1:c774a1c:         while (rs.next())
1:c774a1c:         {
1:c774a1c:             assertEquals(expected[i],rs.getString(1));
1:c774a1c:             i++;
1:c774a1c:         }
1:c774a1c:         assertEquals(expected.length, i);
1:c774a1c:         conn1.commit();
1:c774a1c:         stmt.close();
1:c774a1c:         conn1.close();
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     // convenience method, password is often using PASSWORD_SUFFIX
1:c774a1c:     protected void assertUserValue(String[] expected, String user, String sql)
1:c774a1c:     throws SQLException {
1:c774a1c:         assertUserValue(expected, user, (user + PASSWORD_SUFFIX), sql);
1:c774a1c:     }
1:c774a1c:     
1:afff7e0:     // get a connection using ds.getConnection(user, password)
1:c774a1c:     protected void assertConnectionOK(
2:c774a1c:          String dbName, String user, String password)
1:c774a1c:     throws SQLException
1:c774a1c:     {
1:14ed86a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:f178a86:         Connection conn = ds.getConnection(user, password);
1:f178a86:         assertNotNull(conn);
1:f178a86:         conn.close();
1:c774a1c:     }
1:c774a1c:     
1:afff7e0:     // get a connection, using setUser / setPassword, and ds.getConnection()
1:c774a1c:     protected void assertConnectionWOUPOK(
1:c774a1c:         String dbName, String user, String password)
1:c774a1c:     throws SQLException
1:c774a1c:     {
6:c774a1c:         DataSource ds = JDBCDataSource.getDataSource(dbName);
4:c774a1c:         JDBCDataSource.setBeanProperty(ds, "user", user);
4:c774a1c:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:f178a86:         Connection conn = ds.getConnection();
1:f178a86:         assertNotNull(conn);
1:f178a86:         conn.close();
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     protected void assertConnectionFail(
1:c774a1c:         String expectedSqlState, String dbName, String user, String password)
1:c774a1c:     throws SQLException
1:c774a1c:     {
1:14ed86a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
19:c774a1c:         try {
1:1b46090:             ds.getConnection(user, password);
1:c774a1c:             fail("Connection should've been refused/failed");
1:c774a1c:         }
3:c774a1c:         catch (SQLException e) {
5:c774a1c:             assertSQLState(expectedSqlState, e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:afff7e0:     // same action as with assertConnectionFail, but using ds.getConnection()
1:afff7e0:     // instead of ds.getConnection(user, password). So, setting user and
1:afff7e0:     // password using appropriate ds.set method.
1:c774a1c:     protected void assertConnectionWOUPFail(
1:c774a1c:         String expectedError, String dbName, String user, String password) 
1:c774a1c:     throws SQLException 
1:c774a1c:     {
1:14ed86a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:c774a1c:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:c774a1c:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:c774a1c:         try {
10:c774a1c:                 ds.getConnection();
1:c774a1c:                 fail("Connection should've been refused/failed");
1:c774a1c:         }
1:c774a1c:         catch (SQLException e) {
3:c774a1c:                 assertSQLState(expectedError, e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:14ed86a:     protected void assertShutdownUsingSetShutdownOK(
1:14ed86a:             String dbName, String user, String password) throws SQLException {
1:14ed86a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         try {
1:14ed86a:             ds.getConnection(user, password);
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             // expect 08006 on successful shutdown
1:14ed86a:             assertSQLState("08006", e);
1:14ed86a:         }
1:c774a1c:     }
1:14ed86a: 
1:14ed86a:     protected void assertShutdownUsingConnAttrsOK(
1:14ed86a:         String dbName, String user, String password) throws SQLException {
1:14ed86a: 
1:14ed86a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         JDBCDataSource.setBeanProperty(
1:14ed86a:             ds, "connectionAttributes", "shutdown=true");
1:14ed86a:         try {
1:14ed86a:             ds.getConnection(user, password);
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             // expect 08006 on successful shutdown
1:14ed86a:             assertSQLState("08006", e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:afff7e0:     // same action as with assertShutdownOK, but using ds.getConnection()
1:afff7e0:     // instead of ds.getConnection(user, password). So, setting user and
1:afff7e0:     // password using appropriate ds.set method.
1:c774a1c:     protected void assertShutdownWOUPOK(
1:c774a1c:         String dbName, String user, String password)
1:c774a1c:     throws SQLException {
1:c774a1c: 
1:c774a1c:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:14ed86a:         try {
1:14ed86a:             ds.getConnection();
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             // expect 08006 on successful shutdown
1:14ed86a:             assertSQLState("08006", e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     protected void assertShutdownFail(
1:c774a1c:         String expectedSqlState, String dbName, String user, String password) 
1:c774a1c:     throws SQLException
1:c774a1c:     {
1:c774a1c:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         try {
1:14ed86a:             ds.getConnection(user, password);
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             assertSQLState(expectedSqlState, e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c:     
1:ca5edbb:     protected void assertShutdownOK(
1:ca5edbb:         String dbName, String user, String password)
1:ca5edbb:     throws SQLException
1:ca5edbb:     {
1:ca5edbb:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:ca5edbb:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:ca5edbb:         try {
1:ca5edbb:             ds.getConnection(user, password);
1:ca5edbb:             fail("expected shutdown to fail");
1:ca5edbb:         } catch (SQLException e) {
1:ca5edbb:             assertSQLState("08006", e);
1:ca5edbb:         }
1:ca5edbb:     }
1:ca5edbb: 
1:c774a1c:     protected void assertShutdownWOUPFail(
1:c774a1c:         String expectedSqlState, String dbName, String user, String password) 
1:c774a1c:     throws SQLException
1:c774a1c:     {
1:c774a1c:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:14ed86a:         try {
1:14ed86a:             ds.getConnection();
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             assertSQLState(expectedSqlState, e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     protected void assertSystemShutdownOK(
1:c774a1c:         String dbName, String user, String password)
1:c774a1c:     throws SQLException {
1:14ed86a:         DataSource ds;
1:c774a1c:         if (usingEmbedded())
1:c774a1c:         {
1:1b46090:             // we cannot use JDBCDataSource.getDataSource() (which uses the
1:1b46090:             // default database name), unless we specifically clear the 
1:1b46090:             // databaseName. Otherwise, only the database will be shutdown.
1:1b46090:             // The alternative is to use jDBCDataSource.getDatasource(dbName),
1:1b46090:             // where dbName is an empty string - this will in the current code
1:1b46090:             // be interpreted as a system shutdown.
1:14ed86a:             
1:14ed86a:             ds = JDBCDataSource.getDataSource();
1:1b46090:             JDBCDataSource.clearStringBeanProperty(ds, "databaseName");
1:c774a1c:         }
1:14ed86a:         else 
1:c774a1c:         {
1:1b46090:             // With client, we cannot user clearStringBeanProperty on the  
1:1b46090:             // databaseName, that will result in error 08001 - 
1:1b46090:             // Required DataSource property databaseName not set.
1:1b46090:             // So, we pass an empty string as databaseName, which the current
1:1b46090:             // code interprets as a system shutdown.
1:14ed86a:             ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         }
1:14ed86a:         
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         try {
1:14ed86a:             ds.getConnection(user, password);
1:14ed86a:             fail("expected system shutdown resulting in XJ015 error");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             // expect XJ015, system shutdown, on successful shutdown
1:14ed86a:             assertSQLState("XJ015", e);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     protected void assertSystemShutdownFail(
1:c774a1c:         String expectedError, String dbName, String user, String password)
1:c774a1c:     throws SQLException {
1:14ed86a:         DataSource ds;
1:c774a1c:         if (usingEmbedded())
1:c774a1c:         {
1:14ed86a:             ds = JDBCDataSource.getDataSource();
1:afff7e0:             JDBCDataSource.clearStringBeanProperty(ds, "databaseName");
1:c774a1c:         }
1:14ed86a:         else
1:c774a1c:         {
1:14ed86a:             // note: with network server/client, you can't set the databaseName
1:1b46090:             // to null, that results in error 08001 - Required DataSource
1:1b46090:             // property databaseName not set.
1:1b46090:             // so, we rely on passing of an empty string for databaseName,
1:1b46090:             // which in the current code is interpreted as system shutdown.
1:14ed86a:             ds = JDBCDataSource.getDataSource(dbName);
1:14ed86a:         }
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:14ed86a:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:14ed86a:         try {
1:14ed86a:             ds.getConnection();
1:14ed86a:             fail("expected shutdown to fail");
1:14ed86a:         } catch (SQLException e) {
1:14ed86a:             assertSQLState(expectedError, e);
1:c774a1c:         }
1:c774a1c:     }
1:14ed86a: 
1:c774a1c:     public void assertConnectionFail(String dbName) throws SQLException {
1:df3ba09:         
1:df3ba09:         // Get the default data source but clear the user and
1:df3ba09:         // password set by the configuration.
1:df3ba09:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:df3ba09:         
1:df3ba09:         // Reset to no user/password though client requires
1:df3ba09:         // a valid name, so reset to the default
2:c774a1c:         if (usingDerbyNetClient())
1:df3ba09:             JDBCDataSource.setBeanProperty(ds, "user", "APP");
1:df3ba09:         else
1:df3ba09:             JDBCDataSource.clearStringBeanProperty(ds, "user");
1:df3ba09:         JDBCDataSource.clearStringBeanProperty(ds, "password");
1:df3ba09:         
1:df3ba09:         try {
1:df3ba09:             ds.getConnection();
1:df3ba09:             fail("expected connection to fail");
1:df3ba09:         } catch (SQLException e) {
1:df3ba09:             assertSQLState("08004", e);
1:df3ba09:         }       
1:c774a1c:     }
1:c774a1c: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("AuthenticationTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("AuthenticationTest");
/////////////////////////////////////////////////////////////////////////
1:     protected static void setBaseProps(BaseTestSuite suite, Test test)
1:             BaseTestSuite suite, Test test, Properties extraDbProps)
commit:ca5edbb
/////////////////////////////////////////////////////////////////////////
1:         // try shutdown as non-owner
1:         assertShutdownOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         assertShutdownWOUPOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         assertShutdownOK(dbName, "system", "admin");
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         assertShutdownWOUPOK(dbName, "system", "admin");
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         // try shutdown as owner
/////////////////////////////////////////////////////////////////////////
1:         // attempt to shutdown db as one of the allowed users, but not db owner
1:         assertShutdownOK(dbName, "francois", ("francois" + PASSWORD_SUFFIX));
1:         // attempt shutdown as db owner
1:         assertConnectionOK(dbName, "system", "admin");
/////////////////////////////////////////////////////////////////////////
1:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertShutdownOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:          // but dbo was not on list...
/////////////////////////////////////////////////////////////////////////
1:             // shutdown as non-dbo
1:             assertShutdownOK(dbName, zeus, apollo);
1:             // wrong credentials
1:              // shutdown as non-dbo
1:             assertShutdownOK(dbName, apollo, zeus);
1:             assertConnectionOK(dbName, apollo, zeus);
1:             // shutdown as dbo
/////////////////////////////////////////////////////////////////////////
1:     protected void assertShutdownOK(
1:         String dbName, String user, String password)
1:     throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         try {
1:             ds.getConnection(user, password);
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             assertSQLState("08006", e);
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String> tokens = new HashSet<String>();
commit:1ede0a8
/////////////////////////////////////////////////////////////////////////
1:     private static final String BUILTIN_SALT_LENGTH_PROP =
1:             "derby.authentication.builtin.saltLength";
1: 
1:     private static final String BUILTIN_ITERATIONS_PROP =
1:             "derby.authentication.builtin.iterations";
1: 
/////////////////////////////////////////////////////////////////////////
1:             // Test the algorithm with and without key stretching (added in
1:             // DERBY-5539)
1:             testVariousBuiltinAlgorithms(algo, true);
1:             testVariousBuiltinAlgorithms(algo, false);
1:         }
1:     }
1:     /**
1:      * Worker method for {@link #testVariousBuiltinAlgorithms()}.
1:      *
1:      * @param algo the name of the hash algorithm to test
1:      * @param keyStretching whether or not to use the authentication scheme that
1:      *   performs key stretching
1:      */
1:     private void testVariousBuiltinAlgorithms(String algo, boolean keyStretching)
1:             throws SQLException {
1:         setDatabaseProperty(BUILTIN_ALGO_PROP, algo);
1:         if (keyStretching) {
1:             // Unset the properties specifying salt length and iterations, so
1:             // we get the default scheme (with key stretching)
1:             setDatabaseProperty(BUILTIN_SALT_LENGTH_PROP, null);
1:             setDatabaseProperty(BUILTIN_ITERATIONS_PROP, null);
1:         } else {
1:             // Disable salt and use a single iteration
1:             setDatabaseProperty(BUILTIN_SALT_LENGTH_PROP, "0");
1:             setDatabaseProperty(BUILTIN_ITERATIONS_PROP, "1");
1:         }
1:         for (int i = 0; i < USERS.length; i++) {
1:             String user = USERS[i];
1:             String password = user + PASSWORD_SUFFIX;
1:             String userProp = USER_PREFIX + user;
1: 
1:             // Set the password for the user
1:             setDatabaseProperty(userProp, password);
1: 
1:             // Get the stored password token and verify that it
1:             // hashed the way we expect it to be
1:             String token = getDatabaseProperty(userProp);
1:             if (algo == null) {
1:                 assertTrue("Expected old authentication scheme: " + token,
1:                            token.startsWith("3b60"));
1:             } else {
1:                 if (keyStretching) {
1:                     assertTrue("Expected configurable hash scheme with "+
1:                                "key stretching: " + token,
1:                                token.startsWith("3b62"));
1:                     assertTrue("Expected configurable hash scheme: " + token,
1:                 assertTrue("Expected algorithm " + algo + ":" + token,
1:                            token.endsWith(":" + algo));
1: 
1:             // Verify that we can still connect as that user
1:             openDefaultConnection(user, password).close();
commit:006b542
/////////////////////////////////////////////////////////////////////////
1:         test = new AuthenticationTest("testDerby5507PlaintextPassword");
1:         setBaseProps(suite, test);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * DERBY-5507: Setting a user's password as a database property, when
1:      * that user's password is already set as a system property, used to make
1:      * the password getting stored in plaintext in the database.
1:      */
1:     public void testDerby5507PlaintextPassword() throws SQLException {
1:         // This user account is defined in a system property
1:         String key = "derby.user.mickey";
1: 
1:         // Now define the account in a database property
1:         String pw = "M0u$e";
1:         setDatabaseProperty(key, pw);
1: 
1:         // This used to return the plaintext password, but it should
1:         // return a hashed token
1:         String pwToken = getDatabaseProperty(key);
1:         assertFalse("Password stored in plaintext", pwToken.equals(pw));
1:     }
commit:1eee305
/////////////////////////////////////////////////////////////////////////
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
/////////////////////////////////////////////////////////////////////////
1:         // SHA-256 should be the default hash algorithm now, if it's supported
1:         // on the platform. Otherwise, we fall back to SHA-1.
1:         String expected = supportsAlgorithm("SHA-256") ? "SHA-256" : "SHA-1";
1:         assertEquals(expected, getDatabaseProperty(BUILTIN_ALGO_PROP));
1:     }
1: 
1:     /**
1:      * Check if a message digest algorithm is supported on this platform.
1:      *
1:      * @param algorithm the algorithm to check
1:      * @return true if the algorithm is supported, false otherwise
1:      */
1:     private boolean supportsAlgorithm(String algorithm) {
1:         try {
1:             MessageDigest.getInstance(algorithm);
1:             return true;
1:         } catch (NoSuchAlgorithmException nsae) {
1:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (algo != null && !supportsAlgorithm(algo)) {
1:                 // DERBY-4602: Skip algorithms not supported on this platform
1:                 continue;
1:             }
1: 
commit:8c305e2
/////////////////////////////////////////////////////////////////////////
1:         test = new AuthenticationTest("testDefaultHashAlgorithm");
1:         setBaseProps(suite, test);
1: 
/////////////////////////////////////////////////////////////////////////
1:      * DERBY-4483: Test that the database by default has the configurable
1:      * hash authentication scheme enabled.
1:      */
1:     public void testDefaultHashAlgorithm() throws SQLException {
0:         // SHA-256 should be the default hash algorithm now
0:         assertEquals("SHA-256", getDatabaseProperty(BUILTIN_ALGO_PROP));
1:     }
1: 
1:     /**
commit:60edeb0
/////////////////////////////////////////////////////////////////////////
1: 
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final String BUILTIN_ALGO_PROP =
1:             "derby.authentication.builtin.algorithm";
1: 
1:     private static final String USER_PREFIX = "derby.user.";
1: 
1:     private static final String NO_SUCH_ALGO = "XBCXW";
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The test cases below test the configurable hash authentication
1:         // mechanism added in DERBY-4483. Set the property that specifies the
1:         // hash algorithm to some valid value for these tests. Not all tests
1:         // depend on the property being set prior to their invocation, but by
1:         // setting it in a decorator we ensure that it will be automatically
1:         // cleared on tear down, so that it will be safe for all of these tests
1:         // to change the property without worrying about resetting it later.
1:         Properties confHashProps = new Properties();
1:         confHashProps.setProperty(BUILTIN_ALGO_PROP, "MD5");
1: 
1:         test = new AuthenticationTest("testVariousBuiltinAlgorithms");
1:         setBaseProps(suite, test, confHashProps);
1:         test = new AuthenticationTest("testNoCollisionsWithConfigurableHash");
1:         setBaseProps(suite, test, confHashProps);
1: 
1:         test = new AuthenticationTest("testInvalidAlgorithmName");
1:         setBaseProps(suite, test, confHashProps);
1: 
/////////////////////////////////////////////////////////////////////////
1:         setBaseProps(suite, test, null);
1:     }
1: 
1:     private static void setBaseProps(
0:             TestSuite suite, Test test, Properties extraDbProps)
1:     {
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (extraDbProps != null) {
1:             props.putAll(extraDbProps);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * DERBY-4483: Test that setting the property
1:      * {@code derby.authentication.builtin.algorithm} changes which hash
1:      * algorithm is used to protect the stored password token.
1:      */
1:     public void testVariousBuiltinAlgorithms() throws SQLException {
1:         setAutoCommit(true);
1:         String[] algorithms = { null, "MD5", "SHA-1", "SHA-256", "SHA-512" };
1:         for (int i = 0; i < algorithms.length; i++) {
1:             String algo = algorithms[i];
0:             setDatabaseProperty(BUILTIN_ALGO_PROP, algo);
1: 
0:             for (int j = 0; j < USERS.length; j++) {
0:                 String user = USERS[j];
0:                 String password = user + PASSWORD_SUFFIX;
1:                 String userProp = USER_PREFIX + user;
1: 
0:                 // Set the password for the user
0:                 setDatabaseProperty(userProp, password);
1: 
0:                 // Get the stored password token and verify that it
0:                 // hashed the way we expect it to be
0:                 String token = getDatabaseProperty(userProp);
0:                 if (algo == null) {
0:                     assertTrue("Expected old authentication schema: " + token,
0:                                token.startsWith("3b60"));
1:                 } else {
0:                     assertTrue("Expected configurable hash schema: " + token,
1:                                token.startsWith("3b61"));
0:                     assertTrue("Expected algorithm " + algo + ":" + token,
0:                                token.endsWith(":" + algo));
1:                 }
1: 
0:                 // Verify that we can still connect as that user
0:                 openDefaultConnection(user, password).close();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * DERBY-4483: Test that slightly different passwords result in different
1:      * hashes, and also that using the same password for different users
1:      * results in a unique hashes with the configurable hash authentication
1:      * scheme.
1:      */
1:     public void testNoCollisionsWithConfigurableHash() throws SQLException {
1:         assertNotNull("hash algorithm not set up",
1:                       getDatabaseProperty(BUILTIN_ALGO_PROP));
1: 
1:         // Store a set of generated password tokens to detect collisions
0:         HashSet tokens = new HashSet();
1: 
1:         for (int i = 0; i < USERS.length; i++) {
1:             String user = USERS[i];
1:             String userProp = USER_PREFIX + user;
1:             assertNotNull("missing user " + user,
1:                           getDatabaseProperty(userProp));
1: 
1:             // Start with the password "testing", and then change one of the
1:             // characters
1:             char[] pw = new char[] { 't', 'e', 's', 't', 'i', 'n', 'g' };
1:             for (int j = 0; j < 100; j++) {
1:                 String pass = new String(pw);
1:                 setDatabaseProperty(userProp, pass);
1: 
1:                 assertTrue("collision detected",
1:                            tokens.add(getDatabaseProperty(userProp)));
1:                 pw[pw.length / 2]++;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * DERBY-4483: Test that we fail gracefully if an invalid algorithm name
1:      * is specified in {@code derby.authentication.builtin.algorithm}.
1:      */
1:     public void testInvalidAlgorithmName() throws SQLException {
1:         setDatabaseProperty(BUILTIN_ALGO_PROP, "not-a-valid-name");
1: 
1:         for (int i = 0; i < USERS.length; i++) {
1:             try {
1:                 setDatabaseProperty(USER_PREFIX + USERS[i], "abcdef");
1:                 fail();
1:             } catch (SQLException sqle) {
1:                 assertSQLState(NO_SUCH_ALGO, sqle);
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set a database property in the default connection.
1:      */
1:     void setDatabaseProperty(String propertyName, String value)
1:             throws SQLException
1:     {
1:         setDatabaseProperty(propertyName, value, getConnection());
1:     }
commit:8f3b0b9
/////////////////////////////////////////////////////////////////////////
1:         assertShutdownFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         assertShutdownWOUPFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertShutdownFail("08004", dbName, "system", "admin");
0:         assertShutdownWOUPFail("08004", dbName, "system", "admin");
/////////////////////////////////////////////////////////////////////////
0:         assertShutdownFail("08004", dbName, "francois", ("francois" + PASSWORD_SUFFIX));
1:         assertConnectionFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         assertShutdownFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
/////////////////////////////////////////////////////////////////////////
0:         assertShutdownFail("08004", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertShutdownFail("08004", dbName, "APP", ("APP" + PASSWORD_SUFFIX));
/////////////////////////////////////////////////////////////////////////
1:         assertConnectionFail("08004", dbName, "system", "admin");
0:         assertShutdownFail("08004", dbName, "system", "admin");
/////////////////////////////////////////////////////////////////////////
0:             assertShutdownFail("08004", dbName, zeus, apollo);
0:             assertShutdownFail("08004", dbName, apollo, zeus);
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("4250C", setDBP);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:527b771
/////////////////////////////////////////////////////////////////////////
author:Lily Wei
-------------------------------------------------------------------------------
commit:e4927d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         //Derby-4856,set the property to avoid thread dump and diagnostic info
0:         sysprops.put("derby.stream.error.extendedDiagSeverityLevel","50000");
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
0:         setSystemProperty("derby.stream.error.extendedDiagSeverityLevel","50000");
1:         
author:Tiago Aurlio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:b005ffa
/////////////////////////////////////////////////////////////////////////
1:         assertConnectionOK(dbName, zeus, apollo);
1:         assertConnectionFail("08004", dbName, apollo, apollo);
0:         // shutdown as non-dbo
0:         assertShutdownOK(dbName, zeus, apollo);
1:         assertConnectionOK(dbName, apollo, zeus);
0:         // wrong credentials
1:         assertShutdownFail("08004", dbName, zeus, zeus);
0:          // shutdown as non-dbo
0:         assertShutdownOK(dbName, apollo, zeus);
1:         assertConnectionOK(dbName, apollo, zeus);
0:         // shutdown as dbo
1:         assertShutdownUsingSetShutdownOK(
1:             dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1: 
1:         conn1 = openDefaultConnection(zeus, apollo);
1:         Statement stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 0, 
1:         "create table APP.t1(c1 varchar(30))");
1:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:         conn1.commit();
1:         assertUserValue(new String[] {zeus}, zeus, apollo,
1:         "select * from APP.t1 where c1 like CURRENT_USER");
1:         stmt.close();
1:         conn1.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt = conn1.createStatement();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:288915e
/////////////////////////////////////////////////////////////////////////
1:      * @param connUser
commit:bbba1c7
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:                     "READONLYACCESS");
/////////////////////////////////////////////////////////////////////////
1:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:                     "FULLACCESS");
/////////////////////////////////////////////////////////////////////////
1:             JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
1:                     "READONLYACCESS");
/////////////////////////////////////////////////////////////////////////
1:         psGetAccess.setString(1, "JAMIE");
1:         psGetAccess.setString(1, "SYSTEM");
1:         psGetAccess.setString(1, "MICKEY");
/////////////////////////////////////////////////////////////////////////
1:         psGetAccess.setString(1, "MICKEY");
1:         psGetAccess.setString(1, "JAMIE");
1:         psGetAccess.setString(1, "SYSTEM");
/////////////////////////////////////////////////////////////////////////
1:         psGetAccess.setString(1, "MICKEY");
1:         psGetAccess.setString(1, "JAMIE");
1:         psGetAccess.setString(1, "SYSTEM");
/////////////////////////////////////////////////////////////////////////
1:         csSetAccess.setString(1, "DAN");
commit:c33061f
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Now test that setting the user connection authorizaton
1:         // with the various names works correctly. Use the first user
1:         // to set the access on others to avoid setting a user to read-only
1:         // and then not being able to reset it.
1:         
1:         PreparedStatement psGetAccess = prepareStatement(
1:             "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
1:         CallableStatement csSetAccess = prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)"); 
1:         
1:         setDatabaseProperty("derby.database.fullAccessUsers",
1:                 USERS[0], getConnection());
1:         setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:                 null, getConnection());
1:         commit();
1:         
1:         // Yes - skip the first user, see above.
1:         for (int i = 1; i < USERS.length; i++)
1:         {          
1:             String jdbcUserName = USERS[i];
1:             boolean delimited = jdbcUserName.charAt(0) == '"';
1:             String normalUserName;
1:             if (delimited)
1:             {
1:                 normalUserName = jdbcUserName.substring(1,
1:                         jdbcUserName.length() - 1);          
1:             }
1:             else
1:             {
1:                 normalUserName = jdbcUserName.toUpperCase(Locale.ENGLISH);
1:             }
1:              
1:             String password = USERS[i] + PASSWORD_SUFFIX;
1:             
1:             // Set the access with the database property
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:                     jdbcUserName, getConnection());
1:             commit();
1:             
1:             
1:             Connection connUser = openDefaultConnection(jdbcUserName, password);
1:             
1:             // DERBY-2738 (network client always returns false for isReadOnly)
1:             if (usingEmbedded())
1:                 assertTrue(jdbcUserName + ":isReadOnly()",
1:                     connUser.isReadOnly());
1:             
1:             
1:             connUser.close();
1:             
1:             psGetAccess.setString(1, normalUserName);
0:             //JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
0:             //        "READONLYACCESS");
1:             commit();
1:             
1:             // clear the property.
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:                     null, getConnection());
1:             commit();
1:             
1:             // Test it was reset back
1:             connUser = openDefaultConnection(jdbcUserName, password);
1:             assertFalse(connUser.isReadOnly());
1:             connUser.close(); 
1:             
1:             psGetAccess.setString(1, normalUserName);
0:             //JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
0:             //        "FULLACCESS");
1:             commit();
1:             
1:             
1:             // Set to be read-only via the procedure which uses
1:             // the normal user name.
1:             csSetAccess.setString(1, normalUserName);
1:             csSetAccess.setString(2, "READONLYACCESS");
1:             csSetAccess.executeUpdate();
1:             commit();
1:             
1:             connUser = openDefaultConnection(jdbcUserName, password);
1:             // DERBY-2738 (network client always returns false for isReadOnly)
1:             if (usingEmbedded())
1:                 assertTrue(jdbcUserName + ":isReadOnly()",
1:                     connUser.isReadOnly());
1: 
1:             connUser.close();
1:             
1:             psGetAccess.setString(1, normalUserName);
0:             //JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(),
0:             //        "READONLYACCESS");
1:             commit();           
1: 
1:         }
commit:ce018f3
/////////////////////////////////////////////////////////////////////////
1:     {        
1:                 jdbcUserName, connUser.getMetaData().getUserName());
1:         
1:         
1:         Statement s = connUser.createStatement();
1:           
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(" +
1:                 "CURRENT_USER, 'FULLACCESS')");
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
commit:9fbf2cb
/////////////////////////////////////////////////////////////////////////
1:         "\"eVe\"","\"fred@derby.com\"", "\"123\"" };
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() throws Exception {
1:         
1:         setDatabaseProperty("derby.database.defaultConnectionMode",
1:                 null, getConnection());
1:         setDatabaseProperty("derby.database.readOnlyAccessUsers",
1:                 null, getConnection());
1:         setDatabaseProperty("derby.database.fullAccessUsers",
1:                 null, getConnection());
1:         
1:         commit();
1:         
1:     }
1:     
1:     protected void tearDown() throws Exception {
1:         removeSystemProperty("derby.connection.requireAuthentication");
1:         removeSystemProperty("derby.user." +apollo);
/////////////////////////////////////////////////////////////////////////
0:                 jdbcUserName, connUser.getMetaData().getUserName());       
commit:7206fbc
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Test duplicates on the list of users
1:         try {
1:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:                     "dan,jamie,dan", conn1);
1:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:                     "dan,jamie,DaN", conn1);
1:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:                     "dan,jamie,\"DAN\"", conn1);
1:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.fullAccessUsers", 
1:                     "\"dan\",jamie,\"dan\"", conn1);
1:             fail("Duplicate allowed on derby.database.fullAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         
1:         try {
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:                     "dan,jamie,dan", conn1);
1:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:                     "dan,jamie,DaN", conn1);
1:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:                     "dan,jamie,\"DAN\"", conn1);
1:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         try {
1:             setDatabaseProperty("derby.database.readOnlyAccessUsers", 
1:                     "\"dan\",jamie,\"dan\"", conn1);
1:             fail("Duplicate allowed on derby.database.readOnlyAccessUsers");
1:         } catch (SQLException e) {
1:             assertSQLState("4250D", e);
1:         }
1:         
commit:3b5204b
/////////////////////////////////////////////////////////////////////////
1:         // DatabaseMetaData.getUserName() returns the user name used
1:         // to make the request via JDBC.
1:         assertEquals("DatabaseMetaData.getUserName()",
0:                 jdbcUserName, connUser.getMetaData().getUserName());
1:         
/////////////////////////////////////////////////////////////////////////
1:     {      
commit:2bbaf40
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:         {"APP","dan","kreg","jeff","ames","jerry","francois","jamie","howardR",
0:         "\"eVe\""};
/////////////////////////////////////////////////////////////////////////
1:         test = new AuthenticationTest("testUserCasing");
1:         setBaseProps(suite, test);
1:         
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test how user names behave with casing.
1:      * @throws SQLException
1:      */
1:     public void testUserCasing() throws SQLException
1:     {
1:         for (int i = 0; i < USERS.length; i++)
1:         {          
1:             String jdbcUserName = USERS[i];
1:             boolean delimited = jdbcUserName.charAt(0) == '"';
1:             String normalUserName;
1:             if (delimited)
1:             {
1:                 normalUserName = jdbcUserName.substring(1,
1:                         jdbcUserName.length() - 1);          
1:             }
1:             else
1:             {
1:                 normalUserName = jdbcUserName.toUpperCase(Locale.ENGLISH);
1:             }
1:              
1:             String password = USERS[i] + PASSWORD_SUFFIX;
1:             
1:             userCasingTest(jdbcUserName, normalUserName, password);
1:             
1:             if (!delimited)
1:             {
1: 
1:                 if (!normalUserName.equals(jdbcUserName))
1:                 {
1:                     // Test connecting via the normalized name
1:                     // but only if it wasn't already tested.
1:                     // E.g. connect as "DAN" for user DAN as opposed
1:                     // to the user being defined as dan (regular identifier).
1:                     
1:                     // DERBY-3150 disable this test until bug is fixed.
1:                     //userCasingTest(normalUserName, normalUserName, password);
1:                 }
1:                 
1:                 // Test with the normalized name quoted as a delimited identifer.
1:                 // E.g. connect as "DAN" for user DAN
1:                 
1:                 // DERBY-3150 disable this test until bug is fixed.
1:                 // userCasingTest("\"" + normalUserName + "\"",
1:                 //        normalUserName, password);
1:             }
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test the user casing obtaining connections a variety of ways.
1:      * @param jdbcUserName User name to be used to obtain the connection via JDBC
1:      * @param normalUserName Normalized form of the user connection.
1:      * @param password Password for the user.
1:      * @throws SQLException
1:      */
1:     private void userCasingTest(String jdbcUserName, String normalUserName,
1:             String password) throws SQLException
1:     {
1:         // Default test mechanism to get a connection.
1:         userCasingTest(jdbcUserName, normalUserName,
1:                 openDefaultConnection(jdbcUserName, password));
1:         
1:         
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         
1:         // DataSource using explict user
1:         userCasingTest(jdbcUserName, normalUserName,
1:                 ds.getConnection(jdbcUserName, password));
1:         
1:         JDBCDataSource.setBeanProperty(ds, "user", jdbcUserName);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         userCasingTest(jdbcUserName, normalUserName,
1:                 ds.getConnection());        
1:     }
1:     
1:     /**
1:      * 
1:      * @param jdbcUserName User name as passed into the JDBC connection request.
1:      * @param normalUserName Normalized user name.
1:      * @param connUser Connection for the user, closed by this method.
1:      * @throws SQLException 
1:      */
1:     private void userCasingTest(String jdbcUserName, String normalUserName,
1:             Connection connUser) throws SQLException
1:     {
1:         assertNormalUserName(normalUserName, connUser);
1:         
1:         JDBC.cleanup(connUser);
1:     }
1:     
1:     /**
1:      * Assert that the user name returned by various mechanisms
1:      * matches the normal user name.
1:      * @param normalUserName
0:      * @param conn
1:      * @throws SQLException
1:      */
1:     private void assertNormalUserName(String normalUserName, Connection connUser)
1:         throws SQLException
1:     {
0:         //assertEquals("DatabaseMetaData.getUserName",
0:         //        normalUserName, connUser.getMetaData().getUserName());
1:         
1:         Statement s = connUser.createStatement();
1:         
1:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES CURRENT_USER"),
1:                 normalUserName);
1:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES SESSION_USER"),
1:                 normalUserName);
1:         JDBC.assertSingleValueResultSet(s.executeQuery("VALUES {fn user()}"),
1:                 normalUserName);
1:         s.close();
1:         
1:     }
commit:9174d61
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerDecorator(
/////////////////////////////////////////////////////////////////////////
1:         csSetAccess.execute();
1: 
1:         // Invalid users
1:         csSetAccess.setString(1, null);
1:         csSetAccess.setString(2, "FULLACCESS");
1:         assertStatementError("28502", csSetAccess);
1:         
0:         csSetAccess.setString(1, "123"); // not an identifier.
1:         csSetAccess.setString(2, "FULLACCESS");
1:         assertStatementError("28502", csSetAccess);
/////////////////////////////////////////////////////////////////////////
1:         
1:         conn1.close();
commit:9cf7d23
/////////////////////////////////////////////////////////////////////////
1:         test = new AuthenticationTest("testUserAccessRoutines");
1:         setBaseProps(suite, test);
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test the procedure and function that provide short-cuts
1:      * to setting and getting connection level access.
1:      * @throws SQLException
1:      */
1:     public void testUserAccessRoutines() throws SQLException
1:     {
1:         // use valid user/pwd to set the full accessusers.
1:         Connection conn1 = openDefaultConnection(
1:             "dan", ("dan" + PASSWORD_SUFFIX));
1:         
1:         PreparedStatement psGetAccess = conn1.prepareStatement(
1:             "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
1:         CallableStatement csSetAccess = conn1.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)"); 
1:         
0:         // Clear out the properties to ensure we start afresh
1:         setDatabaseProperty("derby.database.fullAccessUsers", 
0:                 null, conn1);
0:         setDatabaseProperty("derby.database.readOnlyAccessUsers", 
0:                 null, conn1);
1:         
0:         csSetAccess.setString(1, "dan");
1:         csSetAccess.setString(2, "FULLACCESS");
1: 
1:         // Random user will now have only READONLYACCESS
1:         setDatabaseProperty(
1:                 "derby.database.defaultConnectionMode","READONLYACCESS", conn1);       
1:         conn1.commit();             
1:         psGetAccess.setString(1, "TONYBLAIR");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:         conn1.commit();
1: 
1:         // Random user will now have FULLACCESS
1:         setDatabaseProperty(
1:                 "derby.database.defaultConnectionMode","FULLACCESS", conn1);       
1:         conn1.commit();             
1:         psGetAccess.setString(1, "TONYBLAIR");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         conn1.commit();
1:         
1:         // and still full access
1:         setDatabaseProperty(
1:                 "derby.database.defaultConnectionMode", null, conn1);       
1:         conn1.commit();             
1:         psGetAccess.setString(1, "TONYBLAIR");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         conn1.commit();
1:            
1:     }
1:     
commit:0d4b400
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         conn1.commit();
1:         
1:         // now add/switch some names using the utility method
1:         CallableStatement csSetAccess = conn1.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_USER_ACCESS(?, ?)");
1:         
1:         // Change AMES, everyone else is unchanged
1:         csSetAccess.setString(1, "AMES");
1:         csSetAccess.setString(2, "FULLACCESS");
1:         csSetAccess.execute();
1:         
1:         psGetAccess.setString(1, "AMES");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         
0:         psGetAccess.setString(1, "miCKEY");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
0:         psGetAccess.setString(1, "jamie");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");       
1:         psGetAccess.setString(1, "DAN");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");        
0:         psGetAccess.setString(1, "system");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         // and change AMES back again
1:         csSetAccess.setString(1, "AMES");
1:         csSetAccess.setString(2, "READONLYACCESS");
1:         csSetAccess.execute();
1:         
1:         psGetAccess.setString(1, "AMES");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:         
0:         psGetAccess.setString(1, "miCKEY");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
0:         psGetAccess.setString(1, "jamie");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");       
1:         psGetAccess.setString(1, "DAN");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");        
0:         psGetAccess.setString(1, "system");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1: 
1:         // add a new users in
1:         csSetAccess.setString(1, "BOND");
1:         csSetAccess.setString(2, "FULLACCESS");
1:         csSetAccess.execute(); 
1:         csSetAccess.setString(1, "JAMES");
1:         csSetAccess.setString(2, "READONLYACCESS");
1:         csSetAccess.execute();
1:         conn1.commit();
1:         
1:         psGetAccess.setString(1, "BOND");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         psGetAccess.setString(1, "JAMES");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:         conn1.commit();
1:         
1:         // and remove them
1:         csSetAccess.setString(1, "BOND");
1:         csSetAccess.setString(2, null);
1:         csSetAccess.execute(); 
1:         csSetAccess.setString(1, "JAMES");
1:         csSetAccess.setString(2, null);
1:         csSetAccess.execute(); 
1:         conn1.commit();
1:         
1:         psGetAccess.setString(1, "BOND");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1:         psGetAccess.setString(1, "JAMES");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1:         conn1.commit();
1:          
1:         
1:         csSetAccess.close();
1:   
commit:72b93c5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:         
1:         PreparedStatement psGetAccess = conn1.prepareStatement(
1:                 "VALUES SYSCS_UTIL.SYSCS_GET_USER_ACCESS(?)");
0:         psGetAccess.setString(1, "jamie");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         
1:         psGetAccess.setString(1, "DAN");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         
0:         psGetAccess.setString(1, "system");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "FULLACCESS");
1:         
1:         psGetAccess.setString(1, "AMES");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1:         
0:         psGetAccess.setString(1, "mickEy");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "READONLYACCESS");
1: 
1:         // unknown user
1:         psGetAccess.setString(1, "hagrid");
1:         JDBC.assertSingleValueResultSet(psGetAccess.executeQuery(), "NOACCESS");
1: 
1:         psGetAccess.close();
1:         
1:         
commit:cca0f77
/////////////////////////////////////////////////////////////////////////
1:         
1:         // DERBY-2738 (network client always returns false for isReadOnly)
1:         if (usingEmbedded())
1:             assertTrue(conn1.isReadOnly());
/////////////////////////////////////////////////////////////////////////
1:         conn1.close();
1:         
1:         // DERBY-2738 (network client always returns false for isReadOnly)
1:         if (usingEmbedded())
1:             assertTrue(conn1.isReadOnly());
commit:f178a86
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Tests authentication and connection level authorization.
1:  *
1:  */
1:     private static final String PASSWORD_SUFFIX = "suf2ix";
1:     private static final String USERS[] = 
1:     private static final String zeus = "\u0396\u0395\u03A5\u03A3";
1:     private static final String apollo = "\u0391\u09A0\u039F\u039B\u039B\u039A\u0390";
/////////////////////////////////////////////////////////////////////////
1:      * Ensure all connections are not in auto commit mode.
1:     protected void initializeConnection(Connection conn) throws SQLException {
1:         conn.setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         Properties props = new Properties();
1:         Properties sysprops = new Properties();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         conn1.close();
/////////////////////////////////////////////////////////////////////////
1:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
1:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
/////////////////////////////////////////////////////////////////////////
1:         conn1.rollback();
/////////////////////////////////////////////////////////////////////////
1:         conn1.close();
1:         setSystemProperty("derby.user.system", "thrdSysPwd");
1:         setSystemProperty("derby.user.system", "admin");
1: 
/////////////////////////////////////////////////////////////////////////
1:         conn1.rollback();
/////////////////////////////////////////////////////////////////////////
1:         
1:         setSystemProperty("derby.user." + apollo, zeus);
/////////////////////////////////////////////////////////////////////////
1:             conn1.commit();
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty("derby.connection.requireAuthentication", "true");
1: 
/////////////////////////////////////////////////////////////////////////
1:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)).close(); // revive
/////////////////////////////////////////////////////////////////////////
1:         
1:         setSystemProperty("derby.connection.requireAuthentication", "false");
1: 
1:         openDefaultConnection("system", "admin").close();
1:         openDefaultConnection("system", "admin").close(); // just so teardown works.
/////////////////////////////////////////////////////////////////////////
1:         setDBP.close();
/////////////////////////////////////////////////////////////////////////
1:         setDBP.close();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = ds.getConnection(user, password);
1:         assertNotNull(conn);
1:         conn.close();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = ds.getConnection();
1:         assertNotNull(conn);
1:         conn.close();
commit:df3ba09
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Get the default data source but clear the user and
1:         // password set by the configuration.
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         
1:         // Reset to no user/password though client requires
1:         // a valid name, so reset to the default
1:             JDBCDataSource.setBeanProperty(ds, "user", "APP");
1:         else
1:             JDBCDataSource.clearStringBeanProperty(ds, "user");
1:         JDBCDataSource.clearStringBeanProperty(ds, "password");
1:         
1:         try {
1:             ds.getConnection();
1:             fail("expected connection to fail");
1:         } catch (SQLException e) {
1:             assertSQLState("08004", e);
1:         }       
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:14ed86a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertShutdownUsingConnAttrsOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
/////////////////////////////////////////////////////////////////////////
1:             assertShutdownUsingSetShutdownOK(
0:                 dbName, "APP", ("APP" + PASSWORD_SUFFIX));
/////////////////////////////////////////////////////////////////////////
1:         assertShutdownUsingSetShutdownOK(
1:             dbName, "APP", "APP" + PASSWORD_SUFFIX);
/////////////////////////////////////////////////////////////////////////
0:         assertShutdownUsingSetShutdownOK(
1:             dbName, "APP", "APP" + PASSWORD_SUFFIX);
/////////////////////////////////////////////////////////////////////////
1:     protected void assertShutdownUsingSetShutdownOK(
1:             String dbName, String user, String password) throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         try {
1:             ds.getConnection(user, password);
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             // expect 08006 on successful shutdown
1:             assertSQLState("08006", e);
1:     }
1: 
1:     protected void assertShutdownUsingConnAttrsOK(
1:         String dbName, String user, String password) throws SQLException {
1: 
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "shutdown=true");
1:         try {
1:             ds.getConnection(user, password);
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             // expect 08006 on successful shutdown
1:             assertSQLState("08006", e);
/////////////////////////////////////////////////////////////////////////
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
1:             ds.getConnection();
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             // expect 08006 on successful shutdown
1:             assertSQLState("08006", e);
/////////////////////////////////////////////////////////////////////////
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         try {
1:             ds.getConnection(user, password);
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             assertSQLState(expectedSqlState, e);
/////////////////////////////////////////////////////////////////////////
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
1:             ds.getConnection();
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             assertSQLState(expectedSqlState, e);
1:         DataSource ds;
/////////////////////////////////////////////////////////////////////////
1:             
1:             ds = JDBCDataSource.getDataSource();
1:         else 
1:             ds = JDBCDataSource.getDataSource(dbName);
1:         }
1:         
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         try {
1:             ds.getConnection(user, password);
1:             fail("expected system shutdown resulting in XJ015 error");
1:         } catch (SQLException e) {
1:             // expect XJ015, system shutdown, on successful shutdown
1:             assertSQLState("XJ015", e);
1:         DataSource ds;
1:             ds = JDBCDataSource.getDataSource();
1:         else
1:             // note: with network server/client, you can't set the databaseName
1:             ds = JDBCDataSource.getDataSource(dbName);
1:         }
1:         JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
1:             ds.getConnection();
1:             fail("expected shutdown to fail");
1:         } catch (SQLException e) {
1:             assertSQLState(expectedError, e);
1: 
commit:1b46090
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
0:     protected static Properties sysprops = new Properties();
0:     protected static Properties props = new Properties();
/////////////////////////////////////////////////////////////////////////
1:         {
1:         }
1:         Test test = new AuthenticationTest(
1:             "testConnectShutdownAuthentication");
1:         setBaseProps(suite, test);
1:         setBaseProps(suite, test);
1:         setBaseProps(suite, test);
1:         setBaseProps(suite, test);
1:         setBaseProps(suite, test);
1: 
1:         test = new AuthenticationTest("testSystemShutdown");
1:         setBaseProps(suite, test);
1:     
0:     protected static void setBaseProps(TestSuite suite, Test test) 
1:     {
1:         // Use DatabasePropertyTestSetup.builtinAuthentication decorator
1:         // to set the user properties required by this test (and shutdown 
1:         // the database for the property to take effect).
1:         // DatabasePropertyTestSetup uses SYSCS_SET_DATABASE_PROPERTY
1:         // so that is database level setting.
1:         // Additionally use DatabasePropertyTestSetup to add some
1:         // possibly useful settings
1:         // Finally SystemPropertyTestSetup sets up system level users
1:         props.setProperty("derby.infolog.append", "true");
1:         props.setProperty("derby.debug.true", "AuthenticationTrace");
1:         sysprops.put("derby.user.system", "admin");
1:         sysprops.put("derby.user.mickey", "mouse");
1:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
1:             USERS, PASSWORD_SUFFIX);
1:         test = new DatabasePropertyTestSetup (test, props, true);
1:         suite.addTest(new SystemPropertyTestSetup (test, sysprops));
1:     }
1:     
0:     public void tearDown() throws Exception {
1:         try {
0:             AccessController.doPrivileged
0:             (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     System.getProperties().remove(
0:                         "derby.connection.requireAuthentication");
0:                     String apollo = 
0:                         "\u0391\u09A0\u039F\u039B\u039B\u039A\u0390";
0:                     return 
0:                         System.getProperties().remove("derby.user." +apollo);
1:                 }
0:             });
0:         } catch (Exception e) {
0:             fail("failed to unset properties");
1:         }
1:         super.tearDown();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:         // try some system shutdowns. Note, that all these work, because
1:         // we have not set require authentication at system level.
1:         // try system shutdown with wrong user - should work
1:         assertSystemShutdownOK("", "badUser", ("dan" + PASSWORD_SUFFIX));
0:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)); // revive
1:         // with 'allowed' user but bad pwd - will succeed
1:         assertSystemShutdownOK("", "dan", ("jeff" + PASSWORD_SUFFIX));
0:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)); // revive
1:         // dbo, but bad pwd - will succeed
1:         assertSystemShutdownOK("", "APP", ("POO"));
0:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)); // revive
1:         // allowed user but not dbo - will also succeed
1:         assertSystemShutdownOK("", "dan", ("dan" + PASSWORD_SUFFIX));
0:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)); // revive
1: 
/////////////////////////////////////////////////////////////////////////
1:     // tests system shutdown with setting required authentication at
1:     // system level
1:     public void testSystemShutdown() throws SQLException
1:     {
1:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:         
1:         // just for the setting the stage, recheck connections while fullAccess
1:         // (default) is set at database level. 
1:         
1:         // first try connection with valid user/password
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1: 
1:         // try ensuring system level is set for authentication
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return java.lang.System.setProperty(
0:                         "derby.connection.requireAuthentication", "true");
1:                 }
0:         });
1:         // bring down the database
0:         assertShutdownOK(dbName, "APP", "APP" + PASSWORD_SUFFIX);
1:         // recheck
1:         assertConnectionOK(dbName, "system", "admin");
1:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         // bring down server to ensure settings take effect 
1:         assertSystemShutdownOK("", "badUser", ("dan" + PASSWORD_SUFFIX));
0:         openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX)); // revive
1: 
1:         // try system shutdown with wrong user
1:         assertSystemShutdownFail("08004", "", "badUser", ("dan" + PASSWORD_SUFFIX));
1:         // with 'allowed' user but bad pwd
1:         assertSystemShutdownFail("08004", "", "dan", ("jeff" + PASSWORD_SUFFIX));
1:         // APP, but bad pwd
1:         assertSystemShutdownFail("08004", "", "APP", ("POO"));
1:         // note: we don't have a database, so no point checking for dbo.
1:         // expect Derby system shutdown, which gives XJ015 error.
1:         assertSystemShutdownOK("", "system", "admin");
1:         
1:         // reset.
1:         Connection conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return java.lang.System.setProperty(
0:                         "derby.connection.requireAuthentication", "false");
1:                 }
0:         });
1:         conn1.commit();
1:         conn1.close();
0:         openDefaultConnection("system", "admin");
0:         assertShutdownOK(dbName, "APP", "APP" + PASSWORD_SUFFIX);
1:         assertSystemShutdownOK("", "system", "admin");
0:         openDefaultConnection("system", "admin"); // just so teardown works.
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:             // we cannot use JDBCDataSource.getDataSource() (which uses the
1:             // default database name), unless we specifically clear the 
1:             // databaseName. Otherwise, only the database will be shutdown.
1:             // The alternative is to use jDBCDataSource.getDatasource(dbName),
1:             // where dbName is an empty string - this will in the current code
1:             // be interpreted as a system shutdown.
0:             DataSource ds = JDBCDataSource.getDataSource();
1:             JDBCDataSource.clearStringBeanProperty(ds, "databaseName");
/////////////////////////////////////////////////////////////////////////
0:             // ds.setShutdown is not currently suppported by client, so we need
0:             // to use ds.setConnectionAttributes.
1:             // With client, we cannot user clearStringBeanProperty on the  
1:             // databaseName, that will result in error 08001 - 
1:             // Required DataSource property databaseName not set.
1:             // So, we pass an empty string as databaseName, which the current
1:             // code interprets as a system shutdown.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             // note: with network server, you cannot set the databaseName
1:             // to null, that results in error 08001 - Required DataSource
1:             // property databaseName not set.
1:             // so, we rely on passing of an empty string for databaseName,
1:             // which in the current code is interpreted as system shutdown.
0:             // also, we need to use setConnectionAttributes.
1:                 ds.getConnection(user, password);
commit:afff7e0
/////////////////////////////////////////////////////////////////////////
1:     // verify that the return value is the expected value, and 
1:     // we have the expected number of rows returning from the query
1:     // in this test, it will be one of the user names through
1:     // use of CURRENT_USER, SESSION_USER etc.
/////////////////////////////////////////////////////////////////////////
1:     // get a connection using ds.getConnection(user, password)
/////////////////////////////////////////////////////////////////////////
1:     // get a connection, using setUser / setPassword, and ds.getConnection()
/////////////////////////////////////////////////////////////////////////
1:     // same action as with assertConnectionFail, but using ds.getConnection()
1:     // instead of ds.getConnection(user, password). So, setting user and
1:     // password using appropriate ds.set method.
/////////////////////////////////////////////////////////////////////////
1:     // same action as with assertShutdownOK, but using ds.getConnection()
1:     // instead of ds.getConnection(user, password). So, setting user and
1:     // password using appropriate ds.set method.
/////////////////////////////////////////////////////////////////////////
0:         // method so can't use the same setBeanProperty as with embedded
/////////////////////////////////////////////////////////////////////////
1:             JDBCDataSource.clearStringBeanProperty(ds, "databaseName");
/////////////////////////////////////////////////////////////////////////
0:             JDBCDataSource.clearStringBeanProperty(ds, "databaseName");
commit:c774a1c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class 
1:        org.apache.derbyTesting.functionTests.tests.jdbcapi.AuthenticationTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import java.security.AccessController;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Properties;
1: 
1: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.jdbc.ClientDataSource;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
0: import org.apache.derby.jdbc.EmbeddedSimpleDataSource;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class AuthenticationTest extends BaseJDBCTestCase {
1: 
0:     protected static String PASSWORD_SUFFIX = "suf2ix";
0:     protected static String USERS[] = 
0:         {"APP","dan","kreg","jeff","ames","jerry","francois","jamie","howardR"};
1: 
0:     protected String zeus = "\u0396\u0395\u03A5\u03A3";
0:     protected String apollo = "\u0391\u09A0\u039F\u039B\u039B\u039A\u0390";
1: 
1:     
1:     /** Creates a new instance of the Test */
1:     public AuthenticationTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
0:      * Set up the conection to the database.
1:      */
0:     public void setUp() throws  Exception {
0:         getConnection().setAutoCommit(false);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("AuthenticationTest");
1:         suite.addTest(baseSuite("AuthenticationTest:embedded"));
0:         if (!JDBC.vmSupportsJSR169())
0:             suite.addTest(TestConfiguration.clientServerDecorator(
1:                 baseSuite("AuthenticationTest:client")));
1:         return suite;
1:     }
1:     
1:     public static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite("AuthenticationTest");
1: 
0:         // set users at system level
0:         java.lang.System.setProperty("derby.user.system", "admin");
0:         java.lang.System.setProperty("derby.user.mickey", "mouse");
1:         
0:         // Use DatabasePropertyTestSetup decorator to set the user properties
0:         // required by this test (and shutdown the database for the
0:         // property to take effect).
0:         Properties props = new Properties();
0:         props.setProperty("derby.infolog.append", "true");
0:         props.setProperty("derby.debug.true", "AuthenticationTrace");
1: 
0:         Test test = new AuthenticationTest("testConnectShutdownAuthentication");
0:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
0:             USERS, PASSWORD_SUFFIX);
0:         suite.addTest(new DatabasePropertyTestSetup (test, props, true));
1:         
0:         // DatabasePropertyTestSsetup uses SYSCS_SET_DATABASE_PROPERTY
0:         // so that is database level setting.
1:         test = new AuthenticationTest("testUserFunctions");
0:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
0:             USERS, PASSWORD_SUFFIX);
0:         suite.addTest(new DatabasePropertyTestSetup (test, props, true));
1: 
1:         test = new AuthenticationTest("testNotFullAccessUsers");
0:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
0:             USERS, PASSWORD_SUFFIX);
0:         suite.addTest(new DatabasePropertyTestSetup (test, props, true));
1:         
1:         test = new AuthenticationTest(
1:             "testChangePasswordAndDatabasePropertiesOnly");
0:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
0:             USERS, PASSWORD_SUFFIX);
0:         suite.addTest(new DatabasePropertyTestSetup (test, props, true));
1: 
1:         // only part of this fixture runs with network server / client
1:         test = new AuthenticationTest("testGreekCharacters");
0:         test = DatabasePropertyTestSetup.builtinAuthentication(test,
0:             USERS, PASSWORD_SUFFIX);
0:         suite.addTest(new DatabasePropertyTestSetup (test, props, true));
1:         
1:         // This test needs to run in a new single use database as we're setting
1:         // a number of properties
1:         return TestConfiguration.singleUseDatabaseDecorator(suite);
1:     }
1: 
1:     // roughly based on old functionTests test users.sql, except that
1:     // test used 2 databases. Possibly that was on the off-chance that
1:     // a second database would not work correctly - but that will not
1:     // be tested now.
1:     public void testConnectShutdownAuthentication() throws SQLException {
1:         
1:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:         
1:         // check connections while fullAccess (default) is set
1:         // note that builtinAuthentication has been set, as well as
1:         // authentication=true.
1:         
1:         // first try connection without user password
1:         assertConnectionFail(dbName);
1:         assertConnectionOK(dbName, "system", ("admin"));
1:         assertConnectionWOUPOK(dbName, "system", ("admin"));
1:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1:         assertConnectionWOUPOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         // try shutdown (but only dbo can do it)
0:         assertShutdownFail("2850H", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         assertShutdownWOUPFail("2850H", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         assertShutdownFail("2850H", dbName, "system", "admin");
0:         assertShutdownWOUPFail("2850H", dbName, "system", "admin");
0:         assertShutdownOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:         
1:         // ensure that a password is encrypted
1:         Connection conn1 = openDefaultConnection(
1:             "dan", ("dan" + PASSWORD_SUFFIX));
1:         Statement stmt = conn1.createStatement();
1:         ResultSet rs = stmt.executeQuery(
1:             "values SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.user.dan')");
1:         rs.next();
1:         assertNotSame(("dan"+PASSWORD_SUFFIX), rs.getString(1));
1:         conn1.commit();
1:         conn1.close();
1: 
1:         // specify full-access users.
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.fullAccessUsers", 
1:             "APP,system,nomen,francois,jeff", conn1);
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:         conn1.commit();
1: 
1:         // check the system wide user
1:         assertConnectionOK(dbName, "system", "admin"); 
1:         // check the non-existent, but allowed user
1:         assertConnectionFail("08004", dbName, "nomen", "nescio");
1:         assertConnectionWOUPFail("08004", dbName, "nomen", "nescio");
0:         // attempt to shutdown db as one of the allowed users, will fail...
0:         assertShutdownFail("2850H", dbName, "francois", ("francois" + PASSWORD_SUFFIX));
0:         // ...for only dbowner can shutdown db.
1:         assertShutdownWOUPOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:         // check simple connect ok as another allowed user, also revive db
1:         assertConnectionOK(dbName, "jeff", ("jeff" + PASSWORD_SUFFIX));
1:         // but dan wasn't on the list
0:         assertConnectionFail("04501", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         assertShutdownFail("04501", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
1: 
1:         // now change fullAccessUsers & test again
1:         conn1 = 
1:             openDefaultConnection("francois", ("francois" + PASSWORD_SUFFIX));
1:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:             "jeff,dan,francois,jamie", conn1);
1:         conn1.commit();
1:         conn1.close();
1:         assertConnectionOK(dbName, "dan", ("dan" + PASSWORD_SUFFIX)); 
0:         assertShutdownFail("2850H", dbName, "dan", ("dan" + PASSWORD_SUFFIX));
0:         // but dbo was not on list...
0:         assertShutdownFail("04501", dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1:         // now add dbo back in...
1:         conn1 = openDefaultConnection("francois", ("francois" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.database.fullAccessUsers", 
1:             "APP,jeff,dan,francois,jamie", conn1);
1:         conn1.commit();
1:         conn1.close();
1: 
1:         // Invalid logins
1:         // bad user
1:         assertConnectionFail("08004", dbName, "badUser", "badPwd");
1:         // just checking that it's still not working if we try again
1:         assertConnectionFail("08004", dbName, "badUser", "badPwd");
1:         // system is not on the list...
0:         assertConnectionFail("04501", dbName, "system", "admin");
1:         // dan's on the list, but this isn't the pwd
1:         assertConnectionFail("08004", dbName, "dan", "badPwd");
1:         assertConnectionFail("08004", dbName, "jamie", ("dan" + PASSWORD_SUFFIX));
1:         // check some shutdowns
0:         assertShutdownFail("04501", dbName, "system", "admin");
1:         assertShutdownFail("08004", dbName, "badUser", "badPwd");
1:         assertShutdownFail("08004", dbName, "dan", "badPwd");
1:         assertShutdownFail("08004", dbName, "badUser", ("dan" + PASSWORD_SUFFIX));
1:         
0:         // try system shutdown with wrong user
0:         assertSystemShutdownFail("08004", "", "badUser", ("dan" + PASSWORD_SUFFIX));
0:         // with 'allowed' user but bad pwd
0:         assertSystemShutdownFail("08004", "", "dan", ("jeff" + PASSWORD_SUFFIX));
0:         // dbo, but bad pwd
0:         assertSystemShutdownFail("08004", "", "APP", ("POO"));
0:         // allowed user but not dbo
0:         assertSystemShutdownFail("2850H", "", "dan", ("dan" + PASSWORD_SUFFIX));
1:         // expect Derby system shutdown, which gives XJ015 error.
1:         assertSystemShutdownOK("", "APP", ("APP" + PASSWORD_SUFFIX));
1:         
1:         // so far so good. set back security properties
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1: 
1:     // Experiment using USER, CURRENT_USER, etc.
1:     // also tests actual write activity
1:     public void testUserFunctions() throws SQLException
1:     {
1:         // use valid user/pwd to set the full accessusers.
1:         Connection conn1 = openDefaultConnection(
1:             "dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.fullAccessUsers", 
1:             "francois,jeff,ames,jerry,jamie,dan,system", conn1);
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:         conn1.commit();
1: 
1:         // we should still be connected as dan
1:         Statement stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 0, 
1:             "create table APP.t1(c1 varchar(30) check (UPPER(c1) <> 'JAMIE'))");
1:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:       
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1: 
1:         useUserValue(1, "jeff", "insert into APP.t1 values CURRENT_USER");
1:         useUserValue(1, "ames", "insert into APP.t1 values SESSION_USER");
1:         useUserValue(1, "jerry", "insert into APP.t1 values {fn user()}");
1:         assertUserValue(new String[] {"DAN","JEFF","AMES","JERRY"},
1:             "dan", "select * from APP.t1");
1:         // attempt some usage in where clause
1:         useUserValue(1,
1:             "dan", "update APP.t1 set c1 = 'edward' where c1 = USER");
1:         assertUserValue(new String[] {"JEFF"},"jeff",
1:             "select * from APP.t1 where c1 like CURRENT_USER");
1:         useUserValue(1, "ames", 
1:             "update APP.t1 set c1 = 'sema' where SESSION_USER = c1");
1:         useUserValue(1, "jerry", 
1:             "update APP.t1 set c1 = 'yrrej' where c1 like {fn user()}");
1:         assertUserValue(new String[] {"edward","JEFF","sema","yrrej"},
1:             "dan", "select * from APP.t1");
1:         useUserValue(4, "francois", "update APP.T1 set c1 = USER");
1:         assertUserValue(
1:             new String[] {"FRANCOIS","FRANCOIS","FRANCOIS","FRANCOIS"},
1:             "dan", "select * from APP.t1");
1: 
1:         // check that attempt to insert 'jamie' gives a check violation
1:         conn1 = openDefaultConnection("jamie", ("jamie" + PASSWORD_SUFFIX));
1:         stmt = conn1.createStatement();
1:         try {
1:             stmt.execute("insert into APP.t1 values CURRENT_USER");
1:         } catch (SQLException sqle) {
1:             assertSQLState("23513", sqle);
1:         }
1:         stmt.close();
1:         conn1.close();
1: 
1:         // Note: there is not much point in attempting to write with an invalid
1:         // user, that's already tested in the testConnectionShutdown fixture
1: 
1:         // reset
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
1:         stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 0, "drop table APP.t1");
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1: 
1:     public void testChangePasswordAndDatabasePropertiesOnly() 
1:     throws SQLException
1:     {
1:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1: 
1:         // use valid user/pwd to set the full accessusers.
1:         Connection conn1 = openDefaultConnection(
1:             "dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:             "dan,jeff,system", conn1);
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:         setDatabaseProperty(
1:                 "derby.database.requireAuthentication","true", conn1);
1:         
1:         conn1.commit();
1:         
1:         // check the system wide user
1:         assertConnectionOK(dbName, "system", "admin"); 
1:         assertConnectionFail("08004", dbName, "system", "otherSysPwd");
1:         assertConnectionOK(dbName, "jeff", ("jeff" + PASSWORD_SUFFIX));
1:         assertConnectionFail("08004", dbName, "jeff", "otherPwd");
1:         setDatabaseProperty("derby.user.jeff", "otherPwd", conn1);
1:         conn1.commit();
1:         // should have changed ok.
1:         assertConnectionOK(dbName, "jeff", "otherPwd");
1: 
1:         // note: if we do this:
1:         //  setDatabaseProperty("derby.user.system", "scndSysPwd", conn1);
1:         //  conn1.commit();
1:         // i.e. adding the same user (but different pwd) at database level,
1:         // then we cannot connect anymore using that user name, not with
1:         // either password.
1: 
1:         // force database props only
1:         setDatabaseProperty(
1:             "derby.database.propertiesOnly","true", conn1);
1:         conn1.commit();
1:         
1:         // now, should not be able to logon as system user
1:         assertConnectionFail("08004", dbName, "system", "admin");
1: 
1:         // reset propertiesOnly
1:         setDatabaseProperty(
1:             "derby.database.propertiesOnly","false", conn1);
1:         conn1.commit();
1:         assertConnectionOK(dbName, "system", "admin");
1:         
1:         // try changing system's pwd
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return java.lang.System.setProperty(
0:                         "derby.user.system", "thrdSysPwd");
1:                 }
0:         });
1: 
1:         // can we get in as system user with changed pwd
1:         assertConnectionOK(dbName, "system", "thrdSysPwd");
1:         
1:         // reset
1:         // first change system's pwd back
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return java.lang.System.setProperty(
0:                         "derby.user.system", "admin");
1:                 }
0:         });
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
1:         setDatabaseProperty(
1:                 "derby.database.propertiesOnly","false", conn1);
1:         conn1.commit();
1:         conn1.close();
1:     }
1:     
1:     public void testNotFullAccessUsers() throws SQLException
1:     {
1:         // use valid user/pwd to set the full accessusers.
1:         Connection conn1 = openDefaultConnection(
1:             "dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:             "dan,jamie,system", conn1);
1:         // cannot set a user to both full and readonly access...
1:         assertFailSetDatabaseProperty(
1:                 "derby.database.readOnlyAccessUsers", "jamie", conn1);
1:         setDatabaseProperty(
1:                 "derby.database.readOnlyAccessUsers", "ames,mickey", conn1);
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","NoAccess", conn1);
1:         setDatabaseProperty(
1:                 "derby.database.requireAuthentication","true", conn1);
1:         conn1.commit();
1: 
1:         // we should still be connected as dan
1:         Statement stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 0, 
1:             "create table APP.t1(c1 varchar(30) check (UPPER(c1) <> 'JAMIE'))");
1:         assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
1:       
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1: 
1:         // check full access system level user can update
1:         conn1 = openDefaultConnection("system", "admin");
1:         stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 1, "update APP.t1 set c1 = USER");
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:         
1:         // read only users
1:         assertUserValue(new String[] {"SYSTEM"},"ames", 
1:             "select * from APP.t1"); // should succeed
1:         conn1 = openDefaultConnection("ames", ("ames"+PASSWORD_SUFFIX));
1:         stmt = conn1.createStatement();
1:         assertStatementError(
1:             "25502", stmt, "delete from APP.t1 where c1 = 'SYSTEM'");
1:         assertStatementError("25502", stmt, "insert into APP.t1 values USER");
1:         assertStatementError(
1:             "25502", stmt, "update APP.t1 set c1 = USER where c1 = 'SYSTEM'");
1:         assertStatementError("25503", stmt, "create table APP.t2 (c1 int)");
1:         conn1.commit();
1:         stmt.close();
1:         // read-only system level user
1:         conn1 = openDefaultConnection("mickey", "mouse");
1:         stmt = conn1.createStatement();
1:         assertStatementError(
1:             "25502", stmt, "delete from APP.t1 where c1 = 'SYSTEM'");
1:         conn1.close();
1: 
1:         // reset
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
1:         stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, 0, "drop table APP.t1");
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1:     
1:     public void testGreekCharacters() throws SQLException {
1:         
1:         String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1: 
0:         // add a system level user
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     String zeus = "\u0396\u0395\u03A5\u03A3";
0:                     String apollo = "\u0391\u09A0\u039F\u039B\u039B\u039A\u0390";
0:                     return java.lang.System.setProperty(
0:                         ("derby.user." + apollo), zeus);
1:                 }
0:         });
1: 
1:         Connection conn1 = openDefaultConnection(
1:                 "dan", ("dan" + PASSWORD_SUFFIX));
1:         // add a database level user
1:         setDatabaseProperty(("derby.user." + zeus), apollo, conn1);
1:         setDatabaseProperty("derby.database.fullAccessUsers", 
1:                 ("dan,system,APP" + zeus + "," + apollo) , conn1);
1:         conn1.commit();
1:         conn1.close();
1:         
0:         // with network server / derbynet client, non-ascii isn't supported,
0:         // (or not working) see also DERBY-728, and
0:         // org.apache.derby.client.net.EbcdicCcsidManager
1:         if (usingDerbyNetClient())
1:         {
0:             assertConnectionFail("22005", dbName, zeus, apollo);
1:         }
0:         else {
0:             assertConnectionOK(dbName, zeus, apollo);
0:             assertConnectionFail("08004", dbName, apollo, apollo);
0:             // shutdown only allowd by DBO
0:             assertShutdownFail("2850H", dbName, zeus, apollo);
0:             assertConnectionOK(dbName, apollo, zeus);
0:             assertShutdownFail("08004", dbName, zeus, zeus);
0:             assertShutdownFail("2850H", dbName, apollo, zeus);
0:             assertShutdownOK(dbName, "APP", ("APP" + PASSWORD_SUFFIX));
1: 
0:             conn1 = openDefaultConnection(zeus, apollo);
1:             Statement stmt = conn1.createStatement();
1:             assertUpdateCount(stmt, 0, 
0:             "create table APP.t1(c1 varchar(30))");
1:             assertUpdateCount(stmt, 1, "insert into APP.t1 values USER");
0:             assertUserValue(new String[] {zeus}, zeus, apollo,
1:             "select * from APP.t1 where c1 like CURRENT_USER");
1:             conn1.commit();
1:             stmt.close();
1:             conn1.close();
1:         }
1:         
1:         // reset
1:         conn1 = openDefaultConnection("dan", ("dan" + PASSWORD_SUFFIX));
1:         setDatabaseProperty(
1:             "derby.database.defaultConnectionMode","fullAccess", conn1);
1:         setDatabaseProperty(
1:             "derby.connection.requireAuthentication","false", conn1);
1:         Statement stmt = conn1.createStatement();
1:         if (usingEmbedded())
1:             assertUpdateCount(stmt, 0, "drop table APP.t1");
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1:     
1:     protected void assertFailSetDatabaseProperty(
1:         String propertyName, String value, Connection conn) 
1:     throws SQLException {
1:         CallableStatement setDBP =  conn.prepareCall(
1:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:         setDBP.setString(1, propertyName);
1:         setDBP.setString(2, value);
1:         // user jamie cannot be both readOnly and fullAccess
0:         assertStatementError("28503", setDBP);
1:     }
1:     
1:     protected void setDatabaseProperty(
1:         String propertyName, String value, Connection conn) 
1:     throws SQLException {
1:         CallableStatement setDBP =  conn.prepareCall(
1:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:         setDBP.setString(1, propertyName);
1:         setDBP.setString(2, value);
1:         setDBP.execute();
1:     }
1:     
1:     protected void useUserValue(int expectedUpdateCount, String user, String sql)
1:     throws SQLException
1:     {
1:         Connection conn1 = openDefaultConnection(user, user + PASSWORD_SUFFIX);
1:         Statement stmt = conn1.createStatement();
1:         assertUpdateCount(stmt, expectedUpdateCount, sql);
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1:     
1:     protected void assertUserValue(
1:         String[] expected, String user, String password, String sql)
1:     throws SQLException
1:     {
1:         Connection conn1 = openDefaultConnection(user, password);
1:         Statement stmt = conn1.createStatement();
1:         ResultSet rs = stmt.executeQuery(sql);
1:         int i = 0; 
1:         while (rs.next())
1:         {
1:             assertEquals(expected[i],rs.getString(1));
1:             i++;
1:         }
1:         assertEquals(expected.length, i);
1:         conn1.commit();
1:         stmt.close();
1:         conn1.close();
1:     }
1:     
1:     // convenience method, password is often using PASSWORD_SUFFIX
1:     protected void assertUserValue(String[] expected, String user, String sql)
1:     throws SQLException {
1:         assertUserValue(expected, user, (user + PASSWORD_SUFFIX), sql);
1:     }
1:     
1:     protected void assertConnectionOK(
1:          String dbName, String user, String password)
1:     throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         try {
0:             assertNotNull(ds.getConnection(user, password));
1:         }
1:         catch (SQLException e) {
0:             throw e;
1:         }
1:     }
1:     
0:     // getConnection(), using setConnectionAttributes
1:     protected void assertConnectionWOUPOK(
1:         String dbName, String user, String password)
1:     throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
0:             assertNotNull(ds.getConnection());
1:         }
1:         catch (SQLException e) {
0:             throw e;
1:         }
1:     }
1:     
1:     protected void assertConnectionFail(
1:         String expectedSqlState, String dbName, String user, String password)
1:     throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         try {
0:             ds.getConnection(user, password);
1:             fail("Connection should've been refused/failed");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState(expectedSqlState, e);
1:         }
1:     }
1: 
0:     // connection without user and password
1:     protected void assertConnectionWOUPFail(
1:         String expectedError, String dbName, String user, String password) 
1:     throws SQLException 
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
1:                 ds.getConnection();
1:                 fail("Connection should've been refused/failed");
1:         }
1:         catch (SQLException e) {
1:                 assertSQLState(expectedError, e);
1:         }
1:     }
1: 
0:     protected void assertShutdownOK(
1:         String dbName, String user, String password)
1:     throws SQLException {
1: 
1:         if (usingEmbedded())
1:         {
1:             DataSource ds = JDBCDataSource.getDataSource(dbName);
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
0:                 // expect 08006 on successful shutdown
0:                 assertSQLState("08006", e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             ds.setConnectionAttributes("shutdown=true");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
0:                 // expect 08006 on successful shutdown
0:                 assertSQLState("08006", e);
1:             }
1:         }
1:     }
1: 
1:     protected void assertShutdownWOUPOK(
1:         String dbName, String user, String password)
1:     throws SQLException {
1: 
1:         if (usingEmbedded())
1:         {
1:             DataSource ds = JDBCDataSource.getDataSource(dbName);
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             JDBCDataSource.setBeanProperty(ds, "user", user);
1:             JDBCDataSource.setBeanProperty(ds, "password", password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
0:                 // expect 08006 on successful shutdown
0:                 assertSQLState("08006", e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             ds.setConnectionAttributes(
0:                     "shutdown=true;user=" + user + ";password="+password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
0:                 // expect 08006 on successful shutdown
0:                 assertSQLState("08006", e);
1:             }
1:         }
1:     }
1:     
1:     protected void assertShutdownFail(
1:         String expectedSqlState, String dbName, String user, String password) 
1:     throws SQLException
1:     {
1: 
0:         // with DerbyNetClient there is no Datasource setShutdownDatabase method
1:         if (usingEmbedded()) 
1:         {
1:             DataSource ds = JDBCDataSource.getDataSource(dbName);
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedSqlState, e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             ds.setConnectionAttributes("shutdown=true");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedSqlState, e);
1:             }
1:         }
1:     }
1:     
1:     protected void assertShutdownWOUPFail(
1:         String expectedSqlState, String dbName, String user, String password) 
1:     throws SQLException
1:     {
0:         // with DerbyNetClient there is no Datasource setShutdownDatabase 
0:         // method so can't use the setBeanProperty
1:         if (usingEmbedded()) 
1:         {
1:             DataSource ds = JDBCDataSource.getDataSource(dbName);
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             JDBCDataSource.setBeanProperty(ds, "user", user);
1:             JDBCDataSource.setBeanProperty(ds, "password", password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedSqlState, e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             ds.setConnectionAttributes(
0:                 "shutdown=true;user=" + user + ";password="+password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedSqlState, e);
1:             }
1:         }
1:     }
1:     
1:     protected void assertSystemShutdownOK(
1:         String dbName, String user, String password)
1:     throws SQLException {
1:         if (usingEmbedded())
1:         {
1:             DataSource ds = JDBCDataSource.getDataSource(dbName);
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected system shutdown resulting in XJ015 error");
0:             } catch (SQLException e) {
0:                 // expect XJ015, system shutdown, on successful shutdown
0:                 assertSQLState("XJ015", e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource(dbName);
0:             ds.setConnectionAttributes("shutdown=true");
1:             try {
0:                 ds.getConnection(user, password);
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
0:                 // expect XJ015 on successful shutdown
0:                 assertSQLState("XJ015", e);
1:             }
1:         }
1:     }
1: 
0:     // Note, we need a separate method for fail & OK because something
0:     // the framework will add the wrong details. If we use
0:     // getDataSource(dbName), we don't get a successful XJ015, ever,
0:     // if we use getDataSource(), it appears the user/password on connect
0:     // is ignored, at least, we get XJ015 anyway.
0:     // 
1:     protected void assertSystemShutdownFail(
1:         String expectedError, String dbName, String user, String password)
1:     throws SQLException {
1:         if (usingEmbedded())
1:         {
0:             DataSource ds = JDBCDataSource.getDataSource();
0:             JDBCDataSource.setBeanProperty(ds, "shutdownDatabase", "shutdown");
1:             JDBCDataSource.setBeanProperty(ds, "user", user);
1:             JDBCDataSource.setBeanProperty(ds, "password", password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedError, e);
1:             }
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = 
0:                 (ClientDataSource)JDBCDataSource.getDataSource();
0:             ds.setConnectionAttributes(
0:                 "shutdown=true;user=" + user + ";password=" + password);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected shutdown to fail");
0:             } catch (SQLException e) {
1:                 assertSQLState(expectedError, e);
1:             }
1:         }
1:     }
1:     
1:     public void assertConnectionFail(String dbName) throws SQLException {
0:         // this method needs to create DataSources without relying on
0:         // the JDBC methods, because those use a default user/pwd
0:         // (APP, APP).
1:         if (usingDerbyNetClient())
1:         {
0:             ClientDataSource ds = new ClientDataSource();
0:             ds.setDatabaseName(dbName);
1:             try {
1:                 ds.getConnection();
0:                 fail("expected connection to fail");
0:             } catch (SQLException e) {
0:                 assertSQLState("08004", e);
1:             }
1:         }
0:         else if (usingEmbedded()) 
1:         {
0:             if (JDBC.vmSupportsJSR169())
1:             {
0:                 EmbeddedSimpleDataSource ds = new EmbeddedSimpleDataSource();
0:                 ds.setDatabaseName(dbName);
1:                 try {
1:                     ds.getConnection();
0:                     fail("expected connection to fail");
0:                 } catch (SQLException e) {
0:                     assertSQLState("08004", e);
1:                 }
1:             }
0:             else
1:             {
0:                 EmbeddedDataSource ds = new EmbeddedDataSource();
0:                 ds.setDatabaseName(dbName);
1:                 try {
1:                     ds.getConnection();
0:                     fail("expected connection to fail");
0:                 } catch (SQLException e) {
0:                     assertSQLState("08004", e);
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================