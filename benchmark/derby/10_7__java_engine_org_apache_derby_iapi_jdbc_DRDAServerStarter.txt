1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.jdbc.DRDAServerStarter
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
5:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.jdbc;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.reference.MessageId;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import java.io.PrintWriter;
1:eac0369: import java.lang.Runnable;
1:eac0369: import java.lang.Thread;
1:eac0369: import java.lang.reflect.Constructor;
1:eac0369: import java.lang.reflect.Method;
1:eac0369: import java.lang.reflect.InvocationTargetException;
1:eac0369: import java.net.InetAddress;
1:eac0369: import java.security.AccessController;
1:6d8a24d: import java.security.PrivilegedAction;
1:eac0369: import java.security.PrivilegedActionException;
1:eac0369: import java.security.PrivilegedExceptionAction;
1:eac0369: 
1:5b5091f: /**
1:5b5091f:  * Class that starts the network server in its own daemon thread.
1:5b5091f:  * Works in two situations.
1:5b5091f:  * <BR>
1:5b5091f:  * As a module in the engine's Monitor, booted if the
1:5b5091f:  * property derby.drda.startNetworkServer is set to true.
1:5b5091f:  * In this case the boot and shutdown is through the
1:5b5091f:  * standard ModuleControl methods.
1:5b5091f:  * <BR>
1:5b5091f:  * Direct calls from the NetworkServerControlImpl start methods.
1:5b5091f:  * This is to centralize the creation of the daemon thread in
1:5b5091f:  * this class in the engine code, since the Monitor provides
1:5b5091f:  * the thread. This means that NetworkServerControlImpl calls
1:5b5091f:  * this class to create a thread which in turn calls back
1:5b5091f:  * to NetworkServerControlImpl.runServer to start the server.
1:acfc688:  *
1:5b5091f:  * @see ModuleControl#boot
1:5b5091f:  * @see ModuleControl#stop
1:5b5091f:  */
1:7a92d1f: public final class DRDAServerStarter implements ModuleControl, Runnable
1:eac0369: {
1:5b5091f:     /**
1:5b5091f:      * The instance of the NetworkServerControlImpl
1:5b5091f:      * being used to run the server.
1:5b5091f:      */
1:eac0369:     private Object server;
1:5b5091f:     
1:5b5091f:     /**
1:5b5091f:      * Reflect reference to the method to run the server.
1:5b5091f:      * NetworkServerControlImpl.blockingStart
1:5b5091f:      */
1:5b5091f:     private Method runServerMethod;
1:5b5091f:     
1:5b5091f:     /**
1:5b5091f:      * Reflect reference to the method to directly
1:5b5091f:      * shutdown the server.
1:5b5091f:      * NetworkServerControlImpl.directShutdown
1:5b5091f:      */
1:5b5091f:     private Method serverShutdownMethod;
1:5b5091f: 
1:eac0369:     private Thread serverThread;
1:9085abb:     private static final String serverClassName = "org.apache.derby.impl.drda.NetworkServerControlImpl";
1:71c8e86:     private Class<?> serverClass;
1:eac0369: 	
1:eac0369: 	private InetAddress listenAddress =null;
1:eac0369: 	private int portNumber = -1;
1:204c040: 	private String userArg = null;
1:204c040: 	private String passwordArg = null;
1:eac0369: 	private PrintWriter consoleWriter = null;
1:eac0369: 
2:eac0369:     /**
1:eac0369:      * Try to start the DRDA server. Log an error in error log and continue if it cannot be started.
1:eac0369:      */
1:eac0369: //     public static void start()
1:eac0369: //     {
1:eac0369: 
1:eac0369: 
1:204c040: 	/**
1:204c040: 	 * Sets configuration information for the network server to be started.
1:acfc688: 	 * @param listenAddress InetAddress to listen on
1:acfc688: 	 * @param portNumber    portNumber to listen on
1:acfc688: 	 * @param userName      the user name for actions requiring authorization
1:acfc688: 	 * @param password      the password for actions requiring authorization
1:204c040: 	 */
1:204c040: 	public void setStartInfo(InetAddress listenAddress, int portNumber,
1:204c040:                              String userName, String password,
1:204c040:                              PrintWriter consoleWriter)
1:204c040: 	{
1:204c040: 		this.userArg = userName;
1:204c040: 		this.passwordArg = password;
1:204c040:         setStartInfo(listenAddress, portNumber, consoleWriter);
1:204c040:     }
1:204c040: 
1:eac0369: 	public void setStartInfo(InetAddress listenAddress, int portNumber, PrintWriter
1:eac0369: 							 consoleWriter)
1:eac0369: 	{
1:eac0369: 		this.listenAddress = listenAddress;
1:eac0369: 		this.portNumber = portNumber;
1:5b5091f: 
1:0f5040a:         // wrap the user-set consoleWriter with autoflush to true.
1:0f5040a:         // this will ensure that messages to console will be 
1:0f5040a:         // written out to the consoleWriter on a println.
1:0f5040a:         // DERBY-1466
1:0f5040a:         if (consoleWriter != null)
1:0f5040a:             this.consoleWriter = new PrintWriter(consoleWriter,true);
1:eac0369:         else
1:eac0369:             this.consoleWriter = consoleWriter;
2:eac0369: 	}
1:5b5091f: 
1:5b5091f:     /**
1:5b5091f:      * Find the methods to start and shutdown the server.
1:5b5091f:      * Perfomed through reflection so that the engine
1:5b5091f:      * code is not dependent on the network server code.
1:5b5091f:      * @param serverClass
1:5b5091f:      * @throws NoSuchMethodException 
1:5b5091f:      * @throws SecurityException 
1:5b5091f:      */
1:71c8e86:     private void findStartStopMethods(final Class<?> serverClass)
1:5b5091f:         throws SecurityException, NoSuchMethodException
1:5b5091f:     {
1:5b5091f:         // Methods are public so no need for privilege blocks.
1:5b5091f:         runServerMethod = serverClass.getMethod(
1:5b5091f:                 "blockingStart", new Class[] { java.io.PrintWriter.class});
1:5b5091f:                
1:5b5091f:         serverShutdownMethod = serverClass.getMethod(
1:5b5091f:                 "directShutdown", null);
1:5b5091f:     }
1:eac0369: 
1:eac0369:     public void boot(boolean create,
1:eac0369:                      java.util.Properties properties)
1:eac0369:     {
1:eac0369:         if( server != null)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.THROWASSERT( "Network server starter module booted twice.");
1:eac0369:             return;
1:eac0369:         }
1:3fd26f3:         // Load the server class indirectly so that Derby does not require the network code
1:eac0369:         try
1:eac0369:         {
1:eac0369:             serverClass = Class.forName( serverClassName);
1:eac0369:         }
1:eac0369:         catch( ClassNotFoundException cnfe)
1:eac0369:         {
1:eac0369:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_FIND, serverClassName);
1:eac0369:             return;
1:eac0369:         }
1:eac0369:         catch( java.lang.Error e)
1:eac0369:         {
1:eac0369:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_LOAD,
1:eac0369:                                     serverClassName,
1:eac0369:                                     e.getMessage());
1:eac0369:             return;
1:eac0369:         }
1:eac0369:         try
1:eac0369:         {
1:eac0369:             Constructor  serverConstructor;
1:eac0369:             try
1:eac0369:             {
1:71c8e86:                 serverConstructor = AccessController.doPrivileged(
1:71c8e86: 			      new PrivilegedExceptionAction<Constructor>() {
1:71c8e86: 						  public Constructor run() throws NoSuchMethodException, SecurityException
1:eac0369: 						  {
2:eac0369: 							  if (listenAddress == null)
1:204c040: 								  return serverClass.getConstructor(
1:204c040:                                       new Class[]{String.class, String.class});
1:eac0369: 							  else
1:eac0369: 								  return
1:117d8b5: 									  serverClass.getConstructor(new
1:eac0369: 										  Class[] {java.net.InetAddress.class,
1:204c040: 												   Integer.TYPE,
1:204c040:                                                    String.class,
1:204c040:                                                    String.class});
1:204c040:                           }
1:eac0369: 					  }
3:eac0369: 				  );
1:eac0369:             }
1:eac0369:             catch( PrivilegedActionException e)
1:eac0369:             {
1:eac0369:                 Exception e1 = e.getException();
1:eac0369:                 Monitor.logTextMessage(
1:eac0369: 									   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e1.getMessage());
1:eac0369: 				e.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369:                 return;
1:eac0369: 
1:eac0369:             }
1:eac0369:             
1:5b5091f:             findStartStopMethods(serverClass);
1:eac0369:             
1:204c040: 			if (listenAddress == null) {
1:204c040: 				server = serverConstructor.newInstance(
1:204c040:                     new Object[]{userArg, passwordArg});
1:204c040:             } else {
1:eac0369: 				server = serverConstructor.newInstance(new Object[]
1:ce40a31: 					{listenAddress, portNumber,
1:204c040:                      userArg, passwordArg});
1:204c040:             }
1:eac0369: 
1:56c1dc2:             serverThread = getMonitor().getDaemonThread( this, "NetworkServerStarter", false);
1:eac0369:             serverThread.start();
1:eac0369:         }
1:eac0369:         catch( Exception e)
1:eac0369:         {
1:eac0369: 			Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
1:eac0369: 			server = null;
1:eac0369: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369:         }
1:eac0369:     } // end of boot
1:eac0369: 
1:eac0369:     public void run()
1:eac0369:     {
1:eac0369:         try
1:eac0369:         {
1:5b5091f:             runServerMethod.invoke( server,
1:eac0369:                                       new Object[] {consoleWriter });
1:eac0369:         }
1:eac0369:         catch( InvocationTargetException ite)
1:eac0369:         {
1:eac0369:             Monitor.logTextMessage(
1:eac0369: 								   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, ite.getTargetException().getMessage());
1:eac0369: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369: 
1:eac0369:             server = null;
1:eac0369:         }
1:eac0369:         catch( Exception e)
1:eac0369:         {
1:eac0369:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
1:eac0369:             server = null;
1:eac0369: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369:         }
1:eac0369:     }
1:eac0369:     
1:eac0369:     public void stop()
1:eac0369:     {
1:eac0369: 		try {
1:eac0369: 			if( serverThread != null && serverThread.isAlive())
1:eac0369: 			{
1:eac0369: 				serverShutdownMethod.invoke( server,
1:eac0369: 											 null);
1:6d8a24d: 				AccessController.doPrivileged(
1:71c8e86: 							      new PrivilegedAction<Object>() {
1:6d8a24d: 								  public Object run() {
1:eac0369: 								      serverThread.interrupt();
1:6d8a24d: 								      return null;
1:eac0369: 								  }
1:6d8a24d: 							      });				
1:eac0369: 				serverThread = null;
1:eac0369: 			}
1:eac0369: 		   
1:eac0369: 		}
1:eac0369: 		catch( InvocationTargetException ite)
1:eac0369:         {
1:eac0369: 			Monitor.logTextMessage(
1:eac0369: 								   MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, ite.getTargetException().getMessage());
1:eac0369: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369: 			
1:eac0369:         }
1:eac0369:         catch( Exception e)
1:eac0369:         {
1:eac0369:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, e.getMessage());
1:eac0369: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		serverThread = null;
1:eac0369: 		server = null;
1:eac0369: 		serverClass = null;
1:eac0369: 		listenAddress = null;
1:eac0369: 		portNumber = -1;
1:eac0369: 		consoleWriter = null;
1:eac0369: 		
1:eac0369:     } // end of stop
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 					{listenAddress, portNumber,
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1:             serverThread = getMonitor().getDaemonThread( this, "NetworkServerStarter", false);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     private Class<?> serverClass;
/////////////////////////////////////////////////////////////////////////
1:     private void findStartStopMethods(final Class<?> serverClass)
/////////////////////////////////////////////////////////////////////////
1:                 serverConstructor = AccessController.doPrivileged(
1: 			      new PrivilegedExceptionAction<Constructor>() {
1: 						  public Constructor run() throws NoSuchMethodException, SecurityException
/////////////////////////////////////////////////////////////////////////
1: 							      new PrivilegedAction<Object>() {
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c572068
/////////////////////////////////////////////////////////////////////////
commit:acfc688
/////////////////////////////////////////////////////////////////////////
1: 	 * @param listenAddress InetAddress to listen on
1: 	 * @param portNumber    portNumber to listen on
1: 	 * @param userName      the user name for actions requiring authorization
1: 	 * @param password      the password for actions requiring authorization
1:      *
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:204c040
/////////////////////////////////////////////////////////////////////////
1: 	private String userArg = null;
1: 	private String passwordArg = null;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Sets configuration information for the network server to be started.
0: 	 * @param address InetAddress to listen on
0: 	 * @param portNumber portNumber to listen on
0: 	 * @param userName the user name for actions requiring authorization
0: 	 * @param password the password for actions requiring authorization
0: 	 * @throws Exception on error
0: 	 * @see NetworkServerControl
1: 	 */
1: 	public void setStartInfo(InetAddress listenAddress, int portNumber,
1:                              String userName, String password,
1:                              PrintWriter consoleWriter)
1: 	{
1: 		this.userArg = userName;
1: 		this.passwordArg = password;
1:         setStartInfo(listenAddress, portNumber, consoleWriter);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 								  return serverClass.getConstructor(
1:                                       new Class[]{String.class, String.class});
1: 												   Integer.TYPE,
1:                                                    String.class,
1:                                                    String.class});
1:                           }
/////////////////////////////////////////////////////////////////////////
1: 			if (listenAddress == null) {
1: 				server = serverConstructor.newInstance(
1:                     new Object[]{userArg, passwordArg});
1:             } else {
0: 					{listenAddress, new Integer(portNumber),
1:                      userArg, passwordArg});
1:             }
commit:5b5091f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Class that starts the network server in its own daemon thread.
1:  * Works in two situations.
1:  * <BR>
1:  * As a module in the engine's Monitor, booted if the
1:  * property derby.drda.startNetworkServer is set to true.
1:  * In this case the boot and shutdown is through the
1:  * standard ModuleControl methods.
1:  * <BR>
1:  * Direct calls from the NetworkServerControlImpl start methods.
1:  * This is to centralize the creation of the daemon thread in
1:  * this class in the engine code, since the Monitor provides
1:  * the thread. This means that NetworkServerControlImpl calls
1:  * this class to create a thread which in turn calls back
1:  * to NetworkServerControlImpl.runServer to start the server.
0:  *
1:  * @see ModuleControl#boot
1:  * @see ModuleControl#stop
1:  */
1:     /**
1:      * The instance of the NetworkServerControlImpl
1:      * being used to run the server.
1:      */
1:     
1:     /**
1:      * Reflect reference to the method to run the server.
1:      * NetworkServerControlImpl.blockingStart
1:      */
1:     private Method runServerMethod;
1:     
1:     /**
1:      * Reflect reference to the method to directly
1:      * shutdown the server.
1:      * NetworkServerControlImpl.directShutdown
1:      */
1:     private Method serverShutdownMethod;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Find the methods to start and shutdown the server.
1:      * Perfomed through reflection so that the engine
1:      * code is not dependent on the network server code.
1:      * @param serverClass
1:      * @throws NoSuchMethodException 
1:      * @throws SecurityException 
1:      */
0:     private void findStartStopMethods(final Class serverClass)
1:         throws SecurityException, NoSuchMethodException
1:     {
1:         // Methods are public so no need for privilege blocks.
1:         runServerMethod = serverClass.getMethod(
1:                 "blockingStart", new Class[] { java.io.PrintWriter.class});
1:                
1:         serverShutdownMethod = serverClass.getMethod(
1:                 "directShutdown", null);
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
1:             findStartStopMethods(serverClass);
1:             
/////////////////////////////////////////////////////////////////////////
1:             runServerMethod.invoke( server,
/////////////////////////////////////////////////////////////////////////
commit:117d8b5
/////////////////////////////////////////////////////////////////////////
0: 								  return serverClass.getConstructor(null);
1: 									  serverClass.getConstructor(new
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
1: public final class DRDAServerStarter implements ModuleControl, Runnable
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.jdbc.DRDAServerStarter
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.jdbc;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.reference.Property;
1: import java.io.PrintWriter;
1: import java.lang.Runnable;
1: import java.lang.Thread;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.InvocationTargetException;
1: import java.net.InetAddress;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: 
0: public class DRDAServerStarter implements ModuleControl, Runnable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1:     private Object server;
0:     private Method serverStartMethod;
0: 	private Method serverShutdownMethod;
0:     private boolean loadSysIBM;
1:     private Thread serverThread;
0:     private static final String serverClassName = "org.apache.derby.impl.drda.DB2jServerImpl";
0:     private Class serverClass;
1: 	
1: 	private InetAddress listenAddress =null;
1: 	private int portNumber = -1;
1: 	private PrintWriter consoleWriter = null;
1: 
1:     /**
1:      * Try to start the DRDA server. Log an error in error log and continue if it cannot be started.
1:      */
1: //     public static void start()
1: //     {
1: 
1: 
1: 	public void setStartInfo(InetAddress listenAddress, int portNumber, PrintWriter
1: 							 consoleWriter)
1: 	{
1: 		this.listenAddress = listenAddress;
1: 		this.portNumber = portNumber;
1: 		this.consoleWriter = consoleWriter;
1: 	}
1: 
1: 
1: 
1:     public void boot(boolean create,
1:                      java.util.Properties properties)
1:     {
1:         if( server != null)
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.THROWASSERT( "Network server starter module booted twice.");
1:             return;
1:         }
0:         // Load the server class indirectly so that Cloudscape does not require the network code
1:         try
1:         {
1:             serverClass = Class.forName( serverClassName);
1:         }
1:         catch( ClassNotFoundException cnfe)
1:         {
1:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_FIND, serverClassName);
1:             return;
1:         }
1:         catch( java.lang.Error e)
1:         {
1:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_LOAD,
1:                                     serverClassName,
1:                                     e.getMessage());
1:             return;
1:         }
1:         try
1:         {
1:             Constructor  serverConstructor;
1:             try
1:             {
0:                 serverConstructor = (Constructor) AccessController.doPrivileged(
0: 			      new PrivilegedExceptionAction() {
0: 						  public Object run() throws NoSuchMethodException, SecurityException
1: 						  {
1: 							  if (listenAddress == null)
0: 								  return serverClass.getDeclaredConstructor(null);
1: 							  else
1: 								  return
0: 									  serverClass.getDeclaredConstructor(new
1: 										  Class[] {java.net.InetAddress.class,
0: 												   Integer.TYPE});}
1: 					  }
1: 				  );
0: 				serverStartMethod = (Method) AccessController.doPrivileged(
0: 				   new PrivilegedExceptionAction() {
0: 						   public Object run() throws NoSuchMethodException, SecurityException
0: 						   { return serverClass.getMethod( "blockingStart", new Class[] { java.io.PrintWriter.class});}
1: 					   }
1: 				   );
1: 				
0: 				serverShutdownMethod = (Method) AccessController.doPrivileged(
0: 				   new PrivilegedExceptionAction() {
0: 						   public Object run() throws NoSuchMethodException, SecurityException
0: 						   { return serverClass.getMethod( "directShutdown", null);}
1: 					   }
1: 				   );
1:             }
1:             catch( PrivilegedActionException e)
1:             {
1:                 Exception e1 = e.getException();
1:                 Monitor.logTextMessage(
1: 									   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e1.getMessage());
1: 				e.printStackTrace(Monitor.getStream().getPrintWriter());
1:                 return;
1: 
1:             }
1: 			if (listenAddress == null)
0: 				server = serverConstructor.newInstance( null);
1: 			else
1: 				server = serverConstructor.newInstance(new Object[]
0: 					{listenAddress, new Integer(portNumber)});
1: 
0:             serverThread = Monitor.getMonitor().getDaemonThread( this, "NetworkServerStarter", false);
1:             serverThread.start();
1:         }
1:         catch( Exception e)
1:         {
1: 			Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
1: 			server = null;
1: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1:         }
1:     } // end of boot
1: 
1:     public void run()
1:     {
1:         try
1:         {
0:             serverStartMethod.invoke( server,
1:                                       new Object[] {consoleWriter });
1:         }
1:         catch( InvocationTargetException ite)
1:         {
1:             Monitor.logTextMessage(
1: 								   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, ite.getTargetException().getMessage());
1: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
1: 
1:             server = null;
1:         }
1:         catch( Exception e)
1:         {
1:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
1:             server = null;
1: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1:         }
1:     }
1:     
1:     public void stop()
1:     {
1: 		try {
1: 			if( serverThread != null && serverThread.isAlive())
1: 			{
1: 				serverShutdownMethod.invoke( server,
1: 											 null);
1: 				serverThread.interrupt();
1: 				serverThread = null;
1: 			}
1: 		   
1: 		}
1: 		catch( InvocationTargetException ite)
1:         {
1: 			Monitor.logTextMessage(
1: 								   MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, ite.getTargetException().getMessage());
1: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
1: 			
1:         }
1:         catch( Exception e)
1:         {
1:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, e.getMessage());
1: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
1: 		}
1: 			
1: 		serverThread = null;
1: 		server = null;
1: 		serverClass = null;
0: 		serverStartMethod = null;
0: 		serverShutdownMethod = null;
1: 		listenAddress = null;
1: 		portNumber = -1;
1: 		consoleWriter = null;
1: 		
1:     } // end of stop
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6d8a24d
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 				AccessController.doPrivileged(
0: 							      new PrivilegedAction() {
1: 								  public Object run() {
0: 								      serverThread.interrupt();
1: 								      return null;
0: 								  }
1: 							      });				
commit:9085abb
/////////////////////////////////////////////////////////////////////////
1:     private static final String serverClassName = "org.apache.derby.impl.drda.NetworkServerControlImpl";
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1:         // Load the server class indirectly so that Derby does not require the network code
author:David Van Couvering
-------------------------------------------------------------------------------
commit:0f5040a
/////////////////////////////////////////////////////////////////////////
0: 
1:         // wrap the user-set consoleWriter with autoflush to true.
1:         // this will ensure that messages to console will be 
1:         // written out to the consoleWriter on a println.
1:         // DERBY-1466
1:         if (consoleWriter != null)
1:             this.consoleWriter = new PrintWriter(consoleWriter,true);
0:         else
0:             this.consoleWriter = consoleWriter;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.jdbc;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.reference.Property;
0: import java.io.PrintWriter;
0: import java.lang.Runnable;
0: import java.lang.Thread;
0: import java.lang.reflect.Constructor;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.InvocationTargetException;
0: import java.net.InetAddress;
0: import java.security.AccessController;
0: import java.security.PrivilegedActionException;
0: import java.security.PrivilegedExceptionAction;
0: 
0: public class DRDAServerStarter implements ModuleControl, Runnable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0:     private Object server;
0:     private Method serverStartMethod;
0: 	private Method serverShutdownMethod;
0:     private boolean loadSysIBM;
0:     private Thread serverThread;
0:     private static final String serverClassName = "org.apache.derby.impl.drda.DB2jServerImpl";
0:     private Class serverClass;
0: 	
0: 	private InetAddress listenAddress =null;
0: 	private int portNumber = -1;
0: 	private PrintWriter consoleWriter = null;
0: 
0:     /**
0:      * Try to start the DRDA server. Log an error in error log and continue if it cannot be started.
0:      */
0: //     public static void start()
0: //     {
0: 
0: 
0: 	public void setStartInfo(InetAddress listenAddress, int portNumber, PrintWriter
0: 							 consoleWriter)
0: 	{
0: 		this.listenAddress = listenAddress;
0: 		this.portNumber = portNumber;
0: 		this.consoleWriter = consoleWriter;
0: 	}
0: 
0: 
0: 
0:     public void boot(boolean create,
0:                      java.util.Properties properties)
0:     {
0:         if( server != null)
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.THROWASSERT( "Network server starter module booted twice.");
0:             return;
0:         }
0:         // Load the server class indirectly so that Cloudscape does not require the network code
0:         try
0:         {
0:             serverClass = Class.forName( serverClassName);
0:         }
0:         catch( ClassNotFoundException cnfe)
0:         {
0:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_FIND, serverClassName);
0:             return;
0:         }
0:         catch( java.lang.Error e)
0:         {
0:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_LOAD,
0:                                     serverClassName,
0:                                     e.getMessage());
0:             return;
0:         }
0:         try
0:         {
0:             Constructor  serverConstructor;
0:             try
0:             {
0:                 serverConstructor = (Constructor) AccessController.doPrivileged(
0: 			      new PrivilegedExceptionAction() {
0: 						  public Object run() throws NoSuchMethodException, SecurityException
0: 						  {
0: 							  if (listenAddress == null)
0: 								  return serverClass.getDeclaredConstructor(null);
0: 							  else
0: 								  return
0: 									  serverClass.getDeclaredConstructor(new
0: 										  Class[] {java.net.InetAddress.class,
0: 												   Integer.TYPE});}
0: 					  }
0: 				  );
0: 				serverStartMethod = (Method) AccessController.doPrivileged(
0: 				   new PrivilegedExceptionAction() {
0: 						   public Object run() throws NoSuchMethodException, SecurityException
0: 						   { return serverClass.getMethod( "blockingStart", new Class[] { java.io.PrintWriter.class});}
0: 					   }
0: 				   );
0: 				
0: 				serverShutdownMethod = (Method) AccessController.doPrivileged(
0: 				   new PrivilegedExceptionAction() {
0: 						   public Object run() throws NoSuchMethodException, SecurityException
0: 						   { return serverClass.getMethod( "directShutdown", null);}
0: 					   }
0: 				   );
0:             }
0:             catch( PrivilegedActionException e)
0:             {
0:                 Exception e1 = e.getException();
0:                 Monitor.logTextMessage(
0: 									   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e1.getMessage());
0: 				e.printStackTrace(Monitor.getStream().getPrintWriter());
0:                 return;
0: 
0:             }
0: 			if (listenAddress == null)
0: 				server = serverConstructor.newInstance( null);
0: 			else
0: 				server = serverConstructor.newInstance(new Object[]
0: 					{listenAddress, new Integer(portNumber)});
0: 
0:             serverThread = Monitor.getMonitor().getDaemonThread( this, "NetworkServerStarter", false);
0:             serverThread.start();
0:         }
0:         catch( Exception e)
0:         {
0: 			Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
0: 			server = null;
0: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
0:         }
0:     } // end of boot
0: 
0:     public void run()
0:     {
0:         try
0:         {
0:             serverStartMethod.invoke( server,
0:                                       new Object[] {consoleWriter });
0:         }
0:         catch( InvocationTargetException ite)
0:         {
0:             Monitor.logTextMessage(
0: 								   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, ite.getTargetException().getMessage());
0: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
0: 
0:             server = null;
0:         }
0:         catch( Exception e)
0:         {
0:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
0:             server = null;
0: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
0:         }
0:     }
0:     
0:     public void stop()
0:     {
0: 		try {
0: 			if( serverThread != null && serverThread.isAlive())
0: 			{
0: 				serverShutdownMethod.invoke( server,
0: 											 null);
0: 				serverThread.interrupt();
0: 				serverThread = null;
0: 			}
0: 		   
0: 		}
0: 		catch( InvocationTargetException ite)
0:         {
0: 			Monitor.logTextMessage(
0: 								   MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, ite.getTargetException().getMessage());
0: 			ite.printStackTrace(Monitor.getStream().getPrintWriter());
0: 			
0:         }
0:         catch( Exception e)
0:         {
0:             Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_SHUTDOWN_EXCEPTION, e.getMessage());
0: 			e.printStackTrace(Monitor.getStream().getPrintWriter());
0: 		}
0: 			
0: 		serverThread = null;
0: 		server = null;
0: 		serverClass = null;
0: 		serverStartMethod = null;
0: 		serverShutdownMethod = null;
0: 		listenAddress = null;
0: 		portNumber = -1;
0: 		consoleWriter = null;
0: 		
0:     } // end of stop
0: }
============================================================================