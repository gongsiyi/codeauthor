1:eac0369: /*
4:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.D_DiagnosticUtil
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:56c1dc2: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.diag.Diagnosticable;
1:eac0369: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: 
1:eac0369: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_MultiIterations;
1:eac0369: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_Fail;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: 
1:eac0369: // import java.util.Properties;
1:eac0369: 
1:eac0369: // DEBUGGING:
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   This class provides some utility functions used to debug on disk structures
1:eac0369:   of the store.
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: 
1:eac0369: public class D_DiagnosticUtil
1:eac0369: {
1:eac0369: 
1:eac0369: 
1:eac0369:     /* Constructors for This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * No arg Constructor.
1:eac0369:      **/
1:eac0369:     public D_DiagnosticUtil()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Given a database name come up with a module.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The store module associated with given database name.
1:eac0369:      *
1:eac0369:      * @param db_name name of the database.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private static Object getModuleFromDbName(String db_name)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Object   store_module = null;
1:eac0369: 
1:56c1dc2: 		Object db = findService(Property.DATABASE_MODULE, db_name);
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - find a single way to find the current 
1:eac0369:         // AccessFactory that works both for ij and unit tests.
1:eac0369:         if (db == null)
1:eac0369:         {
1:eac0369:             // maybe it is a module test - try this hack:
1:56c1dc2:             store_module = findService(AccessFactory.MODULE, db_name);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // Find the AccessFactory
1:56c1dc2:             store_module = findServiceModule(db, AccessFactory.MODULE);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(store_module);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Public Methods of This class: */
1:eac0369:     /**
1:eac0369:      * Given a Database name and conglomid print out diagnostic info.
1:eac0369:      * <p>
1:eac0369:      * Print diagnostic information about a particular conglomerate, can be
1:eac0369:      * called for either a btree or heap conglomerate.  This routine
1:eac0369:      * prints out the string to "System.out"; "ij", depending on it's 
1:eac0369:      * configuration, will only print out a fixed length (default 128 bytes),
1:eac0369:      * so having ij print the string can be a problem.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * Can be called from ij to find out info about conglomid 19 in database
1:eac0369:      * 'msgdb' by using the following syntax:
1:eac0369:      *
1:e3647c1:        maximumdisplaywidth 9000;
1:e3647c1: 
1:e3647c1:        CREATE FUNCTION D_CONGLOMID_PRINT(DBNAME VARCHAR(128), CONGLOMID INT)
1:e3647c1:        RETURNS VARCHAR(32000) RETURNS NULL ON NULL INPUT
1:e3647c1:        EXTERNAL NAME
1:e3647c1:        'org.apache.derby.impl.store.raw.data.D_DiagnosticUtil.diag_conglomid_print'
1:e3647c1:        LANGUAGE JAVA PARAMETER STYLE JAVA;
1:e3647c1: 
1:e3647c1:        values D_CONGLOMID_PRINT('msgdb', 19);
1:eac0369:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:eac0369:           diag_conglomid_print('msgdb', 19);
1:eac0369:      *
1:eac0369:      * RESOLVE - An interface that takes a table name would be nice.
1:eac0369:      *
1:eac0369:      * @param db_name   name of the database 
1:eac0369:      * @param conglomid conglomerate id of the conglomerate to debug
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static String diag_conglomid_print(String db_name, long conglomid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         try 
1:eac0369:         {
1:eac0369:             System.out.println(diag_conglomid(db_name, conglomid));
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369:             t.printStackTrace();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return("");
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:20bc69f:      * Given a Database name and conglomid, return diagnositic string.
1:eac0369:      * <p>
1:eac0369:      * Return a string with diagnostic information about a particular
1:eac0369:      * conglomerate, can be called for any type of conglomerate (some types
1:eac0369:      * may not return any info though).
1:eac0369:      * <p>
1:eac0369:      * Can be called from ij to find out info about conglomid 19 in database
1:eac0369:      * 'msgdb' by using the following syntax:
1:eac0369:      *
1:eac0369:      *     values 
1:eac0369:      *     com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:eac0369:      *     diag_conglomid('msgdb', 19);
1:e3647c1:        maximumdisplaywidth 9000;
1:e3647c1: 
1:e3647c1:        CREATE FUNCTION DIAG_CONGLOMID(DBNAME VARCHAR(128), CONGLOMID INT)
1:e3647c1:        RETURNS VARCHAR(32000) RETURNS NULL ON NULL INPUT
1:e3647c1:        EXTERNAL NAME
1:e3647c1:        'org.apache.derby.impl.store.raw.data.D_DiagnosticUtil.diag_conglomid'
1:e3647c1:        LANGUAGE JAVA PARAMETER STYLE JAVA;
1:e3647c1: 
1:e3647c1:        values DIAG_CONGLOMID('msgdb', 19);
1:e3647c1:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:e3647c1:           diag_conglomid_print('msgdb', 19);
1:eac0369:      *
1:eac0369:      * RESOLVE - An interface that takes a table name would be nice.
1:eac0369:      *
1:eac0369:      * @param db_name   name of the database 
1:eac0369:      * @param conglomid conglomerate id of the conglomerate to debug
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static String diag_conglomid(String db_name, long conglomid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         String          ret_string   = null;
1:eac0369:         AccessFactory   store_module = null;
1:eac0369: 
1:eac0369:         store_module = (AccessFactory) getModuleFromDbName(db_name);
1:eac0369: 
1:eac0369:         if (store_module != null)
1:eac0369:         {
1:eac0369: 
1:eac0369:             TransactionController tc =
1:eac0369:                 store_module.getTransaction(
1:a0dbbd7:                     FileContainer.getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369:             ConglomerateController open_table = 
1:eac0369:                 tc.openConglomerate(
1:eac0369:                     conglomid, false, 0, TransactionController.MODE_TABLE,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 
1:eac0369:             open_table.debugConglomerate();
1:eac0369: 
1:eac0369:             Diagnosticable diag_obj = DiagnosticUtil.findDiagnostic(open_table);
1:eac0369: 
1:eac0369:             ret_string = diag_obj.diag();
1:eac0369: 
1:eac0369:             open_table.close();
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             System.out.println(
1:eac0369:                 "Could not find module for database: " + db_name);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_string);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Dump raw contents of a page.
1:eac0369:      * <p>
1:eac0369:      * A utility routine that can be called from an ij session that will 
1:eac0369:      * dump the raw contents of a page, in the raw store dump format.
1:eac0369:      *
1:eac0369:      * @param db_name       name of the database 
1:eac0369:      * @param segmentid     segmentid of the table (usually 0)
1:eac0369:      * @param containerid   containerid of the table (not conglomid)
1:eac0369:      * @param pagenumber    pagenumber of page to dump.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public static void diag_dump_page(
1:eac0369:     String  db_name, 
1:eac0369:     long    segmentid, 
1:eac0369:     long    containerid, 
1:eac0369:     long    pagenumber)
1:eac0369: 	{
1:eac0369: 		Transaction xact = null;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			Object module = getModuleFromDbName(db_name);
1:eac0369: 
1:eac0369: 			RawStoreFactory store_module = (RawStoreFactory)
1:56c1dc2: 				findServiceModule(module, RawStoreFactory.MODULE);
1:eac0369: 
1:a0dbbd7: 			xact = store_module.startInternalTransaction
1:a0dbbd7:                 (FileContainer.getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369: 			ContainerKey id = new ContainerKey(segmentid, containerid);
1:eac0369: 			ContainerHandle container = 
1:eac0369: 				xact.openContainer(id,
1:eac0369: 								   ContainerHandle.MODE_READONLY);
1:eac0369: 			Page page = container.getPage(pagenumber);
1:eac0369: 
1:eac0369: 			if (page != null)
1:eac0369: 			{
1:eac0369: 				System.out.println(page.toString());
1:eac0369: 				page.unlatch();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				System.out.println("page " + pagenumber + " not found");
1:eac0369: 			}
1:eac0369: 			xact.abort();
1:eac0369: 			xact.close();
1:eac0369: 			xact = null;
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			se.printStackTrace();
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (xact != null)
1:eac0369: 			{
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					xact.abort();
1:eac0369: 					xact.close();
1:eac0369: 				}
1:eac0369: 				catch (StandardException se)
1:eac0369: 				{
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:20bc69f:      * Given a Database name and conglomid, return container id.
1:eac0369:      * <p>
1:eac0369:      * Return the containerid of a given conglomerate id.
1:eac0369:      * <p>
1:eac0369:      * Can be called from ij to find out info about conglomid 19 in database
1:eac0369:      * 'msgdb' by using the following syntax:
1:eac0369:      *
2:eac0369:           values 
1:eac0369:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
1:eac0369:           diag_containerid_to_conglomid('msgdb', 924300359390);
1:eac0369:      *
1:eac0369:      * RESOLVE - An interface that takes a table name would be nice.
1:eac0369:      *
1:eac0369:      * @param db_name       name of the database 
1:eac0369:      * @param containerid   container id of the conglomerate to look up
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static long diag_containerid_to_conglomid(
1:eac0369:     String          db_name,
1:eac0369:     long            containerid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // Find the AccessFactory
1:eac0369:         Object store_module = getModuleFromDbName(db_name);
1:eac0369: 
1:eac0369:         return(diag_containerid_to_conglomid(store_module, containerid));
1:eac0369:     }
1:eac0369: 
1:eac0369:     public static long diag_containerid_to_conglomid(
1:eac0369:     Object   module,
1:eac0369:     long            containerid)
1:eac0369:     {
1:eac0369:         String          ret_string   = null;
1:eac0369:         AccessFactory   store_module = null;
1:eac0369:         long            conglom_id   = Long.MIN_VALUE;
1:eac0369: 
1:eac0369:         // Find the AccessFactory
1:eac0369:         store_module = (AccessFactory) 
1:56c1dc2:             getServiceModule(module, AccessFactory.MODULE);
1:eac0369: 
1:eac0369:         if (store_module != null)
1:eac0369:         {
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 TransactionController tc = 
1:eac0369:                     store_module.getTransaction(
1:a0dbbd7:                         FileContainer.getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369:                 conglom_id = tc.findConglomid(containerid);
1:eac0369:             }
1:eac0369:             catch (Throwable t)
1:eac0369:             {
1:eac0369:                 t.printStackTrace();
1:eac0369:                 // on error just return the initialized bad value conglom_id
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // during access boot this does not exist, assume for now that
1:eac0369:             // is why we got here.  RESOLVE - it would be nice if we could
1:eac0369:             // actuallly figure that is why we failed.
1:eac0369:             
1:eac0369:             /*
1:eac0369:             System.out.println(
1:eac0369:                 "Could not find module for module: " + module);
1:eac0369:             */
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(conglom_id);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:20bc69f:      * Given a Database name and containerid, return conglomerate id.
1:eac0369:      * <p>
1:eac0369:      * Return the conglomerate id of a given conainer id.
1:eac0369:      * <p>
1:eac0369:      * Can be called from ij to find out info about conglomid 19 in database
1:eac0369:      * 'msgdb' by using the following syntax:
1:eac0369:      *
1:eac0369:           values 
1:eac0369:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
1:eac0369:           diag_conglomid_to_containerid('msgdb', 19);
1:eac0369:      *
1:eac0369:      * RESOLVE - An interface that takes a table name would be nice.
1:eac0369:      *
1:eac0369:      * @param db_name   name of the database
1:eac0369:      * @param conglomid conglomerate id of the conglomerate to debug
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static long diag_conglomid_to_containerid(
1:eac0369:     String          db_name,
1:eac0369:     long            conglomid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         String          ret_string   = null;
1:eac0369:         Object   store_module = null;
1:eac0369:         long            conglom_id   = Long.MIN_VALUE;
1:eac0369: 
1:eac0369:         // Find the AccessFactory
1:eac0369:         store_module = getModuleFromDbName(db_name);
1:eac0369: 
1:eac0369:         return(diag_conglomid_to_containerid(store_module, conglomid));
1:eac0369:     }
1:eac0369: 
1:eac0369:     public static long diag_conglomid_to_containerid(
1:eac0369:     Object   module,
1:eac0369:     long            conglomid)
1:eac0369:     {
1:eac0369:         String          ret_string   = null;
1:eac0369:         AccessFactory   store_module = null;
1:eac0369:         long            container_id = Long.MIN_VALUE;
1:eac0369: 
1:eac0369:         // Find the AccessFactory
1:eac0369:         store_module = (AccessFactory) 
1:56c1dc2:             getServiceModule(module, AccessFactory.MODULE);
1:eac0369: 
1:eac0369:         if (store_module != null)
1:eac0369:         {
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 TransactionController tc =
1:eac0369:                     store_module.getTransaction(
1:a0dbbd7:                         FileContainer.getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369:                 container_id = tc.findContainerid(conglomid);
1:eac0369:             }
1:eac0369:             catch (Throwable t)
1:eac0369:             {
1:eac0369:                 t.printStackTrace();
1:eac0369:                 // on error just return the initialized bad value conglom_id
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // during access boot this does not exist, assume for now that
1:eac0369:             // is why we got here.  RESOLVE - it would be nice if we could
1:eac0369:             // actuallly figure that is why we failed.
1:eac0369:             
1:eac0369:             /*
1:eac0369:             System.out.println(
1:eac0369:                 "Could not find module for module: " + module);
1:eac0369:             */
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(container_id);
1:eac0369:     }
1:eac0369: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged module lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object findService( final String factoryInterface, final String serviceName )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.findService( factoryInterface, serviceName );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2:     
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		Object db = findService(Property.DATABASE_MODULE, db_name);
1:             store_module = findService(AccessFactory.MODULE, db_name);
1:             store_module = findServiceModule(db, AccessFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1: 				findServiceModule(module, RawStoreFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1:             getServiceModule(module, AccessFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1:             getServiceModule(module, AccessFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged module lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged service lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object findService( final String factoryInterface, final String serviceName )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.findService( factoryInterface, serviceName );
1:                  }
1:              }
1:              );
1:     }
1:     
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:                     FileContainer.getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1: 			xact = store_module.startInternalTransaction
1:                 (FileContainer.getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:                         FileContainer.getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:                         FileContainer.getContextService().getCurrentContextManager());
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:e3647c1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:        maximumdisplaywidth 9000;
1: 
1:        CREATE FUNCTION D_CONGLOMID_PRINT(DBNAME VARCHAR(128), CONGLOMID INT)
1:        RETURNS VARCHAR(32000) RETURNS NULL ON NULL INPUT
1:        EXTERNAL NAME
1:        'org.apache.derby.impl.store.raw.data.D_DiagnosticUtil.diag_conglomid_print'
1:        LANGUAGE JAVA PARAMETER STYLE JAVA;
1: 
1:        values D_CONGLOMID_PRINT('msgdb', 19);
/////////////////////////////////////////////////////////////////////////
1:        maximumdisplaywidth 9000;
1: 
1:        CREATE FUNCTION DIAG_CONGLOMID(DBNAME VARCHAR(128), CONGLOMID INT)
1:        RETURNS VARCHAR(32000) RETURNS NULL ON NULL INPUT
1:        EXTERNAL NAME
1:        'org.apache.derby.impl.store.raw.data.D_DiagnosticUtil.diag_conglomid'
1:        LANGUAGE JAVA PARAMETER STYLE JAVA;
1: 
1:        values DIAG_CONGLOMID('msgdb', 19);
1:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:           diag_conglomid_print('msgdb', 19);
/////////////////////////////////////////////////////////////////////////
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1:      * Given a Database name and conglomid, return diagnositic string.
/////////////////////////////////////////////////////////////////////////
1:      * Given a Database name and conglomid, return container id.
/////////////////////////////////////////////////////////////////////////
1:      * Given a Database name and containerid, return conglomerate id.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.D_DiagnosticUtil
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.diag.Diagnosticable;
1: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
1: 
1: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_MultiIterations;
1: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_Fail;
1: import org.apache.derby.iapi.reference.Property;
1: 
1: // import java.util.Properties;
1: 
1: // DEBUGGING:
1: 
1: /**
1: 
1:   This class provides some utility functions used to debug on disk structures
1:   of the store.
1: 
1: **/
1: 
1: 
1: public class D_DiagnosticUtil
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 
1:     /* Constructors for This class: */
1: 
1:     /**
1:      * No arg Constructor.
1:      **/
1:     public D_DiagnosticUtil()
1:     {
1:     }
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Given a database name come up with a module.
1:      * <p>
1:      *
1: 	 * @return The store module associated with given database name.
1:      *
1:      * @param db_name name of the database.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private static Object getModuleFromDbName(String db_name)
1: 		throws StandardException
1:     {
1:         Object   store_module = null;
1: 
0: 		Object db = Monitor.findService(Property.DATABASE_MODULE, db_name);
1: 
1:         // RESOLVE (mikem) - find a single way to find the current 
1:         // AccessFactory that works both for ij and unit tests.
1:         if (db == null)
1:         {
1:             // maybe it is a module test - try this hack:
0:             store_module = Monitor.findService(AccessFactory.MODULE, db_name);
1:         }
1:         else
1:         {
1:             // Find the AccessFactory
0:             store_module = Monitor.findServiceModule(db, AccessFactory.MODULE);
1:         }
1: 
1:         return(store_module);
1:     }
1: 
1:     /* Public Methods of This class: */
1: 
1:     /**
1:      * Given a Database name and conglomid print out diagnostic info.
1:      * <p>
1:      * Print diagnostic information about a particular conglomerate, can be
1:      * called for either a btree or heap conglomerate.  This routine
1:      * prints out the string to "System.out"; "ij", depending on it's 
1:      * configuration, will only print out a fixed length (default 128 bytes),
1:      * so having ij print the string can be a problem.
1:      * <p>
0:      * RESOLVE - example does not work in version 10.x and later 
1:      *
1:      * Can be called from ij to find out info about conglomid 19 in database
1:      * 'msgdb' by using the following syntax:
1:      *
1:           values 
1:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:           diag_conglomid_print('msgdb', 19);
1:      *
1:      * RESOLVE - An interface that takes a table name would be nice.
1:      *
1:      * @param db_name   name of the database 
1:      * @param conglomid conglomerate id of the conglomerate to debug
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static String diag_conglomid_print(String db_name, long conglomid)
1:         throws StandardException
1:     {
1:         try 
1:         {
1:             System.out.println(diag_conglomid(db_name, conglomid));
1:         }
1:         catch (Throwable t)
1:         {
1:             t.printStackTrace();
1:         }
1: 
1:         return("");
1:     }
1:     
1:     /**
0:      * Given a Database name and conglomid, return diagnositic string
1:      * <p>
1:      * Return a string with diagnostic information about a particular
1:      * conglomerate, can be called for any type of conglomerate (some types
1:      * may not return any info though).
1:      * <p>
1:      * Can be called from ij to find out info about conglomid 19 in database
1:      * 'msgdb' by using the following syntax:
1:      *
1:      *     values 
1:      *     com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
1:      *     diag_conglomid('msgdb', 19);
1:      *
1:      * RESOLVE - An interface that takes a table name would be nice.
1:      *
1:      * @param db_name   name of the database 
1:      * @param conglomid conglomerate id of the conglomerate to debug
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static String diag_conglomid(String db_name, long conglomid)
1:         throws StandardException
1:     {
1:         String          ret_string   = null;
1:         AccessFactory   store_module = null;
1: 
1:         store_module = (AccessFactory) getModuleFromDbName(db_name);
1: 
1:         if (store_module != null)
1:         {
1: 
1:             TransactionController tc =
1:                 store_module.getTransaction(
0:                     ContextService.getFactory().getCurrentContextManager());
1: 
1:             ConglomerateController open_table = 
1:                 tc.openConglomerate(
1:                     conglomid, false, 0, TransactionController.MODE_TABLE,
1:                     TransactionController.ISOLATION_SERIALIZABLE);
1: 
1:             open_table.debugConglomerate();
1: 
1:             Diagnosticable diag_obj = DiagnosticUtil.findDiagnostic(open_table);
1: 
1:             ret_string = diag_obj.diag();
1: 
1:             open_table.close();
1:         }
1:         else
1:         {
1:             System.out.println(
1:                 "Could not find module for database: " + db_name);
1:         }
1: 
1:         return(ret_string);
1:     }
1: 
1: 
1:     /**
1:      * Dump raw contents of a page.
1:      * <p>
1:      * A utility routine that can be called from an ij session that will 
1:      * dump the raw contents of a page, in the raw store dump format.
1:      *
1:      * @param db_name       name of the database 
1:      * @param segmentid     segmentid of the table (usually 0)
1:      * @param containerid   containerid of the table (not conglomid)
1:      * @param pagenumber    pagenumber of page to dump.
1:      *
1:      **/
1: 	public static void diag_dump_page(
1:     String  db_name, 
1:     long    segmentid, 
1:     long    containerid, 
1:     long    pagenumber)
1: 	{
1: 		Transaction xact = null;
1: 		try
1: 		{
1: 			Object module = getModuleFromDbName(db_name);
1: 
1: 			RawStoreFactory store_module = (RawStoreFactory)
0: 				Monitor.findServiceModule(module, RawStoreFactory.MODULE);
1: 
0: 			xact = store_module.startInternalTransaction(ContextService.getFactory().getCurrentContextManager());
1: 
1: 			ContainerKey id = new ContainerKey(segmentid, containerid);
1: 			ContainerHandle container = 
1: 				xact.openContainer(id,
1: 								   ContainerHandle.MODE_READONLY);
1: 			Page page = container.getPage(pagenumber);
1: 
1: 			if (page != null)
1: 			{
1: 				System.out.println(page.toString());
1: 				page.unlatch();
1: 			}
1: 			else
1: 			{
1: 				System.out.println("page " + pagenumber + " not found");
1: 			}
1: 			xact.abort();
1: 			xact.close();
1: 			xact = null;
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			se.printStackTrace();
1: 		}
1: 		finally
1: 		{
1: 			if (xact != null)
1: 			{
1: 				try
1: 				{
1: 					xact.abort();
1: 					xact.close();
1: 				}
1: 				catch (StandardException se)
1: 				{
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1:     /**
0:      * Given a Database name and conglomid, return container id
1:      * <p>
1:      * Return the containerid of a given conglomerate id.
1:      * <p>
1:      * Can be called from ij to find out info about conglomid 19 in database
1:      * 'msgdb' by using the following syntax:
1:      *
1:           values 
1:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
1:           diag_containerid_to_conglomid('msgdb', 924300359390);
1:      *
1:      * RESOLVE - An interface that takes a table name would be nice.
1:      *
1:      * @param db_name       name of the database 
1:      * @param containerid   container id of the conglomerate to look up
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static long diag_containerid_to_conglomid(
1:     String          db_name,
1:     long            containerid)
1:         throws StandardException
1:     {
1:         // Find the AccessFactory
1:         Object store_module = getModuleFromDbName(db_name);
1: 
1:         return(diag_containerid_to_conglomid(store_module, containerid));
1:     }
1: 
1:     public static long diag_containerid_to_conglomid(
1:     Object   module,
1:     long            containerid)
1:     {
1:         String          ret_string   = null;
1:         AccessFactory   store_module = null;
1:         long            conglom_id   = Long.MIN_VALUE;
1: 
1:         // Find the AccessFactory
1:         store_module = (AccessFactory) 
0:             Monitor.getServiceModule(module, AccessFactory.MODULE);
1: 
1:         if (store_module != null)
1:         {
1:             try
1:             {
1:                 TransactionController tc = 
1:                     store_module.getTransaction(
0:                         ContextService.getFactory().getCurrentContextManager());
1: 
1:                 conglom_id = tc.findConglomid(containerid);
1:             }
1:             catch (Throwable t)
1:             {
1:                 t.printStackTrace();
1:                 // on error just return the initialized bad value conglom_id
1:             }
1:         }
1:         else
1:         {
1:             // during access boot this does not exist, assume for now that
1:             // is why we got here.  RESOLVE - it would be nice if we could
1:             // actuallly figure that is why we failed.
1:             
1:             /*
1:             System.out.println(
1:                 "Could not find module for module: " + module);
1:             */
1:         }
1: 
1:         return(conglom_id);
1:     }
1: 
1:     /**
0:      * Given a Database name and containerid, return conglomerate id
1:      * <p>
1:      * Return the conglomerate id of a given conainer id.
1:      * <p>
1:      * Can be called from ij to find out info about conglomid 19 in database
1:      * 'msgdb' by using the following syntax:
1:      *
1:           values 
1:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
1:           diag_conglomid_to_containerid('msgdb', 19);
1:      *
1:      * RESOLVE - An interface that takes a table name would be nice.
1:      *
1:      * @param db_name   name of the database
1:      * @param conglomid conglomerate id of the conglomerate to debug
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static long diag_conglomid_to_containerid(
1:     String          db_name,
1:     long            conglomid)
1:         throws StandardException
1:     {
1:         String          ret_string   = null;
1:         Object   store_module = null;
1:         long            conglom_id   = Long.MIN_VALUE;
1: 
1:         // Find the AccessFactory
1:         store_module = getModuleFromDbName(db_name);
1: 
1:         return(diag_conglomid_to_containerid(store_module, conglomid));
1:     }
1: 
1:     public static long diag_conglomid_to_containerid(
1:     Object   module,
1:     long            conglomid)
1:     {
1:         String          ret_string   = null;
1:         AccessFactory   store_module = null;
1:         long            container_id = Long.MIN_VALUE;
1: 
1:         // Find the AccessFactory
1:         store_module = (AccessFactory) 
0:             Monitor.getServiceModule(module, AccessFactory.MODULE);
1: 
1:         if (store_module != null)
1:         {
1:             try
1:             {
1:                 TransactionController tc =
1:                     store_module.getTransaction(
0:                         ContextService.getFactory().getCurrentContextManager());
1: 
1:                 container_id = tc.findContainerid(conglomid);
1:             }
1:             catch (Throwable t)
1:             {
1:                 t.printStackTrace();
1:                 // on error just return the initialized bad value conglom_id
1:             }
1:         }
1:         else
1:         {
1:             // during access boot this does not exist, assume for now that
1:             // is why we got here.  RESOLVE - it would be nice if we could
1:             // actuallly figure that is why we failed.
1:             
1:             /*
1:             System.out.println(
1:                 "Could not find module for module: " + module);
1:             */
1:         }
1: 
1:         return(container_id);
1:     }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.diag.Diagnosticable;
0: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: 
0: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_MultiIterations;
0: // import com.ibm.db2j.impl.BasicServices.TestService.TestTemplate.T_Fail;
0: import org.apache.derby.iapi.reference.Property;
0: 
0: // import java.util.Properties;
0: 
0: // DEBUGGING:
0: 
0: /**
0: 
0:   This class provides some utility functions used to debug on disk structures
0:   of the store.
0: 
0: **/
0: 
0: 
0: public class D_DiagnosticUtil
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 
0:     /* Constructors for This class: */
0: 
0:     /**
0:      * No arg Constructor.
0:      **/
0:     public D_DiagnosticUtil()
0:     {
0:     }
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Given a database name come up with a module.
0:      * <p>
0:      *
0: 	 * @return The store module associated with given database name.
0:      *
0:      * @param db_name name of the database.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private static Object getModuleFromDbName(String db_name)
0: 		throws StandardException
0:     {
0:         Object   store_module = null;
0: 
0: 		Object db = Monitor.findService(Property.DATABASE_MODULE, db_name);
0: 
0:         // RESOLVE (mikem) - find a single way to find the current 
0:         // AccessFactory that works both for ij and unit tests.
0:         if (db == null)
0:         {
0:             // maybe it is a module test - try this hack:
0:             store_module = Monitor.findService(AccessFactory.MODULE, db_name);
0:         }
0:         else
0:         {
0:             // Find the AccessFactory
0:             store_module = Monitor.findServiceModule(db, AccessFactory.MODULE);
0:         }
0: 
0:         return(store_module);
0:     }
0: 
0:     /* Public Methods of This class: */
0: 
0:     /**
0:      * Given a Database name and conglomid print out diagnostic info.
0:      * <p>
0:      * Print diagnostic information about a particular conglomerate, can be
0:      * called for either a btree or heap conglomerate.  This routine
0:      * prints out the string to "System.out"; "ij", depending on it's 
0:      * configuration, will only print out a fixed length (default 128 bytes),
0:      * so having ij print the string can be a problem.
0:      * <p>
0:      * RESOLVE - example does not work in version 10.x and later 
0:      *
0:      * Can be called from ij to find out info about conglomid 19 in database
0:      * 'msgdb' by using the following syntax:
0:      *
0:           values 
0:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
0:           diag_conglomid_print('msgdb', 19);
0:      *
0:      * RESOLVE - An interface that takes a table name would be nice.
0:      *
0:      * @param db_name   name of the database 
0:      * @param conglomid conglomerate id of the conglomerate to debug
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static String diag_conglomid_print(String db_name, long conglomid)
0:         throws StandardException
0:     {
0:         try 
0:         {
0:             System.out.println(diag_conglomid(db_name, conglomid));
0:         }
0:         catch (Throwable t)
0:         {
0:             t.printStackTrace();
0:         }
0: 
0:         return("");
0:     }
0:     
0:     /**
0:      * Given a Database name and conglomid, return diagnositic string
0:      * <p>
0:      * Return a string with diagnostic information about a particular
0:      * conglomerate, can be called for any type of conglomerate (some types
0:      * may not return any info though).
0:      * <p>
0:      * Can be called from ij to find out info about conglomid 19 in database
0:      * 'msgdb' by using the following syntax:
0:      *
0:      *     values 
0:      *     com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable::
0:      *     diag_conglomid('msgdb', 19);
0:      *
0:      * RESOLVE - An interface that takes a table name would be nice.
0:      *
0:      * @param db_name   name of the database 
0:      * @param conglomid conglomerate id of the conglomerate to debug
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static String diag_conglomid(String db_name, long conglomid)
0:         throws StandardException
0:     {
0:         String          ret_string   = null;
0:         AccessFactory   store_module = null;
0: 
0:         store_module = (AccessFactory) getModuleFromDbName(db_name);
0: 
0:         if (store_module != null)
0:         {
0: 
0:             TransactionController tc =
0:                 store_module.getTransaction(
0:                     ContextService.getFactory().getCurrentContextManager());
0: 
0:             ConglomerateController open_table = 
0:                 tc.openConglomerate(
0:                     conglomid, false, 0, TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_SERIALIZABLE);
0: 
0:             open_table.debugConglomerate();
0: 
0:             Diagnosticable diag_obj = DiagnosticUtil.findDiagnostic(open_table);
0: 
0:             ret_string = diag_obj.diag();
0: 
0:             open_table.close();
0:         }
0:         else
0:         {
0:             System.out.println(
0:                 "Could not find module for database: " + db_name);
0:         }
0: 
0:         return(ret_string);
0:     }
0: 
0: 
0:     /**
0:      * Dump raw contents of a page.
0:      * <p>
0:      * A utility routine that can be called from an ij session that will 
0:      * dump the raw contents of a page, in the raw store dump format.
0:      *
0:      * @param db_name       name of the database 
0:      * @param segmentid     segmentid of the table (usually 0)
0:      * @param containerid   containerid of the table (not conglomid)
0:      * @param pagenumber    pagenumber of page to dump.
0:      *
0:      **/
0: 	public static void diag_dump_page(
0:     String  db_name, 
0:     long    segmentid, 
0:     long    containerid, 
0:     long    pagenumber)
0: 	{
0: 		Transaction xact = null;
0: 		try
0: 		{
0: 			Object module = getModuleFromDbName(db_name);
0: 
0: 			RawStoreFactory store_module = (RawStoreFactory)
0: 				Monitor.findServiceModule(module, RawStoreFactory.MODULE);
0: 
0: 			xact = store_module.startInternalTransaction(ContextService.getFactory().getCurrentContextManager());
0: 
0: 			ContainerKey id = new ContainerKey(segmentid, containerid);
0: 			ContainerHandle container = 
0: 				xact.openContainer(id,
0: 								   ContainerHandle.MODE_READONLY);
0: 			Page page = container.getPage(pagenumber);
0: 
0: 			if (page != null)
0: 			{
0: 				System.out.println(page.toString());
0: 				page.unlatch();
0: 			}
0: 			else
0: 			{
0: 				System.out.println("page " + pagenumber + " not found");
0: 			}
0: 			xact.abort();
0: 			xact.close();
0: 			xact = null;
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			se.printStackTrace();
0: 		}
0: 		finally
0: 		{
0: 			if (xact != null)
0: 			{
0: 				try
0: 				{
0: 					xact.abort();
0: 					xact.close();
0: 				}
0: 				catch (StandardException se)
0: 				{
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0:     /**
0:      * Given a Database name and conglomid, return container id
0:      * <p>
0:      * Return the containerid of a given conglomerate id.
0:      * <p>
0:      * Can be called from ij to find out info about conglomid 19 in database
0:      * 'msgdb' by using the following syntax:
0:      *
0:           values 
0:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
0:           diag_containerid_to_conglomid('msgdb', 924300359390);
0:      *
0:      * RESOLVE - An interface that takes a table name would be nice.
0:      *
0:      * @param db_name       name of the database 
0:      * @param containerid   container id of the conglomerate to look up
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static long diag_containerid_to_conglomid(
0:     String          db_name,
0:     long            containerid)
0:         throws StandardException
0:     {
0:         // Find the AccessFactory
0:         Object store_module = getModuleFromDbName(db_name);
0: 
0:         return(diag_containerid_to_conglomid(store_module, containerid));
0:     }
0: 
0:     public static long diag_containerid_to_conglomid(
0:     Object   module,
0:     long            containerid)
0:     {
0:         String          ret_string   = null;
0:         AccessFactory   store_module = null;
0:         long            conglom_id   = Long.MIN_VALUE;
0: 
0:         // Find the AccessFactory
0:         store_module = (AccessFactory) 
0:             Monitor.getServiceModule(module, AccessFactory.MODULE);
0: 
0:         if (store_module != null)
0:         {
0:             try
0:             {
0:                 TransactionController tc = 
0:                     store_module.getTransaction(
0:                         ContextService.getFactory().getCurrentContextManager());
0: 
0:                 conglom_id = tc.findConglomid(containerid);
0:             }
0:             catch (Throwable t)
0:             {
0:                 t.printStackTrace();
0:                 // on error just return the initialized bad value conglom_id
0:             }
0:         }
0:         else
0:         {
0:             // during access boot this does not exist, assume for now that
0:             // is why we got here.  RESOLVE - it would be nice if we could
0:             // actuallly figure that is why we failed.
0:             
0:             /*
0:             System.out.println(
0:                 "Could not find module for module: " + module);
0:             */
0:         }
0: 
0:         return(conglom_id);
0:     }
0: 
0:     /**
0:      * Given a Database name and containerid, return conglomerate id
0:      * <p>
0:      * Return the conglomerate id of a given conainer id.
0:      * <p>
0:      * Can be called from ij to find out info about conglomid 19 in database
0:      * 'msgdb' by using the following syntax:
0:      *
0:           values 
0:           com.ibm.db2j.protocol.BasicServices.Diagnostic.T_Diagnosticable).
0:           diag_conglomid_to_containerid('msgdb', 19);
0:      *
0:      * RESOLVE - An interface that takes a table name would be nice.
0:      *
0:      * @param db_name   name of the database
0:      * @param conglomid conglomerate id of the conglomerate to debug
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static long diag_conglomid_to_containerid(
0:     String          db_name,
0:     long            conglomid)
0:         throws StandardException
0:     {
0:         String          ret_string   = null;
0:         Object   store_module = null;
0:         long            conglom_id   = Long.MIN_VALUE;
0: 
0:         // Find the AccessFactory
0:         store_module = getModuleFromDbName(db_name);
0: 
0:         return(diag_conglomid_to_containerid(store_module, conglomid));
0:     }
0: 
0:     public static long diag_conglomid_to_containerid(
0:     Object   module,
0:     long            conglomid)
0:     {
0:         String          ret_string   = null;
0:         AccessFactory   store_module = null;
0:         long            container_id = Long.MIN_VALUE;
0: 
0:         // Find the AccessFactory
0:         store_module = (AccessFactory) 
0:             Monitor.getServiceModule(module, AccessFactory.MODULE);
0: 
0:         if (store_module != null)
0:         {
0:             try
0:             {
0:                 TransactionController tc =
0:                     store_module.getTransaction(
0:                         ContextService.getFactory().getCurrentContextManager());
0: 
0:                 container_id = tc.findContainerid(conglomid);
0:             }
0:             catch (Throwable t)
0:             {
0:                 t.printStackTrace();
0:                 // on error just return the initialized bad value conglom_id
0:             }
0:         }
0:         else
0:         {
0:             // during access boot this does not exist, assume for now that
0:             // is why we got here.  RESOLVE - it would be nice if we could
0:             // actuallly figure that is why we failed.
0:             
0:             /*
0:             System.out.println(
0:                 "Could not find module for module: " + module);
0:             */
0:         }
0: 
0:         return(container_id);
0:     }
0: 
0: }
============================================================================