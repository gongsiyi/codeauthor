1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.RealResultSetStatisticsFactory
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.PreparedStatement;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.sql.execute.AnyResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.CurrentOfResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DeleteResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DeleteCascadeResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DeleteVTIResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DistinctScalarAggregateResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DistinctScanResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.GroupedAggregateResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.HashJoinResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.HashLeftOuterJoinResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.HashScanResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.HashTableResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.InsertResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.InsertVTIResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.LastIndexKeyResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.MaterializedResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.NestedLoopLeftOuterJoinResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.NormalizeResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.OnceResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.ProjectRestrictResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.RowResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.ScalarAggregateResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet;
1:6f2391f: import org.apache.derby.impl.sql.execute.SetOpResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.SortResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.TableScanResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.UnionResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.UpdateResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.VTIResultSet;
1:eac0369: import org.apache.derby.impl.sql.execute.DependentResultSet;
1:7a9ce7e: import org.apache.derby.impl.sql.execute.WindowResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealAnyResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealCurrentOfStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealDeleteResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealDeleteCascadeResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealDeleteVTIResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealDistinctScalarAggregateStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealDistinctScanStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealGroupedAggregateStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealHashJoinStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealHashLeftOuterJoinStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealHashTableStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealIndexRowToBaseRowStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealInsertResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealInsertVTIResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealJoinResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealLastIndexKeyScanStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealMaterializedResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopJoinStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopLeftOuterJoinStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealNormalizeResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealOnceResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealProjectRestrictStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealRowResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealScalarAggregateStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealScrollInsensitiveResultSetStatistics;
1:6f2391f: import org.apache.derby.impl.sql.execute.rts.RealSetOpResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealSortStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RealVTIStatistics;
1:69a192a: import org.apache.derby.impl.sql.execute.rts.RealRowCountStatistics;
1:5825332: import org.apache.derby.iapi.sql.execute.ResultSetStatistics;
1:eac0369: import org.apache.derby.impl.sql.execute.rts.RunTimeStatisticsImpl;
1:7a9ce7e: import org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * ResultSetStatisticsFactory provides a wrapper around all of
1:eac0369:  * objects associated with run time statistics.
1:eac0369:  * <p>
1:eac0369:  * This implementation of the protocol is for returning the "real"
1:eac0369:  * run time statistics.  We have modularized this so that we could
1:eac0369:  * have an implementation that just returns null for each of the
1:eac0369:  * objects should we decided to provide a configuration without
1:eac0369:  * the run time statistics feature.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public class RealResultSetStatisticsFactory 
1:eac0369: 		implements ResultSetStatisticsFactory
2:eac0369: {
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ExecutionFactory interface
1:eac0369: 	//
1:eac0369: 	//
1:eac0369: 	// ResultSetStatisticsFactory interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetStatisticsFactory#getRunTimeStatistics
1:eac0369: 	 */
1:eac0369: 	public RunTimeStatistics getRunTimeStatistics(
1:eac0369: 			Activation activation, 
1:eac0369: 			ResultSet rs,
1:eac0369: 			NoPutResultSet[] subqueryTrackingArray)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		PreparedStatement preStmt = activation.getPreparedStatement();
1:eac0369: 
1:eac0369: 		// If the prepared statement is null then the result set is being
1:eac0369: 		// finished as a result of a activation being closed during a recompile.
1:eac0369: 		// In this case statistics should not be generated.
1:eac0369: 		if (preStmt == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		ResultSetStatistics topResultSetStatistics;
1:eac0369: 
1:eac0369: 		if (rs instanceof NoPutResultSet)
1:eac0369: 		{
1:eac0369: 			topResultSetStatistics =
1:eac0369: 									getResultSetStatistics((NoPutResultSet) rs);
2:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			topResultSetStatistics = getResultSetStatistics(rs);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Build up the info on the materialized subqueries */
1:eac0369: 		int subqueryTrackingArrayLength =
1:eac0369: 				(subqueryTrackingArray == null) ? 0 :
1:eac0369: 					subqueryTrackingArray.length;
1:eac0369: 		ResultSetStatistics[] subqueryRSS =
1:eac0369: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1:eac0369: 		boolean anyAttached = false;
1:eac0369: 		for (int index = 0; index < subqueryTrackingArrayLength; index++)
1:eac0369: 		{
1:eac0369: 			if (subqueryTrackingArray[index] != null &&
1:eac0369: 				subqueryTrackingArray[index].getPointOfAttachment() == -1)
1:eac0369: 			{
1:eac0369: 				subqueryRSS[index] =
1:eac0369: 						getResultSetStatistics(subqueryTrackingArray[index]);
1:eac0369: 				anyAttached = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (anyAttached == false)
1:eac0369: 		{
1:eac0369: 			subqueryRSS = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Get the info on all of the materialized subqueries (attachment point = -1)
1:eac0369: 		return new RunTimeStatisticsImpl(
1:eac0369: 								preStmt.getSPSName(),
1:eac0369: 								activation.getCursorName(),
1:eac0369: 								preStmt.getSource(),
1:eac0369: 								preStmt.getCompileTimeInMillis(),
1:eac0369: 								preStmt.getParseTimeInMillis(),
1:eac0369: 								preStmt.getBindTimeInMillis(),
1:eac0369: 								preStmt.getOptimizeTimeInMillis(),
1:eac0369: 								preStmt.getGenerateTimeInMillis(),
1:eac0369: 								rs.getExecuteTime(),
1:eac0369: 								preStmt.getBeginCompileTimestamp(),
1:eac0369: 								preStmt.getEndCompileTimestamp(),
1:eac0369: 								rs.getBeginExecutionTimestamp(),
1:eac0369: 								rs.getEndExecutionTimestamp(),
1:eac0369: 								subqueryRSS,
1:eac0369: 								topResultSetStatistics);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ResultSetStatisticsFactory#getResultSetStatistics
1:eac0369: 	 */
1:eac0369: 	public ResultSetStatistics getResultSetStatistics(ResultSet rs)
1:eac0369: 	{
1:eac0369: 		if (!rs.returnsRows())
1:eac0369: 		{
1:eac0369: 			return getNoRowsResultSetStatistics(rs);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof NoPutResultSet)
1:eac0369: 		{
1:eac0369: 			return getResultSetStatistics((NoPutResultSet) rs);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ResultSetStatistics getNoRowsResultSetStatistics(ResultSet rs)
1:eac0369: 	{
1:eac0369: 		ResultSetStatistics retval = null;
1:eac0369: 
1:eac0369: 		/* We need to differentiate based on instanceof in order
1:eac0369: 		 * to find the right constructor to call.  This is ugly,
1:eac0369: 		 * but if we don't do instanceof then rs is always seen as an
1:eac0369: 		 * interface instead of a class when we try to overload 
1:eac0369: 		 * a method with both.
1:eac0369: 		 */
1:eac0369: 		if( rs instanceof InsertResultSet)
1:eac0369: 		{
1:eac0369: 			InsertResultSet irs = (InsertResultSet) rs;
1:eac0369: 
1:eac0369: 			retval = new RealInsertResultSetStatistics(
1:7fb9956:                                     (int) irs.rowCount,
1:eac0369: 									irs.constants.deferred,
1:eac0369: 									irs.constants.irgs.length,
1:eac0369: 									irs.userSpecifiedBulkInsert,
1:eac0369: 									irs.bulkInsertPerformed,
1:eac0369: 									irs.constants.lockMode ==
1:eac0369: 										TransactionController.MODE_TABLE,
1:eac0369: 									irs.getExecuteTime(), 
1:eac0369: 									getResultSetStatistics(irs.savedSource)
2:eac0369: 									);
1:c723732: 
1:eac0369: 			irs.savedSource = null;
1:eac0369: 		}
1:eac0369: 		else if( rs instanceof InsertVTIResultSet)
1:c723732: 		{
1:eac0369: 			InsertVTIResultSet iVTIrs = (InsertVTIResultSet) rs;
1:eac0369: 
1:eac0369: 			retval = new RealInsertVTIResultSetStatistics(
1:7fb9956:                                     (int) iVTIrs.rowCount,
1:eac0369: 									iVTIrs.constants.deferred,
1:eac0369: 									iVTIrs.getExecuteTime(), 
1:eac0369: 									getResultSetStatistics(iVTIrs.savedSource)
1:eac0369: 									);
1:eac0369: 
1:eac0369: 			iVTIrs.savedSource = null;
1:eac0369: 		}
1:eac0369: 		else if( rs instanceof UpdateResultSet)
1:eac0369: 		{
1:eac0369: 			UpdateResultSet urs = (UpdateResultSet) rs;
1:eac0369: 
1:eac0369: 			retval = new RealUpdateResultSetStatistics(
1:7fb9956:                                     (int) urs.rowCount,
1:eac0369: 									urs.constants.deferred,
1:eac0369: 									urs.constants.irgs.length,
1:eac0369: 									urs.constants.lockMode ==
1:eac0369: 										TransactionController.MODE_TABLE,
1:eac0369: 									urs.getExecuteTime(),
1:eac0369: 									getResultSetStatistics(urs.savedSource)
1:eac0369: 									);
1:eac0369: 
1:eac0369: 			urs.savedSource = null;
1:eac0369: 		}
1:eac0369: 		else if( rs instanceof DeleteCascadeResultSet)
1:eac0369: 		{
1:eac0369: 			DeleteCascadeResultSet dcrs = (DeleteCascadeResultSet) rs;
1:eac0369: 			int dependentTrackingArrayLength =
1:eac0369: 				(dcrs.dependentResultSets == null) ? 0 :
1:eac0369: 					dcrs.dependentResultSets.length;
1:eac0369: 			ResultSetStatistics[] dependentTrackingArray =
1:eac0369: 				new ResultSetStatistics[dependentTrackingArrayLength];
1:eac0369: 			boolean anyAttached = false;
1:eac0369: 			for (int index = 0; index < dependentTrackingArrayLength; index++)
1:eac0369: 			{
1:eac0369: 				if (dcrs.dependentResultSets[index] != null)
1:eac0369: 				{
1:eac0369: 					dependentTrackingArray[index] =
1:eac0369: 										getResultSetStatistics(
1:eac0369: 											dcrs.dependentResultSets[index]);
1:eac0369: 					anyAttached = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (! anyAttached)
1:eac0369: 			{
1:eac0369: 				dependentTrackingArray = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			retval = new RealDeleteCascadeResultSetStatistics(
1:7fb9956:                                     (int) dcrs.rowCount,
1:eac0369: 									dcrs.constants.deferred,
1:eac0369: 									dcrs.constants.irgs.length,
1:eac0369: 									dcrs.constants.lockMode ==
1:eac0369: 										TransactionController.MODE_TABLE,
1:eac0369: 									dcrs.getExecuteTime(),
1:eac0369: 									getResultSetStatistics(dcrs.savedSource),
1:eac0369: 									dependentTrackingArray
1:eac0369: 									);
1:eac0369: 
1:eac0369: 			dcrs.savedSource = null;
1:eac0369: 		}
1:eac0369: 		else if( rs instanceof DeleteResultSet)
1:eac0369: 		{
1:eac0369: 			DeleteResultSet drs = (DeleteResultSet) rs;
1:eac0369: 
1:eac0369: 			retval = new RealDeleteResultSetStatistics(
1:7fb9956: 									(int) drs.rowCount,
1:eac0369: 									drs.constants.deferred,
1:eac0369: 									drs.constants.irgs.length,
1:eac0369: 									drs.constants.lockMode ==
1:eac0369: 										TransactionController.MODE_TABLE,
1:eac0369: 									drs.getExecuteTime(),
1:eac0369: 									getResultSetStatistics(drs.savedSource)
1:eac0369: 									);
1:eac0369: 
1:eac0369: 			drs.savedSource = null;
1:eac0369: 		}
1:eac0369: 		else if( rs instanceof DeleteVTIResultSet)
1:eac0369: 		{
1:eac0369: 			DeleteVTIResultSet dVTIrs = (DeleteVTIResultSet) rs;
1:eac0369: 
1:eac0369: 			retval = new RealDeleteVTIResultSetStatistics(
1:7fb9956: 									(int) dVTIrs.rowCount,
1:eac0369: 									dVTIrs.getExecuteTime(), 
1:eac0369: 									getResultSetStatistics(dVTIrs.savedSource)
1:eac0369: 									);
1:eac0369: 
1:eac0369: 			dVTIrs.savedSource = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ResultSetStatistics getResultSetStatistics(NoPutResultSet rs)
1:eac0369: 	{
1:eac0369: 		/* We need to differentiate based on instanceof in order
1:eac0369: 		 * to find the right constructor to call.  This is ugly,
1:eac0369: 		 * but if we don't do instanceof then rs is always seen as an
1:eac0369: 		 * interface instead of a class when we try to overload 
1:eac0369: 		 * a method with both.
1:eac0369: 		 */
1:eac0369: 		if( rs instanceof ProjectRestrictResultSet)
1:eac0369: 		{
1:eac0369: 			ProjectRestrictResultSet prrs = (ProjectRestrictResultSet) rs;
1:eac0369: 			int subqueryTrackingArrayLength =
1:eac0369: 				(prrs.subqueryTrackingArray == null) ? 0 :
1:eac0369: 					prrs.subqueryTrackingArray.length;
1:eac0369: 			ResultSetStatistics[] subqueryTrackingArray =
1:eac0369: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1:eac0369: 			boolean anyAttached = false;
1:eac0369: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
1:eac0369: 			{
1:eac0369: 				if (prrs.subqueryTrackingArray[index] != null &&
1:eac0369: 					prrs.subqueryTrackingArray[index].getPointOfAttachment() ==
1:eac0369: 						prrs.resultSetNumber)
1:eac0369: 				{
1:eac0369: 					subqueryTrackingArray[index] =
1:eac0369: 										getResultSetStatistics(
1:eac0369: 											prrs.subqueryTrackingArray[index]);
1:eac0369: 					anyAttached = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (! anyAttached)
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return new RealProjectRestrictStatistics(
1:eac0369: 											prrs.numOpens,
1:eac0369: 											prrs.rowsSeen,
1:eac0369: 											prrs.rowsFiltered,
1:eac0369: 											prrs.constructorTime,
1:eac0369: 											prrs.openTime,
1:eac0369: 											prrs.nextTime,
1:eac0369: 											prrs.closeTime,
1:eac0369: 											prrs.resultSetNumber,
1:eac0369: 											prrs.restrictionTime,
1:eac0369: 											prrs.projectionTime,
1:eac0369: 											subqueryTrackingArray,
1:eac0369: 											(prrs.restriction != null),
1:eac0369: 											prrs.doesProjection,
1:eac0369: 											prrs.optimizerEstimatedRowCount,
1:eac0369: 											prrs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(prrs.source)
1:eac0369: 											);
1:eac0369: 		}
1:69a192a: 		else if (rs instanceof RowCountResultSet)
1:69a192a: 		{
1:69a192a: 			RowCountResultSet rcrs = (RowCountResultSet) rs;
1:69a192a: 
1:69a192a: 			return new RealRowCountStatistics(
1:69a192a: 				rcrs.numOpens,
1:69a192a: 				rcrs.rowsSeen,
1:69a192a: 				rcrs.rowsFiltered,
1:69a192a: 				rcrs.constructorTime,
1:69a192a: 				rcrs.openTime,
1:69a192a: 				rcrs.nextTime,
1:69a192a: 				rcrs.closeTime,
1:69a192a: 				rcrs.resultSetNumber,
1:69a192a: 				rcrs.optimizerEstimatedRowCount,
1:69a192a: 				rcrs.optimizerEstimatedCost,
1:69a192a: 				getResultSetStatistics(rcrs.source) );
1:69a192a: 		}
1:eac0369: 		else if (rs instanceof SortResultSet)
1:eac0369: 		{
1:eac0369: 			SortResultSet srs = (SortResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealSortStatistics(
1:eac0369: 											srs.numOpens,
1:eac0369: 											srs.rowsSeen,
1:eac0369: 											srs.rowsFiltered,
1:eac0369: 											srs.constructorTime,
1:eac0369: 											srs.openTime,
1:eac0369: 											srs.nextTime,
1:eac0369: 											srs.closeTime,
1:eac0369: 											srs.resultSetNumber,
1:eac0369: 											srs.rowsInput,
1:eac0369: 											srs.rowsReturned,
1:eac0369: 											srs.distinct,
1:eac0369: 											srs.isInSortedOrder,
1:eac0369: 											srs.sortProperties,
1:eac0369: 											srs.optimizerEstimatedRowCount,
1:eac0369: 											srs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(srs.source)
1:eac0369: 										);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof DistinctScalarAggregateResultSet)
1:eac0369: 		{
1:eac0369: 			DistinctScalarAggregateResultSet dsars = (DistinctScalarAggregateResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealDistinctScalarAggregateStatistics(
1:eac0369: 											dsars.numOpens,
1:eac0369: 											dsars.rowsSeen,
1:eac0369: 											dsars.rowsFiltered,
1:eac0369: 											dsars.constructorTime,
1:eac0369: 											dsars.openTime,
1:eac0369: 											dsars.nextTime,
1:eac0369: 											dsars.closeTime,
1:eac0369: 											dsars.resultSetNumber,
1:eac0369: 											dsars.rowsInput,
1:eac0369: 											dsars.optimizerEstimatedRowCount,
1:eac0369: 											dsars.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(dsars.source)
1:eac0369: 										);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof ScalarAggregateResultSet)
1:eac0369: 		{
1:eac0369: 			ScalarAggregateResultSet sars = (ScalarAggregateResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealScalarAggregateStatistics(
1:eac0369: 											sars.numOpens,
1:eac0369: 											sars.rowsSeen,
1:eac0369: 											sars.rowsFiltered,
1:eac0369: 											sars.constructorTime,
1:eac0369: 											sars.openTime,
1:eac0369: 											sars.nextTime,
1:eac0369: 											sars.closeTime,
1:eac0369: 											sars.resultSetNumber,
1:eac0369: 											sars.singleInputRow,
1:eac0369: 											sars.rowsInput,
1:eac0369: 											sars.optimizerEstimatedRowCount,
1:eac0369: 											sars.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(sars.source)
1:eac0369: 										);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof GroupedAggregateResultSet)
1:eac0369: 		{
1:eac0369: 			GroupedAggregateResultSet gars = (GroupedAggregateResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealGroupedAggregateStatistics(
1:eac0369: 											gars.numOpens,
1:eac0369: 											gars.rowsSeen,
1:eac0369: 											gars.rowsFiltered,
1:eac0369: 											gars.constructorTime,
1:eac0369: 											gars.openTime,
1:eac0369: 											gars.nextTime,
1:eac0369: 											gars.closeTime,
1:eac0369: 											gars.resultSetNumber,
1:eac0369: 											gars.rowsInput,
1:eac0369: 											gars.hasDistinctAggregate,
1:eac0369: 											gars.isInSortedOrder,
1:eac0369: 											gars.sortProperties,
1:eac0369: 											gars.optimizerEstimatedRowCount,
1:eac0369: 											gars.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(gars.source)
1:eac0369: 										);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof TableScanResultSet)
1:eac0369: 		{
1:eac0369: 			boolean instantaneousLocks = false;
1:eac0369: 			TableScanResultSet tsrs = (TableScanResultSet) rs;
1:eac0369: 			String startPosition = null;
1:eac0369: 			String stopPosition = null;
1:eac0369: 			String isolationLevel =  null;
1:eac0369: 			String lockString = null;
1:eac0369: 			String lockRequestString = null;
1:eac0369: 
1:eac0369: 			switch (tsrs.isolationLevel)
1:eac0369: 			{
1:eac0369: 				case TransactionController.ISOLATION_SERIALIZABLE:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_SERIALIZABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_REPEATABLE_READ);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1:eac0369: 					instantaneousLocks = true;
1:eac0369: 					//fall through
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED:
1:eac0369: 					isolationLevel = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_READ_COMMITTED);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_READ_UNCOMMITTED);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (tsrs.forUpdate)
1:eac0369: 			{
1:eac0369: 				lockString = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_EXCLUSIVE);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (instantaneousLocks)
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 														SQLState.LANG_SHARE);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			switch (tsrs.lockMode)
1:eac0369: 			{
1:eac0369: 				case TransactionController.MODE_TABLE:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockRequestString = lockString + " " +
1:eac0369: 										MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_TABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.MODE_RECORD:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockRequestString = lockString + " " +
1:eac0369: 										MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_ROW);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (tsrs.indexName != null)
1:eac0369: 			{
1:eac0369: 				/* Start and stop position strings will be non-null
1:eac0369: 			 	* if the TSRS has been closed.  Otherwise, we go off
1:eac0369: 			 	* and build the strings now.
1:eac0369: 			 	*/
1:eac0369: 				startPosition = tsrs.startPositionString;
1:eac0369: 				if (startPosition == null)
1:eac0369: 				{
1:eac0369: 					startPosition = tsrs.printStartPosition();
1:eac0369: 				}
1:eac0369: 				stopPosition = tsrs.stopPositionString;
1:eac0369: 				if (stopPosition == null)
1:eac0369: 				{
1:eac0369: 					stopPosition = tsrs.printStopPosition();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return new 
1:eac0369:                 RealTableScanStatistics(
1:eac0369:                     tsrs.numOpens,
1:eac0369:                     tsrs.rowsSeen,
1:eac0369:                     tsrs.rowsFiltered,
1:eac0369:                     tsrs.constructorTime,
1:eac0369:                     tsrs.openTime,
1:eac0369:                     tsrs.nextTime,
1:eac0369:                     tsrs.closeTime,
1:eac0369:                     tsrs.resultSetNumber,
1:eac0369:                     tsrs.tableName,
1:c7248d5: 					tsrs.userSuppliedOptimizerOverrides,
1:eac0369:                     tsrs.indexName,
1:eac0369:                     tsrs.isConstraint,
1:eac0369:                     tsrs.printQualifiers(tsrs.qualifiers),
1:eac0369:                     tsrs.getScanProperties(),
1:eac0369:                     startPosition,
1:eac0369:                     stopPosition,
1:eac0369:                     isolationLevel,
1:eac0369:                     lockRequestString,
1:eac0369:                     tsrs.rowsPerRead,
1:eac0369:                     tsrs.coarserLock,
1:eac0369:                     tsrs.optimizerEstimatedRowCount,
1:eac0369:                     tsrs.optimizerEstimatedCost);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		else if (rs instanceof LastIndexKeyResultSet )
1:eac0369: 		{
1:eac0369: 			LastIndexKeyResultSet lrs = (LastIndexKeyResultSet) rs;
1:eac0369: 			String isolationLevel =  null;
1:eac0369: 			String lockRequestString = null;
1:eac0369: 
1:eac0369: 			switch (lrs.isolationLevel)
1:eac0369: 			{
1:eac0369: 				case TransactionController.ISOLATION_SERIALIZABLE:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_SERIALIZABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_REPEATABLE_READ);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED:
1:eac0369: 					isolationLevel = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_READ_COMMITTED);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1:eac0369: 					isolationLevel = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_READ_UNCOMMITTED);
1:eac0369:                     break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			switch (lrs.lockMode)
1:eac0369: 			{
1:eac0369: 				case TransactionController.MODE_TABLE:
1:eac0369: 					lockRequestString = MessageService.getTextMessage(
1:eac0369: 													SQLState.LANG_SHARE_TABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.MODE_RECORD:
1:eac0369: 					lockRequestString = MessageService.getTextMessage(
1:eac0369: 													SQLState.LANG_SHARE_ROW);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return new RealLastIndexKeyScanStatistics(
1:eac0369: 											lrs.numOpens,
1:eac0369: 											lrs.constructorTime,
1:eac0369: 											lrs.openTime,
1:eac0369: 											lrs.nextTime,
1:eac0369: 											lrs.closeTime,
1:eac0369: 											lrs.resultSetNumber,
1:eac0369: 											lrs.tableName,
1:eac0369: 											lrs.indexName,
1:eac0369: 											isolationLevel,
1:eac0369: 											lockRequestString,
1:eac0369: 											lrs.optimizerEstimatedRowCount,
1:eac0369: 											lrs.optimizerEstimatedCost);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof HashLeftOuterJoinResultSet)
1:eac0369: 		{
1:eac0369: 			HashLeftOuterJoinResultSet hlojrs =
1:eac0369: 				(HashLeftOuterJoinResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealHashLeftOuterJoinStatistics(
1:eac0369: 											hlojrs.numOpens,
1:eac0369: 											hlojrs.rowsSeen,
1:eac0369: 											hlojrs.rowsFiltered,
1:eac0369: 											hlojrs.constructorTime,
1:eac0369: 											hlojrs.openTime,
1:eac0369: 											hlojrs.nextTime,
1:eac0369: 											hlojrs.closeTime,
1:eac0369: 											hlojrs.resultSetNumber,
1:eac0369: 											hlojrs.rowsSeenLeft,
1:eac0369: 											hlojrs.rowsSeenRight,
1:eac0369: 											hlojrs.rowsReturned,
1:eac0369: 											hlojrs.restrictionTime,
1:eac0369: 											hlojrs.optimizerEstimatedRowCount,
1:eac0369: 											hlojrs.optimizerEstimatedCost,
1:c7248d5: 											hlojrs.userSuppliedOptimizerOverrides,
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												hlojrs.leftResultSet),
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												hlojrs.rightResultSet),
1:eac0369: 											hlojrs.emptyRightRowsReturned);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof NestedLoopLeftOuterJoinResultSet)
1:eac0369: 		{
1:eac0369: 			NestedLoopLeftOuterJoinResultSet nllojrs =
1:eac0369: 				(NestedLoopLeftOuterJoinResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealNestedLoopLeftOuterJoinStatistics(
1:eac0369: 											nllojrs.numOpens,
1:eac0369: 											nllojrs.rowsSeen,
1:eac0369: 											nllojrs.rowsFiltered,
1:eac0369: 											nllojrs.constructorTime,
1:eac0369: 											nllojrs.openTime,
1:eac0369: 											nllojrs.nextTime,
1:eac0369: 											nllojrs.closeTime,
1:eac0369: 											nllojrs.resultSetNumber,
1:eac0369: 											nllojrs.rowsSeenLeft,
1:eac0369: 											nllojrs.rowsSeenRight,
1:eac0369: 											nllojrs.rowsReturned,
1:eac0369: 											nllojrs.restrictionTime,
1:eac0369: 											nllojrs.optimizerEstimatedRowCount,
1:eac0369: 											nllojrs.optimizerEstimatedCost,
1:c7248d5: 											nllojrs.userSuppliedOptimizerOverrides,
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												nllojrs.leftResultSet),
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												nllojrs.rightResultSet),
1:eac0369: 											nllojrs.emptyRightRowsReturned);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof HashJoinResultSet)
1:eac0369: 		{
1:eac0369: 			HashJoinResultSet hjrs = (HashJoinResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealHashJoinStatistics(
1:eac0369: 											hjrs.numOpens,
1:eac0369: 											hjrs.rowsSeen,
1:eac0369: 											hjrs.rowsFiltered,
1:eac0369: 											hjrs.constructorTime,
1:eac0369: 											hjrs.openTime,
1:eac0369: 											hjrs.nextTime,
1:eac0369: 											hjrs.closeTime,
1:eac0369: 											hjrs.resultSetNumber,
1:eac0369: 											hjrs.rowsSeenLeft,
1:eac0369: 											hjrs.rowsSeenRight,
1:eac0369: 											hjrs.rowsReturned,
1:eac0369: 											hjrs.restrictionTime,
1:eac0369: 											hjrs.oneRowRightSide,
1:eac0369: 											hjrs.optimizerEstimatedRowCount,
1:eac0369: 											hjrs.optimizerEstimatedCost,
1:c7248d5: 											hjrs.userSuppliedOptimizerOverrides,
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												hjrs.leftResultSet),
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												hjrs.rightResultSet)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof NestedLoopJoinResultSet)
1:eac0369: 		{
1:eac0369: 			NestedLoopJoinResultSet nljrs = (NestedLoopJoinResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealNestedLoopJoinStatistics(
1:eac0369: 											nljrs.numOpens,
1:eac0369: 											nljrs.rowsSeen,
1:eac0369: 											nljrs.rowsFiltered,
1:eac0369: 											nljrs.constructorTime,
1:eac0369: 											nljrs.openTime,
1:eac0369: 											nljrs.nextTime,
1:eac0369: 											nljrs.closeTime,
1:eac0369: 											nljrs.resultSetNumber,
1:eac0369: 											nljrs.rowsSeenLeft,
1:eac0369: 											nljrs.rowsSeenRight,
1:eac0369: 											nljrs.rowsReturned,
1:eac0369: 											nljrs.restrictionTime,
1:eac0369: 											nljrs.oneRowRightSide,
1:eac0369: 											nljrs.optimizerEstimatedRowCount,
1:eac0369: 											nljrs.optimizerEstimatedCost,
1:c7248d5: 											nljrs.userSuppliedOptimizerOverrides,
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												nljrs.leftResultSet),
1:eac0369: 											getResultSetStatistics(
1:eac0369: 												nljrs.rightResultSet)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof IndexRowToBaseRowResultSet)
1:eac0369: 		{
1:eac0369: 			IndexRowToBaseRowResultSet irtbrrs =
1:eac0369: 											(IndexRowToBaseRowResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealIndexRowToBaseRowStatistics(
1:eac0369: 											irtbrrs.numOpens,
1:eac0369: 											irtbrrs.rowsSeen,
1:eac0369: 											irtbrrs.rowsFiltered,
1:eac0369: 											irtbrrs.constructorTime,
1:eac0369: 											irtbrrs.openTime,
1:eac0369: 											irtbrrs.nextTime,
1:eac0369: 											irtbrrs.closeTime,
1:eac0369: 											irtbrrs.resultSetNumber,
1:eac0369: 											irtbrrs.indexName,
1:eac0369: 											irtbrrs.accessedHeapCols,
1:eac0369: 											irtbrrs.optimizerEstimatedRowCount,
1:eac0369: 											irtbrrs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(
1:eac0369: 																irtbrrs.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof RowResultSet)
1:eac0369: 		{
1:eac0369: 			RowResultSet rrs = (RowResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealRowResultSetStatistics(
1:eac0369: 											rrs.numOpens,
1:eac0369: 											rrs.rowsSeen,
1:eac0369: 											rrs.rowsFiltered,
1:eac0369: 											rrs.constructorTime,
1:eac0369: 											rrs.openTime,
1:eac0369: 											rrs.nextTime,
1:eac0369: 											rrs.closeTime,
1:eac0369: 											rrs.resultSetNumber,
1:eac0369: 											rrs.rowsReturned,
1:eac0369: 											rrs.optimizerEstimatedRowCount,
1:eac0369: 											rrs.optimizerEstimatedCost);
1:eac0369: 		}
1:7a9ce7e: 		else if (rs instanceof WindowResultSet)
1:7a9ce7e: 		{
1:7a9ce7e: 			WindowResultSet wrs = (WindowResultSet) rs;
1:7a9ce7e: 
1:7a9ce7e: 			return new RealWindowResultSetStatistics(
1:7a9ce7e: 											wrs.numOpens,
1:7a9ce7e: 											wrs.rowsSeen,
1:7a9ce7e: 											wrs.rowsFiltered,
1:7a9ce7e: 											wrs.constructorTime,
1:7a9ce7e: 											wrs.openTime,
1:7a9ce7e: 											wrs.nextTime,
1:7a9ce7e: 											wrs.closeTime,
1:7a9ce7e: 											wrs.resultSetNumber,
1:7a9ce7e: 											wrs.optimizerEstimatedRowCount,
1:7a9ce7e: 											wrs.optimizerEstimatedCost,
1:7a9ce7e: 											getResultSetStatistics(wrs.source)
1:7a9ce7e: 											);
1:7a9ce7e: 		}
1:6f2391f: 		else if (rs instanceof SetOpResultSet)
1:6f2391f: 		{
1:6f2391f: 			SetOpResultSet srs = (SetOpResultSet) rs;
1:6f2391f: 
1:6f2391f: 			return new RealSetOpResultSetStatistics(
1:6f2391f: 											srs.getOpType(),
1:6f2391f: 											srs.numOpens,
1:6f2391f: 											srs.rowsSeen,
1:6f2391f: 											srs.rowsFiltered,
1:6f2391f: 											srs.constructorTime,
1:6f2391f: 											srs.openTime,
1:6f2391f: 											srs.nextTime,
1:6f2391f: 											srs.closeTime,
1:6f2391f: 											srs.getResultSetNumber(),
1:6f2391f: 											srs.getRowsSeenLeft(),
1:6f2391f: 											srs.getRowsSeenRight(),
1:6f2391f: 											srs.getRowsReturned(),
1:6f2391f: 											srs.optimizerEstimatedRowCount,
1:6f2391f: 											srs.optimizerEstimatedCost,
1:6f2391f: 											getResultSetStatistics(srs.getLeftSourceInput()),
1:6f2391f: 											getResultSetStatistics(srs.getRightSourceInput())
1:c723732: 											);
1:c723732: 		}
1:eac0369: 		else if (rs instanceof UnionResultSet)
1:eac0369: 		{
1:6f2391f: 			UnionResultSet urs = (UnionResultSet)rs;
1:eac0369: 
1:eac0369: 			return new RealUnionResultSetStatistics(
1:eac0369: 											urs.numOpens,
1:eac0369: 											urs.rowsSeen,
1:eac0369: 											urs.rowsFiltered,
1:eac0369: 											urs.constructorTime,
1:eac0369: 											urs.openTime,
1:eac0369: 											urs.nextTime,
1:eac0369: 											urs.closeTime,
1:eac0369: 											urs.resultSetNumber,
1:eac0369: 											urs.rowsSeenLeft,
1:eac0369: 											urs.rowsSeenRight,
1:eac0369: 											urs.rowsReturned,
1:eac0369: 											urs.optimizerEstimatedRowCount,
1:eac0369: 											urs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(urs.source1),
1:eac0369: 											getResultSetStatistics(urs.source2)
1:6f2391f: 											);
1:6f2391f: 		}
1:eac0369: 		else if (rs instanceof AnyResultSet)
1:eac0369: 		{
1:eac0369: 			AnyResultSet ars = (AnyResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealAnyResultSetStatistics(
1:eac0369: 											ars.numOpens,
1:eac0369: 											ars.rowsSeen,
1:eac0369: 											ars.rowsFiltered,
1:eac0369: 											ars.constructorTime,
1:eac0369: 											ars.openTime,
1:eac0369: 											ars.nextTime,
1:eac0369: 											ars.closeTime,
1:eac0369: 											ars.resultSetNumber,
1:eac0369: 											ars.subqueryNumber,
1:eac0369: 											ars.pointOfAttachment,
1:eac0369: 											ars.optimizerEstimatedRowCount,
1:eac0369: 											ars.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(ars.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof OnceResultSet)
1:eac0369: 		{
1:eac0369: 			OnceResultSet ors = (OnceResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealOnceResultSetStatistics(
1:eac0369: 											ors.numOpens,
1:eac0369: 											ors.rowsSeen,
1:eac0369: 											ors.rowsFiltered,
1:eac0369: 											ors.constructorTime,
1:eac0369: 											ors.openTime,
1:eac0369: 											ors.nextTime,
1:eac0369: 											ors.closeTime,
1:eac0369: 											ors.resultSetNumber,
1:eac0369: 											ors.subqueryNumber,
1:eac0369: 											ors.pointOfAttachment,
1:eac0369: 											ors.optimizerEstimatedRowCount,
1:eac0369: 											ors.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(ors.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof NormalizeResultSet)
1:eac0369: 		{
1:eac0369: 			NormalizeResultSet nrs = (NormalizeResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealNormalizeResultSetStatistics(
1:eac0369: 											nrs.numOpens,
1:eac0369: 											nrs.rowsSeen,
1:eac0369: 											nrs.rowsFiltered,
1:eac0369: 											nrs.constructorTime,
1:eac0369: 											nrs.openTime,
1:eac0369: 											nrs.nextTime,
1:eac0369: 											nrs.closeTime,
1:eac0369: 											nrs.resultSetNumber,
1:eac0369: 											nrs.optimizerEstimatedRowCount,
1:eac0369: 											nrs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(nrs.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof MaterializedResultSet)
1:eac0369: 		{
1:eac0369: 			MaterializedResultSet mrs = (MaterializedResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealMaterializedResultSetStatistics(
1:eac0369: 											mrs.numOpens,
1:eac0369: 											mrs.rowsSeen,
1:eac0369: 											mrs.rowsFiltered,
1:eac0369: 											mrs.constructorTime,
1:eac0369: 											mrs.openTime,
1:eac0369: 											mrs.nextTime,
1:eac0369: 											mrs.closeTime,
1:eac0369: 											mrs.createTCTime,
1:eac0369: 											mrs.fetchTCTime,
1:eac0369: 											mrs.resultSetNumber,
1:eac0369: 											mrs.optimizerEstimatedRowCount,
1:eac0369: 											mrs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(mrs.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof ScrollInsensitiveResultSet)
1:eac0369: 		{
1:eac0369: 			ScrollInsensitiveResultSet sirs = (ScrollInsensitiveResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealScrollInsensitiveResultSetStatistics(
1:eac0369: 											sirs.numOpens,
1:eac0369: 											sirs.rowsSeen,
1:eac0369: 											sirs.rowsFiltered,
1:eac0369: 											sirs.constructorTime,
1:eac0369: 											sirs.openTime,
1:eac0369: 											sirs.nextTime,
1:eac0369: 											sirs.closeTime,
1:eac0369: 											sirs.numFromHashTable,
1:eac0369: 											sirs.numToHashTable,
1:eac0369: 											sirs.resultSetNumber,
1:eac0369: 											sirs.optimizerEstimatedRowCount,
1:eac0369: 											sirs.optimizerEstimatedCost,
1:eac0369: 											getResultSetStatistics(sirs.source)
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof CurrentOfResultSet)
1:eac0369: 		{
1:eac0369: 			CurrentOfResultSet cors = (CurrentOfResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealCurrentOfStatistics(
1:eac0369: 											cors.numOpens,
1:eac0369: 											cors.rowsSeen,
1:eac0369: 											cors.rowsFiltered,
1:eac0369: 											cors.constructorTime,
1:eac0369: 											cors.openTime,
1:eac0369: 											cors.nextTime,
1:eac0369: 											cors.closeTime,
1:eac0369: 											cors.resultSetNumber
1:eac0369: 											);
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof HashScanResultSet)
1:eac0369: 		{
1:eac0369: 			boolean instantaneousLocks = false;
1:eac0369: 			HashScanResultSet hsrs = (HashScanResultSet) rs;
1:eac0369: 			String startPosition = null;
1:eac0369: 			String stopPosition = null;
1:eac0369: 			String isolationLevel =  null;
1:eac0369: 			String lockString = null;
1:eac0369: 
1:eac0369: 			switch (hsrs.isolationLevel)
1:eac0369: 			{
1:eac0369: 				case TransactionController.ISOLATION_SERIALIZABLE:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_SERIALIZABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_REPEATABLE_READ);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1:eac0369: 					instantaneousLocks = true;
1:eac0369: 					//fall through
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED:
1:eac0369: 					isolationLevel = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_READ_COMMITTED);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (hsrs.forUpdate)
1:eac0369: 			{
1:eac0369: 				lockString = MessageService.getTextMessage(
1:eac0369: 													SQLState.LANG_EXCLUSIVE);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (instantaneousLocks)
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 														SQLState.LANG_SHARE);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			switch (hsrs.lockMode)
1:eac0369: 			{
1:eac0369: 				case TransactionController.MODE_TABLE:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockString = lockString + " " +
1:eac0369: 									MessageService.getTextMessage(
1:eac0369: 														SQLState.LANG_TABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.MODE_RECORD:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockString = lockString + " " +
1:eac0369: 									MessageService.getTextMessage(
1:eac0369: 															SQLState.LANG_ROW);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (hsrs.indexName != null)
1:eac0369: 			{
1:eac0369: 				/* Start and stop position strings will be non-null
1:eac0369: 			 	* if the HSRS has been closed.  Otherwise, we go off
1:eac0369: 			 	* and build the strings now.
1:eac0369: 			 	*/
1:eac0369: 				startPosition = hsrs.startPositionString;
1:eac0369: 				if (startPosition == null)
1:eac0369: 				{
1:eac0369: 					startPosition = hsrs.printStartPosition();
1:eac0369: 				}
1:eac0369: 				stopPosition = hsrs.stopPositionString;
1:eac0369: 				if (stopPosition == null)
1:eac0369: 				{
1:eac0369: 					stopPosition = hsrs.printStopPosition();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// DistinctScanResultSet is simple sub-class of
1:eac0369: 			// HashScanResultSet
1:eac0369: 			if (rs instanceof DistinctScanResultSet)
1:eac0369: 			{
1:eac0369: 				return new RealDistinctScanStatistics(
1:eac0369: 											hsrs.numOpens,
1:eac0369: 											hsrs.rowsSeen,
1:eac0369: 											hsrs.rowsFiltered,
1:eac0369: 											hsrs.constructorTime,
1:eac0369: 											hsrs.openTime,
1:eac0369: 											hsrs.nextTime,
1:eac0369: 											hsrs.closeTime,
1:eac0369: 											hsrs.resultSetNumber,
1:eac0369: 											hsrs.tableName,
1:eac0369: 											hsrs.indexName,
1:eac0369: 											hsrs.isConstraint,
1:eac0369: 											hsrs.hashtableSize,
1:eac0369: 											hsrs.keyColumns,
1:eac0369: 											hsrs.printQualifiers(
1:eac0369: 												hsrs.scanQualifiers),
1:eac0369: 											hsrs.printQualifiers(
1:eac0369: 												hsrs.nextQualifiers),
1:eac0369: 											hsrs.getScanProperties(),
1:eac0369: 											startPosition,
1:eac0369: 											stopPosition,
1:eac0369: 											isolationLevel,
1:eac0369: 											lockString,
1:eac0369: 											hsrs.optimizerEstimatedRowCount,
1:eac0369: 											hsrs.optimizerEstimatedCost
1:eac0369: 											);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				return new RealHashScanStatistics(
1:eac0369: 											hsrs.numOpens,
1:eac0369: 											hsrs.rowsSeen,
1:eac0369: 											hsrs.rowsFiltered,
1:eac0369: 											hsrs.constructorTime,
1:eac0369: 											hsrs.openTime,
1:eac0369: 											hsrs.nextTime,
1:eac0369: 											hsrs.closeTime,
1:eac0369: 											hsrs.resultSetNumber,
1:eac0369: 											hsrs.tableName,
1:eac0369: 											hsrs.indexName,
1:eac0369: 											hsrs.isConstraint,
1:eac0369: 											hsrs.hashtableSize,
1:eac0369: 											hsrs.keyColumns,
1:eac0369: 											hsrs.printQualifiers(
1:eac0369: 												hsrs.scanQualifiers),
1:eac0369: 											hsrs.printQualifiers(
1:eac0369: 												hsrs.nextQualifiers),
1:eac0369: 											hsrs.getScanProperties(),
1:eac0369: 											startPosition,
1:eac0369: 											stopPosition,
1:eac0369: 											isolationLevel,
1:eac0369: 											lockString,
1:eac0369: 											hsrs.optimizerEstimatedRowCount,
1:eac0369: 											hsrs.optimizerEstimatedCost
1:eac0369: 											);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof HashTableResultSet)
1:eac0369: 		{
1:eac0369: 			HashTableResultSet htrs = (HashTableResultSet) rs;
1:eac0369: 			int subqueryTrackingArrayLength =
1:eac0369: 				(htrs.subqueryTrackingArray == null) ? 0 :
1:eac0369: 					htrs.subqueryTrackingArray.length;
1:eac0369: 			ResultSetStatistics[] subqueryTrackingArray =
1:eac0369: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1:eac0369: 			boolean anyAttached = false;
1:eac0369: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
1:eac0369: 			{
1:eac0369: 				if (htrs.subqueryTrackingArray[index] != null &&
1:eac0369: 					htrs.subqueryTrackingArray[index].getPointOfAttachment() ==
1:eac0369: 						htrs.resultSetNumber)
1:eac0369: 				{
1:eac0369: 					subqueryTrackingArray[index] =
1:eac0369: 										getResultSetStatistics(
1:eac0369: 											htrs.subqueryTrackingArray[index]);
1:eac0369: 					anyAttached = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (! anyAttached)
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return new 
1:eac0369:                 RealHashTableStatistics(
1:eac0369:                     htrs.numOpens,
1:eac0369:                     htrs.rowsSeen,
1:eac0369:                     htrs.rowsFiltered,
1:eac0369:                     htrs.constructorTime,
1:eac0369:                     htrs.openTime,
1:eac0369:                     htrs.nextTime,
1:eac0369:                     htrs.closeTime,
1:eac0369:                     htrs.resultSetNumber,
1:eac0369:                     htrs.hashtableSize,
1:eac0369:                     htrs.keyColumns,
1:eac0369:                     HashScanResultSet.printQualifiers(
1:eac0369:                         htrs.nextQualifiers),
1:eac0369:                     htrs.scanProperties,
1:eac0369:                     htrs.optimizerEstimatedRowCount,
1:eac0369:                     htrs.optimizerEstimatedCost,
1:eac0369:                     subqueryTrackingArray,
1:eac0369:                     getResultSetStatistics(htrs.source)
1:eac0369:                     );
1:eac0369: 		}
1:eac0369: 		else if (rs instanceof VTIResultSet)
1:eac0369: 		{
1:eac0369: 			VTIResultSet vtirs = (VTIResultSet) rs;
1:eac0369: 
1:eac0369: 			return new RealVTIStatistics(
1:eac0369: 										vtirs.numOpens,
1:eac0369: 										vtirs.rowsSeen,
1:eac0369: 										vtirs.rowsFiltered,
1:eac0369: 										vtirs.constructorTime,
1:eac0369: 										vtirs.openTime,
1:eac0369: 										vtirs.nextTime,
1:eac0369: 										vtirs.closeTime,
1:eac0369: 										vtirs.resultSetNumber,
1:eac0369: 										vtirs.javaClassName,
1:eac0369: 										vtirs.optimizerEstimatedRowCount,
1:eac0369: 										vtirs.optimizerEstimatedCost
1:eac0369: 										);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		else if (rs instanceof DependentResultSet)
1:eac0369: 		{
1:eac0369: 			boolean instantaneousLocks = false;
1:eac0369: 			DependentResultSet dsrs = (DependentResultSet) rs;
1:eac0369: 			String startPosition = null;
1:eac0369: 			String stopPosition = null;
1:eac0369: 			String isolationLevel =  null;
1:eac0369: 			String lockString = null;
1:eac0369: 			String lockRequestString = null;
1:eac0369: 
1:eac0369: 			switch (dsrs.isolationLevel)
1:eac0369: 			{
1:eac0369: 				case TransactionController.ISOLATION_SERIALIZABLE:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_SERIALIZABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_REPEATABLE_READ);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1:eac0369: 					instantaneousLocks = true;
1:eac0369: 					//fall through
1:eac0369: 				case TransactionController.ISOLATION_READ_COMMITTED:
1:eac0369: 					isolationLevel = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_READ_COMMITTED);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1:eac0369: 					isolationLevel = 
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_READ_UNCOMMITTED);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (dsrs.forUpdate)
1:eac0369: 			{
1:eac0369: 				lockString = MessageService.getTextMessage(
1:eac0369: 												SQLState.LANG_EXCLUSIVE);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (instantaneousLocks)
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					lockString = MessageService.getTextMessage(
1:eac0369: 														SQLState.LANG_SHARE);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			switch (dsrs.lockMode)
1:eac0369: 			{
1:eac0369: 				case TransactionController.MODE_TABLE:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockRequestString = lockString + " " +
1:eac0369: 										MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_TABLE);
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				case TransactionController.MODE_RECORD:
1:eac0369: 					// RESOLVE: Not sure this will really work, as we
1:eac0369: 					// are tacking together English words to make a phrase.
1:eac0369: 					// Will this work in other languages?
1:eac0369: 					lockRequestString = lockString + " " +
1:eac0369: 										MessageService.getTextMessage(
1:eac0369: 											SQLState.LANG_ROW);
1:eac0369: 					break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Start and stop position strings will be non-null
1:eac0369: 			 * if the dSRS has been closed.  Otherwise, we go off
1:eac0369: 			 * and build the strings now.
1:eac0369: 			 */
1:eac0369: 			startPosition = dsrs.startPositionString;
1:eac0369: 			if (startPosition == null)
1:eac0369: 			{
1:eac0369: 				startPosition = dsrs.printStartPosition();
1:eac0369: 			}
1:eac0369: 			stopPosition = dsrs.stopPositionString;
1:eac0369: 			if (stopPosition == null)
1:eac0369: 			{
1:eac0369: 				stopPosition = dsrs.printStopPosition();
1:eac0369: 			}
1:eac0369: 		
1:eac0369: 			return new 
1:eac0369:                 RealTableScanStatistics(
1:eac0369:                     dsrs.numOpens,
1:eac0369:                     dsrs.rowsSeen,
1:eac0369:                     dsrs.rowsFiltered,
1:eac0369:                     dsrs.constructorTime,
1:eac0369:                     dsrs.openTime,
1:eac0369:                     dsrs.nextTime,
1:eac0369:                     dsrs.closeTime,
1:eac0369:                     dsrs.resultSetNumber,
1:eac0369:                     dsrs.tableName,
1:c7248d5: 					null,
1:eac0369:                     dsrs.indexName,
1:eac0369:                     dsrs.isConstraint,
1:eac0369:                     dsrs.printQualifiers(),
1:eac0369:                     dsrs.getScanProperties(),
1:eac0369:                     startPosition,
1:eac0369:                     stopPosition,
1:eac0369:                     isolationLevel,
1:eac0369:                     lockRequestString,
1:eac0369:                     dsrs.rowsPerRead,
1:eac0369:                     dsrs.coarserLock,
1:eac0369:                     dsrs.optimizerEstimatedRowCount,
1:eac0369:                     dsrs.optimizerEstimatedCost);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class interface
1:eac0369: 	//
1:eac0369: 	public RealResultSetStatisticsFactory() 
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1:                                     (int) irs.rowCount,
/////////////////////////////////////////////////////////////////////////
1:                                     (int) iVTIrs.rowCount,
/////////////////////////////////////////////////////////////////////////
1:                                     (int) urs.rowCount,
/////////////////////////////////////////////////////////////////////////
1:                                     (int) dcrs.rowCount,
/////////////////////////////////////////////////////////////////////////
1: 									(int) drs.rowCount,
/////////////////////////////////////////////////////////////////////////
1: 									(int) dVTIrs.rowCount,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5825332
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ResultSetStatistics;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.WindowResultSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics;
/////////////////////////////////////////////////////////////////////////
1: 		else if (rs instanceof WindowResultSet)
1: 		{
1: 			WindowResultSet wrs = (WindowResultSet) rs;
1: 
1: 			return new RealWindowResultSetStatistics(
1: 											wrs.numOpens,
1: 											wrs.rowsSeen,
1: 											wrs.rowsFiltered,
1: 											wrs.constructorTime,
1: 											wrs.openTime,
1: 											wrs.nextTime,
1: 											wrs.closeTime,
1: 											wrs.resultSetNumber,
1: 											wrs.optimizerEstimatedRowCount,
1: 											wrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(wrs.source)
1: 											);
1: 		}
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.rts.RealRowCountStatistics;
/////////////////////////////////////////////////////////////////////////
1: 		else if (rs instanceof RowCountResultSet)
1: 		{
1: 			RowCountResultSet rcrs = (RowCountResultSet) rs;
1: 
1: 			return new RealRowCountStatistics(
1: 				rcrs.numOpens,
1: 				rcrs.rowsSeen,
1: 				rcrs.rowsFiltered,
1: 				rcrs.constructorTime,
1: 				rcrs.openTime,
1: 				rcrs.nextTime,
1: 				rcrs.closeTime,
1: 				rcrs.resultSetNumber,
1: 				rcrs.optimizerEstimatedRowCount,
1: 				rcrs.optimizerEstimatedCost,
1: 				getResultSetStatistics(rcrs.source) );
1: 		}
author:Army
-------------------------------------------------------------------------------
commit:c723732
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.execute.WindowResultSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics;
/////////////////////////////////////////////////////////////////////////
0: 		else if (rs instanceof WindowResultSet)
1: 		{
0: 			WindowResultSet wrs = (WindowResultSet) rs;
1: 
0: 			return new RealWindowResultSetStatistics(											
0: 											wrs.numOpens,
0: 											wrs.rowsSeen,
0: 											wrs.rowsFiltered,
0: 											wrs.constructorTime,
0: 											wrs.openTime,
0: 											wrs.nextTime,
0: 											wrs.closeTime,
0: 											wrs.resultSetNumber,											
0: 											wrs.optimizerEstimatedRowCount,
0: 											wrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(wrs.source)		
1: 											);
1: 		}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6f2391f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.SetOpResultSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.rts.RealSetOpResultSetStatistics;
/////////////////////////////////////////////////////////////////////////
1: 		else if (rs instanceof SetOpResultSet)
1: 		{
1: 			SetOpResultSet srs = (SetOpResultSet) rs;
1: 
1: 			return new RealSetOpResultSetStatistics(
1: 											srs.getOpType(),
1: 											srs.numOpens,
1: 											srs.rowsSeen,
1: 											srs.rowsFiltered,
1: 											srs.constructorTime,
1: 											srs.openTime,
1: 											srs.nextTime,
1: 											srs.closeTime,
1: 											srs.getResultSetNumber(),
1: 											srs.getRowsSeenLeft(),
1: 											srs.getRowsSeenRight(),
1: 											srs.getRowsReturned(),
1: 											srs.optimizerEstimatedRowCount,
1: 											srs.optimizerEstimatedCost,
1: 											getResultSetStatistics(srs.getLeftSourceInput()),
1: 											getResultSetStatistics(srs.getRightSourceInput())
1: 											);
1: 		}
1: 			UnionResultSet urs = (UnionResultSet)rs;
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 					tsrs.userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 											hlojrs.userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 											nllojrs.userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 											hjrs.userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 											nljrs.userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 					null,
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.RealResultSetStatisticsFactory
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: 
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.impl.sql.execute.AnyResultSet;
1: import org.apache.derby.impl.sql.execute.CurrentOfResultSet;
1: import org.apache.derby.impl.sql.execute.DeleteResultSet;
1: import org.apache.derby.impl.sql.execute.DeleteCascadeResultSet;
1: import org.apache.derby.impl.sql.execute.DeleteVTIResultSet;
1: import org.apache.derby.impl.sql.execute.DistinctScalarAggregateResultSet;
1: import org.apache.derby.impl.sql.execute.DistinctScanResultSet;
1: import org.apache.derby.impl.sql.execute.GroupedAggregateResultSet;
1: import org.apache.derby.impl.sql.execute.HashJoinResultSet;
1: import org.apache.derby.impl.sql.execute.HashLeftOuterJoinResultSet;
1: import org.apache.derby.impl.sql.execute.HashScanResultSet;
1: import org.apache.derby.impl.sql.execute.HashTableResultSet;
1: import org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet;
1: import org.apache.derby.impl.sql.execute.InsertResultSet;
1: import org.apache.derby.impl.sql.execute.InsertVTIResultSet;
1: import org.apache.derby.impl.sql.execute.LastIndexKeyResultSet;
1: import org.apache.derby.impl.sql.execute.MaterializedResultSet;
1: import org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet;
1: import org.apache.derby.impl.sql.execute.NestedLoopLeftOuterJoinResultSet;
1: import org.apache.derby.impl.sql.execute.NormalizeResultSet;
1: import org.apache.derby.impl.sql.execute.OnceResultSet;
1: import org.apache.derby.impl.sql.execute.ProjectRestrictResultSet;
1: import org.apache.derby.impl.sql.execute.RowResultSet;
1: import org.apache.derby.impl.sql.execute.ScalarAggregateResultSet;
1: import org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet;
1: import org.apache.derby.impl.sql.execute.SortResultSet;
1: import org.apache.derby.impl.sql.execute.TableScanResultSet;
1: import org.apache.derby.impl.sql.execute.UnionResultSet;
1: import org.apache.derby.impl.sql.execute.UpdateResultSet;
1: import org.apache.derby.impl.sql.execute.VTIResultSet;
1: import org.apache.derby.impl.sql.execute.DependentResultSet;
1: 
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealAnyResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealCurrentOfStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealDeleteResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealDeleteCascadeResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealDeleteVTIResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealDistinctScalarAggregateStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealDistinctScanStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealGroupedAggregateStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealHashJoinStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealHashLeftOuterJoinStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealHashTableStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealIndexRowToBaseRowStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealInsertResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealInsertVTIResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealJoinResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealLastIndexKeyScanStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealMaterializedResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopJoinStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopLeftOuterJoinStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealNormalizeResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealOnceResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealProjectRestrictStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealRowResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealScalarAggregateStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealScrollInsensitiveResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealSortStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RealVTIStatistics;
0: import org.apache.derby.impl.sql.execute.rts.ResultSetStatistics;
1: import org.apache.derby.impl.sql.execute.rts.RunTimeStatisticsImpl;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.util.Properties;
1: 
1: /**
1:  * ResultSetStatisticsFactory provides a wrapper around all of
1:  * objects associated with run time statistics.
1:  * <p>
1:  * This implementation of the protocol is for returning the "real"
1:  * run time statistics.  We have modularized this so that we could
1:  * have an implementation that just returns null for each of the
1:  * objects should we decided to provide a configuration without
1:  * the run time statistics feature.
1:  *
0:  * @author jerry
1:  */
1: public class RealResultSetStatisticsFactory 
1: 		implements ResultSetStatisticsFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	//
1: 	// ExecutionFactory interface
1: 	//
1: 	//
1: 	// ResultSetStatisticsFactory interface
1: 	//
1: 
1: 	/**
1: 		@see ResultSetStatisticsFactory#getRunTimeStatistics
1: 	 */
1: 	public RunTimeStatistics getRunTimeStatistics(
1: 			Activation activation, 
1: 			ResultSet rs,
1: 			NoPutResultSet[] subqueryTrackingArray)
1: 		throws StandardException
1: 	{
1: 		PreparedStatement preStmt = activation.getPreparedStatement();
1: 
1: 		// If the prepared statement is null then the result set is being
1: 		// finished as a result of a activation being closed during a recompile.
1: 		// In this case statistics should not be generated.
1: 		if (preStmt == null)
1: 			return null;
1: 
1: 
1: 
1: 
1: 		ResultSetStatistics topResultSetStatistics;
1: 
1: 		if (rs instanceof NoPutResultSet)
1: 		{
1: 			topResultSetStatistics =
1: 									getResultSetStatistics((NoPutResultSet) rs);
1: 		}
1: 		else
1: 		{
1: 			topResultSetStatistics = getResultSetStatistics(rs);
1: 		}
1: 
1: 		/* Build up the info on the materialized subqueries */
1: 		int subqueryTrackingArrayLength =
1: 				(subqueryTrackingArray == null) ? 0 :
1: 					subqueryTrackingArray.length;
1: 		ResultSetStatistics[] subqueryRSS =
1: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1: 		boolean anyAttached = false;
1: 		for (int index = 0; index < subqueryTrackingArrayLength; index++)
1: 		{
1: 			if (subqueryTrackingArray[index] != null &&
1: 				subqueryTrackingArray[index].getPointOfAttachment() == -1)
1: 			{
1: 				subqueryRSS[index] =
1: 						getResultSetStatistics(subqueryTrackingArray[index]);
1: 				anyAttached = true;
1: 			}
1: 		}
1: 		if (anyAttached == false)
1: 		{
1: 			subqueryRSS = null;
1: 		}
1: 
1: 		// Get the info on all of the materialized subqueries (attachment point = -1)
1: 		return new RunTimeStatisticsImpl(
1: 								preStmt.getSPSName(),
1: 								activation.getCursorName(),
1: 								preStmt.getSource(),
1: 								preStmt.getCompileTimeInMillis(),
1: 								preStmt.getParseTimeInMillis(),
1: 								preStmt.getBindTimeInMillis(),
1: 								preStmt.getOptimizeTimeInMillis(),
1: 								preStmt.getGenerateTimeInMillis(),
1: 								rs.getExecuteTime(),
1: 								preStmt.getBeginCompileTimestamp(),
1: 								preStmt.getEndCompileTimestamp(),
1: 								rs.getBeginExecutionTimestamp(),
1: 								rs.getEndExecutionTimestamp(),
1: 								subqueryRSS,
1: 								topResultSetStatistics);
1: 	}
1: 
1: 	/**
1: 		@see ResultSetStatisticsFactory#getResultSetStatistics
1: 	 */
1: 	public ResultSetStatistics getResultSetStatistics(ResultSet rs)
1: 	{
1: 		if (!rs.returnsRows())
1: 		{
1: 			return getNoRowsResultSetStatistics(rs);
1: 		}
1: 		else if (rs instanceof NoPutResultSet)
1: 		{
1: 			return getResultSetStatistics((NoPutResultSet) rs);
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
1: 	public ResultSetStatistics getNoRowsResultSetStatistics(ResultSet rs)
1: 	{
1: 		ResultSetStatistics retval = null;
1: 
1: 		/* We need to differentiate based on instanceof in order
1: 		 * to find the right constructor to call.  This is ugly,
1: 		 * but if we don't do instanceof then rs is always seen as an
1: 		 * interface instead of a class when we try to overload 
1: 		 * a method with both.
1: 		 */
1: 		if( rs instanceof InsertResultSet)
1: 		{
1: 			InsertResultSet irs = (InsertResultSet) rs;
1: 
1: 			retval = new RealInsertResultSetStatistics(
0: 									irs.rowCount,
1: 									irs.constants.deferred,
1: 									irs.constants.irgs.length,
1: 									irs.userSpecifiedBulkInsert,
1: 									irs.bulkInsertPerformed,
1: 									irs.constants.lockMode ==
1: 										TransactionController.MODE_TABLE,
1: 									irs.getExecuteTime(), 
1: 									getResultSetStatistics(irs.savedSource)
1: 									);
1: 
1: 			irs.savedSource = null;
1: 		}
1: 		else if( rs instanceof InsertVTIResultSet)
1: 		{
1: 			InsertVTIResultSet iVTIrs = (InsertVTIResultSet) rs;
1: 
1: 			retval = new RealInsertVTIResultSetStatistics(
0: 									iVTIrs.rowCount,
1: 									iVTIrs.constants.deferred,
1: 									iVTIrs.getExecuteTime(), 
1: 									getResultSetStatistics(iVTIrs.savedSource)
1: 									);
1: 
1: 			iVTIrs.savedSource = null;
1: 		}
1: 		else if( rs instanceof UpdateResultSet)
1: 		{
1: 			UpdateResultSet urs = (UpdateResultSet) rs;
1: 
1: 			retval = new RealUpdateResultSetStatistics(
0: 									urs.rowCount,
1: 									urs.constants.deferred,
1: 									urs.constants.irgs.length,
1: 									urs.constants.lockMode ==
1: 										TransactionController.MODE_TABLE,
1: 									urs.getExecuteTime(),
1: 									getResultSetStatistics(urs.savedSource)
1: 									);
1: 
1: 			urs.savedSource = null;
1: 		}
1: 		else if( rs instanceof DeleteCascadeResultSet)
1: 		{
1: 			DeleteCascadeResultSet dcrs = (DeleteCascadeResultSet) rs;
1: 			int dependentTrackingArrayLength =
1: 				(dcrs.dependentResultSets == null) ? 0 :
1: 					dcrs.dependentResultSets.length;
1: 			ResultSetStatistics[] dependentTrackingArray =
1: 				new ResultSetStatistics[dependentTrackingArrayLength];
1: 			boolean anyAttached = false;
1: 			for (int index = 0; index < dependentTrackingArrayLength; index++)
1: 			{
1: 				if (dcrs.dependentResultSets[index] != null)
1: 				{
1: 					dependentTrackingArray[index] =
1: 										getResultSetStatistics(
1: 											dcrs.dependentResultSets[index]);
1: 					anyAttached = true;
1: 				}
1: 			}
1: 			if (! anyAttached)
1: 			{
1: 				dependentTrackingArray = null;
1: 			}
1: 
1: 			retval = new RealDeleteCascadeResultSetStatistics(
0: 									dcrs.rowCount,
1: 									dcrs.constants.deferred,
1: 									dcrs.constants.irgs.length,
1: 									dcrs.constants.lockMode ==
1: 										TransactionController.MODE_TABLE,
1: 									dcrs.getExecuteTime(),
1: 									getResultSetStatistics(dcrs.savedSource),
1: 									dependentTrackingArray
1: 									);
1: 
1: 			dcrs.savedSource = null;
1: 		}
1: 		else if( rs instanceof DeleteResultSet)
1: 		{
1: 			DeleteResultSet drs = (DeleteResultSet) rs;
1: 
1: 			retval = new RealDeleteResultSetStatistics(
0: 									drs.rowCount,
1: 									drs.constants.deferred,
1: 									drs.constants.irgs.length,
1: 									drs.constants.lockMode ==
1: 										TransactionController.MODE_TABLE,
1: 									drs.getExecuteTime(),
1: 									getResultSetStatistics(drs.savedSource)
1: 									);
1: 
1: 			drs.savedSource = null;
1: 		}
1: 		else if( rs instanceof DeleteVTIResultSet)
1: 		{
1: 			DeleteVTIResultSet dVTIrs = (DeleteVTIResultSet) rs;
1: 
1: 			retval = new RealDeleteVTIResultSetStatistics(
0: 									dVTIrs.rowCount,
1: 									dVTIrs.getExecuteTime(), 
1: 									getResultSetStatistics(dVTIrs.savedSource)
1: 									);
1: 
1: 			dVTIrs.savedSource = null;
1: 		}
1: 
1: 
1: 		return retval;
1: 	}
1: 
1: 	public ResultSetStatistics getResultSetStatistics(NoPutResultSet rs)
1: 	{
1: 		/* We need to differentiate based on instanceof in order
1: 		 * to find the right constructor to call.  This is ugly,
1: 		 * but if we don't do instanceof then rs is always seen as an
1: 		 * interface instead of a class when we try to overload 
1: 		 * a method with both.
1: 		 */
1: 		if( rs instanceof ProjectRestrictResultSet)
1: 		{
1: 			ProjectRestrictResultSet prrs = (ProjectRestrictResultSet) rs;
1: 			int subqueryTrackingArrayLength =
1: 				(prrs.subqueryTrackingArray == null) ? 0 :
1: 					prrs.subqueryTrackingArray.length;
1: 			ResultSetStatistics[] subqueryTrackingArray =
1: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1: 			boolean anyAttached = false;
1: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
1: 			{
1: 				if (prrs.subqueryTrackingArray[index] != null &&
1: 					prrs.subqueryTrackingArray[index].getPointOfAttachment() ==
1: 						prrs.resultSetNumber)
1: 				{
1: 					subqueryTrackingArray[index] =
1: 										getResultSetStatistics(
1: 											prrs.subqueryTrackingArray[index]);
1: 					anyAttached = true;
1: 				}
1: 			}
1: 			if (! anyAttached)
1: 			{
1: 				subqueryTrackingArray = null;
1: 			}
1: 
1: 			return new RealProjectRestrictStatistics(
1: 											prrs.numOpens,
1: 											prrs.rowsSeen,
1: 											prrs.rowsFiltered,
1: 											prrs.constructorTime,
1: 											prrs.openTime,
1: 											prrs.nextTime,
1: 											prrs.closeTime,
1: 											prrs.resultSetNumber,
1: 											prrs.restrictionTime,
1: 											prrs.projectionTime,
1: 											subqueryTrackingArray,
1: 											(prrs.restriction != null),
1: 											prrs.doesProjection,
1: 											prrs.optimizerEstimatedRowCount,
1: 											prrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(prrs.source)
1: 											);
1: 		}
1: 		else if (rs instanceof SortResultSet)
1: 		{
1: 			SortResultSet srs = (SortResultSet) rs;
1: 
1: 			return new RealSortStatistics(
1: 											srs.numOpens,
1: 											srs.rowsSeen,
1: 											srs.rowsFiltered,
1: 											srs.constructorTime,
1: 											srs.openTime,
1: 											srs.nextTime,
1: 											srs.closeTime,
1: 											srs.resultSetNumber,
1: 											srs.rowsInput,
1: 											srs.rowsReturned,
1: 											srs.distinct,
1: 											srs.isInSortedOrder,
1: 											srs.sortProperties,
1: 											srs.optimizerEstimatedRowCount,
1: 											srs.optimizerEstimatedCost,
1: 											getResultSetStatistics(srs.source)
1: 										);
1: 		}
1: 		else if (rs instanceof DistinctScalarAggregateResultSet)
1: 		{
1: 			DistinctScalarAggregateResultSet dsars = (DistinctScalarAggregateResultSet) rs;
1: 
1: 			return new RealDistinctScalarAggregateStatistics(
1: 											dsars.numOpens,
1: 											dsars.rowsSeen,
1: 											dsars.rowsFiltered,
1: 											dsars.constructorTime,
1: 											dsars.openTime,
1: 											dsars.nextTime,
1: 											dsars.closeTime,
1: 											dsars.resultSetNumber,
1: 											dsars.rowsInput,
1: 											dsars.optimizerEstimatedRowCount,
1: 											dsars.optimizerEstimatedCost,
1: 											getResultSetStatistics(dsars.source)
1: 										);
1: 		}
1: 		else if (rs instanceof ScalarAggregateResultSet)
1: 		{
1: 			ScalarAggregateResultSet sars = (ScalarAggregateResultSet) rs;
1: 
1: 			return new RealScalarAggregateStatistics(
1: 											sars.numOpens,
1: 											sars.rowsSeen,
1: 											sars.rowsFiltered,
1: 											sars.constructorTime,
1: 											sars.openTime,
1: 											sars.nextTime,
1: 											sars.closeTime,
1: 											sars.resultSetNumber,
1: 											sars.singleInputRow,
1: 											sars.rowsInput,
1: 											sars.optimizerEstimatedRowCount,
1: 											sars.optimizerEstimatedCost,
1: 											getResultSetStatistics(sars.source)
1: 										);
1: 		}
1: 		else if (rs instanceof GroupedAggregateResultSet)
1: 		{
1: 			GroupedAggregateResultSet gars = (GroupedAggregateResultSet) rs;
1: 
1: 			return new RealGroupedAggregateStatistics(
1: 											gars.numOpens,
1: 											gars.rowsSeen,
1: 											gars.rowsFiltered,
1: 											gars.constructorTime,
1: 											gars.openTime,
1: 											gars.nextTime,
1: 											gars.closeTime,
1: 											gars.resultSetNumber,
1: 											gars.rowsInput,
1: 											gars.hasDistinctAggregate,
1: 											gars.isInSortedOrder,
1: 											gars.sortProperties,
1: 											gars.optimizerEstimatedRowCount,
1: 											gars.optimizerEstimatedCost,
1: 											getResultSetStatistics(gars.source)
1: 										);
1: 		}
1: 		else if (rs instanceof TableScanResultSet)
1: 		{
1: 			boolean instantaneousLocks = false;
1: 			TableScanResultSet tsrs = (TableScanResultSet) rs;
1: 			String startPosition = null;
1: 			String stopPosition = null;
1: 			String isolationLevel =  null;
1: 			String lockString = null;
1: 			String lockRequestString = null;
1: 
1: 			switch (tsrs.isolationLevel)
1: 			{
1: 				case TransactionController.ISOLATION_SERIALIZABLE:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_SERIALIZABLE);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_REPEATABLE_READ);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1: 					instantaneousLocks = true;
1: 					//fall through
1: 				case TransactionController.ISOLATION_READ_COMMITTED:
1: 					isolationLevel = MessageService.getTextMessage(
1: 												SQLState.LANG_READ_COMMITTED);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_READ_UNCOMMITTED);
1: 					break;
1: 			}
1: 
1: 			if (tsrs.forUpdate)
1: 			{
1: 				lockString = MessageService.getTextMessage(
1: 												SQLState.LANG_EXCLUSIVE);
1: 			}
1: 			else
1: 			{
1: 				if (instantaneousLocks)
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1: 				}
1: 				else
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 														SQLState.LANG_SHARE);
1: 				}
1: 			}
1: 
1: 			switch (tsrs.lockMode)
1: 			{
1: 				case TransactionController.MODE_TABLE:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockRequestString = lockString + " " +
1: 										MessageService.getTextMessage(
1: 											SQLState.LANG_TABLE);
1: 					break;
1: 
1: 				case TransactionController.MODE_RECORD:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockRequestString = lockString + " " +
1: 										MessageService.getTextMessage(
1: 											SQLState.LANG_ROW);
1: 					break;
1: 			}
1: 
1: 			if (tsrs.indexName != null)
1: 			{
1: 				/* Start and stop position strings will be non-null
1: 			 	* if the TSRS has been closed.  Otherwise, we go off
1: 			 	* and build the strings now.
1: 			 	*/
1: 				startPosition = tsrs.startPositionString;
1: 				if (startPosition == null)
1: 				{
1: 					startPosition = tsrs.printStartPosition();
1: 				}
1: 				stopPosition = tsrs.stopPositionString;
1: 				if (stopPosition == null)
1: 				{
1: 					stopPosition = tsrs.printStopPosition();
1: 				}
1: 			}
1: 
1: 			return new 
1:                 RealTableScanStatistics(
1:                     tsrs.numOpens,
1:                     tsrs.rowsSeen,
1:                     tsrs.rowsFiltered,
1:                     tsrs.constructorTime,
1:                     tsrs.openTime,
1:                     tsrs.nextTime,
1:                     tsrs.closeTime,
1:                     tsrs.resultSetNumber,
1:                     tsrs.tableName,
1:                     tsrs.indexName,
1:                     tsrs.isConstraint,
1:                     tsrs.printQualifiers(tsrs.qualifiers),
1:                     tsrs.getScanProperties(),
1:                     startPosition,
1:                     stopPosition,
1:                     isolationLevel,
1:                     lockRequestString,
1:                     tsrs.rowsPerRead,
1:                     tsrs.coarserLock,
1:                     tsrs.optimizerEstimatedRowCount,
1:                     tsrs.optimizerEstimatedCost);
1: 		}
1: 
1: 		else if (rs instanceof LastIndexKeyResultSet )
1: 		{
1: 			LastIndexKeyResultSet lrs = (LastIndexKeyResultSet) rs;
1: 			String isolationLevel =  null;
1: 			String lockRequestString = null;
1: 
1: 			switch (lrs.isolationLevel)
1: 			{
1: 				case TransactionController.ISOLATION_SERIALIZABLE:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_SERIALIZABLE);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_REPEATABLE_READ);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1: 				case TransactionController.ISOLATION_READ_COMMITTED:
1: 					isolationLevel = MessageService.getTextMessage(
1: 												SQLState.LANG_READ_COMMITTED);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1: 					isolationLevel = MessageService.getTextMessage(
1: 												SQLState.LANG_READ_UNCOMMITTED);
1:                     break;
1: 			}
1: 
1: 			switch (lrs.lockMode)
1: 			{
1: 				case TransactionController.MODE_TABLE:
1: 					lockRequestString = MessageService.getTextMessage(
1: 													SQLState.LANG_SHARE_TABLE);
1: 					break;
1: 
1: 				case TransactionController.MODE_RECORD:
1: 					lockRequestString = MessageService.getTextMessage(
1: 													SQLState.LANG_SHARE_ROW);
1: 					break;
1: 			}
1: 
1: 			return new RealLastIndexKeyScanStatistics(
1: 											lrs.numOpens,
1: 											lrs.constructorTime,
1: 											lrs.openTime,
1: 											lrs.nextTime,
1: 											lrs.closeTime,
1: 											lrs.resultSetNumber,
1: 											lrs.tableName,
1: 											lrs.indexName,
1: 											isolationLevel,
1: 											lockRequestString,
1: 											lrs.optimizerEstimatedRowCount,
1: 											lrs.optimizerEstimatedCost);
1: 		}
1: 		else if (rs instanceof HashLeftOuterJoinResultSet)
1: 		{
1: 			HashLeftOuterJoinResultSet hlojrs =
1: 				(HashLeftOuterJoinResultSet) rs;
1: 
1: 			return new RealHashLeftOuterJoinStatistics(
1: 											hlojrs.numOpens,
1: 											hlojrs.rowsSeen,
1: 											hlojrs.rowsFiltered,
1: 											hlojrs.constructorTime,
1: 											hlojrs.openTime,
1: 											hlojrs.nextTime,
1: 											hlojrs.closeTime,
1: 											hlojrs.resultSetNumber,
1: 											hlojrs.rowsSeenLeft,
1: 											hlojrs.rowsSeenRight,
1: 											hlojrs.rowsReturned,
1: 											hlojrs.restrictionTime,
1: 											hlojrs.optimizerEstimatedRowCount,
1: 											hlojrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(
1: 												hlojrs.leftResultSet),
1: 											getResultSetStatistics(
1: 												hlojrs.rightResultSet),
1: 											hlojrs.emptyRightRowsReturned);
1: 		}
1: 		else if (rs instanceof NestedLoopLeftOuterJoinResultSet)
1: 		{
1: 			NestedLoopLeftOuterJoinResultSet nllojrs =
1: 				(NestedLoopLeftOuterJoinResultSet) rs;
1: 
1: 			return new RealNestedLoopLeftOuterJoinStatistics(
1: 											nllojrs.numOpens,
1: 											nllojrs.rowsSeen,
1: 											nllojrs.rowsFiltered,
1: 											nllojrs.constructorTime,
1: 											nllojrs.openTime,
1: 											nllojrs.nextTime,
1: 											nllojrs.closeTime,
1: 											nllojrs.resultSetNumber,
1: 											nllojrs.rowsSeenLeft,
1: 											nllojrs.rowsSeenRight,
1: 											nllojrs.rowsReturned,
1: 											nllojrs.restrictionTime,
1: 											nllojrs.optimizerEstimatedRowCount,
1: 											nllojrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(
1: 												nllojrs.leftResultSet),
1: 											getResultSetStatistics(
1: 												nllojrs.rightResultSet),
1: 											nllojrs.emptyRightRowsReturned);
1: 		}
1: 		else if (rs instanceof HashJoinResultSet)
1: 		{
1: 			HashJoinResultSet hjrs = (HashJoinResultSet) rs;
1: 
1: 			return new RealHashJoinStatistics(
1: 											hjrs.numOpens,
1: 											hjrs.rowsSeen,
1: 											hjrs.rowsFiltered,
1: 											hjrs.constructorTime,
1: 											hjrs.openTime,
1: 											hjrs.nextTime,
1: 											hjrs.closeTime,
1: 											hjrs.resultSetNumber,
1: 											hjrs.rowsSeenLeft,
1: 											hjrs.rowsSeenRight,
1: 											hjrs.rowsReturned,
1: 											hjrs.restrictionTime,
1: 											hjrs.oneRowRightSide,
1: 											hjrs.optimizerEstimatedRowCount,
1: 											hjrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(
1: 												hjrs.leftResultSet),
1: 											getResultSetStatistics(
1: 												hjrs.rightResultSet)
1: 											);
1: 		}
1: 		else if (rs instanceof NestedLoopJoinResultSet)
1: 		{
1: 			NestedLoopJoinResultSet nljrs = (NestedLoopJoinResultSet) rs;
1: 
1: 			return new RealNestedLoopJoinStatistics(
1: 											nljrs.numOpens,
1: 											nljrs.rowsSeen,
1: 											nljrs.rowsFiltered,
1: 											nljrs.constructorTime,
1: 											nljrs.openTime,
1: 											nljrs.nextTime,
1: 											nljrs.closeTime,
1: 											nljrs.resultSetNumber,
1: 											nljrs.rowsSeenLeft,
1: 											nljrs.rowsSeenRight,
1: 											nljrs.rowsReturned,
1: 											nljrs.restrictionTime,
1: 											nljrs.oneRowRightSide,
1: 											nljrs.optimizerEstimatedRowCount,
1: 											nljrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(
1: 												nljrs.leftResultSet),
1: 											getResultSetStatistics(
1: 												nljrs.rightResultSet)
1: 											);
1: 		}
1: 		else if (rs instanceof IndexRowToBaseRowResultSet)
1: 		{
1: 			IndexRowToBaseRowResultSet irtbrrs =
1: 											(IndexRowToBaseRowResultSet) rs;
1: 
1: 			return new RealIndexRowToBaseRowStatistics(
1: 											irtbrrs.numOpens,
1: 											irtbrrs.rowsSeen,
1: 											irtbrrs.rowsFiltered,
1: 											irtbrrs.constructorTime,
1: 											irtbrrs.openTime,
1: 											irtbrrs.nextTime,
1: 											irtbrrs.closeTime,
1: 											irtbrrs.resultSetNumber,
1: 											irtbrrs.indexName,
1: 											irtbrrs.accessedHeapCols,
1: 											irtbrrs.optimizerEstimatedRowCount,
1: 											irtbrrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(
1: 																irtbrrs.source)
1: 											);
1: 		}
1: 		else if (rs instanceof RowResultSet)
1: 		{
1: 			RowResultSet rrs = (RowResultSet) rs;
1: 
1: 			return new RealRowResultSetStatistics(
1: 											rrs.numOpens,
1: 											rrs.rowsSeen,
1: 											rrs.rowsFiltered,
1: 											rrs.constructorTime,
1: 											rrs.openTime,
1: 											rrs.nextTime,
1: 											rrs.closeTime,
1: 											rrs.resultSetNumber,
1: 											rrs.rowsReturned,
1: 											rrs.optimizerEstimatedRowCount,
1: 											rrs.optimizerEstimatedCost);
1: 		}
1: 		else if (rs instanceof UnionResultSet)
1: 		{
0: 			UnionResultSet urs = (UnionResultSet) rs;
1: 
1: 			return new RealUnionResultSetStatistics(
1: 											urs.numOpens,
1: 											urs.rowsSeen,
1: 											urs.rowsFiltered,
1: 											urs.constructorTime,
1: 											urs.openTime,
1: 											urs.nextTime,
1: 											urs.closeTime,
1: 											urs.resultSetNumber,
1: 											urs.rowsSeenLeft,
1: 											urs.rowsSeenRight,
1: 											urs.rowsReturned,
1: 											urs.optimizerEstimatedRowCount,
1: 											urs.optimizerEstimatedCost,
1: 											getResultSetStatistics(urs.source1),
1: 											getResultSetStatistics(urs.source2)
1: 											);
1: 		}
1: 		else if (rs instanceof AnyResultSet)
1: 		{
1: 			AnyResultSet ars = (AnyResultSet) rs;
1: 
1: 			return new RealAnyResultSetStatistics(
1: 											ars.numOpens,
1: 											ars.rowsSeen,
1: 											ars.rowsFiltered,
1: 											ars.constructorTime,
1: 											ars.openTime,
1: 											ars.nextTime,
1: 											ars.closeTime,
1: 											ars.resultSetNumber,
1: 											ars.subqueryNumber,
1: 											ars.pointOfAttachment,
1: 											ars.optimizerEstimatedRowCount,
1: 											ars.optimizerEstimatedCost,
1: 											getResultSetStatistics(ars.source)
1: 											);
1: 		}
1: 		else if (rs instanceof OnceResultSet)
1: 		{
1: 			OnceResultSet ors = (OnceResultSet) rs;
1: 
1: 			return new RealOnceResultSetStatistics(
1: 											ors.numOpens,
1: 											ors.rowsSeen,
1: 											ors.rowsFiltered,
1: 											ors.constructorTime,
1: 											ors.openTime,
1: 											ors.nextTime,
1: 											ors.closeTime,
1: 											ors.resultSetNumber,
1: 											ors.subqueryNumber,
1: 											ors.pointOfAttachment,
1: 											ors.optimizerEstimatedRowCount,
1: 											ors.optimizerEstimatedCost,
1: 											getResultSetStatistics(ors.source)
1: 											);
1: 		}
1: 		else if (rs instanceof NormalizeResultSet)
1: 		{
1: 			NormalizeResultSet nrs = (NormalizeResultSet) rs;
1: 
1: 			return new RealNormalizeResultSetStatistics(
1: 											nrs.numOpens,
1: 											nrs.rowsSeen,
1: 											nrs.rowsFiltered,
1: 											nrs.constructorTime,
1: 											nrs.openTime,
1: 											nrs.nextTime,
1: 											nrs.closeTime,
1: 											nrs.resultSetNumber,
1: 											nrs.optimizerEstimatedRowCount,
1: 											nrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(nrs.source)
1: 											);
1: 		}
1: 		else if (rs instanceof MaterializedResultSet)
1: 		{
1: 			MaterializedResultSet mrs = (MaterializedResultSet) rs;
1: 
1: 			return new RealMaterializedResultSetStatistics(
1: 											mrs.numOpens,
1: 											mrs.rowsSeen,
1: 											mrs.rowsFiltered,
1: 											mrs.constructorTime,
1: 											mrs.openTime,
1: 											mrs.nextTime,
1: 											mrs.closeTime,
1: 											mrs.createTCTime,
1: 											mrs.fetchTCTime,
1: 											mrs.resultSetNumber,
1: 											mrs.optimizerEstimatedRowCount,
1: 											mrs.optimizerEstimatedCost,
1: 											getResultSetStatistics(mrs.source)
1: 											);
1: 		}
1: 		else if (rs instanceof ScrollInsensitiveResultSet)
1: 		{
1: 			ScrollInsensitiveResultSet sirs = (ScrollInsensitiveResultSet) rs;
1: 
1: 			return new RealScrollInsensitiveResultSetStatistics(
1: 											sirs.numOpens,
1: 											sirs.rowsSeen,
1: 											sirs.rowsFiltered,
1: 											sirs.constructorTime,
1: 											sirs.openTime,
1: 											sirs.nextTime,
1: 											sirs.closeTime,
1: 											sirs.numFromHashTable,
1: 											sirs.numToHashTable,
1: 											sirs.resultSetNumber,
1: 											sirs.optimizerEstimatedRowCount,
1: 											sirs.optimizerEstimatedCost,
1: 											getResultSetStatistics(sirs.source)
1: 											);
1: 		}
1: 		else if (rs instanceof CurrentOfResultSet)
1: 		{
1: 			CurrentOfResultSet cors = (CurrentOfResultSet) rs;
1: 
1: 			return new RealCurrentOfStatistics(
1: 											cors.numOpens,
1: 											cors.rowsSeen,
1: 											cors.rowsFiltered,
1: 											cors.constructorTime,
1: 											cors.openTime,
1: 											cors.nextTime,
1: 											cors.closeTime,
1: 											cors.resultSetNumber
1: 											);
1: 		}
1: 		else if (rs instanceof HashScanResultSet)
1: 		{
1: 			boolean instantaneousLocks = false;
1: 			HashScanResultSet hsrs = (HashScanResultSet) rs;
1: 			String startPosition = null;
1: 			String stopPosition = null;
1: 			String isolationLevel =  null;
1: 			String lockString = null;
1: 
1: 			switch (hsrs.isolationLevel)
1: 			{
1: 				case TransactionController.ISOLATION_SERIALIZABLE:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_SERIALIZABLE);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_REPEATABLE_READ);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1: 					instantaneousLocks = true;
1: 					//fall through
1: 				case TransactionController.ISOLATION_READ_COMMITTED:
1: 					isolationLevel = MessageService.getTextMessage(
1: 												SQLState.LANG_READ_COMMITTED);
1: 					break;
1: 
1: 			}
1: 
1: 			if (hsrs.forUpdate)
1: 			{
1: 				lockString = MessageService.getTextMessage(
1: 													SQLState.LANG_EXCLUSIVE);
1: 			}
1: 			else
1: 			{
1: 				if (instantaneousLocks)
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1: 				}
1: 				else
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 														SQLState.LANG_SHARE);
1: 				}
1: 			}
1: 
1: 			switch (hsrs.lockMode)
1: 			{
1: 				case TransactionController.MODE_TABLE:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockString = lockString + " " +
1: 									MessageService.getTextMessage(
1: 														SQLState.LANG_TABLE);
1: 					break;
1: 
1: 				case TransactionController.MODE_RECORD:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockString = lockString + " " +
1: 									MessageService.getTextMessage(
1: 															SQLState.LANG_ROW);
1: 					break;
1: 			}
1: 
1: 			if (hsrs.indexName != null)
1: 			{
1: 				/* Start and stop position strings will be non-null
1: 			 	* if the HSRS has been closed.  Otherwise, we go off
1: 			 	* and build the strings now.
1: 			 	*/
1: 				startPosition = hsrs.startPositionString;
1: 				if (startPosition == null)
1: 				{
1: 					startPosition = hsrs.printStartPosition();
1: 				}
1: 				stopPosition = hsrs.stopPositionString;
1: 				if (stopPosition == null)
1: 				{
1: 					stopPosition = hsrs.printStopPosition();
1: 				}
1: 			}
1: 
1: 			// DistinctScanResultSet is simple sub-class of
1: 			// HashScanResultSet
1: 			if (rs instanceof DistinctScanResultSet)
1: 			{
1: 				return new RealDistinctScanStatistics(
1: 											hsrs.numOpens,
1: 											hsrs.rowsSeen,
1: 											hsrs.rowsFiltered,
1: 											hsrs.constructorTime,
1: 											hsrs.openTime,
1: 											hsrs.nextTime,
1: 											hsrs.closeTime,
1: 											hsrs.resultSetNumber,
1: 											hsrs.tableName,
1: 											hsrs.indexName,
1: 											hsrs.isConstraint,
1: 											hsrs.hashtableSize,
1: 											hsrs.keyColumns,
1: 											hsrs.printQualifiers(
1: 												hsrs.scanQualifiers),
1: 											hsrs.printQualifiers(
1: 												hsrs.nextQualifiers),
1: 											hsrs.getScanProperties(),
1: 											startPosition,
1: 											stopPosition,
1: 											isolationLevel,
1: 											lockString,
1: 											hsrs.optimizerEstimatedRowCount,
1: 											hsrs.optimizerEstimatedCost
1: 											);
1: 			}
1: 			else
1: 			{
1: 				return new RealHashScanStatistics(
1: 											hsrs.numOpens,
1: 											hsrs.rowsSeen,
1: 											hsrs.rowsFiltered,
1: 											hsrs.constructorTime,
1: 											hsrs.openTime,
1: 											hsrs.nextTime,
1: 											hsrs.closeTime,
1: 											hsrs.resultSetNumber,
1: 											hsrs.tableName,
1: 											hsrs.indexName,
1: 											hsrs.isConstraint,
1: 											hsrs.hashtableSize,
1: 											hsrs.keyColumns,
1: 											hsrs.printQualifiers(
1: 												hsrs.scanQualifiers),
1: 											hsrs.printQualifiers(
1: 												hsrs.nextQualifiers),
1: 											hsrs.getScanProperties(),
1: 											startPosition,
1: 											stopPosition,
1: 											isolationLevel,
1: 											lockString,
1: 											hsrs.optimizerEstimatedRowCount,
1: 											hsrs.optimizerEstimatedCost
1: 											);
1: 			}
1: 		}
1: 		else if (rs instanceof HashTableResultSet)
1: 		{
1: 			HashTableResultSet htrs = (HashTableResultSet) rs;
1: 			int subqueryTrackingArrayLength =
1: 				(htrs.subqueryTrackingArray == null) ? 0 :
1: 					htrs.subqueryTrackingArray.length;
1: 			ResultSetStatistics[] subqueryTrackingArray =
1: 				new ResultSetStatistics[subqueryTrackingArrayLength];
1: 			boolean anyAttached = false;
1: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
1: 			{
1: 				if (htrs.subqueryTrackingArray[index] != null &&
1: 					htrs.subqueryTrackingArray[index].getPointOfAttachment() ==
1: 						htrs.resultSetNumber)
1: 				{
1: 					subqueryTrackingArray[index] =
1: 										getResultSetStatistics(
1: 											htrs.subqueryTrackingArray[index]);
1: 					anyAttached = true;
1: 				}
1: 			}
1: 			if (! anyAttached)
1: 			{
1: 				subqueryTrackingArray = null;
1: 			}
1: 
1: 			return new 
1:                 RealHashTableStatistics(
1:                     htrs.numOpens,
1:                     htrs.rowsSeen,
1:                     htrs.rowsFiltered,
1:                     htrs.constructorTime,
1:                     htrs.openTime,
1:                     htrs.nextTime,
1:                     htrs.closeTime,
1:                     htrs.resultSetNumber,
1:                     htrs.hashtableSize,
1:                     htrs.keyColumns,
1:                     HashScanResultSet.printQualifiers(
1:                         htrs.nextQualifiers),
1:                     htrs.scanProperties,
1:                     htrs.optimizerEstimatedRowCount,
1:                     htrs.optimizerEstimatedCost,
1:                     subqueryTrackingArray,
1:                     getResultSetStatistics(htrs.source)
1:                     );
1: 		}
1: 		else if (rs instanceof VTIResultSet)
1: 		{
1: 			VTIResultSet vtirs = (VTIResultSet) rs;
1: 
1: 			return new RealVTIStatistics(
1: 										vtirs.numOpens,
1: 										vtirs.rowsSeen,
1: 										vtirs.rowsFiltered,
1: 										vtirs.constructorTime,
1: 										vtirs.openTime,
1: 										vtirs.nextTime,
1: 										vtirs.closeTime,
1: 										vtirs.resultSetNumber,
1: 										vtirs.javaClassName,
1: 										vtirs.optimizerEstimatedRowCount,
1: 										vtirs.optimizerEstimatedCost
1: 										);
1: 		}
1: 
1: 		else if (rs instanceof DependentResultSet)
1: 		{
1: 			boolean instantaneousLocks = false;
1: 			DependentResultSet dsrs = (DependentResultSet) rs;
1: 			String startPosition = null;
1: 			String stopPosition = null;
1: 			String isolationLevel =  null;
1: 			String lockString = null;
1: 			String lockRequestString = null;
1: 
1: 			switch (dsrs.isolationLevel)
1: 			{
1: 				case TransactionController.ISOLATION_SERIALIZABLE:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_SERIALIZABLE);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_REPEATABLE_READ:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_REPEATABLE_READ);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
1: 					instantaneousLocks = true;
1: 					//fall through
1: 				case TransactionController.ISOLATION_READ_COMMITTED:
1: 					isolationLevel = MessageService.getTextMessage(
1: 												SQLState.LANG_READ_COMMITTED);
1: 					break;
1: 
1: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
1: 					isolationLevel = 
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_READ_UNCOMMITTED);
1: 					break;
1: 			}
1: 
1: 			if (dsrs.forUpdate)
1: 			{
1: 				lockString = MessageService.getTextMessage(
1: 												SQLState.LANG_EXCLUSIVE);
1: 			}
1: 			else
1: 			{
1: 				if (instantaneousLocks)
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 											SQLState.LANG_INSTANTANEOUS_SHARE);
1: 				}
1: 				else
1: 				{
1: 					lockString = MessageService.getTextMessage(
1: 														SQLState.LANG_SHARE);
1: 				}
1: 			}
1: 
1: 			switch (dsrs.lockMode)
1: 			{
1: 				case TransactionController.MODE_TABLE:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockRequestString = lockString + " " +
1: 										MessageService.getTextMessage(
1: 											SQLState.LANG_TABLE);
1: 					break;
1: 
1: 				case TransactionController.MODE_RECORD:
1: 					// RESOLVE: Not sure this will really work, as we
1: 					// are tacking together English words to make a phrase.
1: 					// Will this work in other languages?
1: 					lockRequestString = lockString + " " +
1: 										MessageService.getTextMessage(
1: 											SQLState.LANG_ROW);
1: 					break;
1: 			}
1: 
1: 			/* Start and stop position strings will be non-null
1: 			 * if the dSRS has been closed.  Otherwise, we go off
1: 			 * and build the strings now.
1: 			 */
1: 			startPosition = dsrs.startPositionString;
1: 			if (startPosition == null)
1: 			{
1: 				startPosition = dsrs.printStartPosition();
1: 			}
1: 			stopPosition = dsrs.stopPositionString;
1: 			if (stopPosition == null)
1: 			{
1: 				stopPosition = dsrs.printStopPosition();
1: 			}
1: 		
1: 			return new 
1:                 RealTableScanStatistics(
1:                     dsrs.numOpens,
1:                     dsrs.rowsSeen,
1:                     dsrs.rowsFiltered,
1:                     dsrs.constructorTime,
1:                     dsrs.openTime,
1:                     dsrs.nextTime,
1:                     dsrs.closeTime,
1:                     dsrs.resultSetNumber,
1:                     dsrs.tableName,
1:                     dsrs.indexName,
1:                     dsrs.isConstraint,
1:                     dsrs.printQualifiers(),
1:                     dsrs.getScanProperties(),
1:                     startPosition,
1:                     stopPosition,
1:                     isolationLevel,
1:                     lockRequestString,
1:                     dsrs.rowsPerRead,
1:                     dsrs.coarserLock,
1:                     dsrs.optimizerEstimatedRowCount,
1:                     dsrs.optimizerEstimatedCost);
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
1: 	//
1: 	// class interface
1: 	//
1: 	public RealResultSetStatisticsFactory() 
1: 	{
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.impl.sql.execute.AnyResultSet;
0: import org.apache.derby.impl.sql.execute.CurrentOfResultSet;
0: import org.apache.derby.impl.sql.execute.DeleteResultSet;
0: import org.apache.derby.impl.sql.execute.DeleteCascadeResultSet;
0: import org.apache.derby.impl.sql.execute.DeleteVTIResultSet;
0: import org.apache.derby.impl.sql.execute.DistinctScalarAggregateResultSet;
0: import org.apache.derby.impl.sql.execute.DistinctScanResultSet;
0: import org.apache.derby.impl.sql.execute.GroupedAggregateResultSet;
0: import org.apache.derby.impl.sql.execute.HashJoinResultSet;
0: import org.apache.derby.impl.sql.execute.HashLeftOuterJoinResultSet;
0: import org.apache.derby.impl.sql.execute.HashScanResultSet;
0: import org.apache.derby.impl.sql.execute.HashTableResultSet;
0: import org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet;
0: import org.apache.derby.impl.sql.execute.InsertResultSet;
0: import org.apache.derby.impl.sql.execute.InsertVTIResultSet;
0: import org.apache.derby.impl.sql.execute.LastIndexKeyResultSet;
0: import org.apache.derby.impl.sql.execute.MaterializedResultSet;
0: import org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet;
0: import org.apache.derby.impl.sql.execute.NestedLoopLeftOuterJoinResultSet;
0: import org.apache.derby.impl.sql.execute.NormalizeResultSet;
0: import org.apache.derby.impl.sql.execute.OnceResultSet;
0: import org.apache.derby.impl.sql.execute.ProjectRestrictResultSet;
0: import org.apache.derby.impl.sql.execute.RowResultSet;
0: import org.apache.derby.impl.sql.execute.ScalarAggregateResultSet;
0: import org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet;
0: import org.apache.derby.impl.sql.execute.SortResultSet;
0: import org.apache.derby.impl.sql.execute.TableScanResultSet;
0: import org.apache.derby.impl.sql.execute.UnionResultSet;
0: import org.apache.derby.impl.sql.execute.UpdateResultSet;
0: import org.apache.derby.impl.sql.execute.VTIResultSet;
0: import org.apache.derby.impl.sql.execute.DependentResultSet;
0: 
0: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealAnyResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealCurrentOfStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteCascadeResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteVTIResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDistinctScalarAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDistinctScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealGroupedAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashLeftOuterJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashTableStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealIndexRowToBaseRowStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealInsertResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealInsertVTIResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealJoinResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealLastIndexKeyScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealMaterializedResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopLeftOuterJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNormalizeResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealOnceResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealProjectRestrictStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealRowResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealScalarAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealScrollInsensitiveResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealSortStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealVTIStatistics;
0: import org.apache.derby.impl.sql.execute.rts.ResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RunTimeStatisticsImpl;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * ResultSetStatisticsFactory provides a wrapper around all of
0:  * objects associated with run time statistics.
0:  * <p>
0:  * This implementation of the protocol is for returning the "real"
0:  * run time statistics.  We have modularized this so that we could
0:  * have an implementation that just returns null for each of the
0:  * objects should we decided to provide a configuration without
0:  * the run time statistics feature.
0:  *
0:  * @author jerry
0:  */
0: public class RealResultSetStatisticsFactory 
0: 		implements ResultSetStatisticsFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	//
0: 	// ExecutionFactory interface
0: 	//
0: 	//
0: 	// ResultSetStatisticsFactory interface
0: 	//
0: 
0: 	/**
0: 		@see ResultSetStatisticsFactory#getRunTimeStatistics
0: 	 */
0: 	public RunTimeStatistics getRunTimeStatistics(
0: 			Activation activation, 
0: 			ResultSet rs,
0: 			NoPutResultSet[] subqueryTrackingArray)
0: 		throws StandardException
0: 	{
0: 		PreparedStatement preStmt = activation.getPreparedStatement();
0: 
0: 		// If the prepared statement is null then the result set is being
0: 		// finished as a result of a activation being closed during a recompile.
0: 		// In this case statistics should not be generated.
0: 		if (preStmt == null)
0: 			return null;
0: 
0: 
0: 
0: 
0: 		ResultSetStatistics topResultSetStatistics;
0: 
0: 		if (rs instanceof NoPutResultSet)
0: 		{
0: 			topResultSetStatistics =
0: 									getResultSetStatistics((NoPutResultSet) rs);
0: 		}
0: 		else
0: 		{
0: 			topResultSetStatistics = getResultSetStatistics(rs);
0: 		}
0: 
0: 		/* Build up the info on the materialized subqueries */
0: 		int subqueryTrackingArrayLength =
0: 				(subqueryTrackingArray == null) ? 0 :
0: 					subqueryTrackingArray.length;
0: 		ResultSetStatistics[] subqueryRSS =
0: 				new ResultSetStatistics[subqueryTrackingArrayLength];
0: 		boolean anyAttached = false;
0: 		for (int index = 0; index < subqueryTrackingArrayLength; index++)
0: 		{
0: 			if (subqueryTrackingArray[index] != null &&
0: 				subqueryTrackingArray[index].getPointOfAttachment() == -1)
0: 			{
0: 				subqueryRSS[index] =
0: 						getResultSetStatistics(subqueryTrackingArray[index]);
0: 				anyAttached = true;
0: 			}
0: 		}
0: 		if (anyAttached == false)
0: 		{
0: 			subqueryRSS = null;
0: 		}
0: 
0: 		// Get the info on all of the materialized subqueries (attachment point = -1)
0: 		return new RunTimeStatisticsImpl(
0: 								preStmt.getSPSName(),
0: 								activation.getCursorName(),
0: 								preStmt.getSource(),
0: 								preStmt.getCompileTimeInMillis(),
0: 								preStmt.getParseTimeInMillis(),
0: 								preStmt.getBindTimeInMillis(),
0: 								preStmt.getOptimizeTimeInMillis(),
0: 								preStmt.getGenerateTimeInMillis(),
0: 								rs.getExecuteTime(),
0: 								preStmt.getBeginCompileTimestamp(),
0: 								preStmt.getEndCompileTimestamp(),
0: 								rs.getBeginExecutionTimestamp(),
0: 								rs.getEndExecutionTimestamp(),
0: 								subqueryRSS,
0: 								topResultSetStatistics);
0: 	}
0: 
0: 	/**
0: 		@see ResultSetStatisticsFactory#getResultSetStatistics
0: 	 */
0: 	public ResultSetStatistics getResultSetStatistics(ResultSet rs)
0: 	{
0: 		if (!rs.returnsRows())
0: 		{
0: 			return getNoRowsResultSetStatistics(rs);
0: 		}
0: 		else if (rs instanceof NoPutResultSet)
0: 		{
0: 			return getResultSetStatistics((NoPutResultSet) rs);
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
0: 
0: 	public ResultSetStatistics getNoRowsResultSetStatistics(ResultSet rs)
0: 	{
0: 		ResultSetStatistics retval = null;
0: 
0: 		/* We need to differentiate based on instanceof in order
0: 		 * to find the right constructor to call.  This is ugly,
0: 		 * but if we don't do instanceof then rs is always seen as an
0: 		 * interface instead of a class when we try to overload 
0: 		 * a method with both.
0: 		 */
0: 		if( rs instanceof InsertResultSet)
0: 		{
0: 			InsertResultSet irs = (InsertResultSet) rs;
0: 
0: 			retval = new RealInsertResultSetStatistics(
0: 									irs.rowCount,
0: 									irs.constants.deferred,
0: 									irs.constants.irgs.length,
0: 									irs.userSpecifiedBulkInsert,
0: 									irs.bulkInsertPerformed,
0: 									irs.constants.lockMode ==
0: 										TransactionController.MODE_TABLE,
0: 									irs.getExecuteTime(), 
0: 									getResultSetStatistics(irs.savedSource)
0: 									);
0: 
0: 			irs.savedSource = null;
0: 		}
0: 		else if( rs instanceof InsertVTIResultSet)
0: 		{
0: 			InsertVTIResultSet iVTIrs = (InsertVTIResultSet) rs;
0: 
0: 			retval = new RealInsertVTIResultSetStatistics(
0: 									iVTIrs.rowCount,
0: 									iVTIrs.constants.deferred,
0: 									iVTIrs.getExecuteTime(), 
0: 									getResultSetStatistics(iVTIrs.savedSource)
0: 									);
0: 
0: 			iVTIrs.savedSource = null;
0: 		}
0: 		else if( rs instanceof UpdateResultSet)
0: 		{
0: 			UpdateResultSet urs = (UpdateResultSet) rs;
0: 
0: 			retval = new RealUpdateResultSetStatistics(
0: 									urs.rowCount,
0: 									urs.constants.deferred,
0: 									urs.constants.irgs.length,
0: 									urs.constants.lockMode ==
0: 										TransactionController.MODE_TABLE,
0: 									urs.getExecuteTime(),
0: 									getResultSetStatistics(urs.savedSource)
0: 									);
0: 
0: 			urs.savedSource = null;
0: 		}
0: 		else if( rs instanceof DeleteCascadeResultSet)
0: 		{
0: 			DeleteCascadeResultSet dcrs = (DeleteCascadeResultSet) rs;
0: 			int dependentTrackingArrayLength =
0: 				(dcrs.dependentResultSets == null) ? 0 :
0: 					dcrs.dependentResultSets.length;
0: 			ResultSetStatistics[] dependentTrackingArray =
0: 				new ResultSetStatistics[dependentTrackingArrayLength];
0: 			boolean anyAttached = false;
0: 			for (int index = 0; index < dependentTrackingArrayLength; index++)
0: 			{
0: 				if (dcrs.dependentResultSets[index] != null)
0: 				{
0: 					dependentTrackingArray[index] =
0: 										getResultSetStatistics(
0: 											dcrs.dependentResultSets[index]);
0: 					anyAttached = true;
0: 				}
0: 			}
0: 			if (! anyAttached)
0: 			{
0: 				dependentTrackingArray = null;
0: 			}
0: 
0: 			retval = new RealDeleteCascadeResultSetStatistics(
0: 									dcrs.rowCount,
0: 									dcrs.constants.deferred,
0: 									dcrs.constants.irgs.length,
0: 									dcrs.constants.lockMode ==
0: 										TransactionController.MODE_TABLE,
0: 									dcrs.getExecuteTime(),
0: 									getResultSetStatistics(dcrs.savedSource),
0: 									dependentTrackingArray
0: 									);
0: 
0: 			dcrs.savedSource = null;
0: 		}
0: 		else if( rs instanceof DeleteResultSet)
0: 		{
0: 			DeleteResultSet drs = (DeleteResultSet) rs;
0: 
0: 			retval = new RealDeleteResultSetStatistics(
0: 									drs.rowCount,
0: 									drs.constants.deferred,
0: 									drs.constants.irgs.length,
0: 									drs.constants.lockMode ==
0: 										TransactionController.MODE_TABLE,
0: 									drs.getExecuteTime(),
0: 									getResultSetStatistics(drs.savedSource)
0: 									);
0: 
0: 			drs.savedSource = null;
0: 		}
0: 		else if( rs instanceof DeleteVTIResultSet)
0: 		{
0: 			DeleteVTIResultSet dVTIrs = (DeleteVTIResultSet) rs;
0: 
0: 			retval = new RealDeleteVTIResultSetStatistics(
0: 									dVTIrs.rowCount,
0: 									dVTIrs.getExecuteTime(), 
0: 									getResultSetStatistics(dVTIrs.savedSource)
0: 									);
0: 
0: 			dVTIrs.savedSource = null;
0: 		}
0: 
0: 
0: 		return retval;
0: 	}
0: 
0: 	public ResultSetStatistics getResultSetStatistics(NoPutResultSet rs)
0: 	{
0: 		/* We need to differentiate based on instanceof in order
0: 		 * to find the right constructor to call.  This is ugly,
0: 		 * but if we don't do instanceof then rs is always seen as an
0: 		 * interface instead of a class when we try to overload 
0: 		 * a method with both.
0: 		 */
0: 		if( rs instanceof ProjectRestrictResultSet)
0: 		{
0: 			ProjectRestrictResultSet prrs = (ProjectRestrictResultSet) rs;
0: 			int subqueryTrackingArrayLength =
0: 				(prrs.subqueryTrackingArray == null) ? 0 :
0: 					prrs.subqueryTrackingArray.length;
0: 			ResultSetStatistics[] subqueryTrackingArray =
0: 				new ResultSetStatistics[subqueryTrackingArrayLength];
0: 			boolean anyAttached = false;
0: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
0: 			{
0: 				if (prrs.subqueryTrackingArray[index] != null &&
0: 					prrs.subqueryTrackingArray[index].getPointOfAttachment() ==
0: 						prrs.resultSetNumber)
0: 				{
0: 					subqueryTrackingArray[index] =
0: 										getResultSetStatistics(
0: 											prrs.subqueryTrackingArray[index]);
0: 					anyAttached = true;
0: 				}
0: 			}
0: 			if (! anyAttached)
0: 			{
0: 				subqueryTrackingArray = null;
0: 			}
0: 
0: 			return new RealProjectRestrictStatistics(
0: 											prrs.numOpens,
0: 											prrs.rowsSeen,
0: 											prrs.rowsFiltered,
0: 											prrs.constructorTime,
0: 											prrs.openTime,
0: 											prrs.nextTime,
0: 											prrs.closeTime,
0: 											prrs.resultSetNumber,
0: 											prrs.restrictionTime,
0: 											prrs.projectionTime,
0: 											subqueryTrackingArray,
0: 											(prrs.restriction != null),
0: 											prrs.doesProjection,
0: 											prrs.optimizerEstimatedRowCount,
0: 											prrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(prrs.source)
0: 											);
0: 		}
0: 		else if (rs instanceof SortResultSet)
0: 		{
0: 			SortResultSet srs = (SortResultSet) rs;
0: 
0: 			return new RealSortStatistics(
0: 											srs.numOpens,
0: 											srs.rowsSeen,
0: 											srs.rowsFiltered,
0: 											srs.constructorTime,
0: 											srs.openTime,
0: 											srs.nextTime,
0: 											srs.closeTime,
0: 											srs.resultSetNumber,
0: 											srs.rowsInput,
0: 											srs.rowsReturned,
0: 											srs.distinct,
0: 											srs.isInSortedOrder,
0: 											srs.sortProperties,
0: 											srs.optimizerEstimatedRowCount,
0: 											srs.optimizerEstimatedCost,
0: 											getResultSetStatistics(srs.source)
0: 										);
0: 		}
0: 		else if (rs instanceof DistinctScalarAggregateResultSet)
0: 		{
0: 			DistinctScalarAggregateResultSet dsars = (DistinctScalarAggregateResultSet) rs;
0: 
0: 			return new RealDistinctScalarAggregateStatistics(
0: 											dsars.numOpens,
0: 											dsars.rowsSeen,
0: 											dsars.rowsFiltered,
0: 											dsars.constructorTime,
0: 											dsars.openTime,
0: 											dsars.nextTime,
0: 											dsars.closeTime,
0: 											dsars.resultSetNumber,
0: 											dsars.rowsInput,
0: 											dsars.optimizerEstimatedRowCount,
0: 											dsars.optimizerEstimatedCost,
0: 											getResultSetStatistics(dsars.source)
0: 										);
0: 		}
0: 		else if (rs instanceof ScalarAggregateResultSet)
0: 		{
0: 			ScalarAggregateResultSet sars = (ScalarAggregateResultSet) rs;
0: 
0: 			return new RealScalarAggregateStatistics(
0: 											sars.numOpens,
0: 											sars.rowsSeen,
0: 											sars.rowsFiltered,
0: 											sars.constructorTime,
0: 											sars.openTime,
0: 											sars.nextTime,
0: 											sars.closeTime,
0: 											sars.resultSetNumber,
0: 											sars.singleInputRow,
0: 											sars.rowsInput,
0: 											sars.optimizerEstimatedRowCount,
0: 											sars.optimizerEstimatedCost,
0: 											getResultSetStatistics(sars.source)
0: 										);
0: 		}
0: 		else if (rs instanceof GroupedAggregateResultSet)
0: 		{
0: 			GroupedAggregateResultSet gars = (GroupedAggregateResultSet) rs;
0: 
0: 			return new RealGroupedAggregateStatistics(
0: 											gars.numOpens,
0: 											gars.rowsSeen,
0: 											gars.rowsFiltered,
0: 											gars.constructorTime,
0: 											gars.openTime,
0: 											gars.nextTime,
0: 											gars.closeTime,
0: 											gars.resultSetNumber,
0: 											gars.rowsInput,
0: 											gars.hasDistinctAggregate,
0: 											gars.isInSortedOrder,
0: 											gars.sortProperties,
0: 											gars.optimizerEstimatedRowCount,
0: 											gars.optimizerEstimatedCost,
0: 											getResultSetStatistics(gars.source)
0: 										);
0: 		}
0: 		else if (rs instanceof TableScanResultSet)
0: 		{
0: 			boolean instantaneousLocks = false;
0: 			TableScanResultSet tsrs = (TableScanResultSet) rs;
0: 			String startPosition = null;
0: 			String stopPosition = null;
0: 			String isolationLevel =  null;
0: 			String lockString = null;
0: 			String lockRequestString = null;
0: 
0: 			switch (tsrs.isolationLevel)
0: 			{
0: 				case TransactionController.ISOLATION_SERIALIZABLE:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_SERIALIZABLE);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_REPEATABLE_READ:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_REPEATABLE_READ);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
0: 					instantaneousLocks = true;
0: 					//fall through
0: 				case TransactionController.ISOLATION_READ_COMMITTED:
0: 					isolationLevel = MessageService.getTextMessage(
0: 												SQLState.LANG_READ_COMMITTED);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_READ_UNCOMMITTED);
0: 					break;
0: 			}
0: 
0: 			if (tsrs.forUpdate)
0: 			{
0: 				lockString = MessageService.getTextMessage(
0: 												SQLState.LANG_EXCLUSIVE);
0: 			}
0: 			else
0: 			{
0: 				if (instantaneousLocks)
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 											SQLState.LANG_INSTANTANEOUS_SHARE);
0: 				}
0: 				else
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 														SQLState.LANG_SHARE);
0: 				}
0: 			}
0: 
0: 			switch (tsrs.lockMode)
0: 			{
0: 				case TransactionController.MODE_TABLE:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockRequestString = lockString + " " +
0: 										MessageService.getTextMessage(
0: 											SQLState.LANG_TABLE);
0: 					break;
0: 
0: 				case TransactionController.MODE_RECORD:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockRequestString = lockString + " " +
0: 										MessageService.getTextMessage(
0: 											SQLState.LANG_ROW);
0: 					break;
0: 			}
0: 
0: 			if (tsrs.indexName != null)
0: 			{
0: 				/* Start and stop position strings will be non-null
0: 			 	* if the TSRS has been closed.  Otherwise, we go off
0: 			 	* and build the strings now.
0: 			 	*/
0: 				startPosition = tsrs.startPositionString;
0: 				if (startPosition == null)
0: 				{
0: 					startPosition = tsrs.printStartPosition();
0: 				}
0: 				stopPosition = tsrs.stopPositionString;
0: 				if (stopPosition == null)
0: 				{
0: 					stopPosition = tsrs.printStopPosition();
0: 				}
0: 			}
0: 
0: 			return new 
0:                 RealTableScanStatistics(
0:                     tsrs.numOpens,
0:                     tsrs.rowsSeen,
0:                     tsrs.rowsFiltered,
0:                     tsrs.constructorTime,
0:                     tsrs.openTime,
0:                     tsrs.nextTime,
0:                     tsrs.closeTime,
0:                     tsrs.resultSetNumber,
0:                     tsrs.tableName,
0:                     tsrs.indexName,
0:                     tsrs.isConstraint,
0:                     tsrs.printQualifiers(tsrs.qualifiers),
0:                     tsrs.getScanProperties(),
0:                     startPosition,
0:                     stopPosition,
0:                     isolationLevel,
0:                     lockRequestString,
0:                     tsrs.rowsPerRead,
0:                     tsrs.coarserLock,
0:                     tsrs.optimizerEstimatedRowCount,
0:                     tsrs.optimizerEstimatedCost);
0: 		}
0: 
0: 		else if (rs instanceof LastIndexKeyResultSet )
0: 		{
0: 			LastIndexKeyResultSet lrs = (LastIndexKeyResultSet) rs;
0: 			String isolationLevel =  null;
0: 			String lockRequestString = null;
0: 
0: 			switch (lrs.isolationLevel)
0: 			{
0: 				case TransactionController.ISOLATION_SERIALIZABLE:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_SERIALIZABLE);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_REPEATABLE_READ:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_REPEATABLE_READ);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
0: 				case TransactionController.ISOLATION_READ_COMMITTED:
0: 					isolationLevel = MessageService.getTextMessage(
0: 												SQLState.LANG_READ_COMMITTED);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
0: 					isolationLevel = MessageService.getTextMessage(
0: 												SQLState.LANG_READ_UNCOMMITTED);
0:                     break;
0: 			}
0: 
0: 			switch (lrs.lockMode)
0: 			{
0: 				case TransactionController.MODE_TABLE:
0: 					lockRequestString = MessageService.getTextMessage(
0: 													SQLState.LANG_SHARE_TABLE);
0: 					break;
0: 
0: 				case TransactionController.MODE_RECORD:
0: 					lockRequestString = MessageService.getTextMessage(
0: 													SQLState.LANG_SHARE_ROW);
0: 					break;
0: 			}
0: 
0: 			return new RealLastIndexKeyScanStatistics(
0: 											lrs.numOpens,
0: 											lrs.constructorTime,
0: 											lrs.openTime,
0: 											lrs.nextTime,
0: 											lrs.closeTime,
0: 											lrs.resultSetNumber,
0: 											lrs.tableName,
0: 											lrs.indexName,
0: 											isolationLevel,
0: 											lockRequestString,
0: 											lrs.optimizerEstimatedRowCount,
0: 											lrs.optimizerEstimatedCost);
0: 		}
0: 		else if (rs instanceof HashLeftOuterJoinResultSet)
0: 		{
0: 			HashLeftOuterJoinResultSet hlojrs =
0: 				(HashLeftOuterJoinResultSet) rs;
0: 
0: 			return new RealHashLeftOuterJoinStatistics(
0: 											hlojrs.numOpens,
0: 											hlojrs.rowsSeen,
0: 											hlojrs.rowsFiltered,
0: 											hlojrs.constructorTime,
0: 											hlojrs.openTime,
0: 											hlojrs.nextTime,
0: 											hlojrs.closeTime,
0: 											hlojrs.resultSetNumber,
0: 											hlojrs.rowsSeenLeft,
0: 											hlojrs.rowsSeenRight,
0: 											hlojrs.rowsReturned,
0: 											hlojrs.restrictionTime,
0: 											hlojrs.optimizerEstimatedRowCount,
0: 											hlojrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(
0: 												hlojrs.leftResultSet),
0: 											getResultSetStatistics(
0: 												hlojrs.rightResultSet),
0: 											hlojrs.emptyRightRowsReturned);
0: 		}
0: 		else if (rs instanceof NestedLoopLeftOuterJoinResultSet)
0: 		{
0: 			NestedLoopLeftOuterJoinResultSet nllojrs =
0: 				(NestedLoopLeftOuterJoinResultSet) rs;
0: 
0: 			return new RealNestedLoopLeftOuterJoinStatistics(
0: 											nllojrs.numOpens,
0: 											nllojrs.rowsSeen,
0: 											nllojrs.rowsFiltered,
0: 											nllojrs.constructorTime,
0: 											nllojrs.openTime,
0: 											nllojrs.nextTime,
0: 											nllojrs.closeTime,
0: 											nllojrs.resultSetNumber,
0: 											nllojrs.rowsSeenLeft,
0: 											nllojrs.rowsSeenRight,
0: 											nllojrs.rowsReturned,
0: 											nllojrs.restrictionTime,
0: 											nllojrs.optimizerEstimatedRowCount,
0: 											nllojrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(
0: 												nllojrs.leftResultSet),
0: 											getResultSetStatistics(
0: 												nllojrs.rightResultSet),
0: 											nllojrs.emptyRightRowsReturned);
0: 		}
0: 		else if (rs instanceof HashJoinResultSet)
0: 		{
0: 			HashJoinResultSet hjrs = (HashJoinResultSet) rs;
0: 
0: 			return new RealHashJoinStatistics(
0: 											hjrs.numOpens,
0: 											hjrs.rowsSeen,
0: 											hjrs.rowsFiltered,
0: 											hjrs.constructorTime,
0: 											hjrs.openTime,
0: 											hjrs.nextTime,
0: 											hjrs.closeTime,
0: 											hjrs.resultSetNumber,
0: 											hjrs.rowsSeenLeft,
0: 											hjrs.rowsSeenRight,
0: 											hjrs.rowsReturned,
0: 											hjrs.restrictionTime,
0: 											hjrs.oneRowRightSide,
0: 											hjrs.optimizerEstimatedRowCount,
0: 											hjrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(
0: 												hjrs.leftResultSet),
0: 											getResultSetStatistics(
0: 												hjrs.rightResultSet)
0: 											);
0: 		}
0: 		else if (rs instanceof NestedLoopJoinResultSet)
0: 		{
0: 			NestedLoopJoinResultSet nljrs = (NestedLoopJoinResultSet) rs;
0: 
0: 			return new RealNestedLoopJoinStatistics(
0: 											nljrs.numOpens,
0: 											nljrs.rowsSeen,
0: 											nljrs.rowsFiltered,
0: 											nljrs.constructorTime,
0: 											nljrs.openTime,
0: 											nljrs.nextTime,
0: 											nljrs.closeTime,
0: 											nljrs.resultSetNumber,
0: 											nljrs.rowsSeenLeft,
0: 											nljrs.rowsSeenRight,
0: 											nljrs.rowsReturned,
0: 											nljrs.restrictionTime,
0: 											nljrs.oneRowRightSide,
0: 											nljrs.optimizerEstimatedRowCount,
0: 											nljrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(
0: 												nljrs.leftResultSet),
0: 											getResultSetStatistics(
0: 												nljrs.rightResultSet)
0: 											);
0: 		}
0: 		else if (rs instanceof IndexRowToBaseRowResultSet)
0: 		{
0: 			IndexRowToBaseRowResultSet irtbrrs =
0: 											(IndexRowToBaseRowResultSet) rs;
0: 
0: 			return new RealIndexRowToBaseRowStatistics(
0: 											irtbrrs.numOpens,
0: 											irtbrrs.rowsSeen,
0: 											irtbrrs.rowsFiltered,
0: 											irtbrrs.constructorTime,
0: 											irtbrrs.openTime,
0: 											irtbrrs.nextTime,
0: 											irtbrrs.closeTime,
0: 											irtbrrs.resultSetNumber,
0: 											irtbrrs.indexName,
0: 											irtbrrs.accessedHeapCols,
0: 											irtbrrs.optimizerEstimatedRowCount,
0: 											irtbrrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(
0: 																irtbrrs.source)
0: 											);
0: 		}
0: 		else if (rs instanceof RowResultSet)
0: 		{
0: 			RowResultSet rrs = (RowResultSet) rs;
0: 
0: 			return new RealRowResultSetStatistics(
0: 											rrs.numOpens,
0: 											rrs.rowsSeen,
0: 											rrs.rowsFiltered,
0: 											rrs.constructorTime,
0: 											rrs.openTime,
0: 											rrs.nextTime,
0: 											rrs.closeTime,
0: 											rrs.resultSetNumber,
0: 											rrs.rowsReturned,
0: 											rrs.optimizerEstimatedRowCount,
0: 											rrs.optimizerEstimatedCost);
0: 		}
0: 		else if (rs instanceof UnionResultSet)
0: 		{
0: 			UnionResultSet urs = (UnionResultSet) rs;
0: 
0: 			return new RealUnionResultSetStatistics(
0: 											urs.numOpens,
0: 											urs.rowsSeen,
0: 											urs.rowsFiltered,
0: 											urs.constructorTime,
0: 											urs.openTime,
0: 											urs.nextTime,
0: 											urs.closeTime,
0: 											urs.resultSetNumber,
0: 											urs.rowsSeenLeft,
0: 											urs.rowsSeenRight,
0: 											urs.rowsReturned,
0: 											urs.optimizerEstimatedRowCount,
0: 											urs.optimizerEstimatedCost,
0: 											getResultSetStatistics(urs.source1),
0: 											getResultSetStatistics(urs.source2)
0: 											);
0: 		}
0: 		else if (rs instanceof AnyResultSet)
0: 		{
0: 			AnyResultSet ars = (AnyResultSet) rs;
0: 
0: 			return new RealAnyResultSetStatistics(
0: 											ars.numOpens,
0: 											ars.rowsSeen,
0: 											ars.rowsFiltered,
0: 											ars.constructorTime,
0: 											ars.openTime,
0: 											ars.nextTime,
0: 											ars.closeTime,
0: 											ars.resultSetNumber,
0: 											ars.subqueryNumber,
0: 											ars.pointOfAttachment,
0: 											ars.optimizerEstimatedRowCount,
0: 											ars.optimizerEstimatedCost,
0: 											getResultSetStatistics(ars.source)
0: 											);
0: 		}
0: 		else if (rs instanceof OnceResultSet)
0: 		{
0: 			OnceResultSet ors = (OnceResultSet) rs;
0: 
0: 			return new RealOnceResultSetStatistics(
0: 											ors.numOpens,
0: 											ors.rowsSeen,
0: 											ors.rowsFiltered,
0: 											ors.constructorTime,
0: 											ors.openTime,
0: 											ors.nextTime,
0: 											ors.closeTime,
0: 											ors.resultSetNumber,
0: 											ors.subqueryNumber,
0: 											ors.pointOfAttachment,
0: 											ors.optimizerEstimatedRowCount,
0: 											ors.optimizerEstimatedCost,
0: 											getResultSetStatistics(ors.source)
0: 											);
0: 		}
0: 		else if (rs instanceof NormalizeResultSet)
0: 		{
0: 			NormalizeResultSet nrs = (NormalizeResultSet) rs;
0: 
0: 			return new RealNormalizeResultSetStatistics(
0: 											nrs.numOpens,
0: 											nrs.rowsSeen,
0: 											nrs.rowsFiltered,
0: 											nrs.constructorTime,
0: 											nrs.openTime,
0: 											nrs.nextTime,
0: 											nrs.closeTime,
0: 											nrs.resultSetNumber,
0: 											nrs.optimizerEstimatedRowCount,
0: 											nrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(nrs.source)
0: 											);
0: 		}
0: 		else if (rs instanceof MaterializedResultSet)
0: 		{
0: 			MaterializedResultSet mrs = (MaterializedResultSet) rs;
0: 
0: 			return new RealMaterializedResultSetStatistics(
0: 											mrs.numOpens,
0: 											mrs.rowsSeen,
0: 											mrs.rowsFiltered,
0: 											mrs.constructorTime,
0: 											mrs.openTime,
0: 											mrs.nextTime,
0: 											mrs.closeTime,
0: 											mrs.createTCTime,
0: 											mrs.fetchTCTime,
0: 											mrs.resultSetNumber,
0: 											mrs.optimizerEstimatedRowCount,
0: 											mrs.optimizerEstimatedCost,
0: 											getResultSetStatistics(mrs.source)
0: 											);
0: 		}
0: 		else if (rs instanceof ScrollInsensitiveResultSet)
0: 		{
0: 			ScrollInsensitiveResultSet sirs = (ScrollInsensitiveResultSet) rs;
0: 
0: 			return new RealScrollInsensitiveResultSetStatistics(
0: 											sirs.numOpens,
0: 											sirs.rowsSeen,
0: 											sirs.rowsFiltered,
0: 											sirs.constructorTime,
0: 											sirs.openTime,
0: 											sirs.nextTime,
0: 											sirs.closeTime,
0: 											sirs.numFromHashTable,
0: 											sirs.numToHashTable,
0: 											sirs.resultSetNumber,
0: 											sirs.optimizerEstimatedRowCount,
0: 											sirs.optimizerEstimatedCost,
0: 											getResultSetStatistics(sirs.source)
0: 											);
0: 		}
0: 		else if (rs instanceof CurrentOfResultSet)
0: 		{
0: 			CurrentOfResultSet cors = (CurrentOfResultSet) rs;
0: 
0: 			return new RealCurrentOfStatistics(
0: 											cors.numOpens,
0: 											cors.rowsSeen,
0: 											cors.rowsFiltered,
0: 											cors.constructorTime,
0: 											cors.openTime,
0: 											cors.nextTime,
0: 											cors.closeTime,
0: 											cors.resultSetNumber
0: 											);
0: 		}
0: 		else if (rs instanceof HashScanResultSet)
0: 		{
0: 			boolean instantaneousLocks = false;
0: 			HashScanResultSet hsrs = (HashScanResultSet) rs;
0: 			String startPosition = null;
0: 			String stopPosition = null;
0: 			String isolationLevel =  null;
0: 			String lockString = null;
0: 
0: 			switch (hsrs.isolationLevel)
0: 			{
0: 				case TransactionController.ISOLATION_SERIALIZABLE:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_SERIALIZABLE);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_REPEATABLE_READ:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_REPEATABLE_READ);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
0: 					instantaneousLocks = true;
0: 					//fall through
0: 				case TransactionController.ISOLATION_READ_COMMITTED:
0: 					isolationLevel = MessageService.getTextMessage(
0: 												SQLState.LANG_READ_COMMITTED);
0: 					break;
0: 
0: 			}
0: 
0: 			if (hsrs.forUpdate)
0: 			{
0: 				lockString = MessageService.getTextMessage(
0: 													SQLState.LANG_EXCLUSIVE);
0: 			}
0: 			else
0: 			{
0: 				if (instantaneousLocks)
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 											SQLState.LANG_INSTANTANEOUS_SHARE);
0: 				}
0: 				else
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 														SQLState.LANG_SHARE);
0: 				}
0: 			}
0: 
0: 			switch (hsrs.lockMode)
0: 			{
0: 				case TransactionController.MODE_TABLE:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockString = lockString + " " +
0: 									MessageService.getTextMessage(
0: 														SQLState.LANG_TABLE);
0: 					break;
0: 
0: 				case TransactionController.MODE_RECORD:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockString = lockString + " " +
0: 									MessageService.getTextMessage(
0: 															SQLState.LANG_ROW);
0: 					break;
0: 			}
0: 
0: 			if (hsrs.indexName != null)
0: 			{
0: 				/* Start and stop position strings will be non-null
0: 			 	* if the HSRS has been closed.  Otherwise, we go off
0: 			 	* and build the strings now.
0: 			 	*/
0: 				startPosition = hsrs.startPositionString;
0: 				if (startPosition == null)
0: 				{
0: 					startPosition = hsrs.printStartPosition();
0: 				}
0: 				stopPosition = hsrs.stopPositionString;
0: 				if (stopPosition == null)
0: 				{
0: 					stopPosition = hsrs.printStopPosition();
0: 				}
0: 			}
0: 
0: 			// DistinctScanResultSet is simple sub-class of
0: 			// HashScanResultSet
0: 			if (rs instanceof DistinctScanResultSet)
0: 			{
0: 				return new RealDistinctScanStatistics(
0: 											hsrs.numOpens,
0: 											hsrs.rowsSeen,
0: 											hsrs.rowsFiltered,
0: 											hsrs.constructorTime,
0: 											hsrs.openTime,
0: 											hsrs.nextTime,
0: 											hsrs.closeTime,
0: 											hsrs.resultSetNumber,
0: 											hsrs.tableName,
0: 											hsrs.indexName,
0: 											hsrs.isConstraint,
0: 											hsrs.hashtableSize,
0: 											hsrs.keyColumns,
0: 											hsrs.printQualifiers(
0: 												hsrs.scanQualifiers),
0: 											hsrs.printQualifiers(
0: 												hsrs.nextQualifiers),
0: 											hsrs.getScanProperties(),
0: 											startPosition,
0: 											stopPosition,
0: 											isolationLevel,
0: 											lockString,
0: 											hsrs.optimizerEstimatedRowCount,
0: 											hsrs.optimizerEstimatedCost
0: 											);
0: 			}
0: 			else
0: 			{
0: 				return new RealHashScanStatistics(
0: 											hsrs.numOpens,
0: 											hsrs.rowsSeen,
0: 											hsrs.rowsFiltered,
0: 											hsrs.constructorTime,
0: 											hsrs.openTime,
0: 											hsrs.nextTime,
0: 											hsrs.closeTime,
0: 											hsrs.resultSetNumber,
0: 											hsrs.tableName,
0: 											hsrs.indexName,
0: 											hsrs.isConstraint,
0: 											hsrs.hashtableSize,
0: 											hsrs.keyColumns,
0: 											hsrs.printQualifiers(
0: 												hsrs.scanQualifiers),
0: 											hsrs.printQualifiers(
0: 												hsrs.nextQualifiers),
0: 											hsrs.getScanProperties(),
0: 											startPosition,
0: 											stopPosition,
0: 											isolationLevel,
0: 											lockString,
0: 											hsrs.optimizerEstimatedRowCount,
0: 											hsrs.optimizerEstimatedCost
0: 											);
0: 			}
0: 		}
0: 		else if (rs instanceof HashTableResultSet)
0: 		{
0: 			HashTableResultSet htrs = (HashTableResultSet) rs;
0: 			int subqueryTrackingArrayLength =
0: 				(htrs.subqueryTrackingArray == null) ? 0 :
0: 					htrs.subqueryTrackingArray.length;
0: 			ResultSetStatistics[] subqueryTrackingArray =
0: 				new ResultSetStatistics[subqueryTrackingArrayLength];
0: 			boolean anyAttached = false;
0: 			for (int index = 0; index < subqueryTrackingArrayLength; index++)
0: 			{
0: 				if (htrs.subqueryTrackingArray[index] != null &&
0: 					htrs.subqueryTrackingArray[index].getPointOfAttachment() ==
0: 						htrs.resultSetNumber)
0: 				{
0: 					subqueryTrackingArray[index] =
0: 										getResultSetStatistics(
0: 											htrs.subqueryTrackingArray[index]);
0: 					anyAttached = true;
0: 				}
0: 			}
0: 			if (! anyAttached)
0: 			{
0: 				subqueryTrackingArray = null;
0: 			}
0: 
0: 			return new 
0:                 RealHashTableStatistics(
0:                     htrs.numOpens,
0:                     htrs.rowsSeen,
0:                     htrs.rowsFiltered,
0:                     htrs.constructorTime,
0:                     htrs.openTime,
0:                     htrs.nextTime,
0:                     htrs.closeTime,
0:                     htrs.resultSetNumber,
0:                     htrs.hashtableSize,
0:                     htrs.keyColumns,
0:                     HashScanResultSet.printQualifiers(
0:                         htrs.nextQualifiers),
0:                     htrs.scanProperties,
0:                     htrs.optimizerEstimatedRowCount,
0:                     htrs.optimizerEstimatedCost,
0:                     subqueryTrackingArray,
0:                     getResultSetStatistics(htrs.source)
0:                     );
0: 		}
0: 		else if (rs instanceof VTIResultSet)
0: 		{
0: 			VTIResultSet vtirs = (VTIResultSet) rs;
0: 
0: 			return new RealVTIStatistics(
0: 										vtirs.numOpens,
0: 										vtirs.rowsSeen,
0: 										vtirs.rowsFiltered,
0: 										vtirs.constructorTime,
0: 										vtirs.openTime,
0: 										vtirs.nextTime,
0: 										vtirs.closeTime,
0: 										vtirs.resultSetNumber,
0: 										vtirs.javaClassName,
0: 										vtirs.optimizerEstimatedRowCount,
0: 										vtirs.optimizerEstimatedCost
0: 										);
0: 		}
0: 
0: 		else if (rs instanceof DependentResultSet)
0: 		{
0: 			boolean instantaneousLocks = false;
0: 			DependentResultSet dsrs = (DependentResultSet) rs;
0: 			String startPosition = null;
0: 			String stopPosition = null;
0: 			String isolationLevel =  null;
0: 			String lockString = null;
0: 			String lockRequestString = null;
0: 
0: 			switch (dsrs.isolationLevel)
0: 			{
0: 				case TransactionController.ISOLATION_SERIALIZABLE:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_SERIALIZABLE);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_REPEATABLE_READ:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_REPEATABLE_READ);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:
0: 					instantaneousLocks = true;
0: 					//fall through
0: 				case TransactionController.ISOLATION_READ_COMMITTED:
0: 					isolationLevel = MessageService.getTextMessage(
0: 												SQLState.LANG_READ_COMMITTED);
0: 					break;
0: 
0: 				case TransactionController.ISOLATION_READ_UNCOMMITTED:
0: 					isolationLevel = 
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_READ_UNCOMMITTED);
0: 					break;
0: 			}
0: 
0: 			if (dsrs.forUpdate)
0: 			{
0: 				lockString = MessageService.getTextMessage(
0: 												SQLState.LANG_EXCLUSIVE);
0: 			}
0: 			else
0: 			{
0: 				if (instantaneousLocks)
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 											SQLState.LANG_INSTANTANEOUS_SHARE);
0: 				}
0: 				else
0: 				{
0: 					lockString = MessageService.getTextMessage(
0: 														SQLState.LANG_SHARE);
0: 				}
0: 			}
0: 
0: 			switch (dsrs.lockMode)
0: 			{
0: 				case TransactionController.MODE_TABLE:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockRequestString = lockString + " " +
0: 										MessageService.getTextMessage(
0: 											SQLState.LANG_TABLE);
0: 					break;
0: 
0: 				case TransactionController.MODE_RECORD:
0: 					// RESOLVE: Not sure this will really work, as we
0: 					// are tacking together English words to make a phrase.
0: 					// Will this work in other languages?
0: 					lockRequestString = lockString + " " +
0: 										MessageService.getTextMessage(
0: 											SQLState.LANG_ROW);
0: 					break;
0: 			}
0: 
0: 			/* Start and stop position strings will be non-null
0: 			 * if the dSRS has been closed.  Otherwise, we go off
0: 			 * and build the strings now.
0: 			 */
0: 			startPosition = dsrs.startPositionString;
0: 			if (startPosition == null)
0: 			{
0: 				startPosition = dsrs.printStartPosition();
0: 			}
0: 			stopPosition = dsrs.stopPositionString;
0: 			if (stopPosition == null)
0: 			{
0: 				stopPosition = dsrs.printStopPosition();
0: 			}
0: 		
0: 			return new 
0:                 RealTableScanStatistics(
0:                     dsrs.numOpens,
0:                     dsrs.rowsSeen,
0:                     dsrs.rowsFiltered,
0:                     dsrs.constructorTime,
0:                     dsrs.openTime,
0:                     dsrs.nextTime,
0:                     dsrs.closeTime,
0:                     dsrs.resultSetNumber,
0:                     dsrs.tableName,
0:                     dsrs.indexName,
0:                     dsrs.isConstraint,
0:                     dsrs.printQualifiers(),
0:                     dsrs.getScanProperties(),
0:                     startPosition,
0:                     stopPosition,
0:                     isolationLevel,
0:                     lockRequestString,
0:                     dsrs.rowsPerRead,
0:                     dsrs.coarserLock,
0:                     dsrs.optimizerEstimatedRowCount,
0:                     dsrs.optimizerEstimatedCost);
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
0: 
0: 	//
0: 	// class interface
0: 	//
0: 	public RealResultSetStatisticsFactory() 
0: 	{
0: 	}
0: 
0: }
============================================================================