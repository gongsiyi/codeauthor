1:2bc809f: /*
2:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverFullLog
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.UnitTest;
1:2bc809f: 
1:2bc809f: import org.apache.derby.impl.store.raw.log.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: import org.apache.derby.iapi.services.context.ContextManager;
1:2bc809f: import org.apache.derby.iapi.services.daemon.DaemonService;
1:2bc809f: import org.apache.derby.iapi.services.property.PropertyUtil;
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:2bc809f: import org.apache.derby.iapi.services.locks.LockFactory;
1:2bc809f: import org.apache.derby.iapi.services.io.Storable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: import org.apache.derby.iapi.reference.EngineType;
1:2bc809f: import org.apache.derby.iapi.services.property.PropertyUtil;
1:2bc809f: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.raw.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:2bc809f: 
1:2bc809f: import java.io.IOException;
1:2bc809f: import java.io.RandomAccessFile;
1:2bc809f: import java.io.File;
1:a0dbbd7: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:a0dbbd7: import java.security.AccessController;
1:2bc809f: import java.util.Properties;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: /**
1:2bc809f: 	A implementation unit test for log full condition
1:2bc809f: 
1:2bc809f:     To run, create a derby.properties file in a new directory with the
1:2bc809f: 	contents
1:2bc809f: 
1:2bc809f: 	derby.module.test.recoverFullLog=org.apache.derbyTesting.unitTests.store.T_RecoverFullLog
1:2bc809f: 
1:2bc809f:     Execute in order
1:2bc809f: 
1:2bc809f: 	java -DTestFillLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 
1:2bc809f: 	java -DTestLogSwitchFail=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 
1:2bc809f: 	java -DTestFullRecoveryFail=true org.apache.derbyTesting.unitTests.harness.UnitTestMain 
1:2bc809f: 		(run this serveral times, this simulate recovery running out of log)
1:2bc809f: 
1:2bc809f: 	java -DTestFullRecover=true org.apache.derbyTesting.unitTests.harness.UnitTestMain 
1:2bc809f: 
1:2bc809f: */
1:2bc809f: 
1:2bc809f: public class T_RecoverFullLog extends T_Generic {
1:2bc809f: 
1:2bc809f: 	private static final String testService = "FullLogTest";
1:2bc809f: 
1:2bc809f: 	static final String REC_001 = "McLaren";
1:2bc809f: 	static final String REC_002 = "Ferrari";
1:2bc809f: 	static final String REC_003 = "Benetton";
1:2bc809f: 	static final String REC_004 = "Prost";
1:2bc809f: 	static final String REC_005 = "Tyrell";
1:2bc809f: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1:2bc809f: 	static final String REC_UNDO = "Lotus";
1:2bc809f: 	static final String SP1 = "savepoint1";
1:2bc809f: 	static final String SP2 = "savepoint2";
1:2bc809f: 
1:2bc809f: 	private RandomAccessFile infofile = null;
1:2bc809f: 	private static final String infoPath = "extinout/T_RecoverFullLog.info";
1:2bc809f: 
1:2bc809f: 	private boolean fillLog;	// test to full up the log
1:2bc809f: 	private boolean recoveryFail; // recovery fill up the log
1:2bc809f: 	private boolean logSwitchFail;	// log filled up during log switch
1:2bc809f: 	private boolean recover;	// successfully recover
1:2bc809f: 
1:2bc809f: 	private String TEST_FILL_LOG = "TestFillLog";	// test to full up the log
1:2bc809f: 	private String TEST_FULL_RECOVER_FAIL = "TestFullRecoveryFail"; // recovery fill up the log
1:2bc809f: 	private String TEST_LOG_SWITCH_FAIL = "TestLogSwitchFail"; // log filled up during log switch
1:2bc809f: 	private String TEST_FULL_RECOVER = "TestFullRecover";	// successfully recover
1:2bc809f: 
1:2bc809f: 	private static final String TEST_FULL_LOG_INFO = "TestFullLogInfo";
1:2bc809f: 
1:2bc809f: 	RawStoreFactory	factory;
1:2bc809f: 	LockFactory  lf;
1:2bc809f: 	ContextService contextService;
1:2bc809f: 	T_Util t_util;
1:2bc809f: 
1:2bc809f: 	public T_RecoverFullLog() {
1:2bc809f: 		super();
2:2bc809f: 	}
1:a0dbbd7: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods required by T_Generic
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	public String getModuleToTestProtocolName() {
1:2bc809f: 		return RawStoreFactory.MODULE;
1:2bc809f: 	}
1:2bc809f: 
1:a0dbbd7: 	/**
1:2bc809f: 	*/
1:2bc809f: 	private void getConfig()
1:a0dbbd7: 	{
1:2bc809f: 		String param;
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_FILL_LOG);
1:2bc809f: 		fillLog = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_FULL_RECOVER_FAIL);
1:2bc809f: 		recoveryFail = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_FULL_RECOVER);
1:2bc809f: 		recover = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_LOG_SWITCH_FAIL);
1:2bc809f: 		logSwitchFail = Boolean.valueOf(param).booleanValue();
1:a0dbbd7: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	    See T_Recovery for the general testing frame work
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	 */
1:2bc809f: 	public void runTests() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		getConfig();
1:2bc809f: 		int tests = 0;
1:2bc809f: 		if (fillLog) tests++;
1:2bc809f: 		if (recoveryFail) tests++;
1:2bc809f: 		if (recover) tests++;
1:2bc809f: 		if (logSwitchFail) tests++;
1:2bc809f: 
1:2bc809f: 		if (tests != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("One & only one of the full log recovery test should be run, now " + tests + " set");
1:2bc809f: 
1:2bc809f: 		if (!SanityManager.DEBUG)
3:2bc809f: 		{
1:2bc809f: 			REPORT("recoverBadLog cannot be run on an insane server");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 
1:a0dbbd7: 			contextService = getContextService();
1:2bc809f: 
1:2bc809f: 			File ifile = new File(infoPath);
1:2bc809f: 			
1:2bc809f: 			//if external input output files dir does not exist ,create one
1:2bc809f: 			File ifdir = new File("extinout");
1:2bc809f: 			if(!ifdir.exists())
1:2bc809f: 				ifdir.mkdirs();
1:2bc809f: 			// see if we are testing encryption
1:2bc809f: 			startParams = T_Util.setEncryptionParam(startParams);
1:2bc809f: 
1:2bc809f: 			if (fillLog)				// the first test cleans up and start from fresh
1:2bc809f: 			{
1:2bc809f: 				// remove the service directory to ensure a clean run
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 				REPORT("\n\t\tcleaning up database for recovering from filled log");
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 				// don't automatic boot this service if it gets left around
1:2bc809f: 				if (startParams == null) 
1:2bc809f: 					startParams = new Properties();
1:2bc809f: 				
1:2bc809f: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1:2bc809f: 				// remove the service directory to ensure a clean run
1:2bc809f: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1:2bc809f: 
1:56c1dc2: 				factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
1:2bc809f: 																  testService,
1:2bc809f: 																  startParams);
1:2bc809f: 				// create a database with nothing
1:2bc809f: 
1:2bc809f: 				// if exist, delete the info file
1:2bc809f: 				if (ifile.exists())
1:2bc809f: 					ifile.delete();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 				// create a new info file
1:2bc809f: 				try
1:2bc809f: 				{
1:2bc809f: 					infofile = new RandomAccessFile(ifile, "rw");
1:2bc809f: 				}
1:2bc809f: 				catch (IOException ioe)
1:2bc809f: 				{
1:2bc809f: 					System.out.println("Cannot write to temporary file " +
1:2bc809f: 									   infoPath + 
1:2bc809f: 									   ".  Please make sure it is correct, if not, please set the property " +
1:2bc809f: 									   "TestFullLogInfo=<where temp files should go>");
1:2bc809f: 
1:2bc809f: 					throw T_Fail.exceptionFail(ioe);
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 					
1:2bc809f: 			}
1:a0dbbd7: 			else
1:a0dbbd7: 			{
1:2bc809f: 				// see if we can recover the database
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 				if (recoveryFail)
1:2bc809f: 					REPORT("\n\t\trecovering database - recovery will fill up log");
2:2bc809f: 				else
1:2bc809f: 					REPORT("\n\t\trecovering database - recovery should succeed");
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 				try
1:2bc809f: 				{
1:2bc809f: 					// make sure it does exist
1:2bc809f: 					infofile = new RandomAccessFile(ifile, "rw");
1:2bc809f: 				}
1:2bc809f: 				catch (IOException ioe)
1:2bc809f: 				{
1:2bc809f: 					throw T_Fail.exceptionFail(ioe);
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 				// let recovery log 10 records then run out of space
1:2bc809f: 				if (recoveryFail)
1:2bc809f: 				{
1:2bc809f: 					SanityManager.DEBUG_SET(LogToFile.TEST_LOG_FULL);
1:1093b6d: 					System.setProperty(LogToFile.TEST_RECORD_TO_FILL_LOG, "10");
1:2bc809f: 				}
1:2bc809f: 
1:56c1dc2: 				if (!startPersistentService(testService, startParams))
1:2bc809f: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
1:56c1dc2: 				factory = (RawStoreFactory) findService(getModuleToTestProtocolName(), testService);
1:2bc809f: 
1:2bc809f: 				if (recoveryFail)
1:2bc809f: 				{
1:2bc809f: 					throw T_Fail.testFailMsg("recovery should have failed but did not - did you run the test in order?");
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 
1:2bc809f: 			if (recoveryFail) {
1:2bc809f: 						REPORT("_______________________________________________________");
1:2bc809f: 						REPORT("\n\tRecovery failed due to log full as requested ");
1:2bc809f: 						REPORT("\texception was " + mse.toString());
1:2bc809f: 						REPORT("_______________________________________________________");
1:2bc809f: 						return;
1:2bc809f: 
1:2bc809f: 			}
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		} catch (NullPointerException npe) {
1:2bc809f: 
1:2bc809f: 			if (recoveryFail) {
1:2bc809f: 						REPORT("_______________________________________________________");
1:2bc809f: 						REPORT("\n\tRecovery failed due to log full as requested ");
1:2bc809f: 						REPORT("\texception was " + npe.toString());
1:2bc809f: 						REPORT("_______________________________________________________");
1:2bc809f: 						return;
1:2bc809f: 
1:2bc809f: 			}
1:2bc809f: 			throw T_Fail.exceptionFail(npe);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		if (factory == null) {
1:2bc809f: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1:2bc809f: 		}
1:2bc809f: 			
1:2bc809f: 		lf = factory.getLockFactory();
1:2bc809f: 		if (lf == null) {
1:2bc809f: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// get a utility helper
1:2bc809f: 		t_util = new T_Util(factory, lf, contextService);
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			if (fillLog)
1:2bc809f: 			{
1:2bc809f: 				testBasic(1);
1:2bc809f: 				fillUpLog();
1:2bc809f: 			}
1:2bc809f: 			else if (logSwitchFail)
1:2bc809f: 			{
1:2bc809f: 				testBasic(2);
1:2bc809f: 				logSwitchFail1();
1:2bc809f: 				testBasic(3);
1:2bc809f: 				logSwitchFail2();
1:2bc809f: 			}
1:2bc809f: 			else if (!recoveryFail)
1:2bc809f: 			{
1:2bc809f: 				checkRecovery();
1:2bc809f: 			}
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private long find(long inkey)
1:2bc809f: 	{
1:2bc809f: 		if (infofile == null)
1:2bc809f: 			return -1;
1:2bc809f: 
1:2bc809f: 		try 
1:2bc809f: 		{
1:2bc809f: 			infofile.seek(0);
1:2bc809f: 			long key;
1:2bc809f: 
1:2bc809f: 			while(true)
1:2bc809f: 			{
1:2bc809f: 				key = infofile.readLong();
1:2bc809f: 				if (key == inkey)
1:2bc809f: 				{
1:2bc809f: 					long value = infofile.readLong();
1:2bc809f: 					// System.out.println("found " + key + " " + value);
1:2bc809f: 					return value;
1:2bc809f: 				}
1:2bc809f: 				infofile.readLong();
1:2bc809f: 			}
1:2bc809f: 		} 
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			// System.out.println("key not found " + inkey);
1:2bc809f: 			return -1;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private long key(int test, int param)
1:2bc809f: 	{
1:2bc809f: 		long i = test;
1:2bc809f: 		return ((i << 32) + param);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private void register(long key, long value)
1:2bc809f: 		 throws T_Fail
1:2bc809f: 	{
1:2bc809f: 		// System.out.println("registering " + key + " " + value);
1:2bc809f: 		try 
1:2bc809f: 		{
1:2bc809f: 			// go to the end
1:2bc809f: 			infofile.seek(infofile.length());
1:2bc809f: 			infofile.writeLong(key);
1:2bc809f: 			infofile.writeLong(value);
1:2bc809f: 		}
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			T_Fail.exceptionFail(ioe);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * A basic routine to write a bunch of stuff to the log
1:2bc809f: 	 * There will be some committed transactions, some uncommitted transactions,
1:2bc809f: 	 * serveral checkpoints.
1:2bc809f: 	 */
1:2bc809f: 	protected void testBasic(int testNumber) throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		int numtrans = 7;
1:2bc809f: 		int numpages = 7;
1:2bc809f: 		int i,j;
1:2bc809f: 
1:2bc809f: 		// this is basically T_Recovery S203 
1:2bc809f: 		T_TWC[] t = new T_TWC[numtrans];
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 			t[i] =  t_util.t_startTransactionWithContext();
1:2bc809f: 
1:2bc809f: 		long[] cid = new long[numtrans];
1:2bc809f: 		ContainerHandle[] c = new ContainerHandle[numtrans];
1:2bc809f: 
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			cid[i] = t_util.t_addContainer(t[i], 0);
1:2bc809f: 			t_util.t_commit(t[i]);
1:2bc809f: 			c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		Page page[][] = new Page[numtrans][numpages];
1:2bc809f: 		long pagenum[][] = new long[numtrans][numpages];
1:2bc809f: 
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
5:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 				page[i][j] = t_util.t_addPage(c[i]);
1:2bc809f: 				pagenum[i][j] = page[i][j].getPageNumber();
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// set up numtrans (at least 5) transactions, each with one
1:2bc809f: 		// container and numpages pages.  Do the following test:
1:2bc809f: 		//
1:2bc809f: 		// 1) insert 1 row onto each page
1:2bc809f: 		// set savepoint SP1 on first transaction (t0)
1:2bc809f: 		//
1:2bc809f: 		// 2) update every rows
1:2bc809f: 		// set savepoint SP1 on all other transactions
1:2bc809f: 		//
1:2bc809f: 		// 3) update every rows
1:2bc809f: 		// set savepoint SP2 on all transactions
1:2bc809f: 		// 
1:2bc809f: 		// 4) update every rows
1:2bc809f: 		//
1:2bc809f: 		// 5) rollback t0 to SP1
1:2bc809f: 		//
1:2bc809f: 		// check that only page[0][x] have been rolled back
1:2bc809f: 		// past SP2
1:2bc809f: 		//
1:2bc809f: 		// 6) update every row
1:2bc809f: 		// 7) rollback SP2 on all transaction except the first
1:2bc809f: 		// 
1:2bc809f: 		// 8) update every rows
1:2bc809f: 		// 9) rollback t0 to SP1
1:2bc809f: 		//
1:2bc809f: 		// 10) leave transactions in the following state
1:2bc809f: 		// t0 - incomplete
1:2bc809f: 		// t1 - abort
1:2bc809f: 		// t2 - commit
1:2bc809f: 		// t3 - incomplete
1:2bc809f: 		// t4 - commit
1:2bc809f: 		// any other transactions - incomplete
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 1 ////////////////////////
1:2bc809f: 		RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
1:2bc809f: 		T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 				rh[i][j] = t_util.t_insert(page[i][j], row1); 
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 		t[0].setSavePoint(SP1, null);	// sp1
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 2 ////////////////////////
1:2bc809f: 		T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:00d19b5: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 				page[i][j].updateAtSlot(slot, row2.getRow(), null);
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 		for (i = 1; i < numtrans; i++) // sp1
1:2bc809f: 		{
1:2bc809f: 			t[i].setSavePoint(SP1, null);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 3 ////////////////////////
1:2bc809f: 		T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:00d19b5: 			for (j = 0; j < numpages; j++) {
1:00d19b5: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 				page[i][j].updateAtSlot(slot, row3.getRow(), null);
1:00d19b5: 			}
1:2bc809f: 
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 			t[i].setSavePoint(SP2, null);	// sp2
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 4 ////////////////////////
1:2bc809f: 		T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 
1:00d19b5: 			for (j = 0; j < numpages; j++) {
1:00d19b5: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 				page[i][j].updateAtSlot(slot, row4.getRow(), null);
1:00d19b5: 			}
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 5 ////////////////////////
1:2bc809f: 		// unlatch relavante pages
1:2bc809f: 		t[0].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			page[0][j].unlatch();
1:2bc809f: 
1:2bc809f: 		t[0].rollbackToSavePoint(SP1, null); // step 5
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// relatch relavante pages
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1:2bc809f: 
1:2bc809f: 		t[0].resetContext();
1:2bc809f: 
1:2bc809f: 		//////////////////////// check ////////////////////////
1:2bc809f: 		for (i = 1; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		t[0].switchTransactionContext();
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1:2bc809f: 
1:2bc809f: 		t[0].resetContext();
1:2bc809f: 			//////////////////////// step 6 ////////////////////////
1:2bc809f: 		T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:00d19b5: 			for (j = 0; j < numpages; j++) {
1:00d19b5: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 				page[i][j].updateAtSlot(slot, row5.getRow(), null);
1:00d19b5: 			}
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 7 ////////////////////////
1:2bc809f: 		for (i = 1; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[i][j].unlatch();
1:2bc809f: 
1:2bc809f: 			t[i].rollbackToSavePoint(SP2, null);
1:2bc809f: 
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		//////////////////////// check ////////////////////////
1:2bc809f: 		for (i = 1; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		t[0].switchTransactionContext();
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
1:2bc809f: 
1:2bc809f: 		t[0].resetContext();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 8 ////////////////////////
1:2bc809f: 		T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:00d19b5: 			for (j = 0; j < numpages; j++) {
1:00d19b5: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 				page[i][j].updateAtSlot(slot, row6.getRow(), null);
1:00d19b5: 			}
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 9 ////////////////////////
1:2bc809f: 		// unlatch relavante pages
1:2bc809f: 		t[0].switchTransactionContext();
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			page[0][j].unlatch();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		t[0].rollbackToSavePoint(SP1, null); 
1:2bc809f: 
1:2bc809f: 		// relatch relevant pages
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 			page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1:2bc809f: 
1:2bc809f: 		t[0].resetContext();
1:2bc809f: 		//////////////////////// check ////////////////////////
1:2bc809f: 		for (i = 1; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
1:2bc809f: 				t_util.t_checkRecordCount(page[i][j], 1, 1);
1:2bc809f: 			}
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		t[0].switchTransactionContext();
1:2bc809f: 		for (j = 0; j < numpages; j++)
1:2bc809f: 		{
1:2bc809f: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1:2bc809f: 			t_util.t_checkRecordCount(page[0][j], 1, 1);
1:2bc809f: 		}
1:2bc809f: 		t[0].resetContext();
1:2bc809f: 
1:2bc809f: 		//////////////////////// step 10 ////////////////////////
1:2bc809f: 		// unlatch all pages
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			t[i].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[i][j].unlatch();
1:2bc809f: 			t[i].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// t[0] incomplete
1:2bc809f: 		t_util.t_abort(t[1]);
1:2bc809f: 		t_util.t_commit(t[2]);
1:2bc809f: 		// t[3] incomplete
1:2bc809f: 		t_util.t_commit(t[4]);
1:2bc809f: 
1:2bc809f: 			// reopen containers 1, 2, and 4, where were closed when the
1:2bc809f: 			// transaction terminated.
1:2bc809f: 		c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
1:2bc809f: 		c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
1:2bc809f: 		c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
1:2bc809f: 
1:2bc809f: 		//////////////////////// check ////////////////////////
1:2bc809f: 		for (j = 0; j < numpages; j++)	
1:2bc809f: 		{
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 			t_util.t_checkFetch(c[0], rh[0][j], REC_001);
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 
1:2bc809f: 			// t[1] has been aborted
1:2bc809f: 			// rh[1][j] (REC_001) is deleted
1:2bc809f: 			t[1].switchTransactionContext();
1:2bc809f: 			page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
1:2bc809f: 			t_util.t_checkRecordCount(page[1][j], 1, 0);
1:2bc809f: 			t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 									  REC_001, true, false);
1:2bc809f: 			page[1][j].unlatch();
1:2bc809f: 			t[1].resetContext();
1:2bc809f: 
1:2bc809f: 			t[2].switchTransactionContext();
1:2bc809f: 			t_util.t_checkFetch(c[2], rh[2][j], REC_006);
1:2bc809f: 			t[2].resetContext();
1:2bc809f: 
1:2bc809f: 			t[3].switchTransactionContext();
1:2bc809f: 			t_util.t_checkFetch(c[3], rh[3][j], REC_006);
1:2bc809f: 			t[3].resetContext();
1:2bc809f: 
1:2bc809f: 			t[4].switchTransactionContext();
1:2bc809f: 			t_util.t_checkFetch(c[4], rh[4][j], REC_006);
1:2bc809f: 			t[4].resetContext();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			register(key(testNumber, i+10), cid[i]);
1:2bc809f: 
1:2bc809f: 			String str = "container " + i + ":" + find(key(testNumber,i+10)) + " pages: ";
1:2bc809f: 
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				str += pagenum[i][j] + " ";
1:2bc809f: 				register(key(testNumber, (i+1)*1000+j), pagenum[i][j]);
1:2bc809f: 			}
1:2bc809f: 			REPORT("\t" + str);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		register(key(testNumber,1), numtrans); 
1:2bc809f: 		register(key(testNumber,2), numpages);
1:2bc809f: 
1:2bc809f: 		// let recovery try to roll back transactions t0, t3 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	// fill up the log immediately
1:2bc809f: 	protected void fillUpLog() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		SanityManager.DEBUG_SET(LogToFile.TEST_LOG_FULL);
1:1093b6d: 		System.setProperty(LogToFile.TEST_RECORD_TO_FILL_LOG, "1");
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException se)
1:2bc809f: 		{
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			REPORT("\n\tlog filled up as requested");
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		catch (NullPointerException npe)
1:2bc809f: 		{
1:2bc809f: 			// likely to be a null pointer exception being thrown because the
1:2bc809f: 			// system is forcibly shutdown due to corruption
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			REPORT("\n\tlog filled up as requested");
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		throw T_Fail.testFailMsg("log should have filled but did not");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void logSwitchFail1() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		SanityManager.DEBUG_SET(LogToFile.TEST_SWITCH_LOG_FAIL1);
1:2bc809f: 
1:2bc809f: 		factory.checkpoint(); // this should succeed, switch log is
1:2bc809f: 								   // optional before the end marker is written
1:2bc809f: 
1:2bc809f: 		SanityManager.DEBUG_CLEAR(LogToFile.TEST_SWITCH_LOG_FAIL1);
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 	protected void logSwitchFail2() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		SanityManager.DEBUG_SET(LogToFile.TEST_SWITCH_LOG_FAIL2);
1:2bc809f: 
1:2bc809f: 		int tries = 10;
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			// checkpoint should fail if it is attempted, after end marker is
1:2bc809f: 			// written, any error is fatal.  If another
1:2bc809f: 			// checkpoint is in progress, log some things and try again
1:2bc809f: 
1:2bc809f: 			// if we are extremely unlucky, it is possible that we will fail
1:2bc809f: 			// even after 10 tries.  It is better to keep trying than to
1:2bc809f: 			// disable the background checkpoint daemon because this is how the
1:2bc809f: 			// system actually runs in real life.  Do not manufacture a
1:2bc809f: 			// non-existant condition just to make the test pass.
1:2bc809f: 
1:2bc809f: 			for (int i = 10; i < 110 + tries; i++)
1:2bc809f: 			{
1:2bc809f: 				factory.checkpoint();
1:2bc809f: 				testBasic(i);
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException se) {
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			REPORT("\n\tlog switch failed as requested");
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 			return;
1:2bc809f: 		} catch (NullPointerException npe) {
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 			REPORT("\n\tlog switch failed as requested");
1:2bc809f: 			REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		finally { SanityManager.DEBUG_CLEAR(LogToFile.TEST_SWITCH_LOG_FAIL2); }
1:2bc809f: 
1:2bc809f: 		throw T_Fail.testFailMsg("log switch should have failed but did not even after " + tries + " tries");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void checkRecovery() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		// check for numTest=1, 2, 3
1:2bc809f: 		
1:2bc809f: 		for(int numTest=1; numTest <= 3; numTest++)
1:2bc809f: 		{
1:2bc809f: 			int numtrans = (int)find(key(numTest, 1));
1:2bc809f: 			int numpages = (int)find(key(numTest, 2));
1:2bc809f: 
1:2bc809f: 			if (numtrans < 5 || numpages < 1)
1:2bc809f: 			{
1:2bc809f: 				REPORT("full log test " + numTest + " not run");
1:2bc809f: 				continue;
1:2bc809f: 			}
1:2bc809f: 			else
1:2bc809f: 			{
1:2bc809f: 				REPORT("Test recovery of test " + numTest);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 			long[] cid = new long[numtrans];
1:2bc809f: 			ContainerHandle[] c = new ContainerHandle[numtrans];
1:2bc809f: 
1:2bc809f: 			long[][] pagenum = new long[numtrans][numpages];
1:2bc809f: 			Page[][] page = new Page[numtrans][numpages];
1:2bc809f: 
1:2bc809f: 			int i,j;
1:2bc809f: 
1:2bc809f: 			for	(i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 
1:2bc809f: 				cid[i] = find(key(numTest, i+10));
1:2bc809f: 				c[i] = t_util.t_openContainer(t, 0, cid[i], true);
1:2bc809f: 			
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					pagenum[i][j] = find(key(numTest, (i+1)*1000+j));
1:2bc809f: 					page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// transactions were left in the following state
1:2bc809f: 			// t0 - incomplete (rolled back)
1:2bc809f: 			// t1 - abort
1:2bc809f: 			// t2 - commit
1:2bc809f: 			// t3 - incomplete (rolled back)
1:2bc809f: 			// t4 - commit
1:2bc809f: 			// any other transactions - incomplete
1:2bc809f: 			//
1:2bc809f: 			// all the rolled back transaction should have a deleted REC_001
1:2bc809f: 			// all the committed transactions should have a REC_006
1:2bc809f: 			//
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 										  REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 										  REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 										  REC_006, false, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 										  REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 										  REC_006, false, true);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				String str = "container " + i + ":" + cid[i] + " pages: ";
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					str += pagenum[i][j] + " ";
1:2bc809f: 				REPORT("\t" + str);
1:2bc809f: 			}
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f:     
1:2bc809f:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object findService( final String factoryInterface, final String serviceName )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.findService( factoryInterface, serviceName );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  boolean startPersistentService( final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Boolean>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Boolean run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.startPersistentService( serviceName, properties );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:56c1dc2:                  ).booleanValue();
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:a0dbbd7:     }
1:2bc809f: 
1:2bc809f: }
1:2bc809f: 
1:2bc809f: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 				factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
/////////////////////////////////////////////////////////////////////////
1: 				if (!startPersistentService(testService, startParams))
1: 				factory = (RawStoreFactory) findService(getModuleToTestProtocolName(), testService);
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                  {
1:                      return ContextService.getFactory();
1:                  }
1:              }
1:              );
1:     }
1: 
1: 
1:     /**
1:      * Privileged service lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object findService( final String factoryInterface, final String serviceName )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.findService( factoryInterface, serviceName );
1:                  }
1:              }
1:              );
1:     }
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  boolean startPersistentService( final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Boolean>()
1:                      public Boolean run()
1:                          throws StandardException
1:                          return Monitor.startPersistentService( serviceName, properties );
1:                  ).booleanValue();
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 			contextService = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
0:                  );
1:         }
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
1: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 				page[i][j].updateAtSlot(slot, row2.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 			for (j = 0; j < numpages; j++) {
1: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 				page[i][j].updateAtSlot(slot, row3.getRow(), null);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			for (j = 0; j < numpages; j++) {
1: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 				page[i][j].updateAtSlot(slot, row4.getRow(), null);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			for (j = 0; j < numpages; j++) {
1: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 				page[i][j].updateAtSlot(slot, row5.getRow(), null);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			for (j = 0; j < numpages; j++) {
1: 				int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 				page[i][j].updateAtSlot(slot, row6.getRow(), null);
1: 			}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverFullLog
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derbyTesting.unitTests.harness.UnitTest;
1: 
1: import org.apache.derby.impl.store.raw.log.*;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.daemon.DaemonService;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.EngineType;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.raw.*;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import java.io.IOException;
1: import java.io.RandomAccessFile;
1: import java.io.File;
1: import java.util.Properties;
1: 
1: 
1: /**
1: 	A implementation unit test for log full condition
1: 
1:     To run, create a derby.properties file in a new directory with the
1: 	contents
1: 
1: 	derby.module.test.recoverFullLog=org.apache.derbyTesting.unitTests.store.T_RecoverFullLog
1: 
1:     Execute in order
1: 
1: 	java -DTestFillLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 
1: 	java -DTestLogSwitchFail=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 
1: 	java -DTestFullRecoveryFail=true org.apache.derbyTesting.unitTests.harness.UnitTestMain 
1: 		(run this serveral times, this simulate recovery running out of log)
1: 
1: 	java -DTestFullRecover=true org.apache.derbyTesting.unitTests.harness.UnitTestMain 
1: 
1: */
1: 
1: public class T_RecoverFullLog extends T_Generic {
1: 
1: 	private static final String testService = "FullLogTest";
1: 
1: 	static final String REC_001 = "McLaren";
1: 	static final String REC_002 = "Ferrari";
1: 	static final String REC_003 = "Benetton";
1: 	static final String REC_004 = "Prost";
1: 	static final String REC_005 = "Tyrell";
1: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1: 	static final String REC_UNDO = "Lotus";
1: 	static final String SP1 = "savepoint1";
1: 	static final String SP2 = "savepoint2";
1: 
1: 	private RandomAccessFile infofile = null;
1: 	private static final String infoPath = "extinout/T_RecoverFullLog.info";
1: 
1: 	private boolean fillLog;	// test to full up the log
1: 	private boolean recoveryFail; // recovery fill up the log
1: 	private boolean logSwitchFail;	// log filled up during log switch
1: 	private boolean recover;	// successfully recover
1: 
1: 	private String TEST_FILL_LOG = "TestFillLog";	// test to full up the log
1: 	private String TEST_FULL_RECOVER_FAIL = "TestFullRecoveryFail"; // recovery fill up the log
1: 	private String TEST_LOG_SWITCH_FAIL = "TestLogSwitchFail"; // log filled up during log switch
1: 	private String TEST_FULL_RECOVER = "TestFullRecover";	// successfully recover
1: 
1: 	private static final String TEST_FULL_LOG_INFO = "TestFullLogInfo";
1: 
1: 	RawStoreFactory	factory;
1: 	LockFactory  lf;
1: 	ContextService contextService;
1: 	T_Util t_util;
1: 
1: 	public T_RecoverFullLog() {
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** Methods required by T_Generic
1: 	*/
1: 
1: 	public String getModuleToTestProtocolName() {
1: 		return RawStoreFactory.MODULE;
1: 	}
1: 
1: 	/**
1: 	*/
1: 	private void getConfig()
1: 	{
1: 		String param;
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_FILL_LOG);
1: 		fillLog = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_FULL_RECOVER_FAIL);
1: 		recoveryFail = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_FULL_RECOVER);
1: 		recover = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_LOG_SWITCH_FAIL);
1: 		logSwitchFail = Boolean.valueOf(param).booleanValue();
1: 	}
1: 
1: 	/**
1: 	    See T_Recovery for the general testing frame work
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 	 */
1: 	public void runTests() throws T_Fail {
1: 
1: 		getConfig();
1: 		int tests = 0;
1: 		if (fillLog) tests++;
1: 		if (recoveryFail) tests++;
1: 		if (recover) tests++;
1: 		if (logSwitchFail) tests++;
1: 
1: 		if (tests != 1)
1: 			throw T_Fail.testFailMsg("One & only one of the full log recovery test should be run, now " + tests + " set");
1: 
1: 		if (!SanityManager.DEBUG)
1: 		{
1: 			REPORT("recoverBadLog cannot be run on an insane server");
1: 			return;
1: 		}
1: 
1: 		try {
1: 
0: 			contextService = ContextService.getFactory();
1: 
1: 			File ifile = new File(infoPath);
1: 			
1: 			//if external input output files dir does not exist ,create one
1: 			File ifdir = new File("extinout");
1: 			if(!ifdir.exists())
1: 				ifdir.mkdirs();
1: 			// see if we are testing encryption
1: 			startParams = T_Util.setEncryptionParam(startParams);
1: 
1: 			if (fillLog)				// the first test cleans up and start from fresh
1: 			{
1: 				// remove the service directory to ensure a clean run
1: 				REPORT("_______________________________________________________");
1: 				REPORT("\n\t\tcleaning up database for recovering from filled log");
1: 				REPORT("_______________________________________________________");
1: 
1: 				// don't automatic boot this service if it gets left around
1: 				if (startParams == null) 
1: 					startParams = new Properties();
1: 				
1: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1: 				// remove the service directory to ensure a clean run
1: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
0: 				factory = (RawStoreFactory) Monitor.createPersistentService(getModuleToTestProtocolName(),
1: 																  testService,
1: 																  startParams);
1: 				// create a database with nothing
1: 
1: 				// if exist, delete the info file
1: 				if (ifile.exists())
1: 					ifile.delete();
1: 
1: 
1: 				// create a new info file
1: 				try
1: 				{
1: 					infofile = new RandomAccessFile(ifile, "rw");
1: 				}
1: 				catch (IOException ioe)
1: 				{
1: 					System.out.println("Cannot write to temporary file " +
1: 									   infoPath + 
1: 									   ".  Please make sure it is correct, if not, please set the property " +
1: 									   "TestFullLogInfo=<where temp files should go>");
1: 
1: 					throw T_Fail.exceptionFail(ioe);
1: 				}
1: 
1: 					
1: 			}
1: 			else
1: 			{
1: 				// see if we can recover the database
1: 				REPORT("_______________________________________________________");
1: 				if (recoveryFail)
1: 					REPORT("\n\t\trecovering database - recovery will fill up log");
1: 				else
1: 					REPORT("\n\t\trecovering database - recovery should succeed");
1: 				REPORT("_______________________________________________________");
1: 
1: 				try
1: 				{
1: 					// make sure it does exist
1: 					infofile = new RandomAccessFile(ifile, "rw");
1: 				}
1: 				catch (IOException ioe)
1: 				{
1: 					throw T_Fail.exceptionFail(ioe);
1: 				}
1: 
1: 				// let recovery log 10 records then run out of space
1: 				if (recoveryFail)
1: 				{
1: 					SanityManager.DEBUG_SET(LogToFile.TEST_LOG_FULL);
0: 					System.getProperties().put(LogToFile.TEST_RECORD_TO_FILL_LOG, "10");
1: 				}
1: 
0: 				if (!Monitor.startPersistentService(testService, startParams))
1: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
0: 				factory = (RawStoreFactory) Monitor.findService(getModuleToTestProtocolName(), testService);
1: 
1: 				if (recoveryFail)
1: 				{
1: 					throw T_Fail.testFailMsg("recovery should have failed but did not - did you run the test in order?");
1: 				}
1: 			}
1: 		} catch (StandardException mse) {
1: 
1: 			if (recoveryFail) {
1: 						REPORT("_______________________________________________________");
1: 						REPORT("\n\tRecovery failed due to log full as requested ");
1: 						REPORT("\texception was " + mse.toString());
1: 						REPORT("_______________________________________________________");
1: 						return;
1: 
1: 			}
1: 			throw T_Fail.exceptionFail(mse);
1: 		} catch (NullPointerException npe) {
1: 
1: 			if (recoveryFail) {
1: 						REPORT("_______________________________________________________");
1: 						REPORT("\n\tRecovery failed due to log full as requested ");
1: 						REPORT("\texception was " + npe.toString());
1: 						REPORT("_______________________________________________________");
1: 						return;
1: 
1: 			}
1: 			throw T_Fail.exceptionFail(npe);
1: 		}
1: 
1: 
1: 		if (factory == null) {
1: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1: 		}
1: 			
1: 		lf = factory.getLockFactory();
1: 		if (lf == null) {
1: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1: 		}
1: 
1: 		// get a utility helper
1: 		t_util = new T_Util(factory, lf, contextService);
1: 
1: 		try
1: 		{
1: 			if (fillLog)
1: 			{
1: 				testBasic(1);
1: 				fillUpLog();
1: 			}
1: 			else if (logSwitchFail)
1: 			{
1: 				testBasic(2);
1: 				logSwitchFail1();
1: 				testBasic(3);
1: 				logSwitchFail2();
1: 			}
1: 			else if (!recoveryFail)
1: 			{
1: 				checkRecovery();
1: 			}
1: 		} catch (StandardException se) {
1: 
1: 			throw T_Fail.exceptionFail(se);
1: 		}
1: 	}
1: 
1: 	private long find(long inkey)
1: 	{
1: 		if (infofile == null)
1: 			return -1;
1: 
1: 		try 
1: 		{
1: 			infofile.seek(0);
1: 			long key;
1: 
1: 			while(true)
1: 			{
1: 				key = infofile.readLong();
1: 				if (key == inkey)
1: 				{
1: 					long value = infofile.readLong();
1: 					// System.out.println("found " + key + " " + value);
1: 					return value;
1: 				}
1: 				infofile.readLong();
1: 			}
1: 		} 
1: 		catch (IOException ioe)
1: 		{
1: 			// System.out.println("key not found " + inkey);
1: 			return -1;
1: 		}
1: 
1: 	}
1: 
1: 	private long key(int test, int param)
1: 	{
1: 		long i = test;
1: 		return ((i << 32) + param);
1: 	}
1: 
1: 	private void register(long key, long value)
1: 		 throws T_Fail
1: 	{
1: 		// System.out.println("registering " + key + " " + value);
1: 		try 
1: 		{
1: 			// go to the end
1: 			infofile.seek(infofile.length());
1: 			infofile.writeLong(key);
1: 			infofile.writeLong(value);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			T_Fail.exceptionFail(ioe);
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	 * A basic routine to write a bunch of stuff to the log
1: 	 * There will be some committed transactions, some uncommitted transactions,
1: 	 * serveral checkpoints.
1: 	 */
1: 	protected void testBasic(int testNumber) throws T_Fail, StandardException
1: 	{
1: 		int numtrans = 7;
1: 		int numpages = 7;
1: 		int i,j;
1: 
1: 		// this is basically T_Recovery S203 
1: 		T_TWC[] t = new T_TWC[numtrans];
1: 		for (i = 0; i < numtrans; i++)
1: 			t[i] =  t_util.t_startTransactionWithContext();
1: 
1: 		long[] cid = new long[numtrans];
1: 		ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			cid[i] = t_util.t_addContainer(t[i], 0);
1: 			t_util.t_commit(t[i]);
1: 			c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
1: 		}
1: 
1: 		Page page[][] = new Page[numtrans][numpages];
1: 		long pagenum[][] = new long[numtrans][numpages];
1: 
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				page[i][j] = t_util.t_addPage(c[i]);
1: 				pagenum[i][j] = page[i][j].getPageNumber();
1: 				t[i].resetContext();
1: 			}
1: 		}
1: 
1: 		// set up numtrans (at least 5) transactions, each with one
1: 		// container and numpages pages.  Do the following test:
1: 		//
1: 		// 1) insert 1 row onto each page
1: 		// set savepoint SP1 on first transaction (t0)
1: 		//
1: 		// 2) update every rows
1: 		// set savepoint SP1 on all other transactions
1: 		//
1: 		// 3) update every rows
1: 		// set savepoint SP2 on all transactions
1: 		// 
1: 		// 4) update every rows
1: 		//
1: 		// 5) rollback t0 to SP1
1: 		//
1: 		// check that only page[0][x] have been rolled back
1: 		// past SP2
1: 		//
1: 		// 6) update every row
1: 		// 7) rollback SP2 on all transaction except the first
1: 		// 
1: 		// 8) update every rows
1: 		// 9) rollback t0 to SP1
1: 		//
1: 		// 10) leave transactions in the following state
1: 		// t0 - incomplete
1: 		// t1 - abort
1: 		// t2 - commit
1: 		// t3 - incomplete
1: 		// t4 - commit
1: 		// any other transactions - incomplete
1: 
1: 
1: 		//////////////////////// step 1 ////////////////////////
1: 		RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
1: 		T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1: 		for (i = 0; i < numtrans; i++)
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				rh[i][j] = t_util.t_insert(page[i][j], row1); 
1: 				t[i].resetContext();
1: 			}
1: 
1: 		t[0].setSavePoint(SP1, null);	// sp1
1: 
1: 		//////////////////////// step 2 ////////////////////////
1: 		T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1: 		for (i = 0; i < numtrans; i++)
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t[i].switchTransactionContext();
0: 				page[i][j].update(rh[i][j], row2.getRow(), (FormatableBitSet) null);
1: 				t[i].resetContext();
1: 			}
1: 
1: 		for (i = 1; i < numtrans; i++) // sp1
1: 		{
1: 			t[i].setSavePoint(SP1, null);
1: 		}
1: 
1: 		//////////////////////// step 3 ////////////////////////
1: 		T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1: 		for (i = 0; i < numtrans; i++)
1: 			for (j = 0; j < numpages; j++)
0: 				page[i][j].update(rh[i][j], row3.getRow(), (FormatableBitSet) null);
1: 
1: 		for (i = 0; i < numtrans; i++)
1: 			t[i].setSavePoint(SP2, null);	// sp2
1: 
1: 		//////////////////////// step 4 ////////////////////////
1: 		T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 
1: 			for (j = 0; j < numpages; j++)
0: 				page[i][j].update(rh[i][j], row4.getRow(), (FormatableBitSet) null);
1: 			t[i].resetContext();
1: 		}
1: 
1: 
1: 		//////////////////////// step 5 ////////////////////////
1: 		// unlatch relavante pages
1: 		t[0].switchTransactionContext();
1: 
1: 		for (j = 0; j < numpages; j++)
1: 			page[0][j].unlatch();
1: 
1: 		t[0].rollbackToSavePoint(SP1, null); // step 5
1: 
1: 
1: 		// relatch relavante pages
1: 		for (j = 0; j < numpages; j++)
1: 			page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
1: 		t[0].resetContext();
1: 
1: 		//////////////////////// check ////////////////////////
1: 		for (i = 1; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
1: 			t[i].resetContext();
1: 		}
1: 
1: 		t[0].switchTransactionContext();
1: 		for (j = 0; j < numpages; j++)
1: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1: 
1: 		t[0].resetContext();
1: 			//////////////////////// step 6 ////////////////////////
1: 		T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
0: 				page[i][j].update(rh[i][j], row5.getRow(), (FormatableBitSet) null);
1: 			t[i].resetContext();
1: 		}
1: 
1: 		//////////////////////// step 7 ////////////////////////
1: 		for (i = 1; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 
1: 			for (j = 0; j < numpages; j++)
1: 				page[i][j].unlatch();
1: 
1: 			t[i].rollbackToSavePoint(SP2, null);
1: 
1: 			for (j = 0; j < numpages; j++)
1: 				page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
1: 			t[i].resetContext();
1: 		}
1: 
1: 		//////////////////////// check ////////////////////////
1: 		for (i = 1; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
1: 			t[i].resetContext();
1: 		}
1: 
1: 		t[0].switchTransactionContext();
1: 		for (j = 0; j < numpages; j++)
1: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
1: 
1: 		t[0].resetContext();
1: 
1: 
1: 		//////////////////////// step 8 ////////////////////////
1: 		T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
0: 				page[i][j].update(rh[i][j], row6.getRow(), (FormatableBitSet) null); // step 8
1: 			t[i].resetContext();
1: 		}
1: 
1: 		//////////////////////// step 9 ////////////////////////
1: 		// unlatch relavante pages
1: 		t[0].switchTransactionContext();
1: 		for (j = 0; j < numpages; j++)
1: 			page[0][j].unlatch();
1: 
1: 
1: 		t[0].rollbackToSavePoint(SP1, null); 
1: 
1: 		// relatch relevant pages
1: 		for (j = 0; j < numpages; j++)
1: 			page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
1: 		t[0].resetContext();
1: 		//////////////////////// check ////////////////////////
1: 		for (i = 1; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
1: 				t_util.t_checkRecordCount(page[i][j], 1, 1);
1: 			}
1: 			t[i].resetContext();
1: 		}
1: 
1: 		t[0].switchTransactionContext();
1: 		for (j = 0; j < numpages; j++)
1: 		{
1: 			t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1: 			t_util.t_checkRecordCount(page[0][j], 1, 1);
1: 		}
1: 		t[0].resetContext();
1: 
1: 		//////////////////////// step 10 ////////////////////////
1: 		// unlatch all pages
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			t[i].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				page[i][j].unlatch();
1: 			t[i].resetContext();
1: 		}
1: 
1: 		// t[0] incomplete
1: 		t_util.t_abort(t[1]);
1: 		t_util.t_commit(t[2]);
1: 		// t[3] incomplete
1: 		t_util.t_commit(t[4]);
1: 
1: 			// reopen containers 1, 2, and 4, where were closed when the
1: 			// transaction terminated.
1: 		c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
1: 		c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
1: 		c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
1: 
1: 		//////////////////////// check ////////////////////////
1: 		for (j = 0; j < numpages; j++)	
1: 		{
1: 			t[0].switchTransactionContext();
1: 			t_util.t_checkFetch(c[0], rh[0][j], REC_001);
1: 			t[0].resetContext();
1: 
1: 			// t[1] has been aborted
1: 			// rh[1][j] (REC_001) is deleted
1: 			t[1].switchTransactionContext();
1: 			page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
1: 			t_util.t_checkRecordCount(page[1][j], 1, 0);
1: 			t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1: 									  REC_001, true, false);
1: 			page[1][j].unlatch();
1: 			t[1].resetContext();
1: 
1: 			t[2].switchTransactionContext();
1: 			t_util.t_checkFetch(c[2], rh[2][j], REC_006);
1: 			t[2].resetContext();
1: 
1: 			t[3].switchTransactionContext();
1: 			t_util.t_checkFetch(c[3], rh[3][j], REC_006);
1: 			t[3].resetContext();
1: 
1: 			t[4].switchTransactionContext();
1: 			t_util.t_checkFetch(c[4], rh[4][j], REC_006);
1: 			t[4].resetContext();
1: 		}
1: 
1: 
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			register(key(testNumber, i+10), cid[i]);
1: 
1: 			String str = "container " + i + ":" + find(key(testNumber,i+10)) + " pages: ";
1: 
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				str += pagenum[i][j] + " ";
1: 				register(key(testNumber, (i+1)*1000+j), pagenum[i][j]);
1: 			}
1: 			REPORT("\t" + str);
1: 		}
1: 
1: 		register(key(testNumber,1), numtrans); 
1: 		register(key(testNumber,2), numpages);
1: 
1: 		// let recovery try to roll back transactions t0, t3 
1: 	}
1: 
1: 	// fill up the log immediately
1: 	protected void fillUpLog() throws T_Fail, StandardException
1: 	{
1: 		SanityManager.DEBUG_SET(LogToFile.TEST_LOG_FULL);
0: 		System.getProperties().put(LogToFile.TEST_RECORD_TO_FILL_LOG, "1");
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			REPORT("_______________________________________________________");
1: 			REPORT("\n\tlog filled up as requested");
1: 			REPORT("_______________________________________________________");
1: 			return;
1: 		}
1: 		catch (NullPointerException npe)
1: 		{
1: 			// likely to be a null pointer exception being thrown because the
1: 			// system is forcibly shutdown due to corruption
1: 			REPORT("_______________________________________________________");
1: 			REPORT("\n\tlog filled up as requested");
1: 			REPORT("_______________________________________________________");
1: 			return;
1: 		}
1: 
1: 		throw T_Fail.testFailMsg("log should have filled but did not");
1: 	}
1: 
1: 	protected void logSwitchFail1() throws T_Fail, StandardException
1: 	{
1: 		SanityManager.DEBUG_SET(LogToFile.TEST_SWITCH_LOG_FAIL1);
1: 
1: 		factory.checkpoint(); // this should succeed, switch log is
1: 								   // optional before the end marker is written
1: 
1: 		SanityManager.DEBUG_CLEAR(LogToFile.TEST_SWITCH_LOG_FAIL1);
1: 	}
1: 	
1: 	protected void logSwitchFail2() throws T_Fail, StandardException
1: 	{
1: 		SanityManager.DEBUG_SET(LogToFile.TEST_SWITCH_LOG_FAIL2);
1: 
1: 		int tries = 10;
1: 		try
1: 		{
1: 			// checkpoint should fail if it is attempted, after end marker is
1: 			// written, any error is fatal.  If another
1: 			// checkpoint is in progress, log some things and try again
1: 
1: 			// if we are extremely unlucky, it is possible that we will fail
1: 			// even after 10 tries.  It is better to keep trying than to
1: 			// disable the background checkpoint daemon because this is how the
1: 			// system actually runs in real life.  Do not manufacture a
1: 			// non-existant condition just to make the test pass.
1: 
1: 			for (int i = 10; i < 110 + tries; i++)
1: 			{
1: 				factory.checkpoint();
1: 				testBasic(i);
1: 			}
1: 		}
1: 		catch (StandardException se) {
1: 			REPORT("_______________________________________________________");
1: 			REPORT("\n\tlog switch failed as requested");
1: 			REPORT("_______________________________________________________");
1: 
1: 			return;
1: 		} catch (NullPointerException npe) {
1: 			REPORT("_______________________________________________________");
1: 			REPORT("\n\tlog switch failed as requested");
1: 			REPORT("_______________________________________________________");
1: 
1: 			return;
1: 		}
1: 		finally { SanityManager.DEBUG_CLEAR(LogToFile.TEST_SWITCH_LOG_FAIL2); }
1: 
1: 		throw T_Fail.testFailMsg("log switch should have failed but did not even after " + tries + " tries");
1: 	}
1: 
1: 	protected void checkRecovery() throws T_Fail, StandardException
1: 	{
1: 		// check for numTest=1, 2, 3
1: 		
1: 		for(int numTest=1; numTest <= 3; numTest++)
1: 		{
1: 			int numtrans = (int)find(key(numTest, 1));
1: 			int numpages = (int)find(key(numTest, 2));
1: 
1: 			if (numtrans < 5 || numpages < 1)
1: 			{
1: 				REPORT("full log test " + numTest + " not run");
1: 				continue;
1: 			}
1: 			else
1: 			{
1: 				REPORT("Test recovery of test " + numTest);
1: 			}
1: 
1: 			Transaction t = t_util.t_startTransaction();
1: 
1: 			long[] cid = new long[numtrans];
1: 			ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
1: 			long[][] pagenum = new long[numtrans][numpages];
1: 			Page[][] page = new Page[numtrans][numpages];
1: 
1: 			int i,j;
1: 
1: 			for	(i = 0; i < numtrans; i++)
1: 			{
1: 
1: 				cid[i] = find(key(numTest, i+10));
1: 				c[i] = t_util.t_openContainer(t, 0, cid[i], true);
1: 			
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					pagenum[i][j] = find(key(numTest, (i+1)*1000+j));
1: 					page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
1: 				}
1: 			}
1: 
1: 			// transactions were left in the following state
1: 			// t0 - incomplete (rolled back)
1: 			// t1 - abort
1: 			// t2 - commit
1: 			// t3 - incomplete (rolled back)
1: 			// t4 - commit
1: 			// any other transactions - incomplete
1: 			//
1: 			// all the rolled back transaction should have a deleted REC_001
1: 			// all the committed transactions should have a REC_006
1: 			//
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
1: 										  REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1: 										  REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
1: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
1: 										  REC_006, false, true);
1: 
1: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
1: 										  REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
1: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
1: 										  REC_006, false, true);
1: 			}
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				String str = "container " + i + ":" + cid[i] + " pages: ";
1: 				for (j = 0; j < numpages; j++)
1: 					str += pagenum[i][j] + " ";
1: 				REPORT("\t" + str);
1: 			}
1: 			t_util.t_commit(t);
1: 			t.close();
1: 
1: 		}
1: 	}
1: 
1: 
1: 
1: }
1: 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1093b6d
/////////////////////////////////////////////////////////////////////////
1: 					System.setProperty(LogToFile.TEST_RECORD_TO_FILL_LOG, "10");
/////////////////////////////////////////////////////////////////////////
1: 		System.setProperty(LogToFile.TEST_RECORD_TO_FILL_LOG, "1");
============================================================================