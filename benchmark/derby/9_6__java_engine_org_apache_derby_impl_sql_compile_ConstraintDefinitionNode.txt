1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ConstraintDefinitionNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
14:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:eac0369: import java.util.Properties;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:3bb140c: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.depend.ProviderList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A ConstraintDefintionNode is a class for all nodes that can represent
1:eac0369:  * constraint definitions.
9:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:09bee7d: public class ConstraintDefinitionNode extends TableElementNode
6:eac0369: {
1:eac0369: 	
1:eac0369: 	private TableName constraintName;
1:eac0369: 	protected int constraintType;
1:eac0369: 	protected Properties properties;
1:eac0369: 	ProviderList apl;
1:eac0369: 
1:eac0369: 	UUIDFactory		uuidFactory;
1:eac0369: 
1:eac0369: 	String			backingIndexName;
1:eac0369: 	UUID			backingIndexUUID;
1:eac0369: 	ResultColumnList columnList;
1:eac0369: 	String			 constraintText;
1:eac0369: 	ValueNode		 checkCondition;
1:eac0369: 	private int				 behavior;
1:3bb140c:     private int verifyType;
1:eac0369: 
1:09bee7d:     public final static boolean DEFERRABLE_DEFAULT = false;
1:09bee7d:     public final static boolean INITIALLY_DEFERRED_DEFAULT = false;
1:09bee7d:     public final static boolean ENFORCED_DEFAULT = true;
1:09bee7d: 
1:09bee7d:     /**
1:09bee7d:      * boolean[3]: {deferrable?, initiallyDeferred?, enforced?}
1:09bee7d:      */
1:09bee7d:     private boolean[] characteristics;
1:09bee7d: 
1:3bb140c:     ConstraintDefinitionNode(
1:3bb140c:                     TableName constraintName,
1:3bb140c:                     int constraintType,
1:3bb140c:                     ResultColumnList rcl,
1:3bb140c:                     Properties properties,
1:3bb140c:                     ValueNode checkCondition,
1:3bb140c:                     String constraintText,
1:3bb140c:                     int behavior,
1:3bb140c:                     int verifyType,
1:3bb140c:                     ContextManager cm)
1:eac0369: 	{
1:eac0369: 		/* We need to pass null as name to TableElementNode's constructor 
1:eac0369: 		 * since constraintName may be null.
1:eac0369: 		 */
1:3bb140c:         super(null, cm);
1:3bb140c: 
1:3bb140c:         this.constraintName = constraintName;
1:3bb140c: 
1:eac0369: 		if (this.constraintName != null)
1:eac0369: 		{
1:eac0369: 			this.name = this.constraintName.getTableName();
6:eac0369: 		}
1:3bb140c:         this.constraintType = constraintType;
1:3bb140c:         this.properties = properties;
1:3bb140c:         this.columnList = rcl;
1:3bb140c:         this.checkCondition = checkCondition;
1:3bb140c:         this.constraintText = constraintText;
1:3bb140c:         this.behavior = behavior;
1:3bb140c:         this.verifyType = verifyType;
1:eac0369: 	}
1:09bee7d: 
1:eac0369: 
1:09bee7d:     void setCharacteristics(boolean[] cc) {
1:09bee7d:         characteristics = cc.clone();
1:09bee7d:     }
1:09bee7d: 
1:09bee7d:     boolean[] getCharacteristics() {
1:09bee7d:         if (characteristics == null) {
1:09bee7d:             characteristics = new boolean[]{
1:09bee7d:                 ConstraintDefinitionNode.DEFERRABLE_DEFAULT,
1:09bee7d:                 ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT,
1:09bee7d:                 ConstraintDefinitionNode.ENFORCED_DEFAULT
1:09bee7d:             };
1:09bee7d:         }
1:09bee7d: 
1:09bee7d:         return characteristics.clone();
1:09bee7d:     }
1:09bee7d: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "constraintName: " + 
1:eac0369: 				( ( constraintName != null) ?
1:eac0369: 						constraintName.toString() : "null" ) + "\n" +
1:eac0369: 				"constraintType: " + constraintType + "\n" + 
1:eac0369: 				"properties: " +
1:eac0369: 				((properties != null) ? properties.toString() : "null") + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this constraint definition. 
1:eac0369: 	 *
1:eac0369: 	   @param ddlNode the create or alter table node
1:eac0369: 	 * @param dd the dd
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:9f2ed7d:     void bind(DDLStatementNode ddlNode, DataDictionary dd) throws StandardException
1:eac0369: 	{
1:eac0369: 		// we need to allow drops on constraints with different schemas
1:eac0369: 		// to support removing constraints created pre 5.2.
1:eac0369: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// ensure the schema of the constraint matches the schema of the table
1:eac0369: 		if (constraintName != null) {
1:eac0369: 
1:eac0369: 			String constraintSchema = constraintName.getSchemaName();
1:eac0369: 
1:eac0369: 
1:eac0369: 			if (constraintSchema != null) {
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 				TableName tableName = ddlNode.getObjectName();
1:eac0369: 				String tableSchema = tableName.getSchemaName();
1:eac0369: 				if (tableSchema == null) {
1:eac0369: 					tableSchema = getSchemaDescriptor((String) null).getSchemaName();
1:eac0369: 					tableName.setSchemaName(tableSchema);
1:eac0369: 				}
1:eac0369: 				if (!constraintSchema.equals(tableSchema)) {
1:eac0369: 					throw StandardException.newException(SQLState.LANG_CONSTRAINT_SCHEMA_MISMATCH,
1:eac0369: 												constraintName, tableName);
1:eac0369: 
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			name = getBackingIndexName(dd);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the name of the constraint. If the user didn't provide one, we make one up. This allows Replication
1:eac0369: 	  *	to agree with the core compiler on the names of constraints.
1:eac0369: 	  *
1:eac0369: 	  *	@return	constraint name
1:eac0369: 	  */
1:eac0369: 	String	getConstraintMoniker()
1:eac0369: 	{
1:eac0369: 		return name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:         To support dropping existing constraints that may have mismatched schema names
1:eac0369: 		we need to support ALTER TABLE S1.T DROP CONSTRAINT S2.C.
1:eac0369: 		If a constraint name was specified this returns it, otherwise it returns null.
1:eac0369: 	*/
1:eac0369: 	String getDropSchemaName() {
1:eac0369: 		if (constraintName != null)
1:eac0369: 			return constraintName.getSchemaName();
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Allocates a UUID if one doesn't already exist for the index backing this constraint. This allows Replication
1:eac0369: 	  *	logic to agree with the core compiler on what the UUIDs of indices are.
1:eac0369: 	  *
1:eac0369: 	  *	@return	a UUID for the constraint. allocates one if this is the first time this method is called.
1:eac0369: 	  */
1:eac0369: 	UUID	getBackingIndexUUID()
1:eac0369: 	{
1:eac0369: 		if ( backingIndexUUID == null )
1:eac0369: 		{
1:eac0369: 			backingIndexUUID = getUUIDFactory().createUUID();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return	backingIndexUUID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets a unique name for the backing index for this constraint of the form SQLyymmddhhmmssxxn
1:eac0369: 	  *	  yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second,
1:eac0369: 	  *	  xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value,
1:eac0369: 	  *	  n - number between 0-9
1:eac0369: 	  *
1:eac0369: 	  *	@return	name of backing index
1:eac0369: 	  */
1:eac0369: 	String	getBackingIndexName(DataDictionary dd)
1:eac0369: 	{
1:eac0369: 		if ( backingIndexName == null )
1:eac0369: 			backingIndexName = dd.getSystemSQLName();
1:eac0369: 
1:eac0369: 		return	backingIndexName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the auxiliary provider list.
1:eac0369: 	 *
1:eac0369: 	 * @param apl	The new auxiliary provider list.
1:eac0369: 	 */
1:eac0369: 	void setAuxiliaryProviderList(ProviderList apl)
1:eac0369: 	{
1:eac0369: 		this.apl = apl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the auxiliary provider list.
1:eac0369: 	 *
1:eac0369: 	 * @return	The auxiliary provider list.
1:eac0369: 	 */
1:3bb140c:     ProviderList getAuxiliaryProviderList()
1:eac0369: 	{
1:eac0369: 		return apl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a primary key constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this is a primary key constraint
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean hasPrimaryKeyConstraint()
1:eac0369: 	{
1:eac0369: 		return constraintType == DataDictionary.PRIMARYKEY_CONSTRAINT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a unique key constraint.
1:eac0369: 	 *
3:eac0369: 	 * @return boolean	Whether or not this is a unique key constraint
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean hasUniqueKeyConstraint()
1:eac0369: 	{
1:eac0369: 		return constraintType == DataDictionary.UNIQUE_CONSTRAINT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
3:eac0369: 	 * Is this a foreign key constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this is a unique key constraint
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean hasForeignKeyConstraint()
1:eac0369: 	{
1:eac0369: 		return constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this element have a check constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this element has a check constraint
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean hasCheckConstraint()
1:eac0369: 	{
1:eac0369: 		return constraintType == DataDictionary.CHECK_CONSTRAINT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this element have a constraint on it.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this element has a constraint on it
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean hasConstraint()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Does this constraint require a backing index for its implementation?
1:eac0369: 	 *
1:09bee7d:      * @return boolean  {@code true} if this constraint requires a backing
1:09bee7d:      *                  index, i.e. if is a foreign key, primary key or
1:09bee7d:      *                  unique key constraint
1:eac0369: 	 */
1:eac0369: 	boolean requiresBackingIndex()
1:eac0369: 	{
1:eac0369: 		switch (constraintType)
1:eac0369: 		{
1:eac0369: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
1:eac0369: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1:eac0369: 			case DataDictionary.UNIQUE_CONSTRAINT:
1:eac0369: 				return true;
1:eac0369: 			default:
1:eac0369: 				return false;
1:eac0369: 		}
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Is this a primary key or unique constraint?
1:eac0369: 	 *
1:09bee7d:      * @return boolean  {@code true} if this is a primary key or
1:09bee7d:      *                  unique key constraint
1:eac0369: 	 */
1:eac0369: 	boolean requiresUniqueIndex()
1:eac0369: 	{
1:eac0369: 		switch (constraintType)
1:eac0369: 		{
1:eac0369: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1:eac0369: 			case DataDictionary.UNIQUE_CONSTRAINT:
1:eac0369: 				return true;
1:eac0369: 			default:
1:eac0369: 				return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the constraint type
1:eac0369: 	 *
1:eac0369: 	 * @return constraintType	The constraint type.
1:eac0369: 	 */
1:eac0369: 	int getConstraintType()
1:eac0369: 	{
1:eac0369: 		return constraintType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the optional properties for the backing index to this constraint.
1:eac0369: 	 *
1:eac0369: 	 * @param properties	The optional Properties for this constraint.
1:eac0369: 	 */
1:3bb140c:     void setProperties(Properties properties)
1:eac0369: 	{
1:eac0369: 		this.properties = properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Get the optional properties for the backing index to this constraint.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return The optional properties for the backing index to this constraint
1:eac0369: 	 */
1:3bb140c:     Properties getProperties()
1:eac0369: 	{
1:eac0369: 		return properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Is this constraint referenced.
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:3bb140c:     boolean isReferenced()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Get the count of enabled fks
1:eac0369: 	 * that reference this constraint
1:eac0369: 	 *
1:eac0369: 	 * @return the number
1:eac0369: 	 */
1:3bb140c:     int getReferenceCount()
1:eac0369: 	{
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 	/** 
1:eac0369: 	 * Is this constraint enabled.
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:3bb140c:     boolean isEnabled()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the column list from this node.
1:eac0369: 	 *
1:eac0369: 	 * @return ResultColumnList The column list from this table constraint.
1:eac0369: 	 */
1:3bb140c:     ResultColumnList getColumnList()
1:eac0369: 	{
1:eac0369: 		return columnList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the column list for this node.  This is useful for check constraints
1:eac0369: 	 * where the list of referenced columns is built at bind time.
1:eac0369: 	 *
1:eac0369: 	 * @param columnList	The new columnList.
1:eac0369: 	 */
1:3bb140c:     void setColumnList(ResultColumnList columnList)
1:eac0369: 	{
1:eac0369: 		this.columnList = columnList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the check condition from this table constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return The check condition from this node.
1:eac0369: 	 */
1:3bb140c:     ValueNode getCheckCondition()
1:eac0369: 	{
1:eac0369: 		return checkCondition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the check condition for this table constraint.
1:eac0369: 	 *
1:eac0369: 	 * @param checkCondition	The check condition
1:eac0369: 	 */
1:3bb140c:     void setCheckCondition(ValueNode checkCondition)
1:eac0369: 	{
1:eac0369: 		this.checkCondition = checkCondition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the text of the constraint. (Only meaningful for check constraints.)
1:eac0369: 	 *
1:eac0369: 	 * @return The constraint text.
1:eac0369: 	 */
1:3bb140c:     String getConstraintText()
1:eac0369: 	{
1:eac0369: 		return constraintText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Return the behavior of this constraint.
1:09bee7d:      * See {@link org.apache.derby.iapi.sql.StatementType#DROP_CASCADE} etc.
1:eac0369: 	 *
1:eac0369: 	 * @return the behavior
1:eac0369: 	 */
1:eac0369: 	int getDropBehavior()
1:eac0369: 	{
1:eac0369: 		return behavior;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @return the expected type of the constraint, DataDictionary.DROP_CONSTRAINT if the constraint is
1:eac0369:      *         to be dropped without checking its type.
1:eac0369:      */
1:eac0369:     int getVerifyType()
1:eac0369:     {
1:eac0369:         return verifyType;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	MINIONS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	  *	Get the UUID factory
1:eac0369: 	  *
1:eac0369: 	  *	@return	the UUID factory
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	private	UUIDFactory	getUUIDFactory()
1:eac0369: 	{
1:eac0369: 		if ( uuidFactory == null )
1:eac0369: 		{
1:56c1dc2: 			uuidFactory = getMonitor().getUUIDFactory();
1:eac0369: 		}
1:eac0369: 		return	uuidFactory;
1:eac0369: 	}
1:69f8afa: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (constraintName != null) {
1:69f8afa:             constraintName = (TableName) constraintName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:9d9f6dd: 
1:9d9f6dd:     /**
1:9d9f6dd:      * Qualify all SQL object names in a CHECK constraint with schema name.
1:9d9f6dd:      * @throws StandardException if an error occurs
1:9d9f6dd:      */
1:9d9f6dd:     void qualifyNames() throws StandardException {
1:9d9f6dd:         // Get all references to SQL object names in the CHECK constraint,
1:9d9f6dd:         // ordered as they appear in the constraint definition.
1:9d9f6dd:         OffsetOrderVisitor<TableName> visitor =
1:9d9f6dd:                 new OffsetOrderVisitor<TableName>(TableName.class,
1:9d9f6dd:                         checkCondition.getBeginOffset(),
1:9d9f6dd:                         checkCondition.getEndOffset() + 1);
1:9d9f6dd:         checkCondition.accept(visitor);
1:9d9f6dd: 
1:9d9f6dd:         StringBuilder sb = new StringBuilder();
1:9d9f6dd:         int pos = 0;
1:9d9f6dd:         int offset = checkCondition.getBeginOffset();
1:9d9f6dd: 
1:9d9f6dd:         // Replace all names with fully qualified names.
1:9d9f6dd:         for (TableName tableName : visitor.getNodes()) {
1:9d9f6dd:             sb.append(constraintText, pos, tableName.getBeginOffset() - offset);
1:9d9f6dd:             sb.append(tableName.getFullSQLName());
1:9d9f6dd:             pos = tableName.getEndOffset() + 1 - offset;
1:9d9f6dd:         }
1:9d9f6dd: 
1:9d9f6dd:         sb.append(constraintText, pos, constraintText.length());
1:9d9f6dd: 
1:9d9f6dd:         constraintText = sb.toString();
1:9d9f6dd:     }
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 			uuidFactory = getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d9f6dd
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Qualify all SQL object names in a CHECK constraint with schema name.
1:      * @throws StandardException if an error occurs
1:      */
1:     void qualifyNames() throws StandardException {
1:         // Get all references to SQL object names in the CHECK constraint,
1:         // ordered as they appear in the constraint definition.
1:         OffsetOrderVisitor<TableName> visitor =
1:                 new OffsetOrderVisitor<TableName>(TableName.class,
1:                         checkCondition.getBeginOffset(),
1:                         checkCondition.getEndOffset() + 1);
1:         checkCondition.accept(visitor);
1: 
1:         StringBuilder sb = new StringBuilder();
1:         int pos = 0;
1:         int offset = checkCondition.getBeginOffset();
1: 
1:         // Replace all names with fully qualified names.
1:         for (TableName tableName : visitor.getNodes()) {
1:             sb.append(constraintText, pos, tableName.getBeginOffset() - offset);
1:             sb.append(tableName.getFullSQLName());
1:             pos = tableName.getEndOffset() + 1 - offset;
1:         }
1: 
1:         sb.append(constraintText, pos, constraintText.length());
1: 
1:         constraintText = sb.toString();
1:     }
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (constraintName != null) {
1:             constraintName = (TableName) constraintName.accept(v);
1:         }
1:     }
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     void bind(DDLStatementNode ddlNode, DataDictionary dd) throws StandardException
commit:28f9484
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1: public class ConstraintDefinitionNode extends TableElementNode
/////////////////////////////////////////////////////////////////////////
1:     public final static boolean DEFERRABLE_DEFAULT = false;
1:     public final static boolean INITIALLY_DEFERRED_DEFAULT = false;
1:     public final static boolean ENFORCED_DEFAULT = true;
1: 
1:     /**
1:      * boolean[3]: {deferrable?, initiallyDeferred?, enforced?}
1:      */
1:     private boolean[] characteristics;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     void setCharacteristics(boolean[] cc) {
1:         characteristics = cc.clone();
1:     }
1: 
1:     boolean[] getCharacteristics() {
1:         if (characteristics == null) {
1:             characteristics = new boolean[]{
1:                 ConstraintDefinitionNode.DEFERRABLE_DEFAULT,
1:                 ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT,
1:                 ConstraintDefinitionNode.ENFORCED_DEFAULT
1:             };
1:         }
1: 
1:         return characteristics.clone();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         To support dropping existing constraints that may have mismatched schema names
/////////////////////////////////////////////////////////////////////////
1:      * Does this constraint require a backing index for its implementation?
1:      * @return boolean  {@code true} if this constraint requires a backing
1:      *                  index, i.e. if is a foreign key, primary key or
1:      *                  unique key constraint
/////////////////////////////////////////////////////////////////////////
1:      * Is this a primary key or unique constraint?
1:      * @return boolean  {@code true} if this is a primary key or
1:      *                  unique key constraint
/////////////////////////////////////////////////////////////////////////
1:      * Return the behavior of this constraint.
1:      * See {@link org.apache.derby.iapi.sql.StatementType#DROP_CASCADE} etc.
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
0: class ConstraintDefinitionNode extends TableElementNode
/////////////////////////////////////////////////////////////////////////
1:     private int verifyType;
1:     ConstraintDefinitionNode(
1:                     TableName constraintName,
1:                     int constraintType,
1:                     ResultColumnList rcl,
1:                     Properties properties,
1:                     ValueNode checkCondition,
1:                     String constraintText,
1:                     int behavior,
1:                     int verifyType,
1:                     ContextManager cm)
1:         super(null, cm);
0:         setNodeType(C_NodeTypes.CONSTRAINT_DEFINITION_NODE);
1: 
1:         this.constraintName = constraintName;
1: 
1:         this.constraintType = constraintType;
1:         this.properties = properties;
1:         this.columnList = rcl;
1:         this.checkCondition = checkCondition;
1:         this.constraintText = constraintText;
1:         this.behavior = behavior;
1:         this.verifyType = verifyType;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     ProviderList getAuxiliaryProviderList()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setProperties(Properties properties)
/////////////////////////////////////////////////////////////////////////
1:     Properties getProperties()
/////////////////////////////////////////////////////////////////////////
1:     boolean isReferenced()
/////////////////////////////////////////////////////////////////////////
1:     int getReferenceCount()
/////////////////////////////////////////////////////////////////////////
1:     boolean isEnabled()
/////////////////////////////////////////////////////////////////////////
1:     ResultColumnList getColumnList()
/////////////////////////////////////////////////////////////////////////
1:     void setColumnList(ResultColumnList columnList)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getCheckCondition()
/////////////////////////////////////////////////////////////////////////
1:     void setCheckCondition(ValueNode checkCondition)
/////////////////////////////////////////////////////////////////////////
1:     String getConstraintText()
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ConstraintDefinitionNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.StatementType;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.reference.SQLState;
1: import java.util.Properties;
1: 
1: /**
1:  * A ConstraintDefintionNode is a class for all nodes that can represent
1:  * constraint definitions.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class ConstraintDefinitionNode extends TableElementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	
1: 	private TableName constraintName;
1: 	protected int constraintType;
1: 	protected Properties properties;
1: 	ProviderList apl;
1: 
1: 	UUIDFactory		uuidFactory;
1: 
1: 	String			backingIndexName;
1: 	UUID			backingIndexUUID;
0: 	int[]			 checkColumnReferences;
1: 	ResultColumnList columnList;
1: 	String			 constraintText;
1: 	ValueNode		 checkCondition;
1: 	private int				 behavior;
0:     private int verifyType = DataDictionary.DROP_CONSTRAINT; // By default do not check the constraint type
1: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText,
0: 					Object behavior)
1: 	{
0: 		this.constraintName = (TableName) constraintName;
1: 
1: 		/* We need to pass null as name to TableElementNode's constructor 
1: 		 * since constraintName may be null.
1: 		 */
0: 		super.init(null);
1: 		if (this.constraintName != null)
1: 		{
1: 			this.name = this.constraintName.getTableName();
1: 		}
0: 		this.constraintType = ((Integer) constraintType).intValue();
0: 		this.properties = (Properties) properties;
0: 		this.columnList = (ResultColumnList) rcl;
0: 		this.checkCondition = (ValueNode) checkCondition;
0: 		this.constraintText = (String) constraintText;
0: 		this.behavior = ((Integer) behavior).intValue();
1: 	}
1: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText)
1: 	{
0: 		init(
0: 					constraintName,
0: 					constraintType,
0: 					rcl,
0: 					properties, 
0: 					checkCondition,
0: 					constraintText,
0: 					ReuseFactory.getInteger(StatementType.DROP_DEFAULT)
0: 					);
1: 	}
1: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText,
0: 					Object behavior,
0:                     Object verifyType)
1: 	{
0:         init( constraintName, constraintType, rcl, properties, checkCondition, constraintText, behavior);
0:         this.verifyType = ((Integer) verifyType).intValue();
1:     }
1:     
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "constraintName: " + 
1: 				( ( constraintName != null) ?
1: 						constraintName.toString() : "null" ) + "\n" +
1: 				"constraintType: " + constraintType + "\n" + 
1: 				"properties: " +
1: 				((properties != null) ? properties.toString() : "null") + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this constraint definition. 
1: 	 *
1: 	   @param ddlNode the create or alter table node
1: 	 * @param dd the dd
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	protected void bind(DDLStatementNode ddlNode, DataDictionary dd)	throws StandardException
1: 	{
1: 		// we need to allow drops on constraints with different schemas
1: 		// to support removing constraints created pre 5.2.
1: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
1: 			return;
1: 
1: 		// ensure the schema of the constraint matches the schema of the table
1: 		if (constraintName != null) {
1: 
1: 			String constraintSchema = constraintName.getSchemaName();
1: 
1: 
1: 			if (constraintSchema != null) {
1: 
1: 
1: 
1: 				TableName tableName = ddlNode.getObjectName();
1: 				String tableSchema = tableName.getSchemaName();
1: 				if (tableSchema == null) {
1: 					tableSchema = getSchemaDescriptor((String) null).getSchemaName();
1: 					tableName.setSchemaName(tableSchema);
1: 				}
1: 				if (!constraintSchema.equals(tableSchema)) {
1: 					throw StandardException.newException(SQLState.LANG_CONSTRAINT_SCHEMA_MISMATCH,
1: 												constraintName, tableName);
1: 
1: 				}
1: 			}
1: 		}
1: 		else {
1: 			name = getBackingIndexName(dd);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  *	Get the name of the constraint. If the user didn't provide one, we make one up. This allows Replication
1: 	  *	to agree with the core compiler on the names of constraints.
1: 	  *
1: 	  *	@return	constraint name
1: 	  */
1: 	String	getConstraintMoniker()
1: 	{
1: 		return name;
1: 	}
1: 
1: 	/**
0: 		To support dropping exisiting constraints that may have mismatched schema names
1: 		we need to support ALTER TABLE S1.T DROP CONSTRAINT S2.C.
1: 		If a constraint name was specified this returns it, otherwise it returns null.
1: 	*/
1: 	String getDropSchemaName() {
1: 		if (constraintName != null)
1: 			return constraintName.getSchemaName();
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	  *	Allocates a UUID if one doesn't already exist for the index backing this constraint. This allows Replication
1: 	  *	logic to agree with the core compiler on what the UUIDs of indices are.
1: 	  *
1: 	  *	@return	a UUID for the constraint. allocates one if this is the first time this method is called.
1: 	  */
1: 	UUID	getBackingIndexUUID()
1: 	{
1: 		if ( backingIndexUUID == null )
1: 		{
1: 			backingIndexUUID = getUUIDFactory().createUUID();
1: 		}
1: 
1: 		return	backingIndexUUID;
1: 	}
1: 
1: 	/**
1: 	  *	Gets a unique name for the backing index for this constraint of the form SQLyymmddhhmmssxxn
1: 	  *	  yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second,
1: 	  *	  xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value,
1: 	  *	  n - number between 0-9
1: 	  *
1: 	  *	@return	name of backing index
1: 	  */
1: 	String	getBackingIndexName(DataDictionary dd)
1: 	{
1: 		if ( backingIndexName == null )
1: 			backingIndexName = dd.getSystemSQLName();
1: 
1: 		return	backingIndexName;
1: 	}
1: 
1: 	/**
0: 	 * Get the constraint name
1: 	 *
0: 	 * @return constraintName	The constraint name.
1: 	 */
0: 	public TableName getXXRConstraintName()
1: 	{
0: 		return constraintName;
1: 	}
1: 
1: 	/**
1: 	 * Set the auxiliary provider list.
1: 	 *
1: 	 * @param apl	The new auxiliary provider list.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setAuxiliaryProviderList(ProviderList apl)
1: 	{
1: 		this.apl = apl;
1: 	}
1: 
1: 	/**
1: 	 * Return the auxiliary provider list.
1: 	 *
1: 	 * @return	The auxiliary provider list.
1: 	 */
0: 	public ProviderList getAuxiliaryProviderList()
1: 	{
1: 		return apl;
1: 	}
1: 
1: 	/**
1: 	 * Is this a primary key constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this is a primary key constraint
1: 	 */
1: 	boolean hasPrimaryKeyConstraint()
1: 	{
1: 		return constraintType == DataDictionary.PRIMARYKEY_CONSTRAINT;
1: 	}
1: 
1: 	/**
1: 	 * Is this a unique key constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this is a unique key constraint
1: 	 */
1: 	boolean hasUniqueKeyConstraint()
1: 	{
1: 		return constraintType == DataDictionary.UNIQUE_CONSTRAINT;
1: 	}
1: 
1: 	/**
1: 	 * Is this a foreign key constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this is a unique key constraint
1: 	 */
1: 	boolean hasForeignKeyConstraint()
1: 	{
1: 		return constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT;
1: 	}
1: 
1: 	/**
1: 	 * Does this element have a check constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this element has a check constraint
1: 	 */
1: 	boolean hasCheckConstraint()
1: 	{
1: 		return constraintType == DataDictionary.CHECK_CONSTRAINT;
1: 	}
1: 
1: 	/**
1: 	 * Does this element have a constraint on it.
1: 	 *
1: 	 * @return boolean	Whether or not this element has a constraint on it
1: 	 */
1: 	boolean hasConstraint()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Is this a foreign key constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this is a unique key constraint
1: 	 */
1: 	boolean requiresBackingIndex()
1: 	{
1: 		switch (constraintType)
1: 		{
1: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
1: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1: 			case DataDictionary.UNIQUE_CONSTRAINT:
1: 				return true;
1: 			default:
1: 				return false;
1: 		}
1: 	}	
1: 
1: 	/**
1: 	 * Is this a foreign key constraint.
1: 	 *
1: 	 * @return boolean	Whether or not this is a unique key constraint
1: 	 */
1: 	boolean requiresUniqueIndex()
1: 	{
1: 		switch (constraintType)
1: 		{
1: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1: 			case DataDictionary.UNIQUE_CONSTRAINT:
1: 				return true;
1: 			default:
1: 				return false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the constraint type
1: 	 *
1: 	 * @return constraintType	The constraint type.
1: 	 */
1: 	int getConstraintType()
1: 	{
1: 		return constraintType;
1: 	}
1: 
1: 	/**
1: 	 * Set the optional properties for the backing index to this constraint.
1: 	 *
1: 	 * @param properties	The optional Properties for this constraint.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setProperties(Properties properties)
1: 	{
1: 		this.properties = properties;
1: 	}
1: 
1: 	/** 
1: 	 * Get the optional properties for the backing index to this constraint.
1: 	 *
1: 	 *
1: 	 * @return The optional properties for the backing index to this constraint
1: 	 */
0: 	public Properties getProperties()
1: 	{
1: 		return properties;
1: 	}
1: 
1: 
1: 	/** 
1: 	 * Is this constraint referenced.
1: 	 *
1: 	 * @return true/false
1: 	 */
0: 	public boolean isReferenced()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** 
1: 	 * Get the count of enabled fks
1: 	 * that reference this constraint
1: 	 *
1: 	 * @return the number
1: 	 */
0: 	public int getReferenceCount()
1: 	{
1: 		return 0;
1: 	}
1: 	/** 
1: 	 * Is this constraint enabled.
1: 	 *
1: 	 * @return true/false
1: 	 */
0: 	public boolean isEnabled()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Get the column list from this node.
1: 	 *
1: 	 * @return ResultColumnList The column list from this table constraint.
1: 	 */
0: 	public ResultColumnList getColumnList()
1: 	{
1: 		return columnList;
1: 	}
1: 
1: 	/**
1: 	 * Set the column list for this node.  This is useful for check constraints
1: 	 * where the list of referenced columns is built at bind time.
1: 	 *
1: 	 * @param columnList	The new columnList.
1: 	 *
0: 	 * @return	Nothing.
1: 	 */
0: 	public void setColumnList(ResultColumnList columnList)
1: 	{
1: 		this.columnList = columnList;
1: 	}
1: 
1: 	/**
1: 	 * Get the check condition from this table constraint.
1: 	 *
1: 	 * @return The check condition from this node.
1: 	 */
0: 	public ValueNode getCheckCondition()
1: 	{
1: 		return checkCondition;
1: 	}
1: 
1: 	/**
1: 	 * Set the check condition for this table constraint.
1: 	 *
1: 	 * @param checkCondition	The check condition
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setCheckCondition(ValueNode checkCondition)
1: 	{
1: 		this.checkCondition = checkCondition;
1: 	}
1: 
1: 	/**
1: 	 * Get the text of the constraint. (Only meaningful for check constraints.)
1: 	 *
1: 	 * @return The constraint text.
1: 	 */
0: 	public String getConstraintText()
1: 	{
1: 		return constraintText;
1: 	}
1: 
1: 	/**
0: 	 * Get the array of 1-based column references for a check constraint.
1: 	 *
0: 	 * @return	The array of 1-based column references for a check constraint.
1: 	 */
0: 	public int[] getCheckColumnReferences()
1: 	{
0: 		return checkColumnReferences;
1: 	}
1: 
1: 	/**
0: 	 * Set the array of 1-based column references for a check constraint.
1: 	 *
0: 	 * @param checkColumnReferences	The array of 1-based column references
0: 	 *								for the check constraint.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setCheckColumnReferences(int[] checkColumnReferences)
1: 	{
0: 		this.checkColumnReferences = checkColumnReferences;
1: 	}
1: 
1: 	/**
0: 	 * Return the behavior of this constriant (DropStatementNode.xxx)	
1: 	 *
1: 	 * @return the behavior
1: 	 */
1: 	int getDropBehavior()
1: 	{
1: 		return behavior;
1: 	}
1: 
1:     /**
1:      * @return the expected type of the constraint, DataDictionary.DROP_CONSTRAINT if the constraint is
1:      *         to be dropped without checking its type.
1:      */
1:     int getVerifyType()
1:     {
1:         return verifyType;
1:     }
1: 
1: 	///////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	MINIONS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  *	Get the UUID factory
1: 	  *
1: 	  *	@return	the UUID factory
1: 	  *
1: 	  */
1: 	private	UUIDFactory	getUUIDFactory()
1: 	{
1: 		if ( uuidFactory == null )
1: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
1: 		}
1: 		return	uuidFactory;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.StatementType;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.reference.SQLState;
0: import java.util.Properties;
0: 
0: /**
0:  * A ConstraintDefintionNode is a class for all nodes that can represent
0:  * constraint definitions.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class ConstraintDefinitionNode extends TableElementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	
0: 	private TableName constraintName;
0: 	protected int constraintType;
0: 	protected Properties properties;
0: 	ProviderList apl;
0: 
0: 	UUIDFactory		uuidFactory;
0: 
0: 	String			backingIndexName;
0: 	UUID			backingIndexUUID;
0: 	int[]			 checkColumnReferences;
0: 	ResultColumnList columnList;
0: 	String			 constraintText;
0: 	ValueNode		 checkCondition;
0: 	private int				 behavior;
0:     private int verifyType = DataDictionary.DROP_CONSTRAINT; // By default do not check the constraint type
0: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText,
0: 					Object behavior)
0: 	{
0: 		this.constraintName = (TableName) constraintName;
0: 
0: 		/* We need to pass null as name to TableElementNode's constructor 
0: 		 * since constraintName may be null.
0: 		 */
0: 		super.init(null);
0: 		if (this.constraintName != null)
0: 		{
0: 			this.name = this.constraintName.getTableName();
0: 		}
0: 		this.constraintType = ((Integer) constraintType).intValue();
0: 		this.properties = (Properties) properties;
0: 		this.columnList = (ResultColumnList) rcl;
0: 		this.checkCondition = (ValueNode) checkCondition;
0: 		this.constraintText = (String) constraintText;
0: 		this.behavior = ((Integer) behavior).intValue();
0: 	}
0: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText)
0: 	{
0: 		init(
0: 					constraintName,
0: 					constraintType,
0: 					rcl,
0: 					properties, 
0: 					checkCondition,
0: 					constraintText,
0: 					ReuseFactory.getInteger(StatementType.DROP_DEFAULT)
0: 					);
0: 	}
0: 
0: 	public void init(
0: 					Object constraintName,
0: 					Object constraintType,
0: 					Object rcl,
0: 					Object properties,
0: 					Object checkCondition,
0: 					Object constraintText,
0: 					Object behavior,
0:                     Object verifyType)
0: 	{
0:         init( constraintName, constraintType, rcl, properties, checkCondition, constraintText, behavior);
0:         this.verifyType = ((Integer) verifyType).intValue();
0:     }
0:     
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "constraintName: " + 
0: 				( ( constraintName != null) ?
0: 						constraintName.toString() : "null" ) + "\n" +
0: 				"constraintType: " + constraintType + "\n" + 
0: 				"properties: " +
0: 				((properties != null) ? properties.toString() : "null") + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this constraint definition. 
0: 	 *
0: 	   @param ddlNode the create or alter table node
0: 	 * @param dd the dd
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	protected void bind(DDLStatementNode ddlNode, DataDictionary dd)	throws StandardException
0: 	{
0: 		// we need to allow drops on constraints with different schemas
0: 		// to support removing constraints created pre 5.2.
0: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
0: 			return;
0: 
0: 		// ensure the schema of the constraint matches the schema of the table
0: 		if (constraintName != null) {
0: 
0: 			String constraintSchema = constraintName.getSchemaName();
0: 
0: 
0: 			if (constraintSchema != null) {
0: 
0: 
0: 
0: 				TableName tableName = ddlNode.getObjectName();
0: 				String tableSchema = tableName.getSchemaName();
0: 				if (tableSchema == null) {
0: 					tableSchema = getSchemaDescriptor((String) null).getSchemaName();
0: 					tableName.setSchemaName(tableSchema);
0: 				}
0: 				if (!constraintSchema.equals(tableSchema)) {
0: 					throw StandardException.newException(SQLState.LANG_CONSTRAINT_SCHEMA_MISMATCH,
0: 												constraintName, tableName);
0: 
0: 				}
0: 			}
0: 		}
0: 		else {
0: 			name = getBackingIndexName(dd);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	Get the name of the constraint. If the user didn't provide one, we make one up. This allows Replication
0: 	  *	to agree with the core compiler on the names of constraints.
0: 	  *
0: 	  *	@return	constraint name
0: 	  */
0: 	String	getConstraintMoniker()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	/**
0: 		To support dropping exisiting constraints that may have mismatched schema names
0: 		we need to support ALTER TABLE S1.T DROP CONSTRAINT S2.C.
0: 		If a constraint name was specified this returns it, otherwise it returns null.
0: 	*/
0: 	String getDropSchemaName() {
0: 		if (constraintName != null)
0: 			return constraintName.getSchemaName();
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	  *	Allocates a UUID if one doesn't already exist for the index backing this constraint. This allows Replication
0: 	  *	logic to agree with the core compiler on what the UUIDs of indices are.
0: 	  *
0: 	  *	@return	a UUID for the constraint. allocates one if this is the first time this method is called.
0: 	  */
0: 	UUID	getBackingIndexUUID()
0: 	{
0: 		if ( backingIndexUUID == null )
0: 		{
0: 			backingIndexUUID = getUUIDFactory().createUUID();
0: 		}
0: 
0: 		return	backingIndexUUID;
0: 	}
0: 
0: 	/**
0: 	  *	Gets a unique name for the backing index for this constraint of the form SQLyymmddhhmmssxxn
0: 	  *	  yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second,
0: 	  *	  xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value,
0: 	  *	  n - number between 0-9
0: 	  *
0: 	  *	@return	name of backing index
0: 	  */
0: 	String	getBackingIndexName(DataDictionary dd)
0: 	{
0: 		if ( backingIndexName == null )
0: 			backingIndexName = dd.getSystemSQLName();
0: 
0: 		return	backingIndexName;
0: 	}
0: 
0: 	/**
0: 	 * Get the constraint name
0: 	 *
0: 	 * @return constraintName	The constraint name.
0: 	 */
0: 	public TableName getXXRConstraintName()
0: 	{
0: 		return constraintName;
0: 	}
0: 
0: 	/**
0: 	 * Set the auxiliary provider list.
0: 	 *
0: 	 * @param apl	The new auxiliary provider list.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setAuxiliaryProviderList(ProviderList apl)
0: 	{
0: 		this.apl = apl;
0: 	}
0: 
0: 	/**
0: 	 * Return the auxiliary provider list.
0: 	 *
0: 	 * @return	The auxiliary provider list.
0: 	 */
0: 	public ProviderList getAuxiliaryProviderList()
0: 	{
0: 		return apl;
0: 	}
0: 
0: 	/**
0: 	 * Is this a primary key constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this is a primary key constraint
0: 	 */
0: 	boolean hasPrimaryKeyConstraint()
0: 	{
0: 		return constraintType == DataDictionary.PRIMARYKEY_CONSTRAINT;
0: 	}
0: 
0: 	/**
0: 	 * Is this a unique key constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this is a unique key constraint
0: 	 */
0: 	boolean hasUniqueKeyConstraint()
0: 	{
0: 		return constraintType == DataDictionary.UNIQUE_CONSTRAINT;
0: 	}
0: 
0: 	/**
0: 	 * Is this a foreign key constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this is a unique key constraint
0: 	 */
0: 	boolean hasForeignKeyConstraint()
0: 	{
0: 		return constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT;
0: 	}
0: 
0: 	/**
0: 	 * Does this element have a check constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this element has a check constraint
0: 	 */
0: 	boolean hasCheckConstraint()
0: 	{
0: 		return constraintType == DataDictionary.CHECK_CONSTRAINT;
0: 	}
0: 
0: 	/**
0: 	 * Does this element have a constraint on it.
0: 	 *
0: 	 * @return boolean	Whether or not this element has a constraint on it
0: 	 */
0: 	boolean hasConstraint()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Is this a foreign key constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this is a unique key constraint
0: 	 */
0: 	boolean requiresBackingIndex()
0: 	{
0: 		switch (constraintType)
0: 		{
0: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
0: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
0: 			case DataDictionary.UNIQUE_CONSTRAINT:
0: 				return true;
0: 			default:
0: 				return false;
0: 		}
0: 	}	
0: 
0: 	/**
0: 	 * Is this a foreign key constraint.
0: 	 *
0: 	 * @return boolean	Whether or not this is a unique key constraint
0: 	 */
0: 	boolean requiresUniqueIndex()
0: 	{
0: 		switch (constraintType)
0: 		{
0: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
0: 			case DataDictionary.UNIQUE_CONSTRAINT:
0: 				return true;
0: 			default:
0: 				return false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the constraint type
0: 	 *
0: 	 * @return constraintType	The constraint type.
0: 	 */
0: 	int getConstraintType()
0: 	{
0: 		return constraintType;
0: 	}
0: 
0: 	/**
0: 	 * Set the optional properties for the backing index to this constraint.
0: 	 *
0: 	 * @param properties	The optional Properties for this constraint.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setProperties(Properties properties)
0: 	{
0: 		this.properties = properties;
0: 	}
0: 
0: 	/** 
0: 	 * Get the optional properties for the backing index to this constraint.
0: 	 *
0: 	 *
0: 	 * @return The optional properties for the backing index to this constraint
0: 	 */
0: 	public Properties getProperties()
0: 	{
0: 		return properties;
0: 	}
0: 
0: 
0: 	/** 
0: 	 * Is this constraint referenced.
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isReferenced()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** 
0: 	 * Get the count of enabled fks
0: 	 * that reference this constraint
0: 	 *
0: 	 * @return the number
0: 	 */
0: 	public int getReferenceCount()
0: 	{
0: 		return 0;
0: 	}
0: 	/** 
0: 	 * Is this constraint enabled.
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isEnabled()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Get the column list from this node.
0: 	 *
0: 	 * @return ResultColumnList The column list from this table constraint.
0: 	 */
0: 	public ResultColumnList getColumnList()
0: 	{
0: 		return columnList;
0: 	}
0: 
0: 	/**
0: 	 * Set the column list for this node.  This is useful for check constraints
0: 	 * where the list of referenced columns is built at bind time.
0: 	 *
0: 	 * @param columnList	The new columnList.
0: 	 *
0: 	 * @return	Nothing.
0: 	 */
0: 	public void setColumnList(ResultColumnList columnList)
0: 	{
0: 		this.columnList = columnList;
0: 	}
0: 
0: 	/**
0: 	 * Get the check condition from this table constraint.
0: 	 *
0: 	 * @return The check condition from this node.
0: 	 */
0: 	public ValueNode getCheckCondition()
0: 	{
0: 		return checkCondition;
0: 	}
0: 
0: 	/**
0: 	 * Set the check condition for this table constraint.
0: 	 *
0: 	 * @param checkCondition	The check condition
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setCheckCondition(ValueNode checkCondition)
0: 	{
0: 		this.checkCondition = checkCondition;
0: 	}
0: 
0: 	/**
0: 	 * Get the text of the constraint. (Only meaningful for check constraints.)
0: 	 *
0: 	 * @return The constraint text.
0: 	 */
0: 	public String getConstraintText()
0: 	{
0: 		return constraintText;
0: 	}
0: 
0: 	/**
0: 	 * Get the array of 1-based column references for a check constraint.
0: 	 *
0: 	 * @return	The array of 1-based column references for a check constraint.
0: 	 */
0: 	public int[] getCheckColumnReferences()
0: 	{
0: 		return checkColumnReferences;
0: 	}
0: 
0: 	/**
0: 	 * Set the array of 1-based column references for a check constraint.
0: 	 *
0: 	 * @param checkColumnReferences	The array of 1-based column references
0: 	 *								for the check constraint.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setCheckColumnReferences(int[] checkColumnReferences)
0: 	{
0: 		this.checkColumnReferences = checkColumnReferences;
0: 	}
0: 
0: 	/**
0: 	 * Return the behavior of this constriant (DropStatementNode.xxx)	
0: 	 *
0: 	 * @return the behavior
0: 	 */
0: 	int getDropBehavior()
0: 	{
0: 		return behavior;
0: 	}
0: 
0:     /**
0:      * @return the expected type of the constraint, DataDictionary.DROP_CONSTRAINT if the constraint is
0:      *         to be dropped without checking its type.
0:      */
0:     int getVerifyType()
0:     {
0:         return verifyType;
0:     }
0: 
0: 	///////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	MINIONS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	  *	Get the UUID factory
0: 	  *
0: 	  *	@return	the UUID factory
0: 	  *
0: 	  */
0: 	private	UUIDFactory	getUUIDFactory()
0: 	{
0: 		if ( uuidFactory == null )
0: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		}
0: 		return	uuidFactory;
0: 	}
0: }
============================================================================