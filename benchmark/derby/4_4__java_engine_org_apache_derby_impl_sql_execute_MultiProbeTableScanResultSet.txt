1:028077e: /*
5:028077e: 
1:028077e:    Derby - Class org.apache.derby.impl.sql.execute.MultiProbeTableScanResultSet
1:028077e: 
1:028077e:    Licensed to the Apache Software Foundation (ASF) under one or more
1:028077e:    contributor license agreements.  See the NOTICE file distributed with
1:028077e:    this work for additional information regarding copyright ownership.
1:028077e:    The ASF licenses this file to you under the Apache License, Version 2.0
1:028077e:    (the "License"); you may not use this file except in compliance with
1:028077e:    the License.  You may obtain a copy of the License at
1:028077e: 
1:028077e:       http://www.apache.org/licenses/LICENSE-2.0
1:028077e: 
1:028077e:    Unless required by applicable law or agreed to in writing, software
1:028077e:    distributed under the License is distributed on an "AS IS" BASIS,
1:028077e:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:028077e:    See the License for the specific language governing permissions and
1:028077e:    limitations under the License.
1:028077e: 
6:028077e:  */
1:028077e: 
1:028077e: package org.apache.derby.impl.sql.execute;
1:028077e: 
1:028077e: import org.apache.derby.iapi.error.StandardException;
1:028077e: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:028077e: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:028077e: 
1:028077e: import org.apache.derby.iapi.store.access.Qualifier;
1:028077e: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:028077e: 
1:028077e: import org.apache.derby.iapi.sql.Activation;
1:20bd3c0: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:028077e: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:5ce8731: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:028077e: import org.apache.derby.iapi.sql.execute.ExecRow;
1:028077e: 
1:028077e: import org.apache.derby.iapi.types.DataValueDescriptor;
1:028077e: 
1:028077e: // These are for javadoc "@see" tags.
1:028077e: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:028077e: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1:028077e: 
2:028077e: /**
1:028077e:  * Result set that fetches rows from a scan by "probing" the underlying
1:028077e:  * table with a given list of values.  Repeated calls to getNextRowCore()
1:028077e:  * will first return all rows matching probeValues[0], then all rows matching
1:028077e:  * probeValues[1], and so on (duplicate probe values are ignored).  Once all
1:028077e:  * matching rows for all values in probeValues have been returned, the call
1:028077e:  * to getNextRowCore() will return null, thereby ending the scan. The
1:028077e:  * expectation is that this kind of result set only ever appears beneath
1:028077e:  * some other top-level result set (esp. IndexRowToBaseRowResultSet), in
1:028077e:  * which case all result sets higher up in the result set tree will just
1:028077e:  * see a stream of rows satisfying the list of probe values.
6:028077e:  *
1:028077e:  * Currently this type of result is used for evaluation of IN lists, where
1:028077e:  * the user wants to retrieve all rows for which some target column has a
1:028077e:  * value that equals one of values in the IN list.  In that case the IN list
1:028077e:  * values are represented by the probeValues array.
1:028077e:  *
1:028077e:  * Most of the work for this class is inherited from TableScanResultSet. 
1:028077e:  * This class overrides four public methods and two protected methods
1:028077e:  * from TableScanResultSet.  In all cases the methods here set probing
1:028077e:  * state and then call the corresponding methods on "super".
1:028077e:  */
1:028077e: class MultiProbeTableScanResultSet extends TableScanResultSet
1:028077e:     implements CursorResultSet
4:028077e: {
1:5efc1ea:     /** The values with which we will probe the table. */
1:028077e:     protected DataValueDescriptor [] probeValues;
1:a336333:     /**
1:a336333:      * The values with which we will probe the table, as they were passed to
1:a336333:      * the constructor. We need to keep them unchanged in case the result set
1:a336333:      * is reused when a statement is re-executed (see DERBY-827).
1:a336333:      */
1:a336333:     protected DataValueDescriptor [] origProbeValues;
1:028077e: 
1:5efc1ea:     /**
1:5efc1ea:      * 0-based position of the <b>next</b> value to lookup w.r.t. the probe
1:028077e:      * values list.
1:028077e:      */
1:028077e:     protected int probeValIndex;
1:028077e: 
1:5efc1ea:     /**
1:20bd3c0:      * Indicator as to which type of sort we need: ASCENDING, DESCENDING,
1:20bd3c0:      * or NONE (NONE is represented by "RowOrdering.DONTCARE" and is used
1:20bd3c0:      * for cases where all necessary sorting occurred at compilation time).
1:028077e:      */
1:20bd3c0:     private int sortRequired;
1:028077e: 
1:028077e:     /**
1:5ce8731:      * Tells whether or not we should skip the next attempt to (re)open the
1:5ce8731:      * scan controller. If it is {@code true} it means that the previous call
1:5ce8731:      * to {@link #initStartAndStopKey()} did not find a new probe value, which
1:5ce8731:      * means that the probe list is exhausted and we shouldn't perform a scan.
1:5ce8731:      */
1:5ce8731:     private boolean skipNextScan;
1:5ce8731: 
1:5ce8731:     /**
1:028077e:      * Constructor.  Just save off the relevant probing state and pass
1:028077e:      * everything else up to TableScanResultSet.
1:028077e:      * 
1:028077e:      * @see ResultSetFactory#getMultiProbeTableScanResultSet
2:028077e:      * @exception StandardException thrown on failure to open
1:028077e:      */
1:028077e:     MultiProbeTableScanResultSet(long conglomId,
1:028077e:         StaticCompiledOpenConglomInfo scoci, Activation activation, 
1:959fef2:         int resultRowTemplate,
1:028077e:         int resultSetNumber,
1:028077e:         GeneratedMethod startKeyGetter, int startSearchOperator,
1:028077e:         GeneratedMethod stopKeyGetter, int stopSearchOperator,
1:028077e:         boolean sameStartStopPosition,
1:028077e:         Qualifier[][] qualifiers,
1:028077e:         DataValueDescriptor [] probingVals,
1:20bd3c0:         int sortRequired,
1:028077e:         String tableName,
1:028077e:         String userSuppliedOptimizerOverrides,
1:028077e:         String indexName,
1:028077e:         boolean isConstraint,
1:028077e:         boolean forUpdate,
1:028077e:         int colRefItem,
1:028077e:         int indexColItem,
1:028077e:         int lockMode,
1:028077e:         boolean tableLocked,
1:028077e:         int isolationLevel,
1:028077e:         boolean oneRowScan,
1:028077e:         double optimizerEstimatedRowCount,
1:028077e:         double optimizerEstimatedCost)
3:028077e:             throws StandardException
1:028077e:     {
1:028077e:         /* Note: We use '1' as rows per read because we do not currently
1:028077e:          * allow bulk fetching when multi-probing.  If that changes in
1:028077e:          * the future then we will need to update rowsPerRead accordingly.
1:028077e:          */
1:028077e:         super(conglomId,
1:028077e:             scoci,
1:028077e:             activation,
1:959fef2:             resultRowTemplate,
1:028077e:             resultSetNumber,
1:028077e:             startKeyGetter,
1:028077e:             startSearchOperator,
1:028077e:             stopKeyGetter,
1:028077e:             stopSearchOperator,
1:028077e:             sameStartStopPosition,
1:028077e:             qualifiers,
1:028077e:             tableName,
1:028077e:             userSuppliedOptimizerOverrides,
1:028077e:             indexName,
1:028077e:             isConstraint,
1:028077e:             forUpdate,
1:028077e:             colRefItem,
1:028077e:             indexColItem,
1:028077e:             lockMode,
1:028077e:             tableLocked,
1:028077e:             isolationLevel,
1:028077e:             1, // rowsPerRead
1:028077e:             oneRowScan,
1:028077e:             optimizerEstimatedRowCount,
1:028077e:             optimizerEstimatedCost);
1:028077e: 
1:028077e:         if (SanityManager.DEBUG)
1:028077e:         {
1:028077e:             SanityManager.ASSERT(
1:028077e:                 (probingVals != null) && (probingVals.length > 0),
1:028077e:                 "No probe values found for multi-probe scan.");
2:028077e:         }
1:028077e: 
1:a336333:         this.origProbeValues = probingVals;
1:20bd3c0:         this.sortRequired = sortRequired;
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * @see NoPutResultSet#openCore
1:028077e:      */
1:028077e:     public void openCore() throws StandardException
1:028077e:     {
1:028077e:         /* If the probe values are not already sorted then sort them now.  This
1:028077e:          * allows us to skip over duplicate probe values (otherwise we could
1:028077e:          * end up with duplicate rows in the result set).
1:028077e:          *
1:028077e:          * Note: If all of the probe values were provided as constants then we
1:028077e:          * sorted them at compile time (during preprocessing) so we don't have
1:028077e:          * to do it now. But if one or more was specified as a param then we
1:028077e:          * have to do the sort here, at execution time, because this is the
1:028077e:          * only point at which we know what values the parameters have.
1:028077e:          */
1:20bd3c0:         if (sortRequired == RowOrdering.DONTCARE)
1:20bd3c0:         {
1:20bd3c0:             /* DONTCARE really means that the values are already sorted
1:20bd3c0:              * in ascending order, and that's good enough.
1:20bd3c0:              */
1:a336333:             probeValues = origProbeValues;
1:20bd3c0:         }
1:20bd3c0:         else
1:028077e:         {
1:028077e:             /* RESOLVE: For some reason sorting the probeValues array
1:028077e:              * directly leads to incorrect parameter value assignment when
1:028077e:              * executing a prepared statement multiple times.  Need to figure
1:028077e:              * out why (maybe related to DERBY-827?).  In the meantime, if
1:028077e:              * we're going to sort the values we use clones.  This is not
1:028077e:              * ideal, but it works for now.
1:028077e:              */
1:028077e:             DataValueDescriptor [] pVals =
1:a336333:                 new DataValueDescriptor[origProbeValues.length];
1:028077e: 
1:028077e:             for (int i = 0; i < pVals.length; i++)
1:854dd10:                 pVals[i] = origProbeValues[i].cloneValue(false);
1:028077e: 
1:20bd3c0:             if (sortRequired == RowOrdering.ASCENDING)
1:20bd3c0:                 java.util.Arrays.sort(pVals);
1:a336333:             else
1:20bd3c0:             {
1:20bd3c0:                 // Sort the values in DESCENDING order.
1:20bd3c0:                 java.util.Arrays.sort(
1:20bd3c0:                     pVals, java.util.Collections.reverseOrder());
1:20bd3c0:             }
1:20bd3c0: 
1:028077e:             probeValues = pVals;
1:028077e:         }
1:028077e: 
1:028077e:         probeValIndex = 0;
1:028077e:         super.openCore();
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * @see NoPutResultSet#reopenCore
1:028077e:      */
1:028077e:     public void reopenCore() throws StandardException
1:028077e:     {
1:aebcea3:         reopenCore(false);
1:aebcea3:     }
1:aebcea3: 
1:aebcea3:     /**
1:aebcea3:      * There are two scenarios for which we reopen this kind of scan:
1:aebcea3:      *
1:aebcea3:      *   A - The first is for join processing.  In this case we have
1:aebcea3:      * a(nother) row from some outer table and we want to reopen this
1:aebcea3:      * scan to look for rows matching the new outer row.
1:aebcea3:      *
1:aebcea3:      *   B - The second is for multi-probing.  Here we want to reopen
1:aebcea3:      * the scan on this table to look for rows matching the next value
1:aebcea3:      * in the probe list.
1:aebcea3:      *
1:aebcea3:      * If we are reopening the scan for scenario A (join processing)
1:aebcea3:      * then we need to reset our position within the probe list. 
1:aebcea3:      * If we are reopening the scan for scenario B then we do *not*
1:aebcea3:      * want to reset our position within the probe list because that
1:aebcea3:      * position tells us where to find the next probe value.
1:aebcea3:      *
1:aebcea3:      * That said, this method does the work of reopenCore() using
1:aebcea3:      * the received boolean to determine which of the two scenarios
1:aebcea3:      * we are in.  Note that if our current position (i.e. the value
1:aebcea3:      * of probeValIndex) is beyond the length of the probe list then
1:aebcea3:      * we know that we are reopening the scan for scenario A.  Or put
1:aebcea3:      * another away, we should never get here for scenario B if
1:aebcea3:      * probeValIndex is greater than or equal to the length of the
1:aebcea3:      * probe list.  The reason is that the call to reopenCore() for
1:aebcea3:      * scenario B will only ever happen when moreInListVals() returns
1:aebcea3:      * true--and in that case we know that probeValIndex will be less
1:aebcea3:      * than the length of the probeValues.  But the opposite is not
1:aebcea3:      * true: i.e. it is *not* safe to say that a probeValIndex which
1:aebcea3:      * is less than the length of probe list is always for scenario
1:aebcea3:      * B.  That's not true because it's possible that the join to
1:aebcea3:      * which this scan belongs is a "oneRowRightSide" join, meaning
1:aebcea3:      * that this, the "right" side scan, will be "interrupted" after
1:aebcea3:      * we return a single row for the current outer row.  If we then
1:aebcea3:      * come back with a new outer row we need to reset our position--
1:aebcea3:      * even though probeValIndex will be less than probeValues.length
1:aebcea3:      * in that case.  DERBY-3603.
1:aebcea3:      */
1:aebcea3:     private void reopenCore(boolean forNextProbe) throws StandardException
1:aebcea3:     {
1:aebcea3:         if (!forNextProbe)
1:028077e:             probeValIndex = 0;
1:028077e: 
1:028077e:         super.reopenCore();
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * Reopen the scan controller
1:028077e:      *
1:028077e:      * @exception StandardException thrown on failure to open
1:028077e:      */
1:028077e:     protected void reopenScanController() throws StandardException
1:028077e:     {
1:5ce8731:         // TableScanResultSet.reopenScanController() will reset rowsThisScan
1:5ce8731:         // because it thinks this is a completely new scan. However, we want
1:5ce8731:         // it to reflect the total number of rows seen in the multi-probe
1:5ce8731:         // scan, so we keep the original value and restore it after reopening
1:5ce8731:         // the controller. Instead, we reset rowsThisScan to 0 each time
1:5ce8731:         // initStartAndStopKey() is called on the first probe value.
1:5ce8731:         long rows = rowsThisScan;
1:5ce8731:         super.reopenScanController();
1:5ce8731:         rowsThisScan = rows;
1:5ce8731:     }
1:5ce8731: 
1:5ce8731:     /**
1:5ce8731:      * Initialize the start key and the stop key used in the scan. Both keys
1:5ce8731:      * will be set to the probe value. If no new probe value was found (the
1:5ce8731:      * probe list was exhausted), the flag skipNextScan will be {@code true}
1:5ce8731:      * when the method returns to prevent a new scan from being reopened with
1:5ce8731:      * a missing or incorrect probe value.
1:5ce8731:      */
1:5ce8731:     void initStartAndStopKey() throws StandardException {
1:5ce8731: 
1:5ce8731:         // Make sure the fields are initialized with a placeholder.
1:5ce8731:         // startPosition and stopPosition will always be non-null in a
1:5ce8731:         // MultiProbeTableScanResultSet, and they will always be initialized
1:5ce8731:         // to the first value in the probe list. They will be changed to
1:5ce8731:         // the actual probe value later in this method.
1:5ce8731:         super.initStartAndStopKey();
1:5ce8731: 
1:028077e:         /* If we're looking for the first value in the probe list, then
1:028077e:          * reset the row scan count.  Otherwise leave it unchanged since
1:028077e:          * we're just continuing an already-opened scan.  Note that we
1:028077e:          * have to do this check *before* we call getNextProbeValue()
1:028077e:          * because that method will increment probeValIndex.
1:028077e:          */
1:028077e:         if (probeValIndex == 0)
1:028077e:             rowsThisScan = 0;
1:028077e: 
1:5ce8731:         DataValueDescriptor[] startPositionRow = startPosition.getRowArray();
1:5ce8731:         DataValueDescriptor[] stopPositionRow = stopPosition.getRowArray();
1:5ce8731: 
1:5ce8731:         DataValueDescriptor probeValue = getNextProbeValue();
1:5ce8731: 
1:5ce8731: 		/* If we have a probe value then we do the "probe" by positioning
1:5ce8731: 		 * the scan at the first row matching the value.  The way to do
1:5ce8731: 		 * that is to use the value as a start key, which is what will
1:5ce8731: 		 * happen if we plug it into first column of "startPositionRow".
1:5ce8731: 		 * So in this case startPositionRow[0] functions as a "place-holder"
1:5ce8731: 		 * for the probe value.  The same goes for stopPositionRow[0].
1:5ce8731: 		 *
1:5ce8731: 		 * Note that it *is* possible for a start/stop key to contain more
1:5ce8731: 		 * than one column (ex. if we're scanning a multi-column index). In
1:5ce8731: 		 * that case we plug probeValue into the first column of the start
1:5ce8731: 		 * and/or stop key and leave the rest of the key as it is.  As an
1:5ce8731: 		 * example, assume we have the following predicates:
1:5ce8731: 		 *
1:5ce8731: 		 *    ... where d in (1, 20000) and b > 200 and b <= 500
1:5ce8731: 		 *
1:5ce8731: 		 * And assume further that we have an index defined on (d, b).
1:5ce8731: 		 * In this case it's possible that we have TWO start predicates
1:5ce8731: 		 * and TWO stop predicates: the IN list will give us "d = probeVal",
1:5ce8731: 		 * which is a start predicate and a stop predicate; then "b > 200"
1:5ce8731: 		 * may give us a second start predicate, while "b <= 500" may give
1:5ce8731: 		 * us a second stop predicate.  So in this situation we want our
1:5ce8731: 		 * start key to be:
1:5ce8731: 		 *
1:5ce8731: 		 *    (probeValue, 200)
1:5ce8731: 		 *
1:5ce8731: 		 * and our stop key to be:
1:5ce8731: 		 *
1:5ce8731: 		 *    (probeValue, 500).
1:5ce8731: 		 *
1:5ce8731: 		 * This will effectively limit the scan so that it only returns
1:5ce8731: 		 * rows whose "D" column equals probeValue and whose "B" column
1:5ce8731: 		 * falls in the range of 200 thru 500.
1:5ce8731: 		 *
1:5ce8731: 		 * Note: Derby currently only allows a single start/stop predicate
1:5ce8731: 		 * per column. See PredicateList.orderUsefulPredicates().
1:5ce8731: 		 */
1:5ce8731:         if (probeValue != null) {
1:5ce8731:             startPositionRow[0] = probeValue;
1:5ce8731:             if (!sameStartStopPosition) {
1:5ce8731:                 stopPositionRow[0] = startPositionRow[0];
1:028077e:             }
1:028077e:         }
1:028077e: 
1:5ce8731:         // If we didn't find a new probe value, the probe list is exhausted,
1:5ce8731:         // and we shouldn't open a new scan. skipScan() will detect this and
1:5ce8731:         // prevent (re)openScanController() from being called.
1:5ce8731:         skipNextScan = (probeValue == null);
1:5ce8731:     }
1:5ce8731: 
1:5ce8731:     /**
1:5ce8731:      * Check if the scan should be skipped. It should be skipped if (1)
1:5ce8731:      * {@link #initStartAndStopKey()} exhausted the probe list, or (2) the scan
1:5ce8731:      * should return no results because of nulls in the start key or stop key.
1:5ce8731:      * See {@link NoPutResultSetImpl#skipScan(ExecIndexRow,ExecIndexRow)} for
1:5ce8731:      * details about (2).
1:5ce8731:      *
1:5ce8731:      * @param startPosition the key on which to start the scan
1:5ce8731:      * @param stopPosition the key on which to stop the scan
1:5ce8731:      * @return {@code true} if scan should be skipped, {@code false} otherwise
1:5ce8731:      */
1:5ce8731:     protected boolean skipScan(
1:5ce8731:             ExecIndexRow startPosition, ExecIndexRow stopPosition)
1:5ce8731: 		throws StandardException
1:5ce8731:     {
1:5ce8731:         return skipNextScan || super.skipScan(startPosition, stopPosition);
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * Return the next row (if any) from the scan (if open).
1:028077e:      *
1:028077e:      * More specifically we do the following:
1:028077e:      *
1:028077e:      *  1 - See if we have a row to read from the current scan position.
1:028077e:      *    If so, return that row (done).
1:028077e:      *
1:028077e:      *  2 - If there are no more rows to read from the current scan
1:028077e:      *    position AND if there are more probe values to look at,
1:028077e:      *    then a) reposition the scan using the next probe value
1:028077e:      *    as the start/stop key and b) go back to step 1.  Otherwise
1:028077e:      *    proceed to step 3.
1:028077e:      *    
1:028077e:      *  3 - Return null (no more rows).
1:028077e:      *
1:028077e:      * Note that step 1 is important for cases where multiple rows in this
1:028077e:      * table match a single probe value.  In such a scenario we have to
1:028077e:      * be sure that we do *not* move on to the next probe value until
1:028077e:      * we have returned all of the rows for the _current_ probe value.
1:028077e:      *
1:028077e:      * @exception StandardException thrown on failure to get next row
1:028077e:      */
1:028077e:     public ExecRow getNextRowCore() throws StandardException
1:028077e:     {
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:028077e:         checkCancellationFlag();
1:028077e: 
1:028077e:         // Step 1.
1:028077e:         ExecRow result = super.getNextRowCore();
1:028077e: 
1:028077e:         // Steps 2, 1, 2, 1, 2, ...
1:028077e:         while ((result == null) && moreInListVals())
1:028077e:         {
1:028077e:             /* Repositioning the scan (if needed) is simply a matter of
1:028077e:              * reopening the core scan again. As part of that method we will
1:028077e:              * figure out what the next probe value should be (and thus
1:028077e:              * where to position the scan).
1:028077e:              */
1:aebcea3:             reopenCore(true);
1:028077e:             result = super.getNextRowCore();
1:028077e:         }
1:028077e: 
1:028077e:         // Step 3: result will be null if there are no more rows.
1:028077e:         return result;
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * @see NoPutResultSet#close
1:028077e:      */
1:028077e:     public void close() throws StandardException
1:028077e:     {
1:028077e:         /* We'll let TableScanResultSet track the time it takes to close up,
1:028077e:          * so no timing here.
1:028077e:          */
1:028077e:         super.close();
1:028077e: 
1:028077e:         /* Note: We can't set probeValues == null here because we may end
1:028077e:          * up reopening this scan again later, in which case we'll need the
1:028077e:          * list of probe values.
1:028077e:          */
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * Figure out whether or not we can (re-)position the scan
1:028077e:      * controller based on the next value in probeValues.  This
1:028077e:      * will return false when we have exhausted the probe list
1:028077e:      * (i.e. when we've gone through all of the values).
1:028077e:      */
1:028077e:     private boolean moreInListVals()
1:028077e:     {
1:028077e:         return (probeValIndex < probeValues.length);
1:028077e:     }
1:028077e: 
1:028077e:     /**
1:028077e:      * Return the next non-duplicate value from the probe list.
1:20bd3c0:      * Assumption is that the list is sorted so that duplicates
1:20bd3c0:      * appear next to each other, and that probeValIndex is the
1:20bd3c0:      * index of the next value. If we've exhausted the probe list
1:20bd3c0:      * then just return null.
1:028077e:      */
1:028077e:     private DataValueDescriptor getNextProbeValue()
1:028077e:     {
1:028077e:         int ctr = probeValIndex;
1:028077e: 
1:028077e:         // Skip over duplicate values.
1:028077e:         while ((ctr > 0) && (ctr < probeValues.length) &&
1:028077e:             probeValues[probeValIndex-1].equals(probeValues[ctr]))
1:028077e:         {
1:028077e:             ctr++;
1:028077e:         }
1:028077e: 
1:028077e:         probeValIndex = ctr;
1:028077e:         if (probeValIndex < probeValues.length)
1:028077e:             return probeValues[probeValIndex++];
1:028077e: 
1:028077e:         return null;
1:028077e:     }
1:028077e: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
commit:aebcea3
/////////////////////////////////////////////////////////////////////////
1:         reopenCore(false);
1:     }
1: 
1:     /**
1:      * There are two scenarios for which we reopen this kind of scan:
1:      *
1:      *   A - The first is for join processing.  In this case we have
1:      * a(nother) row from some outer table and we want to reopen this
1:      * scan to look for rows matching the new outer row.
1:      *
1:      *   B - The second is for multi-probing.  Here we want to reopen
1:      * the scan on this table to look for rows matching the next value
1:      * in the probe list.
1:      *
1:      * If we are reopening the scan for scenario A (join processing)
1:      * then we need to reset our position within the probe list. 
1:      * If we are reopening the scan for scenario B then we do *not*
1:      * want to reset our position within the probe list because that
1:      * position tells us where to find the next probe value.
1:      *
1:      * That said, this method does the work of reopenCore() using
1:      * the received boolean to determine which of the two scenarios
1:      * we are in.  Note that if our current position (i.e. the value
1:      * of probeValIndex) is beyond the length of the probe list then
1:      * we know that we are reopening the scan for scenario A.  Or put
1:      * another away, we should never get here for scenario B if
1:      * probeValIndex is greater than or equal to the length of the
1:      * probe list.  The reason is that the call to reopenCore() for
1:      * scenario B will only ever happen when moreInListVals() returns
1:      * true--and in that case we know that probeValIndex will be less
1:      * than the length of the probeValues.  But the opposite is not
1:      * true: i.e. it is *not* safe to say that a probeValIndex which
1:      * is less than the length of probe list is always for scenario
1:      * B.  That's not true because it's possible that the join to
1:      * which this scan belongs is a "oneRowRightSide" join, meaning
1:      * that this, the "right" side scan, will be "interrupted" after
1:      * we return a single row for the current outer row.  If we then
1:      * come back with a new outer row we need to reset our position--
1:      * even though probeValIndex will be less than probeValues.length
1:      * in that case.  DERBY-3603.
1:      */
1:     private void reopenCore(boolean forNextProbe) throws StandardException
1:     {
1:         if (!forNextProbe)
/////////////////////////////////////////////////////////////////////////
1:             reopenCore(true);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1:         int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1:             resultRowTemplate,
commit:2349a90
/////////////////////////////////////////////////////////////////////////
commit:5ce8731
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
/////////////////////////////////////////////////////////////////////////
1:      * Tells whether or not we should skip the next attempt to (re)open the
1:      * scan controller. If it is {@code true} it means that the previous call
1:      * to {@link #initStartAndStopKey()} did not find a new probe value, which
1:      * means that the probe list is exhausted and we shouldn't perform a scan.
1:      */
1:     private boolean skipNextScan;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // TableScanResultSet.reopenScanController() will reset rowsThisScan
1:         // because it thinks this is a completely new scan. However, we want
1:         // it to reflect the total number of rows seen in the multi-probe
1:         // scan, so we keep the original value and restore it after reopening
1:         // the controller. Instead, we reset rowsThisScan to 0 each time
1:         // initStartAndStopKey() is called on the first probe value.
1:         long rows = rowsThisScan;
1:         super.reopenScanController();
1:         rowsThisScan = rows;
1:     }
1: 
1:     /**
1:      * Initialize the start key and the stop key used in the scan. Both keys
1:      * will be set to the probe value. If no new probe value was found (the
1:      * probe list was exhausted), the flag skipNextScan will be {@code true}
1:      * when the method returns to prevent a new scan from being reopened with
1:      * a missing or incorrect probe value.
1:      */
1:     void initStartAndStopKey() throws StandardException {
1: 
1:         // Make sure the fields are initialized with a placeholder.
1:         // startPosition and stopPosition will always be non-null in a
1:         // MultiProbeTableScanResultSet, and they will always be initialized
1:         // to the first value in the probe list. They will be changed to
1:         // the actual probe value later in this method.
1:         super.initStartAndStopKey();
1: 
/////////////////////////////////////////////////////////////////////////
1:         DataValueDescriptor[] startPositionRow = startPosition.getRowArray();
1:         DataValueDescriptor[] stopPositionRow = stopPosition.getRowArray();
1: 
1:         DataValueDescriptor probeValue = getNextProbeValue();
1: 
1: 		/* If we have a probe value then we do the "probe" by positioning
1: 		 * the scan at the first row matching the value.  The way to do
1: 		 * that is to use the value as a start key, which is what will
1: 		 * happen if we plug it into first column of "startPositionRow".
1: 		 * So in this case startPositionRow[0] functions as a "place-holder"
1: 		 * for the probe value.  The same goes for stopPositionRow[0].
1: 		 *
1: 		 * Note that it *is* possible for a start/stop key to contain more
1: 		 * than one column (ex. if we're scanning a multi-column index). In
1: 		 * that case we plug probeValue into the first column of the start
1: 		 * and/or stop key and leave the rest of the key as it is.  As an
1: 		 * example, assume we have the following predicates:
1: 		 *
1: 		 *    ... where d in (1, 20000) and b > 200 and b <= 500
1: 		 *
1: 		 * And assume further that we have an index defined on (d, b).
1: 		 * In this case it's possible that we have TWO start predicates
1: 		 * and TWO stop predicates: the IN list will give us "d = probeVal",
1: 		 * which is a start predicate and a stop predicate; then "b > 200"
1: 		 * may give us a second start predicate, while "b <= 500" may give
1: 		 * us a second stop predicate.  So in this situation we want our
1: 		 * start key to be:
1: 		 *
1: 		 *    (probeValue, 200)
1: 		 *
1: 		 * and our stop key to be:
1: 		 *
1: 		 *    (probeValue, 500).
1: 		 *
1: 		 * This will effectively limit the scan so that it only returns
1: 		 * rows whose "D" column equals probeValue and whose "B" column
1: 		 * falls in the range of 200 thru 500.
1: 		 *
1: 		 * Note: Derby currently only allows a single start/stop predicate
1: 		 * per column. See PredicateList.orderUsefulPredicates().
1: 		 */
1:         if (probeValue != null) {
1:             startPositionRow[0] = probeValue;
1:             if (!sameStartStopPosition) {
1:                 stopPositionRow[0] = startPositionRow[0];
1:         // If we didn't find a new probe value, the probe list is exhausted,
1:         // and we shouldn't open a new scan. skipScan() will detect this and
1:         // prevent (re)openScanController() from being called.
1:         skipNextScan = (probeValue == null);
1:     }
1: 
1:     /**
1:      * Check if the scan should be skipped. It should be skipped if (1)
1:      * {@link #initStartAndStopKey()} exhausted the probe list, or (2) the scan
1:      * should return no results because of nulls in the start key or stop key.
1:      * See {@link NoPutResultSetImpl#skipScan(ExecIndexRow,ExecIndexRow)} for
1:      * details about (2).
1:      *
1:      * @param startPosition the key on which to start the scan
1:      * @param stopPosition the key on which to stop the scan
1:      * @return {@code true} if scan should be skipped, {@code false} otherwise
1:      */
1:     protected boolean skipScan(
1:             ExecIndexRow startPosition, ExecIndexRow stopPosition)
1: 		throws StandardException
1:     {
1:         return skipNextScan || super.skipScan(startPosition, stopPosition);
commit:5efc1ea
/////////////////////////////////////////////////////////////////////////
1:     /** The values with which we will probe the table. */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * 0-based position of the <b>next</b> value to lookup w.r.t. the probe
1:     /**
0:      * Whether or not we need to sort the values.  If all values were
commit:a336333
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The values with which we will probe the table, as they were passed to
1:      * the constructor. We need to keep them unchanged in case the result set
1:      * is reused when a statement is re-executed (see DERBY-827).
1:      */
1:     protected DataValueDescriptor [] origProbeValues;
0:     /* Whether or not we need to sort the values.  If all values were
0:      * specified as literals (as opposed to parameters) then we did the
0:      * sort at compile time and so we do not need to do it here.
/////////////////////////////////////////////////////////////////////////
1:         this.origProbeValues = probingVals;
/////////////////////////////////////////////////////////////////////////
1:                 new DataValueDescriptor[origProbeValues.length];
0:                 pVals[i] = origProbeValues[i].getClone();
1:         else
1:             probeValues = origProbeValues;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:                 pVals[i] = origProbeValues[i].cloneValue(false);
author:Army
-------------------------------------------------------------------------------
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
/////////////////////////////////////////////////////////////////////////
1:      * Indicator as to which type of sort we need: ASCENDING, DESCENDING,
1:      * or NONE (NONE is represented by "RowOrdering.DONTCARE" and is used
1:      * for cases where all necessary sorting occurred at compilation time).
1:     private int sortRequired;
/////////////////////////////////////////////////////////////////////////
1:         int sortRequired,
/////////////////////////////////////////////////////////////////////////
1:         this.sortRequired = sortRequired;
/////////////////////////////////////////////////////////////////////////
1:         if (sortRequired == RowOrdering.DONTCARE)
1:         {
1:             /* DONTCARE really means that the values are already sorted
1:              * in ascending order, and that's good enough.
1:              */
0:             probeValues = origProbeValues;
1:         }
1:         else
/////////////////////////////////////////////////////////////////////////
1:             if (sortRequired == RowOrdering.ASCENDING)
1:                 java.util.Arrays.sort(pVals);
0:             else
1:             {
1:                 // Sort the values in DESCENDING order.
1:                 java.util.Arrays.sort(
1:                     pVals, java.util.Collections.reverseOrder());
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Assumption is that the list is sorted so that duplicates
1:      * appear next to each other, and that probeValIndex is the
1:      * index of the next value. If we've exhausted the probe list
1:      * then just return null.
commit:9fd3c00
/////////////////////////////////////////////////////////////////////////
commit:028077e
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.MultiProbeTableScanResultSet
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: // These are for javadoc "@see" tags.
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: 
1: /**
1:  * Result set that fetches rows from a scan by "probing" the underlying
1:  * table with a given list of values.  Repeated calls to getNextRowCore()
1:  * will first return all rows matching probeValues[0], then all rows matching
1:  * probeValues[1], and so on (duplicate probe values are ignored).  Once all
1:  * matching rows for all values in probeValues have been returned, the call
1:  * to getNextRowCore() will return null, thereby ending the scan. The
1:  * expectation is that this kind of result set only ever appears beneath
1:  * some other top-level result set (esp. IndexRowToBaseRowResultSet), in
1:  * which case all result sets higher up in the result set tree will just
1:  * see a stream of rows satisfying the list of probe values.
1:  *
1:  * Currently this type of result is used for evaluation of IN lists, where
1:  * the user wants to retrieve all rows for which some target column has a
1:  * value that equals one of values in the IN list.  In that case the IN list
1:  * values are represented by the probeValues array.
1:  *
1:  * Most of the work for this class is inherited from TableScanResultSet. 
1:  * This class overrides four public methods and two protected methods
1:  * from TableScanResultSet.  In all cases the methods here set probing
1:  * state and then call the corresponding methods on "super".
1:  */
1: class MultiProbeTableScanResultSet extends TableScanResultSet
1:     implements CursorResultSet
1: {
0:     /* The values with which we will probe the table. */
1:     protected DataValueDescriptor [] probeValues;
1: 
0:     /* 0-based position of the *next* value to lookup w.r.t. the probe
1:      * values list.
1:      */
1:     protected int probeValIndex;
1: 
0:     /* Whether or not we need to sort the values (sorting should only
0:      * happen once).  If all values were specified as literals (as
0:      * opposed to parameters) then we did the sort at compile time
0:      * and so we do not need to do it here.
1:      */
0:     private boolean needSort;
1: 
1:     /**
1:      * Constructor.  Just save off the relevant probing state and pass
1:      * everything else up to TableScanResultSet.
1:      * 
1:      * @see ResultSetFactory#getMultiProbeTableScanResultSet
1:      * @exception StandardException thrown on failure to open
1:      */
1:     MultiProbeTableScanResultSet(long conglomId,
1:         StaticCompiledOpenConglomInfo scoci, Activation activation, 
0:         GeneratedMethod resultRowAllocator, 
1:         int resultSetNumber,
1:         GeneratedMethod startKeyGetter, int startSearchOperator,
1:         GeneratedMethod stopKeyGetter, int stopSearchOperator,
1:         boolean sameStartStopPosition,
1:         Qualifier[][] qualifiers,
1:         DataValueDescriptor [] probingVals,
0:         boolean probeValsAreSorted,
1:         String tableName,
1:         String userSuppliedOptimizerOverrides,
1:         String indexName,
1:         boolean isConstraint,
1:         boolean forUpdate,
1:         int colRefItem,
1:         int indexColItem,
1:         int lockMode,
1:         boolean tableLocked,
1:         int isolationLevel,
1:         boolean oneRowScan,
1:         double optimizerEstimatedRowCount,
1:         double optimizerEstimatedCost)
1:             throws StandardException
1:     {
1:         /* Note: We use '1' as rows per read because we do not currently
1:          * allow bulk fetching when multi-probing.  If that changes in
1:          * the future then we will need to update rowsPerRead accordingly.
1:          */
1:         super(conglomId,
1:             scoci,
1:             activation,
0:             resultRowAllocator,
1:             resultSetNumber,
1:             startKeyGetter,
1:             startSearchOperator,
1:             stopKeyGetter,
1:             stopSearchOperator,
1:             sameStartStopPosition,
1:             qualifiers,
1:             tableName,
1:             userSuppliedOptimizerOverrides,
1:             indexName,
1:             isConstraint,
1:             forUpdate,
1:             colRefItem,
1:             indexColItem,
1:             lockMode,
1:             tableLocked,
1:             isolationLevel,
1:             1, // rowsPerRead
1:             oneRowScan,
1:             optimizerEstimatedRowCount,
1:             optimizerEstimatedCost);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 (probingVals != null) && (probingVals.length > 0),
1:                 "No probe values found for multi-probe scan.");
1: 
0:             SanityManager.ASSERT(sameStartStopPosition,
0:                 "All multi-probing result sets are expected to have a single" +
0:                 " key that is both the start key AND the stop key, but that" +
0:                 " is not the case.");
1:         }
1: 
0:         this.probeValues = probingVals;
0:         this.needSort = !probeValsAreSorted;
1:     }
1: 
1:     /**
1:      * @see NoPutResultSet#openCore
1:      */
1:     public void openCore() throws StandardException
1:     {
1:         /* If the probe values are not already sorted then sort them now.  This
1:          * allows us to skip over duplicate probe values (otherwise we could
1:          * end up with duplicate rows in the result set).
1:          *
1:          * Note: If all of the probe values were provided as constants then we
1:          * sorted them at compile time (during preprocessing) so we don't have
1:          * to do it now. But if one or more was specified as a param then we
1:          * have to do the sort here, at execution time, because this is the
1:          * only point at which we know what values the parameters have.
1:          */
0:         if (needSort)
1:         {
1:             /* RESOLVE: For some reason sorting the probeValues array
1:              * directly leads to incorrect parameter value assignment when
1:              * executing a prepared statement multiple times.  Need to figure
1:              * out why (maybe related to DERBY-827?).  In the meantime, if
1:              * we're going to sort the values we use clones.  This is not
1:              * ideal, but it works for now.
1:              */
1:             DataValueDescriptor [] pVals =
0:                 new DataValueDescriptor[probeValues.length];
1: 
1:             for (int i = 0; i < pVals.length; i++)
0:                 pVals[i] = probeValues[i].getClone();
1: 
0:             java.util.Arrays.sort(pVals);
1:             probeValues = pVals;
1: 
0:             // Only sort once.
0:             needSort = false;
1:         }
1: 
1:         probeValIndex = 0;
1:         super.openCore();
1:     }
1: 
1:     /**
0:      * Open the scan controller
1:      *
0:      * @param tc transaction controller; will open one if null.
1:      * @exception StandardException thrown on failure to open
1:      */
0:     protected void openScanController(TransactionController tc)
1:         throws StandardException
1:     {
0:         /* If we're opening the scan controller for the first time then
0:          * we want to use the first value in the (now sorted) list as
0:          * the start/stop key.  That's what we pass in here.
1:          */
0:         openScanController(tc, probeValues[0]);
1: 
0:         /* probeValIndex should be the index of the *next* value to
0:          * use.  Since we just positioned ourselves at the 0th probe
0:          * value with the above call, the next value we want is the
0:          * one at index "1".
1:          */
0:         probeValIndex = 1;
1:     }
1: 
1:     /**
1:      * @see NoPutResultSet#reopenCore
1:      */
1:     public void reopenCore() throws StandardException
1:     {
0:         /* There are two scenarios for which we reopen this kind of scan:
1:          *
0:          *   A - The first is for join processing.  In this case we have
0:          * a(nother) row from some outer table and we want to reopen this
0:          * scan to look for rows matching the new outer row.
1:          *
0:          *   B - The second is for multi-probing.  Here we want to reopen
0:          * the scan on this table to look for rows matching the next value
0:          * in the probe list.
1:          *
0:          * If we are reopening the scan for scenario A (join processing)
0:          * then we need to reset our position within the probe list. 
0:          * If we are reopening the scan for scenario B then we do *not*
0:          * want to reset our position within the probe list because that
0:          * position tells us where to find the next probe value.
1:          *
0:          * The way we tell the difference between the two scenarios is
0:          * by looking at our current position in the probe list (i.e. the
0:          * value of probeValIndex): if our current position is beyond the
0:          * length of the probe list then we know that we are reopening the
0:          * scan for scenario A.  Or put another away, we should never get
0:          * here for scenario B if probeValIndex is greater than or equal
0:          * to the length of the probe list.  The reason is that the call
0:          * to reopenCore() for scenario B will only ever happen when
0:          * moreInListVals() returns true--and in that case we know that
0:          * probeValIndex will be less than the length of the probeValues.
1:          */
0:         if (probeValIndex >= probeValues.length)
1:             probeValIndex = 0;
1: 
1:         super.reopenCore();
1:     }
1: 
1:     /**
1:      * Reopen the scan controller
1:      *
1:      * @exception StandardException thrown on failure to open
1:      */
1:     protected void reopenScanController() throws StandardException
1:     {
1:         /* If we're looking for the first value in the probe list, then
1:          * reset the row scan count.  Otherwise leave it unchanged since
1:          * we're just continuing an already-opened scan.  Note that we
1:          * have to do this check *before* we call getNextProbeValue()
1:          * because that method will increment probeValIndex.
1:          */
1:         if (probeValIndex == 0)
1:             rowsThisScan = 0;
1: 
0:         DataValueDescriptor pv = null;
0:         if (moreInListVals())
1:         {
0:             pv = getNextProbeValue();
0:             if (pv == null)
1:             {
0:                 /* We'll get here when we've exhausted the probe list. In
0:                  * that case leave the scan as it is, which effectively
0:                  * means we are done.
1:                  */
0:                 return;
1:             }
1:         }
1: 
0:         reopenScanController(pv);
1:     }
1: 
1:     /**
1:      * Return the next row (if any) from the scan (if open).
1:      *
1:      * More specifically we do the following:
1:      *
1:      *  1 - See if we have a row to read from the current scan position.
1:      *    If so, return that row (done).
1:      *
1:      *  2 - If there are no more rows to read from the current scan
1:      *    position AND if there are more probe values to look at,
1:      *    then a) reposition the scan using the next probe value
1:      *    as the start/stop key and b) go back to step 1.  Otherwise
1:      *    proceed to step 3.
1:      *    
1:      *  3 - Return null (no more rows).
1:      *
1:      * Note that step 1 is important for cases where multiple rows in this
1:      * table match a single probe value.  In such a scenario we have to
1:      * be sure that we do *not* move on to the next probe value until
1:      * we have returned all of the rows for the _current_ probe value.
1:      *
1:      * @exception StandardException thrown on failure to get next row
1:      */
1:     public ExecRow getNextRowCore() throws StandardException
1:     {
1:         checkCancellationFlag();
1: 
1:         // Step 1.
1:         ExecRow result = super.getNextRowCore();
1: 
1:         // Steps 2, 1, 2, 1, 2, ...
1:         while ((result == null) && moreInListVals())
1:         {
1:             /* Repositioning the scan (if needed) is simply a matter of
1:              * reopening the core scan again. As part of that method we will
1:              * figure out what the next probe value should be (and thus
1:              * where to position the scan).
1:              */
0:             reopenCore();
1:             result = super.getNextRowCore();
1:         }
1: 
1:         // Step 3: result will be null if there are no more rows.
1:         return result;
1:     }
1: 
1:     /**
1:      * @see NoPutResultSet#close
1:      */
1:     public void close() throws StandardException
1:     {
1:         /* We'll let TableScanResultSet track the time it takes to close up,
1:          * so no timing here.
1:          */
1:         super.close();
1: 
1:         /* Note: We can't set probeValues == null here because we may end
1:          * up reopening this scan again later, in which case we'll need the
1:          * list of probe values.
1:          */
1:     }
1: 
1:     /**
1:      * Figure out whether or not we can (re-)position the scan
1:      * controller based on the next value in probeValues.  This
1:      * will return false when we have exhausted the probe list
1:      * (i.e. when we've gone through all of the values).
1:      */
1:     private boolean moreInListVals()
1:     {
1:         return (probeValIndex < probeValues.length);
1:     }
1: 
1:     /**
1:      * Return the next non-duplicate value from the probe list.
0:      * Assumption is that the list is sorted in ascending order
0:      * and that probeValIndex is the index of the next value.
0:      * If we've exhausted the probe list then just return null.
1:      */
1:     private DataValueDescriptor getNextProbeValue()
1:         throws StandardException
1:     {
1:         int ctr = probeValIndex;
1: 
1:         // Skip over duplicate values.
1:         while ((ctr > 0) && (ctr < probeValues.length) &&
1:             probeValues[probeValIndex-1].equals(probeValues[ctr]))
1:         {
1:             ctr++;
1:         }
1: 
1:         probeValIndex = ctr;
1:         if (probeValIndex < probeValues.length)
1:             return probeValues[probeValIndex++];
1: 
1:         return null;
1:     }
1: }
============================================================================