1:966d2c3: /*
1:966d2c3:  
1:04f8e95:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest
1:04f8e95:  
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:04f8e95:  
1:966d2c3:       http://www.apache.org/licenses/LICENSE-2.0
1:966d2c3:  
1:966d2c3:    Unless required by applicable law or agreed to in writing, software
1:966d2c3:    distributed under the License is distributed on an "AS IS" BASIS,
1:966d2c3:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:966d2c3:    See the License for the specific language governing permissions and
1:966d2c3:    limitations under the License.
1:966d2c3:  
1:966d2c3:  */
1:966d2c3: 
1:966d2c3: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:966d2c3: 
1:9c14132: import java.io.IOException;
1:9c14132: import java.io.Reader;
1:04f8e95: import java.math.BigDecimal;
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.DatabaseMetaData;
1:1ae02c9: import java.sql.Date;
1:1ae02c9: import java.sql.NClob;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLDataException;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLFeatureNotSupportedException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import java.sql.Time;
1:1ae02c9: import java.sql.Timestamp;
1:1ae02c9: import java.sql.Types;
1:1ae02c9: import junit.framework.Test;
1:04f8e95: import org.apache.derby.iapi.types.HarmonySerialBlob;
1:04f8e95: import org.apache.derby.iapi.types.HarmonySerialClob;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:966d2c3: 
1:966d2c3: /**
1:966d2c3:  * Tests of the <code>java.sql.CallableStatement</code> JDBC40 API.
1:966d2c3:  */
1:04f8e95: public class CallableStatementTest  extends Wrapper41Test
1:04f8e95: {
1:966d2c3:     /** Default callable statement used by the tests. */
1:966d2c3:     private CallableStatement cStmt = null;
1:16bb01f: 
1:16bb01f:     private static  boolean _nullOutArgs;
1:966d2c3:     
1:966d2c3:     /**
1:966d2c3:      * Create a test with the given name.
1:966d2c3:      *
1:966d2c3:      * @param name name of the test.
1:966d2c3:      */
1:966d2c3:     public CallableStatementTest(String name) {
1:966d2c3:         super(name);
1:966d2c3:     }
1:9c14132: 
1:3bfb5f0:     /**
1:966d2c3:      * Create a default callable statement and connection.
1:3bfb5f0:      *
1:966d2c3:      * @throws SQLException if creation of connection or callable statement
1:966d2c3:      *                      fail.
1:3bfb5f0:      */
1:13e9e78:     protected void setUp() 
2:966d2c3:         throws SQLException {
1:13e9e78:         cStmt = prepareCall("? = CALL FLOOR(?)");
1:9c14132:         cStmt.registerOutParameter(1, Types.DOUBLE);
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     /**
1:966d2c3:      * Close default callable statement and connection.
1:3bfb5f0:      *
1:966d2c3:      * @throws SQLException if closing of the connection or the callable
1:966d2c3:      *                      statement fail.
1:966d2c3:      */
1:13e9e78:     protected void tearDown()
1:13e9e78:         throws Exception {
1:966d2c3: 
1:966d2c3:         cStmt.close();
1:966d2c3:         cStmt = null;
1:966d2c3: 
1:13e9e78:         super.tearDown();
1:966d2c3:     }
1:966d2c3:    
1:9c14132:     public void testNamedParametersAreNotSupported()
1:9c14132:         throws SQLException {
1:03a99e2:         DatabaseMetaData met = getConnection().getMetaData();
1:9c14132:         assertFalse("Named parameters are not supported, but the metadata " +
1:9c14132:                     "says they are", met.supportsNamedParameters());
1:9c14132:     }
1:9c14132:     
1:9c14132:     public void testGetDoubleIntOnInParameter()
1:9c14132:         throws SQLException {
1:9c14132:         cStmt.setDouble(2, 3.3);
1:9c14132:         cStmt.execute();
1:9c14132:         try {
1:9c14132:             cStmt.getDouble(2);
1:9c14132:             fail("Calling getDouble on an IN parameter should throw " +
1:9c14132:                  "an exception");
1:9c14132:         } catch (SQLException sqle) {
1:9c14132:             // SQLState differ between DerbyNetClient and embedded.
1:9c14132:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:9c14132:             assertSQLState("Unexpected SQLState", sqlState, sqle);
1:9c14132:         }
1:9c14132:     }
1:9c14132:     
1:966d2c3:     public void testGetNClobIntNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getNClob(1);
1:966d2c3:             fail("CallableStatement.getNClob(int) should not be implemented");
2:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
2:966d2c3:             // We are fine, do nothing.
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0:     
1:966d2c3:     public void testGetNClobStringNotImplemented() 
1:966d2c3:         throws SQLException {
1:3bfb5f0:         try {
1:966d2c3:             cStmt.getNClob("some-parameter-name");
1:966d2c3:             fail("CallableStatement.getNClob(String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0: 
1:966d2c3:     public void testGetNStringIntNotImplemented() 
1:966d2c3:         throws SQLException {
1:3bfb5f0:         try {
1:966d2c3:             cStmt.getNString(1);
1:966d2c3:             fail("CallableStatement.getNString(int) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0: 
1:966d2c3:     public void testGetNStringStringNotImplemented() 
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getNString("some-parameter-name");
1:966d2c3:             fail("CallableStatement.getNString(String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0: 
1:3bfb5f0:     
1:9c14132:     public void testGetCharacterStreamIntOnInvalidTypeDOUBLE() 
1:966d2c3:         throws SQLException {
1:9c14132:         cStmt.setDouble(2, 3.3);
1:9c14132:         cStmt.execute();
1:966d2c3:         try {
1:966d2c3:             cStmt.getCharacterStream(1);
1:9c14132:             fail("An exception signalling invalid data type conversion " +
1:9c14132:                  "should have been thrown");
1:9c14132:         } catch (SQLDataException sqlde) {
1:9c14132:             assertSQLState("Exception with invalid SQL state thrown on " +
1:9c14132:                     "invalid data type conversion", "22005", sqlde);
1:966d2c3:         }
1:966d2c3:     }
1:9c14132: 
1:9c14132:     /**
1:9c14132:      * Test which SQLState is thrown when getCharacterStream is called
1:9c14132:      * on an IN parameter of an unsupported type.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntOnInParameterOfInvalidType()
1:9c14132:         throws SQLException {
1:9c14132:         cStmt.setDouble(2, 3.3);
1:9c14132:         cStmt.execute();
1:9c14132:         try {
1:9c14132:             cStmt.getCharacterStream(2);
1:9c14132:             fail("Calling getCharacterStream on an IN parameter should " +
1:9c14132:                  "throw an exception");
1:9c14132:         } catch (SQLException sqle) {
1:9c14132:             // SQLState differ between DerbyNetClient and embedded.
1:9c14132:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:9c14132:             assertSQLState("Exception with invalid SQL state thrown for " +
1:9c14132:                            "getCharacterStream on IN parameter", 
1:9c14132:                            sqlState, sqle);
1:9c14132:         }
1:9c14132:     }
1:9c14132:     
1:9c14132:     /**
1:9c14132:      * Test which SQLState is thrown when getCharacterStream is called
1:9c14132:      * on an IN parameter of a supported type.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntOnInParameterOfValidType()
1:9c14132:         throws SQLException {
1:03a99e2:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getConnection());
1:9c14132:         cStmt.setString(1, "A string");
1:9c14132:         cStmt.execute();
1:9c14132:         try {
1:9c14132:             cStmt.getCharacterStream(1);
1:9c14132:             fail("Calling getCharacterStream on an IN parameter should " +
1:9c14132:                  "throw an exception");
1:9c14132:         } catch (SQLException sqle) {
1:9c14132:             // SQLState differ between DerbyNetClient and embedded.
1:9c14132:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:9c14132:             assertSQLState("Exception with invalid SQL state thrown for " +
1:9c14132:                            "getCharacterStream on IN parameter", 
1:9c14132:                            sqlState, sqle);
1:9c14132:         }
1:9c14132:     }
1:9c14132:     
1:9c14132:     /**
1:9c14132:      * Test basic use of getCharacterStream on character data.
1:9c14132:      * Create a CallableStatement that takes an integer as input and returns
1:9c14132:      * the number as a string. The string is read as a stream, and the integer
1:9c14132:      * is recreated from it and compared to the integer passed in.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntVARCHAR()
1:9c14132:         throws IOException, SQLException {
1:03a99e2:         cStmt = CallableStatementTestSetup.getIntToStringFunction(getConnection());
1:9c14132:         cStmt.setInt(2, 4509);
1:9c14132:         assertFalse("No resultsets should be returned", cStmt.execute());
1:9c14132:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:9c14132:         // Get a character stream
1:9c14132:         Reader cStream = cStmt.getCharacterStream(1);
1:9c14132:         assertFalse("Stream should not be null", cStmt.wasNull());
1:9c14132:         assertNotNull("Stream is null even though wasNull() returned false",
1:9c14132:                 cStream);
1:9c14132:         char[] chars = new char[4];
1:9c14132:         assertEquals("Wrong number of characters read",
1:9c14132:                 4, cStream.read(chars));
1:9c14132:         // Make sure we have reached end of stream.
1:9c14132:         assertEquals("Expected end of stream, but there were more data",
1:9c14132:                 -1, cStream.read());
1:9c14132:         cStream.close();
1:9c14132:         String result = new String(chars);
1:9c14132:         assertEquals("Incorrect result obtained through java.io.Reader",
1:9c14132:                 "4509", result);
1:9c14132:     }
1:9c14132:     
1:9c14132:     /**
1:9c14132:      * Test basic use of getCharacterStream on binary data.
1:9c14132:      * Create a CallableStatement that takes a string as input and returns
1:9c14132:      * a byte representation, which is then read through a stream. The string
1:9c14132:      * is recreated and compared to the one passed in. Note that strings must
1:9c14132:      * be represented in UTF-16BE for this to work.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntVARBINARYDirect()
1:9c14132:         throws IOException, SQLException {
1:9c14132:         String data = "This is the test string.";
1:03a99e2:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getConnection());
1:9c14132:         cStmt.setString(1, data);
1:9c14132:         assertFalse("No resultsets should be returned", cStmt.execute());
1:9c14132:         // Note that getUpdateCount behaves differently on client and embedded.
1:9c14132:         assertEquals("Incorrect updatecount", 
1:9c14132:                      usingEmbedded() ? 0 : -1, 
1:9c14132:                      cStmt.getUpdateCount());
1:9c14132:         Reader cStream = cStmt.getCharacterStream(2);
1:9c14132:         assertFalse("Stream should not be null", cStmt.wasNull());
1:9c14132:         assertNotNull("Stream is null even though wasNull() returned false",
1:9c14132:                 cStream);
1:9c14132:         // Assume we don't know how many bytes the string will be represented 
1:9c14132:         // by, just create enough space and read until stream is exhausted.
1:9c14132:         // To be able to read the string back, getBytes must be called with
1:9c14132:         // UTF-16BE charset, because Derby uses UTF-16BE encoding as default.
1:9c14132:         // JDBC does not specify which charset to use for binary data, and 
1:9c14132:         // UTF-16BE was apparently selected to match JCC.
1:9c14132:         char[] tmpChars = new char[data.length() * 4];
1:9c14132:         int curChar = cStream.read();
1:9c14132:         int index = 0;
1:9c14132:         while (curChar != -1) {
1:9c14132:             tmpChars[index] = (char)curChar;
1:9c14132:             index++;
1:9c14132:             curChar = cStream.read();
1:9c14132:         }
1:9c14132:         cStream.close();
1:9c14132:         char[] chars = new char[index];
1:9c14132:         System.arraycopy(tmpChars, 0, chars, 0, index);
1:9c14132:         String result = new String(chars);
1:9c14132:         assertEquals("Incorrect result obtained through java.io.Reader",
1:9c14132:                 data, result);
1:9c14132:     }
1:9c14132: 
1:9c14132:     /**
1:9c14132:      * Fetch a string stored as bytes from the database through a reader,
1:9c14132:      * then recreate the string.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntVARBINARYFromDb()
1:9c14132:         throws IOException, SQLException {
1:03a99e2:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getConnection());
1:9c14132:         cStmt.setInt(2, CallableStatementTestSetup.STRING_BYTES_ID);
1:9c14132:         assertFalse("No resultsets should be returned", cStmt.execute());
1:9c14132:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:9c14132:         Reader cStream = cStmt.getCharacterStream(1);
1:9c14132:         assertFalse("Stream should not be null", cStmt.wasNull());
1:9c14132:         assertNotNull("Stream is null even though wasNull() returned false",
1:9c14132:                 cStream);
1:9c14132:         char[] tmpChars = new char[32672];
1:9c14132:         int curChar = cStream.read();
1:9c14132:         int index = 0;
1:9c14132:         while (curChar != -1) {
1:9c14132:             tmpChars[index] = (char)curChar;
1:9c14132:             index++;
1:9c14132:             curChar = cStream.read();
1:9c14132:         }
1:9c14132:         char[] chars = new char[index];
1:9c14132:         System.arraycopy(tmpChars, 0, chars, 0, index);
1:9c14132:         tmpChars = null;
1:9c14132:         cStream.close();
1:9c14132:         String result = new String(chars);
1:9c14132:         assertEquals("Strings not equal", 
1:9c14132:                      CallableStatementTestSetup.STRING_BYTES, 
1:9c14132:                      result);
1:9c14132:     }
1:9c14132: 
1:9c14132:     /**
1:9c14132:      * Read a SQL NULL value from a VARBINARY column through a reader.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntOnVARBINARYWithNull()
1:9c14132:         throws SQLException {
1:03a99e2:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getConnection());
1:9c14132:         cStmt.setInt(2, CallableStatementTestSetup.SQL_NULL_ID);
1:9c14132:         assertFalse("No resultsets should be returned", cStmt.execute());
1:9c14132:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:9c14132:         Reader cStream = cStmt.getCharacterStream(1);
1:9c14132:         assertTrue("Stream should be null", cStmt.wasNull());
1:9c14132:         assertNull("Stream is not null even though wasNull() returned true",
1:9c14132:                 cStream);
1:9c14132:     }
1:9c14132:     
1:9c14132:     /**
1:9c14132:      * Read a SQL NULL value from a VARCHAR column through a reader.
1:9c14132:      */
1:9c14132:     public void testGetCharacterStreamIntOnVARCHARWithNull()
1:9c14132:         throws SQLException {
1:03a99e2:         cStmt = CallableStatementTestSetup.getVarcharFromDbFunction(getConnection());
1:9c14132:         cStmt.setInt(2, CallableStatementTestSetup.SQL_NULL_ID);
1:9c14132:         assertFalse("No resultsets should be returned", cStmt.execute());
1:9c14132:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:9c14132:         Reader cStream = cStmt.getCharacterStream(1);
1:9c14132:         assertTrue("Stream should be null", cStmt.wasNull());
1:9c14132:         assertNull("Stream is not null even though wasNull() returned true",
1:9c14132:                 cStream);
1:9c14132:     }
1:3bfb5f0:     
1:966d2c3:     public void testGetCharacterStreamStringNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getCharacterStream("some-parameter-name");
1:966d2c3:             fail("CallableStatement.getCharacterStream(String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testGetNCharacterStreamIntNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getNCharacterStream(1);
1:966d2c3:             fail("CallableStatement.getNCharacterStream(int) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3:     
1:966d2c3:     public void testGetNCharacterStreamStringNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getNCharacterStream("some-parameter-name");
1:966d2c3:             fail("CallableStatement.getNCharacterStream(String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetBlobNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:9e6ceb7:             cStmt.setBlob("some-parameter-name", (Blob)null);
1:966d2c3:             fail("CallableStatement.setBlob(String, Blob) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3:     
1:966d2c3:     public void testSetClobNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:9e6ceb7:             cStmt.setClob("some-parameter-name", (Clob)null);
1:966d2c3:             fail("CallableStatement.setClob(String, Clob) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetNCharacterStreamNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.setNCharacterStream("some-parameter-name", null, 0l);
1:966d2c3:             fail("CallableStatement.setNCharacterStream(String,Reader,long) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetNClobNClobNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:9e6ceb7:             cStmt.setNClob("some-parameter-name", (NClob)null);
1:966d2c3:             fail("CallableStatement.setNClob(String, NClob) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetNClobReaderNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.setNClob("some-parameter-name", null, 0l);
1:966d2c3:             fail("CallableStatement.setNClob(String, Reader, long) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetNStringNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.setNString("some-parameter-name", "some-value");
1:966d2c3:             fail("CallableStatement.setNString(String, String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3:    
1:966d2c3:     public void testGetSQLXMLIntNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getSQLXML(1);
1:966d2c3:             fail("CallableStatement.getSQLXML(int) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3:     
1:966d2c3:     public void testGetSQLXMLStringNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.getSQLXML("some-parameter-name");
1:966d2c3:             fail("CallableStatement.getSQLXML(String) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:966d2c3:     public void testSetSQLXMLNotImplemented()
1:966d2c3:         throws SQLException {
1:966d2c3:         try {
1:966d2c3:             cStmt.setSQLXML("some-parameter-name", null);
1:966d2c3:             fail("CallableStatement.setSQLXML(String, SQLXML) " +
1:966d2c3:                  "should not be implemented");
1:966d2c3:         } catch (SQLFeatureNotSupportedException sfnse) {
1:966d2c3:             // We are fine, do nothing.
1:966d2c3:         }
1:966d2c3:     }
1:966d2c3: 
1:f631317:     /** Helper method for testIsWrapperFor*Statement test cases. */
1:f631317:     private void testIsWrapperForXXXStatement(Class klass) throws SQLException {
1:f631317:         assertTrue("The CallableStatement is not a wrapper for "
1:f631317:                        + klass.getName(),
1:f631317:                    cStmt.isWrapperFor(klass));
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testIsWrapperForStatement() throws SQLException {
1:f631317:         testIsWrapperForXXXStatement(Statement.class);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testIsWrapperForPreparedStatement() throws SQLException {
1:f631317:         testIsWrapperForXXXStatement(PreparedStatement.class);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testIsWrapperForCallableStatement() throws SQLException {
1:f631317:         testIsWrapperForXXXStatement(CallableStatement.class);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testIsNotWrapperForResultSet() throws SQLException {
1:f631317:         assertFalse(cStmt.isWrapperFor(ResultSet.class));
1:966d2c3:     }
1:966d2c3: 
1:2ff02ef:     public void testIsWrapperForSelf() throws SQLException {
1:2ff02ef:         assertTrue(cStmt.isWrapperFor(cStmt.getClass()));
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testUnwrapStatement() throws SQLException {
1:f631317:         Statement stmt = cStmt.unwrap(Statement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", cStmt, stmt);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testUnwrapPreparedStatement() throws SQLException {
1:f631317:         PreparedStatement ps = cStmt.unwrap(PreparedStatement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", cStmt, ps);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testUnwrapCallableStatement() throws SQLException {
1:f631317:         Statement cs = cStmt.unwrap(CallableStatement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", cStmt, cs);
1:966d2c3:     }
1:966d2c3: 
1:2ff02ef:     public void testUnwrapAsSelf() throws SQLException {
1:2ff02ef:         PreparedStatement cs = cStmt.unwrap(cStmt.getClass());
1:2ff02ef:         assertSame("Unwrap returned wrong object.", cStmt, cs);
1:966d2c3:     }
1:966d2c3: 
1:f631317:     public void testUnwrapResultSet() {
1:966d2c3:         try {
1:f631317:             ResultSet rs = cStmt.unwrap(ResultSet.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:2ff02ef:         }
1:2ff02ef:     }
1:966d2c3: 
1:3bfb5f0:     /**
1:3bfb5f0:      *
1:c511410:      * Tests the setCharacterStream method that accepts length as a long
1:c511410:      * parameter in the Callable Statement interface
1:3bfb5f0:      *
1:c511410:      * @throws SQLException Upon any error that occurs while calling this
1:c511410:      *         method
1:966d2c3:      *
1:3bfb5f0:      */
1:1ae02c9: 
1:c511410:     public void testSetCharacterStream() throws SQLException {
1:966d2c3:         try {
1:c511410:             cStmt.setCharacterStream("Some String",null,0L);
1:ff7369c:             fail("CallableStatement.setCharacterStream() " +
1:966d2c3:                  "should not be implemented");
1:f631317:         }
1:c511410:         catch(SQLFeatureNotSupportedException sqlfne) {
1:c511410:             //Do nothing as this is the expected behaviour
1:2ff02ef: 
1:f631317:         }
1:f631317:     }
1:2ff02ef: 
1:966d2c3:     /**
1:966d2c3:      *
1:c511410:      * Tests the setAsciiStream method that accepts length as a long
1:c511410:      * parameter in the Callable Statement interface
5:c511410:      *
1:c511410:      * @throws SQLException Upon any error that occurs while calling this
1:c511410:      *         method
1:c511410:      *
1:966d2c3:      */
1:9b52936: 
1:c511410:     public void testSetAsciiStream() throws SQLException {
1:f631317:         try {
1:c511410:             cStmt.setAsciiStream("Some String",null,0L);
1:ff7369c:             fail("CallableStatement.setAsciiStream() " +
1:ff7369c:                  "should not be implemented");
1:f631317:         }
1:c511410:         catch(SQLFeatureNotSupportedException sqlfne) {
1:c511410:             //Do nothing as this is the expected behaviour
4:f631317: 
1:f631317:         }
1:f631317:     }
1:f631317: 
1:966d2c3:     /**
1:c511410:      *
1:c511410:      * Tests the setBinaryStream method that accepts length as a long
1:c511410:      * parameter in the Callable Statement interface
1:c511410:      *
1:c511410:      * @throws SQLException Upon any error that occurs while calling this
1:c511410:      *         method
1:c511410:      *
3:c511410:      */
1:f631317: 
1:c511410:     public void testSetBinaryStream() throws SQLException {
3:c511410:         try {
1:c511410:             cStmt.setBinaryStream("Some String",null,0L);
1:ff7369c:             fail("CallableStatement.setBinaryStream() " +
1:ff7369c:                  "should not be implemented");
1:f631317:         }
1:c511410:         catch(SQLFeatureNotSupportedException sqlfne) {
1:c511410:             //Do nothing as this is the expected behaviour
1:f631317: 
1:f631317:         }
1:f631317:     }
1:f631317: 
3:c511410:     /**
1:04f8e95:      * Test the JDBC 4.1 extensions.
1:04f8e95:      */
1:04f8e95:     public  void    testJDBC4_1() throws Exception
1:04f8e95:     {
1:04f8e95:         Connection  conn = getConnection();
1:04f8e95:         
1:04f8e95:         vetDataTypeCount( conn );
1:04f8e95: 
1:04f8e95:         PreparedStatement   ps = prepareStatement
1:04f8e95:             (
1:04f8e95:              conn,
1:04f8e95:              "create procedure allTypesProc\n" +
1:04f8e95:              "(\n" +
1:04f8e95:              "    out bigintCol bigint,\n" +
1:04f8e95:              "    out blobCol blob,\n" +
1:04f8e95:              "    out booleanCol boolean,\n" +
1:04f8e95:              "    out charCol char(1),\n" +
1:04f8e95:              "    out charForBitDataCol char(1) for bit data,\n" +
1:04f8e95:              "    out clobCol clob,\n" +
1:04f8e95:              "    out dateCol date,\n" +
1:04f8e95:              "    out doubleCol double,\n" +
1:04f8e95:              "    out floatCol float,\n" +
1:04f8e95:              "    out intCol int,\n" +
1:04f8e95:              "    out longVarcharCol long varchar,\n" +
1:04f8e95:              "    out longVarcharForBitDataCol long varchar for bit data,\n" +
1:04f8e95:              "    out numericCol numeric,\n" +
1:04f8e95:              "    out realCol real,\n" +
1:04f8e95:              "    out smallintCol smallint,\n" +
1:04f8e95:              "    out timeCol time,\n" +
1:04f8e95:              "    out timestampCol timestamp,\n" +
1:04f8e95:              "    out varcharCol varchar( 2 ),\n" +
1:04f8e95:              "    out varcharForBitDataCol varchar( 2 ) for bit data\n" +
1:04f8e95:              ")\n" +
1:04f8e95:              "language java\n" +
1:04f8e95:              "parameter style java\n" +
1:04f8e95:              "no sql\n" +
1:04f8e95:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.allTypesProc'\n"
1:04f8e95:              );
1:04f8e95:         ps.execute();
1:04f8e95:         ps.close();
1:04f8e95: 
1:04f8e95:         CallableStatement cs = prepareCall
1:04f8e95:             (
1:04f8e95:              conn,
1:04f8e95:              "call allTypesProc(  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )"
1:04f8e95:              );
1:04f8e95:         int param = 1;
1:04f8e95:         cs.registerOutParameter( param++, Types.BIGINT );
1:04f8e95:         cs.registerOutParameter( param++, Types.BLOB );
1:04f8e95:         cs.registerOutParameter( param++, Types.BOOLEAN );
1:04f8e95:         cs.registerOutParameter( param++, Types.CHAR );
1:04f8e95:         cs.registerOutParameter( param++, Types.BINARY );
1:04f8e95:         cs.registerOutParameter( param++, Types.CLOB );
1:04f8e95:         cs.registerOutParameter( param++, Types.DATE );
1:04f8e95:         cs.registerOutParameter( param++, Types.DOUBLE );
1:04f8e95:         cs.registerOutParameter( param++, Types.FLOAT );
1:04f8e95:         cs.registerOutParameter( param++, Types.INTEGER );
1:04f8e95:         cs.registerOutParameter( param++, Types.LONGVARCHAR );
1:04f8e95:         cs.registerOutParameter( param++, Types.LONGVARBINARY );
1:04f8e95:         cs.registerOutParameter( param++, Types.NUMERIC );
1:04f8e95:         cs.registerOutParameter( param++, Types.REAL );
1:04f8e95:         cs.registerOutParameter( param++, Types.SMALLINT );
1:04f8e95:         cs.registerOutParameter( param++, Types.TIME );
1:04f8e95:         cs.registerOutParameter( param++, Types.TIMESTAMP );
1:04f8e95:         cs.registerOutParameter( param++, Types.VARCHAR );
1:04f8e95:         cs.registerOutParameter( param++, Types.VARBINARY );
1:16bb01f: 
1:16bb01f:         _nullOutArgs = false;
1:04f8e95:         cs.execute();
1:16bb01f:         examineJDBC4_1extensions( new Wrapper41( cs ), _nullOutArgs );
1:16bb01f:         
1:16bb01f:         _nullOutArgs = true;
1:16bb01f:         cs.execute();
1:16bb01f:         examineJDBC4_1extensions( new Wrapper41( cs ), _nullOutArgs );
1:16bb01f:         
1:04f8e95:         cs.close();
1:04f8e95: 
1:04f8e95:         ps = prepareStatement( conn, "drop procedure allTypesProc" );
1:04f8e95:         ps.execute();
1:04f8e95:         ps.close();
1:04f8e95:     }
1:04f8e95:     private void    vetDataTypeCount( Connection conn ) throws Exception
1:04f8e95:     {
1:04f8e95:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:04f8e95:         int actualTypeCount = 0;
1:04f8e95:         while ( rs.next() ) { actualTypeCount++; }
1:04f8e95:         rs.close();
1:04f8e95: 
1:04f8e95:         //
1:04f8e95:         // If this assertion fails, that means that another data type has been added
1:04f8e95:         // to Derby. You need to add that datatype to the allTypesProc procedure created
1:04f8e95:         // by testJDBC4_1() and you need to add a verification case to examineJDBC4_1extensions().
1:04f8e95:         //
1:04f8e95:         assertEquals( 22, actualTypeCount );
1:04f8e95:     }
1:f1ec775: 
1:f1ec775:     /**
1:f1ec775:      * <p>
1:f1ec775:      * Regression test for https://issues.apache.org/jira/browse/DERBY-4959, an NPE
1:f1ec775:      * trying to return null LOBs as procedure output args.
1:f1ec775:      * </p>
1:f1ec775:      */
1:f1ec775:     public  void    test_4959() throws Exception
1:f1ec775:     {
1:f1ec775:         Connection  conn = getConnection();
1:f1ec775: 
1:f1ec775:         PreparedStatement   ps = prepareStatement
1:f1ec775:             (
1:f1ec775:              conn,
1:f1ec775:              "create procedure blobProc\n" +
1:f1ec775:              "(\n" +
1:f1ec775:              "    out blobCol blob\n" +
1:f1ec775:              ")\n" +
1:f1ec775:              "language java\n" +
1:f1ec775:              "parameter style java\n" +
1:f1ec775:              "no sql\n" +
1:f1ec775:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.blobProc'\n"
1:f1ec775:              );
1:f1ec775:         ps.execute();
1:f1ec775:         ps.close();
1:f1ec775:         ps = prepareStatement
1:f1ec775:             (
1:f1ec775:              conn,
1:f1ec775:              "create procedure clobProc\n" +
1:f1ec775:              "(\n" +
1:f1ec775:              "    out clobCol clob\n" +
1:f1ec775:              ")\n" +
1:f1ec775:              "language java\n" +
1:f1ec775:              "parameter style java\n" +
1:f1ec775:              "no sql\n" +
1:f1ec775:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.clobProc'\n"
1:f1ec775:              );
1:f1ec775:         ps.execute();
1:f1ec775:         ps.close();
1:f1ec775: 
1:f1ec775:         CallableStatement cs = prepareCall
1:f1ec775:             (
1:f1ec775:              conn,
1:f1ec775:              "call blobProc(  ? )"
1:f1ec775:              );
1:f1ec775:         cs.registerOutParameter( 1, Types.BLOB );
1:f1ec775:         cs.execute();
1:f1ec775:         assertNull( cs.getBlob( 1 ) );
1:f1ec775:         cs.close();
1:f1ec775:         
1:f1ec775:         cs = prepareCall
1:f1ec775:             (
1:f1ec775:              conn,
1:f1ec775:              "call clobProc(  ? )"
1:f1ec775:              );
1:f1ec775:         cs.registerOutParameter( 1, Types.CLOB );
1:f1ec775:         cs.execute();
1:f1ec775:         assertNull( cs.getClob( 1 ) );
1:f1ec775:         cs.close();
1:f1ec775: 
1:f1ec775:         ps = prepareStatement( conn, "drop procedure blobProc" );
1:f1ec775:         ps.execute();
1:f1ec775:         ps.close();
1:f1ec775:         ps = prepareStatement( conn, "drop procedure clobProc" );
1:f1ec775:         ps.execute();
1:f1ec775:         ps.close();
1:f1ec775:     }
1:04f8e95:     
1:04f8e95:     /**
1:04f8e95:      * <p>
1:04f8e95:      * Procedure used by jdbc 4.1 tests.
1:04f8e95:      * </p>
1:04f8e95:      */
1:04f8e95:     public  static  void    allTypesProc
1:04f8e95:         (
1:16bb01f:          Long[] bigintarg,
1:04f8e95:          Blob[] blobarg,
1:16bb01f:          Boolean[] booleanarg,
1:04f8e95:          String[] chararg,
1:04f8e95:          byte[][] charforbitdataarg,
1:04f8e95:          Clob[] clobarg,
1:04f8e95:          Date[] datearg,
1:16bb01f:          Double[] doublearg,
1:16bb01f:          Double[] floatarg,
1:16bb01f:          Integer[] intarg,
1:04f8e95:          String[] longvarchararg,
1:04f8e95:          byte[][] longvarcharforbitdataarg,
1:04f8e95:          BigDecimal[] numericarg,
1:16bb01f:          Float[] realarg,
1:16bb01f:          Integer[] smallintarg,
1:04f8e95:          Time[] timearg,
1:04f8e95:          Timestamp[] timestamparg,
1:04f8e95:          String[] varchararg,
1:04f8e95:          byte[][] varcharforbitdataarg
1:04f8e95:          )
1:04f8e95:         throws Exception
1:04f8e95:     {
1:04f8e95:         String  stringValue = "a";
1:04f8e95:         byte    intValue = (byte) 1;
1:04f8e95:         float   floatValue = 1.0F;
1:04f8e95:         String lobValue = "abc";
1:16bb01f: 
1:39b3237:         bigintarg[0] = _nullOutArgs ? null : (long) intValue;
1:16bb01f:         blobarg[0] = _nullOutArgs ? null : new HarmonySerialBlob( BINARY_VALUE );
1:16bb01f:         booleanarg[0] = _nullOutArgs ? null : Boolean.TRUE;
1:16bb01f:         chararg[0] = _nullOutArgs ? null : stringValue;
1:16bb01f:         charforbitdataarg[0] = _nullOutArgs ? null : BINARY_VALUE;
1:16bb01f:         clobarg[0] = _nullOutArgs ? null : new HarmonySerialClob( lobValue );
1:16bb01f:         datearg[0]= _nullOutArgs ? null : new Date( 761990400000L );
1:39b3237:         doublearg[0] = _nullOutArgs ? null : (double) floatValue;
1:39b3237:         floatarg[0] = _nullOutArgs ? null : (double) floatValue;
1:39b3237:         intarg[0] = _nullOutArgs ? null : (int) intValue;
1:16bb01f:         longvarchararg[0] = _nullOutArgs ? null : stringValue;
1:16bb01f:         longvarcharforbitdataarg[0] =  _nullOutArgs ? null : BINARY_VALUE;
1:16bb01f:         numericarg[0] = _nullOutArgs ? null : new BigDecimal( "1.0" );
1:39b3237:         realarg[0] = _nullOutArgs ? null : (float) floatValue;
1:39b3237:         smallintarg[0] = _nullOutArgs ? null : (int) intValue;
1:16bb01f:         timearg[0] = _nullOutArgs ? null : new Time(TIME_VALUE);
1:16bb01f:         timestamparg[0] = _nullOutArgs ? null : new Timestamp(TIMESTAMP_VALUE);
1:16bb01f:         varchararg[0] = _nullOutArgs ? null : stringValue;
1:16bb01f:         varcharforbitdataarg[0] = _nullOutArgs ? null : BINARY_VALUE;
1:04f8e95:     }
1:04f8e95: 
1:f1ec775:     public  static  void    blobProc
1:f1ec775:         (
1:f1ec775:          Blob[] blobarg
1:f1ec775:          )
1:f1ec775:         throws Exception
1:f1ec775:     {
1:f1ec775:         blobarg[0] = null;
1:f1ec775:     }
1:f1ec775: 
1:f1ec775:     public  static  void    clobProc
1:f1ec775:         (
1:f1ec775:          Clob[] clobarg
1:f1ec775:          )
1:f1ec775:         throws Exception
1:f1ec775:     {
1:f1ec775:         clobarg[0] = null;
1:f1ec775:     }
1:f1ec775: 
1:04f8e95:     /**
1:966d2c3:      * Return suite with all tests of the class.
1:966d2c3:      */
1:966d2c3:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("CallableStatementTest suite");
1:04f8e95: 
1:ec5ae26:         suite.addTest(baseSuite("CallableStatementTest:embedded"));
1:ec5ae26:         suite.addTest(TestConfiguration.clientServerDecorator(
1:ec5ae26:             baseSuite("CallableStatementTest:client")));
1:0cfef0d:         suite.addTest(TestConfiguration.clientServerDecorator(
1:0cfef0d:                                 TestConfiguration.connectionCPDecorator( baseSuite
1:0cfef0d:                                         ("CallableStatementTest:logical"))));
1:ec5ae26:         return suite;
1:966d2c3:     }
1:966d2c3: 
1:ec5ae26:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(CallableStatementTest.class, name);
1:1ae02c9: 
1:9c14132:         return new CallableStatementTestSetup(suite);
1:ec5ae26:     }
1:ec5ae26:     
1:966d2c3: } // End class CallableStatementTest
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         bigintarg[0] = _nullOutArgs ? null : (long) intValue;
1:         doublearg[0] = _nullOutArgs ? null : (double) floatValue;
1:         floatarg[0] = _nullOutArgs ? null : (double) floatValue;
1:         intarg[0] = _nullOutArgs ? null : (int) intValue;
1:         realarg[0] = _nullOutArgs ? null : (float) floatValue;
1:         smallintarg[0] = _nullOutArgs ? null : (int) intValue;
commit:16bb01f
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static  boolean _nullOutArgs;
/////////////////////////////////////////////////////////////////////////
1: 
1:         _nullOutArgs = false;
1:         examineJDBC4_1extensions( new Wrapper41( cs ), _nullOutArgs );
1:         
1:         _nullOutArgs = true;
1:         cs.execute();
1:         examineJDBC4_1extensions( new Wrapper41( cs ), _nullOutArgs );
1:         
/////////////////////////////////////////////////////////////////////////
1:          Long[] bigintarg,
1:          Boolean[] booleanarg,
1:          Double[] doublearg,
1:          Double[] floatarg,
1:          Integer[] intarg,
1:          Float[] realarg,
1:          Integer[] smallintarg,
/////////////////////////////////////////////////////////////////////////
1: 
0:         bigintarg[0] = _nullOutArgs ? null : new Long( intValue );
1:         blobarg[0] = _nullOutArgs ? null : new HarmonySerialBlob( BINARY_VALUE );
1:         booleanarg[0] = _nullOutArgs ? null : Boolean.TRUE;
1:         chararg[0] = _nullOutArgs ? null : stringValue;
1:         charforbitdataarg[0] = _nullOutArgs ? null : BINARY_VALUE;
1:         clobarg[0] = _nullOutArgs ? null : new HarmonySerialClob( lobValue );
1:         datearg[0]= _nullOutArgs ? null : new Date( 761990400000L );
0:         doublearg[0] = _nullOutArgs ? null : new  Double( floatValue );
0:         floatarg[0] = _nullOutArgs ? null : new Double( floatValue );
0:         intarg[0] = _nullOutArgs ? null : new Integer( intValue );
1:         longvarchararg[0] = _nullOutArgs ? null : stringValue;
1:         longvarcharforbitdataarg[0] =  _nullOutArgs ? null : BINARY_VALUE;
1:         numericarg[0] = _nullOutArgs ? null : new BigDecimal( "1.0" );
0:         realarg[0] = _nullOutArgs ? null : new Float( floatValue );
0:         smallintarg[0] = _nullOutArgs ? null : new Integer( intValue );
1:         timearg[0] = _nullOutArgs ? null : new Time(TIME_VALUE);
1:         timestamparg[0] = _nullOutArgs ? null : new Timestamp(TIMESTAMP_VALUE);
1:         varchararg[0] = _nullOutArgs ? null : stringValue;
1:         varcharforbitdataarg[0] = _nullOutArgs ? null : BINARY_VALUE;
commit:f1ec775
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Regression test for https://issues.apache.org/jira/browse/DERBY-4959, an NPE
1:      * trying to return null LOBs as procedure output args.
1:      * </p>
1:      */
1:     public  void    test_4959() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "create procedure blobProc\n" +
1:              "(\n" +
1:              "    out blobCol blob\n" +
1:              ")\n" +
1:              "language java\n" +
1:              "parameter style java\n" +
1:              "no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.blobProc'\n"
1:              );
1:         ps.execute();
1:         ps.close();
1:         ps = prepareStatement
1:             (
1:              conn,
1:              "create procedure clobProc\n" +
1:              "(\n" +
1:              "    out clobCol clob\n" +
1:              ")\n" +
1:              "language java\n" +
1:              "parameter style java\n" +
1:              "no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.clobProc'\n"
1:              );
1:         ps.execute();
1:         ps.close();
1: 
1:         CallableStatement cs = prepareCall
1:             (
1:              conn,
1:              "call blobProc(  ? )"
1:              );
1:         cs.registerOutParameter( 1, Types.BLOB );
1:         cs.execute();
1:         assertNull( cs.getBlob( 1 ) );
1:         cs.close();
1:         
1:         cs = prepareCall
1:             (
1:              conn,
1:              "call clobProc(  ? )"
1:              );
1:         cs.registerOutParameter( 1, Types.CLOB );
1:         cs.execute();
1:         assertNull( cs.getClob( 1 ) );
1:         cs.close();
1: 
1:         ps = prepareStatement( conn, "drop procedure blobProc" );
1:         ps.execute();
1:         ps.close();
1:         ps = prepareStatement( conn, "drop procedure clobProc" );
1:         ps.execute();
1:         ps.close();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public  static  void    blobProc
1:         (
1:          Blob[] blobarg
1:          )
1:         throws Exception
1:     {
1:         blobarg[0] = null;
1:     }
1: 
1:     public  static  void    clobProc
1:         (
1:          Clob[] clobarg
1:          )
1:         throws Exception
1:     {
1:         clobarg[0] = null;
1:     }
1: 
commit:1447862
/////////////////////////////////////////////////////////////////////////
0:         blobarg[0] = new HarmonySerialBlob( BINARY_VALUE );
0:         charforbitdataarg[0] = BINARY_VALUE;
0:         longvarcharforbitdataarg[0] =  BINARY_VALUE;
0:         varcharforbitdataarg[0] = BINARY_VALUE;
commit:04f8e95
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.HarmonySerialBlob;
1: import org.apache.derby.iapi.types.HarmonySerialClob;
1: 
1: 
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: public class CallableStatementTest  extends Wrapper41Test
1: {
/////////////////////////////////////////////////////////////////////////
1:      * Test the JDBC 4.1 extensions.
1:      */
1:     public  void    testJDBC4_1() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         
1:         vetDataTypeCount( conn );
1: 
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "create procedure allTypesProc\n" +
1:              "(\n" +
1:              "    out bigintCol bigint,\n" +
1:              "    out blobCol blob,\n" +
1:              "    out booleanCol boolean,\n" +
1:              "    out charCol char(1),\n" +
1:              "    out charForBitDataCol char(1) for bit data,\n" +
1:              "    out clobCol clob,\n" +
1:              "    out dateCol date,\n" +
1:              "    out doubleCol double,\n" +
1:              "    out floatCol float,\n" +
1:              "    out intCol int,\n" +
1:              "    out longVarcharCol long varchar,\n" +
1:              "    out longVarcharForBitDataCol long varchar for bit data,\n" +
1:              "    out numericCol numeric,\n" +
1:              "    out realCol real,\n" +
1:              "    out smallintCol smallint,\n" +
1:              "    out timeCol time,\n" +
1:              "    out timestampCol timestamp,\n" +
1:              "    out varcharCol varchar( 2 ),\n" +
1:              "    out varcharForBitDataCol varchar( 2 ) for bit data\n" +
1:              ")\n" +
1:              "language java\n" +
1:              "parameter style java\n" +
1:              "no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.CallableStatementTest.allTypesProc'\n"
1:              );
1:         ps.execute();
1:         ps.close();
1: 
1:         CallableStatement cs = prepareCall
1:             (
1:              conn,
1:              "call allTypesProc(  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )"
1:              );
1:         int param = 1;
1:         cs.registerOutParameter( param++, Types.BIGINT );
1:         cs.registerOutParameter( param++, Types.BLOB );
1:         cs.registerOutParameter( param++, Types.BOOLEAN );
1:         cs.registerOutParameter( param++, Types.CHAR );
1:         cs.registerOutParameter( param++, Types.BINARY );
1:         cs.registerOutParameter( param++, Types.CLOB );
1:         cs.registerOutParameter( param++, Types.DATE );
1:         cs.registerOutParameter( param++, Types.DOUBLE );
1:         cs.registerOutParameter( param++, Types.FLOAT );
1:         cs.registerOutParameter( param++, Types.INTEGER );
1:         cs.registerOutParameter( param++, Types.LONGVARCHAR );
1:         cs.registerOutParameter( param++, Types.LONGVARBINARY );
1:         cs.registerOutParameter( param++, Types.NUMERIC );
1:         cs.registerOutParameter( param++, Types.REAL );
1:         cs.registerOutParameter( param++, Types.SMALLINT );
1:         cs.registerOutParameter( param++, Types.TIME );
1:         cs.registerOutParameter( param++, Types.TIMESTAMP );
1:         cs.registerOutParameter( param++, Types.VARCHAR );
1:         cs.registerOutParameter( param++, Types.VARBINARY );
1:         cs.execute();
0:         examineJDBC4_1extensions( new Wrapper41( cs ) );
1:         cs.close();
1: 
1:         ps = prepareStatement( conn, "drop procedure allTypesProc" );
1:         ps.execute();
1:         ps.close();
1:     }
1:     private void    vetDataTypeCount( Connection conn ) throws Exception
1:     {
1:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:         int actualTypeCount = 0;
1:         while ( rs.next() ) { actualTypeCount++; }
1:         rs.close();
1: 
1:         //
1:         // If this assertion fails, that means that another data type has been added
1:         // to Derby. You need to add that datatype to the allTypesProc procedure created
1:         // by testJDBC4_1() and you need to add a verification case to examineJDBC4_1extensions().
1:         //
1:         assertEquals( 22, actualTypeCount );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Procedure used by jdbc 4.1 tests.
1:      * </p>
1:      */
1:     public  static  void    allTypesProc
1:         (
0:          long[] bigintarg,
1:          Blob[] blobarg,
0:          boolean[] booleanarg,
1:          String[] chararg,
1:          byte[][] charforbitdataarg,
1:          Clob[] clobarg,
1:          Date[] datearg,
0:          double[] doublearg,
0:          double[] floatarg,
0:          int[] intarg,
1:          String[] longvarchararg,
1:          byte[][] longvarcharforbitdataarg,
1:          BigDecimal[] numericarg,
0:          float[] realarg,
0:          short[] smallintarg,
1:          Time[] timearg,
1:          Timestamp[] timestamparg,
1:          String[] varchararg,
1:          byte[][] varcharforbitdataarg
1:          )
1:         throws Exception
1:     {
1:         String  stringValue = "a";
0:         byte[]  binaryValue = new byte[] { (byte) 0xde };
1:         byte    intValue = (byte) 1;
1:         float   floatValue = 1.0F;
1:         String lobValue = "abc";
1:         
0:         bigintarg[0] = intValue;
0:         blobarg[0] = new HarmonySerialBlob( lobValue.getBytes( "UTF-8" ));
0:         booleanarg[0] = true;
0:         chararg[0] = stringValue;
0:         charforbitdataarg[0] = binaryValue;
0:         clobarg[0] = new HarmonySerialClob( lobValue );
0:         datearg[0]= new Date( 761990400000L );
0:         doublearg[0] = floatValue;
0:         floatarg[0] = floatValue;
0:         intarg[0] = intValue;
0:         longvarchararg[0] = stringValue;
0:         longvarcharforbitdataarg[0] =  binaryValue;
0:         numericarg[0] = new BigDecimal( "1.0" );
0:         realarg[0] = floatValue;
0:         smallintarg[0] = intValue;
0:         timearg[0] = new Time( 83342000L );
0:         timestamparg[0] = new Timestamp( -229527385766L );
0:         varchararg[0] = stringValue;
0:         varcharforbitdataarg[0] = binaryValue;
1:     }
1: 
1:     /**
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:9e6ceb7
/////////////////////////////////////////////////////////////////////////
1:             cStmt.setBlob("some-parameter-name", (Blob)null);
/////////////////////////////////////////////////////////////////////////
1:             cStmt.setClob("some-parameter-name", (Clob)null);
/////////////////////////////////////////////////////////////////////////
1:             cStmt.setNClob("some-parameter-name", (NClob)null);
commit:9c14132
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         cStmt = con.prepareCall("? = CALL FLOOR(?)");
1:         cStmt.registerOutParameter(1, Types.DOUBLE);
/////////////////////////////////////////////////////////////////////////
1:     public void testNamedParametersAreNotSupported()
1:         throws SQLException {
0:         DatabaseMetaData met = con.getMetaData();
1:         assertFalse("Named parameters are not supported, but the metadata " +
1:                     "says they are", met.supportsNamedParameters());
0:         met = null;
1:     }
1:     
1:     public void testGetDoubleIntOnInParameter()
1:         throws SQLException {
1:         cStmt.setDouble(2, 3.3);
1:         cStmt.execute();
1:         try {
1:             cStmt.getDouble(2);
1:             fail("Calling getDouble on an IN parameter should throw " +
1:                  "an exception");
1:         } catch (SQLException sqle) {
1:             // SQLState differ between DerbyNetClient and embedded.
1:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:             assertSQLState("Unexpected SQLState", sqlState, sqle);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void testGetCharacterStreamIntOnInvalidTypeDOUBLE() 
1:         cStmt.setDouble(2, 3.3);
1:         cStmt.execute();
1:             fail("An exception signalling invalid data type conversion " +
1:                  "should have been thrown");
1:         } catch (SQLDataException sqlde) {
1:             assertSQLState("Exception with invalid SQL state thrown on " +
1:                     "invalid data type conversion", "22005", sqlde);
1: 
1:     /**
1:      * Test which SQLState is thrown when getCharacterStream is called
1:      * on an IN parameter of an unsupported type.
1:      */
1:     public void testGetCharacterStreamIntOnInParameterOfInvalidType()
1:         throws SQLException {
1:         cStmt.setDouble(2, 3.3);
1:         cStmt.execute();
1:         try {
1:             cStmt.getCharacterStream(2);
1:             fail("Calling getCharacterStream on an IN parameter should " +
1:                  "throw an exception");
1:         } catch (SQLException sqle) {
1:             // SQLState differ between DerbyNetClient and embedded.
1:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:             assertSQLState("Exception with invalid SQL state thrown for " +
1:                            "getCharacterStream on IN parameter", 
1:                            sqlState, sqle);
1:         }
1:     }
1:     
1:     /**
1:      * Test which SQLState is thrown when getCharacterStream is called
1:      * on an IN parameter of a supported type.
1:      */
1:     public void testGetCharacterStreamIntOnInParameterOfValidType()
1:         throws SQLException {
0:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(con);
1:         cStmt.setString(1, "A string");
1:         cStmt.execute();
1:         try {
1:             cStmt.getCharacterStream(1);
1:             fail("Calling getCharacterStream on an IN parameter should " +
1:                  "throw an exception");
1:         } catch (SQLException sqle) {
1:             // SQLState differ between DerbyNetClient and embedded.
1:             String sqlState = usingDerbyNetClient() ? "XJ091" : "XCL26";
1:             assertSQLState("Exception with invalid SQL state thrown for " +
1:                            "getCharacterStream on IN parameter", 
1:                            sqlState, sqle);
1:         }
1:     }
1:     
1:     /**
1:      * Test basic use of getCharacterStream on character data.
1:      * Create a CallableStatement that takes an integer as input and returns
1:      * the number as a string. The string is read as a stream, and the integer
1:      * is recreated from it and compared to the integer passed in.
1:      */
1:     public void testGetCharacterStreamIntVARCHAR()
1:         throws IOException, SQLException {
0:         cStmt = CallableStatementTestSetup.getIntToStringFunction(con);
1:         cStmt.setInt(2, 4509);
1:         assertFalse("No resultsets should be returned", cStmt.execute());
1:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:         // Get a character stream
1:         Reader cStream = cStmt.getCharacterStream(1);
1:         assertFalse("Stream should not be null", cStmt.wasNull());
1:         assertNotNull("Stream is null even though wasNull() returned false",
1:                 cStream);
1:         char[] chars = new char[4];
1:         assertEquals("Wrong number of characters read",
1:                 4, cStream.read(chars));
1:         // Make sure we have reached end of stream.
1:         assertEquals("Expected end of stream, but there were more data",
1:                 -1, cStream.read());
1:         cStream.close();
1:         String result = new String(chars);
1:         assertEquals("Incorrect result obtained through java.io.Reader",
1:                 "4509", result);
1:     }
1:     
1:     /**
1:      * Test basic use of getCharacterStream on binary data.
1:      * Create a CallableStatement that takes a string as input and returns
1:      * a byte representation, which is then read through a stream. The string
1:      * is recreated and compared to the one passed in. Note that strings must
1:      * be represented in UTF-16BE for this to work.
1:      */
1:     public void testGetCharacterStreamIntVARBINARYDirect()
1:         throws IOException, SQLException {
1:         String data = "This is the test string.";
0:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(con);
1:         cStmt.setString(1, data);
1:         assertFalse("No resultsets should be returned", cStmt.execute());
1:         // Note that getUpdateCount behaves differently on client and embedded.
1:         assertEquals("Incorrect updatecount", 
1:                      usingEmbedded() ? 0 : -1, 
1:                      cStmt.getUpdateCount());
1:         Reader cStream = cStmt.getCharacterStream(2);
1:         assertFalse("Stream should not be null", cStmt.wasNull());
1:         assertNotNull("Stream is null even though wasNull() returned false",
1:                 cStream);
1:         // Assume we don't know how many bytes the string will be represented 
1:         // by, just create enough space and read until stream is exhausted.
1:         // To be able to read the string back, getBytes must be called with
1:         // UTF-16BE charset, because Derby uses UTF-16BE encoding as default.
1:         // JDBC does not specify which charset to use for binary data, and 
1:         // UTF-16BE was apparently selected to match JCC.
1:         char[] tmpChars = new char[data.length() * 4];
1:         int curChar = cStream.read();
1:         int index = 0;
1:         while (curChar != -1) {
1:             tmpChars[index] = (char)curChar;
1:             index++;
1:             curChar = cStream.read();
1:         }
1:         cStream.close();
1:         char[] chars = new char[index];
1:         System.arraycopy(tmpChars, 0, chars, 0, index);
1:         String result = new String(chars);
1:         assertEquals("Incorrect result obtained through java.io.Reader",
1:                 data, result);
1:     }
1: 
1:     /**
1:      * Fetch a string stored as bytes from the database through a reader,
1:      * then recreate the string.
1:      */
1:     public void testGetCharacterStreamIntVARBINARYFromDb()
1:         throws IOException, SQLException {
0:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(con);
1:         cStmt.setInt(2, CallableStatementTestSetup.STRING_BYTES_ID);
1:         assertFalse("No resultsets should be returned", cStmt.execute());
1:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:         Reader cStream = cStmt.getCharacterStream(1);
1:         assertFalse("Stream should not be null", cStmt.wasNull());
1:         assertNotNull("Stream is null even though wasNull() returned false",
1:                 cStream);
1:         char[] tmpChars = new char[32672];
1:         int curChar = cStream.read();
1:         int index = 0;
1:         while (curChar != -1) {
1:             tmpChars[index] = (char)curChar;
1:             index++;
1:             curChar = cStream.read();
1:         }
1:         char[] chars = new char[index];
1:         System.arraycopy(tmpChars, 0, chars, 0, index);
1:         tmpChars = null;
1:         cStream.close();
1:         String result = new String(chars);
1:         assertEquals("Strings not equal", 
1:                      CallableStatementTestSetup.STRING_BYTES, 
1:                      result);
1:     }
1: 
1:     /**
1:      * Read a SQL NULL value from a VARBINARY column through a reader.
1:      */
1:     public void testGetCharacterStreamIntOnVARBINARYWithNull()
1:         throws SQLException {
0:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(con);
1:         cStmt.setInt(2, CallableStatementTestSetup.SQL_NULL_ID);
1:         assertFalse("No resultsets should be returned", cStmt.execute());
1:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:         Reader cStream = cStmt.getCharacterStream(1);
1:         assertTrue("Stream should be null", cStmt.wasNull());
1:         assertNull("Stream is not null even though wasNull() returned true",
1:                 cStream);
1:     }
1:     
1:     /**
1:      * Read a SQL NULL value from a VARCHAR column through a reader.
1:      */
1:     public void testGetCharacterStreamIntOnVARCHARWithNull()
1:         throws SQLException {
0:         cStmt = CallableStatementTestSetup.getVarcharFromDbFunction(con);
1:         cStmt.setInt(2, CallableStatementTestSetup.SQL_NULL_ID);
1:         assertFalse("No resultsets should be returned", cStmt.execute());
1:         assertEquals("Incorrect updatecount", -1, cStmt.getUpdateCount());
1:         Reader cStream = cStmt.getCharacterStream(1);
1:         assertTrue("Stream should be null", cStmt.wasNull());
1:         assertNull("Stream is not null even though wasNull() returned true",
1:                 cStream);
1:     }
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite(CallableStatementTest.class,
0:                                         "CallableStatementTest suite");
1:         return new CallableStatementTestSetup(suite);
commit:2e7a2af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
0: import java.lang.reflect.Method;
0: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns true and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      */
0:     public void testisWrapperReturnsTrue() throws SQLException {
0:         //wrapper support is currently provided 
0:         //only for embedded side so return if 
0:         //running in DerbyNetClient framework
0:         if(usingDerbyNetClient())
0:             return;
1:         
0:         Class<CallableStatement> wrap_class = CallableStatement.class;
1:         
0:         //The if should return true enabling us  to call the unwrap method
0:         //without throwing  an exception
0:         if(cStmt.isWrapperFor(wrap_class)) {
1:             try {
0:                 CallableStatement stmt1 =
0:                         (CallableStatement)cStmt.unwrap(wrap_class);
1:             }
0:             catch(SQLException sqle) {
0:                 fail("Unwrap wrongly throws a SQLException");
1:             }
0:         } else {
0:             fail("isWrapperFor wrongly returns false");
1:         }
1:     }
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns false and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      */
0:     public void testisWrapperReturnsFalse() throws SQLException {
0:         //wrapper support is currently provided 
0:         //only for embedded side so return if 
0:         //running in DerbyNetClient framework
0:          if(usingDerbyNetClient())
0:             return;
1:          
0:         //test for the case when isWrapper returns false
0:         //using some class that will return false when
0:         //passed to isWrapperFor
0:         Class<ResultSet> wrap_class = ResultSet.class;
1:         
0:         //returning false is the correct behaviour in this case
0:         //Generate a message if it returns true
0:         if(cStmt.isWrapperFor(wrap_class)) {
0:             fail("isWrapperFor wrongly returns true");
0:         } else {
1:             try {
0:                 ResultSet rs1 = (ResultSet)
0:                 cStmt.unwrap(wrap_class);
0:                 fail("unwrap does not throw the expected " +
0:                         "exception");
0:             } catch (SQLException sqle) {
0:                 //calling unwrap in this case throws an SQLException
0:                 //check that this SQLException has the correct SQLState
0:                 if(!SQLStateConstants.UNABLE_TO_UNWRAP.equals(sqle.getSQLState())) {
0:                     throw sqle;
1:                 }
1:             }
1:         }
1:     }
commit:966d2c3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0:    Derby - Class CallableStatementTest
1:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
0: import java.sql.*;
1: 
1: /**
1:  * Tests of the <code>java.sql.CallableStatement</code> JDBC40 API.
1:  */
0: public class CallableStatementTest
0:     extends BaseJDBCTestCase {
1: 
0:     /** Default connection used by the tests. */
0:     private Connection con = null;
1:     /** Default callable statement used by the tests. */
1:     private CallableStatement cStmt = null;
1:     
1: 
1:     /**
1:      * Create a test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public CallableStatementTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Create a default callable statement and connection.
1:      *
1:      * @throws SQLException if creation of connection or callable statement
1:      *                      fail.
1:      */
0:     public void setUp() 
1:         throws SQLException {
0:         con = getConnection();
0:         cStmt = con.prepareCall("values 1");
1:     }
1: 
1:     /**
1:      * Close default callable statement and connection.
1:      *
1:      * @throws SQLException if closing of the connection or the callable
1:      *                      statement fail.
1:      */
0:     public void tearDown()
1:         throws SQLException {
0:         if (cStmt != null && !cStmt.isClosed()) {
1:             cStmt.close();
1:         }
0:         if (con != null && !con.isClosed()) {
0:             con.rollback();
0:             con.close();
1:         }
1:         cStmt = null;
0:         con = null;
1:     }
1:    
1:     public void testGetNClobIntNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getNClob(1);
1:             fail("CallableStatement.getNClob(int) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:     
1:     public void testGetNClobStringNotImplemented() 
1:         throws SQLException {
1:         try {
1:             cStmt.getNClob("some-parameter-name");
1:             fail("CallableStatement.getNClob(String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testGetNStringIntNotImplemented() 
1:         throws SQLException {
1:         try {
1:             cStmt.getNString(1);
1:             fail("CallableStatement.getNString(int) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testGetNStringStringNotImplemented() 
1:         throws SQLException {
1:         try {
1:             cStmt.getNString("some-parameter-name");
1:             fail("CallableStatement.getNString(String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
0:     public void testGetCharacterStreamIntNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getCharacterStream(1);
0:             fail("CallableStatement.getCharacterStream(int) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:     
1:     public void testGetCharacterStreamStringNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getCharacterStream("some-parameter-name");
1:             fail("CallableStatement.getCharacterStream(String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testGetNCharacterStreamIntNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getNCharacterStream(1);
1:             fail("CallableStatement.getNCharacterStream(int) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:     
1:     public void testGetNCharacterStreamStringNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getNCharacterStream("some-parameter-name");
1:             fail("CallableStatement.getNCharacterStream(String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetBlobNotImplemented()
1:         throws SQLException {
1:         try {
0:             cStmt.setBlob("some-parameter-name", null);
1:             fail("CallableStatement.setBlob(String, Blob) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:     
1:     public void testSetClobNotImplemented()
1:         throws SQLException {
1:         try {
0:             cStmt.setClob("some-parameter-name", null);
1:             fail("CallableStatement.setClob(String, Clob) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetNCharacterStreamNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.setNCharacterStream("some-parameter-name", null, 0l);
1:             fail("CallableStatement.setNCharacterStream(String,Reader,long) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetNClobNClobNotImplemented()
1:         throws SQLException {
1:         try {
0:             cStmt.setNClob("some-parameter-name", null);
1:             fail("CallableStatement.setNClob(String, NClob) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetNClobReaderNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.setNClob("some-parameter-name", null, 0l);
1:             fail("CallableStatement.setNClob(String, Reader, long) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetNStringNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.setNString("some-parameter-name", "some-value");
1:             fail("CallableStatement.setNString(String, String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:    
1:     public void testGetSQLXMLIntNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getSQLXML(1);
1:             fail("CallableStatement.getSQLXML(int) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1:     
1:     public void testGetSQLXMLStringNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.getSQLXML("some-parameter-name");
1:             fail("CallableStatement.getSQLXML(String) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     public void testSetSQLXMLNotImplemented()
1:         throws SQLException {
1:         try {
1:             cStmt.setSQLXML("some-parameter-name", null);
1:             fail("CallableStatement.setSQLXML(String, SQLXML) " +
1:                  "should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // We are fine, do nothing.
1:         }
1:     }
1: 
1:     /**
1:      * Return suite with all tests of the class.
1:      */
1:     public static Test suite() {
0:         return (new TestSuite(CallableStatementTest.class,
0:                               "CallableStatementTest suite"));
1:     }
1:     
1: } // End class CallableStatementTest
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.Date;
1: import java.sql.NClob;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLDataException;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Types;
1: import junit.framework.Test;
0: import org.apache.derby.iapi.types.HarmonySerialBlob;
0: import org.apache.derby.iapi.types.HarmonySerialClob;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("CallableStatementTest suite");
1: 
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(CallableStatementTest.class, name);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2ff02ef
/////////////////////////////////////////////////////////////////////////
1:     public void testIsWrapperForSelf() throws SQLException {
1:         assertTrue(cStmt.isWrapperFor(cStmt.getClass()));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testUnwrapAsSelf() throws SQLException {
1:         PreparedStatement cs = cStmt.unwrap(cStmt.getClass());
1:         assertSame("Unwrap returned wrong object.", cStmt, cs);
1:     }
1: 
commit:0cfef0d
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:                                 TestConfiguration.connectionCPDecorator( baseSuite
1:                                         ("CallableStatementTest:logical"))));
commit:4f2e50d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         timearg[0] = new Time(TIME_VALUE);
0:         timestamparg[0] = new Timestamp(TIMESTAMP_VALUE);
commit:9b52936
/////////////////////////////////////////////////////////////////////////
1: 
0:         cStmt.close();
0:         cStmt = null;
/////////////////////////////////////////////////////////////////////////
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("CallableStatementTest suite");
1:         suite.addTest(baseSuite("CallableStatementTest:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("CallableStatementTest:client")));
1:         return suite;
1:     }
1: 
1:     private static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(CallableStatementTest.class, name);
0:         return new CallableStatementTestSetup(suite);
commit:f631317
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Helper method for testIsWrapperFor*Statement test cases. */
1:     private void testIsWrapperForXXXStatement(Class klass) throws SQLException {
1:         assertTrue("The CallableStatement is not a wrapper for "
1:                        + klass.getName(),
1:                    cStmt.isWrapperFor(klass));
1:     public void testIsWrapperForStatement() throws SQLException {
1:         testIsWrapperForXXXStatement(Statement.class);
1:     }
1: 
1:     public void testIsWrapperForPreparedStatement() throws SQLException {
1:         testIsWrapperForXXXStatement(PreparedStatement.class);
1:     }
1: 
1:     public void testIsWrapperForCallableStatement() throws SQLException {
1:         testIsWrapperForXXXStatement(CallableStatement.class);
1:     }
1: 
1:     public void testIsNotWrapperForResultSet() throws SQLException {
1:         assertFalse(cStmt.isWrapperFor(ResultSet.class));
1:     }
1: 
1:     public void testUnwrapStatement() throws SQLException {
1:         Statement stmt = cStmt.unwrap(Statement.class);
1:         assertSame("Unwrap returned wrong object.", cStmt, stmt);
1:     }
1: 
1:     public void testUnwrapPreparedStatement() throws SQLException {
1:         PreparedStatement ps = cStmt.unwrap(PreparedStatement.class);
1:         assertSame("Unwrap returned wrong object.", cStmt, ps);
1:     }
1: 
1:     public void testUnwrapCallableStatement() throws SQLException {
1:         Statement cs = cStmt.unwrap(CallableStatement.class);
1:         assertSame("Unwrap returned wrong object.", cStmt, cs);
1:     }
1: 
1:     public void testUnwrapResultSet() {
1:         try {
1:             ResultSet rs = cStmt.unwrap(ResultSet.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
1:         }
1:     }
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
0:         TestSuite mainSuite = new TestSuite();
0:         mainSuite.addTest(new CallableStatementTestSetup(suite));
0:         mainSuite.addTest(SetObjectUnsupportedTest.suite(true));
0:         return mainSuite;
commit:ff7369c
/////////////////////////////////////////////////////////////////////////
1:             fail("CallableStatement.setCharacterStream() " +
1:                  "should not be implemented");
/////////////////////////////////////////////////////////////////////////
1:             fail("CallableStatement.setAsciiStream() " +
1:                  "should not be implemented");
/////////////////////////////////////////////////////////////////////////
1:             fail("CallableStatement.setBinaryStream() " +
0:                  "should not be implemented");
commit:c511410
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      *
1:      * Tests the setCharacterStream method that accepts length as a long
1:      * parameter in the Callable Statement interface
1:      *
1:      * @throws SQLException Upon any error that occurs while calling this
1:      *         method
1:      *
1:      */
0: 
1:     public void testSetCharacterStream() throws SQLException {
1:         try {
1:             cStmt.setCharacterStream("Some String",null,0L);
0:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do nothing as this is the expected behaviour
0: 
0:         }
0:     }
0: 
1:     /**
1:      *
1:      * Tests the setAsciiStream method that accepts length as a long
1:      * parameter in the Callable Statement interface
1:      *
1:      * @throws SQLException Upon any error that occurs while calling this
1:      *         method
1:      *
1:      */
0: 
1:     public void testSetAsciiStream() throws SQLException {
1:         try {
1:             cStmt.setAsciiStream("Some String",null,0L);
0:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do nothing as this is the expected behaviour
0: 
0:         }
0:     }
0: 
1:     /**
1:      *
1:      * Tests the setBinaryStream method that accepts length as a long
1:      * parameter in the Callable Statement interface
1:      *
1:      * @throws SQLException Upon any error that occurs while calling this
1:      *         method
1:      *
1:      */
0: 
1:     public void testSetBinaryStream() throws SQLException {
1:         try {
1:             cStmt.setBinaryStream("Some String",null,0L);
0:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do nothing as this is the expected behaviour
0: 
0:         }
0:     }
0: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite mainSuite = new TestSuite(
0:                 "CallableStatementTest and SetObjectUnsupportedTest suite");
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:         DatabaseMetaData met = getConnection().getMetaData();
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getIntToStringFunction(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         cStmt = CallableStatementTestSetup.getVarcharFromDbFunction(getConnection());
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() 
1:         cStmt = prepareCall("? = CALL FLOOR(?)");
/////////////////////////////////////////////////////////////////////////
1:     protected void tearDown()
1:         throws Exception {
0: 
1:         super.tearDown();
0:         DatabaseMetaData met = getXConnection().getMetaData();
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getXConnection());
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getIntToStringFunction(getXConnection());
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getBinaryDirectProcedure(getXConnection());
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getXConnection());
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getBinaryFromDbFunction(getXConnection());
/////////////////////////////////////////////////////////////////////////
0:         cStmt = CallableStatementTestSetup.getVarcharFromDbFunction(getXConnection());
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================