1:eac0369: /*
19:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.RAMAccessManager
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access;
1:eac0369: 
1:bf32514: import org.apache.derby.iapi.security.Securable;
1:bf32514: import org.apache.derby.iapi.security.SecurityUtil;
1:bf32514: 
1:eac0369: import org.apache.derby.iapi.services.cache.Cacheable;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheableFactory;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheFactory;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:9496f49: import org.apache.derby.iapi.services.monitor.PersistentService;
1:eac0369: import org.apache.derby.iapi.services.property.PropertySetCallback;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:9496f49: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:9496f49: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: 
1:a0dbbd7: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:a0dbbd7: import java.security.AccessController;
1:eac0369: import java.util.Dictionary;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import java.io.Serializable;
1:eac0369: 
1:eac0369: 
1:eac0369: public abstract class RAMAccessManager
1:eac0369:     implements AccessFactory, 
1:eac0369:                CacheableFactory, 
1:eac0369:                ModuleControl, 
1:eac0369:                PropertySetCallback
14:eac0369: {
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
3:eac0369:     /**
1:eac0369:     The raw store that this access manager uses.
2:eac0369:     **/
1:eac0369:     private RawStoreFactory rawstore;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Hash table on primary implementation type.
1:eac0369:     **/
1:7e7a589:     private Hashtable<String,MethodFactory> implhash;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Hash table on primary format.
1:eac0369:     **/
1:7e7a589:     private Hashtable<UUID,MethodFactory> formathash;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Service properties.  These are supplied from ModuleControl.boot(),
1:eac0369: 	and ultimately come from the service.properties file.
1:eac0369: 	By convention, these properties are passed down to all modules
1:eac0369: 	booted by this one.  If this module needs to pass specific instructions
1:eac0369: 	to its sub-modules, it should create a new Properties object with
1:eac0369: 	serviceProperties as its default (so that the rest of the modules
1:eac0369: 	that are looking at it don't see the properties that this module
1:eac0369: 	needs to add).
1:eac0369: 	**/
1:eac0369: 	private Properties serviceProperties;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Default locking policy for the entire system.
1:eac0369:      **/
1:eac0369:     LockingPolicy system_default_locking_policy;
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 		The object providing the properties like behaviour
1:eac0369: 		that is transactional.
1:eac0369: 	*/
1:eac0369: 	private PropertyConglomerate xactProperties;
1:eac0369: 	private PropertyFactory 	pf;
1:eac0369: 
1:eac0369:     protected LockingPolicy table_level_policy[];
1:eac0369:     protected LockingPolicy record_level_policy[];
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * A map of the implementation specific id to conglomerate object.
3:eac0369:      * <p>
1:eac0369:      * A map of the implementation specific id to conglomerate object.
1:eac0369:      * The id is encoded into the conglomerate number, and then used to
1:eac0369:      * pick the right implementation of the conglomerate.  It is then
1:eac0369:      * up to the conglomerate implementation to retrieve it's stored 
1:eac0369:      * representation from disk.
4:eac0369:      *
1:eac0369:      * An internal mapping of the encoding of conglomerate identity in the
1:eac0369:      * conglomerate number to the actual conglomerate implementation.  Encoding
1:eac0369:      * this means that we can't dynamically add conglomerate implementations
1:eac0369:      * into the system, so when we want to do that this mapping will have to
1:eac0369:      * be more dynamic - but for now store knows exactly what implementations
1:eac0369:      * there are.
1:eac0369:      **/
1:eac0369:     protected ConglomerateFactory conglom_map[];
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Cache of Conglomerate objects, keyed by conglom id.  Used to speed up
1:eac0369:      * subsquent open of conglomerates, first open will need to call the 
1:eac0369:      * conglomerate to read and return it's description.
1:eac0369:      **/
1:eac0369:     private CacheManager    conglom_cache;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     public RAMAccessManager()
1:eac0369:     {
1:eac0369:         // Intialize the hash tables that hold the access methods that
1:eac0369:         // this access manager knows about.
1:7e7a589:         implhash   = new Hashtable<String,MethodFactory>();
1:7e7a589:         formathash = new Hashtable<UUID,MethodFactory>();
11:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:54be3b4:     /**
1:eac0369:      * Return the default locking policy for this access manager.
1:eac0369:      *
1:eac0369: 	 * @return the default locking policy for this accessmanager.
1:eac0369:      **/
1:eac0369:     protected LockingPolicy getDefaultLockingPolicy()
1:eac0369:     {
1:eac0369:         return(system_default_locking_policy);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     RawStoreFactory getRawStore()
1:eac0369:     {
1:eac0369:         return rawstore;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	PropertyConglomerate getTransactionalProperties()
1:eac0369:     {
1:eac0369: 		return xactProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private void boot_load_conglom_map()
3:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // System.out.println("before new code.");
1:eac0369: 
1:eac0369:         conglom_map = new ConglomerateFactory[2];
1:eac0369: 
1:eac0369: 		// Find the appropriate factory for the desired implementation.
1:eac0369: 		MethodFactory mfactory = findMethodFactoryByImpl("heap");
1:eac0369: 
1:eac0369: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "heap");
1:eac0369:         }
1:eac0369: 
1:eac0369:         conglom_map[ConglomerateFactory.HEAP_FACTORY_ID] = 
1:eac0369:             (ConglomerateFactory) mfactory;
1:eac0369: 
1:eac0369: 		// Find the appropriate factory for the desired implementation.
1:eac0369: 		mfactory = findMethodFactoryByImpl("BTREE");
1:eac0369: 
1:eac0369: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "BTREE");
1:eac0369:         }
1:eac0369:         conglom_map[ConglomerateFactory.BTREE_FACTORY_ID] = 
1:eac0369:             (ConglomerateFactory) mfactory;
1:eac0369: 
1:eac0369:         // System.out.println("conglom_map[0] = " + conglom_map[0]);
1:eac0369:         // System.out.println("conglom_map[1] = " + conglom_map[1]);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /***************************************************************************
1:eac0369:     ** Abstract Methods of RAMAccessManager, interfaces that control locking
1:eac0369:     ** level of the system.
1:eac0369:     ****************************************************************************
1:eac0369:     */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the locking level of the system.
1:eac0369:      * <p>
1:eac0369:      * This routine controls the lowest level of locking enabled for all locks
1:eac0369:      * for all tables accessed through this accessmanager.  The concrete 
1:eac0369:      * implementation may set this value always to table level locking for
1:eac0369:      * a client configuration, or it may set it to row level locking for a
1:eac0369:      * server configuration.
1:eac0369:      * <p>
1:eac0369:      * If TransactionController.MODE_RECORD is returned table may either be
1:eac0369:      * locked at table or row locking depending on the type of access expected
1:eac0369:      * (ie. level 3 will require table locking for heap scans.)
1:eac0369:      *
1:eac0369: 	 * @return TransactionController.MODE_TABLE if only table locking allowed,
1:eac0369:      *         else returns TransactionController.MODE_RECORD.
1:eac0369:      *
1:eac0369:      **/
1:eac0369:     abstract protected int getSystemLockLevel();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Query property system to get the System lock level.
1:eac0369:      * <p>
1:eac0369:      * This routine will be called during boot after access has booted far 
1:eac0369:      * enough, to allow access to the property conglomerate.  This routine
1:eac0369:      * will call the property system and set the value to be returned by
1:eac0369:      * getSystemLockLevel().
1:eac0369:      * <p>
1:eac0369:      *
2:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     abstract protected void bootLookupSystemLockLevel(
1:eac0369:     TransactionController tc)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Routines to map to/from conglomid/containerid:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     private long conglom_nextid = 0;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return next conglomid to try to add the container with.
1:eac0369:      * <p>
1:eac0369:      * The conglomerate number has 2 parts.  The low 4 bits are used to 
1:eac0369:      * encode the factory which "owns" the conglomerate.  The high 60 bits
1:eac0369:      * are used as a normal unique id mechanism.
1:eac0369:      * <p>
1:eac0369:      * So for example if the next id to assign is 0x54 the following will
1:eac0369:      * be the conglomid:
1:eac0369:      *     if a HEAP  (factory 0) - 0x540
1:eac0369:      *     if a BTREE (factory 1) - 0x541
1:eac0369:      *
1:eac0369:      * And the next id assigned will be:
1:eac0369:      *     if a HEAP  (factory 0) - 0x550
1:eac0369:      *     if a BTREE (factory 1) - 0x551
1:eac0369:      *
1:eac0369:      * @param factory_type factory id as gotten from getConglomerateFactoryId()
1:eac0369:      *
2:eac0369: 	 * @return The identifier to be used to open the conglomerate later.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected long getNextConglomId(int   factory_type)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         long    conglomid;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             // current code depends on this range, if we ever need to expand the
1:eac0369:             // range we can claim bits from the high order of the long.
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(factory_type >= 0x00 && factory_type <= 0x0f);
1:eac0369:         }
1:eac0369: 
6:eac0369:         synchronized (conglom_cache)
1:eac0369:         {
1:eac0369:             if (conglom_nextid == 0)
1:eac0369:             {
1:eac0369:                 // shift out the factory id and then add 1.
1:eac0369:                 conglom_nextid = (rawstore.getMaxContainerId() >> 4) + 1;
1:eac0369:             }
1:eac0369: 
1:eac0369:             conglomid = conglom_nextid++;
1:eac0369:         }
1:eac0369: 
1:eac0369:         // shift in the factory id and then return the conglomid.
1:eac0369:         
1:eac0369:         return((conglomid << 4) | factory_type);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Bump the conglomid.
1:eac0369:      * <p>
1:eac0369:      * For some reason we have found that the give conglomid already exists
1:eac0369:      * in the directory so just bump the next conglomid to greater than this
1:eac0369:      * one.  The algorithm to store and retrieve the last conglomid is not
1:eac0369:      * transactional as we don't want to pay the overhead for such an algorithm
1:eac0369:      * on every ddl statement - so it is possible to "lose" an update to the
1:eac0369:      * counter if we crash at an inopportune moment.  In general the upper
1:eac0369:      * level store code will just handle the error from addContainer which 
1:eac0369:      * says there already exists a conglom with that id, update the next
1:eac0369:      * conglomid and then try again.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param conglomid The conglomid which already exists.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     // currently not used, but this is one idea on how to handle 
1:eac0369:     // non-transactional update of the nextid field, just handle the error
1:eac0369:     // if we try to create a conglom and find the container already exists.
1:eac0369:     /*
1:eac0369:     private void handleConglomidExists(
1:eac0369:     long   conglomid)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         synchronized (conglom_cache)
1:eac0369:         {
1:eac0369:             conglom_nextid = ((conglomid >> 4) + 1);
1:eac0369:         }
1:eac0369:     }
1:eac0369:     */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Given a conglomid, return the factory which "owns" it.
1:eac0369:      * <p>
1:eac0369:      * A simple lookup on the boot time built table which maps the low order
1:eac0369:      * 4 bits into which factory owns the conglomerate.
1:eac0369:      * <p>
1:eac0369:      *
1:8758a25:      * @param conglom_id The conglomerate id of the conglomerate to look up.
1:eac0369:      *
1:eac0369: 	 * @return The ConglomerateFactory which "owns" this conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:fa87f1c:     ConglomerateFactory getFactoryFromConglomId(
1:eac0369:     long    conglom_id)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         try
1:eac0369:         {
1:eac0369:             return(conglom_map[((int) (0x0f & conglom_id))]);
1:eac0369:         }
1:eac0369:         catch (java.lang.ArrayIndexOutOfBoundsException e)
1:eac0369:         {
1:eac0369:             // just in case language passes in a bad factory id.
1:eac0369: 			throw StandardException.newException(
1:eac0369:                 SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
1:ce40a31:                 conglom_id);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Conglomerate Cache routines:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * ACCESSMANAGER CONGLOMERATE CACHE - 
1:eac0369:      * <p>
1:eac0369:      * Every conglomerate in the system is described by an object which 
1:eac0369:      * implements Conglomerate.  This object basically contains the parameters
1:eac0369:      * which describe the metadata about the conglomerate that store needs
1:eac0369:      * to know - like types of columns, number of keys, number of columns, ...
1:eac0369:      * <p>
1:eac0369:      * It is up to each conglomerate to maintain it's own description, and
1:eac0369:      * it's factory must be able to read this info from disk and return it
1:eac0369:      * from the ConglomerateFactory.readConglomerate() interface.
1:eac0369:      * <p>
1:eac0369:      * This cache simply maintains an in memory copy of these conglomerate
1:eac0369:      * objects, key'd by conglomerate id.  By caching, this avoids the cost
1:eac0369:      * of reading the conglomerate info from disk on each subsequent query
1:eac0369:      * which accesses the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * The interfaces and internal routines which deal with this cache are:
1:eac0369:      * conglomCacheInit() - initializes the cache at boot time.
1:eac0369:      *
1:eac0369:      *
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Initialize the conglomerate cache.
1:eac0369:      * <p>
1:eac0369:      * Simply calls the cache manager to create the cache with some hard
1:eac0369:      * coded defaults for size.
1:eac0369:      * <p>
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private void conglomCacheInit()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // Get a cache factory to create the conglomerate cache.
1:eac0369: 		CacheFactory cf = 
1:56c1dc2:             (CacheFactory) startSystemModule(
1:eac0369:                  org.apache.derby.iapi.reference.Module.CacheFactory);
1:eac0369: 
1:eac0369:         // Now create the conglomerate cache.
1:eac0369: 
1:eac0369: 	    conglom_cache =
1:eac0369:            cf.newCacheManager(
1:eac0369:                this, AccessFactoryGlobals.CFG_CONGLOMDIR_CACHE, 200, 300);
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Find a conglomerate by conglomid in the cache.
1:eac0369:      * <p>
1:eac0369:      * Look for a conglomerate given a conglomid.  If in cache return it,
1:eac0369:      * otherwise fault in an entry by asking the owning factory to produce
1:eac0369:      * an entry.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The conglomerate object identified by "conglomid".
1:eac0369:      *
2:eac0369:      * @param conglomid The conglomerate id of the conglomerate to look up.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:888d12e:     /* package */ Conglomerate conglomCacheFind(long conglomid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         Conglomerate conglom       = null;
1:ce40a31:         Long         conglomid_obj = conglomid;
1:eac0369: 
1:fa87f1c:         CacheableConglomerate cache_entry =
1:fa87f1c:             (CacheableConglomerate) conglom_cache.find(conglomid_obj);
1:eac0369: 
1:fa87f1c:         if (cache_entry != null) {
1:fa87f1c:             conglom = cache_entry.getConglom();
1:fa87f1c:             conglom_cache.release(cache_entry);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(conglom);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Invalide the current Conglomerate Cache.
1:eac0369:      * <p>
1:eac0369:      * Abort of certain operations will invalidate the contents of the 
1:eac0369:      * cache.  Longer term we could just invalidate those entries, but
1:eac0369:      * for now just invalidate the whole cache.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     /* package */ protected void conglomCacheInvalidate()
1:eac0369:         throws StandardException
1:eac0369:     {
1:fa87f1c:         conglom_cache.ageOut();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Add a newly created conglomerate to the cache.
1:eac0369:      * <p>
1:eac0369:      *
2:eac0369:      * @param conglomid   The conglomid of conglomerate to replace.
1:eac0369:      * @param conglom     The Conglom to add.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     /* package */ void conglomCacheAddEntry(
2:eac0369:     long            conglomid,
1:eac0369:     Conglomerate    conglom)
1:eac0369:         throws StandardException
1:eac0369:     {
1:fa87f1c:         // Insert the new entry.
1:fa87f1c:         CacheableConglomerate conglom_entry = (CacheableConglomerate)
1:ce40a31:             conglom_cache.create(conglomid, conglom);
1:fa87f1c:         conglom_cache.release(conglom_entry);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Remove an entry from the cache.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param conglomid   The conglomid of conglomerate to replace.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     /* package */ void conglomCacheRemoveEntry(long conglomid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:fa87f1c:         CacheableConglomerate conglom_entry = (CacheableConglomerate)
1:ce40a31:             conglom_cache.findCached(conglomid);
1:eac0369: 
1:fa87f1c:         if (conglom_entry != null) {
1:fa87f1c:             conglom_cache.remove(conglom_entry);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:fa87f1c:     /**
1:fa87f1c:      * <p>
1:fa87f1c:      * Get the current transaction context.
1:fa87f1c:      * </p>
1:fa87f1c:      *
1:fa87f1c:      * <p>
1:fa87f1c:      * If there is an internal transaction on the context stack, return the
1:fa87f1c:      * internal transaction. Otherwise, if there is a nested user transaction
1:fa87f1c:      * on the context stack, return the nested transaction. Otherwise,
1:fa87f1c:      * return the current user transaction.
1:fa87f1c:      * </p>
1:fa87f1c:      *
1:fa87f1c:      * @return a context object referencing the current transaction
1:fa87f1c:      */
1:fa87f1c:     RAMTransactionContext getCurrentTransactionContext() {
1:fa87f1c:         RAMTransactionContext rtc =
1:a0dbbd7:             (RAMTransactionContext) getContext(
1:fa87f1c:                 AccessFactoryGlobals.RAMXACT_INTERNAL_CONTEXT_ID);
1:eac0369: 
1:fa87f1c:         if (rtc == null) {
1:a0dbbd7:             rtc = (RAMTransactionContext) getContext(
1:fa87f1c:                     AccessFactoryGlobals.RAMXACT_CHILD_CONTEXT_ID);
1:fa87f1c:         }
1:fa87f1c: 
1:fa87f1c:         if (rtc == null) {
1:a0dbbd7:             rtc = (RAMTransactionContext) getContext(
1:fa87f1c:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1:fa87f1c:         }
1:fa87f1c: 
1:fa87f1c:         return rtc;
1:fa87f1c:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing AccessFactory Interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Database creation finished.  Tell RawStore.
1:94f158a: 	@exception StandardException standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public void createFinished() throws StandardException
1:eac0369: 	{
1:eac0369: 		rawstore.createFinished();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Find an access method that implements a format type.
1:eac0369:     @see AccessFactory#findMethodFactoryByFormat
1:eac0369:     **/
1:eac0369:     public MethodFactory findMethodFactoryByFormat(UUID format)
1:eac0369:     {
2:eac0369:         MethodFactory factory;
1:eac0369:         
1:eac0369:         // See if there's an access method that supports the desired
1:eac0369:         // format type as its primary format type.
1:7e7a589:         factory = formathash.get(format);
1:eac0369:         if (factory != null)
1:eac0369:             return factory;
1:eac0369: 
1:eac0369:         // No primary format.  See if one of the access methods
1:eac0369:         // supports it as a secondary format.
1:7e7a589:         Enumeration<MethodFactory> e = formathash.elements();
1:eac0369:         while (e.hasMoreElements())
1:eac0369:         {
1:7e7a589:             factory = e.nextElement();
1:eac0369:             if (factory.supportsFormat(format))
1:eac0369:                 return factory;
1:eac0369:         }
1:eac0369: 
1:eac0369:         // No such implementation.
1:eac0369:         return null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Find an access method that implements an implementation type.
1:eac0369:     @see AccessFactory#findMethodFactoryByImpl
1:eac0369:     **/
1:eac0369:     public MethodFactory findMethodFactoryByImpl(String impltype)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // See if there's an access method that supports the desired
1:eac0369:         // implementation type as its primary implementation type.
1:7e7a589:         MethodFactory factory = implhash.get(impltype);
1:eac0369:         if (factory != null)
1:eac0369: 				return factory;
1:eac0369: 
1:eac0369:         // No primary implementation.  See if one of the access methods
1:eac0369:         // supports the implementation type as a secondary.
1:7e7a589:         Enumeration<MethodFactory> e = implhash.elements();
1:eac0369:         while (e.hasMoreElements())
1:eac0369:         {
1:7e7a589:             factory = e.nextElement();
1:eac0369:             if (factory.supportsImplementation(impltype))
1:eac0369:                 return factory;
1:eac0369:         }
1:eac0369: 		factory = null;
1:eac0369: 
1:eac0369: 		// try and load an implementation.  a new properties object needs
1:eac0369: 		// to be created to hold the conglomerate type property, since
1:eac0369: 		// that value is specific to the conglomerate we want to boot, not
1:eac0369: 		// to the service as a whole
1:eac0369: 		Properties conglomProperties = new Properties(serviceProperties);
1:eac0369: 		conglomProperties.put(AccessFactoryGlobals.CONGLOM_PROP, impltype);
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			factory = 
1:56c1dc2:                (MethodFactory) bootServiceModule(
1:eac0369:                     false, this, MethodFactory.MODULE, 
1:eac0369:                     impltype, conglomProperties);
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			if (!se.getMessageId().equals(SQLState.SERVICE_MISSING_IMPLEMENTATION))
1:eac0369: 				throw se;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		conglomProperties = null;
1:eac0369: 
1:eac0369: 		if (factory != null) {
1:eac0369: 			registerAccessMethod(factory);
1:eac0369: 			return factory;
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // No such implementation.
1:eac0369:         return null;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public LockFactory getLockFactory() {
1:eac0369: 		return rawstore.getLockFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     public TransactionController getTransaction(
1:eac0369:     ContextManager cm)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return getAndNameTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public TransactionController getAndNameTransaction(
1:eac0369:     ContextManager cm, String transName)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (cm == null)
1:eac0369:             return null;  // XXX (nat) should throw exception
1:eac0369: 
1:eac0369:         // See if there's already a transaction context.
1:eac0369:         RAMTransactionContext rtc = (RAMTransactionContext)
1:eac0369:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1:eac0369: 
1:eac0369:         if (rtc == null)
1:eac0369:         {
1:eac0369:             // No transaction context.  Create or find a raw store transaction,
1:eac0369:             // make a context for it, and push the context.  Note this puts the
1:eac0369:             // raw store transaction context above the access context, which is
1:eac0369:             // required for error handling assumptions to be correct.
1:eac0369:             Transaction rawtran = rawstore.findUserTransaction(cm, transName);
1:eac0369:             RAMTransaction rt      = new RAMTransaction(this, rawtran, null);
1:eac0369: 
1:eac0369:             rtc = 
1:eac0369:                 new RAMTransactionContext(
1:eac0369:                     cm, 
1:eac0369:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
1:eac0369:                     rt, false /* abortAll */);
1:eac0369: 
1:eac0369: 			TransactionController tc = rtc.getTransaction();
1:eac0369: 
1:eac0369: 			if (xactProperties != null)
1:eac0369:             {
1:eac0369: 				rawtran.setup(tc);
1:eac0369: 				tc.commit();
1:eac0369: 			}
1:eac0369: 
1:eac0369:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
1:eac0369: 
1:eac0369: 			tc.commit();
1:eac0369: 
1:eac0369: 			return tc;
1:eac0369:         }
1:eac0369:         return rtc.getTransaction();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Start a global transaction.
1:eac0369:      * <p>
1:eac0369: 	 * Get a transaction controller with which to manipulate data within
1:eac0369: 	 * the access manager.  Implicitly creates an access context.
1:eac0369:      * <p>
1:eac0369:      * Must only be called if no other transaction context exists in the
1:eac0369:      * current context manager.  If another transaction exists in the context
1:eac0369:      * an exception will be thrown.
1:eac0369:      * <p>
1:eac0369:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:eac0369:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:eac0369:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:eac0369:      * in the path.  
1:eac0369:      *
1:eac0369:      * @param cm        The context manager for the current context.
1:eac0369:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:eac0369:      * @param global_id the global transaction identifier part of XID - ie.
1:eac0369:      *                  Xid.getGlobalTransactionId().
1:eac0369:      * @param branch_id The branch qualifier of the Xid - ie. 
1:eac0369:      *                  Xid.getBranchQaulifier()
1:eac0369:      * 	
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 * @see TransactionController
1:eac0369: 	 **/
1:eac0369: 	public /* XATransactionController */ Object startXATransaction(
1:eac0369:     ContextManager  cm, 
1:eac0369:     int             format_id,
1:eac0369:     byte[]          global_id,
1:eac0369:     byte[]          branch_id)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         RAMTransaction xa_tc = null;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(global_id != null);
1:eac0369:             SanityManager.ASSERT(branch_id != null);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (cm == null)
1:eac0369:             return null;  // XXX (nat) should throw exception
1:eac0369: 
1:eac0369:         // See if there's already a transaction context.
1:eac0369:         RAMTransactionContext rtc = (RAMTransactionContext) 
1:eac0369:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1:eac0369: 
1:eac0369:         if (rtc == null)
1:eac0369:         {
1:eac0369:             // No transaction context.  Create or find a raw store transaction,
1:eac0369:             // make a context for it, and push the context.  Note this puts the
1:eac0369:             // raw store transaction context above the access context, which is
1:eac0369:             // required for error handling assumptions to be correct.
1:eac0369:             Transaction rawtran = 
1:eac0369:                 rawstore.startGlobalTransaction(
1:eac0369:                     cm, format_id, global_id, branch_id);
1:eac0369: 
1:eac0369:             xa_tc                    = new RAMTransaction(this, rawtran, null);
1:eac0369: 
1:eac0369:             rtc = 
1:eac0369:                 new RAMTransactionContext(
1:eac0369:                     cm, 
1:eac0369:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
1:eac0369:                     xa_tc, false /* abortAll */);
1:eac0369: 
1:eac0369:             // RESOLVE - an XA transaction can only commit once so, if we
1:eac0369:             // acquire readlocks.
1:eac0369: 
1:eac0369: 			if (xactProperties != null) 
1:eac0369:             {
1:eac0369: 				rawtran.setup(xa_tc);
1:eac0369: 
1:eac0369:                 // HACK - special support has been added to the commitNoSync
1:eac0369:                 // of a global xact, to allow committing of read only xact, 
1:eac0369:                 // which will allow subsequent activity on the xact keeping
1:eac0369:                 // the same global transaction id.
1:eac0369:                 xa_tc.commitNoSync(
1:eac0369:                     TransactionController.RELEASE_LOCKS |
1:eac0369:                     TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1:eac0369: 			}
1:eac0369: 
1:eac0369:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
1:eac0369: 
1:eac0369:             // HACK - special support has been added to the commitNoSync
1:eac0369:             // of a global xact, to allow committing of read only xact, 
1:eac0369:             // which will allow subsequent activity on the xact keeping
1:eac0369:             // the same global transaction id.
1:eac0369:             xa_tc.commitNoSync(
1:eac0369:                 TransactionController.RELEASE_LOCKS |
1:eac0369:                 TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1:eac0369:         }
1:a0dbbd7:         else
1:eac0369:         {
1:eac0369:             // throw an error.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "RAMTransactionContext found on stack.");
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(xa_tc);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the XAResourceManager associated with this AccessFactory.
1:eac0369:      * <p>
1:eac0369:      * Returns an object which can be used to implement the "offline" 
1:eac0369:      * 2 phase commit interaction between the accessfactory and outstanding
1:eac0369:      * transaction managers taking care of in-doubt transactions.
1:eac0369:      *
1:eac0369:      * @return The XAResourceManager associated with this accessfactory.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public /* XAResourceManager */ Object getXAResourceManager()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(rawstore.getXAResourceManager());
1:eac0369:     }
1:eac0369: 
1:eac0369:     public void registerAccessMethod(MethodFactory factory)
1:eac0369:     {
1:eac0369:         // Put the access method's primary implementation type in
1:eac0369:         // a hash table so we can find it quickly.
1:eac0369:         implhash.put(factory.primaryImplementationType(), factory);
1:eac0369: 
1:eac0369:         // Put the access method's primary format in a hash table
1:eac0369:         // so we can find it quickly.
1:eac0369:         formathash.put(factory.primaryFormat(), factory);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public boolean isReadOnly()
1:eac0369: 	{
1:eac0369: 		return rawstore.isReadOnly();
1:eac0369: 	}
1:eac0369: 
1:9496f49:     /**
1:9496f49:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:9496f49:      *  database files) at database hard upgrade time)
1:9496f49:      * This gets called during hard upgrade. It will create 3 readme files
1:9496f49:      *  one in database directory, one in "seg0" directory and one in log
1:9496f49:      *  directory. These readme files warn users against touching any of
1:9496f49:      *  files associated with derby database 
1:9496f49:      */
1:9496f49:     public void createReadMeFiles()
1:9496f49:         throws StandardException
1:9496f49:     {
1:9496f49:         //creating readme in "seg0" directory
1:9496f49:         rawstore.createDataWarningFile();
1:9496f49: 
1:9496f49:         //creating readme in log directory
1:56c1dc2:         LogFactory logFactory =(LogFactory) findServiceModule(this, rawstore.getLogFactoryModule());
1:9496f49:         logFactory.createDataWarningFile();
1:9496f49: 
1:9496f49:         //creating readme in root database directory
1:56c1dc2:         DataFactory dataFactory =(DataFactory) findServiceModule(this, rawstore.getDataFactoryModule());
1:56c1dc2:         PersistentService ps = getMonitor().getServiceType(rawstore);
1:9496f49:         ps.createDataWarningFile(dataFactory.getStorageFactory());
1:9496f49:     }
1:9496f49: 	
1:eac0369: 	private void addPropertySetNotification(PropertySetCallback who, TransactionController tc) {
1:eac0369: 
1:eac0369: 		pf.addPropertySetNotification(who);
1:eac0369: 		
1:eac0369: 		// set up the initial values by calling the validate and apply methods.
1:eac0369: 		// the map methods are not called as they will have been called
1:eac0369: 		// at runtime when the user set the property.
1:a045b63:         Dictionary<Object, Object> d = new Hashtable<Object, Object>();
1:eac0369: 		try {
1:eac0369: 			xactProperties.getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
1:eac0369: 		} catch (StandardException se) {
5:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean dbOnly = PropertyUtil.isDBOnly(d);
1:eac0369: 
1:eac0369: 		who.init(dbOnly, d);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public TransactionInfo[] getTransactionInfo()
1:eac0369: 	{
1:eac0369: 		return rawstore.getTransactionInfo();
1:eac0369: 	}
1:eac0369: 
1:4aeada8:     /**
1:964abfa:      * Start the replication master role for this database.
1:964abfa:      * @param dbmaster The master database that is being replicated.
1:4aeada8:      * @param host The hostname for the slave
1:4aeada8:      * @param port The port the slave is listening on
1:4aeada8:      * @param replicationMode The type of replication contract.
1:4aeada8:      * Currently only asynchronous replication is supported, but
1:4aeada8:      * 1-safe/2-safe/very-safe modes may be added later.
1:4aeada8:      * @exception StandardException Standard Derby exception policy,
1:4aeada8:      * thrown on error.
1:4aeada8:      */
1:964abfa:     public void startReplicationMaster(String dbmaster, String host, int port,
1:4aeada8:                                        String replicationMode)
1:4aeada8:         throws StandardException {
1:964abfa:         rawstore.startReplicationMaster(dbmaster, host, port, replicationMode);
1:4aeada8:     }
1:fd20d6b:     
1:fd20d6b:     /**
1:fd20d6b:      * @see org.apache.derby.iapi.store.access.AccessFactory#failover(String dbname).
1:fd20d6b:      */
1:fd20d6b:     public void failover(String dbname) throws StandardException {
1:fd20d6b:         rawstore.failover(dbname);
1:fd20d6b:     }
1:4aeada8: 
1:eac0369:     /**
1:54be3b4:      * Stop the replication master role for this database.
1:54be3b4:      * 
1:54be3b4:      * @exception StandardException Standard Derby exception policy,
1:54be3b4:      * thrown on error.
1:54be3b4:      */
1:54be3b4:     public void stopReplicationMaster() throws StandardException {
1:54be3b4:         rawstore.stopReplicationMaster();
1:54be3b4:     }
1:54be3b4: 
1:eac0369: 	public void freeze() throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.FREEZE_DATABASE );
1:bf32514:             
1:eac0369: 		rawstore.freeze();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void unfreeze() throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.UNFREEZE_DATABASE );
1:bf32514:             
1:eac0369: 		rawstore.unfreeze();
1:eac0369: 	}
1:eac0369: 
1:fbb8866:     public void backup(
1:fbb8866:     String  backupDir, 
1:fbb8866:     boolean wait) 
1:fbb8866:         throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize
1:bf32514:             (
1:bf32514:              wait ?
1:bf32514:              Securable.BACKUP_DATABASE :
1:bf32514:              Securable.BACKUP_DATABASE_NOWAIT
1:bf32514:              );
1:fbb8866: 		rawstore.backup(backupDir, wait);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
2:fbb8866:     public void backupAndEnableLogArchiveMode(
1:fbb8866:     String  backupDir, 
1:fbb8866:     boolean deleteOnlineArchivedLogFiles,
1:fbb8866:     boolean wait)
1:eac0369: 		throws StandardException 
1:a0dbbd7: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize
1:bf32514:             (
1:bf32514:              wait ?
1:bf32514:              Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE :
1:bf32514:              Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT
1:bf32514:              );
1:fbb8866: 		rawstore.backupAndEnableLogArchiveMode(backupDir, 
1:fbb8866:                                                deleteOnlineArchivedLogFiles, 
1:fbb8866:                                                wait);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1:eac0369: 		throws StandardException
1:a0dbbd7: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.DISABLE_LOG_ARCHIVE_MODE );
1:bf32514:             
1:eac0369: 		rawstore.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void checkpoint() throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.CHECKPOINT_DATABASE );
1:bf32514:             
1:eac0369: 		rawstore.checkpoint();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void waitForPostCommitToFinishWork()
1:eac0369: 	{
1:eac0369: 		rawstore.getDaemon().waitUntilQueueIsEmpty();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing ModuleControl Interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 	public void boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		this.serviceProperties = startParams;
1:eac0369: 
1:eac0369:         boot_load_conglom_map();
1:eac0369: 
1:eac0369:         if (create)
1:eac0369:         {
1:eac0369:             // if we are creating the db, then just start the conglomid's at
1:eac0369:             // 1, and proceed from there.  If not create, we delay 
1:eac0369:             // initialization of this until the first ddl which needs a new
1:eac0369:             // id.
1:eac0369:             conglom_nextid = 1;
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Access depends on a Raw Store implementations.  Load it.
1:eac0369:         //
1:56c1dc2:         rawstore = (RawStoreFactory) bootServiceModule(
1:eac0369:             create, this, RawStoreFactory.MODULE, serviceProperties);
1:eac0369: 
1:888d12e:         // initialize handler with raw store to be called in the event of
1:888d12e:         // aborted inserts.  Store will use the call back to reclaim space
1:888d12e:         // when these events happen.  See DERBY-4057.
1:888d12e:         rawstore.setUndoInsertEventHandler(new RAMAccessUndoHandler(this));
1:888d12e: 
1:94f158a: 		// Note: we also boot this module here since we may start Derby
1:eac0369: 		// system from store access layer, as some of the unit test case,
1:eac0369: 		// not from JDBC layer.(See
1:eac0369: 		// /protocol/Database/Storage/Access/Interface/T_AccessFactory.java)
1:eac0369: 		// If this module has already been booted by the JDBC layer, this will 
1:eac0369: 		// have no effect at all.
1:56c1dc2: 		bootServiceModule(
1:eac0369:             create, this, org.apache.derby.iapi.reference.Module.PropertyFactory, 
1:eac0369:             startParams);
1:eac0369: 
1:eac0369:         // Create the in-memory conglomerate directory
1:eac0369: 
1:eac0369:         conglomCacheInit();
1:eac0369: 
1:eac0369:         // Read in the conglomerate directory from the conglom conglom
1:eac0369:         // Create the conglom conglom from within a separate system xact
1:eac0369:         RAMTransaction tc =
1:eac0369:             (RAMTransaction) getAndNameTransaction(
1:a0dbbd7:                 getContextService().getCurrentContextManager(),
1:eac0369:                 AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369: 
1:eac0369:         // looking up lock_mode is dependant on access booting, but
1:eac0369:         // some boot routines need lock_mode and
1:eac0369:         // system_default_locking_policy, so during boot do table level
1:eac0369:         // locking and then look up the "right" locking level.
1:eac0369: 
1:eac0369:         int lock_mode = LockingPolicy.MODE_CONTAINER;
1:eac0369: 
1:eac0369:         system_default_locking_policy =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 lock_mode,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1:eac0369: 
1:eac0369: 
1:eac0369:         // RESOLVE - code reduction - get rid of this table, and somehow
1:eac0369:         // combine it with the raw store one.
1:eac0369: 
1:eac0369:         table_level_policy = new LockingPolicy[6];
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_NOLOCK] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_NOLOCK, true);
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED, true);
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:eac0369:                 true);
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
1:eac0369: 
1:eac0369:         table_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_CONTAINER,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1:eac0369: 
1:eac0369:         record_level_policy = new LockingPolicy[6];
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_NOLOCK] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_NOLOCK, true);
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED, true);
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:eac0369:                 true);
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
1:eac0369: 
1:eac0369:         record_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             for (int i = 0;
1:eac0369:                  i < TransactionController.ISOLATION_SERIALIZABLE;
1:eac0369:                  i++)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     table_level_policy[i] != null,
1:eac0369:                     "table_level_policy[" + i + "] is null");
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     record_level_policy[i] != null,
1:eac0369:                     "record_level_policy[" + i + "] is null");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         tc.commit();
1:eac0369: 
1:eac0369:         // set up the property validation
1:eac0369:         pf = (PropertyFactory) 
1:56c1dc2:             findServiceModule(
1:eac0369:                 this, org.apache.derby.iapi.reference.Module.PropertyFactory);
1:eac0369: 
1:eac0369:         // set up the transaction properties.  On J9, over NFS, runing on a
1:eac0369:         // power PC coprossor, the directories were created fine, but create
1:eac0369:         // db would fail when trying to create this first file in seg0.
1:eac0369:         xactProperties = new PropertyConglomerate(tc, create, startParams, pf);
1:eac0369: 
1:651c99e:         //Put a readme file in seg0 directory, alerting users to not 
1:651c99e:         // touch or remove any of the files there 
1:651c99e:         if(create) {
1:651c99e:             rawstore.createDataWarningFile();
1:651c99e:         }
1:651c99e: 
1:eac0369:         // see if there is any properties that raw store needs to know
1:eac0369:         // about
1:eac0369:         rawstore.getRawStoreProperties(tc);
1:eac0369: 
1:eac0369:         // now that access and raw store are booted, do the property lookup
1:eac0369:         // which may do conglomerate access.
1:eac0369:         bootLookupSystemLockLevel(tc);
1:eac0369: 
1:eac0369:         lock_mode =
1:eac0369:             (getSystemLockLevel() == TransactionController.MODE_TABLE ?
1:eac0369:                  LockingPolicy.MODE_CONTAINER : LockingPolicy.MODE_RECORD);
1:eac0369: 
1:eac0369:         system_default_locking_policy =
1:eac0369:             tc.getRawStoreXact().newLockingPolicy(
1:eac0369:                 lock_mode,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1:eac0369: 
1:eac0369:         // set up the callbacl for the lock manager with initialization
1:eac0369:         addPropertySetNotification(getLockFactory(), tc);
1:eac0369: 
1:eac0369:         // make sure user cannot change these properties
1:eac0369:         addPropertySetNotification(this,tc);
1:eac0369: 
1:eac0369:         tc.commit();
1:eac0369: 
1:eac0369:         tc.destroy();
1:eac0369:         tc = null;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             // RESOLVE - (mikem) currently these constants need to be the
1:eac0369:             // same, but for modularity reasons there are 2 sets.  Probably
1:eac0369:             // should only be one set.  For now just make sure they are the
1:eac0369:             // same value.
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 TransactionController.OPENMODE_USE_UPDATE_LOCKS ==
1:eac0369:                 ContainerHandle.MODE_USE_UPDATE_LOCKS);
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 TransactionController.OPENMODE_SECONDARY_LOCKED ==
1:eac0369:                 ContainerHandle.MODE_SECONDARY_LOCKED);
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 TransactionController.OPENMODE_BASEROW_INSERT_LOCKED ==
1:eac0369:                 ContainerHandle.MODE_BASEROW_INSERT_LOCKED);
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 TransactionController.OPENMODE_FORUPDATE ==
1:eac0369:                 ContainerHandle.MODE_FORUPDATE);
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 TransactionController.OPENMODE_FOR_LOCK_ONLY ==
1:eac0369:                 ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public void stop()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Methods of the PropertySetCallback interface */
1:eac0369: 
1:eac0369:     // This interface is implemented to ensure the user cannot change the
1:eac0369:     // encryption provider or algorithm.
1:eac0369: 
1:eac0369: 	public void init(boolean dbOnly, Dictionary p)
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean validate(String key, Serializable value, Dictionary p)
1:eac0369: 		 throws StandardException
1:eac0369:     {
1:eac0369:         if (key.equals(Attribute.CRYPTO_ALGORITHM))
1:eac0369:         {
1:eac0369:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_ALGORITHM);
1:eac0369: 		}
1:eac0369:         if (key.equals(Attribute.CRYPTO_PROVIDER))
1:eac0369:         {
1:eac0369:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_PROVIDER);
1:eac0369: 		}
1:eac0369:         return true;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public Serviceable apply(String key, Serializable value, Dictionary p)
1:eac0369: 		 throws StandardException
1:eac0369:     {
1:eac0369:         return null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public Serializable map(String key, Serializable value, Dictionary p)
1:eac0369: 		 throws StandardException
1:eac0369:     {
1:eac0369:         return null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     // ///////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** CacheableFactory interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public Cacheable newCacheable(CacheManager cm) {
1:fa87f1c: 		return new CacheableConglomerate(this);
1:a0dbbd7: 	}
1:a0dbbd7: 
1:a0dbbd7:     // ///////////////////////////////////////////////////////////////
1:eac0369: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private static  ContextService    getContextService()
1:a0dbbd7:     {
2:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getFactory();
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<ContextService>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public ContextService run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getFactory();
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Context>()
1:56c1dc2:              {
1:56c1dc2:                  public Context run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getContext( contextID );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object  startSystemModule( final String factoryInterface )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.startSystemModule( factoryInterface );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final String identifier, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, identifier, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 conglom_id);
/////////////////////////////////////////////////////////////////////////
1:         Long         conglomid_obj = conglomid;
/////////////////////////////////////////////////////////////////////////
1:             conglom_cache.create(conglomid, conglom);
/////////////////////////////////////////////////////////////////////////
1:             conglom_cache.findCached(conglomid);
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:             (CacheFactory) startSystemModule(
/////////////////////////////////////////////////////////////////////////
1:                (MethodFactory) bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:         LogFactory logFactory =(LogFactory) findServiceModule(this, rawstore.getLogFactoryModule());
1:         DataFactory dataFactory =(DataFactory) findServiceModule(this, rawstore.getDataFactoryModule());
1:         PersistentService ps = getMonitor().getServiceType(rawstore);
/////////////////////////////////////////////////////////////////////////
1:         rawstore = (RawStoreFactory) bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1: 		bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:             findServiceModule(
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Context>()
1:              {
1:                  public Context run()
1:                  {
1:                      return ContextService.getContext( contextID );
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object  startSystemModule( final String factoryInterface )
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Object>()
1:                      public Object run()
1:                          throws StandardException
1:                          return Monitor.startSystemModule( factoryInterface );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final String identifier, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, identifier, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1:             (RAMTransactionContext) getContext(
1:             rtc = (RAMTransactionContext) getContext(
1:             rtc = (RAMTransactionContext) getContext(
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager(),
/////////////////////////////////////////////////////////////////////////
1:     // ///////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  ContextService    getContextService()
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<ContextService>()
1:                  {
1:                      public ContextService run()
1:                      {
1:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<Context>()
1:                  {
0:                      public Context run()
1:                      {
0:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:bf32514
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.Securable;
1: import org.apache.derby.iapi.security.SecurityUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.FREEZE_DATABASE );
1:             
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.UNFREEZE_DATABASE );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize
1:             (
1:              wait ?
1:              Securable.BACKUP_DATABASE :
1:              Securable.BACKUP_DATABASE_NOWAIT
1:              );
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize
1:             (
1:              wait ?
1:              Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE :
1:              Securable.BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT
1:              );
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.DISABLE_LOG_ARCHIVE_MODE );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.CHECKPOINT_DATABASE );
1:             
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1:     private Hashtable<String,MethodFactory> implhash;
1:     private Hashtable<UUID,MethodFactory> formathash;
/////////////////////////////////////////////////////////////////////////
1:         implhash   = new Hashtable<String,MethodFactory>();
1:         formathash = new Hashtable<UUID,MethodFactory>();
/////////////////////////////////////////////////////////////////////////
1:         factory = formathash.get(format);
1:         Enumeration<MethodFactory> e = formathash.elements();
1:             factory = e.nextElement();
/////////////////////////////////////////////////////////////////////////
1:         MethodFactory factory = implhash.get(impltype);
1:         Enumeration<MethodFactory> e = implhash.elements();
1:             factory = e.nextElement();
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:     /* package */ Conglomerate conglomCacheFind(long conglomid)
/////////////////////////////////////////////////////////////////////////
1:         // initialize handler with raw store to be called in the event of
1:         // aborted inserts.  Store will use the call back to reclaim space
1:         // when these events happen.  See DERBY-4057.
1:         rawstore.setUndoInsertEventHandler(new RAMAccessUndoHandler(this));
1: 
commit:ffd4e9b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
1:     public void backup(
1:     String  backupDir, 
1:     boolean wait) 
1:         throws StandardException
1: 		rawstore.backup(backupDir, wait);
/////////////////////////////////////////////////////////////////////////
1:     public void backupAndEnableLogArchiveMode(
1:     String  backupDir, 
1:     boolean deleteOnlineArchivedLogFiles,
1:     boolean wait)
1: 		rawstore.backupAndEnableLogArchiveMode(backupDir, 
1:                                                deleteOnlineArchivedLogFiles, 
1:                                                wait);
1: 	public void backupAndEnableLogArchiveMode(
0:     File    backupDir, 
0:     boolean deleteOnlineArchivedLogFiles) 
0: 		rawstore.backupAndEnableLogArchiveMode(
0:             backupDir, deleteOnlineArchivedLogFiles);
commit:8758a25
/////////////////////////////////////////////////////////////////////////
1:      * @param conglom_id The conglomerate id of the conglomerate to look up.
commit:0641e2f
/////////////////////////////////////////////////////////////////////////
0:         MethodFactory factory = (MethodFactory) implhash.get(impltype);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a045b63
/////////////////////////////////////////////////////////////////////////
1:         Dictionary<Object, Object> d = new Hashtable<Object, Object>();
commit:fa87f1c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     ConglomerateFactory getFactoryFromConglomId(
/////////////////////////////////////////////////////////////////////////
1:         CacheableConglomerate cache_entry =
1:             (CacheableConglomerate) conglom_cache.find(conglomid_obj);
1:         if (cache_entry != null) {
1:             conglom = cache_entry.getConglom();
1:             conglom_cache.release(cache_entry);
/////////////////////////////////////////////////////////////////////////
1:         conglom_cache.ageOut();
/////////////////////////////////////////////////////////////////////////
1:         // Insert the new entry.
1:         CacheableConglomerate conglom_entry = (CacheableConglomerate)
0:             conglom_cache.create(new Long(conglomid), conglom);
1:         conglom_cache.release(conglom_entry);
/////////////////////////////////////////////////////////////////////////
1:         CacheableConglomerate conglom_entry = (CacheableConglomerate)
0:             conglom_cache.findCached(new Long(conglomid));
1:         if (conglom_entry != null) {
1:             conglom_cache.remove(conglom_entry);
1:     /**
1:      * <p>
1:      * Get the current transaction context.
1:      * </p>
1:      *
1:      * <p>
1:      * If there is an internal transaction on the context stack, return the
1:      * internal transaction. Otherwise, if there is a nested user transaction
1:      * on the context stack, return the nested transaction. Otherwise,
1:      * return the current user transaction.
1:      * </p>
1:      *
1:      * @return a context object referencing the current transaction
1:      */
1:     RAMTransactionContext getCurrentTransactionContext() {
1:         RAMTransactionContext rtc =
0:             (RAMTransactionContext) ContextService.getContext(
1:                 AccessFactoryGlobals.RAMXACT_INTERNAL_CONTEXT_ID);
1:         if (rtc == null) {
0:             rtc = (RAMTransactionContext) ContextService.getContext(
1:                     AccessFactoryGlobals.RAMXACT_CHILD_CONTEXT_ID);
1:         }
1: 
1:         if (rtc == null) {
0:             rtc = (RAMTransactionContext) ContextService.getContext(
1:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1:         }
1: 
1:         return rtc;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		return new CacheableConglomerate(this);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:9496f49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.PersistentService;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-5996(Create readme files (cautioning users against modifying 
1:      *  database files) at database hard upgrade time)
1:      * This gets called during hard upgrade. It will create 3 readme files
1:      *  one in database directory, one in "seg0" directory and one in log
1:      *  directory. These readme files warn users against touching any of
1:      *  files associated with derby database 
1:      */
1:     public void createReadMeFiles()
1:         throws StandardException
1:     {
1:         //creating readme in "seg0" directory
1:         rawstore.createDataWarningFile();
1: 
1:         //creating readme in log directory
0:         LogFactory logFactory =(LogFactory) Monitor.findServiceModule(this, rawstore.getLogFactoryModule());
1:         logFactory.createDataWarningFile();
1: 
1:         //creating readme in root database directory
0:         DataFactory dataFactory =(DataFactory) Monitor.findServiceModule(this, rawstore.getDataFactoryModule());
0:         PersistentService ps = Monitor.getMonitor().getServiceType(rawstore);
1:         ps.createDataWarningFile(dataFactory.getStorageFactory());
1:     }
1: 	
commit:651c99e
/////////////////////////////////////////////////////////////////////////
1:         //Put a readme file in seg0 directory, alerting users to not 
1:         // touch or remove any of the files there 
1:         if(create) {
1:             rawstore.createDataWarningFile();
1:         }
1: 
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:fd20d6b
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @see org.apache.derby.iapi.store.access.AccessFactory#failover(String dbname).
1:      */
1:     public void failover(String dbname) throws StandardException {
1:         rawstore.failover(dbname);
1:     }
commit:964abfa
/////////////////////////////////////////////////////////////////////////
1:      * Start the replication master role for this database.
1:      * @param dbmaster The master database that is being replicated.
/////////////////////////////////////////////////////////////////////////
1:     public void startReplicationMaster(String dbmaster, String host, int port,
1:         rawstore.startReplicationMaster(dbmaster, host, port, replicationMode);
commit:54be3b4
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Stop the replication master role for this database.
1:      * 
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
1:     public void stopReplicationMaster() throws StandardException {
1:         rawstore.stopReplicationMaster();
1:     }
1: 
commit:4aeada8
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Start the replication master role for this database. 
1:      * @param host The hostname for the slave
1:      * @param port The port the slave is listening on
1:      * @param replicationMode The type of replication contract.
1:      * Currently only asynchronous replication is supported, but
1:      * 1-safe/2-safe/very-safe modes may be added later.
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
0:     public void startReplicationMaster(String host, int port,
1:                                        String replicationMode)
1:         throws StandardException {
0:         rawstore.startReplicationMaster(host, port, replicationMode);
1:     }
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	@exception StandardException standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		// Note: we also boot this module here since we may start Derby
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.RAMAccessManager
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access;
1: 
1: import org.apache.derby.iapi.services.cache.Cacheable;
1: import org.apache.derby.iapi.services.cache.CacheableFactory;
1: import org.apache.derby.iapi.services.cache.CacheFactory;
1: import org.apache.derby.iapi.services.cache.CacheManager;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
1: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.services.property.PropertyFactory;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.TransactionInfo;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.Attribute;
1: 
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.Properties;
1: 
0: import java.io.File;
1: import java.io.Serializable;
1: 
1: 
1: public abstract class RAMAccessManager
1:     implements AccessFactory, 
1:                CacheableFactory, 
1:                ModuleControl, 
1:                PropertySetCallback
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:     The raw store that this access manager uses.
1:     **/
1:     private RawStoreFactory rawstore;
1: 
1:     /**
1:     Hash table on primary implementation type.
1:     **/
0:     private Hashtable implhash;
1: 
1:     /**
1:     Hash table on primary format.
1:     **/
0:     private Hashtable formathash;
1: 
1: 	/**
1: 	Service properties.  These are supplied from ModuleControl.boot(),
1: 	and ultimately come from the service.properties file.
1: 	By convention, these properties are passed down to all modules
1: 	booted by this one.  If this module needs to pass specific instructions
1: 	to its sub-modules, it should create a new Properties object with
1: 	serviceProperties as its default (so that the rest of the modules
1: 	that are looking at it don't see the properties that this module
1: 	needs to add).
1: 	**/
1: 	private Properties serviceProperties;
1: 
1:     /**
1:      * Default locking policy for the entire system.
1:      **/
1:     LockingPolicy system_default_locking_policy;
1: 
1: 	/**	
1: 		The object providing the properties like behaviour
1: 		that is transactional.
1: 	*/
1: 	private PropertyConglomerate xactProperties;
1: 	private PropertyFactory 	pf;
1: 
1:     protected LockingPolicy table_level_policy[];
1:     protected LockingPolicy record_level_policy[];
1: 
1: 
1:     /**
1:      * A map of the implementation specific id to conglomerate object.
1:      * <p>
1:      * A map of the implementation specific id to conglomerate object.
1:      * The id is encoded into the conglomerate number, and then used to
1:      * pick the right implementation of the conglomerate.  It is then
1:      * up to the conglomerate implementation to retrieve it's stored 
1:      * representation from disk.
1:      *
1:      * An internal mapping of the encoding of conglomerate identity in the
1:      * conglomerate number to the actual conglomerate implementation.  Encoding
1:      * this means that we can't dynamically add conglomerate implementations
1:      * into the system, so when we want to do that this mapping will have to
1:      * be more dynamic - but for now store knows exactly what implementations
1:      * there are.
1:      **/
1:     protected ConglomerateFactory conglom_map[];
1: 
1:     /**
1:      * Cache of Conglomerate objects, keyed by conglom id.  Used to speed up
1:      * subsquent open of conglomerates, first open will need to call the 
1:      * conglomerate to read and return it's description.
1:      **/
1:     private CacheManager    conglom_cache;
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     public RAMAccessManager()
1:     {
1:         // Intialize the hash tables that hold the access methods that
1:         // this access manager knows about.
0:         implhash   = new Hashtable();
0:         formathash = new Hashtable();
1:     }
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Return the default locking policy for this access manager.
1:      *
1: 	 * @return the default locking policy for this accessmanager.
1:      **/
1:     protected LockingPolicy getDefaultLockingPolicy()
1:     {
1:         return(system_default_locking_policy);
1:     }
1: 
1: 
1:     RawStoreFactory getRawStore()
1:     {
1:         return rawstore;
1:     }
1: 
1: 
1: 	PropertyConglomerate getTransactionalProperties()
1:     {
1: 		return xactProperties;
1: 	}
1: 
1:     private void boot_load_conglom_map()
1:         throws StandardException
1:     {
1:         // System.out.println("before new code.");
1: 
1:         conglom_map = new ConglomerateFactory[2];
1: 
1: 		// Find the appropriate factory for the desired implementation.
1: 		MethodFactory mfactory = findMethodFactoryByImpl("heap");
1: 
1: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "heap");
1:         }
1: 
1:         conglom_map[ConglomerateFactory.HEAP_FACTORY_ID] = 
1:             (ConglomerateFactory) mfactory;
1: 
1: 		// Find the appropriate factory for the desired implementation.
1: 		mfactory = findMethodFactoryByImpl("BTREE");
1: 
1: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "BTREE");
1:         }
1:         conglom_map[ConglomerateFactory.BTREE_FACTORY_ID] = 
1:             (ConglomerateFactory) mfactory;
1: 
1:         // System.out.println("conglom_map[0] = " + conglom_map[0]);
1:         // System.out.println("conglom_map[1] = " + conglom_map[1]);
1:     }
1: 
1: 
1: 
1: 
1:     /***************************************************************************
1:     ** Abstract Methods of RAMAccessManager, interfaces that control locking
1:     ** level of the system.
1:     ****************************************************************************
1:     */
1: 
1:     /**
1:      * Return the locking level of the system.
1:      * <p>
1:      * This routine controls the lowest level of locking enabled for all locks
1:      * for all tables accessed through this accessmanager.  The concrete 
1:      * implementation may set this value always to table level locking for
1:      * a client configuration, or it may set it to row level locking for a
1:      * server configuration.
1:      * <p>
1:      * If TransactionController.MODE_RECORD is returned table may either be
1:      * locked at table or row locking depending on the type of access expected
1:      * (ie. level 3 will require table locking for heap scans.)
1:      *
1: 	 * @return TransactionController.MODE_TABLE if only table locking allowed,
1:      *         else returns TransactionController.MODE_RECORD.
1:      *
1:      **/
1:     abstract protected int getSystemLockLevel();
1: 
1:     /**
1:      * Query property system to get the System lock level.
1:      * <p>
1:      * This routine will be called during boot after access has booted far 
1:      * enough, to allow access to the property conglomerate.  This routine
1:      * will call the property system and set the value to be returned by
1:      * getSystemLockLevel().
1:      * <p>
1:      *
1: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     abstract protected void bootLookupSystemLockLevel(
1:     TransactionController tc)
1: 		throws StandardException;
1: 
1:     /**************************************************************************
1:      * Routines to map to/from conglomid/containerid:
1:      **************************************************************************
1:      */
1:     private long conglom_nextid = 0;
1: 
1:     /**
1:      * Return next conglomid to try to add the container with.
1:      * <p>
1:      * The conglomerate number has 2 parts.  The low 4 bits are used to 
1:      * encode the factory which "owns" the conglomerate.  The high 60 bits
1:      * are used as a normal unique id mechanism.
1:      * <p>
1:      * So for example if the next id to assign is 0x54 the following will
1:      * be the conglomid:
1:      *     if a HEAP  (factory 0) - 0x540
1:      *     if a BTREE (factory 1) - 0x541
1:      *
1:      * And the next id assigned will be:
1:      *     if a HEAP  (factory 0) - 0x550
1:      *     if a BTREE (factory 1) - 0x551
1:      *
1:      * @param factory_type factory id as gotten from getConglomerateFactoryId()
1:      *
1: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected long getNextConglomId(int   factory_type)
1: 		throws StandardException
1:     {
1:         long    conglomid;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             // current code depends on this range, if we ever need to expand the
1:             // range we can claim bits from the high order of the long.
1: 
1:             SanityManager.ASSERT(factory_type >= 0x00 && factory_type <= 0x0f);
1:         }
1: 
1:         synchronized (conglom_cache)
1:         {
1:             if (conglom_nextid == 0)
1:             {
1:                 // shift out the factory id and then add 1.
1:                 conglom_nextid = (rawstore.getMaxContainerId() >> 4) + 1;
1:             }
1: 
1:             conglomid = conglom_nextid++;
1:         }
1: 
1:         // shift in the factory id and then return the conglomid.
1:         
1:         return((conglomid << 4) | factory_type);
1:     }
1: 
1:     /**
1:      * Bump the conglomid.
1:      * <p>
1:      * For some reason we have found that the give conglomid already exists
1:      * in the directory so just bump the next conglomid to greater than this
1:      * one.  The algorithm to store and retrieve the last conglomid is not
1:      * transactional as we don't want to pay the overhead for such an algorithm
1:      * on every ddl statement - so it is possible to "lose" an update to the
1:      * counter if we crash at an inopportune moment.  In general the upper
1:      * level store code will just handle the error from addContainer which 
1:      * says there already exists a conglom with that id, update the next
1:      * conglomid and then try again.
1:      * <p>
1:      *
1:      * @param conglomid The conglomid which already exists.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     // currently not used, but this is one idea on how to handle 
1:     // non-transactional update of the nextid field, just handle the error
1:     // if we try to create a conglom and find the container already exists.
1:     /*
1:     private void handleConglomidExists(
1:     long   conglomid)
1: 		throws StandardException
1:     {
1:         synchronized (conglom_cache)
1:         {
1:             conglom_nextid = ((conglomid >> 4) + 1);
1:         }
1:     }
1:     */
1: 
1:     /**
1:      * Given a conglomid, return the factory which "owns" it.
1:      * <p>
1:      * A simple lookup on the boot time built table which maps the low order
1:      * 4 bits into which factory owns the conglomerate.
1:      * <p>
1:      *
1:      * @param conglomid The conglomerate id of the conglomerate to look up.
1:      *
1: 	 * @return The ConglomerateFactory which "owns" this conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     private ConglomerateFactory getFactoryFromConglomId(
1:     long    conglom_id)
1: 		throws StandardException
1:     {
1:         try
1:         {
1:             return(conglom_map[((int) (0x0f & conglom_id))]);
1:         }
1:         catch (java.lang.ArrayIndexOutOfBoundsException e)
1:         {
1:             // just in case language passes in a bad factory id.
1: 			throw StandardException.newException(
1:                 SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
0:                 new Long(conglom_id));
1:         }
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Conglomerate Cache routines:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * ACCESSMANAGER CONGLOMERATE CACHE - 
1:      * <p>
1:      * Every conglomerate in the system is described by an object which 
1:      * implements Conglomerate.  This object basically contains the parameters
1:      * which describe the metadata about the conglomerate that store needs
1:      * to know - like types of columns, number of keys, number of columns, ...
1:      * <p>
1:      * It is up to each conglomerate to maintain it's own description, and
1:      * it's factory must be able to read this info from disk and return it
1:      * from the ConglomerateFactory.readConglomerate() interface.
1:      * <p>
1:      * This cache simply maintains an in memory copy of these conglomerate
1:      * objects, key'd by conglomerate id.  By caching, this avoids the cost
1:      * of reading the conglomerate info from disk on each subsequent query
1:      * which accesses the conglomerate.
1:      * <p>
1:      * The interfaces and internal routines which deal with this cache are:
1:      * conglomCacheInit() - initializes the cache at boot time.
1:      *
1:      *
1:      *
1:      **/
1: 
1:     /**
1:      * Initialize the conglomerate cache.
1:      * <p>
1:      * Simply calls the cache manager to create the cache with some hard
1:      * coded defaults for size.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void conglomCacheInit()
1:         throws StandardException
1:     {
1:         // Get a cache factory to create the conglomerate cache.
1: 		CacheFactory cf = 
0:             (CacheFactory) Monitor.startSystemModule(
1:                  org.apache.derby.iapi.reference.Module.CacheFactory);
1: 
1:         // Now create the conglomerate cache.
1: 
1: 	    conglom_cache =
1:            cf.newCacheManager(
1:                this, AccessFactoryGlobals.CFG_CONGLOMDIR_CACHE, 200, 300);
1: 
1:     }
1: 
1:     /**
1:      * Find a conglomerate by conglomid in the cache.
1:      * <p>
1:      * Look for a conglomerate given a conglomid.  If in cache return it,
1:      * otherwise fault in an entry by asking the owning factory to produce
1:      * an entry.
1:      * <p>
1:      *
1: 	 * @return The conglomerate object identified by "conglomid".
1:      *
1:      * @param conglomid The conglomerate id of the conglomerate to look up.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     /* package */ Conglomerate conglomCacheFind(
0:     TransactionManager  xact_mgr,
0:     long                conglomid)
1:         throws StandardException
1:     {
1:         Conglomerate conglom       = null;
0:         Long         conglomid_obj = new Long(conglomid);
1: 
1:         synchronized (conglom_cache)
1:         {
0:             CacheableConglomerate cache_entry = 
0:                 (CacheableConglomerate) conglom_cache.findCached(conglomid_obj);
1: 
0:             if (cache_entry != null)
1:             {
0:                 conglom = cache_entry.getConglom();
0:                 conglom_cache.release(cache_entry);
1: 
0:                 // SanityManager.DEBUG_PRINT("find", "find hit : " + conglomid);
1:             }
0:             else
1:             {
0:                 // SanityManager.DEBUG_PRINT("find", "find miss: " + conglomid);
1: 
0:                 // If not in cache - ask the factory for it and insert it.
1: 
0:                 conglom = 
0:                     getFactoryFromConglomId(conglomid).readConglomerate(
0:                         xact_mgr, new ContainerKey(0, conglomid));
1: 
0:                 if (conglom != null)
1:                 {
0:                     // on cache miss, put the missing conglom in the cache.
0:                     cache_entry = (CacheableConglomerate) 
0:                         this.conglom_cache.create(conglomid_obj, conglom);
0:                     this.conglom_cache.release(cache_entry);
1:                 }
1:             }
1:         }
1: 
1:         return(conglom);
1:     }
1: 
1:     /**
1:      * Invalide the current Conglomerate Cache.
1:      * <p>
1:      * Abort of certain operations will invalidate the contents of the 
1:      * cache.  Longer term we could just invalidate those entries, but
1:      * for now just invalidate the whole cache.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     /* package */ protected void conglomCacheInvalidate()
1:         throws StandardException
1:     {
1:         synchronized (conglom_cache)
1:         {
0:             conglom_cache.ageOut();
1:         }
1: 
1:         return;
1:     }
1: 
1:     /**
0:      * Update a conglomerate directory entry.
1:      * <p>
0:      * Update the Conglom column of the Conglomerate Directory.  The 
0:      * Conglomerate with id "conglomid" is replaced by "new_conglom".
1:      * <p>
1:      *
1:      * @param conglomid   The conglomid of conglomerate to replace.
0:      * @param new_conglom The new Conglom to update the conglom column to.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     /* package */ void conglomCacheUpdateEntry(
1:     long            conglomid, 
0:     Conglomerate    new_conglom) 
1:         throws StandardException
1:     {
0:         Long         conglomid_obj = new Long(conglomid);
1: 
1:         synchronized (conglom_cache)
1:         {
0:             // remove the current entry
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.findCached(conglomid_obj);
1: 
0:             if (conglom_entry != null)
0:                 conglom_cache.remove(conglom_entry);
1: 
0:             // insert the updated entry.
0:             conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.create(conglomid_obj, new_conglom);
0:             conglom_cache.release(conglom_entry);
1:         }
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * Add a newly created conglomerate to the cache.
1:      * <p>
1:      *
1:      * @param conglomid   The conglomid of conglomerate to replace.
1:      * @param conglom     The Conglom to add.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     /* package */ void conglomCacheAddEntry(
1:     long            conglomid,
1:     Conglomerate    conglom)
1:         throws StandardException
1:     {
1:         synchronized (conglom_cache)
1:         {
0:             // insert the updated entry.
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.create(new Long(conglomid), conglom);
0:             conglom_cache.release(conglom_entry);
1:         }
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * Remove an entry from the cache.
1:      * <p>
1:      *
1:      * @param conglomid   The conglomid of conglomerate to replace.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     /* package */ void conglomCacheRemoveEntry(long conglomid)
1:         throws StandardException
1:     {
1:         synchronized (conglom_cache)
1:         {
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.findCached(new Long(conglomid));
1: 
0:             if (conglom_entry != null)
0:                 conglom_cache.remove(conglom_entry);
1:         }
1: 
1:         return;
1:     }
1: 
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods implementing AccessFactory Interface:
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	Database creation finished.  Tell RawStore.
0: 	@exception StandardException cloudscape standard error policy
1: 	*/
1: 	public void createFinished() throws StandardException
1: 	{
1: 		rawstore.createFinished();
1: 	}
1: 
1:     /**
1:     Find an access method that implements a format type.
1:     @see AccessFactory#findMethodFactoryByFormat
1:     **/
1:     public MethodFactory findMethodFactoryByFormat(UUID format)
1:     {
1:         MethodFactory factory;
1:         
1:         // See if there's an access method that supports the desired
1:         // format type as its primary format type.
0:         factory = (MethodFactory) formathash.get(format);
1:         if (factory != null)
1:             return factory;
1: 
1:         // No primary format.  See if one of the access methods
1:         // supports it as a secondary format.
0:         Enumeration e = formathash.elements();
1:         while (e.hasMoreElements())
1:         {
0:             factory = (MethodFactory) e.nextElement();
1:             if (factory.supportsFormat(format))
1:                 return factory;
1:         }
1: 
1:         // No such implementation.
1:         return null;
1:     }
1: 
1:     /**
1:     Find an access method that implements an implementation type.
1:     @see AccessFactory#findMethodFactoryByImpl
1:     **/
1:     public MethodFactory findMethodFactoryByImpl(String impltype)
1:         throws StandardException
1:     {
1:         MethodFactory factory;
1:         
1:         // See if there's an access method that supports the desired
1:         // implementation type as its primary implementation type.
0: 		Object value = implhash.get(impltype);
1: 
1: 
0:         factory = (MethodFactory) implhash.get(impltype);
1:         if (factory != null)
1: 				return factory;
1: 
1:         // No primary implementation.  See if one of the access methods
1:         // supports the implementation type as a secondary.
0:         Enumeration e = implhash.elements();
1:         while (e.hasMoreElements())
1:         {
0:             factory = (MethodFactory) e.nextElement();
1:             if (factory.supportsImplementation(impltype))
1:                 return factory;
1:         }
1: 		factory = null;
1: 
1: 		// try and load an implementation.  a new properties object needs
1: 		// to be created to hold the conglomerate type property, since
1: 		// that value is specific to the conglomerate we want to boot, not
1: 		// to the service as a whole
1: 		Properties conglomProperties = new Properties(serviceProperties);
1: 		conglomProperties.put(AccessFactoryGlobals.CONGLOM_PROP, impltype);
1: 
1: 		try {
1: 			factory = 
0:                (MethodFactory) Monitor.bootServiceModule(
1:                     false, this, MethodFactory.MODULE, 
1:                     impltype, conglomProperties);
1: 		} catch (StandardException se) {
1: 			if (!se.getMessageId().equals(SQLState.SERVICE_MISSING_IMPLEMENTATION))
1: 				throw se;
1: 		}
1: 
1: 		conglomProperties = null;
1: 
1: 		if (factory != null) {
1: 			registerAccessMethod(factory);
1: 			return factory;
1: 		}
1: 
1:         // No such implementation.
1:         return null;
1:     }
1: 
1: 	public LockFactory getLockFactory() {
1: 		return rawstore.getLockFactory();
1: 	}
1: 
1: 
1:     public TransactionController getTransaction(
1:     ContextManager cm)
1:         throws StandardException
1:     {
1:         return getAndNameTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:     }
1: 
1:     public TransactionController getAndNameTransaction(
1:     ContextManager cm, String transName)
1:         throws StandardException
1:     {
1:         if (cm == null)
1:             return null;  // XXX (nat) should throw exception
1: 
1:         // See if there's already a transaction context.
1:         RAMTransactionContext rtc = (RAMTransactionContext)
1:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1: 
1:         if (rtc == null)
1:         {
1:             // No transaction context.  Create or find a raw store transaction,
1:             // make a context for it, and push the context.  Note this puts the
1:             // raw store transaction context above the access context, which is
1:             // required for error handling assumptions to be correct.
1:             Transaction rawtran = rawstore.findUserTransaction(cm, transName);
1:             RAMTransaction rt      = new RAMTransaction(this, rawtran, null);
1: 
1:             rtc = 
1:                 new RAMTransactionContext(
1:                     cm, 
1:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
1:                     rt, false /* abortAll */);
1: 
1: 			TransactionController tc = rtc.getTransaction();
1: 
1: 			if (xactProperties != null)
1:             {
1: 				rawtran.setup(tc);
1: 				tc.commit();
1: 			}
1: 
1:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
1: 
1: 			tc.commit();
1: 
1: 			return tc;
1:         }
1:         return rtc.getTransaction();
1:     }
1: 
1: 	/**
1:      * Start a global transaction.
1:      * <p>
1: 	 * Get a transaction controller with which to manipulate data within
1: 	 * the access manager.  Implicitly creates an access context.
1:      * <p>
1:      * Must only be called if no other transaction context exists in the
1:      * current context manager.  If another transaction exists in the context
1:      * an exception will be thrown.
1:      * <p>
1:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:      * in the path.  
1:      *
1:      * @param cm        The context manager for the current context.
1:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:      * @param global_id the global transaction identifier part of XID - ie.
1:      *                  Xid.getGlobalTransactionId().
1:      * @param branch_id The branch qualifier of the Xid - ie. 
1:      *                  Xid.getBranchQaulifier()
1:      * 	
1: 	 * @exception StandardException Standard exception policy.
1: 	 * @see TransactionController
1: 	 **/
1: 	public /* XATransactionController */ Object startXATransaction(
1:     ContextManager  cm, 
1:     int             format_id,
1:     byte[]          global_id,
1:     byte[]          branch_id)
1: 		throws StandardException
1:     {
1:         RAMTransaction xa_tc = null;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(global_id != null);
1:             SanityManager.ASSERT(branch_id != null);
1:         }
1: 
1:         if (cm == null)
1:             return null;  // XXX (nat) should throw exception
1: 
1:         // See if there's already a transaction context.
1:         RAMTransactionContext rtc = (RAMTransactionContext) 
1:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
1: 
1:         if (rtc == null)
1:         {
1:             // No transaction context.  Create or find a raw store transaction,
1:             // make a context for it, and push the context.  Note this puts the
1:             // raw store transaction context above the access context, which is
1:             // required for error handling assumptions to be correct.
1:             Transaction rawtran = 
1:                 rawstore.startGlobalTransaction(
1:                     cm, format_id, global_id, branch_id);
1: 
1:             xa_tc                    = new RAMTransaction(this, rawtran, null);
1: 
1:             rtc = 
1:                 new RAMTransactionContext(
1:                     cm, 
1:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
1:                     xa_tc, false /* abortAll */);
1: 
1:             // RESOLVE - an XA transaction can only commit once so, if we
1:             // acquire readlocks.
1: 
1: 			if (xactProperties != null) 
1:             {
1: 				rawtran.setup(xa_tc);
1: 
1:                 // HACK - special support has been added to the commitNoSync
1:                 // of a global xact, to allow committing of read only xact, 
1:                 // which will allow subsequent activity on the xact keeping
1:                 // the same global transaction id.
1:                 xa_tc.commitNoSync(
1:                     TransactionController.RELEASE_LOCKS |
1:                     TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1: 			}
1: 
1:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
1: 
1:             // HACK - special support has been added to the commitNoSync
1:             // of a global xact, to allow committing of read only xact, 
1:             // which will allow subsequent activity on the xact keeping
1:             // the same global transaction id.
1:             xa_tc.commitNoSync(
1:                 TransactionController.RELEASE_LOCKS |
1:                 TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1:         }
0:         else
1:         {
1:             // throw an error.
1:             if (SanityManager.DEBUG)
1:                 SanityManager.THROWASSERT(
1:                     "RAMTransactionContext found on stack.");
1:         }
1: 
1:         return(xa_tc);
1:     }
1: 
1: 
1:     /**
1:      * Return the XAResourceManager associated with this AccessFactory.
1:      * <p>
1:      * Returns an object which can be used to implement the "offline" 
1:      * 2 phase commit interaction between the accessfactory and outstanding
1:      * transaction managers taking care of in-doubt transactions.
1:      *
1:      * @return The XAResourceManager associated with this accessfactory.
1:      *
1:      **/
1: 	public /* XAResourceManager */ Object getXAResourceManager()
1:         throws StandardException
1:     {
1:         return(rawstore.getXAResourceManager());
1:     }
1: 
1:     public void registerAccessMethod(MethodFactory factory)
1:     {
1:         // Put the access method's primary implementation type in
1:         // a hash table so we can find it quickly.
1:         implhash.put(factory.primaryImplementationType(), factory);
1: 
1:         // Put the access method's primary format in a hash table
1:         // so we can find it quickly.
1:         formathash.put(factory.primaryFormat(), factory);
1:     }
1: 
1: 	public boolean isReadOnly()
1: 	{
1: 		return rawstore.isReadOnly();
1: 	}
1: 
1: 	private void addPropertySetNotification(PropertySetCallback who, TransactionController tc) {
1: 
1: 		pf.addPropertySetNotification(who);
1: 		
1: 		// set up the initial values by calling the validate and apply methods.
1: 		// the map methods are not called as they will have been called
1: 		// at runtime when the user set the property.
0: 		Dictionary d = new Hashtable();
1: 		try {
1: 			xactProperties.getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
1: 		} catch (StandardException se) {
1: 			return;
1: 		}
1: 
1: 		boolean dbOnly = PropertyUtil.isDBOnly(d);
1: 
1: 		who.init(dbOnly, d);
1: 	}
1: 
1: 	public TransactionInfo[] getTransactionInfo()
1: 	{
1: 		return rawstore.getTransactionInfo();
1: 	}
1: 
1: 	public void freeze() throws StandardException
1: 	{
1: 		rawstore.freeze();
1: 	}
1: 
1: 	public void unfreeze() throws StandardException
1: 	{
1: 		rawstore.unfreeze();
1: 	}
1: 
0: 	public void backup(String backupDir) throws StandardException
1: 	{
0: 		rawstore.backup(backupDir);
1: 	}
1: 
0: 	public void backup(File backupDir) throws StandardException
1: 	{
0: 		rawstore.backup(backupDir);
1: 	}
1: 
1: 
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean deleteOnlineArchivedLogFiles)
1: 		throws StandardException 
1: 	{
0: 		rawstore.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
1: 	}
1: 
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean deleteOnlineArchivedLogFiles) 
1: 		throws StandardException
1: 	{
0: 		rawstore.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
1: 	}	
1: 
1: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1: 		throws StandardException
1: 	{
1: 		rawstore.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
1: 	}
1: 
1: 
1: 
1: 	public void checkpoint() throws StandardException
1: 	{
1: 		rawstore.checkpoint();
1: 	}
1: 
1: 	public void waitForPostCommitToFinishWork()
1: 	{
1: 		rawstore.getDaemon().waitUntilQueueIsEmpty();
1: 	}
1: 
1:     /**************************************************************************
1:      * Public Methods implementing ModuleControl Interface:
1:      **************************************************************************
1:      */
1: 	public void boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		this.serviceProperties = startParams;
1: 
1:         boot_load_conglom_map();
1: 
1:         if (create)
1:         {
1:             // if we are creating the db, then just start the conglomid's at
1:             // 1, and proceed from there.  If not create, we delay 
1:             // initialization of this until the first ddl which needs a new
1:             // id.
1:             conglom_nextid = 1;
1:         }
1: 
1:         // Access depends on a Raw Store implementations.  Load it.
1:         //
0:         rawstore = (RawStoreFactory) Monitor.bootServiceModule(
1:             create, this, RawStoreFactory.MODULE, serviceProperties);
1: 
0: 		// Note: we also boot this module here since we may start cloudscape
1: 		// system from store access layer, as some of the unit test case,
1: 		// not from JDBC layer.(See
1: 		// /protocol/Database/Storage/Access/Interface/T_AccessFactory.java)
1: 		// If this module has already been booted by the JDBC layer, this will 
1: 		// have no effect at all.
0: 		Monitor.bootServiceModule(
1:             create, this, org.apache.derby.iapi.reference.Module.PropertyFactory, 
1:             startParams);
1: 
1:         // Create the in-memory conglomerate directory
1: 
1:         conglomCacheInit();
1: 
1:         // Read in the conglomerate directory from the conglom conglom
1:         // Create the conglom conglom from within a separate system xact
1:         RAMTransaction tc =
1:             (RAMTransaction) getAndNameTransaction(
0:                 ContextService.getFactory().getCurrentContextManager(),
1:                 AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:         // looking up lock_mode is dependant on access booting, but
1:         // some boot routines need lock_mode and
1:         // system_default_locking_policy, so during boot do table level
1:         // locking and then look up the "right" locking level.
1: 
1:         int lock_mode = LockingPolicy.MODE_CONTAINER;
1: 
1:         system_default_locking_policy =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 lock_mode,
1:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1: 
1: 
1:         // RESOLVE - code reduction - get rid of this table, and somehow
1:         // combine it with the raw store one.
1: 
1:         table_level_policy = new LockingPolicy[6];
1: 
1:         table_level_policy[TransactionController.ISOLATION_NOLOCK] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_NOLOCK, true);
1: 
1:         table_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
1: 
1:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_READ_COMMITTED, true);
1: 
1:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:                 true);
1: 
1:         table_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
1: 
1:         table_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_CONTAINER,
1:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1: 
1:         record_level_policy = new LockingPolicy[6];
1: 
1:         record_level_policy[TransactionController.ISOLATION_NOLOCK] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_NOLOCK, true);
1: 
1:         record_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
1: 
1:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_READ_COMMITTED, true);
1: 
1:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:                 true);
1: 
1:         record_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
1: 
1:         record_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             for (int i = 0;
1:                  i < TransactionController.ISOLATION_SERIALIZABLE;
1:                  i++)
1:             {
1:                 SanityManager.ASSERT(
1:                     table_level_policy[i] != null,
1:                     "table_level_policy[" + i + "] is null");
1:                 SanityManager.ASSERT(
1:                     record_level_policy[i] != null,
1:                     "record_level_policy[" + i + "] is null");
1:             }
1:         }
1: 
1:         tc.commit();
1: 
1:         // set up the property validation
1:         pf = (PropertyFactory) 
0:             Monitor.findServiceModule(
1:                 this, org.apache.derby.iapi.reference.Module.PropertyFactory);
1: 
1:         // set up the transaction properties.  On J9, over NFS, runing on a
1:         // power PC coprossor, the directories were created fine, but create
1:         // db would fail when trying to create this first file in seg0.
1:         xactProperties = new PropertyConglomerate(tc, create, startParams, pf);
1: 
1:         // see if there is any properties that raw store needs to know
1:         // about
1:         rawstore.getRawStoreProperties(tc);
1: 
1:         // now that access and raw store are booted, do the property lookup
1:         // which may do conglomerate access.
1:         bootLookupSystemLockLevel(tc);
1: 
1:         lock_mode =
1:             (getSystemLockLevel() == TransactionController.MODE_TABLE ?
1:                  LockingPolicy.MODE_CONTAINER : LockingPolicy.MODE_RECORD);
1: 
1:         system_default_locking_policy =
1:             tc.getRawStoreXact().newLockingPolicy(
1:                 lock_mode,
1:                 TransactionController.ISOLATION_SERIALIZABLE, true);
1: 
1:         // set up the callbacl for the lock manager with initialization
1:         addPropertySetNotification(getLockFactory(), tc);
1: 
1:         // make sure user cannot change these properties
1:         addPropertySetNotification(this,tc);
1: 
1:         tc.commit();
1: 
1:         tc.destroy();
1:         tc = null;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             // RESOLVE - (mikem) currently these constants need to be the
1:             // same, but for modularity reasons there are 2 sets.  Probably
1:             // should only be one set.  For now just make sure they are the
1:             // same value.
1:             SanityManager.ASSERT(
1:                 TransactionController.OPENMODE_USE_UPDATE_LOCKS ==
1:                 ContainerHandle.MODE_USE_UPDATE_LOCKS);
1:             SanityManager.ASSERT(
1:                 TransactionController.OPENMODE_SECONDARY_LOCKED ==
1:                 ContainerHandle.MODE_SECONDARY_LOCKED);
1:             SanityManager.ASSERT(
1:                 TransactionController.OPENMODE_BASEROW_INSERT_LOCKED ==
1:                 ContainerHandle.MODE_BASEROW_INSERT_LOCKED);
1:             SanityManager.ASSERT(
1:                 TransactionController.OPENMODE_FORUPDATE ==
1:                 ContainerHandle.MODE_FORUPDATE);
1:             SanityManager.ASSERT(
1:                 TransactionController.OPENMODE_FOR_LOCK_ONLY ==
1:                 ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY);
1:         }
1: 	}
1: 
1:     public void stop()
1:     {
1:     }
1: 
1:     /* Methods of the PropertySetCallback interface */
1: 
1:     // This interface is implemented to ensure the user cannot change the
1:     // encryption provider or algorithm.
1: 
1: 	public void init(boolean dbOnly, Dictionary p)
1:     {
1:     }
1: 
1:     public boolean validate(String key, Serializable value, Dictionary p)
1: 		 throws StandardException
1:     {
1:         if (key.equals(Attribute.CRYPTO_ALGORITHM))
1:         {
1:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_ALGORITHM);
1: 		}
1:         if (key.equals(Attribute.CRYPTO_PROVIDER))
1:         {
1:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_PROVIDER);
1: 		}
1:         return true;
1:     }
1: 
1:     public Serviceable apply(String key, Serializable value, Dictionary p)
1: 		 throws StandardException
1:     {
1:         return null;
1:     }
1: 
1:     public Serializable map(String key, Serializable value, Dictionary p)
1: 		 throws StandardException
1:     {
1:         return null;
1:     }
1: 
1:     // ///////////////////////////////////////////////////////////////
1: 
1: 	/*
1: 	** CacheableFactory interface
1: 	*/
1: 
1: 	public Cacheable newCacheable(CacheManager cm) {
0: 		return new CacheableConglomerate();
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access;
0: 
0: import org.apache.derby.iapi.services.cache.Cacheable;
0: import org.apache.derby.iapi.services.cache.CacheableFactory;
0: import org.apache.derby.iapi.services.cache.CacheFactory;
0: import org.apache.derby.iapi.services.cache.CacheManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.services.property.PropertyFactory;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.TransactionInfo;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Attribute;
0: 
0: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Properties;
0: 
0: import java.io.File;
0: import java.io.Serializable;
0: 
0: 
0: public abstract class RAMAccessManager
0:     implements AccessFactory, 
0:                CacheableFactory, 
0:                ModuleControl, 
0:                PropertySetCallback
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:     The raw store that this access manager uses.
0:     **/
0:     private RawStoreFactory rawstore;
0: 
0:     /**
0:     Hash table on primary implementation type.
0:     **/
0:     private Hashtable implhash;
0: 
0:     /**
0:     Hash table on primary format.
0:     **/
0:     private Hashtable formathash;
0: 
0: 	/**
0: 	Service properties.  These are supplied from ModuleControl.boot(),
0: 	and ultimately come from the service.properties file.
0: 	By convention, these properties are passed down to all modules
0: 	booted by this one.  If this module needs to pass specific instructions
0: 	to its sub-modules, it should create a new Properties object with
0: 	serviceProperties as its default (so that the rest of the modules
0: 	that are looking at it don't see the properties that this module
0: 	needs to add).
0: 	**/
0: 	private Properties serviceProperties;
0: 
0:     /**
0:      * Default locking policy for the entire system.
0:      **/
0:     LockingPolicy system_default_locking_policy;
0: 
0: 	/**	
0: 		The object providing the properties like behaviour
0: 		that is transactional.
0: 	*/
0: 	private PropertyConglomerate xactProperties;
0: 	private PropertyFactory 	pf;
0: 
0:     protected LockingPolicy table_level_policy[];
0:     protected LockingPolicy record_level_policy[];
0: 
0: 
0:     /**
0:      * A map of the implementation specific id to conglomerate object.
0:      * <p>
0:      * A map of the implementation specific id to conglomerate object.
0:      * The id is encoded into the conglomerate number, and then used to
0:      * pick the right implementation of the conglomerate.  It is then
0:      * up to the conglomerate implementation to retrieve it's stored 
0:      * representation from disk.
0:      *
0:      * An internal mapping of the encoding of conglomerate identity in the
0:      * conglomerate number to the actual conglomerate implementation.  Encoding
0:      * this means that we can't dynamically add conglomerate implementations
0:      * into the system, so when we want to do that this mapping will have to
0:      * be more dynamic - but for now store knows exactly what implementations
0:      * there are.
0:      **/
0:     protected ConglomerateFactory conglom_map[];
0: 
0:     /**
0:      * Cache of Conglomerate objects, keyed by conglom id.  Used to speed up
0:      * subsquent open of conglomerates, first open will need to call the 
0:      * conglomerate to read and return it's description.
0:      **/
0:     private CacheManager    conglom_cache;
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     public RAMAccessManager()
0:     {
0:         // Intialize the hash tables that hold the access methods that
0:         // this access manager knows about.
0:         implhash   = new Hashtable();
0:         formathash = new Hashtable();
0:     }
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return the default locking policy for this access manager.
0:      *
0: 	 * @return the default locking policy for this accessmanager.
0:      **/
0:     protected LockingPolicy getDefaultLockingPolicy()
0:     {
0:         return(system_default_locking_policy);
0:     }
0: 
0: 
0:     RawStoreFactory getRawStore()
0:     {
0:         return rawstore;
0:     }
0: 
0: 
0: 	PropertyConglomerate getTransactionalProperties()
0:     {
0: 		return xactProperties;
0: 	}
0: 
0:     private void boot_load_conglom_map()
0:         throws StandardException
0:     {
0:         // System.out.println("before new code.");
0: 
0:         conglom_map = new ConglomerateFactory[2];
0: 
0: 		// Find the appropriate factory for the desired implementation.
0: 		MethodFactory mfactory = findMethodFactoryByImpl("heap");
0: 
0: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "heap");
0:         }
0: 
0:         conglom_map[ConglomerateFactory.HEAP_FACTORY_ID] = 
0:             (ConglomerateFactory) mfactory;
0: 
0: 		// Find the appropriate factory for the desired implementation.
0: 		mfactory = findMethodFactoryByImpl("BTREE");
0: 
0: 		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, "BTREE");
0:         }
0:         conglom_map[ConglomerateFactory.BTREE_FACTORY_ID] = 
0:             (ConglomerateFactory) mfactory;
0: 
0:         // System.out.println("conglom_map[0] = " + conglom_map[0]);
0:         // System.out.println("conglom_map[1] = " + conglom_map[1]);
0:     }
0: 
0: 
0: 
0: 
0:     /***************************************************************************
0:     ** Abstract Methods of RAMAccessManager, interfaces that control locking
0:     ** level of the system.
0:     ****************************************************************************
0:     */
0: 
0:     /**
0:      * Return the locking level of the system.
0:      * <p>
0:      * This routine controls the lowest level of locking enabled for all locks
0:      * for all tables accessed through this accessmanager.  The concrete 
0:      * implementation may set this value always to table level locking for
0:      * a client configuration, or it may set it to row level locking for a
0:      * server configuration.
0:      * <p>
0:      * If TransactionController.MODE_RECORD is returned table may either be
0:      * locked at table or row locking depending on the type of access expected
0:      * (ie. level 3 will require table locking for heap scans.)
0:      *
0: 	 * @return TransactionController.MODE_TABLE if only table locking allowed,
0:      *         else returns TransactionController.MODE_RECORD.
0:      *
0:      **/
0:     abstract protected int getSystemLockLevel();
0: 
0:     /**
0:      * Query property system to get the System lock level.
0:      * <p>
0:      * This routine will be called during boot after access has booted far 
0:      * enough, to allow access to the property conglomerate.  This routine
0:      * will call the property system and set the value to be returned by
0:      * getSystemLockLevel().
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     abstract protected void bootLookupSystemLockLevel(
0:     TransactionController tc)
0: 		throws StandardException;
0: 
0:     /**************************************************************************
0:      * Routines to map to/from conglomid/containerid:
0:      **************************************************************************
0:      */
0:     private long conglom_nextid = 0;
0: 
0:     /**
0:      * Return next conglomid to try to add the container with.
0:      * <p>
0:      * The conglomerate number has 2 parts.  The low 4 bits are used to 
0:      * encode the factory which "owns" the conglomerate.  The high 60 bits
0:      * are used as a normal unique id mechanism.
0:      * <p>
0:      * So for example if the next id to assign is 0x54 the following will
0:      * be the conglomid:
0:      *     if a HEAP  (factory 0) - 0x540
0:      *     if a BTREE (factory 1) - 0x541
0:      *
0:      * And the next id assigned will be:
0:      *     if a HEAP  (factory 0) - 0x550
0:      *     if a BTREE (factory 1) - 0x551
0:      *
0:      * @param factory_type factory id as gotten from getConglomerateFactoryId()
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected long getNextConglomId(int   factory_type)
0: 		throws StandardException
0:     {
0:         long    conglomid;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             // current code depends on this range, if we ever need to expand the
0:             // range we can claim bits from the high order of the long.
0: 
0:             SanityManager.ASSERT(factory_type >= 0x00 && factory_type <= 0x0f);
0:         }
0: 
0:         synchronized (conglom_cache)
0:         {
0:             if (conglom_nextid == 0)
0:             {
0:                 // shift out the factory id and then add 1.
0:                 conglom_nextid = (rawstore.getMaxContainerId() >> 4) + 1;
0:             }
0: 
0:             conglomid = conglom_nextid++;
0:         }
0: 
0:         // shift in the factory id and then return the conglomid.
0:         
0:         return((conglomid << 4) | factory_type);
0:     }
0: 
0:     /**
0:      * Bump the conglomid.
0:      * <p>
0:      * For some reason we have found that the give conglomid already exists
0:      * in the directory so just bump the next conglomid to greater than this
0:      * one.  The algorithm to store and retrieve the last conglomid is not
0:      * transactional as we don't want to pay the overhead for such an algorithm
0:      * on every ddl statement - so it is possible to "lose" an update to the
0:      * counter if we crash at an inopportune moment.  In general the upper
0:      * level store code will just handle the error from addContainer which 
0:      * says there already exists a conglom with that id, update the next
0:      * conglomid and then try again.
0:      * <p>
0:      *
0:      * @param conglomid The conglomid which already exists.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     // currently not used, but this is one idea on how to handle 
0:     // non-transactional update of the nextid field, just handle the error
0:     // if we try to create a conglom and find the container already exists.
0:     /*
0:     private void handleConglomidExists(
0:     long   conglomid)
0: 		throws StandardException
0:     {
0:         synchronized (conglom_cache)
0:         {
0:             conglom_nextid = ((conglomid >> 4) + 1);
0:         }
0:     }
0:     */
0: 
0:     /**
0:      * Given a conglomid, return the factory which "owns" it.
0:      * <p>
0:      * A simple lookup on the boot time built table which maps the low order
0:      * 4 bits into which factory owns the conglomerate.
0:      * <p>
0:      *
0:      * @param conglomid The conglomerate id of the conglomerate to look up.
0:      *
0: 	 * @return The ConglomerateFactory which "owns" this conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private ConglomerateFactory getFactoryFromConglomId(
0:     long    conglom_id)
0: 		throws StandardException
0:     {
0:         try
0:         {
0:             return(conglom_map[((int) (0x0f & conglom_id))]);
0:         }
0:         catch (java.lang.ArrayIndexOutOfBoundsException e)
0:         {
0:             // just in case language passes in a bad factory id.
0: 			throw StandardException.newException(
0:                 SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
0:                 new Long(conglom_id));
0:         }
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Conglomerate Cache routines:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * ACCESSMANAGER CONGLOMERATE CACHE - 
0:      * <p>
0:      * Every conglomerate in the system is described by an object which 
0:      * implements Conglomerate.  This object basically contains the parameters
0:      * which describe the metadata about the conglomerate that store needs
0:      * to know - like types of columns, number of keys, number of columns, ...
0:      * <p>
0:      * It is up to each conglomerate to maintain it's own description, and
0:      * it's factory must be able to read this info from disk and return it
0:      * from the ConglomerateFactory.readConglomerate() interface.
0:      * <p>
0:      * This cache simply maintains an in memory copy of these conglomerate
0:      * objects, key'd by conglomerate id.  By caching, this avoids the cost
0:      * of reading the conglomerate info from disk on each subsequent query
0:      * which accesses the conglomerate.
0:      * <p>
0:      * The interfaces and internal routines which deal with this cache are:
0:      * conglomCacheInit() - initializes the cache at boot time.
0:      *
0:      *
0:      *
0:      **/
0: 
0:     /**
0:      * Initialize the conglomerate cache.
0:      * <p>
0:      * Simply calls the cache manager to create the cache with some hard
0:      * coded defaults for size.
0:      * <p>
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private void conglomCacheInit()
0:         throws StandardException
0:     {
0:         // Get a cache factory to create the conglomerate cache.
0: 		CacheFactory cf = 
0:             (CacheFactory) Monitor.startSystemModule(
0:                  org.apache.derby.iapi.reference.Module.CacheFactory);
0: 
0:         // Now create the conglomerate cache.
0: 
0: 	    conglom_cache =
0:            cf.newCacheManager(
0:                this, AccessFactoryGlobals.CFG_CONGLOMDIR_CACHE, 200, 300);
0: 
0:     }
0: 
0:     /**
0:      * Find a conglomerate by conglomid in the cache.
0:      * <p>
0:      * Look for a conglomerate given a conglomid.  If in cache return it,
0:      * otherwise fault in an entry by asking the owning factory to produce
0:      * an entry.
0:      * <p>
0:      *
0: 	 * @return The conglomerate object identified by "conglomid".
0:      *
0:      * @param conglomid The conglomerate id of the conglomerate to look up.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /* package */ Conglomerate conglomCacheFind(
0:     TransactionManager  xact_mgr,
0:     long                conglomid)
0:         throws StandardException
0:     {
0:         Conglomerate conglom       = null;
0:         Long         conglomid_obj = new Long(conglomid);
0: 
0:         synchronized (conglom_cache)
0:         {
0:             CacheableConglomerate cache_entry = 
0:                 (CacheableConglomerate) conglom_cache.findCached(conglomid_obj);
0: 
0:             if (cache_entry != null)
0:             {
0:                 conglom = cache_entry.getConglom();
0:                 conglom_cache.release(cache_entry);
0: 
0:                 // SanityManager.DEBUG_PRINT("find", "find hit : " + conglomid);
0:             }
0:             else
0:             {
0:                 // SanityManager.DEBUG_PRINT("find", "find miss: " + conglomid);
0: 
0:                 // If not in cache - ask the factory for it and insert it.
0: 
0:                 conglom = 
0:                     getFactoryFromConglomId(conglomid).readConglomerate(
0:                         xact_mgr, new ContainerKey(0, conglomid));
0: 
0:                 if (conglom != null)
0:                 {
0:                     // on cache miss, put the missing conglom in the cache.
0:                     cache_entry = (CacheableConglomerate) 
0:                         this.conglom_cache.create(conglomid_obj, conglom);
0:                     this.conglom_cache.release(cache_entry);
0:                 }
0:             }
0:         }
0: 
0:         return(conglom);
0:     }
0: 
0:     /**
0:      * Invalide the current Conglomerate Cache.
0:      * <p>
0:      * Abort of certain operations will invalidate the contents of the 
0:      * cache.  Longer term we could just invalidate those entries, but
0:      * for now just invalidate the whole cache.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /* package */ protected void conglomCacheInvalidate()
0:         throws StandardException
0:     {
0:         synchronized (conglom_cache)
0:         {
0:             conglom_cache.ageOut();
0:         }
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * Update a conglomerate directory entry.
0:      * <p>
0:      * Update the Conglom column of the Conglomerate Directory.  The 
0:      * Conglomerate with id "conglomid" is replaced by "new_conglom".
0:      * <p>
0:      *
0:      * @param conglomid   The conglomid of conglomerate to replace.
0:      * @param new_conglom The new Conglom to update the conglom column to.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /* package */ void conglomCacheUpdateEntry(
0:     long            conglomid, 
0:     Conglomerate    new_conglom) 
0:         throws StandardException
0:     {
0:         Long         conglomid_obj = new Long(conglomid);
0: 
0:         synchronized (conglom_cache)
0:         {
0:             // remove the current entry
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.findCached(conglomid_obj);
0: 
0:             if (conglom_entry != null)
0:                 conglom_cache.remove(conglom_entry);
0: 
0:             // insert the updated entry.
0:             conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.create(conglomid_obj, new_conglom);
0:             conglom_cache.release(conglom_entry);
0:         }
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * Add a newly created conglomerate to the cache.
0:      * <p>
0:      *
0:      * @param conglomid   The conglomid of conglomerate to replace.
0:      * @param conglom     The Conglom to add.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /* package */ void conglomCacheAddEntry(
0:     long            conglomid,
0:     Conglomerate    conglom)
0:         throws StandardException
0:     {
0:         synchronized (conglom_cache)
0:         {
0:             // insert the updated entry.
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.create(new Long(conglomid), conglom);
0:             conglom_cache.release(conglom_entry);
0:         }
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * Remove an entry from the cache.
0:      * <p>
0:      *
0:      * @param conglomid   The conglomid of conglomerate to replace.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /* package */ void conglomCacheRemoveEntry(long conglomid)
0:         throws StandardException
0:     {
0:         synchronized (conglom_cache)
0:         {
0:             CacheableConglomerate conglom_entry = (CacheableConglomerate) 
0:                 conglom_cache.findCached(new Long(conglomid));
0: 
0:             if (conglom_entry != null)
0:                 conglom_cache.remove(conglom_entry);
0:         }
0: 
0:         return;
0:     }
0: 
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods implementing AccessFactory Interface:
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	Database creation finished.  Tell RawStore.
0: 	@exception StandardException cloudscape standard error policy
0: 	*/
0: 	public void createFinished() throws StandardException
0: 	{
0: 		rawstore.createFinished();
0: 	}
0: 
0:     /**
0:     Find an access method that implements a format type.
0:     @see AccessFactory#findMethodFactoryByFormat
0:     **/
0:     public MethodFactory findMethodFactoryByFormat(UUID format)
0:     {
0:         MethodFactory factory;
0:         
0:         // See if there's an access method that supports the desired
0:         // format type as its primary format type.
0:         factory = (MethodFactory) formathash.get(format);
0:         if (factory != null)
0:             return factory;
0: 
0:         // No primary format.  See if one of the access methods
0:         // supports it as a secondary format.
0:         Enumeration e = formathash.elements();
0:         while (e.hasMoreElements())
0:         {
0:             factory = (MethodFactory) e.nextElement();
0:             if (factory.supportsFormat(format))
0:                 return factory;
0:         }
0: 
0:         // No such implementation.
0:         return null;
0:     }
0: 
0:     /**
0:     Find an access method that implements an implementation type.
0:     @see AccessFactory#findMethodFactoryByImpl
0:     **/
0:     public MethodFactory findMethodFactoryByImpl(String impltype)
0:         throws StandardException
0:     {
0:         MethodFactory factory;
0:         
0:         // See if there's an access method that supports the desired
0:         // implementation type as its primary implementation type.
0: 		Object value = implhash.get(impltype);
0: 
0: 
0:         factory = (MethodFactory) implhash.get(impltype);
0:         if (factory != null)
0: 				return factory;
0: 
0:         // No primary implementation.  See if one of the access methods
0:         // supports the implementation type as a secondary.
0:         Enumeration e = implhash.elements();
0:         while (e.hasMoreElements())
0:         {
0:             factory = (MethodFactory) e.nextElement();
0:             if (factory.supportsImplementation(impltype))
0:                 return factory;
0:         }
0: 		factory = null;
0: 
0: 		// try and load an implementation.  a new properties object needs
0: 		// to be created to hold the conglomerate type property, since
0: 		// that value is specific to the conglomerate we want to boot, not
0: 		// to the service as a whole
0: 		Properties conglomProperties = new Properties(serviceProperties);
0: 		conglomProperties.put(AccessFactoryGlobals.CONGLOM_PROP, impltype);
0: 
0: 		try {
0: 			factory = 
0:                (MethodFactory) Monitor.bootServiceModule(
0:                     false, this, MethodFactory.MODULE, 
0:                     impltype, conglomProperties);
0: 		} catch (StandardException se) {
0: 			if (!se.getMessageId().equals(SQLState.SERVICE_MISSING_IMPLEMENTATION))
0: 				throw se;
0: 		}
0: 
0: 		conglomProperties = null;
0: 
0: 		if (factory != null) {
0: 			registerAccessMethod(factory);
0: 			return factory;
0: 		}
0: 
0:         // No such implementation.
0:         return null;
0:     }
0: 
0: 	public LockFactory getLockFactory() {
0: 		return rawstore.getLockFactory();
0: 	}
0: 
0: 
0:     public TransactionController getTransaction(
0:     ContextManager cm)
0:         throws StandardException
0:     {
0:         return getAndNameTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
0:     }
0: 
0:     public TransactionController getAndNameTransaction(
0:     ContextManager cm, String transName)
0:         throws StandardException
0:     {
0:         if (cm == null)
0:             return null;  // XXX (nat) should throw exception
0: 
0:         // See if there's already a transaction context.
0:         RAMTransactionContext rtc = (RAMTransactionContext)
0:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
0: 
0:         if (rtc == null)
0:         {
0:             // No transaction context.  Create or find a raw store transaction,
0:             // make a context for it, and push the context.  Note this puts the
0:             // raw store transaction context above the access context, which is
0:             // required for error handling assumptions to be correct.
0:             Transaction rawtran = rawstore.findUserTransaction(cm, transName);
0:             RAMTransaction rt      = new RAMTransaction(this, rawtran, null);
0: 
0:             rtc = 
0:                 new RAMTransactionContext(
0:                     cm, 
0:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
0:                     rt, false /* abortAll */);
0: 
0: 			TransactionController tc = rtc.getTransaction();
0: 
0: 			if (xactProperties != null)
0:             {
0: 				rawtran.setup(tc);
0: 				tc.commit();
0: 			}
0: 
0:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
0: 
0: 			tc.commit();
0: 
0: 			return tc;
0:         }
0:         return rtc.getTransaction();
0:     }
0: 
0: 	/**
0:      * Start a global transaction.
0:      * <p>
0: 	 * Get a transaction controller with which to manipulate data within
0: 	 * the access manager.  Implicitly creates an access context.
0:      * <p>
0:      * Must only be called if no other transaction context exists in the
0:      * current context manager.  If another transaction exists in the context
0:      * an exception will be thrown.
0:      * <p>
0:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
0:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
0:      * can be delivered on a non-1.2 vm system and not require the javax classes
0:      * in the path.  
0:      *
0:      * @param cm        The context manager for the current context.
0:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
0:      * @param global_id the global transaction identifier part of XID - ie.
0:      *                  Xid.getGlobalTransactionId().
0:      * @param branch_id The branch qualifier of the Xid - ie. 
0:      *                  Xid.getBranchQaulifier()
0:      * 	
0: 	 * @exception StandardException Standard exception policy.
0: 	 * @see TransactionController
0: 	 **/
0: 	public /* XATransactionController */ Object startXATransaction(
0:     ContextManager  cm, 
0:     int             format_id,
0:     byte[]          global_id,
0:     byte[]          branch_id)
0: 		throws StandardException
0:     {
0:         RAMTransaction xa_tc = null;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(global_id != null);
0:             SanityManager.ASSERT(branch_id != null);
0:         }
0: 
0:         if (cm == null)
0:             return null;  // XXX (nat) should throw exception
0: 
0:         // See if there's already a transaction context.
0:         RAMTransactionContext rtc = (RAMTransactionContext) 
0:             cm.getContext(AccessFactoryGlobals.RAMXACT_CONTEXT_ID);
0: 
0:         if (rtc == null)
0:         {
0:             // No transaction context.  Create or find a raw store transaction,
0:             // make a context for it, and push the context.  Note this puts the
0:             // raw store transaction context above the access context, which is
0:             // required for error handling assumptions to be correct.
0:             Transaction rawtran = 
0:                 rawstore.startGlobalTransaction(
0:                     cm, format_id, global_id, branch_id);
0: 
0:             xa_tc                    = new RAMTransaction(this, rawtran, null);
0: 
0:             rtc = 
0:                 new RAMTransactionContext(
0:                     cm, 
0:                     AccessFactoryGlobals.RAMXACT_CONTEXT_ID,
0:                     xa_tc, false /* abortAll */);
0: 
0:             // RESOLVE - an XA transaction can only commit once so, if we
0:             // acquire readlocks.
0: 
0: 			if (xactProperties != null) 
0:             {
0: 				rawtran.setup(xa_tc);
0: 
0:                 // HACK - special support has been added to the commitNoSync
0:                 // of a global xact, to allow committing of read only xact, 
0:                 // which will allow subsequent activity on the xact keeping
0:                 // the same global transaction id.
0:                 xa_tc.commitNoSync(
0:                     TransactionController.RELEASE_LOCKS |
0:                     TransactionController.READONLY_TRANSACTION_INITIALIZATION);
0: 			}
0: 
0:             rawtran.setDefaultLockingPolicy(system_default_locking_policy);
0: 
0:             // HACK - special support has been added to the commitNoSync
0:             // of a global xact, to allow committing of read only xact, 
0:             // which will allow subsequent activity on the xact keeping
0:             // the same global transaction id.
0:             xa_tc.commitNoSync(
0:                 TransactionController.RELEASE_LOCKS |
0:                 TransactionController.READONLY_TRANSACTION_INITIALIZATION);
0:         }
0:         else
0:         {
0:             // throw an error.
0:             if (SanityManager.DEBUG)
0:                 SanityManager.THROWASSERT(
0:                     "RAMTransactionContext found on stack.");
0:         }
0: 
0:         return(xa_tc);
0:     }
0: 
0: 
0:     /**
0:      * Return the XAResourceManager associated with this AccessFactory.
0:      * <p>
0:      * Returns an object which can be used to implement the "offline" 
0:      * 2 phase commit interaction between the accessfactory and outstanding
0:      * transaction managers taking care of in-doubt transactions.
0:      *
0:      * @return The XAResourceManager associated with this accessfactory.
0:      *
0:      **/
0: 	public /* XAResourceManager */ Object getXAResourceManager()
0:         throws StandardException
0:     {
0:         return(rawstore.getXAResourceManager());
0:     }
0: 
0:     public void registerAccessMethod(MethodFactory factory)
0:     {
0:         // Put the access method's primary implementation type in
0:         // a hash table so we can find it quickly.
0:         implhash.put(factory.primaryImplementationType(), factory);
0: 
0:         // Put the access method's primary format in a hash table
0:         // so we can find it quickly.
0:         formathash.put(factory.primaryFormat(), factory);
0:     }
0: 
0: 	public boolean isReadOnly()
0: 	{
0: 		return rawstore.isReadOnly();
0: 	}
0: 
0: 	private void addPropertySetNotification(PropertySetCallback who, TransactionController tc) {
0: 
0: 		pf.addPropertySetNotification(who);
0: 		
0: 		// set up the initial values by calling the validate and apply methods.
0: 		// the map methods are not called as they will have been called
0: 		// at runtime when the user set the property.
0: 		Dictionary d = new Hashtable();
0: 		try {
0: 			xactProperties.getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
0: 		} catch (StandardException se) {
0: 			return;
0: 		}
0: 
0: 		boolean dbOnly = PropertyUtil.isDBOnly(d);
0: 
0: 		who.init(dbOnly, d);
0: 	}
0: 
0: 	public TransactionInfo[] getTransactionInfo()
0: 	{
0: 		return rawstore.getTransactionInfo();
0: 	}
0: 
0: 	public void freeze() throws StandardException
0: 	{
0: 		rawstore.freeze();
0: 	}
0: 
0: 	public void unfreeze() throws StandardException
0: 	{
0: 		rawstore.unfreeze();
0: 	}
0: 
0: 	public void backup(String backupDir) throws StandardException
0: 	{
0: 		rawstore.backup(backupDir);
0: 	}
0: 
0: 	public void backup(File backupDir) throws StandardException
0: 	{
0: 		rawstore.backup(backupDir);
0: 	}
0: 
0: 
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean deleteOnlineArchivedLogFiles)
0: 		throws StandardException 
0: 	{
0: 		rawstore.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
0: 	}
0: 
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean deleteOnlineArchivedLogFiles) 
0: 		throws StandardException
0: 	{
0: 		rawstore.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
0: 	}	
0: 
0: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
0: 		throws StandardException
0: 	{
0: 		rawstore.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
0: 	}
0: 
0: 
0: 
0: 	public void checkpoint() throws StandardException
0: 	{
0: 		rawstore.checkpoint();
0: 	}
0: 
0: 	public void waitForPostCommitToFinishWork()
0: 	{
0: 		rawstore.getDaemon().waitUntilQueueIsEmpty();
0: 	}
0: 
0:     /**************************************************************************
0:      * Public Methods implementing ModuleControl Interface:
0:      **************************************************************************
0:      */
0: 	public void boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		this.serviceProperties = startParams;
0: 
0:         boot_load_conglom_map();
0: 
0:         if (create)
0:         {
0:             // if we are creating the db, then just start the conglomid's at
0:             // 1, and proceed from there.  If not create, we delay 
0:             // initialization of this until the first ddl which needs a new
0:             // id.
0:             conglom_nextid = 1;
0:         }
0: 
0:         // Access depends on a Raw Store implementations.  Load it.
0:         //
0:         rawstore = (RawStoreFactory) Monitor.bootServiceModule(
0:             create, this, RawStoreFactory.MODULE, serviceProperties);
0: 
0: 		// Note: we also boot this module here since we may start cloudscape
0: 		// system from store access layer, as some of the unit test case,
0: 		// not from JDBC layer.(See
0: 		// /protocol/Database/Storage/Access/Interface/T_AccessFactory.java)
0: 		// If this module has already been booted by the JDBC layer, this will 
0: 		// have no effect at all.
0: 		Monitor.bootServiceModule(
0:             create, this, org.apache.derby.iapi.reference.Module.PropertyFactory, 
0:             startParams);
0: 
0:         // Create the in-memory conglomerate directory
0: 
0:         conglomCacheInit();
0: 
0:         // Read in the conglomerate directory from the conglom conglom
0:         // Create the conglom conglom from within a separate system xact
0:         RAMTransaction tc =
0:             (RAMTransaction) getAndNameTransaction(
0:                 ContextService.getFactory().getCurrentContextManager(),
0:                 AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0:         // looking up lock_mode is dependant on access booting, but
0:         // some boot routines need lock_mode and
0:         // system_default_locking_policy, so during boot do table level
0:         // locking and then look up the "right" locking level.
0: 
0:         int lock_mode = LockingPolicy.MODE_CONTAINER;
0: 
0:         system_default_locking_policy =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 lock_mode,
0:                 TransactionController.ISOLATION_SERIALIZABLE, true);
0: 
0: 
0:         // RESOLVE - code reduction - get rid of this table, and somehow
0:         // combine it with the raw store one.
0: 
0:         table_level_policy = new LockingPolicy[6];
0: 
0:         table_level_policy[TransactionController.ISOLATION_NOLOCK] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_NOLOCK, true);
0: 
0:         table_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
0: 
0:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_READ_COMMITTED, true);
0: 
0:         table_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
0:                 true);
0: 
0:         table_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
0: 
0:         table_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_CONTAINER,
0:                 TransactionController.ISOLATION_SERIALIZABLE, true);
0: 
0:         record_level_policy = new LockingPolicy[6];
0: 
0:         record_level_policy[TransactionController.ISOLATION_NOLOCK] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_NOLOCK, true);
0: 
0:         record_level_policy[TransactionController.ISOLATION_READ_UNCOMMITTED] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_READ_UNCOMMITTED, true);
0: 
0:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_READ_COMMITTED, true);
0: 
0:         record_level_policy[TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
0:                 true);
0: 
0:         record_level_policy[TransactionController.ISOLATION_REPEATABLE_READ] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
0: 
0:         record_level_policy[TransactionController.ISOLATION_SERIALIZABLE] =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_SERIALIZABLE, true);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             for (int i = 0;
0:                  i < TransactionController.ISOLATION_SERIALIZABLE;
0:                  i++)
0:             {
0:                 SanityManager.ASSERT(
0:                     table_level_policy[i] != null,
0:                     "table_level_policy[" + i + "] is null");
0:                 SanityManager.ASSERT(
0:                     record_level_policy[i] != null,
0:                     "record_level_policy[" + i + "] is null");
0:             }
0:         }
0: 
0:         tc.commit();
0: 
0:         // set up the property validation
0:         pf = (PropertyFactory) 
0:             Monitor.findServiceModule(
0:                 this, org.apache.derby.iapi.reference.Module.PropertyFactory);
0: 
0:         // set up the transaction properties.  On J9, over NFS, runing on a
0:         // power PC coprossor, the directories were created fine, but create
0:         // db would fail when trying to create this first file in seg0.
0:         xactProperties = new PropertyConglomerate(tc, create, startParams, pf);
0: 
0:         // see if there is any properties that raw store needs to know
0:         // about
0:         rawstore.getRawStoreProperties(tc);
0: 
0:         // now that access and raw store are booted, do the property lookup
0:         // which may do conglomerate access.
0:         bootLookupSystemLockLevel(tc);
0: 
0:         lock_mode =
0:             (getSystemLockLevel() == TransactionController.MODE_TABLE ?
0:                  LockingPolicy.MODE_CONTAINER : LockingPolicy.MODE_RECORD);
0: 
0:         system_default_locking_policy =
0:             tc.getRawStoreXact().newLockingPolicy(
0:                 lock_mode,
0:                 TransactionController.ISOLATION_SERIALIZABLE, true);
0: 
0:         // set up the callbacl for the lock manager with initialization
0:         addPropertySetNotification(getLockFactory(), tc);
0: 
0:         // make sure user cannot change these properties
0:         addPropertySetNotification(this,tc);
0: 
0:         tc.commit();
0: 
0:         tc.destroy();
0:         tc = null;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             // RESOLVE - (mikem) currently these constants need to be the
0:             // same, but for modularity reasons there are 2 sets.  Probably
0:             // should only be one set.  For now just make sure they are the
0:             // same value.
0:             SanityManager.ASSERT(
0:                 TransactionController.OPENMODE_USE_UPDATE_LOCKS ==
0:                 ContainerHandle.MODE_USE_UPDATE_LOCKS);
0:             SanityManager.ASSERT(
0:                 TransactionController.OPENMODE_SECONDARY_LOCKED ==
0:                 ContainerHandle.MODE_SECONDARY_LOCKED);
0:             SanityManager.ASSERT(
0:                 TransactionController.OPENMODE_BASEROW_INSERT_LOCKED ==
0:                 ContainerHandle.MODE_BASEROW_INSERT_LOCKED);
0:             SanityManager.ASSERT(
0:                 TransactionController.OPENMODE_FORUPDATE ==
0:                 ContainerHandle.MODE_FORUPDATE);
0:             SanityManager.ASSERT(
0:                 TransactionController.OPENMODE_FOR_LOCK_ONLY ==
0:                 ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY);
0:         }
0: 	}
0: 
0:     public void stop()
0:     {
0:     }
0: 
0:     /* Methods of the PropertySetCallback interface */
0: 
0:     // This interface is implemented to ensure the user cannot change the
0:     // encryption provider or algorithm.
0: 
0: 	public void init(boolean dbOnly, Dictionary p)
0:     {
0:     }
0: 
0:     public boolean validate(String key, Serializable value, Dictionary p)
0: 		 throws StandardException
0:     {
0:         if (key.equals(Attribute.CRYPTO_ALGORITHM))
0:         {
0:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_ALGORITHM);
0: 		}
0:         if (key.equals(Attribute.CRYPTO_PROVIDER))
0:         {
0:             throw StandardException.newException(SQLState.ENCRYPTION_NOCHANGE_PROVIDER);
0: 		}
0:         return true;
0:     }
0: 
0:     public Serviceable apply(String key, Serializable value, Dictionary p)
0: 		 throws StandardException
0:     {
0:         return null;
0:     }
0: 
0:     public Serializable map(String key, Serializable value, Dictionary p)
0: 		 throws StandardException
0:     {
0:         return null;
0:     }
0: 
0:     // ///////////////////////////////////////////////////////////////
0: 
0: 	/*
0: 	** CacheableFactory interface
0: 	*/
0: 
0: 	public Cacheable newCacheable(CacheManager cm) {
0: 		return new CacheableConglomerate();
0: 	}
0: 
0: }
============================================================================