1:106ea47: /*
1:106ea47: 
1:106ea47: Derby - Class org.apache.derbyTesting.perf.clients.SingleRecordSelectClient
1:106ea47: 
1:106ea47: Licensed to the Apache Software Foundation (ASF) under one or more
1:106ea47: contributor license agreements.  See the NOTICE file distributed with
1:106ea47: this work for additional information regarding copyright ownership.
1:106ea47: The ASF licenses this file to You under the Apache License, Version 2.0
1:106ea47: (the "License"); you may not use this file except in compliance with
1:106ea47: the License.  You may obtain a copy of the License at
1:106ea47: 
1:106ea47:    http://www.apache.org/licenses/LICENSE-2.0
1:106ea47: 
1:106ea47: Unless required by applicable law or agreed to in writing, software
1:106ea47: distributed under the License is distributed on an "AS IS" BASIS,
1:106ea47: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:106ea47: See the License for the specific language governing permissions and
1:106ea47: limitations under the License.
1:106ea47: 
1:106ea47: */
1:106ea47: 
1:106ea47: package org.apache.derbyTesting.perf.clients;
1:106ea47: 
1:9a05e65: import java.io.PrintStream;
1:106ea47: import java.sql.Connection;
1:106ea47: import java.sql.PreparedStatement;
1:106ea47: import java.sql.ResultSet;
1:106ea47: import java.sql.SQLException;
1:6f53b7f: import java.sql.Types;
1:106ea47: import java.util.Random;
1:106ea47: 
1:106ea47: /**
1:106ea47:  * Client which performs single-record lookups on tables generated by
1:106ea47:  * {@code SingleRecordFiller}. Each time the client's {@code doWork()} method
1:106ea47:  * is called, it will pick one of the tables randomly, and select one random
1:106ea47:  * record in that table.
1:106ea47:  */
1:106ea47: public class SingleRecordSelectClient implements Client {
1:106ea47: 
1:106ea47:     private Connection conn;
1:106ea47: 
1:106ea47:     private final PreparedStatement[] pss;
1:106ea47:     private final Random r;
1:106ea47:     private final int tableSize;
1:6f53b7f:     private final int dataType;
1:4ea38fb:     private final boolean secondaryIndex;
1:4ea38fb:     private final boolean noIndex;
1:4ea38fb: 
1:4ea38fb:     /**
1:4ea38fb:      * Construct a new single-record select client which fetches VARCHAR data
1:4ea38fb:      * by primary key.
1:4ea38fb:      *
1:4ea38fb:      * @param records the number of records in each table in the test
1:4ea38fb:      * @param tables the number of tables in the test
1:4ea38fb:      */
1:4ea38fb:     public SingleRecordSelectClient(int records, int tables) {
1:4ea38fb:         this(records, tables, Types.VARCHAR, false, false);
1:4ea38fb:     }
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Construct a new single-record select client.
1:106ea47:      *
1:106ea47:      * @param records the number of records in each table in the test
1:106ea47:      * @param tables the number of tables in the test
1:6f53b7f:      * @param type the data type of the text column
1:6f53b7f:      * ({@code java.sql.Types.VARCHAR}, {@code java.sql.Types.BLOB} or
1:6f53b7f:      * {@code java.sql.Types.CLOB})
1:4ea38fb:      * @param secIndex if {@code true}, select by secondary index column
1:4ea38fb:      * instead of primary key column
1:4ea38fb:      * @param nonIndexed if {@code true}, select by non-indexed column
1:4ea38fb:      * instead of primary key column
1:106ea47:      */
1:4ea38fb:     public SingleRecordSelectClient(int records, int tables, int type,
1:4ea38fb:                                     boolean secIndex, boolean nonIndexed) {
1:106ea47:         tableSize = records;
1:106ea47:         r = new Random();
1:106ea47:         pss = new PreparedStatement[tables];
1:6f53b7f:         dataType = type;
1:4ea38fb:         if (secIndex && nonIndexed) {
1:4ea38fb:             throw new IllegalArgumentException(
1:4ea38fb:                 "Cannot select on both secondary index and non-index column");
1:4ea38fb:         }
1:4ea38fb:         secondaryIndex = secIndex;
1:4ea38fb:         noIndex = nonIndexed;
1:106ea47:     }
1:106ea47: 
1:106ea47:     public void init(Connection c) throws SQLException {
1:106ea47:         for (int i = 0; i < pss.length; i++) {
1:6f53b7f:             String tableName =
1:4ea38fb:                     SingleRecordFiller.getTableName(tableSize, i, dataType,
1:4ea38fb:                                                     secondaryIndex, noIndex);
1:4ea38fb:             String column = "ID";
1:4ea38fb:             if (secondaryIndex) {
1:4ea38fb:                 column = "SEC";
1:4ea38fb:             } else if (noIndex) {
1:4ea38fb:                 column = "NI";
1:4ea38fb:             }
1:4ea38fb:             String sql =
1:4ea38fb:                     "SELECT ID, TEXT FROM " + tableName +
1:4ea38fb:                     " WHERE " + column + " = ?";
1:106ea47:             pss[i] = c.prepareStatement(sql);
1:106ea47:         }
1:106ea47:         c.setAutoCommit(false);
1:106ea47:         conn = c;
1:106ea47:     }
1:106ea47: 
1:106ea47:     public void doWork() throws SQLException {
1:106ea47:         PreparedStatement ps = pss[r.nextInt(pss.length)];
1:106ea47:         ps.setInt(1, r.nextInt(tableSize));
1:106ea47:         ResultSet rs = ps.executeQuery();
1:106ea47:         rs.next();
1:106ea47:         rs.getInt(1);
1:6f53b7f:         fetchTextColumn(rs, 2);
1:106ea47:         rs.close();
1:106ea47:         conn.commit();
1:106ea47:     }
1:6f53b7f: 
1:9a05e65:     public void printReport(PrintStream out) {}
1:9a05e65:     
1:6f53b7f:     /**
1:6f53b7f:      * Make sure the text column is retrieved and read. Different methods
1:6f53b7f:      * are used for the retrieval based on whether the column is a VARCHAR,
1:6f53b7f:      * a BLOB or a CLOB.
1:6f53b7f:      */
1:6f53b7f:     private void fetchTextColumn(ResultSet rs, int column) throws SQLException {
1:6f53b7f:         if (dataType == Types.VARCHAR) {
1:6f53b7f:             rs.getString(column);
1:6f53b7f:         } else if (dataType == Types.CLOB) {
1:6f53b7f:             rs.getClob(column).getSubString(1, SingleRecordFiller.TEXT_SIZE);
1:6f53b7f:         } else if (dataType == Types.BLOB) {
1:6f53b7f:             rs.getBlob(column).getBytes(1, SingleRecordFiller.TEXT_SIZE);
1:6f53b7f:         } else {
1:6f53b7f:             throw new IllegalArgumentException();
1:6f53b7f:         }
1:6f53b7f:     }
1:106ea47: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9a05e65
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
1:     public void printReport(PrintStream out) {}
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ea38fb
/////////////////////////////////////////////////////////////////////////
1:     private final boolean secondaryIndex;
1:     private final boolean noIndex;
1: 
1:     /**
1:      * Construct a new single-record select client which fetches VARCHAR data
1:      * by primary key.
1:      *
1:      * @param records the number of records in each table in the test
1:      * @param tables the number of tables in the test
1:      */
1:     public SingleRecordSelectClient(int records, int tables) {
1:         this(records, tables, Types.VARCHAR, false, false);
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @param secIndex if {@code true}, select by secondary index column
1:      * instead of primary key column
1:      * @param nonIndexed if {@code true}, select by non-indexed column
1:      * instead of primary key column
1:     public SingleRecordSelectClient(int records, int tables, int type,
1:                                     boolean secIndex, boolean nonIndexed) {
1:         if (secIndex && nonIndexed) {
1:             throw new IllegalArgumentException(
1:                 "Cannot select on both secondary index and non-index column");
1:         }
1:         secondaryIndex = secIndex;
1:         noIndex = nonIndexed;
1:                     SingleRecordFiller.getTableName(tableSize, i, dataType,
1:                                                     secondaryIndex, noIndex);
1:             String column = "ID";
1:             if (secondaryIndex) {
1:                 column = "SEC";
1:             } else if (noIndex) {
1:                 column = "NI";
1:             }
1:             String sql =
1:                     "SELECT ID, TEXT FROM " + tableName +
1:                     " WHERE " + column + " = ?";
commit:6f53b7f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     private final int dataType;
1:      * @param type the data type of the text column
1:      * ({@code java.sql.Types.VARCHAR}, {@code java.sql.Types.BLOB} or
1:      * {@code java.sql.Types.CLOB})
0:     public SingleRecordSelectClient(int records, int tables, int type) {
1:         dataType = type;
1:             String tableName =
0:                     SingleRecordFiller.getTableName(tableSize, i, dataType);
/////////////////////////////////////////////////////////////////////////
1:         fetchTextColumn(rs, 2);
1: 
1:     /**
1:      * Make sure the text column is retrieved and read. Different methods
1:      * are used for the retrieval based on whether the column is a VARCHAR,
1:      * a BLOB or a CLOB.
1:      */
1:     private void fetchTextColumn(ResultSet rs, int column) throws SQLException {
1:         if (dataType == Types.VARCHAR) {
1:             rs.getString(column);
1:         } else if (dataType == Types.CLOB) {
1:             rs.getClob(column).getSubString(1, SingleRecordFiller.TEXT_SIZE);
1:         } else if (dataType == Types.BLOB) {
1:             rs.getBlob(column).getBytes(1, SingleRecordFiller.TEXT_SIZE);
1:         } else {
1:             throw new IllegalArgumentException();
1:         }
1:     }
commit:106ea47
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.perf.clients.SingleRecordSelectClient
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.perf.clients;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.util.Random;
1: 
1: /**
1:  * Client which performs single-record lookups on tables generated by
1:  * {@code SingleRecordFiller}. Each time the client's {@code doWork()} method
1:  * is called, it will pick one of the tables randomly, and select one random
1:  * record in that table.
1:  */
1: public class SingleRecordSelectClient implements Client {
1: 
1:     private Connection conn;
1: 
1:     private final PreparedStatement[] pss;
1:     private final Random r;
1:     private final int tableSize;
1: 
1:     /**
1:      * Construct a new single-record select client.
1:      *
1:      * @param records the number of records in each table in the test
1:      * @param tables the number of tables in the test
1:      */
0:     public SingleRecordSelectClient(int records, int tables) {
1:         tableSize = records;
1:         r = new Random();
1:         pss = new PreparedStatement[tables];
1:     }
1: 
1:     public void init(Connection c) throws SQLException {
1:         for (int i = 0; i < pss.length; i++) {
0:             String tableName = SingleRecordFiller.getTableName(tableSize, i);
0:             String sql = "SELECT * FROM " + tableName + " WHERE ID = ?";
1:             pss[i] = c.prepareStatement(sql);
1:         }
1:         c.setAutoCommit(false);
1:         conn = c;
1:     }
1: 
1:     public void doWork() throws SQLException {
1:         PreparedStatement ps = pss[r.nextInt(pss.length)];
1:         ps.setInt(1, r.nextInt(tableSize));
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         rs.getInt(1);
0:         rs.getString(2);
1:         rs.close();
1:         conn.commit();
1:     }
1: }
============================================================================