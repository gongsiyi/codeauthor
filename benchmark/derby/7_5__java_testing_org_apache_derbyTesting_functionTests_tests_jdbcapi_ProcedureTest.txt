1:56439cb: /*
1:35d620a:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ProcedureTest
1:35d620a:  *
1:56439cb:  * Licensed to the Apache Software Foundation (ASF) under one
1:56439cb:  * or more contributor license agreements.  See the NOTICE file
1:56439cb:  * distributed with this work for additional information
1:56439cb:  * regarding copyright ownership.  The ASF licenses this file
1:56439cb:  * to you under the Apache License, Version 2.0 (the
1:56439cb:  * "License"); you may not use this file except in compliance
1:56439cb:  * with the License.  You may obtain a copy of the License at
9:56439cb:  *
1:56439cb:  *   http://www.apache.org/licenses/LICENSE-2.0
1:56439cb:  *
1:56439cb:  * Unless required by applicable law or agreed to in writing,
1:56439cb:  * software distributed under the License is distributed on an
1:56439cb:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:56439cb:  * KIND, either express or implied.  See the License for the
1:56439cb:  * specific language governing permissions and limitations
1:56439cb:  * under the License.
1:56439cb:  */
1:56439cb: 
1:56439cb: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:56439cb: 
1:35d620a: import java.math.BigDecimal;
1:35d620a: import java.sql.Blob;
1:56439cb: import java.sql.CallableStatement;
1:35d620a: import java.sql.Clob;
1:56439cb: import java.sql.Connection;
1:99d9d5c: import java.sql.DatabaseMetaData;
1:35d620a: import java.sql.Date;
1:56439cb: import java.sql.DriverManager;
1:56439cb: import java.sql.PreparedStatement;
1:56439cb: import java.sql.ResultSet;
1:56439cb: import java.sql.SQLException;
1:56439cb: import java.sql.Statement;
1:35d620a: import java.sql.Time;
1:35d620a: import java.sql.Timestamp;
1:0252fa4: import java.sql.Types;
1:56439cb: import junit.framework.Test;
1:35d620a: import org.apache.derby.iapi.types.HarmonySerialBlob;
1:35d620a: import org.apache.derby.iapi.types.HarmonySerialClob;
1:35d620a: import org.apache.derbyTesting.functionTests.tests.lang.Price;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:3bd1dd8: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:3bd1dd8: import org.apache.derbyTesting.junit.JDBC;
1:283931e: import org.apache.derbyTesting.junit.TestConfiguration;
1:35d620a: 
1:56439cb: /**
1:56439cb:  * Tests of stored procedures.
1:56439cb:  */
1:56439cb: public class ProcedureTest extends BaseJDBCTestCase {
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Creates a new <code>ProcedureTest</code> instance.
1:d8383bd:      *
1:56439cb:      * @param name name of the test
1:56439cb:      */
1:56439cb:     public ProcedureTest(String name) {
1:56439cb:         super(name);
1:73d678d:     }
1:56439cb: 
1:56439cb:     // TESTS
1:56439cb: 
1:35d620a:     /**
1:56439cb:      * Tests that <code>Statement.executeQuery()</code> fails when no
1:56439cb:      * result sets are returned.
1:d8383bd:      * @exception SQLException if a database error occurs
1:d8383bd:      */
1:56439cb:     public void testExecuteQueryWithNoDynamicResultSets() throws SQLException {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         try {
1:56439cb:             stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(0)");
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:99d9d5c:     /**
1:56439cb:      * Tests that <code>Statement.executeQuery()</code> succeeds when
1:56439cb:      * one result set is returned from a stored procedure.
3:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithOneDynamicResultSet() throws SQLException {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         ResultSet rs = stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(1)");
1:56439cb:         assertNotNull("executeQuery() returned null.", rs);
1:f62cb68:         assertSame(stmt, rs.getStatement());
1:b24134e:         JDBC.assertDrainResultsHasData(rs);
1:56439cb:     }
1:56439cb: 
1:0252fa4:     /**
1:56439cb:      * Tests that <code>Statement.executeQuery()</code> fails when
1:56439cb:      * multiple result sets are returned.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithMoreThanOneDynamicResultSet()
1:d8383bd:         throws SQLException
1:d8383bd:     {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         try {
1:56439cb:             stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(2)");
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertMultipleResultsFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>Statement.executeUpdate()</code> succeeds when
1:56439cb:      * no result sets are returned.
1:d8383bd:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testExecuteUpdateWithNoDynamicResultSets()
1:56439cb:         throws SQLException
1:56439cb:     {
1:b24134e:         Statement stmt = createStatement();
1:84eabad:         assertUpdateCount(stmt, 0, "CALL RETRIEVE_DYNAMIC_RESULTS(0)");
1:84eabad:         JDBC.assertNoMoreResults(stmt);
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>Statement.executeUpdate()</code> fails when a
1:56439cb:      * result set is returned from a stored procedure.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteUpdateWithOneDynamicResultSet() throws SQLException {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         try {
1:56439cb:             stmt.executeUpdate("CALL RETRIEVE_DYNAMIC_RESULTS(1)");
1:56439cb:             fail("executeUpdate() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertResultsFromExecuteUpdate(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>PreparedStatement.executeQuery()</code> fails
1:56439cb:      * when no result sets are returned.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithNoDynamicResultSets_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:d8383bd:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:d8383bd:         ps.setInt(1, 0);
1:d8383bd:         try {
1:56439cb:             ps.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>PreparedStatement.executeQuery()</code>
1:56439cb:      * succeeds when one result set is returned from a stored
1:56439cb:      * procedure.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithOneDynamicResultSet_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         ps.setInt(1, 1);
2:d8383bd:         ResultSet rs = ps.executeQuery();
1:56439cb:         assertNotNull("executeQuery() returned null.", rs);
1:f62cb68:         assertSame(ps, rs.getStatement());
1:b24134e:         JDBC.assertDrainResultsHasData(rs);
1:56439cb: 
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>PreparedStatement.executeQuery()</code> fails
1:56439cb:      * when multiple result sets are returned.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithMoreThanOneDynamicResultSet_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         ps.setInt(1, 2);
1:56439cb:         try {
1:56439cb:             ps.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertMultipleResultsFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>PreparedStatement.executeUpdate()</code>
1:56439cb:      * succeeds when no result sets are returned.
1:56439cb:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testExecuteUpdateWithNoDynamicResultSets_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         ps.setInt(1, 0);
1:84eabad:         assertUpdateCount(ps, 0);
1:84eabad:         JDBC.assertNoMoreResults(ps);
1:56439cb:     }
1:56439cb: 
1:0252fa4:     /**
1:56439cb:      * Tests that <code>PreparedStatement.executeUpdate()</code> fails
1:56439cb:      * when a result set is returned from a stored procedure.
1:56439cb:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testExecuteUpdateWithOneDynamicResultSet_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         ps.setInt(1, 1);
1:56439cb:         try {
1:56439cb:             ps.executeUpdate();
1:56439cb:             fail("executeUpdate() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertResultsFromExecuteUpdate(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>CallableStatement.executeQuery()</code> fails
1:56439cb:      * when no result sets are returned.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithNoDynamicResultSets_callable()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         CallableStatement cs =
1:b24134e:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         cs.setInt(1, 0);
1:56439cb:         try {
1:56439cb:             cs.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>CallableStatement.executeQuery()</code>
1:56439cb:      * succeeds when one result set is returned from a stored
1:56439cb:      * procedure.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithOneDynamicResultSet_callable()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         CallableStatement cs =
1:b24134e:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         cs.setInt(1, 1);
1:56439cb:         ResultSet rs = cs.executeQuery();
1:56439cb:         assertNotNull("executeQuery() returned null.", rs);
1:f62cb68:         assertSame(cs, rs.getStatement());
1:b24134e:         JDBC.assertDrainResultsHasData(rs);
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>CallableStatement.executeQuery()</code> fails
1:56439cb:      * when multiple result sets are returned.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteQueryWithMoreThanOneDynamicResultSet_callable()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         CallableStatement cs =
1:b24134e:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         cs.setInt(1, 2);
1:56439cb:         try {
1:56439cb:             cs.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertMultipleResultsFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>CallableStatement.executeUpdate()</code>
1:56439cb:      * succeeds when no result sets are returned.
1:56439cb:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testExecuteUpdateWithNoDynamicResultSets_callable()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         CallableStatement cs =
1:b24134e:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         cs.setInt(1, 0);
1:84eabad:         assertUpdateCount(cs, 0);
1:84eabad:         JDBC.assertNoMoreResults(cs);
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that <code>CallableStatement.executeUpdate()</code> fails
1:56439cb:      * when a result set is returned from a stored procedure.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testExecuteUpdateWithOneDynamicResultSet_callable()
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         CallableStatement cs =
1:b24134e:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:56439cb:         cs.setInt(1, 1);
1:56439cb:         try {
1:56439cb:             cs.executeUpdate();
1:56439cb:             fail("executeUpdate() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertResultsFromExecuteUpdate(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:d8383bd:      * Tests that the effects of executing a stored procedure with
1:56439cb:      * <code>executeQuery()</code> are correctly rolled back when
1:56439cb:      * <code>Connection.rollback()</code> is called.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testRollbackStoredProcWithExecuteQuery() throws SQLException {
1:56439cb: 
1:b24134e:         Statement stmt = createStatement();
1:56439cb:         ResultSet rs = stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(1)");
3:d8383bd:         rs.close();
1:b24134e:         rollback();
1:56439cb:         
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:84eabad:  
1:56439cb:     }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that the effects of executing a stored procedure with
1:56439cb:      * <code>executeUpdate()</code> are correctly rolled back when
1:56439cb:      * <code>Connection.rollback()</code> is called.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testRollbackStoredProcWithExecuteUpdate() throws SQLException {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         stmt.executeUpdate("CALL PROC_WITH_SIDE_EFFECTS(0)");
1:b24134e:         rollback();
1:56439cb:         
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:84eabad:  
1:56439cb:     }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that the effects of executing a stored procedure with
1:d8383bd:      * <code>executeQuery()</code> are correctly rolled back when the
1:d8383bd:      * query fails because the number of returned result sets is zero.
1:56439cb:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testRollbackStoredProcWhenExecuteQueryReturnsNothing()
1:56439cb:         throws SQLException
1:56439cb:     {
1:03a99e2:         Connection conn = getConnection();
1:d8383bd:         conn.setAutoCommit(true);
1:b24134e:         Statement stmt = createStatement();
1:56439cb:         try {
1:b24134e:             stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(0)");
1:d8383bd:             fail("executeQuery() didn't fail.");
1:d8383bd:         } catch (SQLException sqle) {
1:d8383bd:             assertNoResultSetFromExecuteQuery(sqle);
1:d8383bd:         }
1:d8383bd: 
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:d8383bd:     }
1:56439cb: 
1:d8383bd:     /**
1:d8383bd:      * Tests that the effects of executing a stored procedure with
1:d8383bd:      * <code>executeQuery()</code> are correctly rolled back when the
1:d8383bd:      * query fails because the number of returned result sets is more
1:d8383bd:      * than one.
1:d8383bd:      *
1:d8383bd:      * @exception SQLException if a database error occurs
1:d8383bd:      */
1:b24134e:     public void testRollbackStoredProcWhenExecuteQueryReturnsTooMuch()
1:d8383bd:         throws SQLException
1:d8383bd:     {
1:03a99e2:         Connection conn = getConnection();
1:d8383bd:         conn.setAutoCommit(true);
1:b24134e:         Statement stmt = createStatement();
1:d8383bd:         try {
1:b24134e:             stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(2)");
1:d8383bd:             fail("executeQuery() didn't fail.");
1:d8383bd:         } catch (SQLException sqle) {
1:d8383bd:             assertMultipleResultsFromExecuteQuery(sqle);
1:d8383bd:         }
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:d8383bd:  
1:d8383bd:     }
1:56439cb: 
1:d8383bd:     /**
1:d8383bd:      * Tests that the effects of executing a stored procedure with
1:d8383bd:      * <code>executeUpdate()</code> are correctly rolled back when the
1:d8383bd:      * query fails because the stored procedure returned a result set.
1:d8383bd:      *
1:d8383bd:      * @exception SQLException if a database error occurs
1:d8383bd:      */
1:b24134e:     public void testRollbackStoredProcWhenExecuteUpdateReturnsResults()
1:56439cb:         throws SQLException
1:56439cb:     {
1:03a99e2:         Connection conn = getConnection();
1:56439cb:         conn.setAutoCommit(true);
1:b24134e:         Statement stmt = createStatement();
1:56439cb:         try {
1:56439cb:             stmt.executeUpdate("CALL PROC_WITH_SIDE_EFFECTS(1)");
1:56439cb:             fail("executeUpdate() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertResultsFromExecuteUpdate(sqle);
1:56439cb:         }
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:56439cb:  
1:56439cb:     }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that the effects of executing a stored procedure with
1:56439cb:      * <code>executeQuery()</code> are correctly rolled back when the
1:56439cb:      * query fails because the number of returned result sets is zero.
1:d8383bd:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testRollbackStoredProcWhenExecuteQueryReturnsNothing_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:03a99e2:         Connection conn = getConnection();
1:56439cb:         conn.setAutoCommit(true);
1:d8383bd:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:56439cb:         ps.setInt(1, 0);
1:56439cb:         try {
1:b24134e:             ps.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:b24134e:         Statement stmt = createStatement();
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:84eabad:  
1:56439cb:     }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that the effects of executing a stored procedure with
1:56439cb:      * <code>executeQuery()</code> are correctly rolled back when the
1:56439cb:      * query fails because the number of returned result sets is more
1:56439cb:      * than one.
1:d8383bd:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:b24134e:     public void testRollbackStoredProcWhenExecuteQueryReturnsTooMuch_prepared()
1:56439cb:         throws SQLException
1:56439cb:     {
1:03a99e2:         Connection conn = getConnection();
1:56439cb:         conn.setAutoCommit(true);
1:56439cb:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:d8383bd:         ps.setInt(1, 2);
1:56439cb:         try {
1:b24134e:             ps.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertMultipleResultsFromExecuteQuery(sqle);
1:56439cb:         }
1:b24134e:         Statement stmt = createStatement();
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:56439cb:      }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that the effects of executing a stored procedure with
1:56439cb:      * <code>executeUpdate()</code> are correctly rolled back when the
1:56439cb:      * query fails because the stored procedure returned a result set.
1:56439cb:      *
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:d8383bd:     public void
1:b24134e:         testRollbackStoredProcWhenExecuteUpdateReturnsResults_prepared()
1:d8383bd:         throws SQLException
1:d8383bd:     {
1:03a99e2:         Connection conn = getConnection();
1:d8383bd:         conn.setAutoCommit(true);
1:d8383bd:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:d8383bd:         ps.setInt(1, 1);
1:d8383bd:         try {
1:d8383bd:             ps.executeUpdate();
1:d8383bd:             fail("executeUpdate() didn't fail.");
1:d8383bd:         } catch (SQLException sqle) {
1:d8383bd:             assertResultsFromExecuteUpdate(sqle);
1:d8383bd:         }
1:2b04028:         Statement stmt = createStatement();
1:84eabad:         // Expect Side effects from stored procedure to be rolled back.
1:84eabad:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:84eabad:  
1:56439cb:     }
1:b24134e: 
1:56439cb:     /**
1:56439cb:      * Tests that closed result sets are not returned when calling
1:56439cb:      * <code>executeQuery()</code>.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testClosedDynamicResultSetsFromExecuteQuery()
1:56439cb:         throws SQLException
1:56439cb:     {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         try {
1:56439cb:             ResultSet rs = stmt.executeQuery("CALL RETRIEVE_CLOSED_RESULT()");
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that closed result sets are ignored when calling
1:56439cb:      * <code>executeUpdate()</code>.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testClosedDynamicResultSetsFromExecuteUpdate()
1:56439cb:         throws SQLException
1:56439cb:     {
1:2b04028:         Statement stmt = createStatement();
1:56439cb:         stmt.executeUpdate("CALL RETRIEVE_CLOSED_RESULT()");
1:84eabad:         JDBC.assertNoMoreResults(stmt);
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Tests that dynamic result sets from other connections are
1:56439cb:      * ignored when calling <code>executeQuery</code>.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testDynamicResultSetsFromOtherConnectionWithExecuteQuery()
1:56439cb:         throws SQLException
1:56439cb:     {
1:09ffc9b:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
1:56439cb:         
1:3df869c:         ps.setString(1, getTestConfiguration().getDefaultDatabaseName());
1:09ffc9b:         ps.setString(2, getTestConfiguration().getUserName());
1:09ffc9b:         ps.setString(3, getTestConfiguration().getUserPassword());
1:56439cb:         try {
1:09ffc9b:             ps.executeQuery();
1:56439cb:             fail("executeQuery() didn't fail.");
1:56439cb:         } catch (SQLException sqle) {
1:56439cb:             assertNoResultSetFromExecuteQuery(sqle);
1:56439cb:         }
1:56439cb:     }
1:84eabad: 
1:56439cb:     /**
1:56439cb:      * Tests that dynamic result sets from other connections are
1:56439cb:      * ignored when calling <code>executeUpdate</code>.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void testDynamicResultSetsFromOtherConnectionWithExecuteUpdate()
1:56439cb:         throws SQLException
1:56439cb:     {
1:09ffc9b:         PreparedStatement ps =
1:b24134e:             prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
1:56439cb:         
1:3df869c:         ps.setString(1, getTestConfiguration().getDefaultDatabaseName());
1:09ffc9b:         ps.setString(2, getTestConfiguration().getUserName());
1:09ffc9b:         ps.setString(3, getTestConfiguration().getUserPassword());
1:56439cb:         
1:09ffc9b:         ps.executeUpdate();
1:b24134e:         
1:84eabad:         JDBC.assertNoMoreResults(ps);
1:56439cb:     }
1:b24134e: 
1:56439cb:     /**
1:0252fa4:      * Test that a call to getBlob() to retrieve the value of a non-BLOB
1:0252fa4:      * parameter fails with the expected SQLException. Used to throw
1:0252fa4:      * ClassCastException, see DERBY-4970.
1:0252fa4:      */
1:0252fa4:     public void testGetBlobFromIntParameter() throws SQLException {
1:0252fa4:         CallableStatement cs = prepareCall("call int_out(?)");
1:0252fa4:         cs.registerOutParameter(1, Types.INTEGER);
1:0252fa4:         cs.execute();
1:0252fa4:         try {
1:0252fa4:             cs.getBlob(1);
1:0252fa4:             fail("getBlob() on int parameter expected to fail");
1:0252fa4:         } catch (SQLException sqle) {
1:0252fa4:             assertSQLState("22005", sqle);
1:0252fa4:         }
1:0252fa4:     }
1:0252fa4: 
1:0252fa4:     /**
1:0252fa4:      * Test that a call to getClob() to retrieve the value of a non-CLOB
1:0252fa4:      * parameter fails with the expected SQLException. Used to throw
1:0252fa4:      * ClassCastException, see DERBY-4970.
1:0252fa4:      */
1:0252fa4:     public void testGetClobFromIntParameter() throws SQLException {
1:0252fa4:         CallableStatement cs = prepareCall("call int_out(?)");
1:0252fa4:         cs.registerOutParameter(1, Types.INTEGER);
1:0252fa4:         cs.execute();
1:0252fa4:         try {
1:0252fa4:             cs.getClob(1);
1:0252fa4:             fail("getClob() on int parameter expected to fail");
1:0252fa4:         } catch (SQLException sqle) {
1:0252fa4:             assertSQLState("22005", sqle);
1:0252fa4:         }
1:0252fa4:     }
1:0252fa4: 
1:56439cb:     /**
1:42114da:      * Test that a statement severity error inside a procedure doesn't kill
1:42114da:      * the top-level statement that executes the stored procedure. Regression
1:42114da:      * test case for DERBY-5280.
1:42114da:      */
1:42114da:     public void testStatementSeverityErrorInProcedure() throws SQLException {
1:42114da:         Statement s = createStatement();
1:42114da:         s.execute("create procedure proc_5280() language java " +
1:42114da:                   "parameter style java external name '" +
1:42114da:                   getClass().getName() + ".proc_5280' reads sql data");
1:42114da:         s.execute("call proc_5280()");
1:42114da:     }
1:42114da: 
1:42114da:     /**
1:42114da:      * Procedure that drops a non-existent table and ignores the exception
1:42114da:      * thrown because of it. Used by the regression test case for DERBY-5280.
1:42114da:      */
1:42114da:     public static void proc_5280() throws SQLException {
1:42114da:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:42114da:         Statement s = c.createStatement();
1:42114da: 
1:42114da:         // Drop a non-existent table and verify that it fails with the
1:42114da:         // expected exception. Ignore the exception.
1:42114da:         try {
1:42114da:             s.execute("drop table this_table_does_not_exist");
1:42114da:             fail("dropping non-existent table should fail");
1:42114da:         } catch (SQLException sqle) {
1:42114da:             assertSQLState("42Y55", sqle);
1:42114da:         }
1:42114da: 
1:42114da:         // The statement should still work.
1:42114da:         JDBC.assertSingleValueResultSet(s.executeQuery("values 1"), "1");
1:42114da:     }
1:42114da: 
1:42114da:     /**
1:35d620a:      * Test that INOUT args are preserved over procedure invocations.
1:35d620a:      * See DERBY-2515.
1:35d620a:      */
1:35d620a:     public  void    test_2515()   throws Exception
1:35d620a:     {
1:35d620a:         Connection  conn = getConnection();
1:35d620a:         
1:35d620a:         PreparedStatement ps = conn.prepareStatement
1:35d620a:             (
1:35d620a:              "create type price_2515 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n"
1:35d620a:              );
1:35d620a:         ps.execute();
1:35d620a:         ps.close();
1:35d620a:         
1:35d620a:         ps = conn.prepareStatement
1:35d620a:             (
1:35d620a:              "create procedure proc_2515\n" +
1:35d620a:              "(\n" +
1:35d620a:              "\tin passNumber int,\n" +
1:35d620a:              "\tout returnMessage varchar( 32672 ),\n" +
1:35d620a:              "\tinout bigintArg bigint,\n" +
1:35d620a:              "\tinout blobArg blob,\n" +
1:35d620a:              "inout booleanArg boolean,\n" +
1:35d620a:              "inout charArg char( 6 ),\n" +
1:35d620a:              "inout charForBitDataArg char( 3 ) for bit data,\n" +
1:35d620a:              "inout clobArg clob,\n" +
1:35d620a:              "inout dateArg date,\n" +
1:35d620a:              "inout decimalArg decimal,\n" +
1:35d620a:              "inout doubleArg double,\n" +
1:35d620a:              "inout intArg int,\n" +
1:35d620a:              "inout longVarcharArg long varchar,\n" +
1:35d620a:              "inout longVarcharForBitDataArg long varchar for bit data,\n" +
1:35d620a:              "inout realArg real,\n" +
1:35d620a:              "inout smallintArg smallint,\n" +
1:35d620a:              "inout timeArg time,\n" +
1:35d620a:              "inout timestampArg timestamp,\n" +
1:35d620a:              "inout priceArg price_2515,\n" +
1:35d620a:              "inout varcharArg varchar( 20 ),\n" +
1:35d620a:              "inout varcharForBitDataArg varchar( 3 ) for bit data\n" +
1:35d620a:             ")\n" +
1:35d620a:             "parameter style java language java no sql\n" +
1:35d620a:             "external name '" + ProcedureTest.class.getName() + ".proc_2515'"
1:35d620a:              );
1:35d620a:         ps.execute();
1:35d620a:         ps.close();
1:35d620a: 
1:35d620a:         CallableStatement   cs = conn.prepareCall
1:35d620a:             ( "call proc_2515( ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ? )" );
1:35d620a:         AllTypesTuple   firstArgs = makeFirstAllTypesTuple();
1:35d620a: 
1:35d620a:         int     idx = 2;
1:35d620a:         
1:35d620a:         cs.registerOutParameter( idx++, Types.VARCHAR );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.BIGINT );
1:35d620a:         cs.setLong( idx++, firstArgs.get_bigintArg().longValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.BLOB );
1:35d620a:         cs.setBlob( idx++, firstArgs.get_blobArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.BOOLEAN );
1:35d620a:         cs.setBoolean( idx++, firstArgs.get_booleanArg().booleanValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.CHAR );
1:35d620a:         cs.setString( idx++, firstArgs.get_charArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.BINARY );
1:35d620a:         cs.setBytes( idx++, firstArgs.get_charForBitDataArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.CLOB );
1:35d620a:         cs.setClob( idx++, firstArgs.get_clobArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.DATE );
1:35d620a:         cs.setDate( idx++, firstArgs.get_dateArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.DECIMAL );
1:35d620a:         cs.setBigDecimal( idx++, firstArgs.get_decimalArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.DOUBLE );
1:35d620a:         cs.setDouble( idx++, firstArgs.get_doubleArg().doubleValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.INTEGER );
1:35d620a:         cs.setInt( idx++, firstArgs.get_intArg().intValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.LONGVARCHAR );
1:35d620a:         cs.setString( idx++, firstArgs.get_longVarcharArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.LONGVARBINARY );
1:35d620a:         cs.setBytes( idx++, firstArgs.get_longVarcharForBitDataArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.REAL );
1:35d620a:         cs.setFloat( idx++, firstArgs.get_realArg().floatValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.SMALLINT );
1:35d620a:         cs.setShort( idx++, firstArgs.get_smallintArg().shortValue() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.TIME );
1:35d620a:         cs.setTime( idx++, firstArgs.get_timeArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.TIMESTAMP );
1:35d620a:         cs.setTimestamp( idx++, firstArgs.get_timestampArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.JAVA_OBJECT );
1:35d620a:         cs.setObject( idx++, firstArgs.get_priceArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.VARCHAR );
1:35d620a:         cs.setString( idx++, firstArgs.get_varcharArg() );
1:35d620a: 
1:35d620a:         cs.registerOutParameter( idx, Types.VARBINARY );
1:35d620a:         cs.setBytes( idx++, firstArgs.get_varcharForBitDataArg() );
1:35d620a: 
1:35d620a:         cs.setInt( 1, 0 );
1:35d620a:         cs.execute();
1:35d620a:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:35d620a:         assertEquals( "", makeSecondAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1:35d620a: 
1:35d620a:         cs.setInt( 1, 1 );
1:35d620a:         cs.execute();
1:35d620a:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:35d620a:         assertEquals( "", makeThirdAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1:35d620a: 
1:35d620a:         cs.setInt( 1, 2 );
1:35d620a:         cs.execute();
1:35d620a:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:35d620a:         assertEquals( "", makeFourthAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1:35d620a: 
1:35d620a:         ps = conn.prepareStatement( "drop procedure proc_2515" );
1:35d620a:         ps.execute();
1:35d620a:         ps.close();
1:35d620a: 
1:35d620a:         ps = conn.prepareStatement( "drop type price_2515 restrict" );
1:35d620a:         ps.execute();
1:35d620a:         ps.close();
1:35d620a:     }
1:35d620a:     private AllTypesTuple   getActualReturnArgs( CallableStatement cs )
1:35d620a:         throws Exception
1:35d620a:     {
1:35d620a:         int idx = 3;
1:35d620a:         
1:35d620a:         return new AllTypesTuple
1:35d620a:             (
1:35d620a:              (Long) cs.getObject( idx++ ),
1:35d620a:              (Blob) cs.getObject( idx++ ),
1:35d620a:              (Boolean) cs.getObject( idx++ ),
1:35d620a:              (String) cs.getObject( idx++ ),
1:35d620a:              (byte[]) cs.getObject( idx++ ),
1:35d620a:              (Clob) cs.getObject( idx++ ),
1:35d620a:              (Date) cs.getObject( idx++ ),
1:35d620a:              (BigDecimal) cs.getObject( idx++ ),
1:35d620a:              (Double) cs.getObject( idx++ ),
1:35d620a:              (Integer) cs.getObject( idx++ ),
1:35d620a:              (String) cs.getObject( idx++ ),
1:35d620a:              (byte[]) cs.getObject( idx++ ),
1:35d620a:              (Float) cs.getObject( idx++ ),
1:35d620a:              (Integer) cs.getObject( idx++ ),
1:35d620a:              (Time) cs.getObject( idx++ ),
1:35d620a:              (Timestamp) cs.getObject( idx++ ),
1:35d620a:              (Price) cs.getObject( idx++ ),
1:35d620a:              (String) cs.getObject( idx++ ),
1:35d620a:              (byte[]) cs.getObject( idx++ )
1:35d620a:              );
1:35d620a:     }
1:35d620a: 
1:b98b60e:     /**
1:b98b60e:      * Regression test case for DERBY-2516. If an INOUT parameter had been
1:b98b60e:      * registered as an output parameter, but no input value had been assigned
1:b98b60e:      * to it, the client driver would go ahead and execute the statement
1:b98b60e:      * using null as input.
1:b98b60e:      */
1:b98b60e:     public void testInOutParamNotSet() throws SQLException {
1:b98b60e:         setAutoCommit(false);
1:b98b60e: 
1:b98b60e:         Statement s = createStatement();
1:b98b60e:         s.execute("create procedure proc_2516 (inout i int) " +
1:b98b60e:                   "language java parameter style java external name '" +
1:b98b60e:                   getClass().getName() + ".proc_2516' no sql");
1:b98b60e: 
1:b98b60e:         // Register an INOUT parameter, but don't set it. Expect failure.
1:b98b60e:         // Client used to execute without error.
1:b98b60e:         CallableStatement cs = prepareCall("call proc_2516(?)");
1:b98b60e:         cs.registerOutParameter(1, Types.INTEGER);
1:b98b60e:         assertStatementError("07000", cs);
1:b98b60e: 
1:b98b60e:         // Should work if the parameter has been set.
1:b98b60e:         cs.setInt(1, 0);
1:b98b60e:         cs.execute();
1:b98b60e:         assertEquals(10, cs.getInt(1));
1:b98b60e: 
1:b98b60e:         // After clearing the parameters, execution should fail. Client used
1:b98b60e:         // to succeed.
1:b98b60e:         cs.clearParameters();
1:b98b60e:         assertStatementError("07000", cs);
1:b98b60e: 
1:b98b60e:         // Setting the parameter again should make it work.
1:b98b60e:         cs.setInt(1, 1);
1:b98b60e:         cs.execute();
1:b98b60e:         assertEquals(10, cs.getInt(1));
1:b98b60e:     }
1:b98b60e: 
1:b98b60e:     /**
1:b98b60e:      * Stored procedure used by the regression test case for DERBY-2516.
1:b98b60e:      *
1:b98b60e:      * @param i INOUT parameter that gets set to 10 by the procedure
1:b98b60e:      */
1:b98b60e:     public static void proc_2516(Integer[] i) {
1:39b3237:         i[0] = 10;
1:b98b60e:     }
1:b98b60e: 
1:d8383bd:     /**
1:99d9d5c:      * Test that we create and execute stored procedures with as many
1:99d9d5c:      * parameters as the Java specification allows.
1:99d9d5c:      */
1:99d9d5c:     public void testMaxNumberOfParameters() throws SQLException {
1:99d9d5c:         // Test with the maximum number of parameters allowed by the
1:99d9d5c:         // Java Virtual Machine specification. That is, 255 parameters.
1:99d9d5c:         testMaxNumberOfParameters(255, true);
1:99d9d5c: 
1:99d9d5c:         // Test with one more parameter than allowed. Since we have no way
1:99d9d5c:         // to declare a method with that many parameters, expect execution to
1:99d9d5c:         // fail gracefully. The DDL will work, however.
1:99d9d5c:         testMaxNumberOfParameters(256, false);
1:99d9d5c: 
1:99d9d5c:         // Test with a very high number of parameters. Again, expect DDL to
1:99d9d5c:         // succeed and execution to fail gracefully.
1:99d9d5c:         testMaxNumberOfParameters(10000, false);
1:99d9d5c:     }
1:99d9d5c: 
1:99d9d5c:     /**
1:99d9d5c:      * Create and execute a stored procedure backed by a Java method with the
1:99d9d5c:      * specified number of parameters.
1:99d9d5c:      *
1:99d9d5c:      * @param params the number of parameters
1:99d9d5c:      * @param methodExists whether or not a method called
1:99d9d5c:      * {@code procWithManyParams} with the specified number of parameters
1:99d9d5c:      * exists
1:99d9d5c:      */
1:99d9d5c:     private void testMaxNumberOfParameters(int params, boolean methodExists)
1:99d9d5c:             throws SQLException {
1:99d9d5c:         final String javaMethod = getClass().getName() + ".procWithManyParams";
1:99d9d5c:         final String sqlProc = "PROC_WITH_LOTS_OF_PARAMETERS";
1:99d9d5c: 
1:99d9d5c:         // Disable auto-commit for easy cleanup with rollback().
1:99d9d5c:         setAutoCommit(false);
1:99d9d5c: 
1:99d9d5c:         // Create a procedure with many parameters.
1:99d9d5c: 
1:99d9d5c:         StringBuffer sb = new StringBuffer("create procedure ");
1:99d9d5c:         sb.append(sqlProc).append('(');
1:99d9d5c:         for (int i = 0; i < params; i++) {
1:99d9d5c:             if (i > 0) {
1:99d9d5c:                 sb.append(',');
1:99d9d5c:             }
1:99d9d5c:             sb.append('p').append(i).append(" int");
1:99d9d5c:         }
1:99d9d5c:         sb.append(") language java parameter style java external name '");
1:99d9d5c:         sb.append(javaMethod).append("' no sql");
1:99d9d5c: 
1:99d9d5c:         Statement s = createStatement();
1:99d9d5c:         s.execute(sb.toString());
1:99d9d5c: 
1:99d9d5c:         // Check that the database meta-data has correct information.
1:99d9d5c:         DatabaseMetaData dmd = getConnection().getMetaData();
1:99d9d5c: 
1:99d9d5c:         JDBC.assertFullResultSet(
1:99d9d5c:             dmd.getProcedures(
1:99d9d5c:                 null, null, sqlProc),
1:99d9d5c:             new Object[][] {{
1:99d9d5c:                 "", "APP", sqlProc, null, null, null,
1:99d9d5c:                 javaMethod,
1:99d9d5c:                 Integer.valueOf(DatabaseMetaData.procedureNoResult),
1:99d9d5c:                 new JDBC.GeneratedId()
1:99d9d5c:             }},
1:99d9d5c:             false);
1:99d9d5c: 
1:99d9d5c:         JDBC.assertDrainResults(
1:99d9d5c:                 dmd.getProcedureColumns(null, null, sqlProc, "%"),
1:99d9d5c:                 params);
1:99d9d5c: 
1:99d9d5c:         // Execute the procedure.
1:99d9d5c:         sb.setLength(0);
1:99d9d5c:         sb.append("call ").append(sqlProc).append('(');
1:99d9d5c:         for (int i = 0; i < params; i++) {
1:99d9d5c:             if (i > 0) {
1:99d9d5c:                 sb.append(',');
1:99d9d5c:             }
1:99d9d5c:             sb.append(i);
1:99d9d5c:         }
1:99d9d5c:         sb.append(')');
1:99d9d5c: 
1:99d9d5c:         if (methodExists) {
1:99d9d5c:             s.execute(sb.toString());
1:99d9d5c:         } else {
1:99d9d5c:             assertCallError("42X50", sb.toString());
1:99d9d5c:         }
1:99d9d5c: 
1:99d9d5c:         rollback();
1:99d9d5c:     }
1:99d9d5c: 
1:99d9d5c:     public static void procWithManyParams(
1:99d9d5c:         int p001, int p002, int p003, int p004, int p005, int p006, int p007,
1:99d9d5c:         int p008, int p009, int p010, int p011, int p012, int p013, int p014,
1:99d9d5c:         int p015, int p016, int p017, int p018, int p019, int p020, int p021,
1:99d9d5c:         int p022, int p023, int p024, int p025, int p026, int p027, int p028,
1:99d9d5c:         int p029, int p030, int p031, int p032, int p033, int p034, int p035,
1:99d9d5c:         int p036, int p037, int p038, int p039, int p040, int p041, int p042,
1:99d9d5c:         int p043, int p044, int p045, int p046, int p047, int p048, int p049,
1:99d9d5c:         int p050, int p051, int p052, int p053, int p054, int p055, int p056,
1:99d9d5c:         int p057, int p058, int p059, int p060, int p061, int p062, int p063,
1:99d9d5c:         int p064, int p065, int p066, int p067, int p068, int p069, int p070,
1:99d9d5c:         int p071, int p072, int p073, int p074, int p075, int p076, int p077,
1:99d9d5c:         int p078, int p079, int p080, int p081, int p082, int p083, int p084,
1:99d9d5c:         int p085, int p086, int p087, int p088, int p089, int p090, int p091,
1:99d9d5c:         int p092, int p093, int p094, int p095, int p096, int p097, int p098,
1:99d9d5c:         int p099, int p100, int p101, int p102, int p103, int p104, int p105,
1:99d9d5c:         int p106, int p107, int p108, int p109, int p110, int p111, int p112,
1:99d9d5c:         int p113, int p114, int p115, int p116, int p117, int p118, int p119,
1:99d9d5c:         int p120, int p121, int p122, int p123, int p124, int p125, int p126,
1:99d9d5c:         int p127, int p128, int p129, int p130, int p131, int p132, int p133,
1:99d9d5c:         int p134, int p135, int p136, int p137, int p138, int p139, int p140,
1:99d9d5c:         int p141, int p142, int p143, int p144, int p145, int p146, int p147,
1:99d9d5c:         int p148, int p149, int p150, int p151, int p152, int p153, int p154,
1:99d9d5c:         int p155, int p156, int p157, int p158, int p159, int p160, int p161,
1:99d9d5c:         int p162, int p163, int p164, int p165, int p166, int p167, int p168,
1:99d9d5c:         int p169, int p170, int p171, int p172, int p173, int p174, int p175,
1:99d9d5c:         int p176, int p177, int p178, int p179, int p180, int p181, int p182,
1:99d9d5c:         int p183, int p184, int p185, int p186, int p187, int p188, int p189,
1:99d9d5c:         int p190, int p191, int p192, int p193, int p194, int p195, int p196,
1:99d9d5c:         int p197, int p198, int p199, int p200, int p201, int p202, int p203,
1:99d9d5c:         int p204, int p205, int p206, int p207, int p208, int p209, int p210,
1:99d9d5c:         int p211, int p212, int p213, int p214, int p215, int p216, int p217,
1:99d9d5c:         int p218, int p219, int p220, int p221, int p222, int p223, int p224,
1:99d9d5c:         int p225, int p226, int p227, int p228, int p229, int p230, int p231,
1:99d9d5c:         int p232, int p233, int p234, int p235, int p236, int p237, int p238,
1:99d9d5c:         int p239, int p240, int p241, int p242, int p243, int p244, int p245,
1:99d9d5c:         int p246, int p247, int p248, int p249, int p250, int p251, int p252,
1:99d9d5c:         int p253, int p254, int p255)
1:99d9d5c:     {
1:99d9d5c:     }
1:99d9d5c: 
1:56439cb:     // UTILITY METHODS
1:d8383bd: 
1:56439cb:     /**
1:56439cb:      * Raises an exception if the exception is not caused by
1:56439cb:      * <code>executeQuery()</code> returning no result set.
1:56439cb:      *
1:56439cb:      * @param sqle a <code>SQLException</code> value
1:56439cb:      */
1:576a49f:     private void assertNoResultSetFromExecuteQuery(SQLException sqle) {
1:d8383bd:         assertSQLState("Unexpected SQL state.", "X0Y78", sqle);        
1:d8383bd:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Raises an exception if the exception is not caused by
1:56439cb:      * <code>executeQuery()</code> returning multiple result sets.
1:56439cb:      *
1:56439cb:      * @param sqle a <code>SQLException</code> value
1:56439cb:      */
1:576a49f:     private void assertMultipleResultsFromExecuteQuery(SQLException sqle)
1:56439cb:     {
1:d8383bd:         assertSQLState("Unexpected SQL state.", "X0Y78", sqle);        
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Raises an exception if the exception is not caused by
1:56439cb:      * <code>executeUpdate()</code> returning result sets.
1:56439cb:      *
1:56439cb:      * @param sqle a <code>SQLException</code> value
1:56439cb:      */
1:576a49f:     private void assertResultsFromExecuteUpdate(SQLException sqle) {
1:d8383bd:         assertSQLState("Unexpected SQL state.", "X0Y79", sqle);
1:56439cb:     }
1:56439cb: 
1:56439cb:     // SETUP
1:56439cb: 
1:56439cb:     /**
1:283931e:      * Runs the test fixtures in embedded and client.
1:283931e:      * @return test suite
1:56439cb:      */
1:56439cb:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ProcedureTest");
1:56439cb: 
1:283931e:         suite.addTest(baseSuite("ProcedureTest:embedded"));
1:283931e: 
1:283931e:         suite.addTest(
1:283931e:                 TestConfiguration.clientServerDecorator(
1:283931e:                         baseSuite("ProcedureTest:client")));    
1:283931e:         return suite;
1:56439cb:     }
1:283931e: 
1:56439cb:     /**
1:56439cb:      * Creates the test suite and wraps it in a <code>TestSetup</code>
1:56439cb:      * instance which sets up and tears down the test environment.
1:56439cb:      * @return test suite
1:56439cb:      */
1:283931e:     private static Test baseSuite(String name)
1:283931e:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:56439cb:         
1:b24134e:         // Need JDBC DriverManager to run these tests
1:b24134e:         if (!JDBC.vmSupportsJDBC3())
1:b24134e:             return suite;
1:56439cb:         
1:2fd14fb:         suite.addTestSuite(ProcedureTest.class);
1:56439cb:         
1:283931e:         return new CleanDatabaseTestSetup(suite) {
1:56439cb:             /**
1:56439cb:              * Creates the tables and the stored procedures used in the test
1:56439cb:              * cases.
1:56439cb:              * @exception SQLException if a database error occurs
1:56439cb:              */
1:283931e:             protected void decorateSQL(Statement s) throws SQLException
1:283931e:             {
2:56439cb:                 for (int i = 0; i < PROCEDURES.length; i++) {
1:283931e:                     s.execute(PROCEDURES[i]);
1:56439cb:                 }
2:56439cb:                 for (int i = 0; i < TABLES.length; i++) {
1:56439cb:                     s.execute(TABLES[i][1]);
1:56439cb:                 }
1:56439cb:             }
1:56439cb:         };
1:56439cb:     }
1:b24134e: 
1:56439cb:     /**
1:56439cb:      * Sets up the connection for a test case and clears all tables
1:56439cb:      * used in the test cases.
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public void setUp() throws SQLException {
1:03a99e2:         Connection conn = getConnection();
1:56439cb:         conn.setAutoCommit(false);
1:b24134e:         Statement s = createStatement();
1:56439cb:         for (int i = 0; i < TABLES.length; i++) {
1:56439cb:             s.execute("DELETE FROM " + TABLES[i][0]);
1:56439cb:         }
1:b24134e:         commit();
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Procedures that should be created before the tests are run and
1:56439cb:      * dropped when the tests have finished. First element in each row
1:56439cb:      * is the name of the procedure, second element is SQL which
1:56439cb:      * creates it.
1:56439cb:      */
1:283931e:     private static final String[] PROCEDURES = {
1:56439cb:        
1:56439cb:           "CREATE PROCEDURE RETRIEVE_DYNAMIC_RESULTS(number INT) " +
1:56439cb:           "LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:56439cb:           ProcedureTest.class.getName() + ".retrieveDynamicResults' " +
1:283931e:           "DYNAMIC RESULT SETS 4",
1:283931e: 
1:283931e: 
1:56439cb:           "CREATE PROCEDURE RETRIEVE_CLOSED_RESULT() LANGUAGE JAVA " +
1:56439cb:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:56439cb:           ProcedureTest.class.getName() + ".retrieveClosedResult' " +
1:283931e:           "DYNAMIC RESULT SETS 1",
1:283931e: 
1:09ffc9b:           "CREATE PROCEDURE RETRIEVE_EXTERNAL_RESULT(" +
1:09ffc9b:           "DBNAME VARCHAR(128), DBUSER VARCHAR(128), DBPWD VARCHAR(128)) LANGUAGE JAVA " +
1:56439cb:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:56439cb:           ProcedureTest.class.getName() + ".retrieveExternalResult' " +
1:283931e:           "DYNAMIC RESULT SETS 1",
1:283931e: 
1:56439cb:           "CREATE PROCEDURE PROC_WITH_SIDE_EFFECTS(ret INT) LANGUAGE JAVA " +
1:56439cb:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:56439cb:           ProcedureTest.class.getName() + ".procWithSideEffects' " +
1:a66fdc1:           "DYNAMIC RESULT SETS 2",
1:56439cb:           
1:a66fdc1:           "CREATE PROCEDURE NESTED_RESULT_SETS(proctext VARCHAR(128)) LANGUAGE JAVA " +
1:a66fdc1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:a66fdc1:           ProcedureTest.class.getName() + ".nestedDynamicResultSets' " +
1:0252fa4:           "DYNAMIC RESULT SETS 6",
1:a66fdc1: 
1:0252fa4:           "CREATE PROCEDURE INT_OUT(OUT X INTEGER) LANGUAGE JAVA " +
1:0252fa4:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:0252fa4:           ProcedureTest.class.getName() + ".intOut'",
1:56439cb:     };
1:283931e: 
1:56439cb:     /**
1:56439cb:      * Tables that should be created before the tests are run and
1:56439cb:      * dropped when the tests have finished. The tables will be
1:56439cb:      * cleared before each test case is run. First element in each row
1:56439cb:      * is the name of the table, second element is the SQL text which
1:56439cb:      * creates it.
1:56439cb:      */
1:56439cb:     private static final String[][] TABLES = {
1:56439cb:         // SIMPLE_TABLE is used by PROC_WITH_SIDE_EFFECTS
1:56439cb:         { "SIMPLE_TABLE", "CREATE TABLE SIMPLE_TABLE (id INT)" },
1:56439cb:     };
1:56439cb: 
1:56439cb:     // PROCEDURES
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Stored procedure which returns 0, 1, 2, 3 or 4 <code>ResultSet</code>s.
1:56439cb:      *
1:56439cb:      * @param number the number of <code>ResultSet</code>s to return
1:56439cb:      * @param rs1 first <code>ResultSet</code>
1:56439cb:      * @param rs2 second <code>ResultSet</code>
1:56439cb:      * @param rs3 third <code>ResultSet</code>
1:56439cb:      * @param rs4 fourth <code>ResultSet</code>
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public static void retrieveDynamicResults(int number,
1:56439cb:                                               ResultSet[] rs1,
1:56439cb:                                               ResultSet[] rs2,
1:56439cb:                                               ResultSet[] rs3,
1:56439cb:                                               ResultSet[] rs4)
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:56439cb:         if (number > 0) {
1:56439cb:             rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
1:56439cb:         if (number > 1) {
1:56439cb:             rs2[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
1:56439cb:         if (number > 2) {
1:56439cb:             rs3[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
1:56439cb:         if (number > 3) {
1:56439cb:             rs4[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
3:56439cb:         c.close();
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Stored procedure which produces a closed result set.
1:56439cb:      *
1:56439cb:      * @param closed holder for the closed result set
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public static void retrieveClosedResult(ResultSet[] closed)
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:56439cb:         closed[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         closed[0].close();
1:56439cb:         c.close();
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Stored procedure which produces a result set in another
1:56439cb:      * connection.
1:56439cb:      *
1:56439cb:      * @param external result set from another connection
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:09ffc9b:     public static void retrieveExternalResult(String dbName, 
1:09ffc9b:             String user, String password, ResultSet[] external)
1:56439cb:         throws SQLException
1:56439cb:     {
1:09ffc9b:         // Use a server-side connection to the same database.
1:09ffc9b:         String url = "jdbc:derby:" + dbName;
1:a66fdc1:         
1:09ffc9b:         Connection conn = DriverManager.getConnection(url, user, password);
1:283931e:         
1:56439cb:         external[0] =
1:09ffc9b:             conn.createStatement().executeQuery("VALUES(1)");
1:56439cb:     }
1:56439cb: 
1:56439cb:     /**
1:56439cb:      * Stored procedure which inserts a row into SIMPLE_TABLE and
1:56439cb:      * optionally returns result sets.
1:56439cb:      *
1:56439cb:      * @param returnResults if one, return one result set; if greater
1:56439cb:      * than one, return two result sets; otherwise, return no result
1:56439cb:      * set
1:56439cb:      * @param rs1 first result set to return
1:56439cb:      * @param rs2 second result set to return
1:56439cb:      * @exception SQLException if a database error occurs
1:56439cb:      */
1:56439cb:     public static void procWithSideEffects(int returnResults,
1:56439cb:                                            ResultSet[] rs1,
1:56439cb:                                            ResultSet[] rs2)
1:56439cb:         throws SQLException
1:56439cb:     {
1:56439cb:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:56439cb:         Statement stmt = c.createStatement();
1:56439cb:         stmt.executeUpdate("INSERT INTO SIMPLE_TABLE VALUES (42)");
1:56439cb:         if (returnResults > 0) {
1:56439cb:             rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
1:56439cb:         if (returnResults > 1) {
1:56439cb:             rs2[0] = c.createStatement().executeQuery("VALUES(1)");
1:56439cb:         }
1:56439cb:         c.close();
1:56439cb:     }
1:283931e:     
1:56439cb:     /**
1:a66fdc1:      * Method for a Java procedure that calls another procedure
1:a66fdc1:      * and just passes on the dynamic results from that call.
1:56439cb:      */
1:a66fdc1:     public static void nestedDynamicResultSets(String procedureText,
1:a66fdc1:             ResultSet[] rs1, ResultSet[] rs2, ResultSet[] rs3, ResultSet[] rs4,
1:a66fdc1:             ResultSet[] rs5, ResultSet[] rs6)
1:a66fdc1:     throws SQLException
1:a66fdc1:     {
1:a66fdc1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:a66fdc1:         
1:a66fdc1:         CallableStatement cs = c.prepareCall("CALL " + procedureText);
1:a66fdc1:         
1:a66fdc1:         cs.execute();
1:a66fdc1:         
1:a66fdc1:         // Mix up the order of the result sets in the returned
1:a66fdc1:         // parameters, ensures order is defined by creation
1:a66fdc1:         // and not parameter order.
1:a66fdc1:         rs6[0] = cs.getResultSet();
1:a66fdc1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:a66fdc1:             return;
1:a66fdc1:         rs3[0] = cs.getResultSet();
1:a66fdc1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:a66fdc1:             return;
1:a66fdc1:         rs4[0] = cs.getResultSet();
1:a66fdc1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:a66fdc1:             return;
1:a66fdc1:         rs2[0] = cs.getResultSet();
1:a66fdc1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:a66fdc1:             return;
1:a66fdc1:         rs1[0] = cs.getResultSet();
1:a66fdc1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:a66fdc1:             return;
1:a66fdc1:         rs5[0] = cs.getResultSet();
1:a66fdc1:     
1:56439cb:     }
1:d1879a3: 
1:a66fdc1:     /**
1:0252fa4:      * Stored procedure with an integer output parameter.
1:0252fa4:      * @param out an output parameter
1:0252fa4:      */
1:0252fa4:     public static void intOut(int[] out) {
1:0252fa4:         out[0] = 42;
1:0252fa4:     }
1:35d620a: 
1:35d620a:     /**
1:35d620a:      * Procedure to test that INOUT args preserve their value when the
1:35d620a:      * procedure is re-executed (DERBY-2515). If you add a new datatype
1:35d620a:      * to Derby, you will need to add a new argument at the end of this
1:35d620a:      * procedure's signature.
1:35d620a:      */
1:35d620a:     public static  AllTypesTuple   makeFirstAllTypesTuple() throws Exception
1:35d620a:     {
1:35d620a:         return new AllTypesTuple
1:35d620a:             (
1:39b3237:              1L,
1:35d620a:              new HarmonySerialBlob( new byte[] { (byte) 1, (byte) 1, (byte) 1 } ),
1:35d620a:              Boolean.TRUE,
1:35d620a:              "firstt",
1:35d620a:              new byte[] { (byte) 1, (byte) 1, (byte) 1 },
1:35d620a:              new HarmonySerialClob( "firstt" ),
1:35d620a:              new Date( 1L ),
1:565f51e:              new BigDecimal( "1" ),
1:39b3237:              1.0,
1:39b3237:              1 ,
1:35d620a:              new String( "firstt" ),
1:35d620a:              new byte[] { (byte) 1, (byte) 1, (byte) 1 },
1:39b3237:              1.0F,
1:39b3237:              1,
1:35d620a:              new Time( 1L ),
1:35d620a:              new Timestamp( 1L ),
1:565f51e:              new Price( "USD", new BigDecimal( "1" ), new Timestamp( 1 ) ),
1:35d620a:              "firstt",
1:35d620a:              new byte[] { (byte) 1, (byte) 1, (byte) 1 }
1:35d620a:              );
1:35d620a:     }
1:35d620a:     public static  AllTypesTuple   makeSecondAllTypesTuple() throws Exception
1:35d620a:     {
1:35d620a:         return new AllTypesTuple
1:35d620a:             (
1:39b3237:              2L,
1:35d620a:              new HarmonySerialBlob( new byte[] { (byte) 2, (byte) 2, (byte) 2 } ),
1:35d620a:              Boolean.FALSE,
1:35d620a:              "second",
1:35d620a:              new byte[] { (byte) 2, (byte) 2, (byte) 2 },
1:35d620a:              new HarmonySerialClob( "second" ),
1:35d620a:              new Date( 2L ),
1:565f51e:              new BigDecimal( "2" ),
1:39b3237:              2.0,
1:39b3237:              2,
1:35d620a:              new String( "second" ),
1:35d620a:              new byte[] { (byte) 2, (byte) 2, (byte) 2 },
1:39b3237:              2.0F,
1:39b3237:              2,
1:35d620a:              new Time( 2L ),
1:35d620a:              new Timestamp( 2L ),
1:565f51e:              new Price( "USD", new BigDecimal( "2" ), new Timestamp( 2 ) ),
1:35d620a:              "second",
1:35d620a:              new byte[] { (byte) 2, (byte) 2, (byte) 2 }
1:35d620a:              );
1:35d620a:     }
1:35d620a:     public static  AllTypesTuple   makeThirdAllTypesTuple() throws Exception
1:35d620a:     {
1:35d620a:         return new AllTypesTuple
1:35d620a:             (
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null,
1:35d620a:              null
1:35d620a:              );
1:35d620a:     }
1:35d620a:     public static  AllTypesTuple   makeFourthAllTypesTuple() throws Exception
1:35d620a:     {
1:35d620a:         return makeFirstAllTypesTuple();
1:35d620a:     }
1:35d620a:     public  static  void    proc_2515
1:35d620a:         (
1:35d620a:          int passNumber,
1:35d620a:          String[] message,
1:35d620a:          
1:35d620a:          Long[] bigintArg,
1:35d620a:          Blob[] blobArg,
1:35d620a:          Boolean[] booleanArg,
1:35d620a:          String[] charArg,
1:35d620a:          byte[][] charForBitDataArg,
1:35d620a:          Clob[] clobArg,
1:35d620a:          Date[] dateArg,
1:35d620a:          BigDecimal[] decimalArg,
1:35d620a:          Double[] doubleArg,
1:35d620a:          Integer[] intArg,
1:35d620a:          String[] longVarcharArg,
1:35d620a:          byte[][] longVarcharForBitDataArg,
1:35d620a:          Float[] realArg,
1:35d620a:          Integer[] smallintArg,
1:35d620a:          Time[] timeArg,
1:35d620a:          Timestamp[] timestampArg,
1:35d620a:          Price[] priceArg,
1:35d620a:          String[] varcharArg,
1:35d620a:          byte[][] varcharForBitDataArg
1:35d620a:          )
1:35d620a:         throws Exception
1:35d620a:     {
1:35d620a:         AllTypesTuple   actualCallSignature = new AllTypesTuple
1:35d620a:             (
1:35d620a:              bigintArg[ 0 ],
1:35d620a:              blobArg[ 0 ],
1:35d620a:              booleanArg[ 0 ],
1:35d620a:              charArg[ 0 ],
1:35d620a:              charForBitDataArg[ 0 ],
1:35d620a:              clobArg[ 0 ],
1:35d620a:              dateArg[ 0 ],
1:35d620a:              decimalArg[ 0 ],
1:35d620a:              doubleArg[ 0 ],
1:35d620a:              intArg[ 0 ],
1:35d620a:              longVarcharArg[ 0 ],
1:35d620a:              longVarcharForBitDataArg[ 0 ],
1:35d620a:              realArg[ 0 ],
1:35d620a:              smallintArg[ 0 ],
1:35d620a:              timeArg[ 0 ],
1:35d620a:              timestampArg[ 0 ],
1:35d620a:              priceArg[ 0 ],
1:35d620a:              varcharArg[ 0 ],
1:35d620a:              varcharForBitDataArg[ 0 ]
1:35d620a:              );
1:35d620a:         AllTypesTuple   expectedCallSignature;
1:35d620a:         AllTypesTuple   returnSignature;
1:35d620a: 
1:35d620a:         switch( passNumber )
1:35d620a:         {
1:35d620a:         case 0:
1:35d620a:             expectedCallSignature = makeFirstAllTypesTuple();
1:35d620a:             returnSignature = makeSecondAllTypesTuple();
1:35d620a:             break;
1:35d620a:         case 1:
1:35d620a:             expectedCallSignature = makeSecondAllTypesTuple();
1:35d620a:             returnSignature = makeThirdAllTypesTuple();
1:35d620a:             break;
1:35d620a:         case 2:
1:35d620a:         default:
1:35d620a:             expectedCallSignature = makeThirdAllTypesTuple();
1:35d620a:             returnSignature = makeFourthAllTypesTuple();
1:35d620a:             break;
1:35d620a:         }
1:35d620a: 
1:35d620a:         message[ 0 ] = expectedCallSignature.compare( actualCallSignature );
1:35d620a:         
1:35d620a:         bigintArg[ 0 ] = returnSignature.get_bigintArg();
1:35d620a:         blobArg[ 0 ] = returnSignature.get_blobArg();
1:35d620a:         booleanArg[ 0 ] = returnSignature.get_booleanArg();
1:35d620a:         charArg[ 0 ] = returnSignature.get_charArg();
1:35d620a:         charForBitDataArg[ 0 ] = returnSignature.get_charForBitDataArg();
1:35d620a:         clobArg[ 0 ] = returnSignature.get_clobArg();
1:35d620a:         dateArg[ 0 ] = returnSignature.get_dateArg();
1:35d620a:         decimalArg[ 0 ] = returnSignature.get_decimalArg();
1:35d620a:         doubleArg[ 0 ] = returnSignature.get_doubleArg();
1:35d620a:         intArg[ 0 ] = returnSignature.get_intArg();
1:35d620a:         longVarcharArg[ 0 ] = returnSignature.get_longVarcharArg();
1:35d620a:         longVarcharForBitDataArg[ 0 ] = returnSignature.get_longVarcharForBitDataArg();
1:35d620a:         realArg[ 0 ] = returnSignature.get_realArg();
1:35d620a:         smallintArg[ 0 ] = returnSignature.get_smallintArg();
1:35d620a:         timeArg[ 0 ] = returnSignature.get_timeArg();
1:35d620a:         timestampArg[ 0 ] = returnSignature.get_timestampArg();
1:35d620a:         priceArg[ 0 ] = returnSignature.get_priceArg();
1:35d620a:         varcharArg[ 0 ] = returnSignature.get_varcharArg();
1:35d620a:         varcharForBitDataArg[ 0 ] = returnSignature.get_varcharForBitDataArg();
1:35d620a:     }
1:2b04028:     
1:283931e:         /**
1:c9bb465:          * Test various combinations of getMoreResults
1:56439cb:          * 
1:c9bb465:          * @throws SQLException
1:a66fdc1:          */
1:c9bb465:         public void testGetMoreResults() throws SQLException {
1:09ffc9b: 
1:b24134e:                 Statement s = createStatement();
1:09ffc9b:                 
1:09ffc9b: 
1:c9bb465:                 s.executeUpdate("create table MRS.FIVERS(i integer)");
1:b24134e:                 PreparedStatement ps = prepareStatement("insert into MRS.FIVERS values (?)");
1:c9bb465:                 for (int i = 1; i <= 20; i++) {
1:c9bb465:                         ps.setInt(1, i);
1:c9bb465:                         ps.executeUpdate();
1:56439cb:                 }
1:09ffc9b: 
1:c9bb465:                 // create a procedure that returns 5 result sets.
1:09ffc9b:                         
1:c9bb465:                 s.executeUpdate("create procedure MRS.FIVEJP() parameter style JAVA READS SQL DATA dynamic result sets 5 language java external name 'org.apache.derbyTesting.functionTests.util.ProcedureTest.fivejp'");
1:2fd14fb: 
1:2fd14fb: 
1:b24134e:                 CallableStatement cs = prepareCall("CALL MRS.FIVEJP()");
1:c9bb465:                 ResultSet[] allRS = new ResultSet[5];
1:6e0750f: 
1:c9bb465:                 defaultGetMoreResults(cs, allRS);
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:c9bb465:                 closeCurrentGetMoreResults(cs, allRS);
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:c9bb465:                 keepCurrentGetMoreResults(cs, allRS);                              
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:c9bb465:                 mixedGetMoreResults(cs, allRS);
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:c9bb465:                 checkExecuteClosesResults(cs, allRS);
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:c9bb465:                 checkCSCloseClosesResults(cs,allRS);
1:c9bb465:                 java.util.Arrays.fill(allRS, null);
1:a66fdc1:                 
1:a66fdc1:                 // a procedure that calls another procedure that returns
1:a66fdc1:                 // dynamic result sets, see if the result sets are handled
1:a66fdc1:                 // correctly through the nesting.
1:a66fdc1:                 CallableStatement nestedCs = prepareCall(
1:a66fdc1:                         "CALL NESTED_RESULT_SETS('MRS.FIVEJP()')");
1:a66fdc1:                 defaultGetMoreResults(nestedCs, allRS);
1:a66fdc1:                 
1:56439cb:         }
1:c9bb465: 
1:c9bb465:         
1:6e0750f:         /**
1:c9bb465:          * Check that CallableStatement.execute() closes results
1:c9bb465:          * @param cs
1:c9bb465:          * @param allRS
1:c9bb465:          * @throws SQLException
1:283931e:          */
1:c9bb465:         private void checkExecuteClosesResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             //Fetching result sets with getMoreResults(Statement.KEEP_CURRENT_RESULT) and checking that cs.execute() closes them");          
1:c9bb465:             cs.execute();
1:c9bb465:             int pass = 0;
1:c9bb465:             do {
28:c9bb465: 
1:f62cb68:                     allRS[pass++] = cs.getResultSet();      
1:f62cb68:                     assertSame(cs, allRS[pass-1].getStatement());
1:c9bb465:                     // expect everything to stay open.                        
1:c9bb465: 
1:c9bb465:             } while (cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:c9bb465:             //fetched all results
1:c9bb465:             // All should still be open.
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertDrainResults(allRS[i]);                
1:c9bb465:             
1:c9bb465:             cs.execute();
1:c9bb465:             // all should be closed.
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertClosed(allRS[i]);
1:56439cb:         }
1:c9bb465: 
1:6e0750f:         /**
1:c9bb465:          * Check that CallableStatement.close() closes results
1:c9bb465:          * @param cs
1:c9bb465:          * @param allRS
1:c9bb465:          * @throws SQLException
1:6e0750f:          */
1:c9bb465:         private void checkCSCloseClosesResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             cs.execute();
1:c9bb465:             int pass = 0;
1:c9bb465:             do {
1:c9bb465: 
1:f62cb68:                     allRS[pass++] = cs.getResultSet();         
1:f62cb68:                     assertSame(cs, allRS[pass-1].getStatement());
1:c9bb465:                     // expect everything to stay open.                        
1:c9bb465: 
1:c9bb465:             } while (cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:c9bb465:             //fetched all results
1:c9bb465:             // All should still be open.
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertDrainResults(allRS[i]);                
1:c9bb465:             
3:56439cb:             cs.close();
1:c9bb465:             // all should be closed.
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertClosed(allRS[i]);
1:56439cb:         }
1:c9bb465: 
1:c9bb465:         private void mixedGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             //Fetching result sets with getMoreResults(<mixture>)"
1:c9bb465:             cs.execute();
1:c9bb465: 
1:c9bb465:             //first two with KEEP_CURRENT_RESULT"
4:c9bb465:             allRS[0] = cs.getResultSet();
1:f62cb68:             assertSame(cs, allRS[0].getStatement());
1:c9bb465:             boolean moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:c9bb465:             if (!moreRS)
1:c9bb465:                     fail("FAIL - no second result set");
1:f62cb68:             allRS[1] = cs.getResultSet();   
1:f62cb68:             assertSame(cs, allRS[1].getStatement());
1:c9bb465:             // two open
4:c9bb465:             allRS[0].next();
4:c9bb465:             assertEquals(2,allRS[0].getInt(1));
4:c9bb465:             allRS[1].next();
4:c9bb465:             assertEquals(3,allRS[1].getInt(1));
1:c9bb465:             
1:c9bb465:             //third with CLOSE_CURRENT_RESULT"
1:c9bb465:             moreRS = cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:c9bb465:             if (!moreRS)
1:c9bb465:                     fail("FAIL - no third result set");
1:c9bb465:             // first and third open
4:c9bb465:             allRS[2] = cs.getResultSet();
1:f62cb68:             assertSame(cs, allRS[2].getStatement());
1:c9bb465:             assertEquals(2,allRS[0].getInt(1));
1:c9bb465:             JDBC.assertClosed(allRS[1]);
4:c9bb465:             allRS[2].next();
4:c9bb465:             assertEquals(4,allRS[2].getInt(1));
1:c9bb465: 
1:c9bb465:             
1:c9bb465:             //fourth with KEEP_CURRENT_RESULT"
1:c9bb465:             moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:c9bb465:             if (!moreRS)
1:c9bb465:                     fail("FAIL - no fourth result set");
4:c9bb465:             allRS[3] = cs.getResultSet();
1:f62cb68:             assertSame(cs, allRS[3].getStatement());
4:c9bb465:             allRS[3].next();
1:c9bb465:             // first, third and fourth open, second closed
1:c9bb465:             assertEquals(2,allRS[0].getInt(1));
1:c9bb465:             JDBC.assertClosed(allRS[1]);
1:c9bb465:             assertEquals(4,allRS[2].getInt(1));
4:c9bb465:             assertEquals(5,allRS[3].getInt(1));
1:c9bb465:             
1:c9bb465:             //fifth with CLOSE_ALL_RESULTS"
1:c9bb465:             moreRS = cs.getMoreResults(Statement.CLOSE_ALL_RESULTS);
1:c9bb465:             if (!moreRS)
1:c9bb465:                    fail("FAIL - no fifth result set");
4:c9bb465:             allRS[4] = cs.getResultSet();
1:f62cb68:             assertSame(cs, allRS[4].getStatement());
4:c9bb465:             allRS[4].next();
1:c9bb465:             // only fifth open
1:c9bb465:             JDBC.assertClosed(allRS[0]);
1:c9bb465:             JDBC.assertClosed(allRS[1]);
1:c9bb465:             JDBC.assertClosed(allRS[2]);
1:c9bb465:             JDBC.assertClosed(allRS[3]);
4:c9bb465:             assertEquals(6,allRS[4].getInt(1));
1:c9bb465:             
1:c9bb465:             //no more results with with KEEP_CURRENT_RESULT"
1:c9bb465:             moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:c9bb465:             if (moreRS)
1:c9bb465:                     fail("FAIL - too many result sets");
1:c9bb465:             // only fifth open
1:c9bb465:             JDBC.assertClosed(allRS[0]);
1:c9bb465:             JDBC.assertClosed(allRS[1]);
1:c9bb465:             JDBC.assertClosed(allRS[2]);
1:c9bb465:             JDBC.assertClosed(allRS[3]);
1:c9bb465:             assertEquals(6,allRS[4].getInt(1));
1:c9bb465:             
1:c9bb465:             allRS[4].close();
1:56439cb:         }
1:c9bb465: 
1:56439cb:         /**
1:c9bb465:          * Check getMoreResults(Statement.KEEP_CURRENT_RESULT)  
1:56439cb:          * 
1:c9bb465:          * @param cs
1:c9bb465:          * @param allRS
1:c9bb465:          * @throws SQLException
1:6e0750f:          */
1:c9bb465:         private void keepCurrentGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             cs.execute();
1:c9bb465:             
1:84eabad:             for (int i = 0; i < 5; i++)
1:84eabad:             {
1:84eabad:                 allRS[i] = cs.getResultSet();
1:f62cb68:                 assertSame(cs, allRS[i].getStatement());
1:84eabad:                 allRS[i].next();
1:84eabad:                 assertEquals(2+i, allRS[i].getInt(1));
1:84eabad:                 
1:84eabad:                 if (i < 4)
1:84eabad:                     assertTrue(cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:84eabad:                 else
1:84eabad:                     assertFalse(cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:56439cb:             }            
1:c9bb465:             
1:c9bb465:             // resultSets should still be open
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertDrainResults(allRS[i]);
1:56439cb:         }
1:c9bb465: 
1:c9bb465:         private void closeCurrentGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             cs.execute();
1:84eabad:             
1:84eabad:             for (int i = 0; i < 5; i++)
1:84eabad:             {
1:84eabad:                 allRS[i] = cs.getResultSet();
1:f62cb68:                 assertSame(cs, allRS[i].getStatement());
1:84eabad:                 allRS[i].next();
1:84eabad:                 assertEquals(2+i, allRS[i].getInt(1));
1:c9bb465:                 
1:84eabad:                 if (i < 4)
1:84eabad:                     assertTrue(cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT));
1:84eabad:                 else
1:84eabad:                     assertFalse(cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT));
1:56439cb:             }
1:c9bb465:             
1:c9bb465:             // verify resultSets are closed
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertClosed(allRS[i]);
1:56439cb:         }
1:c9bb465: 
5:c9bb465:         /**
1:c9bb465:          * Test default getMoreResults() closes result set.
1:c9bb465:          * @param cs
1:c9bb465:          * @param allRS
1:c9bb465:          * @throws SQLException
5:c9bb465:          */
1:c9bb465:         private void defaultGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:c9bb465:             // execute the procedure that returns 5 result sets and then use the various
1:c9bb465:             // options of getMoreResults().
1:84eabad: 
1:c9bb465:             cs.execute();
1:c9bb465:             
1:84eabad:             for (int i = 0; i < 5; i++)
1:84eabad:             {
1:84eabad:                 allRS[i] = cs.getResultSet();
1:f62cb68:                 assertSame(cs, allRS[i].getStatement());
1:84eabad:                 allRS[i].next();
1:84eabad:                 assertEquals(2+i, allRS[i].getInt(1));
1:c9bb465:                 
1:84eabad:                 if (i < 4)
1:84eabad:                     assertTrue(cs.getMoreResults());
1:84eabad:                 else
1:84eabad:                     assertFalse(cs.getMoreResults());
1:56439cb:             } 
1:84eabad:                         
1:c9bb465:             // verify resultSets are closed
1:c9bb465:             for (int i = 0; i < 5; i++)
1:c9bb465:                 JDBC.assertClosed(allRS[i]);
1:a66fdc1:         }
1:c9bb465: 
1:35d620a:     ////////////////////////////////////////////
1:35d620a:     //
1:35d620a:     // Nested classes.
1:35d620a:     //
1:35d620a:     ////////////////////////////////////////////
1:35d620a: 
1:35d620a:     public  static  final   class   AllTypesTuple
1:35d620a:     {
1:35d620a:         private Long _bigintArg;
1:35d620a:         private Blob _blobArg;
1:35d620a:         private Boolean _booleanArg;
1:35d620a:         private String _charArg;
1:35d620a:         private byte[] _charForBitDataArg;
1:35d620a:         private Clob _clobArg;
1:35d620a:         private Date _dateArg;
1:35d620a:         private BigDecimal _decimalArg;
1:35d620a:         private Double _doubleArg;
1:35d620a:         private Integer _intArg;
1:35d620a:         private String _longVarcharArg;
1:35d620a:         private byte[] _longVarcharForBitDataArg;
1:35d620a:         private Float _realArg;
1:35d620a:         private Integer _smallintArg;
1:35d620a:         private Time _timeArg;
1:35d620a:         private Timestamp _timestampArg;
1:35d620a:         private Price _priceArg;
1:35d620a:         private String _varcharArg;
1:35d620a:         private byte[] _varcharForBitDataArg;
1:35d620a: 
1:35d620a:         public AllTypesTuple
1:35d620a:             (
1:35d620a:              Long  bigintArg,
1:35d620a:              Blob  blobArg,
1:35d620a:              Boolean  booleanArg,
1:35d620a:              String  charArg,
1:35d620a:              byte[]   charForBitDataArg,
1:35d620a:              Clob  clobArg,
1:35d620a:              Date  dateArg,
1:35d620a:              BigDecimal  decimalArg,
1:35d620a:              Double  doubleArg,
1:35d620a:              Integer  intArg,
1:35d620a:              String  longVarcharArg,
1:35d620a:              byte[]   longVarcharForBitDataArg,
1:35d620a:              Float  realArg,
1:35d620a:              Integer  smallintArg,
1:35d620a:              Time  timeArg,
1:35d620a:              Timestamp  timestampArg,
1:35d620a:              Price  priceArg,
1:35d620a:              String  varcharArg,
1:35d620a:              byte[]   varcharForBitDataArg
1:35d620a:              )
1:35d620a:         {
1:35d620a:             _bigintArg = bigintArg;
1:35d620a:             _blobArg = blobArg;
1:35d620a:             _booleanArg = booleanArg;
1:35d620a:             _charArg = charArg;
1:35d620a:             _charForBitDataArg = charForBitDataArg;
1:35d620a:             _clobArg = clobArg;
1:35d620a:             _dateArg = dateArg;
1:35d620a:             _decimalArg = decimalArg;
1:35d620a:             _doubleArg = doubleArg;
1:35d620a:             _intArg = intArg;
1:35d620a:             _longVarcharArg = longVarcharArg;
1:35d620a:             _longVarcharForBitDataArg = longVarcharForBitDataArg;
1:35d620a:             _realArg = realArg;
1:35d620a:             _smallintArg = smallintArg;
1:35d620a:             _timeArg = timeArg;
1:35d620a:             _timestampArg = timestampArg;
1:35d620a:             _priceArg = priceArg;
1:35d620a:             _varcharArg = varcharArg;
1:35d620a:             _varcharForBitDataArg = varcharForBitDataArg;
1:35d620a:         }
1:35d620a: 
1:35d620a:         public Long get_bigintArg() { return _bigintArg; }
1:35d620a:         public Blob get_blobArg() { return _blobArg; }
1:35d620a:         public Boolean get_booleanArg() { return _booleanArg; }
1:35d620a:         public String get_charArg() { return _charArg; }
1:35d620a:         public byte[] get_charForBitDataArg() { return _charForBitDataArg; }
1:35d620a:         public Clob get_clobArg() { return _clobArg; }
1:35d620a:         public Date get_dateArg() { return _dateArg; }
1:35d620a:         public BigDecimal get_decimalArg() { return _decimalArg; }
1:35d620a:         public Double get_doubleArg() { return _doubleArg; }
1:35d620a:         public Integer get_intArg() { return _intArg; }
1:35d620a:         public String get_longVarcharArg() { return _longVarcharArg; }
1:35d620a:         public byte[] get_longVarcharForBitDataArg() { return _longVarcharForBitDataArg; }
1:35d620a:         public Float get_realArg() { return _realArg; }
1:35d620a:         public Integer get_smallintArg() { return _smallintArg; }
1:35d620a:         public Time get_timeArg() { return _timeArg; }
1:35d620a:         public Timestamp get_timestampArg() { return _timestampArg; }
1:35d620a:         public Price get_priceArg() { return _priceArg; }
1:35d620a:         public String get_varcharArg() { return _varcharArg; }
1:35d620a:         public byte[] get_varcharForBitDataArg() { return _varcharForBitDataArg; }
1:35d620a: 
1:35d620a:         public  String  compare( AllTypesTuple that ) throws Exception
1:35d620a:         {
1:35d620a:             String  message = "";
1:35d620a: 
1:35d620a:             message = message + compare( "_bigintArg", this._bigintArg, that._bigintArg );
1:35d620a:             message = message + compare( "_blobArg", this.getBlobBytes(), that.getBlobBytes() );
1:35d620a:             message = message + compare( "_booleanArg", this._booleanArg, that._booleanArg );
1:35d620a:             message = message + compare( "_charArg", this._charArg, that._charArg );
1:35d620a:             message = message + compare( "_charForBitDataArg", this._charForBitDataArg, that._charForBitDataArg );
1:35d620a:             message = message + compare( "_clobArg", this.getClobString(), that.getClobString() );
1:35d620a:             message = message + compare( "_dateArg", this.getDateString(), that.getDateString() );
1:35d620a:             message = message + compare( "_decimalArg", this._decimalArg, that._decimalArg );
1:35d620a:             message = message + compare( "_doubleArg", this._doubleArg, that._doubleArg );
1:35d620a:             message = message + compare( "_intArg", this._intArg, that._intArg );
1:35d620a:             message = message + compare( "_longVarcharArg", this._longVarcharArg, that._longVarcharArg );
1:35d620a:             message = message + compare( "_longVarcharForBitDataArg", this._longVarcharForBitDataArg, that._longVarcharForBitDataArg );
1:35d620a:             message = message + compare( "_realArg", this._realArg, that._realArg );
1:35d620a:             message = message + compare( "_smallintArg", this._smallintArg, that._smallintArg );
1:35d620a:             message = message + compare( "_timeArg", this.getTimeString(), that.getTimeString() );
1:35d620a:             message = message + compare( "_timestampArg", this._timestampArg, that._timestampArg );
1:35d620a:             message = message + compare( "_priceArg", this._priceArg, that._priceArg );
1:35d620a:             message = message + compare( "_varcharArg", this._varcharArg, that._varcharArg );
1:35d620a:             message = message + compare( "_varcharForBitDataArg", this._varcharForBitDataArg, that._varcharForBitDataArg );
1:35d620a: 
1:35d620a:             return message;
1:35d620a:         }
1:35d620a:         private byte[]  getBlobBytes() throws Exception
1:35d620a:         {
1:35d620a:             if ( _blobArg == null ) { return null; }
1:35d620a:             else { return _blobArg.getBytes( 1, (int) _blobArg.length() ); }
1:35d620a:         }
1:35d620a:         private String  getClobString() throws Exception
1:35d620a:         {
1:35d620a:             if ( _clobArg == null ) { return null; }
1:35d620a:             else { return _clobArg.getSubString( 1, (int) _clobArg.length() ); }
1:35d620a:         }
1:35d620a:         private String  getDateString()
1:35d620a:         {
1:35d620a:             if ( _dateArg ==  null ) { return null; }
1:35d620a:             else { return _dateArg.toString(); }
1:35d620a:         }
1:35d620a:         private String  getTimeString()
1:35d620a:         {
1:35d620a:             if ( _timeArg == null ) { return null; }
1:35d620a:             else { return _timeArg.toString(); }
1:35d620a:         }
1:35d620a:         private String  compare( String argName, Object left, Object right )
1:35d620a:         {
1:35d620a:             if ( left == null )
1:35d620a:             {
1:35d620a:                 if ( right == null ) { return ""; }
1:35d620a:                 return (argName + ": left was null but right was " + right);
1:35d620a:             }
1:35d620a:             if ( right == null ) { return (argName + ": left = " + left + " but right is null" ); }
1:35d620a:             if ( left instanceof byte[] ) { return compareBytes( argName, (byte[]) left, (byte[]) right ); }
1:35d620a: 
1:35d620a:             if ( left.equals( right ) ) { return ""; }
1:35d620a: 
1:35d620a:             return (argName + ": left = " + left + " but right = " + right);
1:35d620a:         }
1:35d620a:         private String  compareBytes( String argName, byte[] left, byte[] right )
1:35d620a:         {
1:35d620a:             int count = left.length;
1:35d620a: 
1:35d620a:             if ( count != right.length )
1:35d620a:             {
1:35d620a:                 return (argName + ": left count = " + count + " but right count = " + right.length );
1:35d620a:             }
1:35d620a:             for ( int i = 0; i < count; i++ )
1:35d620a:             {
1:35d620a:                 if ( left[ i ] != right[ i ] )
1:35d620a:                 {
1:35d620a:                     return (argName + ": left[ " + i + " ] = " + left[ i ] + " but right[ " + i + " ] = " + right[ i ] );
1:35d620a:                 }
1:35d620a:             }
1:35d620a: 
1:35d620a:             return "";
1:35d620a:         }
1:35d620a:     }
1:35d620a: 
1:35d620a:     
1:35d620a: 
1:84eabad: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         i[0] = 10;
/////////////////////////////////////////////////////////////////////////
1:              1L,
/////////////////////////////////////////////////////////////////////////
1:              1.0,
1:              1 ,
1:              1.0F,
1:              1,
/////////////////////////////////////////////////////////////////////////
1:              2L,
/////////////////////////////////////////////////////////////////////////
1:              2.0,
1:              2,
1:              2.0F,
1:              2,
commit:565f51e
/////////////////////////////////////////////////////////////////////////
1:              new BigDecimal( "1" ),
/////////////////////////////////////////////////////////////////////////
1:              new Price( "USD", new BigDecimal( "1" ), new Timestamp( 1 ) ),
/////////////////////////////////////////////////////////////////////////
1:              new BigDecimal( "2" ),
/////////////////////////////////////////////////////////////////////////
1:              new Price( "USD", new BigDecimal( "2" ), new Timestamp( 2 ) ),
commit:35d620a
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ProcedureTest
1:  *
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import org.apache.derby.iapi.types.HarmonySerialBlob;
1: import org.apache.derby.iapi.types.HarmonySerialClob;
1: 
1: import org.apache.derbyTesting.functionTests.tests.lang.Price;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that INOUT args are preserved over procedure invocations.
1:      * See DERBY-2515.
1:      */
1:     public  void    test_2515()   throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         
1:         PreparedStatement ps = conn.prepareStatement
1:             (
1:              "create type price_2515 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n"
1:              );
1:         ps.execute();
1:         ps.close();
1:         
1:         ps = conn.prepareStatement
1:             (
1:              "create procedure proc_2515\n" +
1:              "(\n" +
1:              "\tin passNumber int,\n" +
1:              "\tout returnMessage varchar( 32672 ),\n" +
1:              "\tinout bigintArg bigint,\n" +
1:              "\tinout blobArg blob,\n" +
1:              "inout booleanArg boolean,\n" +
1:              "inout charArg char( 6 ),\n" +
1:              "inout charForBitDataArg char( 3 ) for bit data,\n" +
1:              "inout clobArg clob,\n" +
1:              "inout dateArg date,\n" +
1:              "inout decimalArg decimal,\n" +
1:              "inout doubleArg double,\n" +
1:              "inout intArg int,\n" +
1:              "inout longVarcharArg long varchar,\n" +
1:              "inout longVarcharForBitDataArg long varchar for bit data,\n" +
1:              "inout realArg real,\n" +
1:              "inout smallintArg smallint,\n" +
1:              "inout timeArg time,\n" +
1:              "inout timestampArg timestamp,\n" +
1:              "inout priceArg price_2515,\n" +
1:              "inout varcharArg varchar( 20 ),\n" +
1:              "inout varcharForBitDataArg varchar( 3 ) for bit data\n" +
1:             ")\n" +
1:             "parameter style java language java no sql\n" +
1:             "external name '" + ProcedureTest.class.getName() + ".proc_2515'"
1:              );
1:         ps.execute();
1:         ps.close();
1: 
1:         CallableStatement   cs = conn.prepareCall
1:             ( "call proc_2515( ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ? )" );
1:         AllTypesTuple   firstArgs = makeFirstAllTypesTuple();
1: 
1:         int     idx = 2;
1:         
1:         cs.registerOutParameter( idx++, Types.VARCHAR );
1: 
1:         cs.registerOutParameter( idx, Types.BIGINT );
1:         cs.setLong( idx++, firstArgs.get_bigintArg().longValue() );
1: 
1:         cs.registerOutParameter( idx, Types.BLOB );
1:         cs.setBlob( idx++, firstArgs.get_blobArg() );
1: 
1:         cs.registerOutParameter( idx, Types.BOOLEAN );
1:         cs.setBoolean( idx++, firstArgs.get_booleanArg().booleanValue() );
1: 
1:         cs.registerOutParameter( idx, Types.CHAR );
1:         cs.setString( idx++, firstArgs.get_charArg() );
1: 
1:         cs.registerOutParameter( idx, Types.BINARY );
1:         cs.setBytes( idx++, firstArgs.get_charForBitDataArg() );
1: 
1:         cs.registerOutParameter( idx, Types.CLOB );
1:         cs.setClob( idx++, firstArgs.get_clobArg() );
1: 
1:         cs.registerOutParameter( idx, Types.DATE );
1:         cs.setDate( idx++, firstArgs.get_dateArg() );
1: 
1:         cs.registerOutParameter( idx, Types.DECIMAL );
1:         cs.setBigDecimal( idx++, firstArgs.get_decimalArg() );
1: 
1:         cs.registerOutParameter( idx, Types.DOUBLE );
1:         cs.setDouble( idx++, firstArgs.get_doubleArg().doubleValue() );
1: 
1:         cs.registerOutParameter( idx, Types.INTEGER );
1:         cs.setInt( idx++, firstArgs.get_intArg().intValue() );
1: 
1:         cs.registerOutParameter( idx, Types.LONGVARCHAR );
1:         cs.setString( idx++, firstArgs.get_longVarcharArg() );
1: 
1:         cs.registerOutParameter( idx, Types.LONGVARBINARY );
1:         cs.setBytes( idx++, firstArgs.get_longVarcharForBitDataArg() );
1: 
1:         cs.registerOutParameter( idx, Types.REAL );
1:         cs.setFloat( idx++, firstArgs.get_realArg().floatValue() );
1: 
1:         cs.registerOutParameter( idx, Types.SMALLINT );
1:         cs.setShort( idx++, firstArgs.get_smallintArg().shortValue() );
1: 
1:         cs.registerOutParameter( idx, Types.TIME );
1:         cs.setTime( idx++, firstArgs.get_timeArg() );
1: 
1:         cs.registerOutParameter( idx, Types.TIMESTAMP );
1:         cs.setTimestamp( idx++, firstArgs.get_timestampArg() );
1: 
1:         cs.registerOutParameter( idx, Types.JAVA_OBJECT );
1:         cs.setObject( idx++, firstArgs.get_priceArg() );
1: 
1:         cs.registerOutParameter( idx, Types.VARCHAR );
1:         cs.setString( idx++, firstArgs.get_varcharArg() );
1: 
1:         cs.registerOutParameter( idx, Types.VARBINARY );
1:         cs.setBytes( idx++, firstArgs.get_varcharForBitDataArg() );
1: 
1:         cs.setInt( 1, 0 );
1:         cs.execute();
1:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:         assertEquals( "", makeSecondAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1: 
1:         cs.setInt( 1, 1 );
1:         cs.execute();
1:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:         assertEquals( "", makeThirdAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1: 
1:         cs.setInt( 1, 2 );
1:         cs.execute();
1:         assertEquals( "", cs.getString( 2 ) );  // the return message should be empty, meaning the call args were what the procedure expected
1:         assertEquals( "", makeFourthAllTypesTuple().compare( getActualReturnArgs( cs ) ) );
1: 
1:         ps = conn.prepareStatement( "drop procedure proc_2515" );
1:         ps.execute();
1:         ps.close();
1: 
1:         ps = conn.prepareStatement( "drop type price_2515 restrict" );
1:         ps.execute();
1:         ps.close();
1:     }
1:     private AllTypesTuple   getActualReturnArgs( CallableStatement cs )
1:         throws Exception
1:     {
1:         int idx = 3;
1:         
1:         return new AllTypesTuple
1:             (
1:              (Long) cs.getObject( idx++ ),
1:              (Blob) cs.getObject( idx++ ),
1:              (Boolean) cs.getObject( idx++ ),
1:              (String) cs.getObject( idx++ ),
1:              (byte[]) cs.getObject( idx++ ),
1:              (Clob) cs.getObject( idx++ ),
1:              (Date) cs.getObject( idx++ ),
1:              (BigDecimal) cs.getObject( idx++ ),
1:              (Double) cs.getObject( idx++ ),
1:              (Integer) cs.getObject( idx++ ),
1:              (String) cs.getObject( idx++ ),
1:              (byte[]) cs.getObject( idx++ ),
1:              (Float) cs.getObject( idx++ ),
1:              (Integer) cs.getObject( idx++ ),
1:              (Time) cs.getObject( idx++ ),
1:              (Timestamp) cs.getObject( idx++ ),
1:              (Price) cs.getObject( idx++ ),
1:              (String) cs.getObject( idx++ ),
1:              (byte[]) cs.getObject( idx++ )
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Procedure to test that INOUT args preserve their value when the
1:      * procedure is re-executed (DERBY-2515). If you add a new datatype
1:      * to Derby, you will need to add a new argument at the end of this
1:      * procedure's signature.
1:      */
1:     public static  AllTypesTuple   makeFirstAllTypesTuple() throws Exception
1:     {
1:         return new AllTypesTuple
1:             (
0:              new Long( 1L ),
1:              new HarmonySerialBlob( new byte[] { (byte) 1, (byte) 1, (byte) 1 } ),
1:              Boolean.TRUE,
1:              "firstt",
1:              new byte[] { (byte) 1, (byte) 1, (byte) 1 },
1:              new HarmonySerialClob( "firstt" ),
1:              new Date( 1L ),
0:              new BigDecimal( 1 ),
0:              new Double( 1.0 ),
0:              new Integer( 1 ),
1:              new String( "firstt" ),
1:              new byte[] { (byte) 1, (byte) 1, (byte) 1 },
0:              new Float( 1.0F ),
0:              new Integer( 1 ),
1:              new Time( 1L ),
1:              new Timestamp( 1L ),
0:              new Price( "USD", new BigDecimal( 1 ), new Timestamp( 1 ) ),
1:              "firstt",
1:              new byte[] { (byte) 1, (byte) 1, (byte) 1 }
1:              );
1:     }
1:     public static  AllTypesTuple   makeSecondAllTypesTuple() throws Exception
1:     {
1:         return new AllTypesTuple
1:             (
0:              new Long( 2L ),
1:              new HarmonySerialBlob( new byte[] { (byte) 2, (byte) 2, (byte) 2 } ),
1:              Boolean.FALSE,
1:              "second",
1:              new byte[] { (byte) 2, (byte) 2, (byte) 2 },
1:              new HarmonySerialClob( "second" ),
1:              new Date( 2L ),
0:              new BigDecimal( 2 ),
0:              new Double( 2.0 ),
0:              new Integer( 2 ),
1:              new String( "second" ),
1:              new byte[] { (byte) 2, (byte) 2, (byte) 2 },
0:              new Float( 2.0F ),
0:              new Integer( 2 ),
1:              new Time( 2L ),
1:              new Timestamp( 2L ),
0:              new Price( "USD", new BigDecimal( 2 ), new Timestamp( 2 ) ),
1:              "second",
1:              new byte[] { (byte) 2, (byte) 2, (byte) 2 }
1:              );
1:     }
1:     public static  AllTypesTuple   makeThirdAllTypesTuple() throws Exception
1:     {
1:         return new AllTypesTuple
1:             (
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null,
1:              null
1:              );
1:     }
1:     public static  AllTypesTuple   makeFourthAllTypesTuple() throws Exception
1:     {
1:         return makeFirstAllTypesTuple();
1:     }
1:     public  static  void    proc_2515
1:         (
1:          int passNumber,
1:          String[] message,
1:          
1:          Long[] bigintArg,
1:          Blob[] blobArg,
1:          Boolean[] booleanArg,
1:          String[] charArg,
1:          byte[][] charForBitDataArg,
1:          Clob[] clobArg,
1:          Date[] dateArg,
1:          BigDecimal[] decimalArg,
1:          Double[] doubleArg,
1:          Integer[] intArg,
1:          String[] longVarcharArg,
1:          byte[][] longVarcharForBitDataArg,
1:          Float[] realArg,
1:          Integer[] smallintArg,
1:          Time[] timeArg,
1:          Timestamp[] timestampArg,
1:          Price[] priceArg,
1:          String[] varcharArg,
1:          byte[][] varcharForBitDataArg
1:          )
1:         throws Exception
1:     {
1:         AllTypesTuple   actualCallSignature = new AllTypesTuple
1:             (
1:              bigintArg[ 0 ],
1:              blobArg[ 0 ],
1:              booleanArg[ 0 ],
1:              charArg[ 0 ],
1:              charForBitDataArg[ 0 ],
1:              clobArg[ 0 ],
1:              dateArg[ 0 ],
1:              decimalArg[ 0 ],
1:              doubleArg[ 0 ],
1:              intArg[ 0 ],
1:              longVarcharArg[ 0 ],
1:              longVarcharForBitDataArg[ 0 ],
1:              realArg[ 0 ],
1:              smallintArg[ 0 ],
1:              timeArg[ 0 ],
1:              timestampArg[ 0 ],
1:              priceArg[ 0 ],
1:              varcharArg[ 0 ],
1:              varcharForBitDataArg[ 0 ]
1:              );
1:         AllTypesTuple   expectedCallSignature;
1:         AllTypesTuple   returnSignature;
1: 
1:         switch( passNumber )
1:         {
1:         case 0:
1:             expectedCallSignature = makeFirstAllTypesTuple();
1:             returnSignature = makeSecondAllTypesTuple();
1:             break;
1:         case 1:
1:             expectedCallSignature = makeSecondAllTypesTuple();
1:             returnSignature = makeThirdAllTypesTuple();
1:             break;
1:         case 2:
1:         default:
1:             expectedCallSignature = makeThirdAllTypesTuple();
1:             returnSignature = makeFourthAllTypesTuple();
1:             break;
1:         }
1: 
1:         message[ 0 ] = expectedCallSignature.compare( actualCallSignature );
1:         
1:         bigintArg[ 0 ] = returnSignature.get_bigintArg();
1:         blobArg[ 0 ] = returnSignature.get_blobArg();
1:         booleanArg[ 0 ] = returnSignature.get_booleanArg();
1:         charArg[ 0 ] = returnSignature.get_charArg();
1:         charForBitDataArg[ 0 ] = returnSignature.get_charForBitDataArg();
1:         clobArg[ 0 ] = returnSignature.get_clobArg();
1:         dateArg[ 0 ] = returnSignature.get_dateArg();
1:         decimalArg[ 0 ] = returnSignature.get_decimalArg();
1:         doubleArg[ 0 ] = returnSignature.get_doubleArg();
1:         intArg[ 0 ] = returnSignature.get_intArg();
1:         longVarcharArg[ 0 ] = returnSignature.get_longVarcharArg();
1:         longVarcharForBitDataArg[ 0 ] = returnSignature.get_longVarcharForBitDataArg();
1:         realArg[ 0 ] = returnSignature.get_realArg();
1:         smallintArg[ 0 ] = returnSignature.get_smallintArg();
1:         timeArg[ 0 ] = returnSignature.get_timeArg();
1:         timestampArg[ 0 ] = returnSignature.get_timestampArg();
1:         priceArg[ 0 ] = returnSignature.get_priceArg();
1:         varcharArg[ 0 ] = returnSignature.get_varcharArg();
1:         varcharForBitDataArg[ 0 ] = returnSignature.get_varcharForBitDataArg();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////
1:     //
1:     // Nested classes.
1:     //
1:     ////////////////////////////////////////////
1: 
1:     public  static  final   class   AllTypesTuple
1:     {
1:         private Long _bigintArg;
1:         private Blob _blobArg;
1:         private Boolean _booleanArg;
1:         private String _charArg;
1:         private byte[] _charForBitDataArg;
1:         private Clob _clobArg;
1:         private Date _dateArg;
1:         private BigDecimal _decimalArg;
1:         private Double _doubleArg;
1:         private Integer _intArg;
1:         private String _longVarcharArg;
1:         private byte[] _longVarcharForBitDataArg;
1:         private Float _realArg;
1:         private Integer _smallintArg;
1:         private Time _timeArg;
1:         private Timestamp _timestampArg;
1:         private Price _priceArg;
1:         private String _varcharArg;
1:         private byte[] _varcharForBitDataArg;
1: 
1:         public AllTypesTuple
1:             (
1:              Long  bigintArg,
1:              Blob  blobArg,
1:              Boolean  booleanArg,
1:              String  charArg,
1:              byte[]   charForBitDataArg,
1:              Clob  clobArg,
1:              Date  dateArg,
1:              BigDecimal  decimalArg,
1:              Double  doubleArg,
1:              Integer  intArg,
1:              String  longVarcharArg,
1:              byte[]   longVarcharForBitDataArg,
1:              Float  realArg,
1:              Integer  smallintArg,
1:              Time  timeArg,
1:              Timestamp  timestampArg,
1:              Price  priceArg,
1:              String  varcharArg,
1:              byte[]   varcharForBitDataArg
1:              )
1:         {
1:             _bigintArg = bigintArg;
1:             _blobArg = blobArg;
1:             _booleanArg = booleanArg;
1:             _charArg = charArg;
1:             _charForBitDataArg = charForBitDataArg;
1:             _clobArg = clobArg;
1:             _dateArg = dateArg;
1:             _decimalArg = decimalArg;
1:             _doubleArg = doubleArg;
1:             _intArg = intArg;
1:             _longVarcharArg = longVarcharArg;
1:             _longVarcharForBitDataArg = longVarcharForBitDataArg;
1:             _realArg = realArg;
1:             _smallintArg = smallintArg;
1:             _timeArg = timeArg;
1:             _timestampArg = timestampArg;
1:             _priceArg = priceArg;
1:             _varcharArg = varcharArg;
1:             _varcharForBitDataArg = varcharForBitDataArg;
1:         }
1: 
1:         public Long get_bigintArg() { return _bigintArg; }
1:         public Blob get_blobArg() { return _blobArg; }
1:         public Boolean get_booleanArg() { return _booleanArg; }
1:         public String get_charArg() { return _charArg; }
1:         public byte[] get_charForBitDataArg() { return _charForBitDataArg; }
1:         public Clob get_clobArg() { return _clobArg; }
1:         public Date get_dateArg() { return _dateArg; }
1:         public BigDecimal get_decimalArg() { return _decimalArg; }
1:         public Double get_doubleArg() { return _doubleArg; }
1:         public Integer get_intArg() { return _intArg; }
1:         public String get_longVarcharArg() { return _longVarcharArg; }
1:         public byte[] get_longVarcharForBitDataArg() { return _longVarcharForBitDataArg; }
1:         public Float get_realArg() { return _realArg; }
1:         public Integer get_smallintArg() { return _smallintArg; }
1:         public Time get_timeArg() { return _timeArg; }
1:         public Timestamp get_timestampArg() { return _timestampArg; }
1:         public Price get_priceArg() { return _priceArg; }
1:         public String get_varcharArg() { return _varcharArg; }
1:         public byte[] get_varcharForBitDataArg() { return _varcharForBitDataArg; }
1: 
1:         public  String  compare( AllTypesTuple that ) throws Exception
1:         {
1:             String  message = "";
1: 
1:             message = message + compare( "_bigintArg", this._bigintArg, that._bigintArg );
1:             message = message + compare( "_blobArg", this.getBlobBytes(), that.getBlobBytes() );
1:             message = message + compare( "_booleanArg", this._booleanArg, that._booleanArg );
1:             message = message + compare( "_charArg", this._charArg, that._charArg );
1:             message = message + compare( "_charForBitDataArg", this._charForBitDataArg, that._charForBitDataArg );
1:             message = message + compare( "_clobArg", this.getClobString(), that.getClobString() );
1:             message = message + compare( "_dateArg", this.getDateString(), that.getDateString() );
1:             message = message + compare( "_decimalArg", this._decimalArg, that._decimalArg );
1:             message = message + compare( "_doubleArg", this._doubleArg, that._doubleArg );
1:             message = message + compare( "_intArg", this._intArg, that._intArg );
1:             message = message + compare( "_longVarcharArg", this._longVarcharArg, that._longVarcharArg );
1:             message = message + compare( "_longVarcharForBitDataArg", this._longVarcharForBitDataArg, that._longVarcharForBitDataArg );
1:             message = message + compare( "_realArg", this._realArg, that._realArg );
1:             message = message + compare( "_smallintArg", this._smallintArg, that._smallintArg );
1:             message = message + compare( "_timeArg", this.getTimeString(), that.getTimeString() );
1:             message = message + compare( "_timestampArg", this._timestampArg, that._timestampArg );
1:             message = message + compare( "_priceArg", this._priceArg, that._priceArg );
1:             message = message + compare( "_varcharArg", this._varcharArg, that._varcharArg );
1:             message = message + compare( "_varcharForBitDataArg", this._varcharForBitDataArg, that._varcharForBitDataArg );
1: 
1:             return message;
1:         }
1:         private byte[]  getBlobBytes() throws Exception
1:         {
1:             if ( _blobArg == null ) { return null; }
1:             else { return _blobArg.getBytes( 1, (int) _blobArg.length() ); }
1:         }
1:         private String  getClobString() throws Exception
1:         {
1:             if ( _clobArg == null ) { return null; }
1:             else { return _clobArg.getSubString( 1, (int) _clobArg.length() ); }
1:         }
1:         private String  getDateString()
1:         {
1:             if ( _dateArg ==  null ) { return null; }
1:             else { return _dateArg.toString(); }
1:         }
1:         private String  getTimeString()
1:         {
1:             if ( _timeArg == null ) { return null; }
1:             else { return _timeArg.toString(); }
1:         }
1:         private String  compare( String argName, Object left, Object right )
1:         {
1:             if ( left == null )
1:             {
1:                 if ( right == null ) { return ""; }
1:                 return (argName + ": left was null but right was " + right);
1:             }
1:             if ( right == null ) { return (argName + ": left = " + left + " but right is null" ); }
1:             if ( left instanceof byte[] ) { return compareBytes( argName, (byte[]) left, (byte[]) right ); }
1: 
1:             if ( left.equals( right ) ) { return ""; }
1: 
1:             return (argName + ": left = " + left + " but right = " + right);
1:         }
1:         private String  compareBytes( String argName, byte[] left, byte[] right )
1:         {
1:             int count = left.length;
1: 
1:             if ( count != right.length )
1:             {
1:                 return (argName + ": left count = " + count + " but right count = " + right.length );
1:             }
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 if ( left[ i ] != right[ i ] )
1:                 {
1:                     return (argName + ": left[ " + i + " ] = " + left[ i ] + " but right[ " + i + " ] = " + right[ i ] );
1:                 }
1:             }
1: 
1:             return "";
1:         }
1:     }
1: 
1:     
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.tests.lang.Price;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ProcedureTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:99d9d5c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DatabaseMetaData;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that we create and execute stored procedures with as many
1:      * parameters as the Java specification allows.
1:      */
1:     public void testMaxNumberOfParameters() throws SQLException {
1:         // Test with the maximum number of parameters allowed by the
1:         // Java Virtual Machine specification. That is, 255 parameters.
1:         testMaxNumberOfParameters(255, true);
1: 
1:         // Test with one more parameter than allowed. Since we have no way
1:         // to declare a method with that many parameters, expect execution to
1:         // fail gracefully. The DDL will work, however.
1:         testMaxNumberOfParameters(256, false);
1: 
1:         // Test with a very high number of parameters. Again, expect DDL to
1:         // succeed and execution to fail gracefully.
1:         testMaxNumberOfParameters(10000, false);
1:     }
1: 
1:     /**
1:      * Create and execute a stored procedure backed by a Java method with the
1:      * specified number of parameters.
1:      *
1:      * @param params the number of parameters
1:      * @param methodExists whether or not a method called
1:      * {@code procWithManyParams} with the specified number of parameters
1:      * exists
1:      */
1:     private void testMaxNumberOfParameters(int params, boolean methodExists)
1:             throws SQLException {
1:         final String javaMethod = getClass().getName() + ".procWithManyParams";
1:         final String sqlProc = "PROC_WITH_LOTS_OF_PARAMETERS";
1: 
1:         // Disable auto-commit for easy cleanup with rollback().
1:         setAutoCommit(false);
1: 
1:         // Create a procedure with many parameters.
1: 
1:         StringBuffer sb = new StringBuffer("create procedure ");
1:         sb.append(sqlProc).append('(');
1:         for (int i = 0; i < params; i++) {
1:             if (i > 0) {
1:                 sb.append(',');
1:             }
1:             sb.append('p').append(i).append(" int");
1:         }
1:         sb.append(") language java parameter style java external name '");
1:         sb.append(javaMethod).append("' no sql");
1: 
1:         Statement s = createStatement();
1:         s.execute(sb.toString());
1: 
1:         // Check that the database meta-data has correct information.
1:         DatabaseMetaData dmd = getConnection().getMetaData();
1: 
1:         JDBC.assertFullResultSet(
1:             dmd.getProcedures(
1:                 null, null, sqlProc),
1:             new Object[][] {{
1:                 "", "APP", sqlProc, null, null, null,
1:                 javaMethod,
1:                 Integer.valueOf(DatabaseMetaData.procedureNoResult),
1:                 new JDBC.GeneratedId()
1:             }},
1:             false);
1: 
1:         JDBC.assertDrainResults(
1:                 dmd.getProcedureColumns(null, null, sqlProc, "%"),
1:                 params);
1: 
1:         // Execute the procedure.
1:         sb.setLength(0);
1:         sb.append("call ").append(sqlProc).append('(');
1:         for (int i = 0; i < params; i++) {
1:             if (i > 0) {
1:                 sb.append(',');
1:             }
1:             sb.append(i);
1:         }
1:         sb.append(')');
1: 
1:         if (methodExists) {
1:             s.execute(sb.toString());
1:         } else {
1:             assertCallError("42X50", sb.toString());
1:         }
1: 
1:         rollback();
1:     }
1: 
1:     public static void procWithManyParams(
1:         int p001, int p002, int p003, int p004, int p005, int p006, int p007,
1:         int p008, int p009, int p010, int p011, int p012, int p013, int p014,
1:         int p015, int p016, int p017, int p018, int p019, int p020, int p021,
1:         int p022, int p023, int p024, int p025, int p026, int p027, int p028,
1:         int p029, int p030, int p031, int p032, int p033, int p034, int p035,
1:         int p036, int p037, int p038, int p039, int p040, int p041, int p042,
1:         int p043, int p044, int p045, int p046, int p047, int p048, int p049,
1:         int p050, int p051, int p052, int p053, int p054, int p055, int p056,
1:         int p057, int p058, int p059, int p060, int p061, int p062, int p063,
1:         int p064, int p065, int p066, int p067, int p068, int p069, int p070,
1:         int p071, int p072, int p073, int p074, int p075, int p076, int p077,
1:         int p078, int p079, int p080, int p081, int p082, int p083, int p084,
1:         int p085, int p086, int p087, int p088, int p089, int p090, int p091,
1:         int p092, int p093, int p094, int p095, int p096, int p097, int p098,
1:         int p099, int p100, int p101, int p102, int p103, int p104, int p105,
1:         int p106, int p107, int p108, int p109, int p110, int p111, int p112,
1:         int p113, int p114, int p115, int p116, int p117, int p118, int p119,
1:         int p120, int p121, int p122, int p123, int p124, int p125, int p126,
1:         int p127, int p128, int p129, int p130, int p131, int p132, int p133,
1:         int p134, int p135, int p136, int p137, int p138, int p139, int p140,
1:         int p141, int p142, int p143, int p144, int p145, int p146, int p147,
1:         int p148, int p149, int p150, int p151, int p152, int p153, int p154,
1:         int p155, int p156, int p157, int p158, int p159, int p160, int p161,
1:         int p162, int p163, int p164, int p165, int p166, int p167, int p168,
1:         int p169, int p170, int p171, int p172, int p173, int p174, int p175,
1:         int p176, int p177, int p178, int p179, int p180, int p181, int p182,
1:         int p183, int p184, int p185, int p186, int p187, int p188, int p189,
1:         int p190, int p191, int p192, int p193, int p194, int p195, int p196,
1:         int p197, int p198, int p199, int p200, int p201, int p202, int p203,
1:         int p204, int p205, int p206, int p207, int p208, int p209, int p210,
1:         int p211, int p212, int p213, int p214, int p215, int p216, int p217,
1:         int p218, int p219, int p220, int p221, int p222, int p223, int p224,
1:         int p225, int p226, int p227, int p228, int p229, int p230, int p231,
1:         int p232, int p233, int p234, int p235, int p236, int p237, int p238,
1:         int p239, int p240, int p241, int p242, int p243, int p244, int p245,
1:         int p246, int p247, int p248, int p249, int p250, int p251, int p252,
1:         int p253, int p254, int p255)
1:     {
1:     }
1: 
commit:b98b60e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-2516. If an INOUT parameter had been
1:      * registered as an output parameter, but no input value had been assigned
1:      * to it, the client driver would go ahead and execute the statement
1:      * using null as input.
1:      */
1:     public void testInOutParamNotSet() throws SQLException {
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_2516 (inout i int) " +
1:                   "language java parameter style java external name '" +
1:                   getClass().getName() + ".proc_2516' no sql");
1: 
1:         // Register an INOUT parameter, but don't set it. Expect failure.
1:         // Client used to execute without error.
1:         CallableStatement cs = prepareCall("call proc_2516(?)");
1:         cs.registerOutParameter(1, Types.INTEGER);
1:         assertStatementError("07000", cs);
1: 
1:         // Should work if the parameter has been set.
1:         cs.setInt(1, 0);
1:         cs.execute();
1:         assertEquals(10, cs.getInt(1));
1: 
1:         // After clearing the parameters, execution should fail. Client used
1:         // to succeed.
1:         cs.clearParameters();
1:         assertStatementError("07000", cs);
1: 
1:         // Setting the parameter again should make it work.
1:         cs.setInt(1, 1);
1:         cs.execute();
1:         assertEquals(10, cs.getInt(1));
1:     }
1: 
1:     /**
1:      * Stored procedure used by the regression test case for DERBY-2516.
1:      *
1:      * @param i INOUT parameter that gets set to 10 by the procedure
1:      */
1:     public static void proc_2516(Integer[] i) {
0:         i[0] = new Integer(10);
1:     }
1: 
commit:42114da
/////////////////////////////////////////////////////////////////////////
1:      * Test that a statement severity error inside a procedure doesn't kill
1:      * the top-level statement that executes the stored procedure. Regression
1:      * test case for DERBY-5280.
1:      */
1:     public void testStatementSeverityErrorInProcedure() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_5280() language java " +
1:                   "parameter style java external name '" +
1:                   getClass().getName() + ".proc_5280' reads sql data");
1:         s.execute("call proc_5280()");
1:     }
1: 
1:     /**
1:      * Procedure that drops a non-existent table and ignores the exception
1:      * thrown because of it. Used by the regression test case for DERBY-5280.
1:      */
1:     public static void proc_5280() throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1: 
1:         // Drop a non-existent table and verify that it fails with the
1:         // expected exception. Ignore the exception.
1:         try {
1:             s.execute("drop table this_table_does_not_exist");
1:             fail("dropping non-existent table should fail");
1:         } catch (SQLException sqle) {
1:             assertSQLState("42Y55", sqle);
1:         }
1: 
1:         // The statement should still work.
1:         JDBC.assertSingleValueResultSet(s.executeQuery("values 1"), "1");
1:     }
1: 
1:     /**
commit:0252fa4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that a call to getBlob() to retrieve the value of a non-BLOB
1:      * parameter fails with the expected SQLException. Used to throw
1:      * ClassCastException, see DERBY-4970.
1:      */
1:     public void testGetBlobFromIntParameter() throws SQLException {
1:         CallableStatement cs = prepareCall("call int_out(?)");
1:         cs.registerOutParameter(1, Types.INTEGER);
1:         cs.execute();
1:         try {
1:             cs.getBlob(1);
1:             fail("getBlob() on int parameter expected to fail");
1:         } catch (SQLException sqle) {
1:             assertSQLState("22005", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Test that a call to getClob() to retrieve the value of a non-CLOB
1:      * parameter fails with the expected SQLException. Used to throw
1:      * ClassCastException, see DERBY-4970.
1:      */
1:     public void testGetClobFromIntParameter() throws SQLException {
1:         CallableStatement cs = prepareCall("call int_out(?)");
1:         cs.registerOutParameter(1, Types.INTEGER);
1:         cs.execute();
1:         try {
1:             cs.getClob(1);
1:             fail("getClob() on int parameter expected to fail");
1:         } catch (SQLException sqle) {
1:             assertSQLState("22005", sqle);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:           "DYNAMIC RESULT SETS 6",
1:           "CREATE PROCEDURE INT_OUT(OUT X INTEGER) LANGUAGE JAVA " +
1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".intOut'",
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Stored procedure with an integer output parameter.
1:      * @param out an output parameter
1:      */
1:     public static void intOut(int[] out) {
1:         out[0] = 42;
1:     }
commit:d8383bd
/////////////////////////////////////////////////////////////////////////
0:      * <p> This test case fails with JCC.
/////////////////////////////////////////////////////////////////////////
0:      * <p> This test case fails with JCC.
/////////////////////////////////////////////////////////////////////////
0:      * <p> This test case fails with JCC.
/////////////////////////////////////////////////////////////////////////
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeQuery()</code> are correctly rolled back when the
1:      * query fails because the number of returned result sets is zero.
1:      *
0:      * <p> This test case fails with JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestRollbackStoredProcWhenExecuteQueryReturnsNothing_prepared()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:         ps.setInt(1, 0);
1:         try {
1:             ResultSet rs = ps.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         Statement stmt = conn.createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
1:         rs.close();
0:         ps.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeQuery()</code> are correctly rolled back when the
1:      * query fails because the number of returned result sets is more
1:      * than one.
1:      *
0:      * <p> This test case fails with JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestRollbackStoredProcWhenExecuteQueryReturnsTooMuch_prepared()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:         ps.setInt(1, 2);
1:         try {
1:             ResultSet rs = ps.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertMultipleResultsFromExecuteQuery(sqle);
1:         }
0:         Statement stmt = conn.createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
1:         rs.close();
0:         ps.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeUpdate()</code> are correctly rolled back when the
1:      * query fails because the stored procedure returned a result set.
1:      *
0:      * <p> This test case fails with JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void
0:         xtestRollbackStoredProcWhenExecuteUpdateReturnsResults_prepared()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:         ps.setInt(1, 1);
1:         try {
1:             ps.executeUpdate();
1:             fail("executeUpdate() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertResultsFromExecuteUpdate(sqle);
1:         }
0:         Statement stmt = conn.createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
1:         rs.close();
0:         ps.close();
0:         stmt.close();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         if (usingDerbyNet()) {
1:             assertSQLState("Unexpected SQL state.", "X0Y78", sqle);
/////////////////////////////////////////////////////////////////////////
0:         if (usingDerbyNet()) {
1:             assertSQLState("Unexpected SQL state.", "X0Y78", sqle);
/////////////////////////////////////////////////////////////////////////
0:         if (usingDerbyNet()) {
1:             assertSQLState("Unexpected SQL state.", "X0Y79", sqle);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteQueryReturnsNothing" +
0:                   "_prepared"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteQueryReturnsTooMuch" +
0:                   "_prepared"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteUpdateReturnsResults" +
0:                   "_prepared"));
commit:73d678d
/////////////////////////////////////////////////////////////////////////
0:      * <p>Currently, this test fails with JCC.
/////////////////////////////////////////////////////////////////////////
0:      * <p>Currently, this test fails with JCC.
/////////////////////////////////////////////////////////////////////////
0:      * <p>Currently, this test fails with
/////////////////////////////////////////////////////////////////////////
0:      * <p>Currently, this test fails with JCC.
/////////////////////////////////////////////////////////////////////////
0:         if (!usingDerbyNet()) {
/////////////////////////////////////////////////////////////////////////
1:         }
0:         if (usingEmbedded()) {
commit:56439cb
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
1: /**
1:  * Tests of stored procedures.
1:  */
1: public class ProcedureTest extends BaseJDBCTestCase {
1: 
0:     /** Connection used by the test cases. Auto-commit is turned off. */
0:     private Connection conn;
1: 
1:     /**
1:      * Creates a new <code>ProcedureTest</code> instance.
1:      *
1:      * @param name name of the test
1:      */
1:     public ProcedureTest(String name) {
1:         super(name);
1:     }
1: 
1:     // TESTS
1: 
1:     /**
1:      * Tests that <code>Statement.executeQuery()</code> fails when no
1:      * result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithNoDynamicResultSets() throws SQLException {
0:         Statement stmt = conn.createStatement();
1:         try {
1:             stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(0)");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>Statement.executeQuery()</code> succeeds when
1:      * one result set is returned from a stored procedure.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithOneDynamicResultSet() throws SQLException {
0:         Statement stmt = conn.createStatement();
1:         ResultSet rs = stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(1)");
1:         assertNotNull("executeQuery() returned null.", rs);
0:         assertTrue("Result set has no data.", rs.next());
0:         rs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>Statement.executeQuery()</code> fails when
1:      * multiple result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithMoreThanOneDynamicResultSet()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
1:         try {
1:             stmt.executeQuery("CALL RETRIEVE_DYNAMIC_RESULTS(2)");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertMultipleResultsFromExecuteQuery(sqle);
1:         }
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>Statement.executeUpdate()</code> succeeds when
1:      * no result sets are returned.
1:      *
0:      * <p>Currently, this test fails with the client driver and JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestExecuteUpdateWithNoDynamicResultSets()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
0:         int count = stmt.executeUpdate("CALL RETRIEVE_DYNAMIC_RESULTS(0)");
0:         assertEquals("Wrong update count.", 0, count);
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>Statement.executeUpdate()</code> fails when a
1:      * result set is returned from a stored procedure.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteUpdateWithOneDynamicResultSet() throws SQLException {
0:         Statement stmt = conn.createStatement();
1:         try {
1:             stmt.executeUpdate("CALL RETRIEVE_DYNAMIC_RESULTS(1)");
1:             fail("executeUpdate() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertResultsFromExecuteUpdate(sqle);
1:         }
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>PreparedStatement.executeQuery()</code> fails
1:      * when no result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithNoDynamicResultSets_prepared()
1:         throws SQLException
1:     {
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         ps.setInt(1, 0);
1:         try {
1:             ps.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         ps.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>PreparedStatement.executeQuery()</code>
1:      * succeeds when one result set is returned from a stored
1:      * procedure.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithOneDynamicResultSet_prepared()
1:         throws SQLException
1:     {
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         ps.setInt(1, 1);
0:         ResultSet rs = ps.executeQuery();
1:         assertNotNull("executeQuery() returned null.", rs);
0:         assertTrue("Result set has no data.", rs.next());
0:         rs.close();
0:         ps.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>PreparedStatement.executeQuery()</code> fails
1:      * when multiple result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithMoreThanOneDynamicResultSet_prepared()
1:         throws SQLException
1:     {
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         ps.setInt(1, 2);
1:         try {
1:             ps.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertMultipleResultsFromExecuteQuery(sqle);
1:         }
0:         ps.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>PreparedStatement.executeUpdate()</code>
1:      * succeeds when no result sets are returned.
1:      *
0:      * <p>Currently, this test fails with the client driver and JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestExecuteUpdateWithNoDynamicResultSets_prepared()
1:         throws SQLException
1:     {
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         ps.setInt(1, 0);
0:         int count = ps.executeUpdate();
0:         assertEquals("Wrong update count.", 0, count);
0:         ps.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>PreparedStatement.executeUpdate()</code> fails
1:      * when a result set is returned from a stored procedure.
1:      *
0:      * <p>Currently, this test fails with the client driver and
0:      * JCC. However, the corresponding tests for
0:      * <code>Statement</code> and <code>CallableStatement</code>
0:      * succeed. Strange...
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestExecuteUpdateWithOneDynamicResultSet_prepared()
1:         throws SQLException
1:     {
1:         PreparedStatement ps =
0:             conn.prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         ps.setInt(1, 1);
1:         try {
1:             ps.executeUpdate();
1:             fail("executeUpdate() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertResultsFromExecuteUpdate(sqle);
1:         }
0:         ps.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>CallableStatement.executeQuery()</code> fails
1:      * when no result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithNoDynamicResultSets_callable()
1:         throws SQLException
1:     {
1:         CallableStatement cs =
0:             conn.prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         cs.setInt(1, 0);
1:         try {
1:             cs.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests that <code>CallableStatement.executeQuery()</code>
1:      * succeeds when one result set is returned from a stored
1:      * procedure.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithOneDynamicResultSet_callable()
1:         throws SQLException
1:     {
1:         CallableStatement cs =
0:             conn.prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         cs.setInt(1, 1);
1:         ResultSet rs = cs.executeQuery();
1:         assertNotNull("executeQuery() returned null.", rs);
0:         assertTrue("Result set has no data.", rs.next());
0:         rs.close();
1:         cs.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>CallableStatement.executeQuery()</code> fails
1:      * when multiple result sets are returned.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteQueryWithMoreThanOneDynamicResultSet_callable()
1:         throws SQLException
1:     {
1:         CallableStatement cs =
0:             conn.prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         cs.setInt(1, 2);
1:         try {
1:             cs.executeQuery();
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertMultipleResultsFromExecuteQuery(sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests that <code>CallableStatement.executeUpdate()</code>
1:      * succeeds when no result sets are returned.
1:      *
0:      * <p>Currently, this test fails with the client driver and JCC.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestExecuteUpdateWithNoDynamicResultSets_callable()
1:         throws SQLException
1:     {
1:         CallableStatement cs =
0:             conn.prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         cs.setInt(1, 0);
0:         int count = cs.executeUpdate();
0:         assertEquals("Wrong update count.", 0, count);
1:         cs.close();
1:     }
1: 
1:     /**
1:      * Tests that <code>CallableStatement.executeUpdate()</code> fails
1:      * when a result set is returned from a stored procedure.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testExecuteUpdateWithOneDynamicResultSet_callable()
1:         throws SQLException
1:     {
1:         CallableStatement cs =
0:             conn.prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         cs.setInt(1, 1);
1:         try {
1:             cs.executeUpdate();
1:             fail("executeUpdate() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertResultsFromExecuteUpdate(sqle);
1:         }
1:         cs.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeQuery()</code> are correctly rolled back when
1:      * <code>Connection.rollback()</code> is called.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testRollbackStoredProcWithExecuteQuery() throws SQLException {
0:         Statement stmt = conn.createStatement();
1:         ResultSet rs = stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(1)");
0:         rs.close();
0:         conn.rollback();
0:         ResultSet tableRs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         // table should be empty after rollback
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     tableRs.next());
0:         tableRs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeUpdate()</code> are correctly rolled back when
1:      * <code>Connection.rollback()</code> is called.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testRollbackStoredProcWithExecuteUpdate() throws SQLException {
0:         Statement stmt = conn.createStatement();
1:         stmt.executeUpdate("CALL PROC_WITH_SIDE_EFFECTS(0)");
0:         conn.rollback();
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         // table should be empty after rollback
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
0:         rs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeQuery()</code> are correctly rolled back when the
1:      * query fails because the number of returned result sets is zero.
1:      *
0:      * <p> This test case fails with the client driver and JCC (DERBY-1364).
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestRollbackStoredProcWhenExecuteQueryReturnsNothing()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
0:         Statement stmt = conn.createStatement();
1:         try {
0:             ResultSet rs = stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(0)");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
0:         rs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeQuery()</code> are correctly rolled back when the
1:      * query fails because the number of returned result sets is more
1:      * than one.
1:      *
0:      * <p> This test case fails with the client driver and JCC (DERBY-1364).
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestRollbackStoredProcWhenExecuteQueryReturnsTooMuch()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
0:         Statement stmt = conn.createStatement();
1:         try {
0:             ResultSet rs = stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(2)");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertMultipleResultsFromExecuteQuery(sqle);
1:         }
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
0:         rs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that the effects of executing a stored procedure with
1:      * <code>executeUpdate()</code> are correctly rolled back when the
1:      * query fails because the stored procedure returned a result set.
1:      *
0:      * <p> This test case fails with the client driver and JCC (DERBY-1364).
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void xtestRollbackStoredProcWhenExecuteUpdateReturnsResults()
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(true);
0:         Statement stmt = conn.createStatement();
1:         try {
1:             stmt.executeUpdate("CALL PROC_WITH_SIDE_EFFECTS(1)");
1:             fail("executeUpdate() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertResultsFromExecuteUpdate(sqle);
1:         }
0:         ResultSet rs = stmt.executeQuery("SELECT * FROM SIMPLE_TABLE");
0:         assertFalse("Side effects from stored procedure not rolled back.",
0:                     rs.next());
0:         rs.close();
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that closed result sets are not returned when calling
1:      * <code>executeQuery()</code>.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testClosedDynamicResultSetsFromExecuteQuery()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
1:         try {
1:             ResultSet rs = stmt.executeQuery("CALL RETRIEVE_CLOSED_RESULT()");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that closed result sets are ignored when calling
1:      * <code>executeUpdate()</code>.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testClosedDynamicResultSetsFromExecuteUpdate()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
1:         stmt.executeUpdate("CALL RETRIEVE_CLOSED_RESULT()");
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that dynamic result sets from other connections are
1:      * ignored when calling <code>executeQuery</code>.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testDynamicResultSetsFromOtherConnectionWithExecuteQuery()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
1:         try {
0:             ResultSet rs = stmt.executeQuery("CALL RETRIEVE_EXTERNAL_RESULT()");
1:             fail("executeQuery() didn't fail.");
1:         } catch (SQLException sqle) {
1:             assertNoResultSetFromExecuteQuery(sqle);
1:         }
0:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests that dynamic result sets from other connections are
1:      * ignored when calling <code>executeUpdate</code>.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testDynamicResultSetsFromOtherConnectionWithExecuteUpdate()
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
0:         stmt.executeUpdate("CALL RETRIEVE_EXTERNAL_RESULT()");
0:         stmt.close();
1:     }
1: 
1:     // UTILITY METHODS
1: 
1:     /**
1:      * Raises an exception if the exception is not caused by
1:      * <code>executeQuery()</code> returning no result set.
1:      *
1:      * @param sqle a <code>SQLException</code> value
1:      */
0:     private static void assertNoResultSetFromExecuteQuery(SQLException sqle) {
0:         if (usingEmbedded()) {
0:             assertSQLState("Unexpected SQL state.", "X0Y78", sqle);
0:         } else if (usingDerbyNetClient()) {
0:             assertSQLState("Unexpected SQL state.", "XJ205", sqle);
0:         } else if (usingDerbyNet()) {
0:             assertNull("Unexpected SQL state.", sqle.getSQLState());
0:         } else {
0:             fail("Unrecognized framework.");
1:         }
1:     }
1: 
1:     /**
1:      * Raises an exception if the exception is not caused by
1:      * <code>executeQuery()</code> returning multiple result sets.
1:      *
1:      * @param sqle a <code>SQLException</code> value
1:      */
0:     private static void assertMultipleResultsFromExecuteQuery(SQLException sqle)
1:     {
0:         if (usingEmbedded()) {
0:             assertSQLState("Unexpected SQL state.", "X0Y78", sqle);
0:         } else if (usingDerbyNetClient()) {
0:             assertSQLState("Unexpected SQL state.", "XJ201", sqle);
0:         } else if (usingDerbyNet()) {
0:             assertNull("Unexpected SQL state.", sqle.getSQLState());
0:         } else {
0:             fail("Unrecognized framework.");
1:         }
1:     }
1: 
1:     /**
1:      * Raises an exception if the exception is not caused by
1:      * <code>executeUpdate()</code> returning result sets.
1:      *
1:      * @param sqle a <code>SQLException</code> value
1:      */
0:     private static void assertResultsFromExecuteUpdate(SQLException sqle) {
0:         if (usingEmbedded()) {
0:             assertSQLState("Unexpected SQL state.", "X0Y79", sqle);
0:         } else if (usingDerbyNetClient()) {
0:             assertSQLState("Unexpected SQL state.", "XJ201", sqle);
0:         } else if (usingDerbyNet()) {
0:             assertNull("Unexpected SQL state.", sqle.getSQLState());
0:         } else {
0:             fail("Unrecognized framework.");
1:         }
1: 
1:     }
1: 
1:     // SETUP
1: 
1:     /**
1:      * Creates the test suite and wraps it in a <code>TestSetup</code>
1:      * instance which sets up and tears down the test environment.
1:      * @return test suite
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite(ProcedureTest.class);
0:         if (usingEmbedded()) {
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestExecuteUpdateWithNoDynamicResultSets"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestExecuteUpdateWithNoDynamicResultSets_prepared"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestExecuteUpdateWithOneDynamicResultSet_prepared"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestExecuteUpdateWithNoDynamicResultSets_callable"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteQueryReturnsNothing"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteQueryReturnsTooMuch"));
0:             suite.addTest
0:                 (new ProcedureTest
0:                  ("xtestRollbackStoredProcWhenExecuteUpdateReturnsResults"));
1:         }
0:         return new TestSetup(suite) {
0:             public void setUp() throws Exception {
0:                 oneTimeSetUp();
1:             }
0:             public void tearDown() throws Exception {
0:                 oneTimeTearDown();
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * Sets up the connection for a test case and clears all tables
1:      * used in the test cases.
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void setUp() throws SQLException {
0:         conn = getConnection();
1:         conn.setAutoCommit(false);
0:         Statement s = conn.createStatement();
1:         for (int i = 0; i < TABLES.length; i++) {
1:             s.execute("DELETE FROM " + TABLES[i][0]);
1:         }
0:         s.close();
0:         conn.commit();
1:     }
1: 
1:     /**
0:      * Closes the connection for a test case.
1:      * @exception SQLException if a database error occurs
1:      */
0:     public void tearDown() throws SQLException {
0:         conn.rollback();
0:         conn.close();
1:     }
1: 
1:     /**
1:      * Creates the tables and the stored procedures used in the test
1:      * cases.
1:      * @exception SQLException if a database error occurs
1:      */
0:     private static void oneTimeSetUp() throws SQLException {
0:         Connection c = getConnection();
0:         c.setAutoCommit(false);
0:         Statement s = c.createStatement();
1:         for (int i = 0; i < PROCEDURES.length; i++) {
0:             s.execute(PROCEDURES[i][1]);
1:         }
1:         for (int i = 0; i < TABLES.length; i++) {
1:             s.execute(TABLES[i][1]);
1:         }
0:         s.close();
0:         c.commit();
1:         c.close();
1:     }
1: 
1:     /**
0:      * Drops the stored procedures used in the tests.
1:      * @exception SQLException if a database error occurs
1:      */
0:     private static void oneTimeTearDown() throws SQLException {
0:         Connection c = getConnection();
0:         c.setAutoCommit(false);
0:         Statement s = c.createStatement();
1:         for (int i = 0; i < PROCEDURES.length; i++) {
0:             s.execute("DROP PROCEDURE " + PROCEDURES[i][0]);
1:         }
1:         for (int i = 0; i < TABLES.length; i++) {
0:             s.execute("DROP TABLE " + TABLES[i][0]);
1:         }
0:         s.close();
0:         c.commit();
1:         c.close();
1:     }
1: 
1:     /**
1:      * Procedures that should be created before the tests are run and
1:      * dropped when the tests have finished. First element in each row
1:      * is the name of the procedure, second element is SQL which
1:      * creates it.
1:      */
0:     private static final String[][] PROCEDURES = {
0:         { "RETRIEVE_DYNAMIC_RESULTS",
1:           "CREATE PROCEDURE RETRIEVE_DYNAMIC_RESULTS(number INT) " +
1:           "LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".retrieveDynamicResults' " +
0:           "DYNAMIC RESULT SETS 4"
0:         },
0:         { "RETRIEVE_CLOSED_RESULT",
1:           "CREATE PROCEDURE RETRIEVE_CLOSED_RESULT() LANGUAGE JAVA " +
1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".retrieveClosedResult' " +
0:           "DYNAMIC RESULT SETS 1"
0:         },
0:         { "RETRIEVE_EXTERNAL_RESULT",
0:           "CREATE PROCEDURE RETRIEVE_EXTERNAL_RESULT() LANGUAGE JAVA " +
1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".retrieveExternalResult' " +
0:           "DYNAMIC RESULT SETS 1"
0:         },
0:         { "PROC_WITH_SIDE_EFFECTS",
1:           "CREATE PROCEDURE PROC_WITH_SIDE_EFFECTS(ret INT) LANGUAGE JAVA " +
1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".procWithSideEffects' " +
0:           "DYNAMIC RESULT SETS 2"
0:         },
1:     };
1: 
1:     /**
1:      * Tables that should be created before the tests are run and
1:      * dropped when the tests have finished. The tables will be
1:      * cleared before each test case is run. First element in each row
1:      * is the name of the table, second element is the SQL text which
1:      * creates it.
1:      */
1:     private static final String[][] TABLES = {
1:         // SIMPLE_TABLE is used by PROC_WITH_SIDE_EFFECTS
1:         { "SIMPLE_TABLE", "CREATE TABLE SIMPLE_TABLE (id INT)" },
1:     };
1: 
1:     // PROCEDURES
1: 
1:     /**
1:      * Stored procedure which returns 0, 1, 2, 3 or 4 <code>ResultSet</code>s.
1:      *
1:      * @param number the number of <code>ResultSet</code>s to return
1:      * @param rs1 first <code>ResultSet</code>
1:      * @param rs2 second <code>ResultSet</code>
1:      * @param rs3 third <code>ResultSet</code>
1:      * @param rs4 fourth <code>ResultSet</code>
1:      * @exception SQLException if a database error occurs
1:      */
1:     public static void retrieveDynamicResults(int number,
1:                                               ResultSet[] rs1,
1:                                               ResultSet[] rs2,
1:                                               ResultSet[] rs3,
1:                                               ResultSet[] rs4)
1:         throws SQLException
1:     {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         if (number > 0) {
1:             rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         if (number > 1) {
1:             rs2[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         if (number > 2) {
1:             rs3[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         if (number > 3) {
1:             rs4[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         c.close();
1:     }
1: 
1:     /**
1:      * Stored procedure which produces a closed result set.
1:      *
1:      * @param closed holder for the closed result set
1:      * @exception SQLException if a database error occurs
1:      */
1:     public static void retrieveClosedResult(ResultSet[] closed)
1:         throws SQLException
1:     {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         closed[0] = c.createStatement().executeQuery("VALUES(1)");
1:         closed[0].close();
1:         c.close();
1:     }
1: 
1:     /**
1:      * Stored procedure which produces a result set in another
1:      * connection.
1:      *
1:      * @param external result set from another connection
1:      * @exception SQLException if a database error occurs
1:      */
0:     public static void retrieveExternalResult(ResultSet[] external)
1:         throws SQLException
1:     {
1:         external[0] =
0:             getConnection().createStatement().executeQuery("VALUES(1)");
1:     }
1: 
1:     /**
1:      * Stored procedure which inserts a row into SIMPLE_TABLE and
1:      * optionally returns result sets.
1:      *
1:      * @param returnResults if one, return one result set; if greater
1:      * than one, return two result sets; otherwise, return no result
1:      * set
1:      * @param rs1 first result set to return
1:      * @param rs2 second result set to return
1:      * @exception SQLException if a database error occurs
1:      */
1:     public static void procWithSideEffects(int returnResults,
1:                                            ResultSet[] rs1,
1:                                            ResultSet[] rs2)
1:         throws SQLException
1:     {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement stmt = c.createStatement();
1:         stmt.executeUpdate("INSERT INTO SIMPLE_TABLE VALUES (42)");
1:         if (returnResults > 0) {
1:             rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         if (returnResults > 1) {
1:             rs2[0] = c.createStatement().executeQuery("VALUES(1)");
1:         }
1:         c.close();
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         assertSQLState("Unexpected SQL state.", "X0Y78", sqle);        
/////////////////////////////////////////////////////////////////////////
0:         assertSQLState("Unexpected SQL state.", "X0Y78", sqle);        
/////////////////////////////////////////////////////////////////////////
0:         assertSQLState("Unexpected SQL state.", "X0Y79", sqle);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client()) {
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client()) {
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client()) {
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f62cb68
/////////////////////////////////////////////////////////////////////////
1:         assertSame(stmt, rs.getStatement());
/////////////////////////////////////////////////////////////////////////
1:         assertSame(ps, rs.getStatement());
/////////////////////////////////////////////////////////////////////////
1:         assertSame(cs, rs.getStatement());
/////////////////////////////////////////////////////////////////////////
1:                     allRS[pass++] = cs.getResultSet();      
1:                     assertSame(cs, allRS[pass-1].getStatement());
/////////////////////////////////////////////////////////////////////////
1:                     allRS[pass++] = cs.getResultSet();         
1:                     assertSame(cs, allRS[pass-1].getStatement());
/////////////////////////////////////////////////////////////////////////
1:             assertSame(cs, allRS[0].getStatement());
1:             allRS[1] = cs.getResultSet();   
1:             assertSame(cs, allRS[1].getStatement());
/////////////////////////////////////////////////////////////////////////
1:             assertSame(cs, allRS[2].getStatement());
/////////////////////////////////////////////////////////////////////////
1:             assertSame(cs, allRS[3].getStatement());
/////////////////////////////////////////////////////////////////////////
1:             assertSame(cs, allRS[4].getStatement());
/////////////////////////////////////////////////////////////////////////
1:                 assertSame(cs, allRS[i].getStatement());
/////////////////////////////////////////////////////////////////////////
1:                 assertSame(cs, allRS[i].getStatement());
/////////////////////////////////////////////////////////////////////////
1:                 assertSame(cs, allRS[i].getStatement());
commit:a66fdc1
/////////////////////////////////////////////////////////////////////////
1:           "DYNAMIC RESULT SETS 2",
1:           
1:           "CREATE PROCEDURE NESTED_RESULT_SETS(proctext VARCHAR(128)) LANGUAGE JAVA " +
1:           "PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:           ProcedureTest.class.getName() + ".nestedDynamicResultSets' " +
0:           "DYNAMIC RESULT SETS 6"
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Method for a Java procedure that calls another procedure
1:      * and just passes on the dynamic results from that call.
1:      */
1:     public static void nestedDynamicResultSets(String procedureText,
1:             ResultSet[] rs1, ResultSet[] rs2, ResultSet[] rs3, ResultSet[] rs4,
1:             ResultSet[] rs5, ResultSet[] rs6)
1:     throws SQLException
1:     {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         
1:         CallableStatement cs = c.prepareCall("CALL " + procedureText);
1:         
1:         cs.execute();
1:         
1:         // Mix up the order of the result sets in the returned
1:         // parameters, ensures order is defined by creation
1:         // and not parameter order.
1:         rs6[0] = cs.getResultSet();
1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:             return;
1:         rs3[0] = cs.getResultSet();
1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:             return;
1:         rs4[0] = cs.getResultSet();
1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:             return;
1:         rs2[0] = cs.getResultSet();
1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:             return;
1:         rs1[0] = cs.getResultSet();
1:         if (!cs.getMoreResults(Statement.KEEP_CURRENT_RESULT))
1:             return;
1:         rs5[0] = cs.getResultSet();
1:     
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 // a procedure that calls another procedure that returns
1:                 // dynamic result sets, see if the result sets are handled
1:                 // correctly through the nesting.
1:                 CallableStatement nestedCs = prepareCall(
1:                         "CALL NESTED_RESULT_SETS('MRS.FIVEJP()')");
1:                 defaultGetMoreResults(nestedCs, allRS);
1:                 
commit:84eabad
/////////////////////////////////////////////////////////////////////////
1:         assertUpdateCount(stmt, 0, "CALL RETRIEVE_DYNAMIC_RESULTS(0)");
1:         JDBC.assertNoMoreResults(stmt);
/////////////////////////////////////////////////////////////////////////
1:         assertUpdateCount(ps, 0);
1:         JDBC.assertNoMoreResults(ps);
/////////////////////////////////////////////////////////////////////////
1:         assertUpdateCount(cs, 0);
1:         JDBC.assertNoMoreResults(cs);
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
/////////////////////////////////////////////////////////////////////////
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:      }
/////////////////////////////////////////////////////////////////////////
1:         // Expect Side effects from stored procedure to be rolled back.
1:         JDBC.assertEmpty(stmt.executeQuery("SELECT * FROM SIMPLE_TABLE"));
1:  
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertNoMoreResults(stmt);
/////////////////////////////////////////////////////////////////////////
1:         
1:         JDBC.assertNoMoreResults(ps);
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < 5; i++)
1:             {
1:                 allRS[i] = cs.getResultSet();
1:                 allRS[i].next();
1:                 assertEquals(2+i, allRS[i].getInt(1));
1:                 
1:                 if (i < 4)
1:                     assertTrue(cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:                 else
1:                     assertFalse(cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
0:             }            
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < 5; i++)
1:             {
1:                 allRS[i] = cs.getResultSet();
1:                 allRS[i].next();
1:                 assertEquals(2+i, allRS[i].getInt(1));
1:                 
1:                 if (i < 4)
1:                     assertTrue(cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT));
1:                 else
1:                     assertFalse(cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT));
0:             }
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < 5; i++)
1:             {
1:                 allRS[i] = cs.getResultSet();
1:                 allRS[i].next();
1:                 assertEquals(2+i, allRS[i].getInt(1));
1:                 
1:                 if (i < 4)
1:                     assertTrue(cs.getMoreResults());
1:                 else
1:                     assertFalse(cs.getMoreResults());
0:             } 
1:                         
commit:b24134e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertDrainResultsHasData(rs);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testExecuteUpdateWithNoDynamicResultSets()
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         JDBC.assertDrainResultsHasData(rs);
1: 
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testExecuteUpdateWithNoDynamicResultSets_prepared()
1:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
1:     public void testExecuteUpdateWithOneDynamicResultSet_prepared()
1:             prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1:         JDBC.assertDrainResultsHasData(rs);
/////////////////////////////////////////////////////////////////////////
1:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
1:     public void testExecuteUpdateWithNoDynamicResultSets_callable()
1:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
1: 
/////////////////////////////////////////////////////////////////////////
1:             prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1: 
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:     public void testRollbackStoredProcWhenExecuteQueryReturnsNothing()
1:         Statement stmt = createStatement();
1:             stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(0)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testRollbackStoredProcWhenExecuteQueryReturnsTooMuch()
1:         Statement stmt = createStatement();
1:             stmt.executeQuery("CALL PROC_WITH_SIDE_EFFECTS(2)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testRollbackStoredProcWhenExecuteUpdateReturnsResults()
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testRollbackStoredProcWhenExecuteQueryReturnsNothing_prepared()
1:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:             ps.executeQuery();
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:     public void testRollbackStoredProcWhenExecuteQueryReturnsTooMuch_prepared()
1:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
1:             ps.executeQuery();
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         testRollbackStoredProcWhenExecuteUpdateReturnsResults_prepared()
1:             prepareStatement("CALL PROC_WITH_SIDE_EFFECTS(?)");
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:         // Need JDBC DriverManager to run these tests
1:         if (!JDBC.vmSupportsJDBC3())
1:             return suite;
1:         
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:                 Statement s = createStatement();
1:                 PreparedStatement ps = prepareStatement("insert into MRS.FIVERS values (?)");
1:                 CallableStatement cs = prepareCall("CALL MRS.FIVEJP()");
commit:3df869c
/////////////////////////////////////////////////////////////////////////
1:         ps.setString(1, getTestConfiguration().getDefaultDatabaseName());
/////////////////////////////////////////////////////////////////////////
1:         ps.setString(1, getTestConfiguration().getDefaultDatabaseName());
commit:d273976
/////////////////////////////////////////////////////////////////////////
0:         cs.close();
commit:283931e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:      * Runs the test fixtures in embedded and client.
1: 
1:         suite.addTest(baseSuite("ProcedureTest:embedded"));
1: 
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         baseSuite("ProcedureTest:client")));    
1:         return suite;
0:     }
1: 
1:     /**
0:      * Creates the test suite and wraps it in a <code>TestSetup</code>
0:      * instance which sets up and tears down the test environment.
1:      * @return test suite
1:      */
1:     private static Test baseSuite(String name)
1:     {
0:         TestSuite suite = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         return new CleanDatabaseTestSetup(suite) {
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {
1:                     s.execute(PROCEDURES[i]);
/////////////////////////////////////////////////////////////////////////
1:     private static final String[] PROCEDURES = {
1:        
1:           "DYNAMIC RESULT SETS 4",
1: 
1: 
1:           "DYNAMIC RESULT SETS 1",
1: 
1:           "DYNAMIC RESULT SETS 1",
1: 
1: 
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("ProcedureTest");
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
/////////////////////////////////////////////////////////////////////////
0:             getConnection().prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = getConnection();
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
commit:d1879a3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
0:         Test test = new BaseJDBCTestSetup(suite) {
/////////////////////////////////////////////////////////////////////////
1:         
0:         return new CleanDatabaseTestSetup(test);
commit:2b04028
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1: 
1:         Statement stmt = createStatement();
0:         stmt.getConnection().rollback();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
0:         stmt.getConnection().rollback();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
commit:09ffc9b
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
0:             getXConnection().prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
1:         
0:         ps.setString(1, getTestConfiguration().getDatabaseName());
1:         ps.setString(2, getTestConfiguration().getUserName());
1:         ps.setString(3, getTestConfiguration().getUserPassword());
1:             ps.executeQuery();
0:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps =
0:             getXConnection().prepareStatement("CALL RETRIEVE_EXTERNAL_RESULT(?,?,?)");
1:         
0:         ps.setString(1, getTestConfiguration().getDatabaseName());
1:         ps.setString(2, getTestConfiguration().getUserName());
1:         ps.setString(3, getTestConfiguration().getUserPassword());
1:         
1:         ps.executeUpdate();
0:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:           "CREATE PROCEDURE RETRIEVE_EXTERNAL_RESULT(" +
1:           "DBNAME VARCHAR(128), DBUSER VARCHAR(128), DBPWD VARCHAR(128)) LANGUAGE JAVA " +
/////////////////////////////////////////////////////////////////////////
1:     public static void retrieveExternalResult(String dbName, 
1:             String user, String password, ResultSet[] external)
1:         // Use a server-side connection to the same database.
1:         String url = "jdbc:derby:" + dbName;
1:         
1:         Connection conn = DriverManager.getConnection(url, user, password);
1:         
1:             conn.createStatement().executeQuery("VALUES(1)");
commit:ffe3f66
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareStatement("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().prepareCall("CALL RETRIEVE_DYNAMIC_RESULTS(?)");
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Statement stmt = getXConnection().createStatement();
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getXConnection();
/////////////////////////////////////////////////////////////////////////
commit:2fd14fb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.JDBC;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite();
1:         
0:         // Need JDBC 2 DriverManager to run these tests
0:         if (JDBC.vmSupportsJDBC2()) {        	
1:         
1:         suite.addTestSuite(ProcedureTest.class);
/////////////////////////////////////////////////////////////////////////
0:         }
commit:6e0750f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestSetup;
/////////////////////////////////////////////////////////////////////////
0:         return new BaseJDBCTestSetup(suite) {
1:             /**
0:              * Creates the tables and the stored procedures used in the test
0:              * cases.
0:              * @exception SQLException if a database error occurs
1:              */
0:         	protected void setUp() throws SQLException {
0:                 Connection c = getConnection();
0:                 c.setAutoCommit(false);
0:                 Statement s = c.createStatement();
0:                 for (int i = 0; i < PROCEDURES.length; i++) {
0:                     s.execute(PROCEDURES[i][1]);
0:                 }
0:                 for (int i = 0; i < TABLES.length; i++) {
0:                     s.execute(TABLES[i][1]);
0:                 }
0:                 s.close();
0:                 c.commit();
0:                 c.close();
1:             /**
0:              * Drops the stored procedures used in the tests.
0:              * @exception SQLException if a database error occurs
1:              */
0:         	protected void tearDown() throws Exception {
0:                 Connection c = getConnection();
0:                 c.setAutoCommit(false);
0:                 Statement s = c.createStatement();
0:                 for (int i = 0; i < PROCEDURES.length; i++) {
0:                     s.execute("DROP PROCEDURE " + PROCEDURES[i][0]);
0:                 }
0:                 for (int i = 0; i < TABLES.length; i++) {
0:                     s.execute("DROP TABLE " + TABLES[i][0]);
0:                 }
0:                 s.close();
0:                 c.commit();
0:                 c.close();
1:                 
0:                 super.tearDown();
/////////////////////////////////////////////////////////////////////////
commit:576a49f
/////////////////////////////////////////////////////////////////////////
1:     private void assertNoResultSetFromExecuteQuery(SQLException sqle) {
/////////////////////////////////////////////////////////////////////////
1:     private void assertMultipleResultsFromExecuteQuery(SQLException sqle)
/////////////////////////////////////////////////////////////////////////
1:     private void assertResultsFromExecuteUpdate(SQLException sqle) {
/////////////////////////////////////////////////////////////////////////
0:             protected void setUp() throws Exception {
0:             protected void tearDown() throws Exception {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c9bb465
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     
1:         /**
1:          * Test various combinations of getMoreResults
0:          * 
1:          * @throws SQLException
1:          */
1:         public void testGetMoreResults() throws SQLException {
0:             Connection conn = getConnection();
1: 
0:                 Statement s = conn.createStatement();
1:                 
1: 
1:                 s.executeUpdate("create table MRS.FIVERS(i integer)");
0:                 PreparedStatement ps = conn.prepareStatement("insert into MRS.FIVERS values (?)");
1:                 for (int i = 1; i <= 20; i++) {
1:                         ps.setInt(1, i);
1:                         ps.executeUpdate();
0:                 }
0:                 ps.close();
1: 
1:                 // create a procedure that returns 5 result sets.
1:                         
1:                 s.executeUpdate("create procedure MRS.FIVEJP() parameter style JAVA READS SQL DATA dynamic result sets 5 language java external name 'org.apache.derbyTesting.functionTests.util.ProcedureTest.fivejp'");
1: 
1: 
0:                 CallableStatement cs = conn.prepareCall("CALL MRS.FIVEJP()");
1:                 ResultSet[] allRS = new ResultSet[5];
1: 
1:                 defaultGetMoreResults(cs, allRS);
1:                 java.util.Arrays.fill(allRS, null);
1:                 closeCurrentGetMoreResults(cs, allRS);
1:                 java.util.Arrays.fill(allRS, null);
1:                 keepCurrentGetMoreResults(cs, allRS);                              
1:                 java.util.Arrays.fill(allRS, null);
1:                 mixedGetMoreResults(cs, allRS);
1:                 java.util.Arrays.fill(allRS, null);
1:                 checkExecuteClosesResults(cs, allRS);
1:                 java.util.Arrays.fill(allRS, null);
1:                 checkCSCloseClosesResults(cs,allRS);
1:                 java.util.Arrays.fill(allRS, null);
0:         }
1: 
1:         
1:         /**
1:          * Check that CallableStatement.execute() closes results
1:          * @param cs
1:          * @param allRS
1:          * @throws SQLException
1:          */
1:         private void checkExecuteClosesResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             //Fetching result sets with getMoreResults(Statement.KEEP_CURRENT_RESULT) and checking that cs.execute() closes them");          
1:             cs.execute();
1:             int pass = 0;
1:             do {
1: 
0:                     allRS[pass++] = cs.getResultSet();                
1:                     // expect everything to stay open.                        
1: 
1:             } while (cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:             //fetched all results
1:             // All should still be open.
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertDrainResults(allRS[i]);                
1:             
1:             cs.execute();
1:             // all should be closed.
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertClosed(allRS[i]);
0:         }
1: 
1:         /**
1:          * Check that CallableStatement.close() closes results
1:          * @param cs
1:          * @param allRS
1:          * @throws SQLException
1:          */
1:         private void checkCSCloseClosesResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             cs.execute();
1:             int pass = 0;
1:             do {
1: 
0:                     allRS[pass++] = cs.getResultSet();                
1:                     // expect everything to stay open.                        
1: 
1:             } while (cs.getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:             //fetched all results
1:             // All should still be open.
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertDrainResults(allRS[i]);                
1:             
0:             cs.close();
1:             // all should be closed.
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertClosed(allRS[i]);
0:         }
1: 
1:         private void mixedGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             //Fetching result sets with getMoreResults(<mixture>)"
1:             cs.execute();
1: 
1:             //first two with KEEP_CURRENT_RESULT"
1:             allRS[0] = cs.getResultSet();
1:             boolean moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             if (!moreRS)
1:                     fail("FAIL - no second result set");
0:             allRS[1] = cs.getResultSet();                
1:             // two open
1:             allRS[0].next();
1:             assertEquals(2,allRS[0].getInt(1));
1:             allRS[1].next();
1:             assertEquals(3,allRS[1].getInt(1));
1:             
1:             //third with CLOSE_CURRENT_RESULT"
1:             moreRS = cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:             if (!moreRS)
1:                     fail("FAIL - no third result set");
1:             // first and third open
1:             allRS[2] = cs.getResultSet();
1:             assertEquals(2,allRS[0].getInt(1));
1:             JDBC.assertClosed(allRS[1]);
1:             allRS[2].next();
1:             assertEquals(4,allRS[2].getInt(1));
1: 
1:             
1:             //fourth with KEEP_CURRENT_RESULT"
1:             moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             if (!moreRS)
1:                     fail("FAIL - no fourth result set");
1:             allRS[3] = cs.getResultSet();
1:             allRS[3].next();
1:             // first, third and fourth open, second closed
1:             assertEquals(2,allRS[0].getInt(1));
1:             JDBC.assertClosed(allRS[1]);
1:             assertEquals(4,allRS[2].getInt(1));
1:             assertEquals(5,allRS[3].getInt(1));
1:             
1:             //fifth with CLOSE_ALL_RESULTS"
1:             moreRS = cs.getMoreResults(Statement.CLOSE_ALL_RESULTS);
1:             if (!moreRS)
1:                    fail("FAIL - no fifth result set");
1:             allRS[4] = cs.getResultSet();
1:             allRS[4].next();
1:             // only fifth open
1:             JDBC.assertClosed(allRS[0]);
1:             JDBC.assertClosed(allRS[1]);
1:             JDBC.assertClosed(allRS[2]);
1:             JDBC.assertClosed(allRS[3]);
1:             assertEquals(6,allRS[4].getInt(1));
1:             
1:             //no more results with with KEEP_CURRENT_RESULT"
1:             moreRS = cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             if (moreRS)
1:                     fail("FAIL - too many result sets");
1:             // only fifth open
1:             JDBC.assertClosed(allRS[0]);
1:             JDBC.assertClosed(allRS[1]);
1:             JDBC.assertClosed(allRS[2]);
1:             JDBC.assertClosed(allRS[3]);
1:             assertEquals(6,allRS[4].getInt(1));
1:             
1:             allRS[4].close();
0:         }
1: 
1:         /**
1:          * Check getMoreResults(Statement.KEEP_CURRENT_RESULT)  
0:          * 
1:          * @param cs
1:          * @param allRS
1:          * @throws SQLException
1:          */
1:         private void keepCurrentGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             cs.execute();
1:             allRS[0] = cs.getResultSet();
1:             allRS[0].next();
1:             assertEquals(2,allRS[0].getInt(1));
0:             cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             
0:             allRS[1] = cs.getResultSet();
1:             allRS[1].next();
1:             assertEquals(3,allRS[1].getInt(1));
0:             cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:           
1:             allRS[2] = cs.getResultSet();
1:             allRS[2].next();
1:             assertEquals(4,allRS[2].getInt(1));
0:             cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:          
1:             
1:             allRS[3] = cs.getResultSet();
1:             allRS[3].next();
1:             assertEquals(5,allRS[3].getInt(1));
0:             cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             
1: 
1:             
1:             allRS[4] = cs.getResultSet();
1:             allRS[4].next();
1:             assertEquals(6,allRS[4].getInt(1));
0:             cs.getMoreResults(Statement.KEEP_CURRENT_RESULT);
1:             
1:             
1:             // resultSets should still be open
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertDrainResults(allRS[i]);
0:         }
1: 
1:         private void closeCurrentGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             cs.execute();
1:             allRS[0] = cs.getResultSet();
1:             allRS[0].next();
1:             assertEquals(2,allRS[0].getInt(1));
0:             cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:             
0:             allRS[1] = cs.getResultSet();
1:             allRS[1].next();
1:             assertEquals(3,allRS[1].getInt(1));
0:             cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:           
1:             allRS[2] = cs.getResultSet();
1:             allRS[2].next();
1:             assertEquals(4,allRS[2].getInt(1));
0:             cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:             
1:             allRS[3] = cs.getResultSet();
1:             allRS[3].next();
1:             assertEquals(5,allRS[3].getInt(1));
0:             cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1: 
1:             
1:             allRS[4] = cs.getResultSet();
1:             allRS[4].next();
1:             assertEquals(6,allRS[4].getInt(1));
0:             cs.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:             
1:             // verify resultSets are closed
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertClosed(allRS[i]);
0:         }
1: 
1:         /**
1:          * Test default getMoreResults() closes result set.
1:          * @param cs
1:          * @param allRS
1:          * @throws SQLException
1:          */
1:         private void defaultGetMoreResults(CallableStatement cs, ResultSet[] allRS) throws SQLException {
1:             // execute the procedure that returns 5 result sets and then use the various
1:             // options of getMoreResults().
1: 
1:             cs.execute();
1:             allRS[0] = cs.getResultSet();
1:             allRS[0].next();
1:             assertEquals(2,allRS[0].getInt(1));
0:             cs.getMoreResults();
1:             
0:             allRS[1] = cs.getResultSet();
1:             allRS[1].next();
1:             assertEquals(3,allRS[1].getInt(1));
0:             cs.getMoreResults();
1:             
1:             allRS[2] = cs.getResultSet();
1:             allRS[2].next();
1:             assertEquals(4,allRS[2].getInt(1));
0:             cs.getMoreResults();
1:             
1:             allRS[3] = cs.getResultSet();
1:             allRS[3].next();
1:             assertEquals(5,allRS[3].getInt(1));
0:             cs.getMoreResults();
1:             
1:             allRS[4] = cs.getResultSet();
1:             allRS[4].next();
1:             assertEquals(6,allRS[4].getInt(1));
0:             cs.getMoreResults();
1:             
1:             // verify resultSets are closed
1:             for (int i = 0; i < 5; i++)
1:                 JDBC.assertClosed(allRS[i]);
0:         }
1: 
============================================================================