1:70f7692: /*
11:daecc5d: 
1:33776ff:    Derby - Class org.apache.derby.client.am.SqlException
1:d506170: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:d506170: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:daecc5d: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:daecc5d: 
1:d506170: */
1:d506170: 
1:33776ff: package org.apache.derby.client.am;
1:d506170: 
1:daecc5d: import java.sql.SQLException;
1:daecc5d: 
1:daecc5d: import org.apache.derby.shared.common.i18n.MessageUtil;
1:daecc5d: import org.apache.derby.shared.common.error.ExceptionUtil;
1:47509e8: import org.apache.derby.shared.common.reference.MessageId;
1:3d650b1: import org.apache.derby.shared.common.reference.SQLState;
1:daecc5d: 
1:daecc5d: 
1:33776ff: // The signature of the stored procedure SQLCAMessage I have come out so far is as follows:
1:33776ff: // SQLCAMessage (
1:33776ff: //     IN  SQLCode       INTEGER,
1:33776ff: //     IN  SQLErrml      SMALLINT,
1:33776ff: //     IN  SQLErrmc      VARCHAR(70),
1:33776ff: //     IN  SQLErrp       CHAR(8),
1:33776ff: //     IN  SQLErrd0      INTEGER,
1:33776ff: //     IN  SQLErrd1      INTEGER,
1:33776ff: //     IN  SQLErrd2      INTEGER,
1:33776ff: //     IN  SQLErrd3      INTEGER,
1:33776ff: //     IN  SQLErrd4      INTEGER,
1:33776ff: //     IN  SQLErrd5      INTEGER,
1:33776ff: //     IN  SQLWarn       CHAR(11),
1:33776ff: //     IN  SQLState      CHAR(5),
1:33776ff: //     IN  Locale        CHAR(5),
1:33776ff: //     IN  BufferSize    SMALLINT,
1:33776ff: //     IN  LineWidth     SMALLINT,
1:33776ff: //     OUT Message       VARCHAR(2400))
1:33776ff: //
1:33776ff: // Some issues have been identified:
1:33776ff: // 1. What would be the schema name of the stored procedue SQLCAMessage?
1:33776ff: // 2. What is the format and type of the Locale parameter? If there does, I would really like to know the format of the locale in order to decide the type of the Locale parameter. Even there does not either, the Locale parameter probably still needs to be kept there for future extension, and we need to figure out the format of the locale.
1:33776ff: // 3. What would be the format of the output message? Is this full message text ok or do we only need the explanation message corresponding to an SQL code. This somehow matters whether we need the Buffersize and Linewidth parameters for the stored procedure.
1:33776ff: // 4. What if the invocation of stored procedure failed (due to, eg, connection dropping)? In this case, we probably need to return some client-side message.
1:d506170: //
1:d506170: // Note that this class does NOT extend java.sql.SQLException.  This is because
1:d506170: // in JDBC 4 there will be multiple subclasses of SQLException defined by the
1:d506170: // spec.  So we can't also extend SQLException without having to create our
1:d506170: // own mirror hierarchy of subclasses.
1:d506170: //
1:d506170: // When Derby is ready to throw an exception to the application, it catches
1:d506170: // SqlException and converts it to a java.sql.SQLException by calling the
1:d506170: // method getSQLException.
1:d506170: //
1:d506170: // It is also possible that internal routines may call public methods.
1:d506170: // In these cases, it will need to wrap a java.sql.SQLException inside
1:d506170: // a Derby SqlException so that the internal method does not have to throw
1:d506170: // java.sql.SQLException.  Otherwise the chain of dependencies would quickly
1:d506170: // force the majority of internal methods to throw java.sql.SQLException.
1:d506170: // You can wrap a java.sql.SQLException inside a SqlException by using
1:d506170: // the constructor <code>new SqlException(java.sql.SQLException wrapMe)</code)
1:d506170: //
1:d506170: public class SqlException extends Exception implements Diagnosable {
1:0326967:     private static final int DEFAULT_ERRCODE = 99999;
1:0326967:     private transient Sqlca sqlca_ = null; // for engine generated errors only
1:96889c1:     /** Tells which of the messages in the SQLCA this exception refers to
1:96889c1:      * (counting from 0). For engine generated errors only. */
1:96889c1:     private transient int messageNumber_;
1:0326967:     private String message_ = null;
1:0326967:     private String cachedMessage_ = null;
1:70f7692:     private String batchPositionLabel_; // for batched exceptions only
1:0326967:     private String sqlstate_ = null;
1:0326967:     private int errorcode_ = DEFAULT_ERRCODE;
1:0326967:     private String causeString_ = null;
1:d506170:     protected SqlException nextException_;
1:daecc5d:     
1:5847a28:     public static final String CLIENT_MESSAGE_RESOURCE_NAME =
1:f28de92:         "org.apache.derby.loc.clientmessages";
1:5d2e2bd:     
1:95049cf:     /**
1:95049cf:      * SQLException factory is initialized with default factory.
1:95049cf:      * It will be over written by the SQLException factory of the
1:95049cf:      * supported JDBC version.
1:95049cf:      */
1:0326967:     private static SQLExceptionFactory
1:04a6ee6:             exceptionFactory = new SQLExceptionFactory ();
1:d506170:     
1:d506170:     /** 
1:d506170:      *  The message utility instance we use to find messages
1:d506170:      *  It's primed with the name of the client message bundle so that
1:d506170:      *  it knows to look there if the message isn't found in the
1:d506170:      *  shared message bundle.
1:d506170:      */
1:f271471:     private static MessageUtil msgutil_;
1:f271471:     
1:f271471:     /**
1:f271471:      * This routine provides singleton access to an instance of MessageUtil
1:f271471:      * that is constructed for client messages.  It is recommended to use
1:f271471:      * this singleton rather than create your own instance.
1:f271471:      *
1:f271471:      * The only time you need this instance is if you need to directly
1:f271471:      * format an internationalized message string.  In most instances this
1:f271471:      * is done for you when you invoke a SqlException constructor
1:f271471:      *
1:f271471:      * @return a singleton instance of MessageUtil configured for client
1:f271471:      *   messages
1:f271471:      */
1:f271471:     public static MessageUtil getMessageUtil() {
1:f271471:         if ( msgutil_ == null ) {
1:f271471:             msgutil_ = new MessageUtil(CLIENT_MESSAGE_RESOURCE_NAME);
1:f271471:         }
1:04a6ee6:         
1:f271471:         return msgutil_;
1:f271471:     }
1:f271471: 
1:04a6ee6:     /** 
1:d506170:      * The wrapped SQLException, if one exists
1:04a6ee6:      */
1:d506170:     protected SQLException wrappedException_;
1:f271471:   
1:70f7692:     //-----------------constructors-----------------------------------------------
1:daecc5d:     // New constructors that support internationalized messages
1:daecc5d:     // The message id is wrapped inside a class so that we can distinguish
1:daecc5d:     // between the signatures of the new constructors and the old constructors
1:f271471:     
1:f271471:     /**
1:f271471:      * Create a SqlException.  This constructor is the "base" constructor;
1:f271471:      * all other constructors (which take a ClientMessageId) delegate to this
1:f271471:      * constructor
2:f271471:      *
1:f271471:      * @param logwriter
1:f271471:      *      Can be null, but if provided, it is used to log this exception
1:f271471:      *
1:f271471:      * @param msgid
1:f271471:      *      The message id for this message.  ClientMessageId is a simple type-safe
1:f271471:      *      wrapper for org.apache.derby.shared.common.reference.SQLState message id
1:f271471:      *      strings.
1:f271471:      *
1:f271471:      * @param args
1:f271471:      *      The set of substitution arguments for the message.  The Java message
1:f271471:      *      formatter will substitute these arguments into the internationalized
1:f271471:      *      strings using the substitution ({0}, {1}, etc.) markers in the string.
1:f271471:      *      Any object can be passed, but if you want it to be readable, make sure
1:f271471:      *      toString() for the object returns something useful.
1:f271471:      *
1:f271471:      * @param cause
1:f271471:      *      Can be null.  Indicates the cause of this exception.  If this is
1:f271471:      *      an instance of SqlException or java.sql.SQLException then the exception
1:f271471:      *      is chained into the nextException chain.  Otherwise it is chained
1:1f18dc3:      *      using initCause().
1:f271471:      */
1:0326967:     SqlException(LogWriter logwriter,
1:e65b4db:         ClientMessageId msgid, Object[] args, Throwable cause)
1:6eb29f6:     {
1:daecc5d:         this(
1:daecc5d:             logwriter,
1:20a22b0:             cause,
1:f271471:             getMessageUtil().getCompleteMessage(
1:daecc5d:                 msgid.msgid,
1:daecc5d:                 args),
1:daecc5d:             ExceptionUtil.getSQLStateFromIdentifier(msgid.msgid),
1:20a22b0:             ExceptionUtil.getSeverityFromIdentifier(msgid.msgid));        
1:1d87ff4:     }
1:96889c1: 
1:f271471:     // Use the following SQLExceptions when you want to override the error
1:f271471:     // code that is derived from the severity of the message id.
1:0326967:     SqlException(LogWriter logWriter, ClientMessageId msgid, Object[] args,
1:1b39163:         SqlCode sqlcode, Throwable t) {
1:1b39163:         this(logWriter, msgid, args, t);
1:5d2e2bd:         this.errorcode_ = sqlcode.getCode();
1:5d2e2bd:     }
1:b565f41: 
1:e1a79c3:     public SqlException(LogWriter logWriter, ClientMessageId msgid,
1:e1a79c3:                         SqlCode sqlcode, Object... args) {
1:1b39163:         this(logWriter, msgid, args, sqlcode, (Throwable)null);
1:1b39163:     }
1:e1a79c3: 
1:f271471:     // The following constructors are all wrappers around the base constructor,
1:f271471:     // created to make it easy to code against them (you don't have to pass
1:f271471:     // null arguments or construct object arrays).  See the javadoc for the
1:f271471:     // "base" constructor for an explanation of the parameters
1:e1a79c3: 
1:e1a79c3:     public SqlException(LogWriter logWriter, ClientMessageId msgid,
1:e1a79c3:                         Throwable cause, Object... args) {
1:e1a79c3:         this(logWriter, msgid, args, cause);
1:5d2e2bd:     }
1:f271471:     
1:1f18dc3:     public SqlException(LogWriter logwriter,
1:1f18dc3:                         ClientMessageId msgid,
1:1f18dc3:                         Object... args)
1:3d650b1:     {
1:1d87ff4:         this(logwriter, msgid, args, (Throwable)null);
1:5d2e2bd:     }
1:1f18dc3: 
1:96889c1:     /**
1:96889c1:      * Create an exception for an engine generated error.
1:96889c1:      *
1:96889c1:      * @param logWriter object used for tracing
1:96889c1:      * @param sqlca the SQLCA sent from the server
1:96889c1:      */
1:daecc5d:     public SqlException(LogWriter logWriter, Sqlca sqlca) {
1:96889c1:         this(sqlca, 0, true);
1:96889c1:         // only set the error code for the first exception in the chain (we
1:96889c1:         // don't know the error code for the rest)
1:b54db0f:         errorcode_ = sqlca.getErrorCode();
1:daecc5d:         if ( logWriter != null )
1:a53b758:         {
1:b13b17c:             logWriter.traceDiagnosable(SqlException.this);
1:5d2e2bd:         }
1:3d650b1:     }
1:96889c1: 
1:96889c1:     /**
1:96889c1:      * Create one of the exceptions in an exception chain generated by the
1:96889c1:      * engine. This constructor calls itself recursively to create the rest of
1:b13b17c:      * the exception chain if {@code chain} is
1:b13b17c:      * {@code true}.
1:96889c1:      *
1:96889c1:      * @param sqlca the SQLCA sent from the server
1:96889c1:      * @param number the message number for this exception (counting from 0)
1:b13b17c:      * @param chain if {@code true}, generate the rest of the exception
1:96889c1:      * chain recursively and link it to this exception
1:96889c1:      */
1:96889c1:     private SqlException(Sqlca sqlca, int number, boolean chain) {
1:96889c1:         this.sqlca_ = sqlca;
1:96889c1:         messageNumber_ = number;
1:96889c1:         sqlstate_ = sqlca.getSqlState(number);
1:b850119: 
1:b850119:         // If the SQLState indicates that this is a java.sql.DataTruncation
1:b850119:         // type of exception, generate one right away.
1:b850119:         if (SQLState.DATA_TRUNCATION_READ.equals(sqlstate_)) {
1:b850119:             wrappedException_ = sqlca.getDataTruncation();
1:b850119:         }
1:b850119: 
1:96889c1:         int nextMsg = number + 1;
1:96889c1:         if (chain && (sqlca.numberOfMessages() > nextMsg)) {
1:96889c1:             setThrowable(new SqlException(sqlca, nextMsg, true));
1:96889c1:         }
1:96889c1:     }
1:1b39163:     
1:daecc5d:     // Once all messages are internationalized, these methods should become
1:daecc5d:     // private
1:b565f41:     private SqlException(LogWriter logWriter, String reason, String sqlState,
1:daecc5d:         int errorCode)
1:486829c:     {
1:1d87ff4:         this(logWriter, (Throwable)null, reason, sqlState, errorCode);
1:a53b758:     }
1:5d2e2bd: 
1:b565f41:     private SqlException(LogWriter logWriter, Throwable throwable,
1:daecc5d:         String reason, String sqlState, int errorCode ) {
1:daecc5d:         message_ = reason;
1:d506170:         sqlstate_ = sqlState;
1:d506170:         errorcode_ = errorCode;
1:5d2e2bd: 
1:d506170:         setThrowable(throwable);
1:5d2e2bd:         
2:daecc5d:         if (logWriter != null) {
1:b13b17c:             logWriter.traceDiagnosable(SqlException.this);
1:486829c:         }
1:5d2e2bd:         
1:d506170:     }
1:3d650b1:     
1:5d2e2bd:     /**
1:55d4cdf:      * Set the cause of this exception based on its type.
1:b13b17c:      * {@code SQLException}s and
1:b13b17c:      * {@code SqlException}s are
1:b13b17c:      * linked with {@code setNextException()} and
1:b13b17c:      * {@code initCause()}.
1:b13b17c:      * All other exception types are linked with {@code initCause()}.
1:5d2e2bd:      */
1:55d4cdf:     private void setThrowable(Throwable throwable)
1:7680ab7:     {
1:d506170:         if ( throwable instanceof SqlException )
1:d506170:         {
1:d506170:             setNextException((SqlException) throwable);
1:d506170:         }
1:d506170:         else if ( throwable instanceof SQLException )
1:d506170:         {
1:d506170:             setNextException((SQLException) throwable );
1:d506170:         }
1:a53b758: 
1:55d4cdf:         if (throwable != null) {
1:55d4cdf:             initCause(throwable);
1:55d4cdf:         }
1:d506170:     }
1:a53b758:         
1:3d650b1:     /**
1:d506170:      * Wrap a SQLException in a SqlException.  This is used by internal routines
1:d506170:      * so the don't have to throw SQLException, which, through the chain of 
1:d506170:      * dependencies would force more and more internal routines to throw
1:d506170:      * SQLException
1:d506170:      */
1:d506170:     public SqlException(SQLException wrapme)
1:d506170:     {
1:d506170:         wrappedException_ = wrapme;
4:daecc5d:     }
1:b2a1747:                 
1:a53b758:     
1:d506170:     /**
1:d506170:      * Convert this SqlException into a java.sql.SQLException
1:d506170:      */
1:d506170:     public SQLException getSQLException()
1:d506170:     {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             return wrappedException_;
1:d506170:         }
1:50ff043:                         
1:d506170:         // When we have support for JDBC 4 SQLException subclasses, this is
1:d506170:         // where we decide which exception to create
1:04a6ee6:         SQLException sqle = exceptionFactory.getSQLException(getMessage(), getSQLState(), 
1:d57ff17:             getErrorCode(), getArgs());
1:55d4cdf:         sqle.initCause(this);
1:486829c: 
1:d506170:         // Set up the nextException chain
1:d506170:         if ( nextException_ != null )
1:d506170:         {
1:d506170:             // The exception chain gets constructed automatically through 
1:d506170:             // the beautiful power of recursion
1:d506170:             sqle.setNextException(nextException_.getSQLException());
1:d506170:         }
1:7680ab7:         
1:d506170:         return sqle;
1:d506170:     }    
1:d506170: 
1:70f7692:     // Label an exception element in a batched update exception chain.
1:70f7692:     // This text will be prepended onto the exceptions message text dynamically
1:70f7692:     // when getMessage() is called.
1:70f7692:     // Called by the Agent.
1:70f7692:     void setBatchPositionLabel(int index) {
1:47509e8:         batchPositionLabel_ = getMessageUtil().getTextMessage(MessageId.BATCH_POSITION_ID) + 
1:5d2e2bd:             index + ": ";
1:daecc5d:     }
1:d506170: 
1:70f7692:     public Sqlca getSqlca() {
1:70f7692:         return sqlca_;
1:daecc5d:     }
1:d506170: 
1:d6401b1:     @Override
1:d6401b1:     public String toString() {
1:d6401b1:         // Match what the embedded driver does in StandardException.toString().
1:d6401b1:         return "ERROR " + getSQLState() + ": " + getMessage();
1:d6401b1:     }
1:d6401b1: 
1:d57ff17:     private Object []getArgs() {
1:d57ff17:         if( sqlca_ != null )
1:d57ff17:             return ((Sqlca)sqlca_).getArgs(messageNumber_);
1:d57ff17:         return null;
1:d57ff17:     }
1:d57ff17: 
1:d6401b1:     @Override
1:70f7692:     public String getMessage() {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             return wrappedException_.getMessage();
1:d506170:         }
1:d506170:         
1:b2c1772:         // The Net JDBC message is retrieved and cached if we have a valid
1:b2c1772:         // SQLCA handle.
1:b2c1772:         // It is possible that we don't have one in case of a serialized
1:b2c1772:         // SqlException for instance. In this case, we set the message to the
1:b2c1772:         // last one cached previously (if any available).
1:b2c1772:         // For serialized SqlException, we can serialize the SQLCA as the
1:b2c1772:         // object handle would become invalid, upon deserialization, causing
1:b2c1772:         // the connection and JDBC not being retrievable (hence why it is
1:b2c1772:         // being cached here).
1:daecc5d:         if (sqlca_ != null) {
1:96889c1:             cachedMessage_ = message_ =
1:96889c1:                     ((Sqlca) sqlca_).getJDBCMessage(messageNumber_);
1:b2c1772:         }
1:b2c1772:         else if (cachedMessage_ != null) {
1:b2c1772:             // SQLCA is no longer valid, set the message to the previously
1:b2c1772:             // cached one
1:b2c1772:             message_ = cachedMessage_;
1:daecc5d:         }
1:d506170:         
1:d506170:         if (batchPositionLabel_ != null) {
1:d506170:             message_ = batchPositionLabel_ + message_;
1:daecc5d:         }
1:d506170:         
1:d506170:         if ( causeString_ != null ) {
1:d506170:             // Append the string indicating the cause of the exception
1:d506170:             // (this happens only in JDK13 environments)
1:d506170:             message_ += causeString_;
1:d506170:         }
1:d506170:         
1:d506170:         return message_;
1:daecc5d:     }
1:d506170: 
1:70f7692:     public String getSQLState() {
1:d506170:         if ( wrappedException_ != null )
3:d506170:         {
1:d506170:             return wrappedException_.getSQLState();
1:d506170:         }
1:96889c1: 
1:96889c1:         return sqlstate_;
1:daecc5d:     }
1:d506170: 
1:70f7692:     public int getErrorCode() {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             return wrappedException_.getErrorCode();
1:d506170:         }
1:d506170:         
1:96889c1:         return errorcode_;
1:daecc5d:     }
1:d506170: 
1:d506170:     public SqlException getNextException()
1:d506170:     {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             return new SqlException(wrappedException_.getNextException());
1:d506170:         }
1:d506170:         else
1:d506170:         {
1:d506170:             return nextException_;
1:d506170:         }
1:d506170:     }
1:d506170:     
1:d506170:     public void setNextException(SqlException nextException)
1:d506170:     {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             wrappedException_.setNextException(nextException.getSQLException());
1:d506170:         }
1:d506170:         else
1:d506170:         {
1:d506170:             nextException_ = nextException;
1:d506170:         }        
1:d506170:     }
1:d506170:     
1:d506170:     public void setNextException(SQLException nextException)
1:7f6e8aa:     {
1:d506170:         if ( wrappedException_ != null )
1:d506170:         {
1:d506170:             wrappedException_.setNextException(nextException);
1:d506170:         }
1:d506170:         else
1:d506170:         {
1:7680ab7:             // Add this exception to the end of the chain
1:7680ab7:             SqlException theEnd = this;
1:7680ab7:             while (theEnd.nextException_ != null) {
1:7680ab7:                 theEnd = theEnd.nextException_;
1:7680ab7:             }
1:7680ab7:             theEnd.nextException_ = new SqlException(nextException);
1:daecc5d:         }
1:daecc5d:     }
1:daecc5d: 
2:d506170:     /**
1:3d650b1:      * Helper method to construct an exception which basically says that
1:3d650b1:      * we encountered an underlying Java exception
1:3d650b1:      */
1:b565f41:     static SqlException javaException(LogWriter logWriter, Throwable e) {
1:3d650b1:         return new SqlException(logWriter, 
1:e65b4db:             new ClientMessageId (SQLState.JAVA_EXCEPTION), 
1:3d650b1:             new Object[] {e.getClass().getName(), e.getMessage()}, e);
1:3d650b1:     }
1:3d650b1:     
1:70f7692:     // Return a single SQLException without the "next" pointing to another SQLException.
1:70f7692:     // Because the "next" is a private field in java.sql.SQLException,
1:70f7692:     // we have to create a new SqlException in order to break the chain with "next" as null.
1:70f7692:     SqlException copyAsUnchainedSQLException(LogWriter logWriter) {
1:70f7692:         if (sqlca_ != null) {
1:96889c1:             // server error
1:96889c1:             return new SqlException(sqlca_, messageNumber_, false);
4:70f7692:         } else {
1:70f7692:             return new SqlException(logWriter, getMessage(), getSQLState(), getErrorCode()); // client error
1:04a6ee6:         }
1:d506170:     }
1:d506170: }
1:d506170: 
3:33776ff: // An intermediate exception encapsulation to provide code-reuse
2:33776ff: // for common ResultSet data conversion exceptions.
1:d506170: 
1:70f7692: class ColumnTypeConversionException extends SqlException {
1:6ef238b:     ColumnTypeConversionException(LogWriter logWriter, String targetType,
1:6ef238b:         String sourceType) {
3:70f7692:         super(logWriter,
1:e65b4db:             new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH),
1:6ef238b:             targetType, sourceType);
1:daecc5d:     }
1:daecc5d: }
1:daecc5d: 
1:33776ff: // An intermediate exception encapsulation to provide code-reuse
1:33776ff: // for common CrossConverters data conversion exceptions.
1:daecc5d: 
1:ae40e9f: class OutsideRangeForDataTypeException extends SqlException {
1:ae40e9f:     OutsideRangeForDataTypeException(LogWriter logWriter, String instance) {
1:ae40e9f:         super(logWriter,
1:ae40e9f:               new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE), 
1:ae40e9f:               instance);
1:daecc5d:     }
1:daecc5d: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d57ff17
/////////////////////////////////////////////////////////////////////////
1:             getErrorCode(), getArgs());
/////////////////////////////////////////////////////////////////////////
1:     private Object []getArgs() {
1:         if( sqlca_ != null )
1:             return ((Sqlca)sqlca_).getArgs(messageNumber_);
1:         return null;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d6401b1
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString() {
1:         // Match what the embedded driver does in StandardException.toString().
1:         return "ERROR " + getSQLState() + ": " + getMessage();
1:     }
1: 
1:     @Override
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:     public SqlException(LogWriter logWriter, ClientMessageId msgid,
1:                         SqlCode sqlcode, Object... args) {
1: 
1: 
1:     public SqlException(LogWriter logWriter, ClientMessageId msgid,
1:                         Throwable cause, Object... args) {
1:         this(logWriter, msgid, args, cause);
/////////////////////////////////////////////////////////////////////////
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
1:      *      using initCause().
/////////////////////////////////////////////////////////////////////////
1:     public SqlException(LogWriter logwriter,
1:                         ClientMessageId msgid,
1:                         Object... args)
1: 
/////////////////////////////////////////////////////////////////////////
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
commit:7f6e8aa
/////////////////////////////////////////////////////////////////////////
1:     {
commit:b54db0f
/////////////////////////////////////////////////////////////////////////
1:         errorcode_ = sqlca.getErrorCode();
commit:b850119
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If the SQLState indicates that this is a java.sql.DataTruncation
1:         // type of exception, generate one right away.
1:         if (SQLState.DATA_TRUNCATION_READ.equals(sqlstate_)) {
1:             wrappedException_ = sqlca.getDataTruncation();
1:         }
1: 
commit:5847a28
/////////////////////////////////////////////////////////////////////////
1:     public static final String CLIENT_MESSAGE_RESOURCE_NAME =
commit:55d4cdf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Set the cause of this exception based on its type.
0:      * <code>SQLException</code>s and <code>SqlException</code>s are
0:      * linked with <code>setNextException()</code> and <code>initCause()</code>.
0:      * All other exception types are linked with <code>initCause()</code>.
1:     private void setThrowable(Throwable throwable)
/////////////////////////////////////////////////////////////////////////
1:         if (throwable != null) {
1:             initCause(throwable);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         sqle.initCause(this);
/////////////////////////////////////////////////////////////////////////
commit:96889c1
/////////////////////////////////////////////////////////////////////////
1:     /** Tells which of the messages in the SQLCA this exception refers to
1:      * (counting from 0). For engine generated errors only. */
1:     private transient int messageNumber_;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create an exception for an engine generated error.
1:      *
1:      * @param logWriter object used for tracing
1:      * @param sqlca the SQLCA sent from the server
1:      */
1:         this(sqlca, 0, true);
1:         // only set the error code for the first exception in the chain (we
1:         // don't know the error code for the rest)
0:         errorcode_ = sqlca.getSqlCode();
1: 
1:     /**
1:      * Create one of the exceptions in an exception chain generated by the
1:      * engine. This constructor calls itself recursively to create the rest of
0:      * the exception chain if <code>chain</code> is <code>true</code>.
1:      *
1:      * @param sqlca the SQLCA sent from the server
1:      * @param number the message number for this exception (counting from 0)
0:      * @param chain if <code>true</code>, generate the rest of the exception
1:      * chain recursively and link it to this exception
1:      */
1:     private SqlException(Sqlca sqlca, int number, boolean chain) {
1:         this.sqlca_ = sqlca;
1:         messageNumber_ = number;
1:         sqlstate_ = sqlca.getSqlState(number);
1:         int nextMsg = number + 1;
1:         if (chain && (sqlca.numberOfMessages() > nextMsg)) {
1:             setThrowable(new SqlException(sqlca, nextMsg, true));
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:             cachedMessage_ = message_ =
1:                     ((Sqlca) sqlca_).getJDBCMessage(messageNumber_);
/////////////////////////////////////////////////////////////////////////
1: 
1:         return sqlstate_;
/////////////////////////////////////////////////////////////////////////
1:         return errorcode_;
/////////////////////////////////////////////////////////////////////////
1:             // server error
1:             return new SqlException(sqlca_, messageNumber_, false);
commit:b2c1772
/////////////////////////////////////////////////////////////////////////
0:     protected transient Sqlca sqlca_ = null; // for engine generated errors only
0:     protected String cachedMessage_ = null;
/////////////////////////////////////////////////////////////////////////
1:         // The Net JDBC message is retrieved and cached if we have a valid
1:         // SQLCA handle.
1:         // It is possible that we don't have one in case of a serialized
1:         // SqlException for instance. In this case, we set the message to the
1:         // last one cached previously (if any available).
1:         // For serialized SqlException, we can serialize the SQLCA as the
1:         // object handle would become invalid, upon deserialization, causing
1:         // the connection and JDBC not being retrievable (hence why it is
1:         // being cached here).
0:             cachedMessage_ = message_ = ((Sqlca) sqlca_).getJDBCMessage();
1:         }
1:         else if (cachedMessage_ != null) {
1:             // SQLCA is no longer valid, set the message to the previously
1:             // cached one
1:             message_ = cachedMessage_;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private SqlException(
0:         LogWriter logWriter,
0:         ClientMessageId msgid,
0:         Object[] args,
1: 
0:     SqlException(LogWriter logWriter, ClientMessageId msgid, Object arg1,
/////////////////////////////////////////////////////////////////////////
1:     private SqlException(LogWriter logWriter, String reason, String sqlState,
1:     private SqlException(LogWriter logWriter, Throwable throwable,
/////////////////////////////////////////////////////////////////////////
1:     static SqlException javaException(LogWriter logWriter, Throwable e) {
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private static final int DEFAULT_ERRCODE = 99999;
1:     private transient Sqlca sqlca_ = null; // for engine generated errors only
1:     private String message_ = null;
1:     private String cachedMessage_ = null;
1:     private String sqlstate_ = null;
1:     private int errorcode_ = DEFAULT_ERRCODE;
1:     private String causeString_ = null;
/////////////////////////////////////////////////////////////////////////
1:     private static SQLExceptionFactory
/////////////////////////////////////////////////////////////////////////
1:     SqlException(LogWriter logwriter,
/////////////////////////////////////////////////////////////////////////
1:     SqlException(LogWriter logWriter, ClientMessageId msgid, Object[] args,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private SqlException(LogWriter logwriter,
0:                          ClientMessageId msgid,
0:                          Object[] args)
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
0:     protected SqlException(LogWriter logWriter, Throwable throwable,
/////////////////////////////////////////////////////////////////////////
0:     public void printTrace(PrintWriter printWriter, String header) {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             logWriter.traceDiagnosable(SqlException.this);
1:      * the exception chain if {@code chain} is
1:      * {@code true}.
1:      * @param chain if {@code true}, generate the rest of the exception
/////////////////////////////////////////////////////////////////////////
1:             logWriter.traceDiagnosable(SqlException.this);
1:      * {@code SQLException}s and
1:      * {@code SqlException}s are
1:      * linked with {@code setNextException()} and
1:      * {@code initCause()}.
1:      * All other exception types are linked with {@code initCause()}.
commit:95049cf
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * SQLException factory is initialized with default factory.
1:      * It will be over written by the SQLException factory of the
1:      * supported JDBC version.
1:      */
0:     static SQLExceptionFactory
commit:ae40e9f
/////////////////////////////////////////////////////////////////////////
1: class OutsideRangeForDataTypeException extends SqlException {
1:     OutsideRangeForDataTypeException(LogWriter logWriter, String instance) {
1:         super(logWriter,
1:               new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE), 
1:               instance);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:     {    
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6ef238b
/////////////////////////////////////////////////////////////////////////
1:     ColumnTypeConversionException(LogWriter logWriter, String targetType,
1:         String sourceType) {
1:             targetType, sourceType);
commit:04a6ee6
/////////////////////////////////////////////////////////////////////////
0:     //SQLException factory initialised with default factory
0:     //It will be over written by the SQLException factory of the 
0:     //supported jdbc version    
0:     protected static SQLExceptionFactory 
1:             exceptionFactory = new SQLExceptionFactory ();
/////////////////////////////////////////////////////////////////////////
1:         SQLException sqle = exceptionFactory.getSQLException(getMessage(), getSQLState(), 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Sets the exceptionFactory to be used for creating SQLException
0:      * @param factory SQLExceptionFactory
1:      */
0:     public static void setExceptionFactory (SQLExceptionFactory factory) {
0:         exceptionFactory = factory;
1:     }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:47509e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         batchPositionLabel_ = getMessageUtil().getTextMessage(MessageId.BATCH_POSITION_ID) + 
commit:e315e42
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6dba60c
/////////////////////////////////////////////////////////////////////////
commit:20a22b0
/////////////////////////////////////////////////////////////////////////
1:             cause,
1:             ExceptionUtil.getSeverityFromIdentifier(msgid.msgid));        
commit:44ad7f6
/////////////////////////////////////////////////////////////////////////
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
0:     protected SqlException(LogWriter logWriter, String reason, String sqlState,
0:     protected SqlException(LogWriter logWriter, java.lang.Throwable throwable, 
/////////////////////////////////////////////////////////////////////////
1:                 
commit:f271471
/////////////////////////////////////////////////////////////////////////
1:     private static MessageUtil msgutil_;
1:     
1:     /**
1:      * This routine provides singleton access to an instance of MessageUtil
1:      * that is constructed for client messages.  It is recommended to use
1:      * this singleton rather than create your own instance.
1:      *
1:      * The only time you need this instance is if you need to directly
1:      * format an internationalized message string.  In most instances this
1:      * is done for you when you invoke a SqlException constructor
1:      *
1:      * @return a singleton instance of MessageUtil configured for client
1:      *   messages
1:      */
1:     public static MessageUtil getMessageUtil() {
1:         if ( msgutil_ == null ) {
1:             msgutil_ = new MessageUtil(CLIENT_MESSAGE_RESOURCE_NAME);
1:         }
1:         
1:         return msgutil_;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Create a SqlException.  This constructor is the "base" constructor;
1:      * all other constructors (which take a ClientMessageId) delegate to this
1:      * constructor
1:      *
1:      * @param logwriter
1:      *      Can be null, but if provided, it is used to log this exception
1:      *
1:      * @param msgid
1:      *      The message id for this message.  ClientMessageId is a simple type-safe
1:      *      wrapper for org.apache.derby.shared.common.reference.SQLState message id
1:      *      strings.
1:      *
1:      * @param args
1:      *      The set of substitution arguments for the message.  The Java message
1:      *      formatter will substitute these arguments into the internationalized
1:      *      strings using the substitution ({0}, {1}, etc.) markers in the string.
1:      *      Any object can be passed, but if you want it to be readable, make sure
1:      *      toString() for the object returns something useful.
1:      *
1:      * @param cause
1:      *      Can be null.  Indicates the cause of this exception.  If this is
1:      *      an instance of SqlException or java.sql.SQLException then the exception
1:      *      is chained into the nextException chain.  Otherwise it is chained
0:      *      using initCause().  On JDK 1.3, since initCause() does not exist,
0:      *      a non-SQL exception can not be chained.  Instead, the exception class
0:      *      and message text is appended to the message for this exception.
1:      *
0:      * @return 
0:      *      An instance of SqlException that you can throw to your heart's content.
1:      */
1:             getMessageUtil().getCompleteMessage(
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Use the following SQLExceptions when you want to override the error
1:     // code that is derived from the severity of the message id.
1: 
/////////////////////////////////////////////////////////////////////////
1:     // The following constructors are all wrappers around the base constructor,
1:     // created to make it easy to code against them (you don't have to pass
1:     // null arguments or construct object arrays).  See the javadoc for the
1:     // "base" constructor for an explanation of the parameters
/////////////////////////////////////////////////////////////////////////
0:                     getMessageUtil().getTextMessage(CAUSED_BY_EXCEPTION_ID)  + " " +
/////////////////////////////////////////////////////////////////////////
0:     // all the messages.  These should be removed once internationalization is
0:     // complete
/////////////////////////////////////////////////////////////////////////
0:         batchPositionLabel_ = getMessageUtil().getTextMessage(BATCH_POSITION_ID) + 
commit:1b39163
/////////////////////////////////////////////////////////////////////////
1:         SqlCode sqlcode, Throwable t) {
1:         this(logWriter, msgid, args, t);
1:     
0:     public SqlException(LogWriter logWriter, ClientMessageId msgid, Object[] args,
0:         SqlCode sqlcode) {
1:         this(logWriter, msgid, args, sqlcode, (Throwable)null);
1:     }
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:         ClientMessageId msgid, Object[] args, Throwable cause)
/////////////////////////////////////////////////////////////////////////
0:     public SqlException(LogWriter logWriter, ClientMessageId msgid, Object[] args,
0:     public SqlException(LogWriter logWriter, ClientMessageId msgid, SqlCode sqlcode) {
0:     public SqlException(LogWriter logWriter, ClientMessageId msgid, Object arg1,
0:     public SqlException(LogWriter logWriter, ClientMessageId msgid, Object arg1,
0:             ClientMessageId msgid, Throwable cause) {
0:     public SqlException(LogWriter logwriter, ClientMessageId msgid, Object[] args)
0:     public SqlException (LogWriter logwriter, ClientMessageId msgid)
0:     public SqlException(LogWriter logwriter, ClientMessageId msgid, Object arg1)
0:     public SqlException(LogWriter logwriter, ClientMessageId msgid, 
0:     public SqlException(LogWriter logwriter, ClientMessageId msgid,
0:         ClientMessageId msgid, Object arg1, Object arg2)
0:         ClientMessageId msgid, Object arg1, Object arg2, Object arg3)
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId (SQLState.JAVA_EXCEPTION), 
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH),
/////////////////////////////////////////////////////////////////////////
0:         super(logWriter, new ClientMessageId(SQLState.LOSS_OF_PRECISION_EXCEPTION), 
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
0:     // Constants for message ids used in text we print out -- not used
0:     // in SqlExceptions
0:     public static final String CAUSED_BY_EXCEPTION_ID           = "J106";
0:     public static final String BATCH_POSITION_ID                = "J107";
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Use this to override the standard error code that is derived
0:      * from the message severity
1:      */
0:     public SqlException(LogWriter logWriter, MessageId msgid, Object[] args,
0:         SqlCode sqlcode) {
0:         this(logWriter, msgid, args);
1:         this.errorcode_ = sqlcode.getCode();
1:     }
1:         
0:     public SqlException(LogWriter logWriter, MessageId msgid, SqlCode sqlcode) {
0:         this(logWriter, msgid, (Object[])null, sqlcode);
1:     }
1:     
0:     public SqlException(LogWriter logWriter, MessageId msgid, Object arg1,
0:         SqlCode sqlcode) {
0:         this(logWriter, msgid, new Object[] {arg1}, sqlcode);
1:     }
1:         
0:     public SqlException(LogWriter logWriter, MessageId msgid, Object arg1,
0:         Object arg2, SqlCode sqlcode) {
0:         this(logWriter, msgid, new Object[] {arg1, arg2}, sqlcode);
1:     }
/////////////////////////////////////////////////////////////////////////
0:                 causeString_ = " " + 
0:                     msgutil_.getTextMessage(CAUSED_BY_EXCEPTION_ID)  + " " +
/////////////////////////////////////////////////////////////////////////
0:         batchPositionLabel_ = msgutil_.getTextMessage(BATCH_POSITION_ID) + 
1:             index + ": ";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         super(logWriter, new MessageId(SQLState.LOSS_OF_PRECISION_EXCEPTION), 
0:             instance);
commit:1d87ff4
/////////////////////////////////////////////////////////////////////////
0:         if ( cause != null ) {
0:             this.setThrowable(cause);
1:         }
0:         this (logwriter, msgid, (Object[])null, cause);
1:         this(logwriter, msgid, args, (Throwable)null);
/////////////////////////////////////////////////////////////////////////
1:         this(logWriter, (Throwable)null, reason, sqlState, errorCode);
commit:3d650b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:     public SqlException(LogWriter logwriter, MessageId msgid,
0:         Object arg1, Object arg2, Throwable cause)
1:     {
0:         this(logwriter, msgid, new Object[] { arg1, arg2 }, cause);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Helper method to construct an exception which basically says that
1:      * we encountered an underlying Java exception
1:      */
0:     public static SqlException javaException(LogWriter logWriter, Throwable e) {
1:         return new SqlException(logWriter, 
0:             new MessageId (SQLState.JAVA_EXCEPTION), 
1:             new Object[] {e.getClass().getName(), e.getMessage()}, e);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:     ColumnTypeConversionException(LogWriter logWriter, String sourceType,
0:         String targetType) {
0:             new MessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH),
0:             sourceType, targetType);
commit:a53b758
/////////////////////////////////////////////////////////////////////////
1:  
0:     public SqlException (LogWriter logwriter, 
0:             MessageId msgid, Throwable cause) {
0:         this (logwriter, msgid, null, cause);
/////////////////////////////////////////////////////////////////////////
0:     public SqlException(LogWriter logwriter, MessageId msgid, 
0:             Object arg1, Throwable cause)
1:     {
0:         this(logwriter, msgid, new Object[] { arg1 }, cause);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:             
commit:fc25cc0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
commit:50ff043
/////////////////////////////////////////////////////////////////////////
1:         
0:         this.setThrowable(cause);
/////////////////////////////////////////////////////////////////////////
0:         // of the SQLException to be this SqlException.  Otherwise the stack
0:         // trace is lost.
commit:486829c
/////////////////////////////////////////////////////////////////////////
1: 
0:     public SqlException(LogWriter logWriter, MessageId messageId, Throwable cause)
1:     {
0:         this(logWriter,messageId,null,cause);
1:     }
/////////////////////////////////////////////////////////////////////////
0:         this(logwriter, msgid, (Object[])null);
commit:8f8cbff
/////////////////////////////////////////////////////////////////////////
0:         // of the SQLException to be this SqlException.
0:             sqle.initCause(this);
commit:7680ab7
/////////////////////////////////////////////////////////////////////////
0: import java.util.TreeMap;
/////////////////////////////////////////////////////////////////////////
1:                         
/////////////////////////////////////////////////////////////////////////
1:     {	
1:             // Add this exception to the end of the chain
1:             SqlException theEnd = this;
1:             while (theEnd.nextException_ != null) {
1:                 theEnd = theEnd.nextException_;
1:             }
1:             theEnd.nextException_ = new SqlException(nextException);
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: //
1: // Note that this class does NOT extend java.sql.SQLException.  This is because
1: // in JDBC 4 there will be multiple subclasses of SQLException defined by the
1: // spec.  So we can't also extend SQLException without having to create our
1: // own mirror hierarchy of subclasses.
1: //
1: // When Derby is ready to throw an exception to the application, it catches
1: // SqlException and converts it to a java.sql.SQLException by calling the
1: // method getSQLException.
1: //
1: // It is also possible that internal routines may call public methods.
1: // In these cases, it will need to wrap a java.sql.SQLException inside
1: // a Derby SqlException so that the internal method does not have to throw
1: // java.sql.SQLException.  Otherwise the chain of dependencies would quickly
1: // force the majority of internal methods to throw java.sql.SQLException.
1: // You can wrap a java.sql.SQLException inside a SqlException by using
1: // the constructor <code>new SqlException(java.sql.SQLException wrapMe)</code)
1: //
1: public class SqlException extends Exception implements Diagnosable {
0:     protected String sqlstate_ = null;
0:     protected int errorcode_ = DEFAULT_ERRCODE;
0:     protected String causeString_ = null;
1:     protected SqlException nextException_;
0:     protected Throwable throwable_;
1:     
1:     /** 
1:      *  The message utility instance we use to find messages
1:      *  It's primed with the name of the client message bundle so that
1:      *  it knows to look there if the message isn't found in the
1:      *  shared message bundle.
1:      */
1:     /** 
1:      * The wrapped SQLException, if one exists
1:      */
1:     protected SQLException wrappedException_;
1:   
/////////////////////////////////////////////////////////////////////////
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, 
1:         sqlstate_ = sqlState;
1:         errorcode_ = errorCode;
1:         setThrowable(throwable);
1:     
1:     /**
0:      * Set the cause of this exception based on its type and
0:      * the current runtime version of Java
1:      */
0:     protected void setThrowable(Throwable throwable)
0:         throwable_ = throwable;
1:         
0:         // If the throwable is a SQL exception, use nextException rather
0:         // than chained exceptions
1:         if ( throwable instanceof SqlException )
1:             setNextException((SqlException) throwable);
1:         }
1:         else if ( throwable instanceof SQLException )
1:         {
1:             setNextException((SQLException) throwable );
1:         }
0:         else if ( throwable != null )
1:         {
0:             // Set up a string indicating the cause if the current runtime
0:             // doesn't support the initCause() method.  This is then used
0:             // by getMessage() when it composes the message string.
0:             if (JVMInfo.JDK_ID < JVMInfo.J2SE_14 )
0:                 causeString_ = " Caused by exception " + 
0:                     throwable.getClass() + ": " + throwable.getMessage();
0:                 initCause(throwable);
1: 
1:     }
1:         
1:     /**
1:      * Wrap a SQLException in a SqlException.  This is used by internal routines
1:      * so the don't have to throw SQLException, which, through the chain of 
1:      * dependencies would force more and more internal routines to throw
1:      * SQLException
1:      */
1:     public SqlException(SQLException wrapme)
1:     {
1:         wrappedException_ = wrapme;
/////////////////////////////////////////////////////////////////////////
1:     
0:     /**
1:      * Convert this SqlException into a java.sql.SQLException
0:      */
1:     public SQLException getSQLException()
1:     {
1:         if ( wrappedException_ != null )
1:         {
1:             return wrappedException_;
1:         }
1:                 
1:         // When we have support for JDBC 4 SQLException subclasses, this is
1:         // where we decide which exception to create
0:         SQLException sqle = new SQLException(getMessage(), getSQLState(), 
0:             getErrorCode());
1: 
0:         // If we're in a runtime that supports chained exceptions, set the cause 
0:         // of the SQLException.
0:          if (JVMInfo.JDK_ID >= JVMInfo.J2SE_14 )
1:         {
0:             sqle.initCause(getCause());
1:         }
1: 
1:         // Set up the nextException chain
1:         if ( nextException_ != null )
1:         {
1:             // The exception chain gets constructed automatically through 
1:             // the beautiful power of recursion
1:             sqle.setNextException(nextException_.getSQLException());
1:         }
1:         
1:         return sqle;
1:     }    
/////////////////////////////////////////////////////////////////////////
1:         if ( wrappedException_ != null )
1:         {
1:             return wrappedException_.getMessage();
1:         }
1:         
1:         
1:         if (batchPositionLabel_ != null) {
1:             message_ = batchPositionLabel_ + message_;
1:         
1:         if ( causeString_ != null ) {
1:             // Append the string indicating the cause of the exception
1:             // (this happens only in JDK13 environments)
1:             message_ += causeString_;
1:         }
1:         
1:         return message_;
1:         if ( wrappedException_ != null )
1:         {
1:             return wrappedException_.getSQLState();
1:         }
1:         
0:             return sqlstate_;
1:         if ( wrappedException_ != null )
1:         {
1:             return wrappedException_.getErrorCode();
1:         }
1:         
0:             return errorcode_;
1:     public SqlException getNextException()
1:     {
1:         if ( wrappedException_ != null )
1:         {
1:             return new SqlException(wrappedException_.getNextException());
1:         }
1:         else
1:         {
1:             return nextException_;
1:         }
1:     }
1:     
1:     public void setNextException(SqlException nextException)
1:     {
1:         if ( wrappedException_ != null )
1:         {
1:             wrappedException_.setNextException(nextException.getSQLException());
1:         }
1:         else
1:         {
1:             nextException_ = nextException;
1:         }        
1:     }
1:     
1:     public void setNextException(SQLException nextException)
1:     {
1:         if ( wrappedException_ != null )
1:         {
1:             wrappedException_.setNextException(nextException);
1:         }
1:         else
1:         {
0:             nextException_ = new SqlException(nextException);
1:         }
1:     }
1: 
commit:f28de92
/////////////////////////////////////////////////////////////////////////
1:         "org.apache.derby.loc.clientmessages";
commit:daecc5d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
0: import org.apache.derby.shared.common.info.JVMInfo;
1: import org.apache.derby.shared.common.i18n.MessageUtil;
1: import org.apache.derby.shared.common.error.ExceptionUtil;
/////////////////////////////////////////////////////////////////////////
0:     protected static final int DEFAULT_ERRCODE = 99999;
0:     protected String message_ = null;
1:     
0:     public static String CLIENT_MESSAGE_RESOURCE_NAME =
0:         "org.apache.derby.loc.client-messages";
1:     
0:     // The message utility instance we use to find messages
0:     // It's primed with the name of the client message bundle so that
0:     // it knows to look there if the message isn't found in the
0:     // shared message bundle.
0:     private static MessageUtil msgutil_ = 
0:         new MessageUtil(CLIENT_MESSAGE_RESOURCE_NAME);
1:     
1:     // New constructors that support internationalized messages
1:     // The message id is wrapped inside a class so that we can distinguish
1:     // between the signatures of the new constructors and the old constructors
0:     public SqlException(LogWriter logwriter, 
0:         MessageId msgid, Object[] args, Throwable cause)
1:         this(
1:             logwriter,
0:             msgutil_.getCompleteMessage(
1:                 msgid.msgid,
1:                 args),
1:             ExceptionUtil.getSQLStateFromIdentifier(msgid.msgid),
0:             ExceptionUtil.getSeverityFromIdentifier(msgid.msgid));
1:     
0:     public SqlException(LogWriter logwriter, MessageId msgid, Object[] args)
0:     {
0:         this(logwriter, msgid, args, null);
1:     }
1:     
0:     public SqlException (LogWriter logwriter, MessageId msgid)
0:     {
0:         this(logwriter, msgid, null);
1:     }
1:     
0:     public SqlException(LogWriter logwriter, MessageId msgid, Object arg1)
0:     {
0:         this(logwriter, msgid, new Object[] { arg1 });
1:     }
1:     
0:     public SqlException(LogWriter logwriter,
0:         MessageId msgid, Object arg1, Object arg2)
0:     {
0:         this(logwriter, msgid, new Object[] { arg1, arg2 });
1:     }
1:     
0:     public SqlException(LogWriter logwriter,
0:         MessageId msgid, Object arg1, Object arg2, Object arg3)
0:     {
0:         this(logwriter, msgid, new Object[] { arg1, arg2, arg3 });
1:     }
1:     
1:     public SqlException(LogWriter logWriter, Sqlca sqlca) {
0:         this.sqlca_ = sqlca;
1:         if ( logWriter != null )
0:         {
0:             logWriter.traceDiagnosable(this);
1:         }
1:     }
1:     
1:     // Once all messages are internationalized, these methods should become
1:     // private
0:     public SqlException(LogWriter logWriter, String reason, String sqlState,
1:         int errorCode)
0:     {
0:         this(logWriter, null, reason, sqlState, errorCode);
1:     }
0:     private SqlException(LogWriter logWriter, java.lang.Throwable throwable, 
1:         String reason, String sqlState, int errorCode ) {
0:         super(reason, sqlState, errorCode);
1:         message_ = reason;
0:         throwable_ = throwable;
1: 
0:         setCause();
1:         
1:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
1:         }
1:         
1:     }
1:         
0:     protected void setCause()
0:     {
0:         // Store the throwable correctly depending upon its class
0:         // and whether initCause() is available
0:         if (throwable_ != null  )
0:         {
0:             if ( throwable_ instanceof SQLException )
0:             {
0:                 setNextException((SQLException)throwable_);
1:             }
0:             else if ( JVMInfo.JDK_ID >= JVMInfo.J2SE_14 )
0:             {
0:     			initCause(throwable_);
1:             }
0:             else
0:             {
0:                 message_ = message_ + " Caused by exception " + 
0:                     throwable_.getClass() + ": " + throwable_.getMessage();
1: 
1:             }
1:         }
1:     }
1:         
0:     // Constructors for backward-compatibility while we're internationalizng
0:     // all the messages
0:     public SqlException(LogWriter logWriter) {
1:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
1:         }
1:     }
1: 
0:         this(logWriter, reason, null, DEFAULT_ERRCODE);
0:         this(logWriter, throwable, reason, null, DEFAULT_ERRCODE);
0:         this(logWriter, throwable, reason, sqlstate.getState(), DEFAULT_ERRCODE);
0:         this(logWriter, throwable, reason, sqlstate, DEFAULT_ERRCODE);
0:         this(logWriter, reason, sqlState.getState(), DEFAULT_ERRCODE);
0:         this(logWriter, reason, sqlState, DEFAULT_ERRCODE);
0:         this(logWriter, reason, sqlState.getState(), errorCode.getCode());
1:     
0:         this(logWriter, throwable, reason, sqlState.getState(), 
0:             errorCode.getCode());
0:     //--- End backward-compatibility constructors ----------------------
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (sqlca_ != null) {
0:             message_ = ((Sqlca) sqlca_).getJDBCMessage();
0:             return message_;
0:         return batchPositionLabel_ + message_;
/////////////////////////////////////////////////////////////////////////
0:     
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class SqlException extends java.sql.SQLException implements Diagnosable {
0:     java.lang.Throwable throwable_ = null;
0:     protected Sqlca sqlca_ = null; // for engine generated errors only
1:     private String batchPositionLabel_; // for batched exceptions only
1:     //-----------------constructors-----------------------------------------------
0:     public SqlException(LogWriter logWriter, ErrorKey errorKey) {
0:         super(ResourceUtilities.getResource(ResourceKeys.driverOriginationIndicator) +
0:                 ResourceUtilities.getResource(errorKey.getResourceKey()),
0:                 errorKey.getSQLState(),
0:                 errorKey.getErrorCode());
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     public SqlException(LogWriter logWriter, ErrorKey errorKey, Object[] args) {
0:         super(ResourceUtilities.getResource(ResourceKeys.driverOriginationIndicator) +
0:                 ResourceUtilities.getResource(errorKey.getResourceKey(), args),
0:                 errorKey.getSQLState(),
0:                 errorKey.getErrorCode());
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     public SqlException(LogWriter logWriter, ErrorKey errorKey, Object arg) {
0:         this(logWriter, errorKey, new Object[]{arg});
0:     }
0:     public SqlException(LogWriter logWriter, Sqlca sqlca) {
0:         super();
0:         sqlca_ = sqlca;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter) {
0:         super(null, null, -99999);
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
1:     /*
0:     // Temporary constructor until all error keys are defined.
0:     public SQLException (LogWriter logWriter, java.lang.Throwable throwable)
0:     {
0:       super ();
0:       throwable_ = throwable;
0:       if (logWriter != null) logWriter.traceDiagnosable (this);
0:     }
0:     */
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, String reason) {
0:         super(reason, null, -99999);
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, String reason) {
0:         super(reason, null, -99999);
0:         throwable_ = throwable;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, String reason, SqlState sqlstate) {
0:         super(reason, sqlstate.getState(), -99999);
0:         throwable_ = throwable;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined, for subsystem use only.
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, String reason, String sqlstate) {
0:         super(reason, sqlstate, -99999);
0:         throwable_ = throwable;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, String reason, SqlState sqlState) {
0:         super(reason, sqlState.getState(), -99999);
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined, for subsystem use only.
0:     public SqlException(LogWriter logWriter, String reason, String sqlState) {
0:         super(reason, sqlState, -99999);
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, String reason, SqlState sqlState, SqlCode errorCode) {
0:         super(reason, (sqlState == null) ? null : sqlState.getState(), errorCode.getCode());
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined, for subsystem use only.
0:     public SqlException(LogWriter logWriter, String reason, String sqlState, int errorCode) {
0:         super(reason, sqlState, errorCode);
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined.
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, String reason, SqlState sqlState, SqlCode errorCode) {
0:         super(reason, sqlState.getState(), errorCode.getCode());
0:         throwable_ = throwable;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
0:     // Temporary constructor until all error keys are defined, for subsystem use only.
0:     public SqlException(LogWriter logWriter, java.lang.Throwable throwable, String reason, String sqlState, int errorCode) {
0:         super(reason, sqlState, errorCode);
0:         throwable_ = throwable;
0:         if (logWriter != null) {
0:             logWriter.traceDiagnosable(this);
0:         }
0:     }
1:     // Label an exception element in a batched update exception chain.
1:     // This text will be prepended onto the exceptions message text dynamically
1:     // when getMessage() is called.
1:     // Called by the Agent.
1:     void setBatchPositionLabel(int index) {
0:         batchPositionLabel_ = "Error for batch element #" + index + ": ";
0:     }
1:     public Sqlca getSqlca() {
1:         return sqlca_;
0:     }
0:     public java.lang.Throwable getThrowable() {
0:         return throwable_;
0:     }
1:     public String getMessage() {
0:         String message;
0:         if (sqlca_ == null) {
0:             message = super.getMessage();
1:         } else {
0:             message = ((Sqlca) sqlca_).getJDBCMessage();
0:         }
0:         if (batchPositionLabel_ == null) {
0:             return message;
0:         }
0:         return batchPositionLabel_ + message;
0:     }
1:     public String getSQLState() {
0:         if (sqlca_ == null) {
0:             return super.getSQLState();
1:         } else {
0:             return sqlca_.getSqlState();
0:         }
0:     }
1:     public int getErrorCode() {
0:         if (sqlca_ == null) {
0:             return super.getErrorCode();
1:         } else {
0:             return sqlca_.getSqlCode();
0:         }
0:     }
0:     public void printTrace(java.io.PrintWriter printWriter, String header) {
0:         ExceptionFormatter.printTrace(this, printWriter, header);
0:     }
0: 
1:     // Return a single SQLException without the "next" pointing to another SQLException.
1:     // Because the "next" is a private field in java.sql.SQLException,
1:     // we have to create a new SqlException in order to break the chain with "next" as null.
1:     SqlException copyAsUnchainedSQLException(LogWriter logWriter) {
1:         if (sqlca_ != null) {
0:             return new SqlException(logWriter, sqlca_); // server error
1:         } else {
1:             return new SqlException(logWriter, getMessage(), getSQLState(), getErrorCode()); // client error
0:         }
0:     }
0: 
0: class ColumnIndexOutOfBoundsException extends SqlException {
0:     ColumnIndexOutOfBoundsException(LogWriter logWriter, Throwable throwable, int resultSetColumn) {
0:         super(logWriter, throwable,
0:                 "Invalid argument:" +
0:                 " Result column index " + resultSetColumn + " is out of range.");
0:     }
0: 
0: class NumberFormatConversionException extends SqlException {
0:     NumberFormatConversionException(LogWriter logWriter, String instance) {
1:         super(logWriter,
0:                 "Invalid data conversion:" +
0:                 " Result column instance " +
0:                 instance +
0:                 " is either an invalid numeric representation" +
0:                 " or is out of range.");
0:     }
0: 
1: class ColumnTypeConversionException extends SqlException {
0:     ColumnTypeConversionException(LogWriter logWriter) {
1:         super(logWriter,
0:                 "Invalid data conversion:" +
0:                 " Wrong result column type for requested conversion.");
0:     }
0: 
0: class LossOfPrecisionConversionException extends SqlException {
0:     LossOfPrecisionConversionException(LogWriter logWriter, String instance) {
1:         super(logWriter,
0:                 "Invalid data conversion:" +
0:                 "Requested conversion would result in a loss of precision of " +
0:                 instance);
0:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derby.client.am.SqlException
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: */
0: 
1: package org.apache.derby.client.am;
0: 
0: import org.apache.derby.client.resources.ResourceKeys;
0: 
0: 
1: // The signature of the stored procedure SQLCAMessage I have come out so far is as follows:
1: // SQLCAMessage (
1: //     IN  SQLCode       INTEGER,
1: //     IN  SQLErrml      SMALLINT,
1: //     IN  SQLErrmc      VARCHAR(70),
1: //     IN  SQLErrp       CHAR(8),
1: //     IN  SQLErrd0      INTEGER,
1: //     IN  SQLErrd1      INTEGER,
1: //     IN  SQLErrd2      INTEGER,
1: //     IN  SQLErrd3      INTEGER,
1: //     IN  SQLErrd4      INTEGER,
1: //     IN  SQLErrd5      INTEGER,
1: //     IN  SQLWarn       CHAR(11),
1: //     IN  SQLState      CHAR(5),
1: //     IN  Locale        CHAR(5),
1: //     IN  BufferSize    SMALLINT,
1: //     IN  LineWidth     SMALLINT,
1: //     OUT Message       VARCHAR(2400))
1: //
1: // Some issues have been identified:
1: // 1. What would be the schema name of the stored procedue SQLCAMessage?
1: // 2. What is the format and type of the Locale parameter? If there does, I would really like to know the format of the locale in order to decide the type of the Locale parameter. Even there does not either, the Locale parameter probably still needs to be kept there for future extension, and we need to figure out the format of the locale.
1: // 3. What would be the format of the output message? Is this full message text ok or do we only need the explanation message corresponding to an SQL code. This somehow matters whether we need the Buffersize and Linewidth parameters for the stored procedure.
1: // 4. What if the invocation of stored procedure failed (due to, eg, connection dropping)? In this case, we probably need to return some client-side message.
0: public class SqlException extends java.sql.SQLException implements Diagnosable
0: {
0:   java.lang.Throwable throwable_ = null;
0:   protected Sqlca sqlca_ = null; // for engine generated errors only
0:   private String batchPositionLabel_; // for batched exceptions only
0: 
0:   //-----------------constructors-----------------------------------------------
0: 
0:   public SqlException (LogWriter logWriter, ErrorKey errorKey)
0:   {
0:     super (ResourceUtilities.getResource (ResourceKeys.driverOriginationIndicator) +
0:            ResourceUtilities.getResource (errorKey.getResourceKey()),
0:            errorKey.getSQLState(),
0:            errorKey.getErrorCode());
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   public SqlException (LogWriter logWriter, ErrorKey errorKey, Object[] args)
0:   {
0:     super (ResourceUtilities.getResource (ResourceKeys.driverOriginationIndicator) +
0:            ResourceUtilities.getResource (errorKey.getResourceKey(), args),
0:            errorKey.getSQLState(),
0:            errorKey.getErrorCode());
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   public SqlException (LogWriter logWriter, ErrorKey errorKey, Object arg)
0:   {
0:     this (logWriter, errorKey, new Object[] {arg});
0:   }
0: 
0:   public SqlException (LogWriter logWriter, Sqlca sqlca)
0:   {
0:     super ();
0:     sqlca_ = sqlca;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter)
0:   {
0:     super (null, null, -99999);
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   /*
0:   // Temporary constructor until all error keys are defined.
0:   public SQLException (LogWriter logWriter, java.lang.Throwable throwable)
0:   {
0:     super ();
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0:   */
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, String reason)
0:   {
0:     super (reason, null, -99999);
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, java.lang.Throwable throwable, String reason)
0:   {
0:     super (reason, null, -99999);
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, java.lang.Throwable throwable, String reason, SqlState sqlstate)
0:   {
0:     super (reason, sqlstate.getState(), -99999);
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined, for subsystem use only.
0:   public SqlException (LogWriter logWriter, java.lang.Throwable throwable, String reason, String sqlstate)
0:   {
0:     super (reason, sqlstate, -99999);
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, String reason, SqlState sqlState)
0:   {
0:     super (reason, sqlState.getState(), -99999);
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined, for subsystem use only.
0:   public SqlException (LogWriter logWriter, String reason, String sqlState)
0:   {
0:     super (reason, sqlState, -99999);
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, String reason, SqlState sqlState, SqlCode errorCode)
0:   {
0:     super (reason, (sqlState == null) ? null : sqlState.getState(), errorCode.getCode());
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined, for subsystem use only.
0:   public SqlException (LogWriter logWriter, String reason, String sqlState, int errorCode)
0:   {
0:     super (reason, sqlState, errorCode);
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined.
0:   public SqlException (LogWriter logWriter, java.lang.Throwable throwable, String reason, SqlState sqlState, SqlCode errorCode)
0:   {
0:     super (reason, sqlState.getState(), errorCode.getCode());
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Temporary constructor until all error keys are defined, for subsystem use only.
0:   public SqlException (LogWriter logWriter, java.lang.Throwable throwable, String reason, String sqlState, int errorCode)
0:   {
0:     super (reason, sqlState, errorCode);
0:     throwable_ = throwable;
0:     if (logWriter != null) logWriter.traceDiagnosable (this);
0:   }
0: 
0:   // Label an exception element in a batched update exception chain.
0:   // This text will be prepended onto the exceptions message text dynamically
0:   // when getMessage() is called.
0:   // Called by the Agent.
0:   void setBatchPositionLabel (int index)
0:   {
0:     batchPositionLabel_ = "Error for batch element #" + index + ": ";
0:   }
0: 
0:   public Sqlca getSqlca ()
0:   {
0:     return sqlca_;
0:   }
0: 
0:   public java.lang.Throwable getThrowable ()
0:   {
0:     return throwable_;
0:   }
0: 
0:   public String getMessage ()
0:   {
0:     String message;
0: 
0:     if (sqlca_ == null)
0:       message = super.getMessage();
0:     else
0:       message = ((Sqlca) sqlca_).getJDBCMessage();
0: 
0:     if (batchPositionLabel_ == null)
0:       return message;
0: 
0:     return batchPositionLabel_ + message;
0:   }
0: 
0:   public String getSQLState ()
0:   {
0:     if (sqlca_ == null)
0:       return super.getSQLState();
0:     else
0:       return sqlca_.getSqlState();
0:   }
0: 
0:   public int getErrorCode ()
0:   {
0:     if (sqlca_ == null)
0:       return super.getErrorCode();
0:     else
0:       return sqlca_.getSqlCode();
0:   }
0: 
0:   public void printTrace (java.io.PrintWriter printWriter, String header)
0:   {
0:     ExceptionFormatter.printTrace (this, printWriter, header);
0:   }
0: 
0:   // Return a single SQLException without the "next" pointing to another SQLException.
0:   // Because the "next" is a private field in java.sql.SQLException,
0:   // we have to create a new SqlException in order to break the chain with "next" as null.
0:   SqlException copyAsUnchainedSQLException (LogWriter logWriter)
0:   {
0:     if (sqlca_ != null)
0:       return new SqlException (logWriter, sqlca_); // server error
0:     else
0:       return new SqlException (logWriter, getMessage(), getSQLState(), getErrorCode()); // client error
0:   }
0: }
0: 
1: // An intermediate exception encapsulation to provide code-reuse
0: // for common ResultSet and ResultSetMetaData column access exceptions.
0: class ColumnIndexOutOfBoundsException extends SqlException
0: {
0:   ColumnIndexOutOfBoundsException (LogWriter logWriter, Throwable throwable, int resultSetColumn)
0:   {
0:     super (logWriter, throwable,
0:            "Invalid argument:" +
0:            " Result column index " + resultSetColumn + " is out of range.");
0:   }
0: }
0: 
1: // An intermediate exception encapsulation to provide code-reuse
1: // for common ResultSet data conversion exceptions.
0: class NumberFormatConversionException extends SqlException
0: {
0:   NumberFormatConversionException (LogWriter logWriter, String instance)
0:   {
0:     super (logWriter,
0:             "Invalid data conversion:" +
0:            " Result column instance " +
0:            instance +
0:            " is either an invalid numeric representation" +
0:            " or is out of range.");
0:   }
0: }
0: 
1: // An intermediate exception encapsulation to provide code-reuse
1: // for common ResultSet data conversion exceptions.
0: class ColumnTypeConversionException extends SqlException
0: {
0:   ColumnTypeConversionException (LogWriter logWriter)
0:   {
0:     super (logWriter,
0:            "Invalid data conversion:" +
0:            " Wrong result column type for requested conversion.");
0:   }
0: }
0: 
1: // An intermediate exception encapsulation to provide code-reuse
1: // for common CrossConverters data conversion exceptions.
0: class LossOfPrecisionConversionException extends SqlException
0: {
0:   LossOfPrecisionConversionException (LogWriter logWriter, String instance)
0:   {
0:     super (logWriter,
0:            "Invalid data conversion:" +
0:            "Requested conversion would result in a loss of precision of " +
0:            instance);
0:   }
0: }
============================================================================