1:b9dfa64: /*
1:ab8e485: * Licensed to the Apache Software Foundation (ASF) under one or more
1:ab8e485: * contributor license agreements.  See the NOTICE file distributed with
1:ab8e485: * this work for additional information regarding copyright ownership.
1:ab8e485: * The ASF licenses this file to you under the Apache License, Version 2.0
1:ab8e485: * (the "License"); you may not use this file except in compliance with
1:ab8e485: * the License.  You may obtain a copy of the License at
1:ab8e485: *
1:ab8e485: *     http://www.apache.org/licenses/LICENSE-2.0
1:ab8e485: *
1:ab8e485: * Unless required by applicable law or agreed to in writing, software
1:ab8e485: * distributed under the License is distributed on an "AS IS" BASIS,
1:ab8e485: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ab8e485: * See the License for the specific language governing permissions and
1:ab8e485: * limitations under the License.
1:ab8e485: */
1:c8208e1: 
1:c8208e1: 
1:b9dfa64: package org.apache.derbyTesting.functionTests.tests.lang;
1:b1397ec: 
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:b1397ec: import java.util.Random;
1:b1397ec: import junit.framework.Test;
1:b1397ec: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:b1397ec: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:c8208e1: 
1:b9dfa64: 
1:b9dfa64: // This test tries to push byte code generation to the limit.
1:209ff61: // It has to be run with a large amount of memory which is set with jvmflags in 
1:209ff61: // largeCodeGen_app.properties
1:209ff61: // There are only a few types of cases now. Other areas need to be tested such as large in clauses, etc.
1:209ff61: // 
1:b9dfa64: 
1:b1397ec: public class largeCodeGen extends BaseJDBCTestCase
1:c8208e1: {
1:7ab414c: 	private static boolean TEST_QUERY_EXECUTION = true;
1:b1397ec:     
1:b1397ec:    
1:b1397ec:     
1:b1397ec:     public largeCodeGen(String name)
1:b9dfa64:     {
1:b1397ec:         super(name);
1:b9dfa64:     }
1:b9dfa64:     
1:b1397ec:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:b1397ec:         
1:b1397ec:         // Code generation test, just invoke on embedded
1:b1397ec:         // as the main function is to test the byte code compiler.
1:b1397ec:         if (usingEmbedded()) {
1:b1397ec:             suite.addTestSuite(largeCodeGen.class);
1:b1397ec:             return new CleanDatabaseTestSetup(suite);
1:b1397ec:         }
1:b1397ec:         return suite;
1:b1397ec:     }
1:b1397ec:        
1:b1397ec:     protected void setUp() throws SQLException
1:b9dfa64:     {
1:03a99e2:         getConnection().setAutoCommit(false);
1:b1397ec:     	Statement stmt = createStatement();
1:b9dfa64: 		
1:209ff61: 		String createSQL = 	"create table t0 " +
1:b9dfa64: 		"(si smallint,i int, bi bigint, r real, f float, d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), ch20 char(3),vc varchar(20), lvc long varchar)";
1:b9dfa64: 		stmt.executeUpdate(createSQL);	
1:209ff61: 		stmt.executeUpdate("insert into t0 values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')");
1:b1397ec:         stmt.close();
1:b1397ec:         commit();
1:b1397ec:     }
1:b1397ec:     
1:b1397ec:     protected void tearDown() throws Exception
1:b1397ec:     {
1:b1397ec:         Statement stmt = createStatement();
1:b1397ec:         stmt.execute("DROP TABLE T0");
1:b1397ec:         stmt.close();
1:b1397ec:         commit();
1:b1397ec:         super.tearDown();
7:209ff61:     }
1:b9dfa64:     
1:b9dfa64:     
1:7ab414c: 	/**
1:7ab414c: 	 * Prepares and executes query against table t0 with n parameters
1:7ab414c: 	 * The assumption is that the query will always return our one row
1:7ab414c: 	 * of data inserted into the t0 table.
1:7ab414c: 	 * 
1:7ab414c: 	 * @param testName
1:7ab414c: 	 * @param sqlBuffer  - StringBuffer with SQL Text
1:7ab414c: 	 * @param numParams  - Number of parameters
1:7ab414c: 	 * @param paramValue - Parameter value
1:7ab414c: 	 * @return true if the check fails
1:b9dfa64: 	 */
1:b1397ec: 	private boolean checkT0Query(String testName, 
1:7ab414c: 				StringBuffer sqlBuffer, int numParams, int paramValue) {
1:7ab414c: 		PreparedStatement ps;
3:b9dfa64: 		try {
1:b1397ec: 			ps = prepareStatement(sqlBuffer.toString());
1:7ab414c: 			if (TEST_QUERY_EXECUTION)
1:b9dfa64: 			{
1:7ab414c: 				for (int i = 1; i <= numParams; i++)
1:b9dfa64: 				{	
1:7ab414c: 					ps.setInt(i, paramValue);
1:b9dfa64: 				}
1:7ab414c: 				ResultSet rs = ps.executeQuery();
1:7ab414c: 				rs.next();
1:b9dfa64: 				checkRowData(rs);
1:7ab414c: 				rs.close();
1:b9dfa64: 			}
2:c8208e1: 			ps.close();
1:b1397ec:             commit();
1:c8208e1: 			return false;
1:b1397ec: 		}catch (SQLException e)
1:b9dfa64: 		{
1:b1397ec:             // The top level exception is expected to be
1:b1397ec:             // the "user-friendly" query is too complex
1:b1397ec:             // rather than some linkage error.
1:d5fba93:             assertSQLState("42ZA0", e);
1:c8208e1: 			return true;
1:b9dfa64: 			
1:b9dfa64: 		}
1:7ab414c: 	}
1:b9dfa64: 
1:7ab414c: 	/**
1:b1397ec:      * Test many logical operators in the where clause.  
1:7ab414c: 	 */
1:b1397ec: 	public void testLogicalOperators()  throws SQLException {
1:b9dfa64: 		 
1:b1397ec:        int passCount = 0;
1:b1397ec: 		 for (int count = 700; count <= 10000 ; count += 100)
1:c8208e1: 		 {
1:b1397ec: 			 // keep testing until it fails
1:b1397ec: 			 if (logicalOperators(count))
1:c8208e1: 				 break;
1:b1397ec:              
1:b1397ec:              passCount = count;
1:c8208e1: 		 }
1:b1397ec:          
1:b1397ec:         // svn 372388 trunk - passed @ 400
1:b1397ec:         // Fix to DERBY-921 - passed @ 800
1:b1397ec:         // DERBY-921 - support 32bit branch offsets
1:b1397ec:         assertEquals("logical operators change from previous limit",
1:b1397ec:                 800, passCount);
1:b1397ec:         
1:b1397ec:      
1:7ab414c: 		 // 10,000 causes Stack overflow and database corruption
1:7ab414c: 		 //testLogicalOperators(con, 10000);
1:7ab414c: 	}
1:b9dfa64: 
1:b9dfa64: 	
2:209ff61: 	/**
1:209ff61: 	 * Tests numParam parameter markers in a where clause
1:209ff61: 	 * 
1:7ab414c: 	 * @param  numOperands 
2:209ff61: 	 */
1:b1397ec: 	private boolean logicalOperators(int numOperands) throws SQLException {
1:b9dfa64: 		
1:7ab414c: 		// First with parameters
1:7ab414c: 		String pred =  "(si = ? AND si = ? )";
1:7ab414c: 		String testName = "Logical operators with " + numOperands + " parameters";
1:7ab414c: 		StringBuffer sqlBuffer = new StringBuffer((numOperands * 20) + 512);
1:7ab414c: 		sqlBuffer.append("SELECT * FROM T0 WHERE " + pred );
1:7ab414c: 		for (int i = 2; i < numOperands; i+=2)
1:b9dfa64: 		{
1:7ab414c: 			sqlBuffer.append(" OR " + pred);
1:7ab414c: 		}
1:b1397ec: 		return checkT0Query(testName, sqlBuffer, numOperands, 2);
1:b9dfa64: 		
1:b9dfa64: 		
1:b9dfa64: 		
1:7ab414c: 		
1:7ab414c: 	}
1:7ab414c: 	
1:b1397ec: 	public void testInClause()  throws SQLException {
1:7ab414c: 	  
1:7ab414c: 		// DERBY-739 raised number of parameters from 2700 to 3400
1:8b4c5e1:         // svn 372388 trunk - passed @ 3400
1:b1397ec:         // So perform a quick check there.
1:b1397ec:         assertFalse("IN clause with 3400 parameters ", inClause(3400));
1:b1397ec:         
1:b1397ec:         int passCount = 0;
1:ee1cc94: 		 for (int count = 97000; count <= 200000 ; count += 1000)
3:7ab414c: 		 {
1:b1397ec:  			 // keep testing until it fails.
1:b1397ec: 			 if (inClause(count))
1:c8208e1: 			 	break;
1:b1397ec:              passCount = count;
1:c8208e1: 		 }
1:b1397ec:          
1:b1397ec:         // fixes for DERBY-766 to split methods with individual statements
1:b1397ec:         // bumps the limit to 98,000 parameters.
1:b1397ec:         assertEquals("IN clause change from previous limit", 98000, passCount);
1:c8208e1: 	}	
1:7ab414c: 	
1:7ab414c: 	/**
1:7ab414c: 	 * Test in clause with many parameters
1:7ab414c: 	 *
1:df4020d: 	 * @param numParams Number of parameters to test
1:7ab414c: 	 * @return true if the test fails
1:7ab414c: 	 * @throws SQLException
1:7ab414c: 	 */
1:b1397ec: 	private boolean inClause(int numParams) throws SQLException {
1:c8208e1: 		String testName = "IN clause with " + numParams + " parameters";
2:c8208e1: 		StringBuffer sqlBuffer = new StringBuffer((numParams * 20) + 512);
1:7ab414c: 		sqlBuffer.append("SELECT * FROM T0 WHERE SI IN ("  );
1:c8208e1: 		for (int i = 1; i < numParams; i++)
1:c8208e1: 		{
1:c8208e1: 			sqlBuffer.append("?, ");
1:c8208e1: 		}
1:c8208e1: 		sqlBuffer.append("?)");
1:b1397ec: 		return checkT0Query(testName, sqlBuffer, numParams, 2); 	
1:c8208e1: 	}
1:c8208e1: 	
1:b1397ec: 	public void testUnions() throws SQLException
1:b1397ec: 	{ 		
1:b9dfa64: 		String viewName = "v0";		
1:b1397ec: 		Statement stmt = createStatement();
1:b1397ec:         
1:b9dfa64: 		StringBuffer createView = new StringBuffer("create view " + viewName + 
1:209ff61: 												   " as select * from t0 " );
1:b9dfa64: 		for (int i = 1; i < 100; i ++)
1:c8208e1: 		{
1:209ff61: 			createView.append(" UNION ALL (SELECT * FROM t0 )");
1:c8208e1: 		}
1:b9dfa64: 		//System.out.println(createViewString);
1:b9dfa64: 		stmt.executeUpdate(createView.toString());
1:b1397ec:         commit();
1:c8208e1: 		
1:b1397ec:        int passCount = 0;
1:b1397ec: 		for (int count = 1000; count <= 1000; count += 1000)
1:c8208e1: 		{
1:b1397ec:  			// keep testing until it fails
1:b1397ec: 			if (largeUnionSelect(viewName, count))
1:c8208e1: 				break;
1:b1397ec:             passCount = count;
1:b1397ec:            
1:c8208e1: 		}
1:b1397ec:         
1:b1397ec:         // 10000 gives a different constant pool error
1:b1397ec:         // DERBY-1315 gives out of memory error.
1:b1397ec:         //assertTrue("10000 UNION passed!",
1:b1397ec:         //        largeUnionSelect(viewName, 10000));
1:b1397ec: 
1:b1397ec:         createStatement().executeUpdate("DROP VIEW " + viewName);
1:b1397ec: 
1:b1397ec:         // svn 372388 trunk - passed @ 900
1:b1397ec:         // trunk now back to 700
1:b1397ec:         //
1:b1397ec:         assertEquals("UNION operators change from previous limit",
1:b1397ec:                 1000, passCount);
1:b1397ec:         
1:b1397ec:         
1:b9dfa64:     }
1:c8208e1:     
1:b1397ec:     private boolean largeUnionSelect(String viewName,
1:b1397ec:     		int numUnions) throws SQLException
1:b9dfa64: 	{
1:b9dfa64: 
1:209ff61:     	// There are 100 unions in each view so round to the nearest 100
1:c8208e1: 		
1:c8208e1: 		String unionClause = " UNION ALL (SELECT * FROM " + viewName + ")";
1:c8208e1: 
1:c8208e1: 		StringBuffer selectSQLBuffer  =
1:c8208e1: 			new StringBuffer(((numUnions/100) * unionClause.length()) + 512);
1:c8208e1: 		
1:c8208e1: 		selectSQLBuffer.append("select * from t0 ");
1:c8208e1: 		
1:b9dfa64: 		for (int i = 1; i < numUnions/100;i++)
1:b9dfa64: 		{
1:c8208e1: 			selectSQLBuffer.append(unionClause);
1:b9dfa64: 		}	
1:b9dfa64: 		
1:c8208e1: 		try {
1:b9dfa64: 		// Ready to execute the problematic query 
1:b9dfa64: 		String selectSQL = selectSQLBuffer.toString();
1:b9dfa64: 		//System.out.println(selectSQL);
1:b1397ec:         PreparedStatement pstmt = prepareStatement(selectSQL);
1:8b4c5e1:         if (largeCodeGen.TEST_QUERY_EXECUTION)
1:8b4c5e1:         {
1:8b4c5e1: 	        ResultSet rs = pstmt.executeQuery();
1:8b4c5e1: 			int numRows = 0;
1:8b4c5e1: 			while (rs.next())
1:8b4c5e1: 			{
1:8b4c5e1: 				numRows++;
1:8b4c5e1: 				if ((numRows % 100) == 0)
1:8b4c5e1: 				checkRowData(rs);
1:8b4c5e1: 			}
1:b1397ec:             rs.close();
1:b1397ec: 	        commit();
1:8b4c5e1:         }
1:b9dfa64:         pstmt.close();
1:c8208e1:         return false;
1:b9dfa64:      
1:b9dfa64: 		} catch (SQLException sqle)
1:b9dfa64: 		{
1:b1397ec:             // The top level exception is expected to be
1:b1397ec:             // the "user-friendly" query is too complex
1:b1397ec:             // rather than some linkage error.
1:d5fba93:             assertSQLState("42ZA0", sqle);
1:b1397ec: 
1:c8208e1: 			return true;
1:b9dfa64: 			
1:b9dfa64: 		}
1:b9dfa64: 
1:b9dfa64:       }
1:b9dfa64: 
1:b9dfa64: 	// Check the data on the positioned row against what we inserted.
1:b1397ec: 	private static void checkRowData(ResultSet rs) throws SQLException
1:b9dfa64: 	{
1:b9dfa64: 		//" values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')");
1:b9dfa64: 		String[] values = {"2", "3", "4", "5.3","5.3","5.3","31.13","123456.123",
1:b9dfa64: 						   "one","one","one"};
1:b9dfa64: 		for (int i = 1; i <= 11; i ++)
1:b9dfa64: 		{
1:b1397ec:             assertEquals("Result set data value: ",
1:b1397ec:                     values[i-1], rs.getString(i));
1:b9dfa64: 		}
1:b9dfa64: 	}
1:b1397ec:     
1:b1397ec:     /**
1:b1397ec:      * Test an INSERT statement with a large number of rows in the VALUES clause.
1:b1397ec:      * Reported as DERBY-1714.
1:b1397ec:      * @throws SQLException 
1:b1397ec:      *
1:b1397ec:      */
1:b1397ec:     public void testInsertValues() throws SQLException {
1:b1397ec:        int passCount = 0;
1:b1397ec:         for (int count = 1500; count <= 1700; count += 200) {
1:b1397ec:             // keep testing until it fails
1:b1397ec:             if (insertValues(count))
1:b1397ec:                 break;
1:b1397ec:             passCount = count;
1:b1397ec: 
1:b1397ec:         }
1:b9dfa64: 
1:b1397ec:         // Final fixes for DERBY-766 pushed the limit to 1700
1:b1397ec:         // Beyond that a StackOverflow occurs.
1:b1397ec:         assertEquals("INSERT VALUES change from previous limit", 1700, passCount);
1:b1397ec:     }
1:b1397ec: 
1:b1397ec:     /**
1:b1397ec:      * Create a large insert statement with rowCount rows all with
1:b1397ec:      * constants. Prepare and execute it and then rollback to leave
1:b1397ec:      * the table unchanged.
1:b1397ec:      * @param rowCount
1:df4020d:      * @return false if rollback succeeds, otherwise true
1:b1397ec:      * @throws SQLException
1:b1397ec:      */
1:b1397ec:     private boolean insertValues(int rowCount) throws SQLException {
1:b1397ec:         Random r = new Random(3457245435L);
1:b1397ec: 
1:b1397ec:         StringBuffer insertSQL = new StringBuffer(
1:b1397ec:                 "INSERT INTO T0(SI,I,BI,R,F,D,N5_2,DEC10_3,CH20,VC,LVC) VALUES\n");
1:b1397ec: 
1:b1397ec:         for (int i = 0; i < rowCount; i++) {
1:b1397ec:             if (i != 0)
1:b1397ec:                 insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append('(');
1:b1397ec: 
1:b1397ec:             insertSQL.append(((short) r.nextInt()));
1:b1397ec:             insertSQL.append(',');
1:b1397ec:             insertSQL.append(i);
1:b1397ec:             insertSQL.append(',');
1:b1397ec:             insertSQL.append(r.nextLong());
1:b1397ec:             insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append(r.nextFloat());
1:b1397ec:             insertSQL.append(',');
1:b1397ec:             insertSQL.append(r.nextFloat());
1:b1397ec:             insertSQL.append(',');
1:b1397ec:             insertSQL.append(r.nextDouble());
1:b1397ec:             insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append("462.54");
1:b1397ec:             insertSQL.append(',');
1:b1397ec:             insertSQL.append("9324324.34");
1:b1397ec:             insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append('\'');
1:b1397ec:             insertSQL.append("c");
1:b1397ec:             insertSQL.append(r.nextInt() % 10);
1:b1397ec:             insertSQL.append('\'');
1:b1397ec:             insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append('\'');
1:b1397ec:             insertSQL.append("vc");
1:b1397ec:             insertSQL.append(r.nextInt() % 1000000);
1:b1397ec:             insertSQL.append('\'');
1:b1397ec:             insertSQL.append(',');
1:b1397ec: 
1:b1397ec:             insertSQL.append('\'');
1:b1397ec:             insertSQL.append("lvc");
1:b1397ec:             insertSQL.append(r.nextInt());
1:b1397ec:             insertSQL.append('\'');
1:b1397ec: 
1:b1397ec:             insertSQL.append(')');
1:b1397ec: 
1:b1397ec:             insertSQL.append('\n');
1:b1397ec:         }
1:b1397ec: 
1:b1397ec:         try {
1:b1397ec:             PreparedStatement ps = prepareStatement(insertSQL.toString());
1:b1397ec:             assertEquals("Incorrect update count", rowCount, ps.executeUpdate());
1:b1397ec:             ps.close();
1:b1397ec:             rollback();
1:b1397ec:             return false;
1:b1397ec:         } catch (SQLException e) {
1:b1397ec:             // The top level exception is expected to be
1:b1397ec:             // the "user-friendly" query is too complex
1:b1397ec:             // rather than some linkage error.
1:d5fba93:             assertSQLState("42ZA0", e);
1:b1397ec:         }
1:b1397ec: 
1:b1397ec:         return true;
1:b1397ec:     }
1:b9dfa64: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1: 	 * @param numParams Number of parameters to test
/////////////////////////////////////////////////////////////////////////
1:      * @return false if rollback succeeds, otherwise true
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d5fba93
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("42ZA0", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("42ZA0", sqle);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("42ZA0", e);
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
commit:b1397ec
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1: public class largeCodeGen extends BaseJDBCTestCase
1:     
1:    
1:     
1:     public largeCodeGen(String name)
1:         super(name);
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         
1:         // Code generation test, just invoke on embedded
1:         // as the main function is to test the byte code compiler.
1:         if (usingEmbedded()) {
1:             suite.addTestSuite(largeCodeGen.class);
1:             return new CleanDatabaseTestSetup(suite);
1:         }
1:         return suite;
1:     }
1:        
1:     protected void setUp() throws SQLException
0:         getXConnection().setAutoCommit(false);
1:     	Statement stmt = createStatement();
1:         stmt.close();
1:         commit();
1:     }
1:     
1:     protected void tearDown() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         stmt.execute("DROP TABLE T0");
1:         stmt.close();
1:         commit();
1:         super.tearDown();
/////////////////////////////////////////////////////////////////////////
1: 	private boolean checkT0Query(String testName, 
1: 			ps = prepareStatement(sqlBuffer.toString());
/////////////////////////////////////////////////////////////////////////
1:             commit();
1: 		}catch (SQLException e)
1:             // The top level exception is expected to be
1:             // the "user-friendly" query is too complex
1:             // rather than some linkage error.
0:             JDBC.assertSQLState("42ZA0", e);
1:      * Test many logical operators in the where clause.  
1: 	public void testLogicalOperators()  throws SQLException {
1:        int passCount = 0;
1: 		 for (int count = 700; count <= 10000 ; count += 100)
1: 			 // keep testing until it fails
1: 			 if (logicalOperators(count))
1:              
1:              passCount = count;
1:          
1:         // svn 372388 trunk - passed @ 400
1:         // Fix to DERBY-921 - passed @ 800
1:         // DERBY-921 - support 32bit branch offsets
1:         assertEquals("logical operators change from previous limit",
1:                 800, passCount);
1:         
1:      
/////////////////////////////////////////////////////////////////////////
1: 	private boolean logicalOperators(int numOperands) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 		return checkT0Query(testName, sqlBuffer, numOperands, 2);
1: 	public void testInClause()  throws SQLException {
1:         // So perform a quick check there.
1:         assertFalse("IN clause with 3400 parameters ", inClause(3400));
1:         
1:         int passCount = 0;
1:  			 // keep testing until it fails.
1: 			 if (inClause(count))
1:              passCount = count;
1:          
1:         // fixes for DERBY-766 to split methods with individual statements
1:         // bumps the limit to 98,000 parameters.
1:         assertEquals("IN clause change from previous limit", 98000, passCount);
/////////////////////////////////////////////////////////////////////////
1: 	private boolean inClause(int numParams) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 		return checkT0Query(testName, sqlBuffer, numParams, 2); 	
1: 	public void testUnions() throws SQLException
1: 	{ 		
1: 		Statement stmt = createStatement();
1:         
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:        int passCount = 0;
1: 		for (int count = 1000; count <= 1000; count += 1000)
1:  			// keep testing until it fails
1: 			if (largeUnionSelect(viewName, count))
1:             passCount = count;
1:            
1:         
1:         // 10000 gives a different constant pool error
1:         // DERBY-1315 gives out of memory error.
1:         //assertTrue("10000 UNION passed!",
1:         //        largeUnionSelect(viewName, 10000));
1: 
1:         createStatement().executeUpdate("DROP VIEW " + viewName);
1: 
1:         // svn 372388 trunk - passed @ 900
1:         // trunk now back to 700
1:         //
1:         assertEquals("UNION operators change from previous limit",
1:                 1000, passCount);
1:         
1:         
1:     private boolean largeUnionSelect(String viewName,
1:     		int numUnions) throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement pstmt = prepareStatement(selectSQL);
/////////////////////////////////////////////////////////////////////////
1:             rs.close();
1: 	        commit();
1:             // The top level exception is expected to be
1:             // the "user-friendly" query is too complex
1:             // rather than some linkage error.
0:             JDBC.assertSQLState("42ZA0", sqle);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	private static void checkRowData(ResultSet rs) throws SQLException
1:             assertEquals("Result set data value: ",
1:                     values[i-1], rs.getString(i));
1:     
1:     /**
1:      * Test an INSERT statement with a large number of rows in the VALUES clause.
1:      * Reported as DERBY-1714.
1:      * @throws SQLException 
1:      *
1:      */
1:     public void testInsertValues() throws SQLException {
1:        int passCount = 0;
1:         for (int count = 1500; count <= 1700; count += 200) {
1:             // keep testing until it fails
1:             if (insertValues(count))
1:                 break;
1:             passCount = count;
1:         }
1: 
1:         // Final fixes for DERBY-766 pushed the limit to 1700
1:         // Beyond that a StackOverflow occurs.
1:         assertEquals("INSERT VALUES change from previous limit", 1700, passCount);
1:     }
1: 
1:     /**
1:      * Create a large insert statement with rowCount rows all with
1:      * constants. Prepare and execute it and then rollback to leave
1:      * the table unchanged.
1:      * @param rowCount
0:      * @return
1:      * @throws SQLException
1:      */
1:     private boolean insertValues(int rowCount) throws SQLException {
1:         Random r = new Random(3457245435L);
1: 
1:         StringBuffer insertSQL = new StringBuffer(
1:                 "INSERT INTO T0(SI,I,BI,R,F,D,N5_2,DEC10_3,CH20,VC,LVC) VALUES\n");
1: 
1:         for (int i = 0; i < rowCount; i++) {
1:             if (i != 0)
1:                 insertSQL.append(',');
1: 
1:             insertSQL.append('(');
1: 
1:             insertSQL.append(((short) r.nextInt()));
1:             insertSQL.append(',');
1:             insertSQL.append(i);
1:             insertSQL.append(',');
1:             insertSQL.append(r.nextLong());
1:             insertSQL.append(',');
1: 
1:             insertSQL.append(r.nextFloat());
1:             insertSQL.append(',');
1:             insertSQL.append(r.nextFloat());
1:             insertSQL.append(',');
1:             insertSQL.append(r.nextDouble());
1:             insertSQL.append(',');
1: 
1:             insertSQL.append("462.54");
1:             insertSQL.append(',');
1:             insertSQL.append("9324324.34");
1:             insertSQL.append(',');
1: 
1:             insertSQL.append('\'');
1:             insertSQL.append("c");
1:             insertSQL.append(r.nextInt() % 10);
1:             insertSQL.append('\'');
1:             insertSQL.append(',');
1: 
1:             insertSQL.append('\'');
1:             insertSQL.append("vc");
1:             insertSQL.append(r.nextInt() % 1000000);
1:             insertSQL.append('\'');
1:             insertSQL.append(',');
1: 
1:             insertSQL.append('\'');
1:             insertSQL.append("lvc");
1:             insertSQL.append(r.nextInt());
1:             insertSQL.append('\'');
1: 
1:             insertSQL.append(')');
1: 
1:             insertSQL.append('\n');
1:         }
1: 
1:         try {
1:             PreparedStatement ps = prepareStatement(insertSQL.toString());
1:             assertEquals("Incorrect update count", rowCount, ps.executeUpdate());
1:             ps.close();
1:             rollback();
1:             return false;
1:         } catch (SQLException e) {
1:             // The top level exception is expected to be
1:             // the "user-friendly" query is too complex
1:             // rather than some linkage error.
0:             JDBC.assertSQLState("42ZA0", e);
1:         }
1: 
1:         return true;
1:     }
commit:ee1cc94
/////////////////////////////////////////////////////////////////////////
0:         // fixes for DERBY-766 to split methods with individual statements
0:         // bumps the limit to 98,000 parameters.
0:         testInClause(con, 3400);
1: 		 for (int count = 97000; count <= 200000 ; count += 1000)
/////////////////////////////////////////////////////////////////////////
commit:af01856
/////////////////////////////////////////////////////////////////////////
0: 			System.out.println("PASS: PREPARE: " + testName);
/////////////////////////////////////////////////////////////////////////
0: 		// Fix to DERBY-921 - passed @ 800
0: 		//   DERBY-921 - support 32bit branch offsets
commit:8b4c5e1
/////////////////////////////////////////////////////////////////////////
0: 		// svn 372388 trunk - passed @ 400
/////////////////////////////////////////////////////////////////////////
1:         // svn 372388 trunk - passed @ 3400
/////////////////////////////////////////////////////////////////////////
0: 		// svn 372388 trunk - passed @ 900
/////////////////////////////////////////////////////////////////////////
0:         System.out.println("PASS: PREPARE: " + testName);
1:         if (largeCodeGen.TEST_QUERY_EXECUTION)
1:         {
1: 	        ResultSet rs = pstmt.executeQuery();
0: 			int numRowsExpected = (numUnions/100 * 100);
1: 			int numRows = 0;
1: 			while (rs.next())
1: 			{
1: 				numRows++;
1: 				if ((numRows % 100) == 0)
1: 				checkRowData(rs);
1: 			}
0: 			System.out.println("PASS: EXECUTE " + testName + " Row data check ok");
0: 	        con.commit();
1:         }
commit:c8208e1
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         createTestTable(con);
0:         testInClause(con);
/////////////////////////////////////////////////////////////////////////
1: 		 
0: 		 for (int count = 200; count <= 10000 ; count += 100)
1: 		 {
0: 			 // keep testing until it fails.
0: 			 if (testWhereParams(con, count))
1: 				 break;
1: 		 }
/////////////////////////////////////////////////////////////////////////
0: 	private static boolean testWhereParams(Connection con, int numParams) throws SQLException {
1: 		StringBuffer sqlBuffer = new StringBuffer((numParams * 20) + 512);
0: 		sqlBuffer.append("DELETE FROM T0 WHERE " + pred );
0: 			PreparedStatement ps = con.prepareStatement(sqlBuffer.toString());
1: 			ps.close();
1: 			return false;
1: 			return true;
0: 	private static void testInClause(Connection con)  throws SQLException {
0: 		 for (int count = 2500; count <= 10000 ; count += 100)
1: 		 {
0: 			 // keep testing until it fails.
0: 			 if (testInClause(con, count))
1: 				 break;
1: 		 }
1: 	}	
0: 	private static boolean testInClause(Connection con, int numParams) throws SQLException {
1: 		String testName = "IN clause with " + numParams + " parameters";
1: 		StringBuffer sqlBuffer = new StringBuffer((numParams * 20) + 512);
0: 		sqlBuffer.append("SELECT * FROM T0 WHERE I IN ("  );
1: 		for (int i = 1; i < numParams; i++)
1: 		{
1: 			sqlBuffer.append("?, ");
1: 		}
1: 		sqlBuffer.append("?)");
1: 		try {
0: 			PreparedStatement ps = con.prepareStatement(sqlBuffer.toString());
0: 			System.out.println("PASS: " + testName);
1: 			ps.close();
1: 			return false;
1: 		 
0: 		}catch (Exception e)
1: 		{
0: 			reportFailure(testName, e);
1: 			return true;
1: 			
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		
0: 		for (int count = 800; count <= 10000; count += 100)
1: 		{
0: 			// keep testing until it fails
0: 			if (largeUnionSelect(con, viewName, count))
1: 				break;
1: 		}
0:     private static boolean largeUnionSelect(Connection con, String viewName,
1: 		
1: 		String unionClause = " UNION ALL (SELECT * FROM " + viewName + ")";
1: 
1: 		StringBuffer selectSQLBuffer  =
1: 			new StringBuffer(((numUnions/100) * unionClause.length()) + 512);
1: 		
1: 		selectSQLBuffer.append("select * from t0 ");
1: 		
1: 			selectSQLBuffer.append(unionClause);
/////////////////////////////////////////////////////////////////////////
0:         return false;
0: 			return true;
commit:b9dfa64
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.DriverManager;
0: import java.sql.Connection;
0: import java.sql.*;
1: 
0: import java.util.Properties;
0: import org.apache.derby.tools.ij;
1: 
1: 
1: // This test tries to push byte code generation to the limit.
0: // the variable numUnions can be changed to push up the byte code generated
0: // It has to be run with a large amount of memory. if numUnions is set high e.g.
0: //  java -Djvmflags=-Xmx512M org.apache.derbyTesting.harness.RunTest lang/largeCodeGen
0: // This is but one code path other areas need to be tested such as large in clauses, etc.
1: 
0: public class largeCodeGen
1: {
1: 
0:     public static void main(String argv[]) 
0:        throws Exception
1:     {
0:         Statement stmt = null;
0:         PreparedStatement pstmt = null; 
0: 		//int numUnions = 4000;
0: 		//int numUnions = 2000;
1: 		/*
0: 		  We still have problems with large queries. 
0: 		  Passes at 4000.
0: 		  With size 5000 it gets "java.lang.VerifyError: 
0: 		  (class: db2j/exe/ac601a400fx0102xc673xe3e9x000000163ac04, method: 
0: 		  execute signature: ()Lcom/ibm/db2j/protocol/Database/Language/Interface/ResultSet;) Illegal target of jump or branch". My fix affects generated method "fillResultSet". With size 10000 largeCodeGen gets Java exception: 'java.io.IOException: constant_pool(70796 > 65535)'.
1: 		*/
1: 
0: 		String tableName = "t0";		
1: 		String viewName = "v0";		
1: 
0: 		ij.getPropertyArg(argv); 
0: 	        Connection con = ij.startJBMS();        
1: 
0: 		con.setAutoCommit(false);
0: 		stmt = con.createStatement();
0:  	       System.out.println("connected");
1: 
0: 		// Create table
1: 		try {
0: 			stmt.executeUpdate("drop table " + tableName);
0: 		}catch (SQLException se)
1: 		{
0: 			// drop error ok.
1: 		}
1: 		try {
0: 			stmt.executeUpdate("drop view " + viewName);
0: 		}catch (SQLException se)
1: 		{
0: 			// drop error ok.
1: 		}
1: 
0: 		String createSQL = 	"create table " +
0: 			tableName +
1: 			"(si smallint,i int, bi bigint, r real, f float, d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), ch20 char(3),vc varchar(20), lvc long varchar)";
1: 		stmt.executeUpdate(createSQL);
0: 		stmt.executeUpdate("insert into " + tableName + " values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')");
1: 		
0: 		System.out.println("Building view 100 unions");  
1: 		StringBuffer createView = new StringBuffer("create view " + viewName + 
0: 												   " as select * from " + 
0: 												   tableName);
1: 		for (int i = 1; i < 100; i ++)
1: 		{
0: 			createView.append(" UNION ALL (SELECT * FROM " + tableName + ")");
1: 		}
0: 		String createViewString = createView.toString();
1: 		//System.out.println(createViewString);
1: 		stmt.executeUpdate(createView.toString());
1: 		
0: 		// 2000 unions caused method too big error in verifier
0: 		largeUnionSelect(con, viewName, 2000);
1: 
0: 		// 10000 unions overflows the number of constant pool entries
0: 		largeUnionSelect(con, viewName, 10000);		
1:     }
1:     
0:     private static void largeUnionSelect(Connection con, String viewName,
0:     		int numUnions) throws Exception
1: 	{
1: 
0: 		StringBuffer selectSQLBuffer  = new StringBuffer("select * from t0 ") ;
1: 		for (int i = 1; i < numUnions/100;i++)
1: 		{
0: 			selectSQLBuffer.append(" UNION ALL (SELECT * FROM " + viewName + ")");
1: 		}	
1: 		
1: 		try {
1: 		// Ready to execute the problematic query 
1: 		String selectSQL = selectSQLBuffer.toString();
1: 		//System.out.println(selectSQL);
0: 		System.out.println("SELECT with " + numUnions/100 * 100 + " unions");
0:         PreparedStatement pstmt = con.prepareStatement(selectSQL);
0:         ResultSet rs = pstmt.executeQuery();
0: 		int numRowsExpected = (numUnions/100 * 100);
0: 		int numRows = 0;
0: 		while (rs.next())
1: 		{
0: 			numRows++;
0: 			if ((numRows % 100) == 0)
1: 			checkRowData(rs);
1: 		}
0: 		System.out.println("PASS: Row data check ok");
0:         con.commit();
1:         pstmt.close();
0:         con.close();
1: 		} catch (SQLException sqle)
1: 		{
0: 			System.out.println("FAILED QUERY");
0: 			do {
0: 				System.out.println(sqle.getSQLState() + ":" + sqle.getMessage());
0: 				sqle = sqle.getNextException();
0: 			} while (sqle != null);
1: 		}
1: 
1:       }
1: 
1: 	// Check the data on the positioned row against what we inserted.
0: 	private static void checkRowData(ResultSet rs) throws Exception
1: 	{
1: 		//" values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')");
1: 		String[] values = {"2", "3", "4", "5.3","5.3","5.3","31.13","123456.123",
1: 						   "one","one","one"};
1: 		for (int i = 1; i <= 11; i ++)
1: 		{
0: 			String rsValue = rs.getString(i);
0: 			String expectedValue = values[i - 1];
0: 			if (!rsValue.equals(values[i-1]))
0: 				throw new Exception("Result set data value: " + rsValue +
0: 									" does not match " + values[i-1] +
0: 					                " for column " + i);				
1: 		}
1: 	}
1: 
1: }
1: 
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:ab8e485
/////////////////////////////////////////////////////////////////////////
0: /*
1: * Licensed to the Apache Software Foundation (ASF) under one or more
1: * contributor license agreements.  See the NOTICE file distributed with
1: * this work for additional information regarding copyright ownership.
1: * The ASF licenses this file to you under the Apache License, Version 2.0
1: * (the "License"); you may not use this file except in compliance with
1: * the License.  You may obtain a copy of the License at
1: *
1: *     http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing, software
1: * distributed under the License is distributed on an "AS IS" BASIS,
1: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: * See the License for the specific language governing permissions and
1: * limitations under the License.
1: */
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0f94520
/////////////////////////////////////////////////////////////////////////
0: 	private static boolean PRINT_FAILURE_EXCEPTION = false;
/////////////////////////////////////////////////////////////////////////
0: 		System.out.println("FAILED QUERY: " + testName +".");
0: 			while (se != null  && PRINT_FAILURE_EXCEPTION)
commit:7ab414c
/////////////////////////////////////////////////////////////////////////
1: 	private static boolean TEST_QUERY_EXECUTION = true;
/////////////////////////////////////////////////////////////////////////
0:         testLogicalOperators(con);
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * Prepares and executes query against table t0 with n parameters
1: 	 * The assumption is that the query will always return our one row
1: 	 * of data inserted into the t0 table.
1: 	 * 
0: 	 * @param con
1: 	 * @param testName
1: 	 * @param sqlBuffer  - StringBuffer with SQL Text
1: 	 * @param numParams  - Number of parameters
1: 	 * @param paramValue - Parameter value
1: 	 * @return true if the check fails
1: 	 */
0: 	private static boolean checkT0Query(Connection con, String testName, 
1: 				StringBuffer sqlBuffer, int numParams, int paramValue) {
1: 		PreparedStatement ps;
0: 		try {
0: 			ps = con.prepareStatement(sqlBuffer.toString());
1: 			
1: 			if (TEST_QUERY_EXECUTION)
1: 			{
1: 				for (int i = 1; i <= numParams; i++)
1: 				{	
1: 					ps.setInt(i, paramValue);
1: 				}
1: 				ResultSet rs = ps.executeQuery();
1: 				rs.next();
0: 				checkRowData(rs);
1: 				rs.close();
1: 			}
0: 			ps.close();
0: 			System.out.println("PASS: " + testName);
0: 			return false;
0: 		}catch (Exception e)
1: 		{
0: 			reportFailure(testName, e);
0: 			return true;
1: 			
1: 		}
1: 	}
1: 
1: 	/**
0: 	private static void testLogicalOperators(Connection con)  throws SQLException {
0: 			 // keep testing until it fails with linkage error
0: 			 if (testLogicalOperators(con, count))
1: 		 // 10,000 causes Stack overflow and database corruption
1: 		 //testLogicalOperators(con, 10000);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param  numOperands 
0: 	private static boolean testLogicalOperators(Connection con, 
0: 				int numOperands) throws SQLException {
0: 		
1: 		// First with parameters
1: 		String pred =  "(si = ? AND si = ? )";
1: 		String testName = "Logical operators with " + numOperands + " parameters";
1: 		StringBuffer sqlBuffer = new StringBuffer((numOperands * 20) + 512);
1: 		sqlBuffer.append("SELECT * FROM T0 WHERE " + pred );
1: 		for (int i = 2; i < numOperands; i+=2)
1: 			sqlBuffer.append(" OR " + pred);
0: 		return checkT0Query(con, testName, sqlBuffer, numOperands, 2);
0: 		
0: 		
0: 		
0: 		
0: 	
0: 	  
1: 		// DERBY-739 raised number of parameters from 2700 to 3400
0: 		 for (int count = 3300; count <= 10000 ; count += 100)
0: 			 	break;
0: 	
1: 	/**
1: 	 * Test in clause with many parameters
1: 	 *
0: 	 * @param con
0: 	 * @param numParams - Number of parameters to test
1: 	 * @return true if the test fails
1: 	 * @throws SQLException
1: 	 */
1: 		sqlBuffer.append("SELECT * FROM T0 WHERE SI IN ("  );
0: 		return checkT0Query(con, testName, sqlBuffer, numParams, 2); 	
0: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// 10000 gives a different constant pool error
0: 		largeUnionSelect(con, viewName, 10000);
commit:209ff61
/////////////////////////////////////////////////////////////////////////
1: // It has to be run with a large amount of memory which is set with jvmflags in 
1: // largeCodeGen_app.properties
1: // There are only a few types of cases now. Other areas need to be tested such as large in clauses, etc.
1: // 
0: 	
0:     	ij.getPropertyArg(argv); 
0:         Connection con = ij.startJBMS();
0:         con.setAutoCommit(false);
0:         testParamsInWhereClause(con);
0:         testUnions(con);
0:         con.commit();
0:         con.close();
1:     }
0:     
0:     private static void createTestTable(Connection con) throws SQLException
0:     {
0:     	 Statement stmt = null;		
0:     	 stmt = con.createStatement();
0:     	 try {
0: 			stmt.executeUpdate("drop table t0 ");
0: 		}catch (SQLException se)
0: 		{
0: 			// drop error ok.
0: 			if (!se.getSQLState().equals("42Y55"))
0: 				throw se;
1: 		}	
0: 		
1: 		String createSQL = 	"create table t0 " +
0: 		"(si smallint,i int, bi bigint, r real, f float, d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), ch20 char(3),vc varchar(20), lvc long varchar)";
0: 		stmt.executeUpdate(createSQL);	
1: 		stmt.executeUpdate("insert into t0 values(2,3,4,5.3,5.3,5.3,31.13,123456.123, 'one','one','one')");
1:     }
0:     
1:     /**
0:      * Test many parameters in the where clause
0:      * e.g. 
0: 	 * @param con  
1: 	 */
0: 	private static void testParamsInWhereClause(Connection con)  throws SQLException {
0: 		 createTestTable(con);
0: 		 testWhereParams(con, 200);
0: 		 testWhereParams(con, 400);
1: 	}
0: 
0: 	
1: 	/**
1: 	 * Tests numParam parameter markers in a where clause
1: 	 * 
0: 	 * @param con          
0: 	 * @param  numparams  
1: 	 */
0: 	private static void testWhereParams(Connection con, int numParams) throws SQLException {
0: 		PreparedStatement ps  = null;
0: 		String pred = "(si = ? AND i = ? )";
0: 		String testName = "WHERE clause with " + numParams + " parameters";
0: 		StringBuffer sqlBuffer = new StringBuffer("DELETE FROM T0 WHERE " + pred );
0: 		for (int i = 2; i < numParams; i+=2)
0: 		{
0: 			sqlBuffer.append(" OR (si = ? AND i = ? ) ");
1: 		}
0: 		try {
0: 			ps = con.prepareStatement(sqlBuffer.toString());
0: 			System.out.println("PASS: " + testName);
0: 		 
0: 		}catch (Exception e)
0: 		{
0: 			reportFailure(testName, e);
0: 			
1: 		}
1: 	}
0: 
0: 	private static void testUnions(Connection con) throws Exception
0: 	{
0: 		Statement stmt = null;
0:         createTestTable(con);
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		
/////////////////////////////////////////////////////////////////////////
0: 				  
1: 												   " as select * from t0 " );
1: 			createView.append(" UNION ALL (SELECT * FROM t0 )");
0: 		
0: 		largeUnionSelect(con, viewName, 10000);
0: 
1:     	// There are 100 unions in each view so round to the nearest 100
0:     	String testName = "SELECT with " + numUnions/100 * 100 + " unions";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		System.out.println("PASS: " + testName + " Row data check ok");
0:      
0: 			reportFailure(testName, sqle);
0: 			
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Show failure message and exception stack trace
0: 	 * @param testName
0: 	 * @param e
0: 	 */
0: 	private static void reportFailure(String testName, Exception e)
0: 	{
0: 		System.out.print("FAILED QUERY: " + testName +". ");
0: 		if (e instanceof SQLException)
0: 		{
0: 			SQLException se = (SQLException) e;
0: 			while (se != null)
0: 			{
0: 				se.printStackTrace(System.out);
0: 				se = se.getNextException();
0: 			}
0: 		}	
0: 		else e.printStackTrace();
0: 	
0: 	}
0: 	
============================================================================