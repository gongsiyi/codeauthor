1:aee2d05: /*
1:aee2d05:  
1:aee2d05: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.StatementJdbc20Test
1:aee2d05:  
1:aee2d05: Licensed to the Apache Software Foundation (ASF) under one or more
1:aee2d05: contributor license agreements.  See the NOTICE file distributed with
1:aee2d05: this work for additional information regarding copyright ownership.
1:aee2d05: The ASF licenses this file to You under the Apache License, Version 2.0
1:aee2d05: (the "License"); you may not use this file except in compliance with
1:aee2d05: the License.  You may obtain a copy of the License at
1:aee2d05:  
1:aee2d05:    http://www.apache.org/licenses/LICENSE-2.0
1:aee2d05:  
1:aee2d05: Unless required by applicable law or agreed to in writing, software
1:aee2d05: distributed under the License is distributed on an "AS IS" BASIS,
1:aee2d05: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:aee2d05: See the License for the specific language governing permissions and
1:aee2d05: limitations under the License.
1:aee2d05:  
1:aee2d05:  */
1:aee2d05: 
1:aee2d05: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:aee2d05: 
1:6e97c84: import java.sql.CallableStatement;
1:aee2d05: import java.sql.Connection;
1:de8ba18: import java.sql.DriverManager;
1:6e97c84: import java.sql.PreparedStatement;
1:aee2d05: import java.sql.ResultSet;
1:aee2d05: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:aee2d05: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:aee2d05: 
1:aee2d05: /**
1:aee2d05:  * Test of additional methods in JDBC2.0  methods in statement and
1:aee2d05:  * resultset classes.
1:aee2d05:  * This test converts the old jdbcapi/statementJdbc20.java test
1:aee2d05:  * to JUnit.
1:aee2d05:  */
1:aee2d05: public class StatementJdbc20Test extends BaseJDBCTestCase {
1:aee2d05: 
1:6e97c84:     private static  final   String  METHOD_NOT_ALLOWED = "XJ016";
1:de8ba18:     private static  final   String  CLOSED_STATEMENT = "XJ012";
1:aee2d05:     
1:aee2d05:     /**
1:aee2d05:      * Create a test with the given name.
1:aee2d05:      *
1:aee2d05:      * @param name name of the test.
1:aee2d05:      */
1:aee2d05:     public StatementJdbc20Test(String name) {
1:aee2d05:         super(name);
1:aee2d05:     }
1:aee2d05:     
1:aee2d05:     /**
1:aee2d05:      * Create suite containing client and embedded tests and to run
1:aee2d05:      * all tests in this class
1:aee2d05:      */
1:aee2d05:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("StatementJdbc20Test");
1:aee2d05:         suite.addTest(baseSuite("StatementJdbc20Test:embedded"));
1:aee2d05:         suite.addTest(
1:aee2d05:                 TestConfiguration.clientServerDecorator(
1:aee2d05:                 baseSuite("StatementJdbc20Test:client")));
1:aee2d05:         
1:aee2d05:         return suite;
1:aee2d05:     }
1:aee2d05:     
1:aee2d05:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:aee2d05:         
1:aee2d05:         suite.addTestSuite(StatementJdbc20Test.class);
1:aee2d05:         
1:aee2d05:         return new CleanDatabaseTestSetup(suite) {
1:aee2d05:             /**
1:aee2d05:              * Creates the tables used in the test
1:aee2d05:              * cases.
1:aee2d05:              *
1:aee2d05:              * @exception SQLException if a database error occurs
1:aee2d05:              */
1:aee2d05:             protected void decorateSQL(Statement stmt) throws SQLException {
1:aee2d05:                 
1:aee2d05:                 Connection conn = getConnection();
1:aee2d05:                 
1:aee2d05:                 /**
1:aee2d05:                  * Creates the table used in the test cases.
1:aee2d05:                  *
1:aee2d05:                  */
1:aee2d05:                 stmt.execute("create table tab1 (i int, s smallint, r real)");
1:aee2d05:                 stmt.executeUpdate("insert into tab1 values(1, 2, 3.1)");
1:aee2d05: 
1:de8ba18:                 stmt.execute
1:de8ba18:                     (
1:de8ba18:                      "create procedure dynamic_results() " +
1:de8ba18:                      "language java parameter style java external name '" +
1:de8ba18:                      StatementJdbc20Test.class.getName() + ".dynamicResults' " +
1:de8ba18:                      "dynamic result sets 2"
1:de8ba18:                      );
1:821bc13: 
1:821bc13:                 stmt.execute( "create table t_autogen( a int generated always as identity, b int )" );
1:aee2d05:             }
1:aee2d05:         };
1:aee2d05:     }
1:aee2d05:     
1:aee2d05:     /**
1:aee2d05:      * Testing wrong values for setFetchSize
1:aee2d05:      * and setFetchDirection.
1:aee2d05:      *
1:aee2d05:      * @exception SQLException if error occurs
1:aee2d05:      */
1:aee2d05:     public void testWrongVaues() throws SQLException {
1:aee2d05:         
1:aee2d05:         Statement stmt = createStatement();
1:aee2d05:         
1:aee2d05:         stmt.setFetchSize(25);
1:aee2d05:         stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
1:aee2d05:         stmt.setEscapeProcessing(true);
1:aee2d05:         
1:aee2d05:         //Error  testing  : set wrong values ..
1:aee2d05:         try {
1:aee2d05:             stmt.setFetchSize(-1000);
1:aee2d05:             fail("setFetchSize(-1000) expected to fail");
1:aee2d05:         } catch(SQLException e) {
1:aee2d05:             assertSQLState("XJ065", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         try {
1:aee2d05:             stmt.setFetchDirection(-1000);
1:aee2d05:             fail("setFetchDirection(-1000) expected to fail");
2:aee2d05:         } catch(SQLException e){
1:aee2d05:             assertSQLState("XJ064", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         assertEquals(stmt.getFetchSize(), 25);
1:aee2d05:         assertEquals(stmt.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:aee2d05:         
1:aee2d05:         stmt.close();
1:aee2d05:     }
1:aee2d05:     /**
1:aee2d05:      * Tests reading data from database
1:aee2d05:      *
1:aee2d05:      * @exception SQLException 	if error occurs
1:aee2d05:      */
1:aee2d05:     public void testReadingData() throws SQLException {
1:aee2d05:         
1:aee2d05:         Statement stmt = createStatement();
1:aee2d05:         ResultSet rs;
1:aee2d05:         
1:aee2d05:         // read the data just for the heck of it
1:aee2d05:         rs = stmt.executeQuery("select * from tab1");
1:aee2d05:         while (rs.next()) {
1:aee2d05:             assertEquals(rs.getInt(1), 1);
1:aee2d05:             assertEquals(rs.getShort(2), 2);
1:aee2d05:             assertEquals(rs.getDouble(3), 3.1, 0.01);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         rs.close();
1:aee2d05:         stmt.close();
1:aee2d05:     }
1:aee2d05:     /**
1:aee2d05:      * Tests values local to result set and get them back
1:aee2d05:      *
1:aee2d05:      * @exception SQLException 	if error occurs
1:aee2d05:      */
1:aee2d05:     public void testLocalValuesOfResultSet() throws SQLException {
1:aee2d05:         
1:aee2d05:         Statement stmt = createStatement();
1:aee2d05:         ResultSet rs;
1:aee2d05:         
1:aee2d05:         stmt.setFetchSize(25);
1:aee2d05:         stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
1:aee2d05:         stmt.setEscapeProcessing(true);
1:aee2d05:         
1:aee2d05:         rs = stmt.executeQuery("select * from tab1");
1:aee2d05:         // Get the constatnts for a result set
1:aee2d05:         assertEquals(rs.getFetchSize(), 25);
1:aee2d05:         assertEquals(rs.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:aee2d05:         
1:aee2d05:         // change values local to result set and get them back
1:aee2d05:         rs.setFetchSize(250);
2:aee2d05:         try{
1:aee2d05:             rs.setFetchDirection(ResultSet.FETCH_FORWARD);
1:aee2d05:         }catch(SQLException e){
1:aee2d05:             
1:aee2d05:             if (usingEmbedded())
1:aee2d05:                 assertSQLState("XJ061", e);
1:aee2d05:             else
1:aee2d05:                 assertSQLState("XJ125", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         assertEquals(rs.getFetchSize(), 250);
1:aee2d05:         assertEquals(rs.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:aee2d05:         
1:51d91d5:         // Verify that fetch size can be set larger than maxRows
1:aee2d05:         stmt.setMaxRows(10);
1:51d91d5:         rs.setFetchSize(100);
1:aee2d05:         
1:aee2d05:         //Error  testing  : set wrong values ..
1:aee2d05:         try{
1:aee2d05:             rs.setFetchSize(-2000);
1:aee2d05:             fail("setFetchSize(-2000) expected to fail");
1:aee2d05:         } catch(SQLException e){
2:aee2d05:             assertSQLState("XJ062", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         try{
1:aee2d05:             rs.setFetchDirection(-2000);
1:aee2d05:         } catch(SQLException e){
1:aee2d05:             
1:aee2d05:             if (usingEmbedded())
1:aee2d05:                 assertSQLState("XJ061", e);
1:aee2d05:             else
1:aee2d05:                 assertSQLState("XJ125", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         // set the fetch size values to zero .. to ensure
1:aee2d05:         // error condtions are correct !
1:aee2d05:         
1:aee2d05:         rs.setFetchSize(0);
1:aee2d05:         stmt.setFetchSize(0);
1:aee2d05:         
1:aee2d05:         rs.close();
1:aee2d05:     }
1:aee2d05:     /**
1:aee2d05:      * Tests creating tables with executeQuery which is
1:aee2d05:      * not allowed on statements that return a row count
1:aee2d05:      *
1:aee2d05:      * @exception SQLException
1:aee2d05:      *                if error occurs
1:aee2d05:      */
1:aee2d05:     public void testCreateTableWithExecuteQuery() throws SQLException {
1:aee2d05:         
1:aee2d05:         Statement stmt = createStatement();
1:aee2d05:         ResultSet rs;
1:aee2d05:         
1:aee2d05:         //RESOLVE - uncomment tests in 3.5
1:aee2d05:         // executeQuery() not allowed on statements
1:aee2d05:         // that return a row count
1:aee2d05:         try {
1:aee2d05:             stmt.executeQuery("create table trash(c1 int)");
1:aee2d05:         } catch (SQLException e) {
1:aee2d05:             if (usingEmbedded())
1:aee2d05:                 assertSQLState("X0Y78", e);
1:aee2d05:             else
1:aee2d05:                 assertSQLState("XJ207", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         // verify that table was not created
1:aee2d05:         try {
1:aee2d05:             rs = stmt.executeQuery("select * from trash");
1:aee2d05:             System.out.println("select from trash expected to fail");
1:aee2d05:         } catch (SQLException e) {
1:aee2d05:             assertSQLState("42X05", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         // executeUpdate() not allowed on statements
1:aee2d05:         // that return a ResultSet
1:aee2d05:         try {
1:aee2d05:             stmt.executeUpdate("values 1");
1:aee2d05:         } catch (SQLException e) {
1:aee2d05:             assertSQLState("X0Y79", e);
1:aee2d05:         }
1:aee2d05:         
1:aee2d05:         stmt.close();
1:aee2d05:         commit();
1:aee2d05:     }
1:de8ba18: 
1:7f1559d:     /**
1:6e97c84:      * Test the following clarification made by JDBC 4.1: You should
1:6e97c84:      * raise an exception when addBatch(String) is called on a PreparedStatement
1:6e97c84:      * or a CallableStatement.
1:6e97c84:      */
1:6e97c84:     public void testAddBatchClarification_jdbc4_1() throws SQLException
1:6e97c84:     {
1:6e97c84:         PreparedStatement ps = prepareStatement( "select * from sys.systables" );
1:6e97c84:         CallableStatement cs = prepareCall( "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)" );
1:6e97c84: 
1:6e97c84:         try {
1:6e97c84:             ps.addBatch( "select * from sys.systables" );
1:6e97c84:             fail( "Oops. ps.addBatch() worked." );
1:aee2d05:         }
1:6e97c84:         catch (SQLException se)
1:6e97c84:         {
1:6e97c84:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:aee2d05:         }
3:6e97c84:         
1:6e97c84:         try {
1:6e97c84:             cs.addBatch( "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)" );
1:6e97c84:             fail( "Oops. cs.addBatch() worked." );
2:6e97c84:         }
1:6e97c84:         catch (SQLException se)
1:6e97c84:         {
1:6e97c84:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:6e97c84:         }
1:6e97c84:     }
1:6e97c84: 
1:de8ba18:     /**
1:de8ba18:      * Test the closeOnCompletion() and isCloseOnCompletion() methods
1:de8ba18:      * added by JDBC 4.1.
1:de8ba18:      */
1:de8ba18:     public void testCompletionClosure_jdbc4_1() throws Exception
1:de8ba18:     {
1:790d93c:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:790d93c:         
1:de8ba18:         vetClosure( false, false );
1:de8ba18:         vetClosure( false, true );
1:de8ba18:         vetClosure( true, false );
1:de8ba18:         vetClosure( true, true );
1:de8ba18:     }
1:de8ba18:     private void vetClosure( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:de8ba18:     {
1:de8ba18:         vetClosedSelect( closeOnCompletion, delayClosureCall );
1:de8ba18:         vetClosedCall( closeOnCompletion, delayClosureCall );
1:de8ba18:         vetClosedPS( closeOnCompletion, delayClosureCall );
1:821bc13:         vetClosedAutoGen( closeOnCompletion, delayClosureCall );
1:de8ba18:     }
1:de8ba18:     private void vetClosedSelect( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:de8ba18:     {
1:de8ba18:         Statement stmt = createStatement();
1:de8ba18:         ResultSet rs;
1:de8ba18: 
1:de8ba18:         println( "Verifying SELECT wrapper on " + stmt.getClass().getName() +
1:de8ba18:                  " with closeOnCompletion = " + closeOnCompletion +
1:de8ba18:                  " and delayClosureCall = " + delayClosureCall );
1:de8ba18:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1:de8ba18: 
1:de8ba18:         if ( !delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:821bc13: 
1:de8ba18:         rs = stmt.executeQuery( "select * from tab1" );
1:de8ba18: 
1:de8ba18:         if ( delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:de8ba18: 
1:de8ba18:         rs.close();
1:de8ba18: 
1:de8ba18:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1:de8ba18: 
1:de8ba18:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:de8ba18:     }
1:de8ba18:     private void vetClosedCall( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:de8ba18:     {
1:de8ba18:         Statement stmt = createStatement();
1:de8ba18:         ResultSet rs;
1:de8ba18: 
1:de8ba18:         println( "Verifying CALL wrapper on " + stmt.getClass().getName() +
1:de8ba18:                  " with closeOnCompletion = " + closeOnCompletion +
1:de8ba18:                  " and delayClosureCall = " + delayClosureCall );
1:de8ba18:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1:de8ba18: 
1:de8ba18:         if ( !delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:de8ba18: 
1:de8ba18:         assertTrue( stmt.execute( "call dynamic_results()" ) );
1:de8ba18: 
1:de8ba18:         assertFalse( wrapper.isClosed() );
1:de8ba18: 
1:de8ba18:         ResultSet   rs1 = stmt.getResultSet();
1:de8ba18: 
1:de8ba18:         if ( delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:de8ba18: 
1:de8ba18:         assertTrue( stmt.getMoreResults() ); // implicitly closes rs1
1:de8ba18:         assertFalse( wrapper.isClosed() );
1:de8ba18: 
1:de8ba18:         ResultSet   rs2 = stmt.getResultSet();
1:de8ba18:         rs2.close();
1:de8ba18:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1:de8ba18: 
1:de8ba18:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:de8ba18:     }
1:de8ba18:     private void vetClosedPS( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:de8ba18:     {
1:de8ba18:         PreparedStatement ps = getConnection().prepareStatement( "select * from tab1" );
1:de8ba18:         ResultSet rs;
1:de8ba18: 
1:de8ba18:         println( "Verifying PreparedStatement wrapper on " + ps.getClass().getName() +
1:de8ba18:                  " with closeOnCompletion = " + closeOnCompletion +
1:de8ba18:                  " and delayClosureCall = " + delayClosureCall );
1:de8ba18:         Wrapper41Statement  wrapper = new Wrapper41Statement( ps );
1:de8ba18: 
1:de8ba18:         if ( !delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:de8ba18: 
1:de8ba18:         rs = ps.executeQuery();
1:de8ba18: 
1:de8ba18:         if ( delayClosureCall )
1:de8ba18:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:de8ba18: 
1:de8ba18:         rs.close();
1:de8ba18: 
1:de8ba18:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1:de8ba18: 
1:de8ba18:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:de8ba18: 
1:de8ba18:         if ( !wrapper.isClosed() ) { ps.close(); }
1:de8ba18:     }
1:821bc13:     private void vetClosedAutoGen( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:821bc13:     {
1:821bc13:         Statement stmt = createStatement();
1:821bc13:         ResultSet rs;
1:821bc13: 
1:821bc13:         println( "Verifying AUTOGENERATED KEYS wrapper on " + stmt.getClass().getName() +
1:821bc13:                  " with closeOnCompletion = " + closeOnCompletion +
1:821bc13:                  " and delayClosureCall = " + delayClosureCall );
1:821bc13:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1:821bc13: 
1:821bc13:         if ( !delayClosureCall )
1:821bc13:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:821bc13: 
1:821bc13:         stmt.executeUpdate( "insert into t_autogen( b ) values ( 1 )", Statement.RETURN_GENERATED_KEYS );
1:821bc13:         rs = stmt.getGeneratedKeys();
1:821bc13: 
1:821bc13:         if ( delayClosureCall )
1:821bc13:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1:821bc13: 
1:821bc13:         assertFalse( wrapper.isClosed() );
1:821bc13: 
1:821bc13:         rs.close();
1:821bc13: 
1:821bc13:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1:de8ba18: 
1:821bc13:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:821bc13:     }
1:de8ba18:     
1:de8ba18:     private void    setCloseOnCompletion( Wrapper41Statement wrapper, boolean closeOnCompletion )
1:de8ba18:         throws Exception
1:de8ba18:     {
1:de8ba18:         assertFalse( wrapper.isCloseOnCompletion() );
1:de8ba18:         if ( closeOnCompletion ) { wrapper.closeOnCompletion(); }
1:de8ba18:         assertEquals( closeOnCompletion, wrapper.isCloseOnCompletion() );
1:de8ba18:     }
1:de8ba18:     private void    vetSuccessfulClosure
1:de8ba18:         ( Wrapper41Statement wrapper, boolean closeOnCompletion )
1:de8ba18:         throws Exception
1:de8ba18:     {
1:de8ba18:         if ( closeOnCompletion )
1:de8ba18:         {
1:de8ba18:             try {
1:de8ba18:                 wrapper.closeOnCompletion();
1:de8ba18:                 fail( "Expected closed statement failure." );
1:de8ba18:             }
1:de8ba18:             catch (SQLException se)
1:de8ba18:             {
1:de8ba18:                 assertSQLState( CLOSED_STATEMENT, se );
1:de8ba18:             }
1:de8ba18: 
1:de8ba18:             try {
1:de8ba18:                 wrapper.isCloseOnCompletion();
1:de8ba18:                 fail( "Expected closed statement failure." );
1:de8ba18:             }
1:de8ba18:             catch (SQLException se)
1:de8ba18:             {
1:de8ba18:                 assertSQLState( CLOSED_STATEMENT, se );
1:de8ba18:             }
1:de8ba18:         }
1:de8ba18:     }
1:de8ba18:     
1:6e97c84:     /**
1:7f1559d:      * <p>
1:7f1559d:      * Spec clarifications in JDBC 4.1. Verify that an exception is raised if a PreparedStatement
1:7f1559d:      * or CallableStatement tries to execute one of the methods which compiles SQL text.
1:7f1559d:      * </p>
1:7f1559d:      */
1:7f1559d:     public  void    test_clarification_jdbc4_1()    throws Exception
1:7f1559d:     {
1:7f1559d:         Connection  conn = getConnection();
1:7f1559d: 
1:7f1559d:         PreparedStatement   ps = conn.prepareStatement( "select * from sys.syscolumns" );
1:7f1559d:         CallableStatement   cs = conn.prepareCall( "call dynamic_results()" );
1:7f1559d: 
1:7f1559d:         vetNotAllowed( ps );
1:7f1559d:         vetNotAllowed( cs );
1:7f1559d: 
1:7f1559d:         ps.close();
1:7f1559d:         cs.close();
1:7f1559d:     }
1:7f1559d:     private void    vetNotAllowed( Statement stmt ) throws Exception
1:7f1559d:     {
1:7f1559d:         println( "Vetting a " + stmt.getClass().getName() );
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.execute( "select * from sys.systables" );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.execute( "select * from sys.systables", Statement.NO_GENERATED_KEYS );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.execute( "select * from sys.systables", new int[] { 1 } );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.execute( "select * from sys.systables", new String[] { "COLUMNNAME" } );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.executeQuery( "select * from sys.systables" );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)" );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", Statement.NO_GENERATED_KEYS );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", new int[] { 1 } );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:         
1:7f1559d:         try {
1:7f1559d:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", new String[] { "COLUMNNAME" } );
1:7f1559d:             failVNA();
1:7f1559d:         }
1:7f1559d:         catch (SQLException se)
1:7f1559d:         {
1:7f1559d:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:7f1559d:         }
1:7f1559d:     }
1:7f1559d:     private void    failVNA() throws Exception
1:7f1559d:     {
1:7f1559d:             fail( "Should have failed when run on a PreparedStatement or CallableStatement" );
1:7f1559d:     }
1:7f1559d: 
1:de8ba18:     ///////////////////////////////////////////////////////////////////////
1:de8ba18:     //
1:de8ba18:     // PROCEDURES
1:de8ba18:     //
1:de8ba18:     ///////////////////////////////////////////////////////////////////////
1:de8ba18: 
1:de8ba18: 
1:de8ba18:     /**
1:de8ba18:      * Stored procedure which returns 2 ResultSets.
1:de8ba18:      */
1:de8ba18:     public static void dynamicResults
1:de8ba18:         ( ResultSet[] rs1, ResultSet[] rs2 )
1:de8ba18:         throws SQLException
1:de8ba18:     {
1:de8ba18:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:de8ba18:         rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:de8ba18:         rs2[0] = c.createStatement().executeQuery("VALUES(2)");
1:de8ba18:     }
1:6e97c84: 
1:6e97c84: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("StatementJdbc20Test");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:51d91d5
/////////////////////////////////////////////////////////////////////////
1:         // Verify that fetch size can be set larger than maxRows
1:         rs.setFetchSize(100);
commit:aee2d05
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.StatementJdbc20Test
1:  
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1:  
1:    http://www.apache.org/licenses/LICENSE-2.0
1:  
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.SQLException;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Test of additional methods in JDBC2.0  methods in statement and
1:  * resultset classes.
1:  * This test converts the old jdbcapi/statementJdbc20.java test
1:  * to JUnit.
1:  */
1: public class StatementJdbc20Test extends BaseJDBCTestCase {
1:     
1:     /**
1:      * Create a test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public StatementJdbc20Test(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Create suite containing client and embedded tests and to run
1:      * all tests in this class
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("StatementJdbc20Test");
1:         suite.addTest(baseSuite("StatementJdbc20Test:embedded"));
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                 baseSuite("StatementJdbc20Test:client")));
1:         
1:         return suite;
1:     }
1:     
1:     private static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         
1:         suite.addTestSuite(StatementJdbc20Test.class);
1:         
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the tables used in the test
1:              * cases.
1:              *
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException {
1:                 
1:                 Connection conn = getConnection();
1:                 
1:                 /**
1:                  * Creates the table used in the test cases.
1:                  *
1:                  */
1:                 stmt.execute("create table tab1 (i int, s smallint, r real)");
1:                 stmt.executeUpdate("insert into tab1 values(1, 2, 3.1)");
1:             }
1:         };
1:     }
1:     
1:     /**
1:      * Testing wrong values for setFetchSize
1:      * and setFetchDirection.
1:      *
1:      * @exception SQLException if error occurs
1:      */
1:     public void testWrongVaues() throws SQLException {
1:         
1:         Statement stmt = createStatement();
1:         
1:         stmt.setFetchSize(25);
1:         stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
1:         stmt.setEscapeProcessing(true);
1:         
1:         //Error  testing  : set wrong values ..
1:         try {
1:             stmt.setFetchSize(-1000);
1:             fail("setFetchSize(-1000) expected to fail");
1:         } catch(SQLException e) {
1:             assertSQLState("XJ065", e);
1:         }
1:         
1:         try {
1:             stmt.setFetchDirection(-1000);
1:             fail("setFetchDirection(-1000) expected to fail");
1:         } catch(SQLException e){
1:             assertSQLState("XJ064", e);
1:         }
1:         
1:         assertEquals(stmt.getFetchSize(), 25);
1:         assertEquals(stmt.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:         
1:         stmt.close();
1:     }
1:     /**
1:      * Tests reading data from database
1:      *
1:      * @exception SQLException 	if error occurs
1:      */
1:     public void testReadingData() throws SQLException {
1:         
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1:         
1:         // read the data just for the heck of it
1:         rs = stmt.executeQuery("select * from tab1");
1:         while (rs.next()) {
1:             assertEquals(rs.getInt(1), 1);
1:             assertEquals(rs.getShort(2), 2);
1:             assertEquals(rs.getDouble(3), 3.1, 0.01);
1:         }
1:         
1:         rs.close();
1:         stmt.close();
1:     }
1:     /**
1:      * Tests values local to result set and get them back
1:      *
1:      * @exception SQLException 	if error occurs
1:      */
1:     public void testLocalValuesOfResultSet() throws SQLException {
1:         
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1:         
1:         stmt.setFetchSize(25);
1:         stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
1:         stmt.setEscapeProcessing(true);
1:         
1:         rs = stmt.executeQuery("select * from tab1");
1:         // Get the constatnts for a result set
1:         assertEquals(rs.getFetchSize(), 25);
1:         assertEquals(rs.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:         
1:         // change values local to result set and get them back
1:         rs.setFetchSize(250);
1:         try{
1:             rs.setFetchDirection(ResultSet.FETCH_FORWARD);
1:         }catch(SQLException e){
1:             
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061", e);
1:             else
1:                 assertSQLState("XJ125", e);
1:         }
1:         
1:         assertEquals(rs.getFetchSize(), 250);
1:         assertEquals(rs.getFetchDirection(), ResultSet.FETCH_REVERSE);
1:         
0:         // exception conditions
1:         stmt.setMaxRows(10);
1:         try{
0:             rs.setFetchSize(100);
1:         } catch(SQLException e){
1:             assertSQLState("XJ062", e);
1:         }
1:         
1:         //Error  testing  : set wrong values ..
1:         try{
1:             rs.setFetchSize(-2000);
1:             fail("setFetchSize(-2000) expected to fail");
1:         } catch(SQLException e){
1:             assertSQLState("XJ062", e);
1:         }
1:         
1:         try{
1:             rs.setFetchDirection(-2000);
1:         } catch(SQLException e){
1:             
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061", e);
1:             else
1:                 assertSQLState("XJ125", e);
1:         }
1:         
1:         // set the fetch size values to zero .. to ensure
1:         // error condtions are correct !
1:         
1:         rs.setFetchSize(0);
1:         stmt.setFetchSize(0);
1:         
1:         rs.close();
1:     }
1:     /**
1:      * Tests creating tables with executeQuery which is
1:      * not allowed on statements that return a row count
1:      *
1:      * @exception SQLException
1:      *                if error occurs
1:      */
1:     public void testCreateTableWithExecuteQuery() throws SQLException {
1:         
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1:         
1:         //RESOLVE - uncomment tests in 3.5
1:         // executeQuery() not allowed on statements
1:         // that return a row count
1:         try {
1:             stmt.executeQuery("create table trash(c1 int)");
1:         } catch (SQLException e) {
1:             if (usingEmbedded())
1:                 assertSQLState("X0Y78", e);
1:             else
1:                 assertSQLState("XJ207", e);
1:         }
1:         
1:         // verify that table was not created
1:         try {
1:             rs = stmt.executeQuery("select * from trash");
1:             System.out.println("select from trash expected to fail");
1:         } catch (SQLException e) {
1:             assertSQLState("42X05", e);
1:         }
1:         
1:         // executeUpdate() not allowed on statements
1:         // that return a ResultSet
1:         try {
1:             stmt.executeUpdate("values 1");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y79", e);
1:         }
1:         
1:         stmt.close();
1:         commit();
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:790d93c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:         
commit:7f1559d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Spec clarifications in JDBC 4.1. Verify that an exception is raised if a PreparedStatement
1:      * or CallableStatement tries to execute one of the methods which compiles SQL text.
1:      * </p>
1:      */
1:     public  void    test_clarification_jdbc4_1()    throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         PreparedStatement   ps = conn.prepareStatement( "select * from sys.syscolumns" );
1:         CallableStatement   cs = conn.prepareCall( "call dynamic_results()" );
1: 
1:         vetNotAllowed( ps );
1:         vetNotAllowed( cs );
1: 
1:         ps.close();
1:         cs.close();
1:     }
1:     private void    vetNotAllowed( Statement stmt ) throws Exception
1:     {
1:         println( "Vetting a " + stmt.getClass().getName() );
1:         
1:         try {
1:             stmt.execute( "select * from sys.systables" );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.execute( "select * from sys.systables", Statement.NO_GENERATED_KEYS );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.execute( "select * from sys.systables", new int[] { 1 } );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.execute( "select * from sys.systables", new String[] { "COLUMNNAME" } );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.executeQuery( "select * from sys.systables" );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)" );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", Statement.NO_GENERATED_KEYS );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", new int[] { 1 } );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             stmt.executeUpdate( "insert into tab1 values(1, 2, 3.1)", new String[] { "COLUMNNAME" } );
1:             failVNA();
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:     }
1:     private void    failVNA() throws Exception
1:     {
1:             fail( "Should have failed when run on a PreparedStatement or CallableStatement" );
1:     }
1: 
commit:821bc13
/////////////////////////////////////////////////////////////////////////
1: 
1:                 stmt.execute( "create table t_autogen( a int generated always as identity, b int )" );
/////////////////////////////////////////////////////////////////////////
1:         vetClosedAutoGen( closeOnCompletion, delayClosureCall );
/////////////////////////////////////////////////////////////////////////
1:     private void vetClosedAutoGen( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1: 
1:         println( "Verifying AUTOGENERATED KEYS wrapper on " + stmt.getClass().getName() +
1:                  " with closeOnCompletion = " + closeOnCompletion +
1:                  " and delayClosureCall = " + delayClosureCall );
1:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1: 
1:         if ( !delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         stmt.executeUpdate( "insert into t_autogen( b ) values ( 1 )", Statement.RETURN_GENERATED_KEYS );
1:         rs = stmt.getGeneratedKeys();
1: 
1:         if ( delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         assertFalse( wrapper.isClosed() );
1: 
1:         rs.close();
1: 
1:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1: 
1:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:     }
commit:de8ba18
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  CLOSED_STATEMENT = "XJ012";
/////////////////////////////////////////////////////////////////////////
1: 
1:                 stmt.execute
1:                     (
1:                      "create procedure dynamic_results() " +
1:                      "language java parameter style java external name '" +
1:                      StatementJdbc20Test.class.getName() + ".dynamicResults' " +
1:                      "dynamic result sets 2"
1:                      );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test the closeOnCompletion() and isCloseOnCompletion() methods
1:      * added by JDBC 4.1.
1:      */
1:     public void testCompletionClosure_jdbc4_1() throws Exception
1:     {
1:         vetClosure( false, false );
1:         vetClosure( false, true );
1:         vetClosure( true, false );
1:         vetClosure( true, true );
1:     }
1:     private void vetClosure( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:     {
1:         vetClosedSelect( closeOnCompletion, delayClosureCall );
1:         vetClosedCall( closeOnCompletion, delayClosureCall );
1:         vetClosedPS( closeOnCompletion, delayClosureCall );
1:     }
1:     private void vetClosedSelect( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1: 
1:         println( "Verifying SELECT wrapper on " + stmt.getClass().getName() +
1:                  " with closeOnCompletion = " + closeOnCompletion +
1:                  " and delayClosureCall = " + delayClosureCall );
1:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1: 
1:         if ( !delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         rs = stmt.executeQuery( "select * from tab1" );
1: 
1:         if ( delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         rs.close();
1: 
1:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1: 
1:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:     }
1:     private void vetClosedCall( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         ResultSet rs;
1: 
1:         println( "Verifying CALL wrapper on " + stmt.getClass().getName() +
1:                  " with closeOnCompletion = " + closeOnCompletion +
1:                  " and delayClosureCall = " + delayClosureCall );
1:         Wrapper41Statement  wrapper = new Wrapper41Statement( stmt );
1: 
1:         if ( !delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         assertTrue( stmt.execute( "call dynamic_results()" ) );
1: 
1:         assertFalse( wrapper.isClosed() );
1: 
1:         ResultSet   rs1 = stmt.getResultSet();
1: 
1:         if ( delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         assertTrue( stmt.getMoreResults() ); // implicitly closes rs1
1:         assertFalse( wrapper.isClosed() );
1: 
1:         ResultSet   rs2 = stmt.getResultSet();
1:         rs2.close();
1:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1: 
1:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1:     }
1:     private void vetClosedPS( boolean closeOnCompletion, boolean delayClosureCall ) throws Exception
1:     {
1:         PreparedStatement ps = getConnection().prepareStatement( "select * from tab1" );
1:         ResultSet rs;
1: 
1:         println( "Verifying PreparedStatement wrapper on " + ps.getClass().getName() +
1:                  " with closeOnCompletion = " + closeOnCompletion +
1:                  " and delayClosureCall = " + delayClosureCall );
1:         Wrapper41Statement  wrapper = new Wrapper41Statement( ps );
1: 
1:         if ( !delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         rs = ps.executeQuery();
1: 
1:         if ( delayClosureCall )
1:         { setCloseOnCompletion( wrapper, closeOnCompletion ); }
1: 
1:         rs.close();
1: 
1:         assertEquals( closeOnCompletion, wrapper.isClosed() );
1: 
1:         vetSuccessfulClosure( wrapper, closeOnCompletion );
1: 
1:         if ( !wrapper.isClosed() ) { ps.close(); }
1:     }
1:     
1:     private void    setCloseOnCompletion( Wrapper41Statement wrapper, boolean closeOnCompletion )
1:         throws Exception
1:     {
1:         assertFalse( wrapper.isCloseOnCompletion() );
1:         if ( closeOnCompletion ) { wrapper.closeOnCompletion(); }
1:         assertEquals( closeOnCompletion, wrapper.isCloseOnCompletion() );
1:     }
1:     private void    vetSuccessfulClosure
1:         ( Wrapper41Statement wrapper, boolean closeOnCompletion )
1:         throws Exception
1:     {
1:         if ( closeOnCompletion )
1:         {
1:             try {
1:                 wrapper.closeOnCompletion();
1:                 fail( "Expected closed statement failure." );
1:             }
1:             catch (SQLException se)
1:             {
1:                 assertSQLState( CLOSED_STATEMENT, se );
1:             }
1: 
1:             try {
1:                 wrapper.isCloseOnCompletion();
1:                 fail( "Expected closed statement failure." );
1:             }
1:             catch (SQLException se)
1:             {
1:                 assertSQLState( CLOSED_STATEMENT, se );
1:             }
1:         }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // PROCEDURES
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Stored procedure which returns 2 ResultSets.
1:      */
1:     public static void dynamicResults
1:         ( ResultSet[] rs1, ResultSet[] rs2 )
1:         throws SQLException
1:     {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         rs1[0] = c.createStatement().executeQuery("VALUES(1)");
1:         rs2[0] = c.createStatement().executeQuery("VALUES(2)");
1:     }
commit:6e97c84
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  METHOD_NOT_ALLOWED = "XJ016";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test the following clarification made by JDBC 4.1: You should
1:      * raise an exception when addBatch(String) is called on a PreparedStatement
1:      * or a CallableStatement.
1:      */
1:     public void testAddBatchClarification_jdbc4_1() throws SQLException
1:     {
1:         PreparedStatement ps = prepareStatement( "select * from sys.systables" );
1:         CallableStatement cs = prepareCall( "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)" );
1: 
1:         try {
1:             ps.addBatch( "select * from sys.systables" );
1:             fail( "Oops. ps.addBatch() worked." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:         
1:         try {
1:             cs.addBatch( "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)" );
1:             fail( "Oops. cs.addBatch() worked." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( METHOD_NOT_ALLOWED, se );
1:         }
1:     }
1: 
1: 
============================================================================