1:2bc809f: /*
3:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_XA
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.xa.*;
1:2bc809f: import org.apache.derby.iapi.store.access.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: import org.apache.derby.iapi.services.context.ContextManager;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException; 
1:2bc809f: 
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:2bc809f: import java.util.Properties; 
1:2bc809f: 
1:2bc809f: import javax.transaction.xa.XAResource;
1:2bc809f: import javax.transaction.xa.Xid;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: public class T_XA extends T_Generic
3:2bc809f: {
1:2bc809f:     private static final String testService = "XaTest";
1:2bc809f: 
1:2bc809f:     byte[] global_id = 
1:2bc809f:         { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
1:2bc809f:          10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
1:2bc809f:          20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
1:2bc809f:          30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
1:2bc809f:          40, 41, 42, 44, 44, 45, 46, 47, 48, 49,
1:2bc809f:          50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
1:2bc809f:          60, 61, 62, 63};
1:2bc809f: 
1:2bc809f:     byte[] branch_id = 
1:2bc809f:         { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
1:2bc809f:          10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
1:2bc809f:          20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
1:2bc809f:          30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
1:2bc809f:          40, 41, 42, 44, 44, 45, 46, 47, 48, 49,
1:2bc809f:          50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
1:2bc809f:          60, 61, 62, 63};
1:2bc809f: 
1:2bc809f:     AccessFactory store = null;
1:2bc809f: 
1:2bc809f: 	public T_XA()
1:2bc809f:     {
1:2bc809f: 		super();
2:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods of UnitTest.
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods required by T_Generic
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	public String getModuleToTestProtocolName()
1:2bc809f:     {
1:2bc809f: 		return AccessFactory.MODULE;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 	protected void runTests() throws T_Fail
1:a0dbbd7: 	{
1:2bc809f: 		// Create a AccessFactory to test.
1:2bc809f: 
1:2bc809f: 		// don't automatic boot this service if it gets left around
1:2bc809f: 		if (startParams == null) 
1:a0dbbd7:         {
1:2bc809f: 			startParams = new Properties();
1:2bc809f: 		}
1:2bc809f: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1:2bc809f: 		// remove the service directory to ensure a clean run
1:2bc809f: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1:2bc809f: 
1:2bc809f: 		// see if we are testing encryption
1:2bc809f: 		startParams = T_Util.setEncryptionParam(startParams);
1:2bc809f: 
1:2bc809f: 		try {
1:56c1dc2: 			store = (AccessFactory) createPersistentService(
1:2bc809f: 				getModuleToTestProtocolName(), testService, startParams);
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		if (store == null) 
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 getModuleToTestProtocolName() + " service not started.");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		REPORT("(unitTestMain) Testing " + testService);
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 
1:2bc809f:             XATest_1(new commit_method(store, true));
1:2bc809f:             XATest_2(new commit_method(store, true));
1:2bc809f:             XATest_3(new commit_method(store, true));
1:2bc809f:             XATest_4(new commit_method(store, true));
1:2bc809f:             XATest_5(new commit_method(store, true));
1:2bc809f:             XATest_6(new commit_method(store, true));
1:2bc809f: 
1:2bc809f:             XATest_1(new commit_method(store, false));
1:2bc809f:             XATest_2(new commit_method(store, false));
1:2bc809f:             XATest_3(new commit_method(store, false));
1:2bc809f:             XATest_4(new commit_method(store, false));
1:2bc809f:             XATest_5(new commit_method(store, false));
1:2bc809f:             XATest_6(new commit_method(store, false));
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException e)
1:2bc809f: 		{
1:2bc809f: 			String  msg = e.getMessage();
1:2bc809f: 			if (msg == null)
1:2bc809f: 				msg = e.getClass().getName();
1:2bc809f: 			REPORT(msg);
1:2bc809f:             e.printStackTrace();
1:2bc809f: 			throw T_Fail.exceptionFail(e);
1:2bc809f: 		}
1:2bc809f:         catch (Throwable t)
1:2bc809f:         {
1:2bc809f:             t.printStackTrace();
1:2bc809f:         }
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f:     /**************************************************************************
1:2bc809f:      * Utility methods.
1:2bc809f:      **************************************************************************
1:2bc809f:      */
1:2bc809f: 
1:2bc809f:     /**************************************************************************
1:2bc809f:      * Test Cases.
1:2bc809f:      **************************************************************************
1:2bc809f:      */
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * one phase commit xa transaction.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_1(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_1) starting");
1:2bc809f: 
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         // COMMIT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController) 
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT AN UPDATE ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null,  	//column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT A READ ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		ScanController scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_1) finishing");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * simple two phase commit xa transaction.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_2(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_2) starting");
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         // COMMIT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController) 
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         if (!xa_tc.isGlobal())
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg("should be a global transaction.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // This prepare will commit the idle transaction.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of idle xact did not return XA_RDONLY.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         try 
1:2bc809f:         {
1:2bc809f:             // this should fail as the xact has been committed, so committing
1:2bc809f:             // it in 2 phase mode should fail.  This test can't be run in 
1:2bc809f:             // offline mode, no transaction will be found.  Pass null as
1:2bc809f:             // global_id to make that test not run.
1:2bc809f: 
1:2bc809f:             commit_method.commit(false, 42, null, null, xa_tc);
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact cant be 2P xa_committed.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception - drop through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // should not be able to find this global xact, it has been committed
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:2bc809f:                 new XAXactId(42, global_id, branch_id)) != null)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT AN UPDATE ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f:                 null, 	//column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         // prepare the update xact.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of update xact did not return XA_OK.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT A READ ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		ScanController scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // This prepare will commit the idle transaction.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of idle xact did not return XA_RDONLY.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         try 
1:2bc809f:         {
1:2bc809f:             // this should fail as the xact has been committed, so committing
1:2bc809f:             // it in 2 phase mode should fail.  This test can't be run in 
1:2bc809f:             // offline mode, no transaction will be found.  Pass null as
1:2bc809f:             // global_id to make that test not run.
1:2bc809f: 
1:2bc809f:             commit_method.commit(false, 42, null, null, xa_tc);
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact cant be 2P xa_committed.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception - drop through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // should not be able to find this global xact, it has been committed
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:2bc809f:                 new XAXactId(42, global_id, branch_id)) != null)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_2) finishing");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test aborts of unprepared xa transaction.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_3(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_3) starting");
1:2bc809f: 
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         // ABORT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // ABORT AN UPDATE ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // ABORT A READ ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         template_row = new T_AccessRow(1);
1:2bc809f: 		conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		ScanController scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_3) finishing");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Test aborts of prepared two phase commit xa transaction.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_4(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_4) starting");
1:2bc809f: 
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         // ABORT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         // This prepare will commit the idle transaction.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of idle xact did not return XA_RDONLY.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // nothing to do, will just abort the next current idle xact.
1:2bc809f: 
1:2bc809f:        // after prepare/readonly we cna continue to use transaction   
1:2bc809f: 		commit_method.commit(true, 42, null, null, xa_tc);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // should not be able to find this global xact, it has been committed
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:2bc809f:                 new XAXactId(42, global_id, branch_id)) != null)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // ABORT AN UPDATE ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // Open a scan on the conglomerate, to verify the create happened,
1:2bc809f:         // and to show that the same openScan done after abort fails.
1:2bc809f:         ScanController scan1 = xa_tc.openScan(
1:2bc809f:             conglomid,
1:2bc809f:             false, // don't hold
1:2bc809f:             0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:             (FormatableBitSet) null, // all columns, all as objects
1:2bc809f:             null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f:             null, // qualifier - accept all rows
1:2bc809f:             null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // prepare the update xact.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of update xact did not return XA_OK.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // Open a scan on the conglomerate.
1:2bc809f:             scan1 = xa_tc.openScan(
1:2bc809f:                 conglomid,
1:2bc809f:                 false, // don't hold
1:2bc809f:                 0,     // not for update
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null, // all columns, all as objects
1:2bc809f:                 null, // start position - first row in conglomerate
1:2bc809f:                 0,    // unused if start position is null.
1:2bc809f:                 null, // qualifier - accept all rows
1:2bc809f:                 null, // stop position - last row in conglomerate
1:2bc809f:                 0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:             scan1.next();
1:2bc809f:             scan1.close();
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "Should not be able to do anything on xact after prepare.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception, fall through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         commit_method.commit(true, 42, null, null, xa_tc);
1:2bc809f: 
1:2bc809f:         // should not be able to find this global xact, it has been committed
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:2bc809f:                 new XAXactId(42, global_id, branch_id)) != null)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A xa_rollbacked xact should not be findable.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // Open a scan on the conglomerate.
1:2bc809f:             scan1 = xa_tc.openScan(
1:2bc809f:                 conglomid,
1:2bc809f:                 false, // don't hold
1:2bc809f:                 0,     // not for update
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null, // all columns, all as objects
1:2bc809f:                 null, // start position - first row in conglomerate
1:2bc809f:                 0,    // unused if start position is null.
1:2bc809f:                 null, // qualifier - accept all rows
1:2bc809f:                 null, // stop position - last row in conglomerate
1:2bc809f:                 0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:             scan1.next();
1:2bc809f:             scan1.close();
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "Should not be able to open conglom, the create was aborted.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception, fall through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // ABORT A READ ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         template_row = new T_AccessRow(1);
1:2bc809f: 		conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // This prepare will commit the idle transaction.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of idle xact did not return XA_RDONLY.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, null, null, xa_tc);
1:2bc809f: 
1:2bc809f:         // should not be able to find this global xact, it has been committed
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:2bc809f:                 new XAXactId(42, global_id, branch_id)) != null)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_5) finishing");
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Very simple testing of the recover() call.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_5(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_5) starting");
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions when we first start.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions when we first start.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMNOFLAGS).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg("NOFLAGS should always return 0.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         // COMMIT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one idle global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT AN UPDATE ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // COMMIT A READ ONLY TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		ScanController scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         // commit an idle transaction - using onePhase optimization.
1:2bc809f:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // PREPARE AN UPDATE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         xa_tc = (XATransactionController)
1:2bc809f:             store.startXATransaction(
1:2bc809f:                 cm,
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         template_row = new T_AccessRow(1);
1:2bc809f: 		conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // prepare the update xact.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of update xact did not return XA_OK.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // Open a scan on the conglomerate.
1:2bc809f:             scan1 = xa_tc.openScan(
1:2bc809f:                 conglomid,
1:2bc809f:                 false, // don't hold
1:2bc809f:                 0,     // not for update
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null, // all columns, all as objects
1:2bc809f:                 null, // start position - first row in conglomerate
1:2bc809f:                 0,    // unused if start position is null.
1:2bc809f:                 null, // qualifier - accept all rows
1:2bc809f:                 null, // stop position - last row in conglomerate
1:2bc809f:                 0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:             scan1.next();
1:2bc809f:             scan1.close();
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "Should not be able to do anything on xact after prepare.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception, fall through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         Xid[] prepared_xacts = 
1:2bc809f:             ((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN);
1:2bc809f: 
1:2bc809f:         if (prepared_xacts.length != 1)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned wrong prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (prepared_xacts[0].getFormatId() != 42)
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "bad format id = " + prepared_xacts[0].getFormatId());
1:2bc809f: 
1:2bc809f:         byte[] gid = prepared_xacts[0].getGlobalTransactionId();
1:2bc809f: 
1:2bc809f:         if (!java.util.Arrays.equals(gid, global_id))
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "bad global id = " + org.apache.derbyTesting.unitTests.util.BitUtil.hexDump(gid));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         byte[] bid = prepared_xacts[0].getBranchQualifier();
1:2bc809f: 
1:2bc809f:         if (!java.util.Arrays.equals(bid, branch_id))
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "bad branch id = " + org.apache.derbyTesting.unitTests.util.BitUtil.hexDump(bid));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMNOFLAGS).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg("NOFLAGS should always return 0.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit a prepared transaction - using two phase.
1:2bc809f:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // done with this xact.
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_5) finishing");
1:2bc809f: 
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     /**
1:2bc809f:      * Very simple testing of changing a local transaction to a global.
1:2bc809f:      * <p>
1:2bc809f: 	 * @exception  StandardException  Standard exception policy.
1:2bc809f:      **/
1:2bc809f:     void XATest_6(
1:2bc809f:     commit_method   commit_method)
1:2bc809f:         throws StandardException, T_Fail
1:2bc809f:     {
1:2bc809f:         REPORT("(XATest_5) starting");
1:2bc809f: 
1:2bc809f:         ContextManager cm = 
1:a0dbbd7:                 getContextService().getCurrentContextManager();
1:2bc809f: 
1:2bc809f:         TransactionController   tc = store.getTransaction(cm);
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         T_AccessRow template_row = new T_AccessRow(1);
1:2bc809f: 		long conglomid = 
1:2bc809f:             tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         tc.commit();
1:2bc809f: 
1:2bc809f:         // COMMIT AN IDLE TRANSACTION.
1:2bc809f: 
1:2bc809f:         // Start a global transaction
1:2bc809f:         XATransactionController xa_tc = (XATransactionController)
1:2bc809f:             tc.createXATransactionFromLocalTransaction(
1:2bc809f:                 42, // fake format id
1:2bc809f:                 global_id,
1:2bc809f:                 branch_id);
1:2bc809f: 
1:2bc809f:         if (!xa_tc.isGlobal())
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg("should be a global transaction.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// Open a scan on the conglomerate.
1:2bc809f: 		ScanController scan1 = xa_tc.openScan(
1:2bc809f: 			conglomid,
1:2bc809f: 			false, // don't hold
1:2bc809f: 			0,     // not for update
1:2bc809f:             TransactionController.MODE_RECORD,
1:2bc809f:             TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f: 			(FormatableBitSet) null, // all columns, all as objects
1:2bc809f: 			null, // start position - first row in conglomerate
1:2bc809f:             0,    // unused if start position is null.
1:2bc809f: 			null, // qualifier - accept all rows
1:2bc809f: 			null, // stop position - last row in conglomerate
1:2bc809f:             0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f: 
1:2bc809f:         scan1.next();
1:2bc809f:         scan1.close();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// Create a heap conglomerate.
1:2bc809f:         template_row = new T_AccessRow(1);
1:2bc809f: 		conglomid = 
1:2bc809f:             xa_tc.createConglomerate(
1:2bc809f:                 "heap",       // create a heap conglomerate
1:2bc809f:                 template_row.getRowArray(), // 1 column template.
1:2bc809f: 				null, //column sort order - not required for heap
1:b61f876: 				null,  	//default collation
1:2bc809f:                 null,         // default properties
1:2bc809f:                 TransactionController.IS_DEFAULT);       // not temporary
1:2bc809f: 
1:2bc809f:         // Should be no prepared transactions, there is one update global xact.
1:2bc809f:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:2bc809f:                 XAResource.TMSTARTRSCAN).length != 0)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "recover incorrectly returned prepared xacts.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // prepare the update xact.
1:2bc809f:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:2bc809f:         {
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "prepare of update xact did not return XA_OK.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             // Open a scan on the conglomerate.
1:2bc809f:             scan1 = xa_tc.openScan(
1:2bc809f:                 conglomid,
1:2bc809f:                 false, // don't hold
1:2bc809f:                 0,     // not for update
1:2bc809f:                 TransactionController.MODE_RECORD,
1:2bc809f:                 TransactionController.ISOLATION_SERIALIZABLE,
1:2bc809f:                 (FormatableBitSet) null, // all columns, all as objects
1:2bc809f:                 null, // start position - first row in conglomerate
1:2bc809f:                 0,    // unused if start position is null.
1:2bc809f:                 null, // qualifier - accept all rows
1:2bc809f:                 null, // stop position - last row in conglomerate
1:2bc809f:                 0);   // unused if stop position is null.
1:2bc809f: 
1:2bc809f:             scan1.next();
1:2bc809f:             scan1.close();
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg(
1:2bc809f:                 "Should not be able to do anything on xact after prepare.");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception, fall through.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         // commit a prepared transaction - using two phase.
1:2bc809f:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1:2bc809f: 
1:2bc809f:         xa_tc.destroy();
1:2bc809f: 
1:2bc809f:         REPORT("(XATest_6) finishing");
1:a0dbbd7:     }
1:a0dbbd7: 
1:2bc809f:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Package protected so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:2bc809f: }
1:a0dbbd7: 
1:2bc809f: class commit_method
1:2bc809f: {
1:2bc809f:     private boolean         online_xact;
1:2bc809f:     private AccessFactory   store;
1:2bc809f: 
1:2bc809f:     public commit_method(
1:2bc809f:     AccessFactory   store,
1:2bc809f:     boolean         online_xact)
1:2bc809f:     {
1:2bc809f:         this.store       = store;
1:2bc809f:         this.online_xact = online_xact;
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     public void commit(
1:2bc809f:     boolean                 one_phase,
1:2bc809f:     int                     format_id,
1:2bc809f:     byte[]                  global_id,
1:2bc809f:     byte[]                  branch_id,
1:2bc809f:     XATransactionController xa_tc)
1:2bc809f:         throws StandardException
1:2bc809f:     {
1:2bc809f:         if (SanityManager.DEBUG)
1:2bc809f:             SanityManager.ASSERT((global_id != null) || (xa_tc != null));
1:2bc809f: 
1:2bc809f:         boolean local_online_xact = online_xact;
1:2bc809f: 
1:2bc809f:         if (global_id == null)
1:2bc809f:             local_online_xact = true;
1:2bc809f:         if (xa_tc == null)
1:2bc809f:             local_online_xact = false;
1:2bc809f:             
1:2bc809f:         if (local_online_xact)
1:2bc809f:         {
1:2bc809f:             xa_tc.xa_commit(one_phase);
1:2bc809f:         }
1:a0dbbd7:         else
1:2bc809f:         {
1:2bc809f:             Xid xid = new XAXactId(format_id, global_id, branch_id);
1:2bc809f: 
1:2bc809f:             ContextManager cm = 
1:2bc809f:                 ((XAResourceManager) store.getXAResourceManager()).find(xid);
1:2bc809f: 
1:2bc809f:             if (SanityManager.DEBUG)
1:2bc809f:             {
1:2bc809f:                 SanityManager.ASSERT(cm != null, "could not find xid = " + xid);
1:2bc809f: 
1:2bc809f:                 SanityManager.ASSERT(
1:2bc809f:                     cm == 
1:a0dbbd7:                     T_XA.getContextService().getCurrentContextManager(),
1:2bc809f:                     "cm = " + cm +
1:2bc809f:                     "current = " + 
1:a0dbbd7:                         T_XA.getContextService().getCurrentContextManager());
1:2bc809f:             }
1:2bc809f: 
1:2bc809f:             ((XAResourceManager) store.getXAResourceManager()).commit(
1:2bc809f:                 cm, xid, one_phase);
1:2bc809f:         }
1:2bc809f:     }
1:2bc809f: 
1:2bc809f:     public void rollback(
1:2bc809f:     int                     format_id,
1:2bc809f:     byte[]                  global_id,
1:2bc809f:     byte[]                  branch_id,
1:2bc809f:     XATransactionController xa_tc)
1:2bc809f:         throws StandardException
1:2bc809f:     {
1:2bc809f:         if (SanityManager.DEBUG)
1:2bc809f:             SanityManager.ASSERT((global_id != null) || (xa_tc != null));
1:2bc809f: 
1:2bc809f:         boolean local_online_xact = online_xact;
1:2bc809f: 
1:2bc809f:         if (global_id == null)
1:2bc809f:             local_online_xact = true;
1:2bc809f:         if (xa_tc == null)
1:2bc809f:             local_online_xact = false;
1:2bc809f:             
1:2bc809f:         if (local_online_xact)
1:2bc809f:         {
1:2bc809f:             xa_tc.xa_rollback();
1:2bc809f:         }
2:2bc809f:         else
1:2bc809f:         {
1:2bc809f:             Xid xid = new XAXactId(format_id, global_id, branch_id);
1:2bc809f: 
1:2bc809f:             ContextManager cm = 
1:2bc809f:                 ((XAResourceManager) store.getXAResourceManager()).find(xid);
1:2bc809f: 
1:2bc809f:             if (SanityManager.DEBUG)
1:2bc809f:             {
1:2bc809f:                 SanityManager.ASSERT(cm != null, "could not find xid = " + xid);
1:2bc809f: 
1:2bc809f:                 SanityManager.ASSERT(
1:2bc809f:                     cm == 
1:a0dbbd7:                     T_XA.getContextService().getCurrentContextManager(),
1:2bc809f:                     "cm = " + cm +
1:2bc809f:                     "current = " + 
1:a0dbbd7:                         T_XA.getContextService().getCurrentContextManager());
1:2bc809f:             }
1:2bc809f: 
1:2bc809f:             ((XAResourceManager) store.getXAResourceManager()).rollback(
1:2bc809f:                 cm, xid);
1:2bc809f:         }
1:2bc809f:     }
1:56c1dc2: 
1:2bc809f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 			store = (AccessFactory) createPersistentService(
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                  {
1:                      return ContextService.getFactory();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Object>()
1:                      public Object run()
1:                          throws StandardException
1:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
/////////////////////////////////////////////////////////////////////////
1: 
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Package protected so that user code
1:      * can't call this entry point.
1:      */
1:     static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     T_XA.getContextService().getCurrentContextManager(),
1:                         T_XA.getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:                     T_XA.getContextService().getCurrentContextManager(),
1:                         T_XA.getContextService().getCurrentContextManager());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
/////////////////////////////////////////////////////////////////////////
1: 				null,  	//default collation
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_XA
1: 
0:    Copyright 1999, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.store.access.xa.*;
1: import org.apache.derby.iapi.store.access.*;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
1: import java.util.Properties; 
1: 
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: 
1: public class T_XA extends T_Generic
1: {
1:     private static final String testService = "XaTest";
1: 
1:     byte[] global_id = 
1:         { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
1:          10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
1:          20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
1:          30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
1:          40, 41, 42, 44, 44, 45, 46, 47, 48, 49,
1:          50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
1:          60, 61, 62, 63};
1: 
1:     byte[] branch_id = 
1:         { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
1:          10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
1:          20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
1:          30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
1:          40, 41, 42, 44, 44, 45, 46, 47, 48, 49,
1:          50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
1:          60, 61, 62, 63};
1: 
1:     AccessFactory store = null;
1: 
1: 	public T_XA()
1:     {
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** Methods of UnitTest.
1: 	*/
1: 
1: 	/*
1: 	** Methods required by T_Generic
1: 	*/
1: 
1: 	public String getModuleToTestProtocolName()
1:     {
1: 		return AccessFactory.MODULE;
1: 	}
1: 
1: 	/**
1: 		@exception T_Fail Unexpected behaviour from the API
1: 	 */
1: 
1: 	protected void runTests() throws T_Fail
1: 	{
1: 		// Create a AccessFactory to test.
1: 
1: 		// don't automatic boot this service if it gets left around
1: 		if (startParams == null) 
1:         {
1: 			startParams = new Properties();
1: 		}
1: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1: 		// remove the service directory to ensure a clean run
1: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
1: 		// see if we are testing encryption
1: 		startParams = T_Util.setEncryptionParam(startParams);
1: 
1: 		try {
0: 			store = (AccessFactory) Monitor.createPersistentService(
1: 				getModuleToTestProtocolName(), testService, startParams);
1: 		} catch (StandardException mse) {
1: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 
1: 
1: 		if (store == null) 
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 getModuleToTestProtocolName() + " service not started.");
1: 		}
1: 
1: 		REPORT("(unitTestMain) Testing " + testService);
1: 
1: 		try {
1: 
1:             XATest_1(new commit_method(store, true));
1:             XATest_2(new commit_method(store, true));
1:             XATest_3(new commit_method(store, true));
1:             XATest_4(new commit_method(store, true));
1:             XATest_5(new commit_method(store, true));
1:             XATest_6(new commit_method(store, true));
1: 
1:             XATest_1(new commit_method(store, false));
1:             XATest_2(new commit_method(store, false));
1:             XATest_3(new commit_method(store, false));
1:             XATest_4(new commit_method(store, false));
1:             XATest_5(new commit_method(store, false));
1:             XATest_6(new commit_method(store, false));
1: 		}
1: 		catch (StandardException e)
1: 		{
1: 			String  msg = e.getMessage();
1: 			if (msg == null)
1: 				msg = e.getClass().getName();
1: 			REPORT(msg);
1:             e.printStackTrace();
1: 			throw T_Fail.exceptionFail(e);
1: 		}
1:         catch (Throwable t)
1:         {
1:             t.printStackTrace();
1:         }
1: 	}
1: 
1:     /**************************************************************************
1:      * Utility methods.
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Test Cases.
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * one phase commit xa transaction.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_1(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_1) starting");
1: 
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         // COMMIT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController) 
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT AN UPDATE ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null,  	//column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT A READ ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Open a scan on the conglomerate.
1: 		ScanController scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         REPORT("(XATest_1) finishing");
1:     }
1: 
1:     /**
1:      * simple two phase commit xa transaction.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_2(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_2) starting");
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         // COMMIT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController) 
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         if (!xa_tc.isGlobal())
1:         {
1: 			throw T_Fail.testFailMsg("should be a global transaction.");
1:         }
1: 
1:         // This prepare will commit the idle transaction.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of idle xact did not return XA_RDONLY.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         try 
1:         {
1:             // this should fail as the xact has been committed, so committing
1:             // it in 2 phase mode should fail.  This test can't be run in 
1:             // offline mode, no transaction will be found.  Pass null as
1:             // global_id to make that test not run.
1: 
1:             commit_method.commit(false, 42, null, null, xa_tc);
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact cant be 2P xa_committed.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception - drop through.
1:         }
1: 
1:         // should not be able to find this global xact, it has been committed
1:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:                 new XAXactId(42, global_id, branch_id)) != null)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:         }
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT AN UPDATE ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1:                 null, 	//column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         // prepare the update xact.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of update xact did not return XA_OK.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT A READ ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Open a scan on the conglomerate.
1: 		ScanController scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // This prepare will commit the idle transaction.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of idle xact did not return XA_RDONLY.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         try 
1:         {
1:             // this should fail as the xact has been committed, so committing
1:             // it in 2 phase mode should fail.  This test can't be run in 
1:             // offline mode, no transaction will be found.  Pass null as
1:             // global_id to make that test not run.
1: 
1:             commit_method.commit(false, 42, null, null, xa_tc);
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact cant be 2P xa_committed.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception - drop through.
1:         }
1: 
1:         // should not be able to find this global xact, it has been committed
1:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:                 new XAXactId(42, global_id, branch_id)) != null)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:         }
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         REPORT("(XATest_2) finishing");
1:     }
1: 
1:     /**
1:      * Test aborts of unprepared xa transaction.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_3(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_3) starting");
1: 
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         // ABORT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // ABORT AN UPDATE ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // ABORT A READ ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         template_row = new T_AccessRow(1);
1: 		conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Open a scan on the conglomerate.
1: 		ScanController scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         REPORT("(XATest_3) finishing");
1:     }
1: 
1:     /**
1:      * Test aborts of prepared two phase commit xa transaction.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_4(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_4) starting");
1: 
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         // ABORT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         // This prepare will commit the idle transaction.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of idle xact did not return XA_RDONLY.");
1:         }
1: 
1:         // nothing to do, will just abort the next current idle xact.
1: 
1:        // after prepare/readonly we cna continue to use transaction   
1: 		commit_method.commit(true, 42, null, null, xa_tc);
1: 
1: 
1: 
1:         // should not be able to find this global xact, it has been committed
1:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:                 new XAXactId(42, global_id, branch_id)) != null)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:         }
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // ABORT AN UPDATE ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1: 
1: 
1:         // Open a scan on the conglomerate, to verify the create happened,
1:         // and to show that the same openScan done after abort fails.
1:         ScanController scan1 = xa_tc.openScan(
1:             conglomid,
1:             false, // don't hold
1:             0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1:             (FormatableBitSet) null, // all columns, all as objects
1:             null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1:             null, // qualifier - accept all rows
1:             null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // prepare the update xact.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of update xact did not return XA_OK.");
1:         }
1: 
1:         try
1:         {
1:             // Open a scan on the conglomerate.
1:             scan1 = xa_tc.openScan(
1:                 conglomid,
1:                 false, // don't hold
1:                 0,     // not for update
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null, // all columns, all as objects
1:                 null, // start position - first row in conglomerate
1:                 0,    // unused if start position is null.
1:                 null, // qualifier - accept all rows
1:                 null, // stop position - last row in conglomerate
1:                 0);   // unused if stop position is null.
1: 
1:             scan1.next();
1:             scan1.close();
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "Should not be able to do anything on xact after prepare.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception, fall through.
1:         }
1: 
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.rollback(42, global_id, branch_id, xa_tc);
1: 
1:         commit_method.commit(true, 42, null, null, xa_tc);
1: 
1:         // should not be able to find this global xact, it has been committed
1:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:                 new XAXactId(42, global_id, branch_id)) != null)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "A xa_rollbacked xact should not be findable.");
1:         }
1: 
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         try
1:         {
1:             // Open a scan on the conglomerate.
1:             scan1 = xa_tc.openScan(
1:                 conglomid,
1:                 false, // don't hold
1:                 0,     // not for update
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null, // all columns, all as objects
1:                 null, // start position - first row in conglomerate
1:                 0,    // unused if start position is null.
1:                 null, // qualifier - accept all rows
1:                 null, // stop position - last row in conglomerate
1:                 0);   // unused if stop position is null.
1: 
1:             scan1.next();
1:             scan1.close();
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "Should not be able to open conglom, the create was aborted.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception, fall through.
1:         }
1: 
1:         xa_tc.destroy();
1: 
1: 
1:         // ABORT A READ ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         template_row = new T_AccessRow(1);
1: 		conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         xa_tc.destroy();
1: 
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Open a scan on the conglomerate.
1: 		scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // This prepare will commit the idle transaction.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_RDONLY)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of idle xact did not return XA_RDONLY.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, null, null, xa_tc);
1: 
1:         // should not be able to find this global xact, it has been committed
1:         if (((XAResourceManager) store.getXAResourceManager()).find(
1:                 new XAXactId(42, global_id, branch_id)) != null)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "A XA_RDONLY prepare-committed xact should not be findable.");
1:         }
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         REPORT("(XATest_5) finishing");
1:     }
1: 
1:     /**
1:      * Very simple testing of the recover() call.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_5(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_5) starting");
1: 
1:         // Should be no prepared transactions when we first start.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // Should be no prepared transactions when we first start.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMNOFLAGS).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg("NOFLAGS should always return 0.");
1:         }
1: 
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         // COMMIT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         // Should be no prepared transactions, there is one idle global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT AN UPDATE ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // COMMIT A READ ONLY TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Open a scan on the conglomerate.
1: 		ScanController scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1: 
1:         // commit an idle transaction - using onePhase optimization.
1:         commit_method.commit(true, 42, global_id, branch_id, xa_tc);
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // PREPARE AN UPDATE TRANSACTION.
1: 
1:         // Start a global transaction
1:         xa_tc = (XATransactionController)
1:             store.startXATransaction(
1:                 cm,
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1: 		// Create a heap conglomerate.
1:         template_row = new T_AccessRow(1);
1: 		conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // prepare the update xact.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of update xact did not return XA_OK.");
1:         }
1: 
1:         try
1:         {
1:             // Open a scan on the conglomerate.
1:             scan1 = xa_tc.openScan(
1:                 conglomid,
1:                 false, // don't hold
1:                 0,     // not for update
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null, // all columns, all as objects
1:                 null, // start position - first row in conglomerate
1:                 0,    // unused if start position is null.
1:                 null, // qualifier - accept all rows
1:                 null, // stop position - last row in conglomerate
1:                 0);   // unused if stop position is null.
1: 
1:             scan1.next();
1:             scan1.close();
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "Should not be able to do anything on xact after prepare.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception, fall through.
1:         }
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         Xid[] prepared_xacts = 
1:             ((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN);
1: 
1:         if (prepared_xacts.length != 1)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned wrong prepared xacts.");
1:         }
1: 
1:         if (prepared_xacts[0].getFormatId() != 42)
1: 			throw T_Fail.testFailMsg(
1:                 "bad format id = " + prepared_xacts[0].getFormatId());
1: 
1:         byte[] gid = prepared_xacts[0].getGlobalTransactionId();
1: 
1:         if (!java.util.Arrays.equals(gid, global_id))
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "bad global id = " + org.apache.derbyTesting.unitTests.util.BitUtil.hexDump(gid));
1:         }
1: 
1:         byte[] bid = prepared_xacts[0].getBranchQualifier();
1: 
1:         if (!java.util.Arrays.equals(bid, branch_id))
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "bad branch id = " + org.apache.derbyTesting.unitTests.util.BitUtil.hexDump(bid));
1:         }
1: 
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMNOFLAGS).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg("NOFLAGS should always return 0.");
1:         }
1: 
1:         // commit a prepared transaction - using two phase.
1:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // done with this xact.
1:         xa_tc.destroy();
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         REPORT("(XATest_5) finishing");
1: 
1:     }
1: 
1:     /**
1:      * Very simple testing of changing a local transaction to a global.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void XATest_6(
1:     commit_method   commit_method)
1:         throws StandardException, T_Fail
1:     {
1:         REPORT("(XATest_5) starting");
1: 
1:         ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
1:         TransactionController   tc = store.getTransaction(cm);
1: 
1: 		// Create a heap conglomerate.
1:         T_AccessRow template_row = new T_AccessRow(1);
1: 		long conglomid = 
1:             tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         tc.commit();
1: 
1:         // COMMIT AN IDLE TRANSACTION.
1: 
1:         // Start a global transaction
1:         XATransactionController xa_tc = (XATransactionController)
1:             tc.createXATransactionFromLocalTransaction(
1:                 42, // fake format id
1:                 global_id,
1:                 branch_id);
1: 
1:         if (!xa_tc.isGlobal())
1:         {
1: 			throw T_Fail.testFailMsg("should be a global transaction.");
1:         }
1: 
1: 
1: 		// Open a scan on the conglomerate.
1: 		ScanController scan1 = xa_tc.openScan(
1: 			conglomid,
1: 			false, // don't hold
1: 			0,     // not for update
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_SERIALIZABLE,
1: 			(FormatableBitSet) null, // all columns, all as objects
1: 			null, // start position - first row in conglomerate
1:             0,    // unused if start position is null.
1: 			null, // qualifier - accept all rows
1: 			null, // stop position - last row in conglomerate
1:             0);   // unused if stop position is null.
1: 
1: 
1:         scan1.next();
1:         scan1.close();
1: 
1: 
1: 		// Create a heap conglomerate.
1:         template_row = new T_AccessRow(1);
1: 		conglomid = 
1:             xa_tc.createConglomerate(
1:                 "heap",       // create a heap conglomerate
1:                 template_row.getRowArray(), // 1 column template.
1: 				null, //column sort order - not required for heap
1:                 null,         // default properties
1:                 TransactionController.IS_DEFAULT);       // not temporary
1: 
1:         // Should be no prepared transactions, there is one update global xact.
1:         if (((XAResourceManager) store.getXAResourceManager()).recover(
1:                 XAResource.TMSTARTRSCAN).length != 0)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "recover incorrectly returned prepared xacts.");
1:         }
1: 
1:         // prepare the update xact.
1:         if (xa_tc.xa_prepare() != XATransactionController.XA_OK)
1:         {
1: 			throw T_Fail.testFailMsg(
1:                 "prepare of update xact did not return XA_OK.");
1:         }
1: 
1:         try
1:         {
1:             // Open a scan on the conglomerate.
1:             scan1 = xa_tc.openScan(
1:                 conglomid,
1:                 false, // don't hold
1:                 0,     // not for update
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null, // all columns, all as objects
1:                 null, // start position - first row in conglomerate
1:                 0,    // unused if start position is null.
1:                 null, // qualifier - accept all rows
1:                 null, // stop position - last row in conglomerate
1:                 0);   // unused if stop position is null.
1: 
1:             scan1.next();
1:             scan1.close();
1: 
1: 			throw T_Fail.testFailMsg(
1:                 "Should not be able to do anything on xact after prepare.");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception, fall through.
1:         }
1: 
1:         // commit a prepared transaction - using two phase.
1:         commit_method.commit(false, 42, global_id, branch_id, xa_tc);
1: 
1:         xa_tc.destroy();
1: 
1:         REPORT("(XATest_6) finishing");
1:     }
1: 
1: }
1: 
1: class commit_method
1: {
1:     private boolean         online_xact;
1:     private AccessFactory   store;
1: 
1:     public commit_method(
1:     AccessFactory   store,
1:     boolean         online_xact)
1:     {
1:         this.store       = store;
1:         this.online_xact = online_xact;
1:     }
1: 
1:     public void commit(
1:     boolean                 one_phase,
1:     int                     format_id,
1:     byte[]                  global_id,
1:     byte[]                  branch_id,
1:     XATransactionController xa_tc)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT((global_id != null) || (xa_tc != null));
1: 
1:         boolean local_online_xact = online_xact;
1: 
1:         if (global_id == null)
1:             local_online_xact = true;
1:         if (xa_tc == null)
1:             local_online_xact = false;
1:             
1:         if (local_online_xact)
1:         {
1:             xa_tc.xa_commit(one_phase);
1:         }
1:         else
1:         {
1:             Xid xid = new XAXactId(format_id, global_id, branch_id);
1: 
1:             ContextManager cm = 
1:                 ((XAResourceManager) store.getXAResourceManager()).find(xid);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(cm != null, "could not find xid = " + xid);
1: 
1:                 SanityManager.ASSERT(
1:                     cm == 
0:                     ContextService.getFactory().getCurrentContextManager(),
1:                     "cm = " + cm +
1:                     "current = " + 
0:                         ContextService.getFactory().getCurrentContextManager());
1:             }
1: 
1:             ((XAResourceManager) store.getXAResourceManager()).commit(
1:                 cm, xid, one_phase);
1:         }
1:     }
1: 
1:     public void rollback(
1:     int                     format_id,
1:     byte[]                  global_id,
1:     byte[]                  branch_id,
1:     XATransactionController xa_tc)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT((global_id != null) || (xa_tc != null));
1: 
1:         boolean local_online_xact = online_xact;
1: 
1:         if (global_id == null)
1:             local_online_xact = true;
1:         if (xa_tc == null)
1:             local_online_xact = false;
1:             
1:         if (local_online_xact)
1:         {
1:             xa_tc.xa_rollback();
1:         }
1:         else
1:         {
1:             Xid xid = new XAXactId(format_id, global_id, branch_id);
1: 
1:             ContextManager cm = 
1:                 ((XAResourceManager) store.getXAResourceManager()).find(xid);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(cm != null, "could not find xid = " + xid);
1: 
1:                 SanityManager.ASSERT(
1:                     cm == 
0:                     ContextService.getFactory().getCurrentContextManager(),
1:                     "cm = " + cm +
1:                     "current = " + 
0:                         ContextService.getFactory().getCurrentContextManager());
1:             }
1: 
1:             ((XAResourceManager) store.getXAResourceManager()).rollback(
1:                 cm, xid);
1:         }
1:     }
1: }
============================================================================