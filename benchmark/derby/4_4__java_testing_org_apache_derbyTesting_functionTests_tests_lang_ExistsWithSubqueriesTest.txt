1:0787955: /*
3:0787955:  
1:9247f31:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ExistsWithSubqueriesTest
1:0787955: 
1:0787955:    Licensed to the Apache Software Foundation (ASF) under one or more
1:0787955:    contributor license agreements.  See the NOTICE file distributed with
1:0787955:    this work for additional information regarding copyright ownership.
1:0787955:    The ASF licenses this file to you under the Apache License, Version 2.0
1:0787955:    (the "License"); you may not use this file except in compliance with
1:0787955:    the License.  You may obtain a copy of the License at
1:0787955:  
1:0787955:       http://www.apache.org/licenses/LICENSE-2.0
1:0787955:  
1:0787955:    Unless required by applicable law or agreed to in writing, software
1:0787955:    distributed under the License is distributed on an "AS IS" BASIS,
1:0787955:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0787955:    See the License for the specific language governing permissions and
1:0787955:    limitations under the License.
1:0787955:  
1:0787955:  */
1:0787955: 
1:0787955: package org.apache.derbyTesting.functionTests.tests.lang;
1:0787955: 
1:1ae02c9: import java.sql.PreparedStatement;
1:0787955: import java.sql.ResultSet;
1:0787955: import java.sql.SQLException;
1:0787955: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:0787955: 
1:0787955: /**
1:9247f31:  * This test contains a variety of cases of EXISTS predicates with subqueries.
1:9247f31:  *
1:9247f31:  * Several tests ensure that an EXISTS predicate which wraps a set operation--
1:0787955:  * meaning a UNION, INTERSECT, or EXCEPT node--returns the correct results.
1:0787955:  * For example:
1:0787955:  *
1:0787955:  *   select * from ( values 'BAD' ) as T
1:0787955:  *     where exists ((values 1) intersect (values 2))
1:0787955:  *
1:0787955:  * should return zero rows. Prompted by DERBY-2370.
1:9247f31:  *
1:9247f31:  * A somewhat unrelated test verifies the DERBY-3033 behavior, which
1:9247f31:  * involves flattening of subqueries with NOT EXISTS predicates. The
1:9247f31:  * issue here is that a flattened NOT EXISTS subquery cannot be used
1:9247f31:  * to perform equi-join transitive closure, because the implied predicate
1:9247f31:  * that results from the flattening is a NOT EQUALS condition.
1:0787955:  */
1:9247f31: public class ExistsWithSubqueriesTest extends BaseJDBCTestCase {
1:0787955:     
1:0787955:     private static final String EXISTS_PREFIX_1 =
1:0787955:         "select * from ( values 'GOT_A_ROW' ) as T where exists (";
1:0787955: 
1:0787955:     private static final String EXISTS_PREFIX_2 =
1:0787955:         "select j from onerow where exists (";
1:0787955: 
1:0787955:     /**
1:0787955:      * Create a test with the given name.
1:0787955:      * @param name name of the test.
1:0787955:      *
1:0787955:      */
1:9247f31:     public ExistsWithSubqueriesTest(String name)
1:0787955:     {
1:0787955:         super(name);
1:0787955:     }
1:0787955:     
1:0787955:     /**
1:0787955:      * Return suite with all tests of the class.
1:0787955:      */
1:0787955:     public static Test suite()
1:0787955:     {
1:1ae02c9:        BaseTestSuite suite = new BaseTestSuite("EXISTS with SET operations");
1:0787955: 
1:0787955:         /* This is a language/optimization test so behavior will be the
1:0787955:          * same for embedded and client/server.  Therefore we only need
1:0787955:          * to run the test against one or the other; we choose embedded.
1:0787955:          */
1:0787955:         suite.addTest(
1:9247f31:             TestConfiguration.embeddedSuite(ExistsWithSubqueriesTest.class));
1:0787955: 
1:0787955:         /* Wrap the suite in a CleanDatabaseTestSetup that will create
1:0787955:          * and populate the test tables.
1:0787955:          */
1:0787955:         return new CleanDatabaseTestSetup(suite) 
1:0787955:         {
1:0787955:             /**
1:0787955:             * Create and populate the test table.
1:0787955:             */
1:0787955:             protected void decorateSQL(Statement s) throws SQLException
1:0787955:             {
1:0787955:                 s.executeUpdate("create table empty (i int)"); 
1:0787955:                 s.executeUpdate("create table onerow (j int)");
1:0787955:                 s.executeUpdate("insert into onerow values 2");
1:0787955:                 s.executeUpdate("create table diffrow (k int)");
1:0787955:                 s.executeUpdate("insert into diffrow values 4");
1:0787955:                 s.executeUpdate("create table tworows (p int)");
1:0787955:                 s.executeUpdate("insert into tworows values 2, 4");
1:0787955:                 s.executeUpdate("create table onerow2col (j1 int, j2 int)");
1:0787955:                 s.executeUpdate("insert into onerow2col values (2, 2)");
1:0787955:             }
1:0787955:         };
1:0787955:     }
1:0787955: 
1:0787955:     /**
1:0787955:      * Test queries where the set operation just involves VALUES
1:0787955:      * expressions.
1:0787955:      */
1:0787955:     public void testSetOpsWithVALUES() throws Exception
1:0787955:     {
1:0787955:         Statement st = createStatement();
1:0787955:         String [][] expRS = new String [1][1];
1:0787955: 
1:0787955:         expRS[0][0] = "GOT_A_ROW";
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 union values 1)");
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 intersect values 1)");
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 except values 0)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 + "values 1 intersect values 0)");
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 + "values 1 except values 1)");
1:0787955:         st.close();
1:0787955:     }
1:0787955: 
1:0787955:     /**
1:0787955:      * Test queries where the set operation has subqueries which are not
1:0787955:      * correlated to the outer query.  It's important to check for cases
1:0787955:      * where we have explicit columns _and_ cases where we have "*" because
1:0787955:      * the binding codepaths differ and we want to verify both.
1:0787955:      */
1:0787955:     public void testNonCorrelatedSetOps() throws Exception
1:0787955:     {
1:0787955:         Statement st = createStatement();
1:0787955:         String [][] expRS = new String [1][1];
1:0787955: 
1:0787955:         expRS[0][0] = "GOT_A_ROW";
1:0787955: 
1:0787955:         // Expect 1 row for the following.
1:0787955: 
1:0787955:         // Simple UNION with "*".
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select * from diffrow union select * from onerow)");
1:0787955: 
1:0787955:         // Simple UNION with explicit columns.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select k from diffrow union select j from onerow)");
1:0787955: 
1:0787955:         // Simple INTERSECT with "*".
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select * from diffrow intersect select 4 from onerow)");
1:0787955: 
1:0787955:         // Simple INTERSECT with explicit columns.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select k from diffrow intersect select 4 from onerow)");
1:0787955: 
1:0787955:         // Simple EXCEPT with "*".
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select * from diffrow except select * from onerow)");
1:0787955: 
1:0787955:         // Simple EXCEPT with explicit columns.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "select k from diffrow except select j from onerow)");
1:0787955: 
1:0787955:         // EXCEPT with "*" where left and right children have their
1:0787955:         // own preds.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "(select * from tworows where p = 2) except " +
1:0787955:             "(select * from tworows where p <> 2))");
1:0787955: 
1:0787955:         // INTERSECT with "*" where left and right children have their
1:0787955:         // own preds.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:0787955:             "(select * from tworows where p = 2) intersect " +
1:0787955:             "(select * from tworows where p = 2))");
1:0787955: 
1:0787955:         // Expect 0 rows for the following.  Similar queries to
1:0787955:         // above except modified to return no rows.
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select i from empty union select * from empty)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select * from onerow intersect select * from empty)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select j from onerow intersect select i from empty)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select * from empty except select * from onerow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select i from empty except select j from onerow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select * from onerow intersect select * from diffrow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select j from onerow intersect select k from diffrow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select * from onerow except select * from onerow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "select j from onerow except select j from onerow)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "(select * from tworows where p = 2) intersect " +
1:0787955:             "(select * from tworows where p <> 2))");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:0787955:             "(select * from tworows where p = 2) except " +
1:0787955:             "(select * from tworows where p = 2))");
1:0787955: 
1:0787955:         // Negative cases.  These should fail because "oops" is not
1:0787955:         // a valid column in ONEROW.
1:0787955: 
1:0787955:         assertCompileError("42X04", EXISTS_PREFIX_1 +
1:0787955:             "(select * from onerow where j = 2) intersect " +
1:0787955:             "(select oops from onerow where j <> 2))");
1:0787955: 
1:0787955:         assertCompileError("42X04", EXISTS_PREFIX_1 +
1:0787955:             "(select * from onerow where j = 2) intersect " +
1:0787955:             "(select * from onerow where oops <> 2))");
1:0787955: 
1:0787955:         st.close();
1:0787955:     }
1:0787955: 
1:0787955:     /**
1:0787955:      * Test queries where the set operation has subqueries which are
1:0787955:      * correlated to the outer query.  Subqueries should still be able
1:0787955:      * reference the outer query table and execute without error.
1:0787955:      */
1:0787955:     public void testCorrelatedSetOps() throws Exception
1:0787955:     {
1:0787955:         Statement st = createStatement();
1:0787955:         String [][] expRS = new String [1][1];
1:0787955: 
1:0787955:         // "2" here is the value that was inserted into "onerow".
1:0787955:         expRS[0][0] = "2";
1:0787955:         
1:0787955:         // Expect 1 row for the following.
1:0787955: 
1:0787955:         // Right child of UNION has "*" for RCL and references table
1:0787955:         // from outer query.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select * from diffrow where onerow.j < k)");
1:0787955: 
1:0787955:         // Right child of UNION has qualified "*" for RCL and references
1:0787955:         // table from outer query.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select diffrow.* from diffrow where onerow.j < k)");
1:0787955: 
1:0787955:         // Right child of UNION has explicit RCL and references
1:0787955:         // table from outer query.
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select k from diffrow where onerow.j < k)");
1:0787955: 
1:0787955:         /* Right child of UNION is itself another EXISTS query whose
1:0787955:          * child is another set operator (INTERSECT). The INTERSECT in
1:0787955:          * turn has a right child which references a table from the
1:0787955:          * outer-most query.
1:0787955:          */
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from diffrow intersect " +
1:0787955:             "     select 2 from diffrow where onerow.j < k))");
1:0787955: 
1:0787955:         /* Right child of UNION is itself another EXISTS query whose
1:0787955:          * child is another set operator (INTERSECT). The INTERSECT in
1:0787955:          * turn has a right child which references a table from the
1:0787955:          * outer-most query.  In this one the INTERSECT returns zero
1:0787955:          * rows.
1:0787955:          */
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from empty intersect " +
1:0787955:             "    select 3 from empty where onerow.j < i))");
1:0787955: 
1:0787955:         /* Right child of UNION is itself another EXISTS query whose
1:0787955:          * child is another set operator (INTERSECT). The INTERSECT in
1:0787955:          * turn has a right child which references 1) a table from the
1:0787955:          * outer-most query, and 2) a table from the INTERSECT node's
1:0787955:          * "parent" subquery (i.e. from the UNION's right subquery).
1:0787955:          */
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from onerow2col intersect " +
1:0787955:             "    select 3 from empty where onerow.j < diffrow.k))");
1:0787955: 
1:0787955:         /* Right child of UNION is itself another EXISTS query whose
1:0787955:          * child is another set operator (INTERSECT). The INTERSECT in
1:0787955:          * turn has a right child which references 1) a table from the
1:0787955:          * outer-most query, and 2) a table from the INTERSECT node's
1:0787955:          * "parent" query.  In addition, add another predicate to the
1:0787955:          * UNION's right subquery and make that predicate reference
1:0787955:          * both 1) a table from the outer-most query, and 2) a table
1:0787955:          * in the subquery's own FROM list.  All of this to ensure
1:0787955:          * that binding finds the correct columns at all levels of
1:0787955:          * the query.
1:0787955:          */
1:0787955:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from onerow2col intersect " +
1:0787955:             "    select 3 from empty where onerow.j < k) " +
1:0787955:             "  and (onerow.j < diffrow.k))");
1:0787955: 
1:0787955:         // Expect 0 rows for the following.  Similar queries to
1:0787955:         // above except modified to return no rows.
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where onerow.j > k)");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:0787955:               "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from diffrow intersect " +
1:0787955:             "     select 3 from diffrow where onerow.j < k))");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from empty intersect " +
1:0787955:             "    select 3 from empty where onerow.j < i))");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from onerow2col intersect " +
1:0787955:             "    select 3 from empty where onerow.j < diffrow.k))");
1:0787955: 
1:0787955:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from diffrow where exists " +
1:0787955:             "  (select 2 from onerow2col intersect " +
1:0787955:             "    select 3 from empty where onerow.j < k) " +
1:0787955:             "  and (onerow.j < diffrow.k))");
1:0787955: 
1:0787955:         // Negative cases.
1:0787955: 
1:0787955:         // Should fail because left and right children of the UNION
1:0787955:         // have different RCL sizes. (NOTE: Would have passed prior
1:0787955:         // to DERBY-2370, but that was incorrect).
1:0787955:         assertCompileError("42X58", EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 0 union " +
1:0787955:             "select * from onerow2col where onerow.j < j)");
1:0787955: 
1:0787955:         /* Should fail because there is an explicit subquery ("SELECT *")
1:0787955:          * within the EXISTS query and such a subquery is not allowed to
1:0787955:          * reference outer tables.  So we will be unable to find the
1:0787955:          * column "onerow.j" in this case.
1:0787955:          */
1:0787955:         assertCompileError("42X04", EXISTS_PREFIX_2 +
1:0787955:             "select * from (select 1 from diffrow where 1 = 0 " +
1:0787955:             "union select * from diffrow where onerow.j < k) x)");
1:0787955: 
1:0787955:         /* Should fail because the UNION's right subquery is trying to
1:0787955:          * select from an outer table.  While the subquery is allowed
1:0787955:          * to reference the outer table in expressions, it cannot
1:0787955:          * include the outer table in its RCL.
1:0787955:          */
1:0787955:         assertCompileError("42X10", EXISTS_PREFIX_2 +
1:0787955:             "select 1 from diffrow where 1 = 1 union " +
1:0787955:             "select onerow.* from diffrow where onerow.j < k)");
1:0787955: 
1:0787955:         st.close();
1:0787955:     }
1:0787955: 
1:0787955:     /**
1:0787955:      * Simple helper method to assert the results of the received
1:0787955:      * query.  If the array representing expected results is null
1:0787955:      * then we assert that the query returns no rows.
1:0787955:      */
1:0787955:     private void checkQuery(Statement st, String [][] expRS,
1:0787955:         String query) throws Exception
1:0787955:     {
1:0787955:         ResultSet rs = st.executeQuery(query);
1:0787955:         if (expRS == null)
1:0787955:             JDBC.assertEmpty(rs);
1:0787955:         else
1:0787955:             JDBC.assertFullResultSet(rs, expRS);
1:0787955:         rs.close();
1:0787955:     }
1:9247f31: 
1:9247f31:     /**
1:9247f31:      * Regression test for Derby-3033.
1:9247f31:      *
1:9247f31:      * This method constructs a query with the property that it:
1:9247f31:      * - contains a NOT EXISTS condition against a correlated subquery
1:9247f31:      * - such that if that subquery is flattened, the result is 3 tables
1:9247f31:      *   which all have join predicates on the same key.
1:9247f31:      * The point of the test is that it is *not* correct to construct
1:9247f31:      * a new equijoin predicate between table d3033_a and d3033_c via
1:9247f31:      * transitive closure, because the join condition between d3033_b and
1:9247f31:      * d3033_c is NOT EXISTS.
1:9247f31:      *
1:9247f31:      * In the original bug, the compiler/optimizer erroneously generated
1:9247f31:      * the extra equijoin predicate, which caused NPE exceptions at
1:9247f31:      * runtime due to attempts to reference the non-existent (NOT EXISTS) row.
1:9247f31:      *
1:9247f31:      * So this test succeeds if it gets the right results and no NPE.
1:9247f31:      */
1:9247f31:     public void testDerby3033()
1:9247f31:         throws Exception
1:9247f31:     {
1:9247f31:         setupDerby3033();
1:9247f31: 
1:9247f31:         PreparedStatement pstmt = prepareStatement(
1:9247f31:             "select c1, c2_b " +
1:9247f31:             "from (select distinct st.c1,st.c2_b,dsr.c3_a,st.c3_b " +
1:9247f31:             "      from " +
1:9247f31:             "             d3033_a dsr, " +  // Table order matters here!
1:9247f31:             "             d3033_b st " +
1:9247f31:             "      where dsr.c4_a is null " +
1:9247f31:             "      and   dsr.c2 = ? " +
1:9247f31:             "      and   dsr.c1 = st.c1 " +
1:9247f31:             "      and   not exists ( " +
1:9247f31:             "              select 1 " +
1:9247f31:             "              from d3033_c " +
1:9247f31:             "              where d3033_c.c1 = st.c1 " +
1:9247f31:             "              and   d3033_c.c2 = ? " +
1:9247f31:             "              and   d3033_c.c3_c = ? " +
1:9247f31:             "              ) " +
1:9247f31:             ") temp "
1:9247f31:         );
1:9247f31:  
1:9247f31:         pstmt.setInt(1, 4);
1:9247f31:         pstmt.setInt(2, 4);
1:9247f31:         pstmt.setInt(3, 100);
1:9247f31:  
1:9247f31:         String [][]expected = {
1:9247f31:             { "1", "100" },
1:9247f31:             { "2", "200" },
1:9247f31:             { "3", "300" },
1:9247f31:         };
1:9247f31:         ResultSet rs = pstmt.executeQuery();
1:9247f31:         JDBC.assertFullResultSet(rs, expected);
1:9247f31:         pstmt.close();
1:9247f31:     }
1:9247f31: 
1:9247f31:     /**
1:9247f31:      * Ensure that the #rows statistics are updated
1:9247f31:      */
1:9247f31:     private void updateStats(Statement st, String tName)
1:9247f31:         throws Exception
1:9247f31:     {
1:9247f31:         ResultSet rs = st.executeQuery("select * from " + tName);
1:9247f31:         int numRows = 0;
1:9247f31:         while (rs.next())
1:9247f31:             numRows ++;
1:9247f31:         rs.close();
1:9247f31:     }
1:9247f31: 
1:9247f31:     private void setupDerby3033()
1:9247f31:         throws Exception
1:9247f31:     {
1:9247f31:         // The pattern of inserting the data is fairly important, as we
1:9247f31:         // are going to do a combination of joins between the three tables
1:9247f31:         // and we want both matching data and non-matching data. We load:
1:9247f31:         //
1:9247f31:         // d3033_a      d3033_b       d3033_c
1:9247f31:         // --------     --------      --------
1:9247f31:         //    1            1             1
1:9247f31:         //    2            2             3
1:9247f31:         //    3            3
1:9247f31:         //                 4
1:9247f31:         //
1:9247f31:         // We also load a whole pile of irrelevant data into tables a and c
1:9247f31:         // so that the index becomes relevant in the optimizer's analysis,
1:9247f31:         // then we create some constraints and indexes and delete the rows
1:9247f31:         // from table d3033_c (the NOT EXISTS table).
1:9247f31:         //
1:9247f31:         Statement s = createStatement();
1:9247f31: 
1:9247f31:         s.executeUpdate("create table d3033_a "+
1:9247f31:                         "(c1 int, c2 int, c3_a int, c4_a date)");
1:9247f31:         s.executeUpdate("create table d3033_b "+
1:9247f31:                         "(c1 int primary key not null, c2_b int, c3_b date)");
1:9247f31:         s.executeUpdate("create table d3033_c (c1 int, c2 int, c3_c int)");
1:9247f31:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(1, 4, 10)");
1:9247f31:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(2, 4, 20)");
1:9247f31:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(3, 4, 30)");
1:9247f31:         s.executeUpdate("insert into d3033_b values(1, 100, CURRENT_DATE)");
1:9247f31:         s.executeUpdate("insert into d3033_b values(2, 200, CURRENT_DATE)");
1:9247f31:         s.executeUpdate("insert into d3033_b values(3, 300, CURRENT_DATE)");
1:9247f31:         s.executeUpdate("insert into d3033_b values(4, 400, CURRENT_DATE)");
1:9247f31:         s.executeUpdate("insert into d3033_c values(1, 4, 100)");
1:9247f31:         s.executeUpdate("insert into d3033_c values(3, 4, 100)");
1:9247f31:             
1:9247f31:         PreparedStatement pstmt2 = prepareStatement(
1:9247f31:                 "insert into d3033_a (c1, c2, c3_a) values (?,?,?)");
1:9247f31: 
1:9247f31:         PreparedStatement pstmt = prepareStatement(
1:9247f31:                 "insert into d3033_b (c1, c2_b, c3_b) values (?,?,?)");
1:9247f31: 
1:9247f31:         java.util.Date now = new java.util.Date();
1:9247f31:         java.sql.Timestamp nowTS = new java.sql.Timestamp(now.getTime());
1:9247f31:         for (int i = 0; i < 15; i++)
1:9247f31:         {
1:9247f31:             pstmt.setInt(1, 100+i);
1:9247f31:             pstmt.setInt(2, 100+i);
1:9247f31:             pstmt.setTimestamp(3, nowTS);
1:9247f31:             pstmt.executeUpdate();
1:9247f31: 
1:9247f31:             for (int j = 0; j < 200; j++)
1:9247f31:             {
1:9247f31:                 pstmt2.setInt(1, 1000+j);
1:9247f31:                 pstmt2.setInt(2, 100+i); // note "i" here (FK)
1:9247f31:                 pstmt2.setInt(3, 1000 + (j+1)*10);
1:9247f31:                 pstmt2.executeUpdate();
1:9247f31:             }
1:9247f31:         }
1:9247f31: 
1:9247f31: 
1:9247f31:         s.executeUpdate("alter table d3033_a add constraint " +
1:9247f31:                 "d3033_a_fk foreign key (c2) references d3033_b(c1) " +
1:9247f31:                 "on delete cascade on update no action");
1:9247f31: 
1:9247f31:         s.executeUpdate("alter table d3033_c add constraint " +
1:9247f31:                 "d3033_c_fk foreign key (c1) references d3033_b(c1) " +
1:9247f31:                 "on delete cascade on update no action");
1:9247f31: 
1:9247f31:         s.executeUpdate("delete from d3033_c");
1:9247f31: 
1:9247f31:         // Update the statistics on the 3 tables:
1:9247f31:         updateStats(s, "d3033_a");
1:9247f31:         updateStats(s, "d3033_b");
1:9247f31:         updateStats(s, "d3033_c");
1:9247f31: 
1:9247f31:         s.close();
1:9247f31:     }
1:9247f31: 
1:09c30dd:     /**
1:09c30dd:      * Some EXISTS subqueries (and IN subqueries transformed to EXISTS)
1:09c30dd:      * returned NULL instead of TRUE or FALSE before DERBY-6408. This test
1:09c30dd:      * case verifies the fix.
1:09c30dd:      */
1:09c30dd:     public void testDerby6408() throws SQLException {
1:09c30dd:         setAutoCommit(false);
1:09c30dd:         Statement s = createStatement();
1:09c30dd: 
1:09c30dd:         // This statement used to return only NULLs.
1:09c30dd:         JDBC.assertFullResultSet(
1:09c30dd:                 s.executeQuery("values (exists(select * from empty), "
1:09c30dd:                         + "not exists (select * from empty), "
1:09c30dd:                         + "not (exists (select * from empty)), "
1:09c30dd:                         + "not (not exists (select * from empty)))"),
1:09c30dd:                 new String[][] {{"false", "true", "true", "false" }});
1:09c30dd: 
1:09c30dd:         // This similar statement worked even before the fix.
1:09c30dd:         JDBC.assertFullResultSet(
1:09c30dd:                 s.executeQuery("values (exists(select * from onerow), "
1:09c30dd:                         + "not exists (select * from onerow), "
1:09c30dd:                         + "not (exists (select * from onerow)), "
1:09c30dd:                         + "not (not exists (select * from onerow)))"),
1:09c30dd:                 new String[][] {{"true", "false", "false", "true" }});
1:09c30dd: 
1:09c30dd:         // Now put the same expressions in the SELECT list. Used to return
1:09c30dd:         // only NULLs.
1:09c30dd:         JDBC.assertFullResultSet(
1:09c30dd:                 s.executeQuery("select exists(select * from empty), "
1:09c30dd:                         + "not exists (select * from empty), "
1:09c30dd:                         + "not (exists (select * from empty)), "
1:09c30dd:                         + "not (not exists (select * from empty)) from onerow"),
1:09c30dd:                 new String[][] {{"false", "true", "true", "false" }});
1:09c30dd: 
1:09c30dd:         // Check the returned value when used in a WHERE predicate. All of
1:09c30dd:         // these queries returned one row, but they should return no rows
1:09c30dd:         // because EXISTS shouldn't return null.
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (exists (select * from empty)) is null"));
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (not exists (select * from empty)) is null"));
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (not (not exists (select * from empty))) is null"));
1:09c30dd: 
1:09c30dd:         // The results were correct even before the fix if the subquery
1:09c30dd:         // wasn't empty. Verify that they still are.
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (exists (select * from onerow)) is null"));
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (not exists (select * from onerow)) is null"));
1:09c30dd:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:09c30dd:                 + "where (not (not exists (select * from onerow))) is null"));
1:09c30dd: 
1:09c30dd:         // Similar problems were seen in IN subqueries that were rewritten
1:7dd317b:         // to EXISTS subqueries internally. For example, this query used
1:09c30dd:         // to return NULL.
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("values 1 in (select j from onerow)"), "false");
1:09c30dd: 
1:09c30dd:         // If it should evaluate to TRUE, it worked even before the fix.
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("values 2 in (select j from onerow)"), "true");
1:09c30dd: 
1:87920f7:         // DERBY-6409: Quantified comparisons can also be rewritten to EXISTS,
1:87920f7:         // and these two queries returned wrong results before the fix.
1:87920f7:         JDBC.assertSingleValueResultSet(
1:87920f7:                 s.executeQuery("values 1 > all (select 2 from tworows)"), "false");
1:87920f7:         JDBC.assertSingleValueResultSet(
1:87920f7:                 s.executeQuery("values 1 < all (select 2 from tworows)"), "true");
1:87920f7: 
1:09c30dd:         // Verify that EXISTS works in INSERT and UPDATE.
1:09c30dd:         s.execute("create table d6408(id int generated by default as identity,"
1:09c30dd:                 + " b boolean not null)");
1:09c30dd: 
1:09c30dd:         // This used to fail with
1:09c30dd:         // ERROR 23502: Column 'B'  cannot accept a NULL value.
1:09c30dd:         s.execute("insert into d6408(b) values exists (select * from empty), "
1:09c30dd:                 + "not exists (select * from empty), "
1:09c30dd:                 + "exists (select * from onerow), "
1:09c30dd:                 + "not exists (select * from onerow)");
1:09c30dd: 
1:09c30dd:         JDBC.assertFullResultSet(
1:09c30dd:                 s.executeQuery("select b from d6408 order by id"),
1:09c30dd:                 new String[][] {{"false"}, {"true"}, {"true"}, {"false"}});
1:09c30dd: 
1:09c30dd:         // These used to fail with
1:09c30dd:         // ERROR 23502: Column 'B'  cannot accept a NULL value.
1:09c30dd:         s.execute("update d6408 set b = exists (select * from empty)");
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("select distinct b from d6408"), "false");
1:09c30dd:         s.execute("update d6408 set b = not exists (select * from empty)");
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("select distinct b from d6408"), "true");
1:09c30dd: 
1:09c30dd:         // These passed even before the fix.
1:09c30dd:         s.execute("update d6408 set b = exists (select * from onerow)");
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("select distinct b from d6408"), "true");
1:09c30dd:         s.execute("update d6408 set b = not exists (select * from onerow)");
1:09c30dd:         JDBC.assertSingleValueResultSet(
1:09c30dd:                 s.executeQuery("select distinct b from d6408"), "false");
1:09c30dd:     }
1:0787955: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:        BaseTestSuite suite = new BaseTestSuite("EXISTS with SET operations");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7dd317b
/////////////////////////////////////////////////////////////////////////
1:         // to EXISTS subqueries internally. For example, this query used
commit:87920f7
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6409: Quantified comparisons can also be rewritten to EXISTS,
1:         // and these two queries returned wrong results before the fix.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values 1 > all (select 2 from tworows)"), "false");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values 1 < all (select 2 from tworows)"), "true");
1: 
commit:09c30dd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Some EXISTS subqueries (and IN subqueries transformed to EXISTS)
1:      * returned NULL instead of TRUE or FALSE before DERBY-6408. This test
1:      * case verifies the fix.
1:      */
1:     public void testDerby6408() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         // This statement used to return only NULLs.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("values (exists(select * from empty), "
1:                         + "not exists (select * from empty), "
1:                         + "not (exists (select * from empty)), "
1:                         + "not (not exists (select * from empty)))"),
1:                 new String[][] {{"false", "true", "true", "false" }});
1: 
1:         // This similar statement worked even before the fix.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("values (exists(select * from onerow), "
1:                         + "not exists (select * from onerow), "
1:                         + "not (exists (select * from onerow)), "
1:                         + "not (not exists (select * from onerow)))"),
1:                 new String[][] {{"true", "false", "false", "true" }});
1: 
1:         // Now put the same expressions in the SELECT list. Used to return
1:         // only NULLs.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select exists(select * from empty), "
1:                         + "not exists (select * from empty), "
1:                         + "not (exists (select * from empty)), "
1:                         + "not (not exists (select * from empty)) from onerow"),
1:                 new String[][] {{"false", "true", "true", "false" }});
1: 
1:         // Check the returned value when used in a WHERE predicate. All of
1:         // these queries returned one row, but they should return no rows
1:         // because EXISTS shouldn't return null.
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (exists (select * from empty)) is null"));
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (not exists (select * from empty)) is null"));
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (not (not exists (select * from empty))) is null"));
1: 
1:         // The results were correct even before the fix if the subquery
1:         // wasn't empty. Verify that they still are.
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (exists (select * from onerow)) is null"));
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (not exists (select * from onerow)) is null"));
1:         JDBC.assertEmpty(s.executeQuery("select * from onerow "
1:                 + "where (not (not exists (select * from onerow))) is null"));
1: 
1:         // Similar problems were seen in IN subqueries that were rewritten
0:         // to an EXISTS subqueries internally. For example, this query used
1:         // to return NULL.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values 1 in (select j from onerow)"), "false");
1: 
1:         // If it should evaluate to TRUE, it worked even before the fix.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values 2 in (select j from onerow)"), "true");
1: 
1:         // Verify that EXISTS works in INSERT and UPDATE.
1:         s.execute("create table d6408(id int generated by default as identity,"
1:                 + " b boolean not null)");
1: 
1:         // This used to fail with
1:         // ERROR 23502: Column 'B'  cannot accept a NULL value.
1:         s.execute("insert into d6408(b) values exists (select * from empty), "
1:                 + "not exists (select * from empty), "
1:                 + "exists (select * from onerow), "
1:                 + "not exists (select * from onerow)");
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select b from d6408 order by id"),
1:                 new String[][] {{"false"}, {"true"}, {"true"}, {"false"}});
1: 
1:         // These used to fail with
1:         // ERROR 23502: Column 'B'  cannot accept a NULL value.
1:         s.execute("update d6408 set b = exists (select * from empty)");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select distinct b from d6408"), "false");
1:         s.execute("update d6408 set b = not exists (select * from empty)");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select distinct b from d6408"), "true");
1: 
1:         // These passed even before the fix.
1:         s.execute("update d6408 set b = exists (select * from onerow)");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select distinct b from d6408"), "true");
1:         s.execute("update d6408 set b = not exists (select * from onerow)");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select distinct b from d6408"), "false");
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:9247f31
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ExistsWithSubqueriesTest
/////////////////////////////////////////////////////////////////////////
0: import java.sql.PreparedStatement;
1:  * This test contains a variety of cases of EXISTS predicates with subqueries.
1:  *
1:  * Several tests ensure that an EXISTS predicate which wraps a set operation--
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * A somewhat unrelated test verifies the DERBY-3033 behavior, which
1:  * involves flattening of subqueries with NOT EXISTS predicates. The
1:  * issue here is that a flattened NOT EXISTS subquery cannot be used
1:  * to perform equi-join transitive closure, because the implied predicate
1:  * that results from the flattening is a NOT EQUALS condition.
1: public class ExistsWithSubqueriesTest extends BaseJDBCTestCase {
/////////////////////////////////////////////////////////////////////////
1:     public ExistsWithSubqueriesTest(String name)
/////////////////////////////////////////////////////////////////////////
1:             TestConfiguration.embeddedSuite(ExistsWithSubqueriesTest.class));
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test for Derby-3033.
1:      *
1:      * This method constructs a query with the property that it:
1:      * - contains a NOT EXISTS condition against a correlated subquery
1:      * - such that if that subquery is flattened, the result is 3 tables
1:      *   which all have join predicates on the same key.
1:      * The point of the test is that it is *not* correct to construct
1:      * a new equijoin predicate between table d3033_a and d3033_c via
1:      * transitive closure, because the join condition between d3033_b and
1:      * d3033_c is NOT EXISTS.
1:      *
1:      * In the original bug, the compiler/optimizer erroneously generated
1:      * the extra equijoin predicate, which caused NPE exceptions at
1:      * runtime due to attempts to reference the non-existent (NOT EXISTS) row.
1:      *
1:      * So this test succeeds if it gets the right results and no NPE.
1:      */
1:     public void testDerby3033()
1:         throws Exception
1:     {
1:         setupDerby3033();
1: 
1:         PreparedStatement pstmt = prepareStatement(
1:             "select c1, c2_b " +
1:             "from (select distinct st.c1,st.c2_b,dsr.c3_a,st.c3_b " +
1:             "      from " +
1:             "             d3033_a dsr, " +  // Table order matters here!
1:             "             d3033_b st " +
1:             "      where dsr.c4_a is null " +
1:             "      and   dsr.c2 = ? " +
1:             "      and   dsr.c1 = st.c1 " +
1:             "      and   not exists ( " +
1:             "              select 1 " +
1:             "              from d3033_c " +
1:             "              where d3033_c.c1 = st.c1 " +
1:             "              and   d3033_c.c2 = ? " +
1:             "              and   d3033_c.c3_c = ? " +
1:             "              ) " +
1:             ") temp "
1:         );
1:  
1:         pstmt.setInt(1, 4);
1:         pstmt.setInt(2, 4);
1:         pstmt.setInt(3, 100);
1:  
1:         String [][]expected = {
1:             { "1", "100" },
1:             { "2", "200" },
1:             { "3", "300" },
1:         };
1:         ResultSet rs = pstmt.executeQuery();
1:         JDBC.assertFullResultSet(rs, expected);
1:         pstmt.close();
1:     }
1: 
1:     /**
1:      * Ensure that the #rows statistics are updated
1:      */
1:     private void updateStats(Statement st, String tName)
1:         throws Exception
1:     {
1:         ResultSet rs = st.executeQuery("select * from " + tName);
1:         int numRows = 0;
1:         while (rs.next())
1:             numRows ++;
1:         rs.close();
1:     }
1: 
1:     private void setupDerby3033()
1:         throws Exception
1:     {
1:         // The pattern of inserting the data is fairly important, as we
1:         // are going to do a combination of joins between the three tables
1:         // and we want both matching data and non-matching data. We load:
1:         //
1:         // d3033_a      d3033_b       d3033_c
1:         // --------     --------      --------
1:         //    1            1             1
1:         //    2            2             3
1:         //    3            3
1:         //                 4
1:         //
1:         // We also load a whole pile of irrelevant data into tables a and c
1:         // so that the index becomes relevant in the optimizer's analysis,
1:         // then we create some constraints and indexes and delete the rows
1:         // from table d3033_c (the NOT EXISTS table).
1:         //
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate("create table d3033_a "+
1:                         "(c1 int, c2 int, c3_a int, c4_a date)");
1:         s.executeUpdate("create table d3033_b "+
1:                         "(c1 int primary key not null, c2_b int, c3_b date)");
1:         s.executeUpdate("create table d3033_c (c1 int, c2 int, c3_c int)");
1:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(1, 4, 10)");
1:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(2, 4, 20)");
1:         s.executeUpdate("insert into d3033_a (c1,c2,c3_a) values(3, 4, 30)");
1:         s.executeUpdate("insert into d3033_b values(1, 100, CURRENT_DATE)");
1:         s.executeUpdate("insert into d3033_b values(2, 200, CURRENT_DATE)");
1:         s.executeUpdate("insert into d3033_b values(3, 300, CURRENT_DATE)");
1:         s.executeUpdate("insert into d3033_b values(4, 400, CURRENT_DATE)");
1:         s.executeUpdate("insert into d3033_c values(1, 4, 100)");
1:         s.executeUpdate("insert into d3033_c values(3, 4, 100)");
1:             
1:         PreparedStatement pstmt2 = prepareStatement(
1:                 "insert into d3033_a (c1, c2, c3_a) values (?,?,?)");
1: 
1:         PreparedStatement pstmt = prepareStatement(
1:                 "insert into d3033_b (c1, c2_b, c3_b) values (?,?,?)");
1: 
1:         java.util.Date now = new java.util.Date();
1:         java.sql.Timestamp nowTS = new java.sql.Timestamp(now.getTime());
1:         for (int i = 0; i < 15; i++)
1:         {
1:             pstmt.setInt(1, 100+i);
1:             pstmt.setInt(2, 100+i);
1:             pstmt.setTimestamp(3, nowTS);
1:             pstmt.executeUpdate();
1: 
1:             for (int j = 0; j < 200; j++)
1:             {
1:                 pstmt2.setInt(1, 1000+j);
1:                 pstmt2.setInt(2, 100+i); // note "i" here (FK)
1:                 pstmt2.setInt(3, 1000 + (j+1)*10);
1:                 pstmt2.executeUpdate();
1:             }
1:         }
1: 
1: 
1:         s.executeUpdate("alter table d3033_a add constraint " +
1:                 "d3033_a_fk foreign key (c2) references d3033_b(c1) " +
1:                 "on delete cascade on update no action");
1: 
1:         s.executeUpdate("alter table d3033_c add constraint " +
1:                 "d3033_c_fk foreign key (c1) references d3033_b(c1) " +
1:                 "on delete cascade on update no action");
1: 
1:         s.executeUpdate("delete from d3033_c");
1: 
1:         // Update the statistics on the 3 tables:
1:         updateStats(s, "d3033_a");
1:         updateStats(s, "d3033_b");
1:         updateStats(s, "d3033_c");
1: 
1:         s.close();
1:     }
1: 
author:Army
-------------------------------------------------------------------------------
commit:0787955
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ExistsWithSetOpsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: /**
0:  * This test ensures that an EXISTS predicate which wraps a set operation--
1:  * meaning a UNION, INTERSECT, or EXCEPT node--returns the correct results.
1:  * For example:
1:  *
1:  *   select * from ( values 'BAD' ) as T
1:  *     where exists ((values 1) intersect (values 2))
1:  *
1:  * should return zero rows. Prompted by DERBY-2370.
1:  */
0: public class ExistsWithSetOpsTest extends BaseJDBCTestCase {
1:     
1:     private static final String EXISTS_PREFIX_1 =
1:         "select * from ( values 'GOT_A_ROW' ) as T where exists (";
1: 
1:     private static final String EXISTS_PREFIX_2 =
1:         "select j from onerow where exists (";
1: 
1:     /**
1:      * Create a test with the given name.
1:      * @param name name of the test.
1:      *
1:      */
0:     public ExistsWithSetOpsTest(String name)
1:     {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Return suite with all tests of the class.
1:      */
1:     public static Test suite()
1:     {
0:        TestSuite suite = new TestSuite("EXISTS with SET operations");
1: 
1:         /* This is a language/optimization test so behavior will be the
1:          * same for embedded and client/server.  Therefore we only need
1:          * to run the test against one or the other; we choose embedded.
1:          */
1:         suite.addTest(
0:             TestConfiguration.embeddedSuite(ExistsWithSetOpsTest.class));
1: 
1:         /* Wrap the suite in a CleanDatabaseTestSetup that will create
1:          * and populate the test tables.
1:          */
1:         return new CleanDatabaseTestSetup(suite) 
1:         {
1:             /**
1:             * Create and populate the test table.
1:             */
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {
1:                 s.executeUpdate("create table empty (i int)"); 
1:                 s.executeUpdate("create table onerow (j int)");
1:                 s.executeUpdate("insert into onerow values 2");
1:                 s.executeUpdate("create table diffrow (k int)");
1:                 s.executeUpdate("insert into diffrow values 4");
1:                 s.executeUpdate("create table tworows (p int)");
1:                 s.executeUpdate("insert into tworows values 2, 4");
1:                 s.executeUpdate("create table onerow2col (j1 int, j2 int)");
1:                 s.executeUpdate("insert into onerow2col values (2, 2)");
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * Test queries where the set operation just involves VALUES
1:      * expressions.
1:      */
1:     public void testSetOpsWithVALUES() throws Exception
1:     {
1:         Statement st = createStatement();
1:         String [][] expRS = new String [1][1];
1: 
1:         expRS[0][0] = "GOT_A_ROW";
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 union values 1)");
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 intersect values 1)");
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 + "values 1 except values 0)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 + "values 1 intersect values 0)");
1:         checkQuery(st, null, EXISTS_PREFIX_1 + "values 1 except values 1)");
1:         st.close();
1:     }
1: 
1:     /**
1:      * Test queries where the set operation has subqueries which are not
1:      * correlated to the outer query.  It's important to check for cases
1:      * where we have explicit columns _and_ cases where we have "*" because
1:      * the binding codepaths differ and we want to verify both.
1:      */
1:     public void testNonCorrelatedSetOps() throws Exception
1:     {
1:         Statement st = createStatement();
1:         String [][] expRS = new String [1][1];
1: 
1:         expRS[0][0] = "GOT_A_ROW";
1: 
1:         // Expect 1 row for the following.
1: 
1:         // Simple UNION with "*".
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select * from diffrow union select * from onerow)");
1: 
1:         // Simple UNION with explicit columns.
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select k from diffrow union select j from onerow)");
1: 
1:         // Simple INTERSECT with "*".
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select * from diffrow intersect select 4 from onerow)");
1: 
1:         // Simple INTERSECT with explicit columns.
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select k from diffrow intersect select 4 from onerow)");
1: 
1:         // Simple EXCEPT with "*".
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select * from diffrow except select * from onerow)");
1: 
1:         // Simple EXCEPT with explicit columns.
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "select k from diffrow except select j from onerow)");
1: 
1:         // EXCEPT with "*" where left and right children have their
1:         // own preds.
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "(select * from tworows where p = 2) except " +
1:             "(select * from tworows where p <> 2))");
1: 
1:         // INTERSECT with "*" where left and right children have their
1:         // own preds.
1:         checkQuery(st, expRS, EXISTS_PREFIX_1 +
1:             "(select * from tworows where p = 2) intersect " +
1:             "(select * from tworows where p = 2))");
1: 
1:         // Expect 0 rows for the following.  Similar queries to
1:         // above except modified to return no rows.
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select i from empty union select * from empty)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select * from onerow intersect select * from empty)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select j from onerow intersect select i from empty)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select * from empty except select * from onerow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select i from empty except select j from onerow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select * from onerow intersect select * from diffrow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select j from onerow intersect select k from diffrow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select * from onerow except select * from onerow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "select j from onerow except select j from onerow)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "(select * from tworows where p = 2) intersect " +
1:             "(select * from tworows where p <> 2))");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_1 +
1:             "(select * from tworows where p = 2) except " +
1:             "(select * from tworows where p = 2))");
1: 
1:         // Negative cases.  These should fail because "oops" is not
1:         // a valid column in ONEROW.
1: 
1:         assertCompileError("42X04", EXISTS_PREFIX_1 +
1:             "(select * from onerow where j = 2) intersect " +
1:             "(select oops from onerow where j <> 2))");
1: 
1:         assertCompileError("42X04", EXISTS_PREFIX_1 +
1:             "(select * from onerow where j = 2) intersect " +
1:             "(select * from onerow where oops <> 2))");
1: 
1:         st.close();
1:     }
1: 
1:     /**
1:      * Test queries where the set operation has subqueries which are
1:      * correlated to the outer query.  Subqueries should still be able
1:      * reference the outer query table and execute without error.
1:      */
1:     public void testCorrelatedSetOps() throws Exception
1:     {
1:         Statement st = createStatement();
1:         String [][] expRS = new String [1][1];
1: 
1:         // "2" here is the value that was inserted into "onerow".
1:         expRS[0][0] = "2";
1:         
1:         // Expect 1 row for the following.
1: 
1:         // Right child of UNION has "*" for RCL and references table
1:         // from outer query.
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select * from diffrow where onerow.j < k)");
1: 
1:         // Right child of UNION has qualified "*" for RCL and references
1:         // table from outer query.
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select diffrow.* from diffrow where onerow.j < k)");
1: 
1:         // Right child of UNION has explicit RCL and references
1:         // table from outer query.
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select k from diffrow where onerow.j < k)");
1: 
1:         /* Right child of UNION is itself another EXISTS query whose
1:          * child is another set operator (INTERSECT). The INTERSECT in
1:          * turn has a right child which references a table from the
1:          * outer-most query.
1:          */
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from diffrow intersect " +
1:             "     select 2 from diffrow where onerow.j < k))");
1: 
1:         /* Right child of UNION is itself another EXISTS query whose
1:          * child is another set operator (INTERSECT). The INTERSECT in
1:          * turn has a right child which references a table from the
1:          * outer-most query.  In this one the INTERSECT returns zero
1:          * rows.
1:          */
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from empty intersect " +
1:             "    select 3 from empty where onerow.j < i))");
1: 
1:         /* Right child of UNION is itself another EXISTS query whose
1:          * child is another set operator (INTERSECT). The INTERSECT in
1:          * turn has a right child which references 1) a table from the
1:          * outer-most query, and 2) a table from the INTERSECT node's
1:          * "parent" subquery (i.e. from the UNION's right subquery).
1:          */
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from onerow2col intersect " +
1:             "    select 3 from empty where onerow.j < diffrow.k))");
1: 
1:         /* Right child of UNION is itself another EXISTS query whose
1:          * child is another set operator (INTERSECT). The INTERSECT in
1:          * turn has a right child which references 1) a table from the
1:          * outer-most query, and 2) a table from the INTERSECT node's
1:          * "parent" query.  In addition, add another predicate to the
1:          * UNION's right subquery and make that predicate reference
1:          * both 1) a table from the outer-most query, and 2) a table
1:          * in the subquery's own FROM list.  All of this to ensure
1:          * that binding finds the correct columns at all levels of
1:          * the query.
1:          */
1:         checkQuery(st, expRS, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from onerow2col intersect " +
1:             "    select 3 from empty where onerow.j < k) " +
1:             "  and (onerow.j < diffrow.k))");
1: 
1:         // Expect 0 rows for the following.  Similar queries to
1:         // above except modified to return no rows.
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where onerow.j > k)");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:               "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from diffrow intersect " +
1:             "     select 3 from diffrow where onerow.j < k))");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from empty intersect " +
1:             "    select 3 from empty where onerow.j < i))");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from onerow2col intersect " +
1:             "    select 3 from empty where onerow.j < diffrow.k))");
1: 
1:         checkQuery(st, null, EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from diffrow where exists " +
1:             "  (select 2 from onerow2col intersect " +
1:             "    select 3 from empty where onerow.j < k) " +
1:             "  and (onerow.j < diffrow.k))");
1: 
1:         // Negative cases.
1: 
1:         // Should fail because left and right children of the UNION
1:         // have different RCL sizes. (NOTE: Would have passed prior
1:         // to DERBY-2370, but that was incorrect).
1:         assertCompileError("42X58", EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 0 union " +
1:             "select * from onerow2col where onerow.j < j)");
1: 
1:         /* Should fail because there is an explicit subquery ("SELECT *")
1:          * within the EXISTS query and such a subquery is not allowed to
1:          * reference outer tables.  So we will be unable to find the
1:          * column "onerow.j" in this case.
1:          */
1:         assertCompileError("42X04", EXISTS_PREFIX_2 +
1:             "select * from (select 1 from diffrow where 1 = 0 " +
1:             "union select * from diffrow where onerow.j < k) x)");
1: 
1:         /* Should fail because the UNION's right subquery is trying to
1:          * select from an outer table.  While the subquery is allowed
1:          * to reference the outer table in expressions, it cannot
1:          * include the outer table in its RCL.
1:          */
1:         assertCompileError("42X10", EXISTS_PREFIX_2 +
1:             "select 1 from diffrow where 1 = 1 union " +
1:             "select onerow.* from diffrow where onerow.j < k)");
1: 
1:         st.close();
1:     }
1: 
1:     /**
1:      * Simple helper method to assert the results of the received
1:      * query.  If the array representing expected results is null
1:      * then we assert that the query returns no rows.
1:      */
1:     private void checkQuery(Statement st, String [][] expRS,
1:         String query) throws Exception
1:     {
1:         ResultSet rs = st.executeQuery(query);
1:         if (expRS == null)
1:             JDBC.assertEmpty(rs);
1:         else
1:             JDBC.assertFullResultSet(rs, expRS);
1:         rs.close();
1:     }
1: }
============================================================================