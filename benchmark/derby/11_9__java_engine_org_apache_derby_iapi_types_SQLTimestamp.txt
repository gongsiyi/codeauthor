2:eac0369: /*
1:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLTimestamp
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.db.DatabaseContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369:  
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:534b037: import java.sql.PreparedStatement;
1:eac0369: 
1:eac0369: import java.util.Calendar;
1:eac0369: import java.util.GregorianCalendar;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.text.DateFormat;
1:eac0369: import java.text.ParseException;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This contains an instance of a SQL Timestamp object.
1:eac0369:  * <p>
1:eac0369:  * SQLTimestamp is stored in 3 ints - an encoded date, an encoded time and
1:eac0369:  *		nanoseconds
1:eac0369:  * encodedDate = 0 indicates a null WSCTimestamp
1:eac0369:  *
1:eac0369:  * SQLTimestamp is similar to SQLTimestamp, but it does conserves space by not keeping a GregorianCalendar object
1:eac0369:  *
1:eac0369:  * PERFORMANCE OPTIMIZATION:
1:eac0369:  *	We only instantiate the value field when required due to the overhead of the
1:eac0369:  *	Date methods.
1:eac0369:  *	Thus, use isNull() instead of "value == null" and
1:eac0369:  *	getTimestamp() instead of using value directly.
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class SQLTimestamp extends DataType
1:eac0369: 						implements DateTimeDataValue
1:eac0369: {
1:eac0369: 
1:c13beb1:     static final int MAX_FRACTION_DIGITS = 9; // Only nanosecond resolution on conversion to/from strings
1:c13beb1:     static final int FRACTION_TO_NANO = 1; // 10**(9 - MAX_FRACTION_DIGITS)
1:eac0369: 
1:d365a22:     static final int ONE_BILLION = 1000000000;
1:eac0369:     
1:eac0369: 	private int	encodedDate;
1:eac0369: 	private int	encodedTime;
1:eac0369: 	private int	nanos;
1:eac0369: 	/*
1:eac0369: 	** DataValueDescriptor interface
1:eac0369: 	** (mostly implemented in DataType)
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTimestamp.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:320f6af:         int sz = BASE_MEMORY_USAGE;
1:eac0369:         return sz;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369: 	public String getString()
1:eac0369: 	{
1:eac0369: 		if (!isNull())
1:eac0369: 		{
1:320f6af:             String valueString = getTimestamp((Calendar) null).toString();
1:320f6af:             /* The java.sql.Timestamp.toString() method is supposed to return a string in
1:320f6af:              * the JDBC escape format. However the JDK 1.3 libraries truncate leading zeros from
1:320f6af:              * the year. This is not acceptable to DB2. So add leading zeros if necessary.
1:320f6af:              */
1:320f6af:             int separatorIdx = valueString.indexOf('-');
1:320f6af:             if (separatorIdx >= 0 && separatorIdx < 4)
1:320f6af:             {
1:320f6af:                 StringBuffer sb = new StringBuffer();
1:320f6af:                 for( ; separatorIdx < 4; separatorIdx++)
1:320f6af:                     sb.append('0');
1:320f6af:                 sb.append(valueString);
1:320f6af:                 valueString = sb.toString();
1:320f6af:             }
1:eac0369: 
1:eac0369: 			return valueString;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		getDate returns the date portion of the timestamp
1:eac0369: 		Time is set to 00:00:00.0
1:eac0369: 		Since Date is a JDBC object we use the JDBC definition
1:eac0369: 		for the time portion.  See JDBC API Tutorial, 47.3.12.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public Date	getDate( Calendar cal) throws StandardException
1:eac0369: 	{
2:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:a57602b: 
3:eac0369:         if( cal == null)
2:eac0369:             cal = new GregorianCalendar();
1:a57602b:         
1:a57602b:         // Will clear all the other fields to zero
1:a57602b:         // that we require at zero, specifically
1:a57602b:         // HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND
1:0c7cafc:         cal.clear();
1:a57602b:         
1:a57602b:         SQLDate.setDateInCalendar(cal, encodedDate);
1:a57602b: 
1:a57602b: 		return new Date(cal.getTimeInMillis());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		getTime returns the time portion of the timestamp
1:eac0369: 		Date is set to 1970-01-01
1:eac0369: 		Since Time is a JDBC object we use the JDBC definition
1:eac0369: 		for the date portion.  See JDBC API Tutorial, 47.3.12.
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public Time	getTime( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369:         
1:a57602b:         // Derby's SQL TIMESTAMP type supports resolution
1:a57602b:         // to nano-seconds so ensure the Time object
1:a57602b:         // maintains that since it has milli-second
1:a57602b:         // resolutiuon.
1:a57602b:         return SQLTime.getTime(cal, encodedTime, nanos);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object getObject()
1:eac0369: 	{
1:eac0369: 		return getTimestamp((Calendar) null);
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/* get storage length */
1:eac0369: 	public int getLength()
1:eac0369: 	{
1:eac0369: 		return 12;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* this is for DataType's error generator */
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return "TIMESTAMP";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_TIMESTAMP_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		@exception IOException error writing data
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException {
1:eac0369: 
7:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Timestamp is written out 3 ints, encoded date, encoded time, and
1:eac0369: 		** nanoseconds
1:eac0369: 		*/
1:eac0369: 		out.writeInt(encodedDate);
1:eac0369: 		out.writeInt(encodedTime);
1:eac0369: 		out.writeInt(nanos);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on error reading the object
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException
1:eac0369: 	{
2:eac0369: 		encodedDate = in.readInt();
2:eac0369: 		encodedTime = in.readInt();
2:eac0369: 		nanos = in.readInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10: 	/** @see DataValueDescriptor#cloneValue */
1:854dd10: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		// Call constructor with all of our info
1:eac0369: 		return new SQLTimestamp(encodedDate, encodedTime, nanos);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new SQLTimestamp();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		// clear numeric representation
1:eac0369: 		encodedDate = 0;
1:eac0369: 		encodedTime = 0;
1:eac0369: 		nanos = 0;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException, StandardException
1:eac0369: 	{
1:eac0369: 			setValue(resultSet.getTimestamp(colNumber), (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int compare(DataValueDescriptor other)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = other.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull	return
1:eac0369: 		 *	T		T		 	0	(this == other)
1:eac0369: 		 *	F		T		 	-1 	(this < other)
1:eac0369: 		 *	T		F		 	1	(this > other)
1:eac0369: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
1:eac0369: 				return -1;
1:eac0369: 			if (!otherNull)		// thisNull must be true
1:eac0369: 				return 1;
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			Neither are null compare them 
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int comparison;
1:eac0369: 		/* get the comparison date values */
1:eac0369: 		int otherEncodedDate = 0;
1:eac0369: 		int otherEncodedTime = 0;
1:eac0369: 		int otherNanos = 0;
1:eac0369: 
1:eac0369: 		/* if the argument is another SQLTimestamp, look up the value
1:eac0369: 		 */
1:eac0369: 		if (other instanceof SQLTimestamp)
1:eac0369: 		{
1:eac0369: 			SQLTimestamp st = (SQLTimestamp)other;
1:eac0369: 			otherEncodedDate= st.encodedDate;
1:eac0369: 			otherEncodedTime= st.encodedTime;
1:eac0369: 			otherNanos= st.nanos;
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			/* O.K. have to do it the hard way and calculate the numeric value
1:eac0369: 			 * from the value
1:eac0369: 			 */
1:eac0369: 			Calendar cal = new GregorianCalendar();
1:eac0369: 			Timestamp otherts = other.getTimestamp(cal);
1:eac0369: 			otherEncodedDate = SQLTimestamp.computeEncodedDate(otherts, cal);
1:eac0369: 			otherEncodedTime = SQLTimestamp.computeEncodedTime(otherts, cal);
1:eac0369: 			otherNanos = otherts.getNanos();
1:eac0369: 		}
1:eac0369: 		if (encodedDate < otherEncodedDate)
1:eac0369: 			comparison = -1;
1:eac0369: 		else if (encodedDate > otherEncodedDate)
1:eac0369: 			comparison = 1;
1:eac0369: 		else if (encodedTime < otherEncodedTime)
1:eac0369: 			comparison = -1;
1:eac0369: 		else if (encodedTime > otherEncodedTime)
1:eac0369: 			comparison = 1;
1:eac0369: 		else if (nanos < otherNanos)
1:eac0369: 			comparison = -1;
1:eac0369: 		else if (nanos > otherNanos)
1:eac0369: 			comparison = 1;
1:eac0369: 		else
1:eac0369: 			comparison = 0;
1:eac0369: 
1:eac0369: 		return comparison;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || ((DataValueDescriptor)other).isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/** no-arg constructor required by Formattable */
1:eac0369: 	public SQLTimestamp() { }
1:eac0369: 
1:531b469:     /**
1:531b469:      * Create a new SQLTimestamp instance that represents the specified
1:531b469:      * Timestamp in the time zone of the given Calendar.
1:531b469:      * @param value the Timestamp value to be represented by this instance
1:531b469:      * @param cal the time zone of the calendar is used to construct the
1:531b469:      * database timestamp value
1:531b469:      * @throws StandardException if an error occurs
1:531b469:      */
1:531b469:     public SQLTimestamp(Timestamp value, Calendar cal) throws StandardException
1:531b469:     {
1:531b469:         setValue(value, cal);
1:531b469:     }
1:eac0369: 
1:531b469:     /**
1:531b469:      * Create a new SQLTimestamp instance that represents the specified
1:531b469:      * Timestamp in the local time zone.
1:531b469:      * @param value the Timestamp value to be represented by this instance
1:531b469:      * @throws StandardException if an error occurs
1:531b469:      */
1:eac0369: 	public SQLTimestamp(Timestamp value) throws StandardException
1:eac0369: 	{
1:531b469:         this(value, (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:d365a22: 	SQLTimestamp(int encodedDate, int encodedTime, int nanos) {
1:eac0369: 
1:eac0369: 		this.encodedDate = encodedDate;
1:eac0369: 		this.encodedTime = encodedTime;
1:eac0369: 		this.nanos = nanos;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public SQLTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
1:eac0369:     {
1:eac0369:         Calendar cal = null;
1:eac0369:         if( date == null || date.isNull()
1:eac0369:             || time == null || time.isNull())
1:eac0369:             return;
1:eac0369:         if( date instanceof SQLDate)
1:eac0369:         {
1:eac0369:             SQLDate sqlDate = (SQLDate) date;
1:eac0369:             encodedDate = sqlDate.getEncodedDate();
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             cal = new GregorianCalendar();
1:eac0369:             encodedDate = computeEncodedDate( date.getDate( cal), cal);
1:eac0369:         }
1:eac0369:         if( time instanceof SQLTime)
1:eac0369:         {
1:eac0369:             SQLTime sqlTime = (SQLTime) time;
1:eac0369:             encodedTime = sqlTime.getEncodedTime();
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if( cal == null)
1:eac0369:                 cal = new GregorianCalendar();
1:eac0369:             encodedTime = computeEncodedTime( time.getTime( cal), cal);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a timestamp from a string. The allowed formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
1:eac0369:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
1:eac0369:      *</ol>
1:eac0369:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
1:eac0369:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
1:eac0369:      */
1:eac0369:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseTimestamp( timestampStr, isJDBCEscape,localeFinder, (Calendar) null);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a timestamp from a string. The allowed formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
1:eac0369:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
1:eac0369:      *</ol>
1:eac0369:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
1:eac0369:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
1:eac0369:      */
1:eac0369:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseTimestamp( timestampStr, isJDBCEscape, localeFinder, cal);
1:eac0369:     }
1:eac0369: 
1:eac0369:     static final char DATE_SEPARATOR = '-';
1:eac0369:     private static final char[] DATE_SEPARATORS = { DATE_SEPARATOR};
1:eac0369:     private static final char IBM_DATE_TIME_SEPARATOR = '-';
1:eac0369:     private static final char ODBC_DATE_TIME_SEPARATOR = ' ';
1:eac0369:     private static final char[] DATE_TIME_SEPARATORS = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR};
1:eac0369:     private static final char[] DATE_TIME_SEPARATORS_OR_END
1:eac0369:     = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR, (char) 0};
1:eac0369:     private static final char IBM_TIME_SEPARATOR = '.';
1:eac0369:     private static final char ODBC_TIME_SEPARATOR = ':';
1:eac0369:     private static final char[] TIME_SEPARATORS = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR};
1:eac0369:     private static final char[] TIME_SEPARATORS_OR_END = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR, (char) 0};
1:eac0369:     private static final char[] END_OF_STRING = {(char) 0};
1:eac0369:     
1:eac0369:     private void parseTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         StandardException thrownSE = null;
1:eac0369:         DateTimeParser parser = new DateTimeParser( timestampStr);
1:eac0369:         try
1:eac0369:         {
1:eac0369:             int[] dateTimeNano = parseDateOrTimestamp( parser, true);
1:eac0369:             encodedDate = dateTimeNano[0];
1:eac0369:             encodedTime = dateTimeNano[1];
1:eac0369:             nanos = dateTimeNano[2];
1:eac0369:             return;
1:eac0369:         }
1:eac0369:         catch( StandardException se)
1:eac0369:         {
1:eac0369:             thrownSE = se;
1:eac0369:         }
1:eac0369:         // see if it is a localized timestamp
1:eac0369:         try
1:eac0369:         {
1:eac0369:             timestampStr = StringUtil.trimTrailing( timestampStr);
1:eac0369:             int[] dateAndTime = parseLocalTimestamp( timestampStr, localeFinder, cal);
1:eac0369:             encodedDate = dateAndTime[0];
1:eac0369:             encodedTime = dateAndTime[1];
1:eac0369:             return;
1:eac0369:         }
1:eac0369:         catch( ParseException pe){}
1:eac0369:         catch( StandardException se){}
1:eac0369:         if( thrownSE != null)
1:eac0369:             throw thrownSE;
1:eac0369:         throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:eac0369:     } // end of parseTimestamp
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Parse a localized timestamp.
1:eac0369:      *
1:eac0369:      * @param str the timestamp string, with trailing blanks removed.
1:6b50965:      * @param localeFinder
1:eac0369:      *
1:eac0369:      * @return a {encodedDate, encodedTime} array.
1:eac0369:      *
1:eac0369:      * @exception ParseException If the string is not a valid timestamp.
1:eac0369:      */
1:eac0369:     static int[] parseLocalTimestamp( String str, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException, ParseException
1:eac0369:     {
1:eac0369:         DateFormat timestampFormat = null;
1:eac0369:         if(localeFinder == null)
1:eac0369:             timestampFormat = DateFormat.getDateTimeInstance();
1:eac0369:         else if( cal == null)
1:eac0369:             timestampFormat = localeFinder.getTimestampFormat();
1:eac0369:         else
1:eac0369:             timestampFormat = (DateFormat) localeFinder.getTimestampFormat().clone();
1:eac0369:         if( cal == null)
1:eac0369:             cal = new GregorianCalendar();
1:eac0369:         else
1:eac0369:             timestampFormat.setCalendar( cal);
1:eac0369:         java.util.Date date = timestampFormat.parse( str);
1:eac0369:             
1:eac0369:         return new int[] { computeEncodedDate( date, cal), computeEncodedTime( date, cal)};
1:eac0369:     } // end of parseLocalTimestamp
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Parse a timestamp or a date. DB2 allows timestamps to be used as dates or times. So
1:eac0369:      * date('2004-04-15-16.15.32') is valid, as is date('2004-04-15').
1:eac0369:      *
1:eac0369:      * This method does not handle localized timestamps.
1:eac0369:      *
1:eac0369:      * @param parser a DateTimeParser initialized with a string.
1:eac0369:      * @param timeRequired If true then an error will be thrown if the time is missing. If false then the time may
1:eac0369:      *                     be omitted.
1:eac0369:      *
1:eac0369:      * @return {encodedDate, encodedTime, nanosecond} array.
1:eac0369:      *
1:eac0369:      * @exception StandardException if the syntax is incorrect for an IBM standard timestamp.
1:eac0369:      */
1:eac0369:     static int[] parseDateOrTimestamp( DateTimeParser parser, boolean timeRequired)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         int year = parser.parseInt( 4, false, DATE_SEPARATORS, false);
1:eac0369:         int month = parser.parseInt( 2, true, DATE_SEPARATORS, false);
1:eac0369:         int day = parser.parseInt( 2, true, timeRequired ? DATE_TIME_SEPARATORS : DATE_TIME_SEPARATORS_OR_END, false);
1:eac0369:         int hour = 0;
1:eac0369:         int minute = 0;
1:eac0369:         int second = 0;
1:eac0369:         int nano = 0;
1:eac0369:         if( parser.getCurrentSeparator() != 0)
1:eac0369:         {
1:eac0369:             char timeSeparator = (parser.getCurrentSeparator() == ODBC_DATE_TIME_SEPARATOR)
1:eac0369:               ? ODBC_TIME_SEPARATOR : IBM_TIME_SEPARATOR;
1:eac0369:             hour = parser.parseInt( 2, true, TIME_SEPARATORS, false);
1:eac0369:             if( timeSeparator == parser.getCurrentSeparator())
1:eac0369:             {
1:eac0369:                 minute = parser.parseInt( 2, false, TIME_SEPARATORS, false);
1:eac0369:                 if( timeSeparator == parser.getCurrentSeparator())
1:eac0369:                 {
1:eac0369:                     second = parser.parseInt( 2, false, TIME_SEPARATORS_OR_END, false);
1:eac0369:                     if( parser.getCurrentSeparator() == '.')
1:eac0369:                         nano = parser.parseInt( MAX_FRACTION_DIGITS, true, END_OF_STRING, true)*FRACTION_TO_NANO;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         parser.checkEnd();
1:eac0369:         return new int[] { SQLDate.computeEncodedDate( year, month, day),
1:eac0369:                            SQLTime.computeEncodedTime( hour,minute,second),
1:eac0369:                            nano};
1:eac0369:     } // end of parseDateOrTimestamp
1:eac0369: 
1:eac0369: 	/**
1:806114c: 	 * Set the value from a correctly typed Timestamp object.
1:806114c: 	 * @throws StandardException 
1:eac0369: 	 */
1:806114c: 	void setObject(Object theValue) throws StandardException
1:eac0369: 	{
1:806114c: 		setValue((Timestamp) theValue);
1:eac0369: 	}
1:806114c: 	
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:eac0369: 		if (theValue instanceof SQLTimestamp) {
2:eac0369: 			restoreToNull();
1:eac0369: 			SQLTimestamp tvst = (SQLTimestamp) theValue;
1:eac0369: 			encodedDate = tvst.encodedDate;
1:eac0369: 			encodedTime = tvst.encodedTime;
1:eac0369: 			nanos = tvst.nanos;
1:eac0369:         }
1:eac0369: 		else
1:eac0369:         {
1:eac0369:             Calendar cal = new GregorianCalendar();
1:eac0369: 			setValue(theValue.getTimestamp( cal), cal);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 		When converting from a date to a timestamp, time is set to 00:00:00.0
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369:         if( value != null)
1:eac0369:         {
1:eac0369:             if( cal == null)
1:eac0369:                 cal = new GregorianCalendar();
1:eac0369:             encodedDate = computeEncodedDate(value, cal);
1:eac0369:         }
1:eac0369: 		/* encodedTime and nanos are already set to zero by restoreToNull() */
1:eac0369: 	}
1:eac0369:     
1:eac0369:     
1:eac0369: 	/**
1:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp value, Calendar cal) 
1:eac0369: 	    throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 		setNumericTimestamp(value, cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setValue(String theValue)
1:eac0369: 	    throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 
1:eac0369: 		if (theValue != null)
1:eac0369: 		{
1:a0dbbd7:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
1:eac0369:             parseTimestamp( theValue,
1:eac0369:                             false,
1:eac0369:                             (databaseContext == null) ? null : databaseContext.getDatabase(),
1:eac0369:                             (Calendar) null);
1:eac0369: 		}
1:eac0369: 		/* restoreToNull will have already set the encoded date to 0 (null value) */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:985f758:     NumberDataValue nullValueInt() {
1:985f758:         return new SQLInteger();
1:eac0369:     }
1:eac0369: 
1:985f758:     NumberDataValue nullValueDouble() {
1:985f758:         return new SQLDouble();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getYear
1:eac0369: 	 * 
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getYear(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(SQLDate.getYear(encodedDate), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMonth
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMonth(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(SQLDate.getMonth(encodedDate), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getDate
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getDate(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(SQLDate.getDay(encodedDate), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getHours
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getHours(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(SQLTime.getHour(encodedTime), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMinutes
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMinutes(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(SQLTime.getMinute(encodedTime), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getSeconds
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getSeconds(NumberDataValue source)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source == null || source instanceof SQLDouble,
1:eac0369: 		"getSeconds for a timestamp was given a source other than a SQLDouble");
1:eac0369: 		}
1:eac0369: 		NumberDataValue result;
1:eac0369: 
1:985f758:         if (isNull()) {
1:985f758:             return nullValueDouble();
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (source != null)
1:eac0369: 			result = source;
1:eac0369: 		else
1:eac0369: 			result = new SQLDouble();
1:eac0369: 
1:eac0369: 		result.setValue((double)(SQLTime.getSecond(encodedTime))
1:eac0369: 				+ ((double)nanos)/1.0e9);
1:eac0369: 
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** String display of value
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return "NULL";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getTimestamp( (Calendar) null).toString();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return  encodedDate + encodedTime + nanos; //since 0 is null
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int	typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.TIMESTAMP_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check if the value is null.  encodedDate value of 0 is null
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not value is logically null.
1:eac0369: 	 */
1:eac0369: 	public final boolean isNull()
1:eac0369: 	{
1:eac0369: 		return (encodedDate == 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the value field.  We instantiate the field
1:eac0369: 	 * on demand.
1:eac0369: 	 *
1:eac0369: 	 * @return	The value field.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getTimestamp(java.util.Calendar cal)
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369: 
1:a57602b:         if (cal == null)
1:a57602b:             cal = new GregorianCalendar();
1:a57602b:         setCalendar(cal);
1:a57602b: 		Timestamp t = new Timestamp(cal.getTimeInMillis());
1:eac0369: 		t.setNanos(nanos);
1:eac0369: 		return t;
1:eac0369: 	}
1:a57602b: 
1:a57602b:     private void setCalendar(Calendar cal)
1:eac0369:     {
1:0c7cafc:         cal.clear();
1:a57602b:         
1:a57602b:         SQLDate.setDateInCalendar(cal, encodedDate);
1:eac0369:         
1:a57602b:         SQLTime.setTimeInCalendar(cal, encodedTime);
1:a57602b: 
1:eac0369: 		cal.set(Calendar.MILLISECOND, 0);
1:d365a22:     } // end of setCalendar
1:eac0369:         
1:eac0369: 	/**
1:eac0369: 	 * Set the encoded values for the timestamp
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private void setNumericTimestamp(Timestamp value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isNull(), "setNumericTimestamp called when already set");
1:eac0369: 		}
2:eac0369: 		if (value != null)
1:eac0369: 		{
1:eac0369:             if( cal == null)
1:eac0369:                 cal = new GregorianCalendar();
1:eac0369: 			encodedDate = computeEncodedDate(value, cal);
2:eac0369: 			encodedTime = computeEncodedTime(value, cal);
1:eac0369: 			nanos = value.getNanos();
1:eac0369: 		}
1:eac0369: 		/* encoded date should already be 0 for null */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		computeEncodedDate sets the date in a Calendar object
1:eac0369: 		and then uses the SQLDate function to compute an encoded date
1:eac0369: 		The encoded date is
1:dbed020: 			year &lt;&lt; 16 + month &lt;&lt; 8 + date
1:eac0369: 		@param value	the value to convert
1:eac0369: 		@return 		the encodedDate
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (value == null)
1:eac0369: 			return 0;
1:eac0369: 
1:eac0369: 		currentCal.setTime(value);
1:eac0369: 		return SQLDate.computeEncodedDate(currentCal);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		computeEncodedTime extracts the hour, minute and seconds from
1:eac0369: 		a java.util.Date value and encodes them as
1:dbed020: 			hour &lt;&lt; 16 + minute &lt;&lt; 8 + second
1:eac0369: 		using the SQLTime function for encoding the data
1:eac0369: 		@param value	the value to convert
1:eac0369: 		@return 		the encodedTime
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
1:eac0369: 	{
1:eac0369: 		currentCal.setTime(value);
1:eac0369: 		return SQLTime.computeEncodedTime(currentCal);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     
1:534b037:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1:eac0369: 
1:534b037:                   ps.setTimestamp(position, getTimestamp((Calendar) null));
1:eac0369:      }
1:eac0369: 
1:eac0369:     /**
1:2dd0b6f:      * Compute the SQL timestamp function.
1:eac0369:      *
1:2dd0b6f:      * @exception StandardException
1:eac0369:      */
1:2dd0b6f:     public static DateTimeDataValue computeTimestampFunction( DataValueDescriptor operand,
1:2dd0b6f:                                                               DataValueFactory dvf) throws StandardException
1:eac0369:     {
1:2dd0b6f:         try
1:eac0369:         {
1:2dd0b6f:             if( operand.isNull())
1:2dd0b6f:                 return new SQLTimestamp();
1:2dd0b6f:             if( operand instanceof SQLTimestamp)
1:854dd10:                 return (SQLTimestamp) operand.cloneValue(false);
1:eac0369: 
1:2dd0b6f:             String str = operand.getString();
1:2dd0b6f:             if( str.length() == 14)
1:eac0369:             {
1:2dd0b6f:                 int year = parseDateTimeInteger( str, 0, 4);
1:2dd0b6f:                 int month = parseDateTimeInteger( str, 4, 2);
1:2dd0b6f:                 int day = parseDateTimeInteger( str, 6, 2);
1:2dd0b6f:                 int hour = parseDateTimeInteger( str, 8, 2);
1:2dd0b6f:                 int minute = parseDateTimeInteger( str, 10, 2);
1:2dd0b6f:                 int second = parseDateTimeInteger( str, 12, 2);
1:2dd0b6f:                 return new SQLTimestamp( SQLDate.computeEncodedDate( year, month, day),
1:2dd0b6f:                                          SQLTime.computeEncodedTime( hour,minute,second),
1:2dd0b6f:                                          0);
1:eac0369:             }
1:2dd0b6f:             // else use the standard cast
1:2dd0b6f:             return dvf.getTimestampValue( str, false);
1:eac0369:         }
1:2dd0b6f:         catch( StandardException se)
1:eac0369:         {
1:2dd0b6f:             if( SQLState.LANG_DATE_SYNTAX_EXCEPTION.startsWith( se.getSQLState()))
2:d365a22:                 throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:2dd0b6f:                                                       operand.getString(), "timestamp");
1:2dd0b6f:             throw se;
1:eac0369:         }
1:2dd0b6f:     } // end of computeTimestampFunction
1:eac0369: 
1:2dd0b6f:     static int parseDateTimeInteger( String str, int start, int ndigits) throws StandardException
1:eac0369:     {
1:2dd0b6f:         int end = start + ndigits;
1:2dd0b6f:         int retVal = 0;
1:2dd0b6f:         for( int i = start; i < end; i++)
1:eac0369:         {
1:2dd0b6f:             char c = str.charAt( i);
1:2dd0b6f:             if( !Character.isDigit( c))
1:2dd0b6f:                 throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:2dd0b6f:             retVal = 10*retVal + Character.digit( c, 10);
1:eac0369:         }
1:2dd0b6f:         return retVal;
1:2dd0b6f:     } // end of parseDateTimeInteger
1:eac0369: 
1:eac0369:     /**
1:d365a22:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:eac0369:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:6b50965:      * @param count The number of intervals to add
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
2:d365a22:      *
1:d365a22:      * @return startTime + intervalCount intervals, as a timestamp
1:d365a22:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     public DateTimeDataValue timestampAdd( int intervalType,
1:d365a22:                                            NumberDataValue count,
1:d365a22:                                            java.sql.Date currentDate,
1:d365a22:                                            DateTimeDataValue resultHolder)
1:d365a22:         throws StandardException
1:eac0369:     {
1:d365a22:         if( resultHolder == null)
1:d365a22:             resultHolder = new SQLTimestamp();
1:d365a22:         SQLTimestamp tsResult = (SQLTimestamp) resultHolder;
1:d365a22:         if( isNull() || count.isNull())
1:eac0369:         {
1:d365a22:             tsResult.restoreToNull();
1:d365a22:             return resultHolder;
1:eac0369:         }
1:d365a22:         tsResult.setFrom( this);
1:d365a22:         int intervalCount = count.getInt();
1:eac0369:         
1:d365a22:         switch( intervalType)
1:eac0369:         {
1:d365a22:         case FRAC_SECOND_INTERVAL:
1:d365a22:             // The interval is nanoseconds. Do the computation in long to avoid overflow.
1:d365a22:             long nanos = this.nanos + intervalCount;
1:d365a22:             if( nanos >= 0 && nanos < ONE_BILLION)
1:d365a22:                 tsResult.nanos = (int) nanos;
1:eac0369:             else
1:eac0369:             {
1:d365a22:                 int secondsInc = (int)(nanos/ONE_BILLION);
1:d365a22:                 if( nanos >= 0)
1:d365a22:                     tsResult.nanos = (int) (nanos % ONE_BILLION);
2:d365a22:                 else
1:eac0369:                 {
1:d365a22:                     secondsInc--;
1:d365a22:                     nanos -= secondsInc * (long)ONE_BILLION; // 0 <= nanos < ONE_BILLION
1:d365a22:                     tsResult.nanos = (int) nanos;
1:eac0369:                 }
1:d365a22:                 addInternal( Calendar.SECOND, secondsInc, tsResult);
1:eac0369:             }
1:d365a22:             break;
1:eac0369: 
1:d365a22:         case SECOND_INTERVAL:
1:d365a22:             addInternal( Calendar.SECOND, intervalCount, tsResult);
1:d365a22:             break;
1:2c865dd: 
1:d365a22:         case MINUTE_INTERVAL:
1:d365a22:             addInternal( Calendar.MINUTE, intervalCount, tsResult);
1:d365a22:             break;
1:2c865dd: 
1:d365a22:         case HOUR_INTERVAL:
1:d365a22:             addInternal( Calendar.HOUR, intervalCount, tsResult);
1:d365a22:             break;
1:985f758: 
1:d365a22:         case DAY_INTERVAL:
1:d365a22:             addInternal( Calendar.DATE, intervalCount, tsResult);
1:d365a22:             break;
1:985f758: 
1:d365a22:         case WEEK_INTERVAL:
1:d365a22:             addInternal( Calendar.DATE, intervalCount*7, tsResult);
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case MONTH_INTERVAL:
1:d365a22:             addInternal( Calendar.MONTH, intervalCount, tsResult);
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case QUARTER_INTERVAL:
1:d365a22:             addInternal( Calendar.MONTH, intervalCount*3, tsResult);
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case YEAR_INTERVAL:
1:d365a22:             addInternal( Calendar.YEAR, intervalCount, tsResult);
1:d365a22:             break;
11:d365a22: 
1:d365a22:         default:
1:bb5be6f:             throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARGUMENT, intervalType,
1:d365a22:                                                   "TIMESTAMPADD");
1:eac0369:         }
1:d365a22:         return tsResult;
1:d365a22:     } // end of timestampAdd
1:d365a22: 
1:d365a22:     private void addInternal( int calIntervalType, int count, SQLTimestamp tsResult) throws StandardException
1:eac0369:     {
1:d365a22:         Calendar cal = new GregorianCalendar();
1:d365a22:         setCalendar( cal);
1:d365a22:         try
1:eac0369:         {
1:d365a22:             cal.add( calIntervalType, count);
1:d365a22:             tsResult.encodedTime = SQLTime.computeEncodedTime( cal);
1:d365a22:             tsResult.encodedDate = SQLDate.computeEncodedDate( cal);
1:eac0369:         }
1:d365a22:         catch( StandardException se)
1:eac0369:         {
1:d365a22:             String state = se.getSQLState();
1:d365a22:             if( state != null && state.length() > 0 && SQLState.LANG_DATE_RANGE_EXCEPTION.startsWith( state))
1:eac0369:             {
1:d365a22:                 throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TIMESTAMP");
1:eac0369:             }
1:d365a22:             throw se;
1:eac0369:         }
1:d365a22:     } // end of addInternal
1:d365a22: 
1:eac0369:     /**
1:d365a22:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:d365a22:      * TIMESTAMPDIFF escape function.
1:d365a22:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:d365a22:      * @param time1
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
1:d365a22:      *
1:d365a22:      * @return the number of intervals by which this datetime is greater than time1
1:d365a22:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     public NumberDataValue timestampDiff( int intervalType,
1:d365a22:                                           DateTimeDataValue time1,
1:d365a22:                                           java.sql.Date currentDate,
1:d365a22:                                           NumberDataValue resultHolder)
1:d365a22:         throws StandardException
1:eac0369:     {
1:d365a22:         if( resultHolder == null)
1:962db2d:             resultHolder = new SQLLongint();
1:d365a22:  
1:d365a22:        if( isNull() || time1.isNull())
1:eac0369:         {
1:d365a22:             resultHolder.setToNull();
1:d365a22:             return resultHolder;
1:eac0369:         }
1:d365a22:         
1:d365a22:         SQLTimestamp ts1 = promote( time1, currentDate);
1:d365a22: 
1:d365a22:         /* Years, months, and quarters are difficult because their lengths are not constant.
1:d365a22:          * The other intervals are relatively easy (because we ignore leap seconds).
1:eac0369:          */
1:d365a22:         Calendar cal = new GregorianCalendar();
1:d365a22:         setCalendar( cal);
1:d365a22:         long thisInSeconds = cal.getTime().getTime()/1000;
1:d365a22:         ts1.setCalendar( cal);
1:d365a22:         long ts1InSeconds = cal.getTime().getTime()/1000;
1:d365a22:         long secondsDiff = thisInSeconds - ts1InSeconds;
1:d365a22:         int nanosDiff = nanos - ts1.nanos;
1:d365a22:         // Normalize secondsDiff and nanosDiff so that they are both <= 0 or both >= 0.
1:d365a22:         if( nanosDiff < 0 && secondsDiff > 0)
1:eac0369:         {
1:d365a22:             secondsDiff--;
1:d365a22:             nanosDiff += ONE_BILLION;
1:eac0369:         }
1:d365a22:         else if( nanosDiff > 0 && secondsDiff < 0)
1:eac0369:         {
1:d365a22:             secondsDiff++;
1:d365a22:             nanosDiff -= ONE_BILLION;
1:eac0369:         }
1:d365a22:         long ldiff = 0;
1:d365a22:         
1:d365a22:         switch( intervalType)
1:eac0369:         {
1:d365a22:         case FRAC_SECOND_INTERVAL:
1:d365a22:             ldiff = secondsDiff*ONE_BILLION + nanosDiff;
1:d365a22:             break;
1:d365a22:             
1:d365a22:         case SECOND_INTERVAL:
1:d365a22:             ldiff = secondsDiff;
1:d365a22:             break;
1:d365a22:             
1:d365a22:         case MINUTE_INTERVAL:
1:d365a22:             ldiff = secondsDiff/60;
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case HOUR_INTERVAL:
1:d365a22:             ldiff = secondsDiff/(60*60);
1:d365a22:             break;
1:d365a22:             
1:d365a22:         case DAY_INTERVAL:
1:d365a22:             ldiff = secondsDiff/(24*60*60);
1:d365a22:             break;
1:d365a22:             
1:d365a22:         case WEEK_INTERVAL:
1:d365a22:             ldiff = secondsDiff/(7*24*60*60);
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case QUARTER_INTERVAL:
1:d365a22:         case MONTH_INTERVAL:
1:d365a22:             // Make a conservative guess and increment until we overshoot.
1:d365a22:             if( Math.abs( secondsDiff) > 366*24*60*60) // Certainly more than a year
1:d365a22:                 ldiff = 12*(secondsDiff/(366*24*60*60));
1:d365a22:             else
1:d365a22:                 ldiff = secondsDiff/(31*24*60*60);
1:d365a22:             if( secondsDiff >= 0)
1:eac0369:             {
1:d365a22:                 if (ldiff >= Integer.MAX_VALUE)
3:d365a22:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:d365a22:                 // cal holds the time for time1
1:d365a22:                 cal.add( Calendar.MONTH, (int) (ldiff + 1));
1:d365a22:                 for(;;)
1:d365a22:                 {
1:d365a22:                     if( cal.getTime().getTime()/1000 > thisInSeconds)
1:d365a22:                         break;
1:d365a22:                     cal.add( Calendar.MONTH, 1);
1:d365a22:                     ldiff++;
1:985f758:                 }
1:985f758:             }
1:d365a22:             else
17:d365a22:             {
1:d365a22:                 if (ldiff <= Integer.MIN_VALUE)
1:d365a22:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:d365a22:                 // cal holds the time for time1
1:d365a22:                 cal.add( Calendar.MONTH, (int) (ldiff - 1));
1:d365a22:                 for(;;)
1:d365a22:                 {
1:d365a22:                     if( cal.getTime().getTime()/1000 < thisInSeconds)
1:d365a22:                         break;
1:d365a22:                     cal.add( Calendar.MONTH, -1);
1:d365a22:                     ldiff--;
1:985f758:                 }
1:985f758:             }
1:d365a22:             if( intervalType == QUARTER_INTERVAL)
1:d365a22:                 ldiff = ldiff/3;
1:d365a22:             break;
1:d365a22: 
1:d365a22:         case YEAR_INTERVAL:
1:d365a22:             // Make a conservative guess and increment until we overshoot.
1:d365a22:             ldiff = secondsDiff/(366*24*60*60);
1:d365a22:             if( secondsDiff >= 0)
1:d365a22:             {
1:d365a22:                 if (ldiff >= Integer.MAX_VALUE)
1:d365a22:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:d365a22:                 // cal holds the time for time1
1:d365a22:                 cal.add( Calendar.YEAR, (int) (ldiff + 1));
1:d365a22:                 for(;;)
1:d365a22:                 {
1:d365a22:                     if( cal.getTime().getTime()/1000 > thisInSeconds)
1:d365a22:                         break;
1:d365a22:                     cal.add( Calendar.YEAR, 1);
1:d365a22:                     ldiff++;
1:985f758:                 }
1:985f758:             }
1:d365a22:             else
1:d365a22:             {
1:d365a22:                 if (ldiff <= Integer.MIN_VALUE)
1:d365a22:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:d365a22:                 // cal holds the time for time1
1:d365a22:                 cal.add( Calendar.YEAR, (int) (ldiff - 1));
1:d365a22:                 for(;;)
1:d365a22:                 {
1:d365a22:                     if( cal.getTime().getTime()/1000 < thisInSeconds)
1:d365a22:                         break;
1:d365a22:                     cal.add( Calendar.YEAR, -1);
1:d365a22:                     ldiff--;
1:985f758:                 }
1:985f758:             }
1:d365a22:             break;
1:d365a22: 
1:d365a22:         default:
1:bb5be6f:             throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARGUMENT, intervalType,
1:d365a22:                                                   "TIMESTAMPDIFF");
18:d365a22:         }
1:962db2d:         resultHolder.setValue(ldiff);
1:d365a22:         return resultHolder;
1:d365a22:     } // end of timestampDiff
1:d365a22: 
3:d365a22:     /**
1:d365a22:      * Promotes a DateTimeDataValue to a timestamp.
1:d365a22:      *
1:d365a22:      *
1:d365a22:      * @return the corresponding timestamp, using the current date if datetime is a time,
1:d365a22:      *         or time 00:00:00 if datetime is a date.
1:d365a22:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     static SQLTimestamp promote( DateTimeDataValue dateTime, java.sql.Date currentDate) throws StandardException
1:d365a22:     {
1:d365a22:         if( dateTime instanceof SQLTimestamp)
1:d365a22:             return (SQLTimestamp) dateTime;
1:d365a22:         else if( dateTime instanceof SQLTime)
1:d365a22:             return new SQLTimestamp( SQLDate.computeEncodedDate( currentDate, (Calendar) null),
1:d365a22:                                     ((SQLTime) dateTime).getEncodedTime(),
1:d365a22:                                     0 /* nanoseconds */);
1:d365a22:         else if( dateTime instanceof SQLDate)
1:d365a22:             return new SQLTimestamp( ((SQLDate) dateTime).getEncodedDate(), 0, 0);
1:d365a22:         else
1:d365a22:             return new SQLTimestamp( dateTime.getTimestamp( new GregorianCalendar()));
1:d365a22:     } // end of promote
1:d365a22: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 			year &lt;&lt; 16 + month &lt;&lt; 8 + date
/////////////////////////////////////////////////////////////////////////
1: 			hour &lt;&lt; 16 + minute &lt;&lt; 8 + second
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARGUMENT, intervalType,
/////////////////////////////////////////////////////////////////////////
1:             throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARGUMENT, intervalType,
commit:531b469
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create a new SQLTimestamp instance that represents the specified
1:      * Timestamp in the time zone of the given Calendar.
1:      * @param value the Timestamp value to be represented by this instance
1:      * @param cal the time zone of the calendar is used to construct the
1:      * database timestamp value
1:      * @throws StandardException if an error occurs
1:      */
1:     public SQLTimestamp(Timestamp value, Calendar cal) throws StandardException
1:     {
1:         setValue(value, cal);
1:     }
1:     /**
1:      * Create a new SQLTimestamp instance that represents the specified
1:      * Timestamp in the local time zone.
1:      * @param value the Timestamp value to be represented by this instance
1:      * @throws StandardException if an error occurs
1:      */
1:         this(value, (Calendar) null);
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c13beb1
/////////////////////////////////////////////////////////////////////////
1:     static final int MAX_FRACTION_DIGITS = 9; // Only nanosecond resolution on conversion to/from strings
1:     static final int FRACTION_TO_NANO = 1; // 10**(9 - MAX_FRACTION_DIGITS)
commit:320f6af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int sz = BASE_MEMORY_USAGE;
/////////////////////////////////////////////////////////////////////////
1:             String valueString = getTimestamp((Calendar) null).toString();
1:             /* The java.sql.Timestamp.toString() method is supposed to return a string in
1:              * the JDBC escape format. However the JDK 1.3 libraries truncate leading zeros from
1:              * the year. This is not acceptable to DB2. So add leading zeros if necessary.
1:              */
1:             int separatorIdx = valueString.indexOf('-');
1:             if (separatorIdx >= 0 && separatorIdx < 4)
1:             {
1:                 StringBuffer sb = new StringBuffer();
1:                 for( ; separatorIdx < 4; separatorIdx++)
1:                     sb.append('0');
1:                 sb.append(valueString);
1:                 valueString = sb.toString();
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:79fec78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aff8c99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 	/** @see DataValueDescriptor#cloneValue */
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
/////////////////////////////////////////////////////////////////////////
1:                 return (SQLTimestamp) operand.cloneValue(false);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a57602b
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Will clear all the other fields to zero
1:         // that we require at zero, specifically
1:         // HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND
1:         
1:         SQLDate.setDateInCalendar(cal, encodedDate);
1: 
1: 		return new Date(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Derby's SQL TIMESTAMP type supports resolution
1:         // to nano-seconds so ensure the Time object
1:         // maintains that since it has milli-second
1:         // resolutiuon.
1:         return SQLTime.getTime(cal, encodedTime, nanos);
/////////////////////////////////////////////////////////////////////////
1:         if (cal == null)
1:             cal = new GregorianCalendar();
1:         setCalendar(cal);
1: 		Timestamp t = new Timestamp(cal.getTimeInMillis());
1:     private void setCalendar(Calendar cal)
1:         
1:         SQLDate.setDateInCalendar(cal, encodedDate);
1:         
1:         SQLTime.setTimeInCalendar(cal, encodedTime);
1: 
commit:962db2d
/////////////////////////////////////////////////////////////////////////
1:             resultHolder = new SQLLongint();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         resultHolder.setValue(ldiff);
commit:0c7cafc
/////////////////////////////////////////////////////////////////////////
1:         cal.clear();
/////////////////////////////////////////////////////////////////////////
1:         cal.clear();
0: 		cal.set(Calendar.MILLISECOND, (int)(nanos/1000000));
/////////////////////////////////////////////////////////////////////////
0:     private Timestamp newTimestamp(Calendar currentCal)
/////////////////////////////////////////////////////////////////////////
0:         cal.clear();
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the value from a correctly typed Timestamp object.
1: 	 * @throws StandardException 
1: 	void setObject(Object theValue) throws StandardException
1: 		setValue((Timestamp) theValue);
1: 	
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLTimestamp
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.db.DatabaseContext;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
1: 
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.context.ContextService;
1:  
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataType;
1: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import org.apache.derby.iapi.types.SQLDouble;
0: import org.apache.derby.iapi.types.SQLTime;
1: 
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import java.util.Calendar;
1: import java.util.GregorianCalendar;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.text.DateFormat;
1: import java.text.ParseException;
1: 
1: /**
1:  * This contains an instance of a SQL Timestamp object.
1:  * <p>
1:  * SQLTimestamp is stored in 3 ints - an encoded date, an encoded time and 
1:  *		nanoseconds
1:  * encodedDate = 0 indicates a null WSCTimestamp
1:  *
1:  * SQLTimestamp is similar to SQLTimestamp, but it does conserves space by not keeping a GregorianCalendar object
1:  *
1:  * PERFORMANCE OPTIMIZATION:
1:  *	We only instantiate the value field when required due to the overhead of the
1:  *	Date methods.
1:  *	Thus, use isNull() instead of "value == null" and
1:  *	getTimestamp() instead of using value directly.
1:  */
1: 
1: public final class SQLTimestamp extends DataType
1: 						implements DateTimeDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
0:     static final int MAX_FRACTION_DIGITS = 6; // Only microsecond resolution on conversion to/from strings
0:     static final int FRACTION_TO_NANO = 1000; // 10**(9 - MAX_FRACTION_DIGITS)
1:     
1: 	private int	encodedDate;
1: 	private int	encodedTime;
1: 	private int	nanos;
1: 
0: 	// The cached value.toString()
0: 	private String	valueString;
1: 
1: 	/*
1: 	** DataValueDescriptor interface
1: 	** (mostly implemented in DataType)
1: 	*/
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTimestamp.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
0:         int sz = BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
1:         return sz;
1:     } // end of estimateMemoryUsage
1: 
1: 	public String getString()
1: 	{
1: 		if (!isNull())
1: 		{
0: 			if (valueString == null)
1: 			{
0: 				valueString = getTimestamp((Calendar) null).toString();
0:                 /* The java.sql.Timestamp.toString() method is supposed to return a string in
0:                  * the JDBC escape format. However the JDK 1.3 libraries truncate leading zeros from
0:                  * the year. This is not acceptable to DB2. So add leading zeros if necessary.
1:                  */
0:                 int separatorIdx = valueString.indexOf( '-');
0:                 if( separatorIdx >= 0 && separatorIdx < 4)
1:                 {
0:                     StringBuffer sb = new StringBuffer();
0:                     for( ; separatorIdx < 4; separatorIdx++)
0:                         sb.append('0');
0:                     sb.append( valueString);
0:                     valueString = sb.toString();
1:                 }
1: 			}
1: 
1: 			return valueString;
1: 		}
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				if (valueString != null)
1: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
1: 				}
1: 			}
1: 			return null;
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		getDate returns the date portion of the timestamp
1: 		Time is set to 00:00:00.0
1: 		Since Date is a JDBC object we use the JDBC definition
1: 		for the time portion.  See JDBC API Tutorial, 47.3.12.
1: 
1: 		@exception StandardException thrown on failure
1: 	 */
1: 	public Date	getDate( Calendar cal) throws StandardException
1: 	{
1: 		if (isNull())
1: 			return null;
0:         return newDate(cal);
1:     }
1: 
0:     private Date newDate(java.util.Calendar cal) throws StandardException
1:     {
1:         if( cal == null)
1:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, SQLDate.getYear(encodedDate) );
0: 		cal.set(Calendar.MONTH, SQLDate.getMonth(encodedDate)-1);
0: 		cal.set(Calendar.DATE, SQLDate.getDay(encodedDate) );
0: 		cal.set(Calendar.HOUR_OF_DAY, 0);
0: 		cal.set(Calendar.MINUTE, 0);
0: 		cal.set(Calendar.SECOND, 0);
1: 		cal.set(Calendar.MILLISECOND, 0);
0: 		return new Date(cal.getTime().getTime());
1: 	}
1: 
1: 	/**
1: 		getTime returns the time portion of the timestamp
1: 		Date is set to 1970-01-01
1: 		Since Time is a JDBC object we use the JDBC definition
1: 		for the date portion.  See JDBC API Tutorial, 47.3.12.
1: 		@exception StandardException thrown on failure
1: 	 */
1: 	public Time	getTime( Calendar cal) throws StandardException
1: 	{
1: 		if (isNull())
1: 			return null;
0:         return newTime(cal);
1:     }
1: 
0:     private Time newTime(java.util.Calendar cal) throws StandardException
1:     {
1:         if( cal == null)
1:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, 1970);
0: 		cal.set(Calendar.MONTH, Calendar.JANUARY);
0: 		cal.set(Calendar.DATE, 1);
0: 		cal.set(Calendar.HOUR_OF_DAY, SQLTime.getHour(encodedTime));
0: 		cal.set(Calendar.MINUTE, SQLTime.getMinute(encodedTime));
0: 		cal.set(Calendar.SECOND, SQLTime.getSecond(encodedTime));
0: 		cal.set(Calendar.MILLISECOND, (int)(nanos/1E06));
0: 		return new Time(cal.getTime().getTime());
1: 	}
1: 
1: 	public Object getObject()
1: 	{
1: 		return getTimestamp((Calendar) null);
1: 	}
1: 		
1: 	/* get storage length */
1: 	public int getLength()
1: 	{
1: 		return 12;
1: 	}
1: 
1: 	/* this is for DataType's error generator */
1: 	public String getTypeName()
1: 	{
1: 		return "TIMESTAMP";
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_TIMESTAMP_ID;
1: 	}
1: 
1: 	/** 
1: 		@exception IOException error writing data
1: 
1: 	*/
1: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1: 
1: 		/*
1: 		** Timestamp is written out 3 ints, encoded date, encoded time, and
1: 		** nanoseconds
1: 		*/
1: 		out.writeInt(encodedDate);
1: 		out.writeInt(encodedTime);
1: 		out.writeInt(nanos);
1: 	}
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on error reading the object
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException
1: 	{
1: 		encodedDate = in.readInt();
1: 		encodedTime = in.readInt();
1: 		nanos = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
1: 	{
1: 		encodedDate = in.readInt();
1: 		encodedTime = in.readInt();
1: 		nanos = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		// Call constructor with all of our info
1: 		return new SQLTimestamp(encodedDate, encodedTime, nanos);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new SQLTimestamp();
1: 	}
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	 *
1: 	 */
1: 	public void restoreToNull()
1: 	{
1: 		// clear numeric representation
1: 		encodedDate = 0;
1: 		encodedTime = 0;
1: 		nanos = 0;
1: 
0: 		// clear cached valueString
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException, StandardException
1: 	{
1: 			setValue(resultSet.getTimestamp(colNumber), (Calendar) null);
1: 	}
1: 
1: 	public int compare(DataValueDescriptor other)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 		boolean thisNull, otherNull;
1: 
1: 		thisNull = this.isNull();
1: 		otherNull = other.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull	return
1: 		 *	T		T		 	0	(this == other)
1: 		 *	F		T		 	-1 	(this < other)
1: 		 *	T		F		 	1	(this > other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
1: 				return -1;
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
1: 			return 0;
1: 		}
1: 
1: 		/*
1: 			Neither are null compare them 
1: 		 */
1: 
1: 		int comparison;
1: 		/* get the comparison date values */
1: 		int otherEncodedDate = 0;
1: 		int otherEncodedTime = 0;
1: 		int otherNanos = 0;
1: 
1: 		/* if the argument is another SQLTimestamp, look up the value
1: 		 */
1: 		if (other instanceof SQLTimestamp)
1: 		{
1: 			SQLTimestamp st = (SQLTimestamp)other;
1: 			otherEncodedDate= st.encodedDate;
1: 			otherEncodedTime= st.encodedTime;
1: 			otherNanos= st.nanos;
1: 		}
1: 		else 
1: 		{
1: 			/* O.K. have to do it the hard way and calculate the numeric value
1: 			 * from the value
1: 			 */
1: 			Calendar cal = new GregorianCalendar();
1: 			Timestamp otherts = other.getTimestamp(cal);
1: 			otherEncodedDate = SQLTimestamp.computeEncodedDate(otherts, cal);
1: 			otherEncodedTime = SQLTimestamp.computeEncodedTime(otherts, cal);
1: 			otherNanos = otherts.getNanos();
1: 		}
1: 		if (encodedDate < otherEncodedDate)
1: 			comparison = -1;
1: 		else if (encodedDate > otherEncodedDate)
1: 			comparison = 1;
1: 		else if (encodedTime < otherEncodedTime)
1: 			comparison = -1;
1: 		else if (encodedTime > otherEncodedTime)
1: 			comparison = 1;
1: 		else if (nanos < otherNanos)
1: 			comparison = -1;
1: 		else if (nanos > otherNanos)
1: 			comparison = 1;
1: 		else
1: 			comparison = 0;
1: 
1: 		return comparison;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || ((DataValueDescriptor)other).isNull())
1: 				return unknownRV;
1: 		}
1: 
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/*
1: 	** Class interface
1: 	*/
1: 
1: 	/*
1: 	** Constructors
1: 	*/
1: 
1: 	/** no-arg constructor required by Formattable */
1: 	public SQLTimestamp() { }
1: 
1: 
1: 	public SQLTimestamp(Timestamp value) throws StandardException
1: 	{
0: 		setValue(value, (Calendar) null);
1: 	}
1: 
0: 	private SQLTimestamp(int encodedDate, int encodedTime, int nanos) {
1: 
1: 		this.encodedDate = encodedDate;
1: 		this.encodedTime = encodedTime;
1: 		this.nanos = nanos;
1: 	}
1: 
1:     public SQLTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
1:     {
1:         Calendar cal = null;
1:         if( date == null || date.isNull()
1:             || time == null || time.isNull())
1:             return;
1:         if( date instanceof SQLDate)
1:         {
1:             SQLDate sqlDate = (SQLDate) date;
1:             encodedDate = sqlDate.getEncodedDate();
1:         }
1:         else
1:         {
1:             cal = new GregorianCalendar();
1:             encodedDate = computeEncodedDate( date.getDate( cal), cal);
1:         }
1:         if( time instanceof SQLTime)
1:         {
1:             SQLTime sqlTime = (SQLTime) time;
1:             encodedTime = sqlTime.getEncodedTime();
1:         }
1:         else
1:         {
1:             if( cal == null)
1:                 cal = new GregorianCalendar();
1:             encodedTime = computeEncodedTime( time.getTime( cal), cal);
1:         }
1:     }
1: 
1:     /**
1:      * Construct a timestamp from a string. The allowed formats are:
1:      *<ol>
1:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
1:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
1:      *</ol>
1:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
1:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
1:      */
1:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder)
1:         throws StandardException
1:     {
1:         parseTimestamp( timestampStr, isJDBCEscape,localeFinder, (Calendar) null);
1:     }
1:     
1:     /**
1:      * Construct a timestamp from a string. The allowed formats are:
1:      *<ol>
1:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
1:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
1:      *</ol>
1:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
1:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
1:      */
1:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         parseTimestamp( timestampStr, isJDBCEscape, localeFinder, cal);
1:     }
1: 
1:     static final char DATE_SEPARATOR = '-';
1:     private static final char[] DATE_SEPARATORS = { DATE_SEPARATOR};
1:     private static final char IBM_DATE_TIME_SEPARATOR = '-';
1:     private static final char ODBC_DATE_TIME_SEPARATOR = ' ';
1:     private static final char[] DATE_TIME_SEPARATORS = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR};
1:     private static final char[] DATE_TIME_SEPARATORS_OR_END
1:     = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR, (char) 0};
1:     private static final char IBM_TIME_SEPARATOR = '.';
1:     private static final char ODBC_TIME_SEPARATOR = ':';
1:     private static final char[] TIME_SEPARATORS = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR};
1:     private static final char[] TIME_SEPARATORS_OR_END = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR, (char) 0};
1:     private static final char[] END_OF_STRING = {(char) 0};
1:     
1:     private void parseTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         StandardException thrownSE = null;
1:         DateTimeParser parser = new DateTimeParser( timestampStr);
1:         try
1:         {
1:             int[] dateTimeNano = parseDateOrTimestamp( parser, true);
1:             encodedDate = dateTimeNano[0];
1:             encodedTime = dateTimeNano[1];
1:             nanos = dateTimeNano[2];
0:             valueString = parser.getTrimmedString();
1:             return;
1:         }
1:         catch( StandardException se)
1:         {
1:             thrownSE = se;
1:         }
1:         // see if it is a localized timestamp
1:         try
1:         {
1:             timestampStr = StringUtil.trimTrailing( timestampStr);
1:             int[] dateAndTime = parseLocalTimestamp( timestampStr, localeFinder, cal);
1:             encodedDate = dateAndTime[0];
1:             encodedTime = dateAndTime[1];
0:             valueString = timestampStr;
1:             return;
1:         }
1:         catch( ParseException pe){}
1:         catch( StandardException se){}
1:         if( thrownSE != null)
1:             throw thrownSE;
1:         throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:     } // end of parseTimestamp
1: 
1:     /**
1:      * Parse a localized timestamp.
1:      *
1:      * @param str the timestamp string, with trailing blanks removed.
0:      * @param localFinder
1:      *
1:      * @return a {encodedDate, encodedTime} array.
1:      *
1:      * @exception ParseException If the string is not a valid timestamp.
1:      */
1:     static int[] parseLocalTimestamp( String str, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException, ParseException
1:     {
1:         DateFormat timestampFormat = null;
1:         if(localeFinder == null)
1:             timestampFormat = DateFormat.getDateTimeInstance();
1:         else if( cal == null)
1:             timestampFormat = localeFinder.getTimestampFormat();
1:         else
1:             timestampFormat = (DateFormat) localeFinder.getTimestampFormat().clone();
1:         if( cal == null)
1:             cal = new GregorianCalendar();
1:         else
1:             timestampFormat.setCalendar( cal);
1:         java.util.Date date = timestampFormat.parse( str);
1:             
1:         return new int[] { computeEncodedDate( date, cal), computeEncodedTime( date, cal)};
1:     } // end of parseLocalTimestamp
1: 
1:     /**
1:      * Parse a timestamp or a date. DB2 allows timestamps to be used as dates or times. So
1:      * date('2004-04-15-16.15.32') is valid, as is date('2004-04-15').
1:      *
1:      * This method does not handle localized timestamps.
1:      *
1:      * @param parser a DateTimeParser initialized with a string.
1:      * @param timeRequired If true then an error will be thrown if the time is missing. If false then the time may
1:      *                     be omitted.
1:      *
1:      * @return {encodedDate, encodedTime, nanosecond} array.
1:      *
1:      * @exception StandardException if the syntax is incorrect for an IBM standard timestamp.
1:      */
1:     static int[] parseDateOrTimestamp( DateTimeParser parser, boolean timeRequired)
1:         throws StandardException
1:     {
1:         int year = parser.parseInt( 4, false, DATE_SEPARATORS, false);
1:         int month = parser.parseInt( 2, true, DATE_SEPARATORS, false);
1:         int day = parser.parseInt( 2, true, timeRequired ? DATE_TIME_SEPARATORS : DATE_TIME_SEPARATORS_OR_END, false);
1:         int hour = 0;
1:         int minute = 0;
1:         int second = 0;
1:         int nano = 0;
1:         if( parser.getCurrentSeparator() != 0)
1:         {
1:             char timeSeparator = (parser.getCurrentSeparator() == ODBC_DATE_TIME_SEPARATOR)
1:               ? ODBC_TIME_SEPARATOR : IBM_TIME_SEPARATOR;
1:             hour = parser.parseInt( 2, true, TIME_SEPARATORS, false);
1:             if( timeSeparator == parser.getCurrentSeparator())
1:             {
1:                 minute = parser.parseInt( 2, false, TIME_SEPARATORS, false);
1:                 if( timeSeparator == parser.getCurrentSeparator())
1:                 {
1:                     second = parser.parseInt( 2, false, TIME_SEPARATORS_OR_END, false);
1:                     if( parser.getCurrentSeparator() == '.')
1:                         nano = parser.parseInt( MAX_FRACTION_DIGITS, true, END_OF_STRING, true)*FRACTION_TO_NANO;
1:                 }
1:             }
1:         }
1:         parser.checkEnd();
1:         return new int[] { SQLDate.computeEncodedDate( year, month, day),
1:                            SQLTime.computeEncodedTime( hour,minute,second),
1:                            nano};
1:     } // end of parseDateOrTimestamp
1: 
1: 	/**
0: 	 * @see DataValueDescriptor#setValue
1: 	 *
1: 	 */
0: 	public void setValue(Object theValue) throws StandardException
1: 	{
0: 		if (theValue == null)
1: 		{
0: 			setToNull();
1: 		}
0: 		else if (theValue instanceof Date)
1: 		{
0: 			this.setValue((Date)theValue, (Calendar) null);
1: 		}
0: 		else if (theValue instanceof Time)
1: 		{
0: 			this.setValue((Time)theValue, (Calendar) null);
1: 		}
0: 		else if (theValue instanceof Timestamp)
1: 		{
0: 			this.setValue((Timestamp)theValue, (Calendar) null);
1: 		}
1: 		else
1: 		{
0: 			genericSetObject(theValue);
1: 		}
1: 	}
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
1: 		if (theValue instanceof SQLTimestamp) {
1: 			restoreToNull();
1: 			SQLTimestamp tvst = (SQLTimestamp) theValue;
1: 			encodedDate = tvst.encodedDate;
1: 			encodedTime = tvst.encodedTime;
1: 			nanos = tvst.nanos;
1:         }
1: 		else
1:         {
1:             Calendar cal = new GregorianCalendar();
1: 			setValue(theValue.getTimestamp( cal), cal);
1:         }
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 		When converting from a date to a timestamp, time is set to 00:00:00.0
1: 
1: 	 */
1: 	public void setValue(Date value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1:         if( value != null)
1:         {
1:             if( cal == null)
1:                 cal = new GregorianCalendar();
1:             encodedDate = computeEncodedDate(value, cal);
1:         }
1: 		/* encodedTime and nanos are already set to zero by restoreToNull() */
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 	 */
0: 	public void setValue(Time value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		if (value != null)
1: 		{
1: 			/*
0: 			** Create a new timestamp with today's date,
0: 			** and 'value' time.  
0: 			**
0: 			** We create a new calendar to get today's date
1: 			*/
0: 			Calendar today = GregorianCalendar.getInstance();
0: 			encodedDate = SQLDate.computeEncodedDate(today);
1:             if( cal == null)
0:                 cal = today;
1: 			encodedTime = computeEncodedTime(value, cal);
1: 		}
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 	 */
1: 	public void setValue(Timestamp value, Calendar cal) 
1: 	    throws StandardException
1: 	{
1: 		restoreToNull();
1: 		setNumericTimestamp(value, cal);
1: 	}
1: 
1: 
1: 	public void setValue(String theValue)
1: 	    throws StandardException
1: 	{
1: 		restoreToNull();
1: 
1: 		if (theValue != null)
1: 		{
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
1:             parseTimestamp( theValue,
1:                             false,
1:                             (databaseContext == null) ? null : databaseContext.getDatabase(),
1:                             (Calendar) null);
1: 		}
1: 		/* restoreToNull will have already set the encoded date to 0 (null value) */
1: 	}
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getYear
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getYear(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on a null");
1: 		}
1: 		return SQLDate.setSource(SQLDate.getYear(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMonth
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMonth(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on a null");
1: 		}
1: 		return SQLDate.setSource(SQLDate.getMonth(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getDate
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getDate(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on a null");
1: 		}
1: 		return SQLDate.setSource(SQLDate.getDay(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getHours
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getHours(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getHours called on a null");
1: 		}
1: 		return SQLDate.setSource(SQLTime.getHour(encodedTime), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMinutes
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMinutes(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinute called on a null");
1: 		}
1: 		return SQLDate.setSource(SQLTime.getMinute(encodedTime), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getSeconds
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getSeconds(NumberDataValue source)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getSeconds called on a null");
1: 			SanityManager.ASSERT(source == null || source instanceof SQLDouble,
1: 		"getSeconds for a timestamp was given a source other than a SQLDouble");
1: 		}
1: 		NumberDataValue result;
1: 
1: 		if (source != null)
1: 			result = source;
1: 		else
1: 			result = new SQLDouble();
1: 
1: 		result.setValue((double)(SQLTime.getSecond(encodedTime))
1: 				+ ((double)nanos)/1.0e9);
1: 
1: 		return result;
1: 	}
1: 
1: 	/*
1: 	** String display of value
1: 	*/
1: 
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return "NULL";
1: 		}
1: 		else
1: 		{
1: 			return getTimestamp( (Calendar) null).toString();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return 0;
1: 		}
1: 		
1: 		return  encodedDate + encodedTime + nanos; //since 0 is null
1: 
1: 	}
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int	typePrecedence()
1: 	{
1: 		return TypeId.TIMESTAMP_PRECEDENCE;
1: 	}
1: 
1: 	/**
1: 	 * Check if the value is null.  encodedDate value of 0 is null
1: 	 *
1: 	 * @return Whether or not value is logically null.
1: 	 */
1: 	public final boolean isNull()
1: 	{
1: 		return (encodedDate == 0);
1: 	}
1: 
1: 	/**
1: 	 * Get the value field.  We instantiate the field
1: 	 * on demand.
1: 	 *
1: 	 * @return	The value field.
1: 	 */
1: 	public Timestamp getTimestamp(java.util.Calendar cal)
1: 	{
1: 		if (isNull())
1: 			return null;
0:         return newTimestamp(cal);
1:     }
1: 
0:     protected Timestamp newTimestamp(Calendar currentCal)
1:     {
0:         if( currentCal == null)
0:             currentCal = new GregorianCalendar();
0: 		currentCal.set(Calendar.YEAR, SQLDate.getYear(encodedDate));
0: 		/* Note calendar month is zero based so we subtract 1*/
0: 		currentCal.set(Calendar.MONTH, (SQLDate.getMonth(encodedDate)-1));
0: 		currentCal.set(Calendar.DATE, SQLDate.getDay(encodedDate));
0: 		currentCal.set(Calendar.HOUR_OF_DAY, SQLTime.getHour(encodedTime));
0: 		currentCal.set(Calendar.MINUTE, SQLTime.getMinute(encodedTime));
0: 		currentCal.set(Calendar.SECOND, SQLTime.getSecond(encodedTime));
0: 		currentCal.set(Calendar.MILLISECOND, 0);
0: 		Timestamp t = new Timestamp(currentCal.getTime().getTime());
1: 		t.setNanos(nanos);
1: 		return t;
1: 	}
1: 	/**
1: 	 * Set the encoded values for the timestamp
1: 	 *
1: 	 */
1: 	private void setNumericTimestamp(Timestamp value, Calendar cal) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isNull(), "setNumericTimestamp called when already set");
1: 		}
1: 		if (value != null)
1: 		{
1:             if( cal == null)
1:                 cal = new GregorianCalendar();
1: 			encodedDate = computeEncodedDate(value, cal);
1: 			encodedTime = computeEncodedTime(value, cal);
1: 			nanos = value.getNanos();
1: 		}
1: 		/* encoded date should already be 0 for null */
1: 	}
1: 
0: 	// International Support
1: 
1: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
1: 	{
1: 		if (isNull())
1: 		{
0: 			return getString();
1: 		}
1: 
1: 
0: 		return localeFinder.getTimestampFormat().format(getTimestamp((Calendar) null));
1: 	}
1: 
1: 	/**
1: 		computeEncodedDate sets the date in a Calendar object
1: 		and then uses the SQLDate function to compute an encoded date
1: 		The encoded date is
0: 			year << 16 + month << 8 + date
1: 		@param value	the value to convert
1: 		@return 		the encodedDate
1: 
1: 	 */
1: 	private static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
1: 	{
1: 		if (value == null)
1: 			return 0;
1: 
1: 		currentCal.setTime(value);
1: 		return SQLDate.computeEncodedDate(currentCal);
1: 	}
1: 	/**
1: 		computeEncodedTime extracts the hour, minute and seconds from
1: 		a java.util.Date value and encodes them as
0: 			hour << 16 + minute << 8 + second
1: 		using the SQLTime function for encoding the data
1: 		@param value	the value to convert
1: 		@return 		the encodedTime
1: 
1: 	 */
1: 	private static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
1: 	{
1: 		currentCal.setTime(value);
1: 		return SQLTime.computeEncodedTime(currentCal);
1: 	}
1: }
1: 
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:2c865dd
/////////////////////////////////////////////////////////////////////////
1:     
1:     
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:985f758
/////////////////////////////////////////////////////////////////////////
1:     NumberDataValue nullValueInt() {
1:         return new SQLInteger();
1:     }
1: 
1:     NumberDataValue nullValueDouble() {
1:         return new SQLDouble();
1:     }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(SQLDate.getYear(encodedDate), result);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(SQLDate.getMonth(encodedDate), result);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(SQLDate.getDay(encodedDate), result);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(SQLTime.getHour(encodedTime), result);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(SQLTime.getMinute(encodedTime), result);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueDouble();
1:         }
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:      * @param localeFinder
/////////////////////////////////////////////////////////////////////////
1:      * @param count The number of intervals to add
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d365a22
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1:     static final int ONE_BILLION = 1000000000;
/////////////////////////////////////////////////////////////////////////
1: 	SQLTimestamp(int encodedDate, int encodedTime, int nanos) {
/////////////////////////////////////////////////////////////////////////
0:         setCalendar( currentCal);
1: 
0:     private void setCalendar( Calendar cal)
1:     {
0: 		cal.set(Calendar.YEAR, SQLDate.getYear(encodedDate));
0: 		/* Note calendar month is zero based so we subtract 1*/
0: 		cal.set(Calendar.MONTH, (SQLDate.getMonth(encodedDate)-1));
0: 		cal.set(Calendar.DATE, SQLDate.getDay(encodedDate));
0: 		cal.set(Calendar.HOUR_OF_DAY, SQLTime.getHour(encodedTime));
0: 		cal.set(Calendar.MINUTE, SQLTime.getMinute(encodedTime));
0: 		cal.set(Calendar.SECOND, SQLTime.getSecond(encodedTime));
0: 		cal.set(Calendar.MILLISECOND, 0);
1:     } // end of setCalendar
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
0:      * @param intervalCount The number of intervals to add
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return startTime + intervalCount intervals, as a timestamp
1:      *
1:      * @exception StandardException
0:      */
1:     public DateTimeDataValue timestampAdd( int intervalType,
1:                                            NumberDataValue count,
1:                                            java.sql.Date currentDate,
1:                                            DateTimeDataValue resultHolder)
1:         throws StandardException
1:     {
1:         if( resultHolder == null)
1:             resultHolder = new SQLTimestamp();
1:         SQLTimestamp tsResult = (SQLTimestamp) resultHolder;
1:         if( isNull() || count.isNull())
1:         {
1:             tsResult.restoreToNull();
1:             return resultHolder;
1:         }
1:         tsResult.setFrom( this);
1:         int intervalCount = count.getInt();
1:         
1:         switch( intervalType)
1:         {
1:         case FRAC_SECOND_INTERVAL:
1:             // The interval is nanoseconds. Do the computation in long to avoid overflow.
1:             long nanos = this.nanos + intervalCount;
1:             if( nanos >= 0 && nanos < ONE_BILLION)
1:                 tsResult.nanos = (int) nanos;
1:             else
1:             {
1:                 int secondsInc = (int)(nanos/ONE_BILLION);
1:                 if( nanos >= 0)
1:                     tsResult.nanos = (int) (nanos % ONE_BILLION);
1:                 else
1:                 {
1:                     secondsInc--;
1:                     nanos -= secondsInc * (long)ONE_BILLION; // 0 <= nanos < ONE_BILLION
1:                     tsResult.nanos = (int) nanos;
1:                 }
1:                 addInternal( Calendar.SECOND, secondsInc, tsResult);
1:             }
1:             break;
1: 
1:         case SECOND_INTERVAL:
1:             addInternal( Calendar.SECOND, intervalCount, tsResult);
1:             break;
1: 
1:         case MINUTE_INTERVAL:
1:             addInternal( Calendar.MINUTE, intervalCount, tsResult);
1:             break;
1: 
1:         case HOUR_INTERVAL:
1:             addInternal( Calendar.HOUR, intervalCount, tsResult);
1:             break;
1: 
1:         case DAY_INTERVAL:
1:             addInternal( Calendar.DATE, intervalCount, tsResult);
1:             break;
1: 
1:         case WEEK_INTERVAL:
1:             addInternal( Calendar.DATE, intervalCount*7, tsResult);
1:             break;
1: 
1:         case MONTH_INTERVAL:
1:             addInternal( Calendar.MONTH, intervalCount, tsResult);
1:             break;
1: 
1:         case QUARTER_INTERVAL:
1:             addInternal( Calendar.MONTH, intervalCount*3, tsResult);
1:             break;
1: 
1:         case YEAR_INTERVAL:
1:             addInternal( Calendar.YEAR, intervalCount, tsResult);
1:             break;
1: 
1:         default:
1:             throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
0:                                                   ReuseFactory.getInteger( intervalType),
1:                                                   "TIMESTAMPADD");
1:         }
1:         return tsResult;
1:     } // end of timestampAdd
1: 
1:     private void addInternal( int calIntervalType, int count, SQLTimestamp tsResult) throws StandardException
1:     {
1:         Calendar cal = new GregorianCalendar();
1:         setCalendar( cal);
1:         try
1:         {
1:             cal.add( calIntervalType, count);
1:             tsResult.encodedTime = SQLTime.computeEncodedTime( cal);
1:             tsResult.encodedDate = SQLDate.computeEncodedDate( cal);
1:         }
1:         catch( StandardException se)
1:         {
1:             String state = se.getSQLState();
1:             if( state != null && state.length() > 0 && SQLState.LANG_DATE_RANGE_EXCEPTION.startsWith( state))
1:             {
1:                 throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TIMESTAMP");
1:             }
1:             throw se;
1:         }
1:     } // end of addInternal
1: 
1:     /**
1:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:      * TIMESTAMPDIFF escape function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:      * @param time1
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return the number of intervals by which this datetime is greater than time1
1:      *
1:      * @exception StandardException
0:      */
1:     public NumberDataValue timestampDiff( int intervalType,
1:                                           DateTimeDataValue time1,
1:                                           java.sql.Date currentDate,
1:                                           NumberDataValue resultHolder)
1:         throws StandardException
1:     {
1:         if( resultHolder == null)
0:             resultHolder = new SQLInteger();
1:  
1:        if( isNull() || time1.isNull())
1:         {
1:             resultHolder.setToNull();
1:             return resultHolder;
1:         }
1:         
1:         SQLTimestamp ts1 = promote( time1, currentDate);
1: 
1:         /* Years, months, and quarters are difficult because their lengths are not constant.
1:          * The other intervals are relatively easy (because we ignore leap seconds).
0:          */
1:         Calendar cal = new GregorianCalendar();
1:         setCalendar( cal);
1:         long thisInSeconds = cal.getTime().getTime()/1000;
1:         ts1.setCalendar( cal);
1:         long ts1InSeconds = cal.getTime().getTime()/1000;
1:         long secondsDiff = thisInSeconds - ts1InSeconds;
1:         int nanosDiff = nanos - ts1.nanos;
1:         // Normalize secondsDiff and nanosDiff so that they are both <= 0 or both >= 0.
1:         if( nanosDiff < 0 && secondsDiff > 0)
1:         {
1:             secondsDiff--;
1:             nanosDiff += ONE_BILLION;
1:         }
1:         else if( nanosDiff > 0 && secondsDiff < 0)
1:         {
1:             secondsDiff++;
1:             nanosDiff -= ONE_BILLION;
1:         }
1:         long ldiff = 0;
1:         
1:         switch( intervalType)
1:         {
1:         case FRAC_SECOND_INTERVAL:
0:             if( secondsDiff > Integer.MAX_VALUE/ONE_BILLION || secondsDiff < Integer.MIN_VALUE/ONE_BILLION)
1:                 throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:             ldiff = secondsDiff*ONE_BILLION + nanosDiff;
1:             break;
1:             
1:         case SECOND_INTERVAL:
1:             ldiff = secondsDiff;
1:             break;
1:             
1:         case MINUTE_INTERVAL:
1:             ldiff = secondsDiff/60;
1:             break;
1: 
1:         case HOUR_INTERVAL:
1:             ldiff = secondsDiff/(60*60);
1:             break;
1:             
1:         case DAY_INTERVAL:
1:             ldiff = secondsDiff/(24*60*60);
1:             break;
1:             
1:         case WEEK_INTERVAL:
1:             ldiff = secondsDiff/(7*24*60*60);
1:             break;
1: 
1:         case QUARTER_INTERVAL:
1:         case MONTH_INTERVAL:
1:             // Make a conservative guess and increment until we overshoot.
1:             if( Math.abs( secondsDiff) > 366*24*60*60) // Certainly more than a year
1:                 ldiff = 12*(secondsDiff/(366*24*60*60));
1:             else
1:                 ldiff = secondsDiff/(31*24*60*60);
1:             if( secondsDiff >= 0)
1:             {
1:                 if (ldiff >= Integer.MAX_VALUE)
1:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:                 // cal holds the time for time1
1:                 cal.add( Calendar.MONTH, (int) (ldiff + 1));
1:                 for(;;)
1:                 {
1:                     if( cal.getTime().getTime()/1000 > thisInSeconds)
1:                         break;
1:                     cal.add( Calendar.MONTH, 1);
1:                     ldiff++;
1:                 }
1:             }
1:             else
1:             {
1:                 if (ldiff <= Integer.MIN_VALUE)
1:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:                 // cal holds the time for time1
1:                 cal.add( Calendar.MONTH, (int) (ldiff - 1));
1:                 for(;;)
1:                 {
1:                     if( cal.getTime().getTime()/1000 < thisInSeconds)
1:                         break;
1:                     cal.add( Calendar.MONTH, -1);
1:                     ldiff--;
1:                 }
1:             }
1:             if( intervalType == QUARTER_INTERVAL)
1:                 ldiff = ldiff/3;
1:             break;
1: 
1:         case YEAR_INTERVAL:
1:             // Make a conservative guess and increment until we overshoot.
1:             ldiff = secondsDiff/(366*24*60*60);
1:             if( secondsDiff >= 0)
1:             {
1:                 if (ldiff >= Integer.MAX_VALUE)
1:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:                 // cal holds the time for time1
1:                 cal.add( Calendar.YEAR, (int) (ldiff + 1));
1:                 for(;;)
1:                 {
1:                     if( cal.getTime().getTime()/1000 > thisInSeconds)
1:                         break;
1:                     cal.add( Calendar.YEAR, 1);
1:                     ldiff++;
1:                 }
1:             }
1:             else
1:             {
1:                 if (ldiff <= Integer.MIN_VALUE)
1:                     throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:                 // cal holds the time for time1
1:                 cal.add( Calendar.YEAR, (int) (ldiff - 1));
1:                 for(;;)
1:                 {
1:                     if( cal.getTime().getTime()/1000 < thisInSeconds)
1:                         break;
1:                     cal.add( Calendar.YEAR, -1);
1:                     ldiff--;
1:                 }
1:             }
1:             break;
1: 
1:         default:
1:             throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
0:                                                   ReuseFactory.getInteger( intervalType),
1:                                                   "TIMESTAMPDIFF");
1:         }
0: 		if (ldiff > Integer.MAX_VALUE || ldiff < Integer.MIN_VALUE)
1: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
0:         resultHolder.setValue( (int) ldiff);
1:         return resultHolder;
1:     } // end of timestampDiff
1: 
1:     /**
1:      * Promotes a DateTimeDataValue to a timestamp.
1:      *
0:      * @param datetime
1:      *
1:      * @return the corresponding timestamp, using the current date if datetime is a time,
1:      *         or time 00:00:00 if datetime is a date.
1:      *
1:      * @exception StandardException
0:      */
1:     static SQLTimestamp promote( DateTimeDataValue dateTime, java.sql.Date currentDate) throws StandardException
1:     {
1:         if( dateTime instanceof SQLTimestamp)
1:             return (SQLTimestamp) dateTime;
1:         else if( dateTime instanceof SQLTime)
1:             return new SQLTimestamp( SQLDate.computeEncodedDate( currentDate, (Calendar) null),
1:                                     ((SQLTime) dateTime).getEncodedTime(),
1:                                     0 /* nanoseconds */);
1:         else if( dateTime instanceof SQLDate)
1:             return new SQLTimestamp( ((SQLDate) dateTime).getEncodedDate(), 0, 0);
1:         else
1:             return new SQLTimestamp( dateTime.getTimestamp( new GregorianCalendar()));
1:     } // end of promote
commit:2dd0b6f
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Compute the SQL timestamp function.
0:      *
1:      * @exception StandardException
0:      */
1:     public static DateTimeDataValue computeTimestampFunction( DataValueDescriptor operand,
1:                                                               DataValueFactory dvf) throws StandardException
0:     {
1:         try
0:         {
1:             if( operand.isNull())
1:                 return new SQLTimestamp();
1:             if( operand instanceof SQLTimestamp)
0:                 return (SQLTimestamp) operand.getClone();
0: 
1:             String str = operand.getString();
1:             if( str.length() == 14)
0:             {
1:                 int year = parseDateTimeInteger( str, 0, 4);
1:                 int month = parseDateTimeInteger( str, 4, 2);
1:                 int day = parseDateTimeInteger( str, 6, 2);
1:                 int hour = parseDateTimeInteger( str, 8, 2);
1:                 int minute = parseDateTimeInteger( str, 10, 2);
1:                 int second = parseDateTimeInteger( str, 12, 2);
1:                 return new SQLTimestamp( SQLDate.computeEncodedDate( year, month, day),
1:                                          SQLTime.computeEncodedTime( hour,minute,second),
1:                                          0);
0:             }
1:             // else use the standard cast
1:             return dvf.getTimestampValue( str, false);
0:         }
1:         catch( StandardException se)
0:         {
1:             if( SQLState.LANG_DATE_SYNTAX_EXCEPTION.startsWith( se.getSQLState()))
0:                 throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:                                                       operand.getString(), "timestamp");
1:             throw se;
0:         }
1:     } // end of computeTimestampFunction
0: 
1:     static int parseDateTimeInteger( String str, int start, int ndigits) throws StandardException
0:     {
1:         int end = start + ndigits;
1:         int retVal = 0;
1:         for( int i = start; i < end; i++)
0:         {
1:             char c = str.charAt( i);
1:             if( !Character.isDigit( c))
1:                 throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:             retVal = 10*retVal + Character.digit( c, 10);
0:         }
1:         return retVal;
1:     } // end of parseDateTimeInteger
commit:534b037
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
0:  * SQLTimestamp is stored in 3 ints - an encoded date, an encoded time and
/////////////////////////////////////////////////////////////////////////
0: 
0:     
1:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
0: 
1:                   ps.setTimestamp(position, getTimestamp((Calendar) null));
0:      }
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.db.DatabaseContext;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.context.ContextService;
0:  
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataType;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.types.SQLDouble;
0: import org.apache.derby.iapi.types.SQLTime;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: import java.util.Calendar;
0: import java.util.GregorianCalendar;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: 
0: /**
0:  * This contains an instance of a SQL Timestamp object.
0:  * <p>
0:  * SQLTimestamp is stored in 3 ints - an encoded date, an encoded time and 
0:  *		nanoseconds
0:  * encodedDate = 0 indicates a null WSCTimestamp
0:  *
0:  * SQLTimestamp is similar to SQLTimestamp, but it does conserves space by not keeping a GregorianCalendar object
0:  *
0:  * PERFORMANCE OPTIMIZATION:
0:  *	We only instantiate the value field when required due to the overhead of the
0:  *	Date methods.
0:  *	Thus, use isNull() instead of "value == null" and
0:  *	getTimestamp() instead of using value directly.
0:  */
0: 
0: public final class SQLTimestamp extends DataType
0: 						implements DateTimeDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0:     static final int MAX_FRACTION_DIGITS = 6; // Only microsecond resolution on conversion to/from strings
0:     static final int FRACTION_TO_NANO = 1000; // 10**(9 - MAX_FRACTION_DIGITS)
0:     
0: 	private int	encodedDate;
0: 	private int	encodedTime;
0: 	private int	nanos;
0: 
0: 	// The cached value.toString()
0: 	private String	valueString;
0: 
0: 	/*
0: 	** DataValueDescriptor interface
0: 	** (mostly implemented in DataType)
0: 	*/
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTimestamp.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
0:         return sz;
0:     } // end of estimateMemoryUsage
0: 
0: 	public String getString()
0: 	{
0: 		if (!isNull())
0: 		{
0: 			if (valueString == null)
0: 			{
0: 				valueString = getTimestamp((Calendar) null).toString();
0:                 /* The java.sql.Timestamp.toString() method is supposed to return a string in
0:                  * the JDBC escape format. However the JDK 1.3 libraries truncate leading zeros from
0:                  * the year. This is not acceptable to DB2. So add leading zeros if necessary.
0:                  */
0:                 int separatorIdx = valueString.indexOf( '-');
0:                 if( separatorIdx >= 0 && separatorIdx < 4)
0:                 {
0:                     StringBuffer sb = new StringBuffer();
0:                     for( ; separatorIdx < 4; separatorIdx++)
0:                         sb.append('0');
0:                     sb.append( valueString);
0:                     valueString = sb.toString();
0:                 }
0: 			}
0: 
0: 			return valueString;
0: 		}
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (valueString != null)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
0: 				}
0: 			}
0: 			return null;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		getDate returns the date portion of the timestamp
0: 		Time is set to 00:00:00.0
0: 		Since Date is a JDBC object we use the JDBC definition
0: 		for the time portion.  See JDBC API Tutorial, 47.3.12.
0: 
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Date	getDate( Calendar cal) throws StandardException
0: 	{
0: 		if (isNull())
0: 			return null;
0:         return newDate(cal);
0:     }
0: 
0:     private Date newDate(java.util.Calendar cal) throws StandardException
0:     {
0:         if( cal == null)
0:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, SQLDate.getYear(encodedDate) );
0: 		cal.set(Calendar.MONTH, SQLDate.getMonth(encodedDate)-1);
0: 		cal.set(Calendar.DATE, SQLDate.getDay(encodedDate) );
0: 		cal.set(Calendar.HOUR_OF_DAY, 0);
0: 		cal.set(Calendar.MINUTE, 0);
0: 		cal.set(Calendar.SECOND, 0);
0: 		cal.set(Calendar.MILLISECOND, 0);
0: 		return new Date(cal.getTime().getTime());
0: 	}
0: 
0: 	/**
0: 		getTime returns the time portion of the timestamp
0: 		Date is set to 1970-01-01
0: 		Since Time is a JDBC object we use the JDBC definition
0: 		for the date portion.  See JDBC API Tutorial, 47.3.12.
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Time	getTime( Calendar cal) throws StandardException
0: 	{
0: 		if (isNull())
0: 			return null;
0:         return newTime(cal);
0:     }
0: 
0:     private Time newTime(java.util.Calendar cal) throws StandardException
0:     {
0:         if( cal == null)
0:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, 1970);
0: 		cal.set(Calendar.MONTH, Calendar.JANUARY);
0: 		cal.set(Calendar.DATE, 1);
0: 		cal.set(Calendar.HOUR_OF_DAY, SQLTime.getHour(encodedTime));
0: 		cal.set(Calendar.MINUTE, SQLTime.getMinute(encodedTime));
0: 		cal.set(Calendar.SECOND, SQLTime.getSecond(encodedTime));
0: 		cal.set(Calendar.MILLISECOND, (int)(nanos/1E06));
0: 		return new Time(cal.getTime().getTime());
0: 	}
0: 
0: 	public Object getObject()
0: 	{
0: 		return getTimestamp((Calendar) null);
0: 	}
0: 		
0: 	/* get storage length */
0: 	public int getLength()
0: 	{
0: 		return 12;
0: 	}
0: 
0: 	/* this is for DataType's error generator */
0: 	public String getTypeName()
0: 	{
0: 		return "TIMESTAMP";
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_TIMESTAMP_ID;
0: 	}
0: 
0: 	/** 
0: 		@exception IOException error writing data
0: 
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
0: 
0: 		/*
0: 		** Timestamp is written out 3 ints, encoded date, encoded time, and
0: 		** nanoseconds
0: 		*/
0: 		out.writeInt(encodedDate);
0: 		out.writeInt(encodedTime);
0: 		out.writeInt(nanos);
0: 	}
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on error reading the object
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException
0: 	{
0: 		encodedDate = in.readInt();
0: 		encodedTime = in.readInt();
0: 		nanos = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
0: 	{
0: 		encodedDate = in.readInt();
0: 		encodedTime = in.readInt();
0: 		nanos = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		// Call constructor with all of our info
0: 		return new SQLTimestamp(encodedDate, encodedTime, nanos);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLTimestamp();
0: 	}
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	 *
0: 	 */
0: 	public void restoreToNull()
0: 	{
0: 		// clear numeric representation
0: 		encodedDate = 0;
0: 		encodedTime = 0;
0: 		nanos = 0;
0: 
0: 		// clear cached valueString
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException, StandardException
0: 	{
0: 			setValue(resultSet.getTimestamp(colNumber), (Calendar) null);
0: 	}
0: 
0: 	public int compare(DataValueDescriptor other)
0: 		throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 		boolean thisNull, otherNull;
0: 
0: 		thisNull = this.isNull();
0: 		otherNull = other.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull	return
0: 		 *	T		T		 	0	(this == other)
0: 		 *	F		T		 	-1 	(this < other)
0: 		 *	T		F		 	1	(this > other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return 1;
0: 			return 0;
0: 		}
0: 
0: 		/*
0: 			Neither are null compare them 
0: 		 */
0: 
0: 		int comparison;
0: 		/* get the comparison date values */
0: 		int otherEncodedDate = 0;
0: 		int otherEncodedTime = 0;
0: 		int otherNanos = 0;
0: 
0: 		/* if the argument is another SQLTimestamp, look up the value
0: 		 */
0: 		if (other instanceof SQLTimestamp)
0: 		{
0: 			SQLTimestamp st = (SQLTimestamp)other;
0: 			otherEncodedDate= st.encodedDate;
0: 			otherEncodedTime= st.encodedTime;
0: 			otherNanos= st.nanos;
0: 		}
0: 		else 
0: 		{
0: 			/* O.K. have to do it the hard way and calculate the numeric value
0: 			 * from the value
0: 			 */
0: 			Calendar cal = new GregorianCalendar();
0: 			Timestamp otherts = other.getTimestamp(cal);
0: 			otherEncodedDate = SQLTimestamp.computeEncodedDate(otherts, cal);
0: 			otherEncodedTime = SQLTimestamp.computeEncodedTime(otherts, cal);
0: 			otherNanos = otherts.getNanos();
0: 		}
0: 		if (encodedDate < otherEncodedDate)
0: 			comparison = -1;
0: 		else if (encodedDate > otherEncodedDate)
0: 			comparison = 1;
0: 		else if (encodedTime < otherEncodedTime)
0: 			comparison = -1;
0: 		else if (encodedTime > otherEncodedTime)
0: 			comparison = 1;
0: 		else if (nanos < otherNanos)
0: 			comparison = -1;
0: 		else if (nanos > otherNanos)
0: 			comparison = 1;
0: 		else
0: 			comparison = 0;
0: 
0: 		return comparison;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || ((DataValueDescriptor)other).isNull())
0: 				return unknownRV;
0: 		}
0: 
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/*
0: 	** Class interface
0: 	*/
0: 
0: 	/*
0: 	** Constructors
0: 	*/
0: 
0: 	/** no-arg constructor required by Formattable */
0: 	public SQLTimestamp() { }
0: 
0: 
0: 	public SQLTimestamp(Timestamp value) throws StandardException
0: 	{
0: 		setValue(value, (Calendar) null);
0: 	}
0: 
0: 	private SQLTimestamp(int encodedDate, int encodedTime, int nanos) {
0: 
0: 		this.encodedDate = encodedDate;
0: 		this.encodedTime = encodedTime;
0: 		this.nanos = nanos;
0: 	}
0: 
0:     public SQLTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
0:     {
0:         Calendar cal = null;
0:         if( date == null || date.isNull()
0:             || time == null || time.isNull())
0:             return;
0:         if( date instanceof SQLDate)
0:         {
0:             SQLDate sqlDate = (SQLDate) date;
0:             encodedDate = sqlDate.getEncodedDate();
0:         }
0:         else
0:         {
0:             cal = new GregorianCalendar();
0:             encodedDate = computeEncodedDate( date.getDate( cal), cal);
0:         }
0:         if( time instanceof SQLTime)
0:         {
0:             SQLTime sqlTime = (SQLTime) time;
0:             encodedTime = sqlTime.getEncodedTime();
0:         }
0:         else
0:         {
0:             if( cal == null)
0:                 cal = new GregorianCalendar();
0:             encodedTime = computeEncodedTime( time.getTime( cal), cal);
0:         }
0:     }
0: 
0:     /**
0:      * Construct a timestamp from a string. The allowed formats are:
0:      *<ol>
0:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
0:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
0:      *</ol>
0:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
0:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
0:      */
0:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder)
0:         throws StandardException
0:     {
0:         parseTimestamp( timestampStr, isJDBCEscape,localeFinder, (Calendar) null);
0:     }
0:     
0:     /**
0:      * Construct a timestamp from a string. The allowed formats are:
0:      *<ol>
0:      *<li>JDBC escape: yyyy-mm-dd hh:mm:ss[.fffff]
0:      *<li>IBM: yyyy-mm-dd-hh.mm.ss[.nnnnnn]
0:      *</ol>
0:      * The format is specified by a parameter to the constructor. Leading zeroes may be omitted from the month, day,
0:      * and hour part of the timestamp. The microsecond part may be omitted or truncated.
0:      */
0:     public SQLTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         parseTimestamp( timestampStr, isJDBCEscape, localeFinder, cal);
0:     }
0: 
0:     static final char DATE_SEPARATOR = '-';
0:     private static final char[] DATE_SEPARATORS = { DATE_SEPARATOR};
0:     private static final char IBM_DATE_TIME_SEPARATOR = '-';
0:     private static final char ODBC_DATE_TIME_SEPARATOR = ' ';
0:     private static final char[] DATE_TIME_SEPARATORS = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR};
0:     private static final char[] DATE_TIME_SEPARATORS_OR_END
0:     = {IBM_DATE_TIME_SEPARATOR, ODBC_DATE_TIME_SEPARATOR, (char) 0};
0:     private static final char IBM_TIME_SEPARATOR = '.';
0:     private static final char ODBC_TIME_SEPARATOR = ':';
0:     private static final char[] TIME_SEPARATORS = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR};
0:     private static final char[] TIME_SEPARATORS_OR_END = {IBM_TIME_SEPARATOR, ODBC_TIME_SEPARATOR, (char) 0};
0:     private static final char[] END_OF_STRING = {(char) 0};
0:     
0:     private void parseTimestamp( String timestampStr, boolean isJDBCEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         StandardException thrownSE = null;
0:         DateTimeParser parser = new DateTimeParser( timestampStr);
0:         try
0:         {
0:             int[] dateTimeNano = parseDateOrTimestamp( parser, true);
0:             encodedDate = dateTimeNano[0];
0:             encodedTime = dateTimeNano[1];
0:             nanos = dateTimeNano[2];
0:             valueString = parser.getTrimmedString();
0:             return;
0:         }
0:         catch( StandardException se)
0:         {
0:             thrownSE = se;
0:         }
0:         // see if it is a localized timestamp
0:         try
0:         {
0:             timestampStr = StringUtil.trimTrailing( timestampStr);
0:             int[] dateAndTime = parseLocalTimestamp( timestampStr, localeFinder, cal);
0:             encodedDate = dateAndTime[0];
0:             encodedTime = dateAndTime[1];
0:             valueString = timestampStr;
0:             return;
0:         }
0:         catch( ParseException pe){}
0:         catch( StandardException se){}
0:         if( thrownSE != null)
0:             throw thrownSE;
0:         throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
0:     } // end of parseTimestamp
0: 
0:     /**
0:      * Parse a localized timestamp.
0:      *
0:      * @param str the timestamp string, with trailing blanks removed.
0:      * @param localFinder
0:      *
0:      * @return a {encodedDate, encodedTime} array.
0:      *
0:      * @exception ParseException If the string is not a valid timestamp.
0:      */
0:     static int[] parseLocalTimestamp( String str, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException, ParseException
0:     {
0:         DateFormat timestampFormat = null;
0:         if(localeFinder == null)
0:             timestampFormat = DateFormat.getDateTimeInstance();
0:         else if( cal == null)
0:             timestampFormat = localeFinder.getTimestampFormat();
0:         else
0:             timestampFormat = (DateFormat) localeFinder.getTimestampFormat().clone();
0:         if( cal == null)
0:             cal = new GregorianCalendar();
0:         else
0:             timestampFormat.setCalendar( cal);
0:         java.util.Date date = timestampFormat.parse( str);
0:             
0:         return new int[] { computeEncodedDate( date, cal), computeEncodedTime( date, cal)};
0:     } // end of parseLocalTimestamp
0: 
0:     /**
0:      * Parse a timestamp or a date. DB2 allows timestamps to be used as dates or times. So
0:      * date('2004-04-15-16.15.32') is valid, as is date('2004-04-15').
0:      *
0:      * This method does not handle localized timestamps.
0:      *
0:      * @param parser a DateTimeParser initialized with a string.
0:      * @param timeRequired If true then an error will be thrown if the time is missing. If false then the time may
0:      *                     be omitted.
0:      *
0:      * @return {encodedDate, encodedTime, nanosecond} array.
0:      *
0:      * @exception StandardException if the syntax is incorrect for an IBM standard timestamp.
0:      */
0:     static int[] parseDateOrTimestamp( DateTimeParser parser, boolean timeRequired)
0:         throws StandardException
0:     {
0:         int year = parser.parseInt( 4, false, DATE_SEPARATORS, false);
0:         int month = parser.parseInt( 2, true, DATE_SEPARATORS, false);
0:         int day = parser.parseInt( 2, true, timeRequired ? DATE_TIME_SEPARATORS : DATE_TIME_SEPARATORS_OR_END, false);
0:         int hour = 0;
0:         int minute = 0;
0:         int second = 0;
0:         int nano = 0;
0:         if( parser.getCurrentSeparator() != 0)
0:         {
0:             char timeSeparator = (parser.getCurrentSeparator() == ODBC_DATE_TIME_SEPARATOR)
0:               ? ODBC_TIME_SEPARATOR : IBM_TIME_SEPARATOR;
0:             hour = parser.parseInt( 2, true, TIME_SEPARATORS, false);
0:             if( timeSeparator == parser.getCurrentSeparator())
0:             {
0:                 minute = parser.parseInt( 2, false, TIME_SEPARATORS, false);
0:                 if( timeSeparator == parser.getCurrentSeparator())
0:                 {
0:                     second = parser.parseInt( 2, false, TIME_SEPARATORS_OR_END, false);
0:                     if( parser.getCurrentSeparator() == '.')
0:                         nano = parser.parseInt( MAX_FRACTION_DIGITS, true, END_OF_STRING, true)*FRACTION_TO_NANO;
0:                 }
0:             }
0:         }
0:         parser.checkEnd();
0:         return new int[] { SQLDate.computeEncodedDate( year, month, day),
0:                            SQLTime.computeEncodedTime( hour,minute,second),
0:                            nano};
0:     } // end of parseDateOrTimestamp
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#setValue
0: 	 *
0: 	 */
0: 	public void setValue(Object theValue) throws StandardException
0: 	{
0: 		if (theValue == null)
0: 		{
0: 			setToNull();
0: 		}
0: 		else if (theValue instanceof Date)
0: 		{
0: 			this.setValue((Date)theValue, (Calendar) null);
0: 		}
0: 		else if (theValue instanceof Time)
0: 		{
0: 			this.setValue((Time)theValue, (Calendar) null);
0: 		}
0: 		else if (theValue instanceof Timestamp)
0: 		{
0: 			this.setValue((Timestamp)theValue, (Calendar) null);
0: 		}
0: 		else
0: 		{
0: 			genericSetObject(theValue);
0: 		}
0: 	}
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		if (theValue instanceof SQLTimestamp) {
0: 			restoreToNull();
0: 			SQLTimestamp tvst = (SQLTimestamp) theValue;
0: 			encodedDate = tvst.encodedDate;
0: 			encodedTime = tvst.encodedTime;
0: 			nanos = tvst.nanos;
0:         }
0: 		else
0:         {
0:             Calendar cal = new GregorianCalendar();
0: 			setValue(theValue.getTimestamp( cal), cal);
0:         }
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 		When converting from a date to a timestamp, time is set to 00:00:00.0
0: 
0: 	 */
0: 	public void setValue(Date value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0:         if( value != null)
0:         {
0:             if( cal == null)
0:                 cal = new GregorianCalendar();
0:             encodedDate = computeEncodedDate(value, cal);
0:         }
0: 		/* encodedTime and nanos are already set to zero by restoreToNull() */
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 	 */
0: 	public void setValue(Time value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		if (value != null)
0: 		{
0: 			/*
0: 			** Create a new timestamp with today's date,
0: 			** and 'value' time.  
0: 			**
0: 			** We create a new calendar to get today's date
0: 			*/
0: 			Calendar today = GregorianCalendar.getInstance();
0: 			encodedDate = SQLDate.computeEncodedDate(today);
0:             if( cal == null)
0:                 cal = today;
0: 			encodedTime = computeEncodedTime(value, cal);
0: 		}
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 	 */
0: 	public void setValue(Timestamp value, Calendar cal) 
0: 	    throws StandardException
0: 	{
0: 		restoreToNull();
0: 		setNumericTimestamp(value, cal);
0: 	}
0: 
0: 
0: 	public void setValue(String theValue)
0: 	    throws StandardException
0: 	{
0: 		restoreToNull();
0: 
0: 		if (theValue != null)
0: 		{
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
0:             parseTimestamp( theValue,
0:                             false,
0:                             (databaseContext == null) ? null : databaseContext.getDatabase(),
0:                             (Calendar) null);
0: 		}
0: 		/* restoreToNull will have already set the encoded date to 0 (null value) */
0: 	}
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getYear
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getYear(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on a null");
0: 		}
0: 		return SQLDate.setSource(SQLDate.getYear(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMonth
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMonth(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on a null");
0: 		}
0: 		return SQLDate.setSource(SQLDate.getMonth(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getDate
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getDate(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on a null");
0: 		}
0: 		return SQLDate.setSource(SQLDate.getDay(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getHours
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getHours(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getHours called on a null");
0: 		}
0: 		return SQLDate.setSource(SQLTime.getHour(encodedTime), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMinutes
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMinutes(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinute called on a null");
0: 		}
0: 		return SQLDate.setSource(SQLTime.getMinute(encodedTime), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getSeconds
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getSeconds(NumberDataValue source)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getSeconds called on a null");
0: 			SanityManager.ASSERT(source == null || source instanceof SQLDouble,
0: 		"getSeconds for a timestamp was given a source other than a SQLDouble");
0: 		}
0: 		NumberDataValue result;
0: 
0: 		if (source != null)
0: 			result = source;
0: 		else
0: 			result = new SQLDouble();
0: 
0: 		result.setValue((double)(SQLTime.getSecond(encodedTime))
0: 				+ ((double)nanos)/1.0e9);
0: 
0: 		return result;
0: 	}
0: 
0: 	/*
0: 	** String display of value
0: 	*/
0: 
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return "NULL";
0: 		}
0: 		else
0: 		{
0: 			return getTimestamp( (Calendar) null).toString();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return 0;
0: 		}
0: 		
0: 		return  encodedDate + encodedTime + nanos; //since 0 is null
0: 
0: 	}
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int	typePrecedence()
0: 	{
0: 		return TypeId.TIMESTAMP_PRECEDENCE;
0: 	}
0: 
0: 	/**
0: 	 * Check if the value is null.  encodedDate value of 0 is null
0: 	 *
0: 	 * @return Whether or not value is logically null.
0: 	 */
0: 	public final boolean isNull()
0: 	{
0: 		return (encodedDate == 0);
0: 	}
0: 
0: 	/**
0: 	 * Get the value field.  We instantiate the field
0: 	 * on demand.
0: 	 *
0: 	 * @return	The value field.
0: 	 */
0: 	public Timestamp getTimestamp(java.util.Calendar cal)
0: 	{
0: 		if (isNull())
0: 			return null;
0:         return newTimestamp(cal);
0:     }
0: 
0:     protected Timestamp newTimestamp(Calendar currentCal)
0:     {
0:         if( currentCal == null)
0:             currentCal = new GregorianCalendar();
0: 		currentCal.set(Calendar.YEAR, SQLDate.getYear(encodedDate));
0: 		/* Note calendar month is zero based so we subtract 1*/
0: 		currentCal.set(Calendar.MONTH, (SQLDate.getMonth(encodedDate)-1));
0: 		currentCal.set(Calendar.DATE, SQLDate.getDay(encodedDate));
0: 		currentCal.set(Calendar.HOUR_OF_DAY, SQLTime.getHour(encodedTime));
0: 		currentCal.set(Calendar.MINUTE, SQLTime.getMinute(encodedTime));
0: 		currentCal.set(Calendar.SECOND, SQLTime.getSecond(encodedTime));
0: 		currentCal.set(Calendar.MILLISECOND, 0);
0: 		Timestamp t = new Timestamp(currentCal.getTime().getTime());
0: 		t.setNanos(nanos);
0: 		return t;
0: 	}
0: 	/**
0: 	 * Set the encoded values for the timestamp
0: 	 *
0: 	 */
0: 	private void setNumericTimestamp(Timestamp value, Calendar cal) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isNull(), "setNumericTimestamp called when already set");
0: 		}
0: 		if (value != null)
0: 		{
0:             if( cal == null)
0:                 cal = new GregorianCalendar();
0: 			encodedDate = computeEncodedDate(value, cal);
0: 			encodedTime = computeEncodedTime(value, cal);
0: 			nanos = value.getNanos();
0: 		}
0: 		/* encoded date should already be 0 for null */
0: 	}
0: 
0: 	// International Support
0: 
0: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
0: 	{
0: 		if (isNull())
0: 		{
0: 			return getString();
0: 		}
0: 
0: 
0: 		return localeFinder.getTimestampFormat().format(getTimestamp((Calendar) null));
0: 	}
0: 
0: 	/**
0: 		computeEncodedDate sets the date in a Calendar object
0: 		and then uses the SQLDate function to compute an encoded date
0: 		The encoded date is
0: 			year << 16 + month << 8 + date
0: 		@param value	the value to convert
0: 		@return 		the encodedDate
0: 
0: 	 */
0: 	private static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
0: 	{
0: 		if (value == null)
0: 			return 0;
0: 
0: 		currentCal.setTime(value);
0: 		return SQLDate.computeEncodedDate(currentCal);
0: 	}
0: 	/**
0: 		computeEncodedTime extracts the hour, minute and seconds from
0: 		a java.util.Date value and encodes them as
0: 			hour << 16 + minute << 8 + second
0: 		using the SQLTime function for encoding the data
0: 		@param value	the value to convert
0: 		@return 		the encodedTime
0: 
0: 	 */
0: 	private static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
0: 	{
0: 		currentCal.setTime(value);
0: 		return SQLTime.computeEncodedTime(currentCal);
0: 	}
0: }
0: 
============================================================================