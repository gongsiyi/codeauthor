1:9bbe2e4: /*
1:9bbe2e4:  *
1:9bbe2e4:  * Derby - Class org.apache.derbyTesting.system.sttest.Sttest
1:9bbe2e4:  *
1:9bbe2e4:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9bbe2e4:  * contributor license agreements. See the NOTICE file distributed with this
1:9bbe2e4:  * work for additional information regarding copyright ownership. The ASF
1:9bbe2e4:  * licenses this file to You under the Apache License, Version 2.0 (the
1:9bbe2e4:  * "License"); you may not use this file except in compliance with the License.
1:9bbe2e4:  * You may obtain a copy of the License at
1:9bbe2e4:  *
1:9bbe2e4:  * http://www.apache.org/licenses/LICENSE-2.0
1:9bbe2e4:  *
1:9bbe2e4:  * Unless required by applicable law or agreed to in writing, software
1:9bbe2e4:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
1:9bbe2e4:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
1:9bbe2e4:  * License for the specific language governing permissions and limitations under
1:9bbe2e4:  * the License.
1:9bbe2e4:  *
1:9bbe2e4:  */
1:9bbe2e4: 
1:9bbe2e4: package org.apache.derbyTesting.system.sttest;
1:9bbe2e4: 
1:9bbe2e4: import java.io.FileInputStream;
1:9bbe2e4: import java.io.IOException;
1:bbde618: import java.sql.CallableStatement;
1:9bbe2e4: import java.sql.Connection;
1:9bbe2e4: import java.sql.DriverManager;
1:9bbe2e4: import java.sql.ResultSet;
1:9bbe2e4: import java.sql.SQLException;
1:9bbe2e4: import java.util.Date;
1:9bbe2e4: import java.util.Enumeration;
1:9bbe2e4: import java.util.Properties;
1:9bbe2e4: import java.util.Random;
1:9bbe2e4: 
1:9bbe2e4: import org.apache.derby.tools.JDBCDisplayUtil;
1:9bbe2e4: import org.apache.derby.tools.ij;
1:9bbe2e4: import org.apache.derbyTesting.system.sttest.tools.MemCheck;
1:9bbe2e4: import org.apache.derbyTesting.system.sttest.utils.Datatypes;
1:9bbe2e4: import org.apache.derbyTesting.system.sttest.utils.Setup;
1:9bbe2e4: import org.apache.derbyTesting.system.sttest.utils.StStatus;
1:9bbe2e4: 
1:9bbe2e4: /*
1:9bbe2e4:  * * Sttest.java * 'Sttest' is short for 'single table test.' Sttest.java
1:9bbe2e4:  * supplies * the main entry point and the top level code for controlling the *
1:9bbe2e4:  * actions of the test, including the ddl for the table and indexes. * The
1:9bbe2e4:  * purpose of the test is to exercise the store code by running * updates on the
1:9bbe2e4:  * single table for an indefinitely long time, with * an indefinitely large
1:9bbe2e4:  * number of user connections, each randomly * executing one of a small number
1:9bbe2e4:  * of update procedures with random * data. The test sets a minimum and maximum
1:9bbe2e4:  * number of rows, builds * the table up to the minimum number of rows, and from
1:9bbe2e4:  * that point * either gradually grows the table to the max size, or gradually *
1:9bbe2e4:  * shrinks it to the min size. Periodically memory use is reported, * and the
1:9bbe2e4:  * table is compressed, to keep performance from deteriorating.
1:9bbe2e4:  */
1:9bbe2e4: public class Sttest extends Thread {
1:9bbe2e4: 
1:9bbe2e4: 	static int loops = 200;
1:9bbe2e4: 
1:9bbe2e4: 	static int rowcount = 0;
1:9bbe2e4: 
1:9bbe2e4: 	static int testcount = 0;
1:9bbe2e4: 
1:9bbe2e4: 	static int connections_to_make = 250;
1:9bbe2e4: 
1:9bbe2e4: 	static Random rand;
1:9bbe2e4: 
1:9bbe2e4: 	static boolean increase = true;
1:9bbe2e4: 
1:9bbe2e4: 	static boolean not_finished = true;
1:9bbe2e4: 
1:ef9dc99: 	static int targetmax = 100000; // build up to 1GB database
1:9bbe2e4: 
1:9bbe2e4: 	static int targetmin = 90000;
1:9bbe2e4: 
1:9bbe2e4: 	static int insertsize = 7;
1:9bbe2e4: 
1:9bbe2e4: 	static int updatesize = 1;
1:9bbe2e4: 
1:9bbe2e4: 	static int deletesize = 1;
1:9bbe2e4: 
1:9bbe2e4: 	static boolean fatal = false;
1:9bbe2e4: 
1:9bbe2e4: 	static int rows = 0;
1:9bbe2e4: 
1:9bbe2e4: 	static boolean countlock = false;
1:9bbe2e4: 
1:9bbe2e4: 	static int delete_freq = 1;
1:9bbe2e4: 
1:9bbe2e4: 	static int locker_id = -1;
1:9bbe2e4: 
1:9bbe2e4: 	static final int INIT = 0;
1:9bbe2e4: 
1:9bbe2e4: 	static final int GROW = 1;
1:9bbe2e4: 
1:9bbe2e4: 	static final int SHRINK = 2;
1:9bbe2e4: 
1:9bbe2e4: 	static int mode = INIT;
1:9bbe2e4: 
1:9bbe2e4: 	static int count_timer = 0;
1:9bbe2e4: 
1:9bbe2e4: 	static int inserts_to_try = 0;
1:9bbe2e4: 
1:ef9dc99: 	static final int INITIAL_CONNECTIONS = 2; // initial connections should be
1:9bbe2e4: 
1:9bbe2e4: 	// low, otherwise deadlock will
1:9bbe2e4: 	// happen.
1:9bbe2e4: 
1:9bbe2e4: 	static boolean startByIJ = false;
1:9bbe2e4: 
1:9bbe2e4: 	static String dbURL = "jdbc:derby:testDB";
1:9bbe2e4: 
1:9bbe2e4: 	static String driver = "org.apache.derby.jdbc.EmbeddedDriver";
1:9bbe2e4: 
1:9bbe2e4: 	static StStatus status = null;
1:9bbe2e4: 
1:9bbe2e4: 	int thread_id;
1:9bbe2e4: 
1:9bbe2e4: 	int ind = 0;
1:9bbe2e4: 
1:9bbe2e4: 	public static void main(String[] args) throws SQLException, IOException,
1:9bbe2e4: 	InterruptedException, Exception, Throwable {
1:9bbe2e4: 		System.getProperties().put("derby.locks.deadlockTimeout", "60");
1:9bbe2e4: 		System.getProperties().put("derby.locks.waitTimeout", "200");
1:9bbe2e4: 		System.out.println("Test Sttest starting");
1:9bbe2e4: 		System.getProperties().put("derby.infolog.append", "true");
1:9bbe2e4: 		System.getProperties().put("derby.stream.error.logSeverityLevel", "0");
1:ef9dc99: 		// get any properties user may have set in Sttest.properties file
1:ef9dc99: 		// these will override any of those set above
1:9bbe2e4: 		userProperties();
1:4469400: 		Class<?> clazz = Class.forName(driver);
1:4469400:         clazz.getConstructor().newInstance();
1:9bbe2e4: 		if (Setup.doit(dbURL) == false)
1:9bbe2e4: 			System.exit(1);
1:9bbe2e4: 		status = new StStatus();
1:9bbe2e4: 		sttTop();
5:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static void userProperties() throws Throwable {
1:9bbe2e4: 		FileInputStream fileIn = null;
2:9bbe2e4: 		try {
1:9bbe2e4: 			fileIn = new FileInputStream("Sttest.properties");
1:9bbe2e4: 		} catch (Exception e) {
2:9bbe2e4: 			System.out
1:9bbe2e4: 			.println("user control file 'Sttest.properties' not found; using defaults");
1:9bbe2e4: 		}
1:9bbe2e4: 		if (fileIn != null) {
1:9bbe2e4: 			Properties props = new Properties();
1:9bbe2e4: 			props.load(fileIn);
1:9bbe2e4: 			fileIn.close();
1:9bbe2e4: 			String prop = null;
1:9bbe2e4: 			prop = props.getProperty("connections");
1:9bbe2e4: 			if (prop != null)
1:9bbe2e4: 				connections_to_make = Integer.parseInt(prop);
1:9bbe2e4: 			prop = props.getProperty("dbURL");
1:9bbe2e4: 			if (prop != null)
1:9bbe2e4: 				dbURL = prop;
1:9bbe2e4: 			prop = props.getProperty("driver");
1:9bbe2e4: 			if (prop != null)
1:9bbe2e4: 				driver = prop;
1:ef9dc99: 			// allows us to get any other properties into the system
1:9bbe2e4: 			Properties sysprops = System.getProperties();
1:9bbe2e4: 			Enumeration list = props.propertyNames();
1:9bbe2e4: 			String s = null;
1:9bbe2e4: 			while (list.hasMoreElements()) {
1:9bbe2e4: 				s = (String) list.nextElement();
1:9bbe2e4: 				sysprops.put(s, props.getProperty(s));
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:9bbe2e4: 		System.out.println("driver = " + driver);
1:9bbe2e4: 		System.out.println("dbURL = " + dbURL);
1:9bbe2e4: 		System.out.println("connections = " + connections_to_make);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public static void sttTop() throws SQLException, IOException,
1:9bbe2e4: 	InterruptedException, Exception, Throwable {
1:9bbe2e4: 		rand = new Random();
32:ef9dc99: 
1:ef9dc99: 		Datatypes.Rn = rand;
1:ef9dc99: 		// harder to actually delete rows when there are
1:ef9dc99: 		// more connections, so repeat operation more often
1:9bbe2e4: 		delete_freq = 1 + connections_to_make % 5;
1:9bbe2e4: 		initial_data();
1:9bbe2e4: 		Date d = new Date();
1:9bbe2e4: 		status.firstMessage(connections_to_make, d);
1:9bbe2e4: 		// check memory in separate thread-- allows us to monitor
1:9bbe2e4: 		// usage during database calls
1:9bbe2e4: 		// 200,000 msec = 3min, 20 sec delay between checks
1:9bbe2e4: 		MemCheck mc = new MemCheck(200000);
1:9bbe2e4: 		mc.start();
1:9bbe2e4: 		Sttest testsessions[] = new Sttest[connections_to_make];
1:9bbe2e4: 		for (int i = 0; i < connections_to_make; i++) {
1:9bbe2e4: 			testsessions[i] = new Sttest(i);
1:9bbe2e4: 			testsessions[i].start();
1:9bbe2e4: 			sleep(3000);
1:9bbe2e4: 		}
1:9bbe2e4: 		for (int i = 0; i < connections_to_make; i++) {
1:9bbe2e4: 			testsessions[i].join();
1:9bbe2e4: 		}
1:9bbe2e4: 		try {
1:9bbe2e4: 			mc.stopNow = true;
1:9bbe2e4: 			mc.join();
1:9bbe2e4: 		} catch (Throwable t) {
1:9bbe2e4: 			throw (t);
1:9bbe2e4: 		}
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	Sttest(int num) throws SQLException {
1:9bbe2e4: 		this.thread_id = num;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized void reset_loops(int myloopcount) {
1:9bbe2e4: 		if (myloopcount == loops)
1:9bbe2e4: 			loops--;
1:9bbe2e4: 		// otherwise some other thread got there first and reset it
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	// available to force synchronization of get_countlock(), ...
1:9bbe2e4: 	static synchronized void locksync() {
2:9bbe2e4: 		return;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized boolean get_countlock() {
1:9bbe2e4: 		locksync();
1:9bbe2e4: 		return (countlock);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized boolean set_countlock(boolean state) {
1:9bbe2e4: 		locksync();
1:9bbe2e4: 		if (state == true && countlock == true)
1:9bbe2e4: 			return (false);
1:9bbe2e4: 		countlock = state;
1:9bbe2e4: 		return (true);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized void changerowcount(int in) {
1:9bbe2e4: 		rowcount += in;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized void changerowcount2zero() {
1:9bbe2e4: 		rowcount = 0;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static void initial_data() throws Exception, Throwable {
1:9bbe2e4: 		Connection conn = null;
1:9bbe2e4: 		int rows = 0;
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn = mystartJBMS();
1:9bbe2e4: 		} catch (Throwable t) {
1:9bbe2e4: 			throw (t);
1:9bbe2e4: 		}
1:9bbe2e4: 		// our goal is to get up to minimum table size
1:9bbe2e4: 		int x = Datatypes.get_table_count(conn);
1:9bbe2e4: 		if (x != -1) {
1:9bbe2e4: 			rows = x;
1:9bbe2e4: 		}
1:9bbe2e4: 		if (conn != null) {
2:9bbe2e4: 			conn.commit();
1:9bbe2e4: 			conn.close();
1:9bbe2e4: 		}
1:9bbe2e4: 		rowcount = rows;
1:9bbe2e4: 		if (rows >= targetmin) {
1:9bbe2e4: 			mode = GROW;
1:9bbe2e4: 			System.out.println("initial data not needed");
1:9bbe2e4: 			return;
1:9bbe2e4: 		}
1:9bbe2e4: 		inserts_to_try = targetmin - rows;
1:9bbe2e4: 		Sttest testthreads[] = new Sttest[INITIAL_CONNECTIONS];
1:9bbe2e4: 		for (int i = 0; i < INITIAL_CONNECTIONS; i++) {
1:9bbe2e4: 			testthreads[i] = new Sttest(i);
1:9bbe2e4: 			testthreads[i].start();
1:9bbe2e4: 		}
1:9bbe2e4: 		for (int i = 0; i < INITIAL_CONNECTIONS; i++) {
1:9bbe2e4: 			testthreads[i].join();
1:9bbe2e4: 		}
1:9bbe2e4: 		mode = GROW;
1:9bbe2e4: 		System.out.println("complete initial data");
1:9bbe2e4: 		return;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public void run() {
1:9bbe2e4: 		Connection conn = null;
1:9bbe2e4: 		Date d = null;
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn = mystartJBMS();
1:9bbe2e4: 		} catch (Throwable t) {
1:9bbe2e4: 			return;
1:9bbe2e4: 		}
1:9bbe2e4: 		int ind2 = 0;
1:9bbe2e4: 		int myloops = loops;
1:9bbe2e4: 		while (not_finished) {
1:9bbe2e4: 			if (loops <= 0)
1:9bbe2e4: 				break;// done
1:9bbe2e4: 			// thread-private copy to be checked against global copy
1:9bbe2e4: 			// before attempting to update
1:9bbe2e4: 			myloops = loops;
1:9bbe2e4: 			if (fatal == true)
1:9bbe2e4: 				break;
1:9bbe2e4: 			if (mode == INIT && inserts_to_try <= 0) {
1:9bbe2e4: 				break;
1:9bbe2e4: 			}
1:9bbe2e4: 			// test rowcount
1:9bbe2e4: 			if (mode == GROW && rowcount > targetmax) {
1:9bbe2e4: 				System.out.println("hit targetmax with " + rowcount + " " + d);
1:9bbe2e4: 				d = new Date();
1:9bbe2e4: 				mode = SHRINK;
1:9bbe2e4: 				reset_loops(myloops);
1:9bbe2e4: 				insertsize = 1;
1:9bbe2e4: 				deletesize = 12;
1:9bbe2e4: 				if (set_countlock(true) == true) {
1:9bbe2e4: 					try {
1:9bbe2e4: 						checkrowcount(conn);
1:9bbe2e4: 						MemCheck.showmem();
1:9bbe2e4: 						status.updateStatus();
1:9bbe2e4: 					} catch (Exception e) {
1:9bbe2e4: 						System.out.println("unexpected exception in rowcount");
1:9bbe2e4: 						set_countlock(false);
1:9bbe2e4: 						System.exit(1);
1:9bbe2e4: 					}
1:9bbe2e4: 					MemCheck.showmem();
1:9bbe2e4: 				}
1:9bbe2e4: 				set_countlock(false);
1:9bbe2e4: 				yield();
1:9bbe2e4: 			} else if (mode == GROW && rowcount >= targetmax) {
1:9bbe2e4: 				d = new Date();
1:9bbe2e4: 				System.out.println("hit targetmax with " + rowcount + " " + d);
1:9bbe2e4: 				mode = SHRINK;
1:9bbe2e4: 				insertsize = 1;
1:9bbe2e4: 				deletesize = 12;
1:9bbe2e4: 			} else if (mode == SHRINK && rowcount <= targetmin) {
1:9bbe2e4: 				d = new Date();
1:9bbe2e4: 				System.out.println("hit targetmin with " + rowcount + " " + d);
1:9bbe2e4: 				mode = GROW;
1:9bbe2e4: 				reset_loops(myloops);
1:9bbe2e4: 				insertsize = 8;
1:9bbe2e4: 				deletesize = 1;
1:9bbe2e4: 				if (set_countlock(true) == true) {
1:9bbe2e4: 					try {
1:9bbe2e4: 						checkrowcount(conn);
1:9bbe2e4: 						MemCheck.showmem();
1:9bbe2e4: 						status.updateStatus();
1:9bbe2e4: 					} catch (Exception e) {
1:9bbe2e4: 						System.out.println("unexpected exception in rowcount");
1:9bbe2e4: 						set_countlock(false);
1:9bbe2e4: 						System.exit(1);
1:9bbe2e4: 					}
1:9bbe2e4: 					MemCheck.showmem();
1:bbde618: 					// compress 
1:bbde618: 					try {
1:bbde618: 						compress(conn);
1:bbde618: 					} catch  (Exception e) {
1:bbde618: 						System.out.println("unexpected exception during compress");
1:bbde618: 					}
1:9bbe2e4: 				}
1:9bbe2e4: 				set_countlock(false);
1:9bbe2e4: 				yield();
1:9bbe2e4: 			}
1:9bbe2e4: 			// don't interfere with count query
1:9bbe2e4: 			while (get_countlock() == true) {
1:9bbe2e4: 				try {
1:9bbe2e4: 					sleep(1000);
1:9bbe2e4: 				} catch (java.lang.InterruptedException ex) {
1:9bbe2e4: 					System.out.println("unexpected sleep interruption");
1:9bbe2e4: 					break;
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:9bbe2e4: 			try {
1:9bbe2e4: 				if (mode == INIT)
1:9bbe2e4: 					ind = 0;
1:9bbe2e4: 				else
1:9bbe2e4: 					ind = Math.abs(rand.nextInt() % 3);
1:9bbe2e4: 				switch (ind) {
1:9bbe2e4: 				case 0:
1:9bbe2e4: 					ind2 = Math.abs(rand.nextInt() % insertsize);
1:ef9dc99: 					int addrows = 0;
1:9bbe2e4: 					for (int i = 0; i <= ind2; i++) {
1:9bbe2e4: 						Datatypes.add_one_row(conn, thread_id);
1:ef9dc99: 						addrows++;
1:9bbe2e4: 						conn.commit();
1:9bbe2e4: 						if (mode == INIT) {
1:9bbe2e4: 							inserts_to_try--;
1:9bbe2e4: 						}
1:9bbe2e4: 						yield();
1:9bbe2e4: 						changerowcount(1);
1:9bbe2e4: 					}
1:ef9dc99: 					System.out.println(addrows + "  Rows inserted");
1:9bbe2e4: 					break;
1:9bbe2e4: 				case 1:
1:9bbe2e4: 					ind2 = Math.abs(rand.nextInt() % updatesize);
1:ef9dc99: 					int updaterow = 0;
1:9bbe2e4: 					for (int i = 0; i <= ind2; i++) {
1:9bbe2e4: 						Datatypes.update_one_row(conn, thread_id);
1:ef9dc99: 						updaterow++;
1:9bbe2e4: 						conn.commit();
1:9bbe2e4: 						yield();
1:9bbe2e4: 					}
1:ef9dc99: 					System.out.println(updaterow + "  rows updated");
1:9bbe2e4: 					break;
1:9bbe2e4: 				case 2:
1:9bbe2e4: 					ind2 = Math.abs(rand.nextInt() % deletesize);
1:9bbe2e4: 					int del_rows = 0;
1:9bbe2e4: 					del_rows = Datatypes.delete_some(conn, thread_id, ind2 + 1);
1:9bbe2e4: 					yield();
1:9bbe2e4: 					changerowcount(-1 * del_rows);
1:ef9dc99: 					// commits are done inside delete_some()
1:ef9dc99: 					System.out.println(del_rows + " rows deleted");
1:9bbe2e4: 					break;
1:ef9dc99: 				} // end switch
1:9bbe2e4: 
2:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				if (se.getSQLState() == null)
1:9bbe2e4: 					se.printStackTrace();
1:9bbe2e4: 				if (se.getSQLState().equals("40001")) {
1:9bbe2e4: 					System.out.println("t" + thread_id + " deadlock op = "
1:9bbe2e4: 							+ ind);
2:9bbe2e4: 					continue;
1:9bbe2e4: 				}
1:9bbe2e4: 				if (se.getSQLState().equals("40XL1")) {
1:9bbe2e4: 					System.out
1:9bbe2e4: 					.println("t" + thread_id + " timeout op = " + ind);
1:9bbe2e4: 					continue;
1:9bbe2e4: 				}
1:9bbe2e4: 				if (se.getSQLState().equals("23500")) {
1:9bbe2e4: 					System.out.println("t" + thread_id
1:9bbe2e4: 							+ " duplicate key violation\n");
1:9bbe2e4: 					continue;
1:9bbe2e4: 				}
1:9bbe2e4: 				if (se.getSQLState().equals("23505")) {
1:9bbe2e4: 					System.out.println("t" + thread_id
1:9bbe2e4: 							+ " duplicate key violation\n");
1:9bbe2e4: 					continue;
1:9bbe2e4: 				}
1:9bbe2e4: 				System.out.println("t" + thread_id
1:9bbe2e4: 						+ " FAIL -- unexpected exception:");
2:9bbe2e4: 				JDBCDisplayUtil.ShowException(System.out, se);
1:9bbe2e4: 				fatal = true;
1:9bbe2e4: 				break;
1:9bbe2e4: 			} catch (Throwable e) {
1:9bbe2e4: 				e.printStackTrace();
1:9bbe2e4: 				if (e.getMessage().equals("java.lang.ThreadDeath")) {
1:9bbe2e4: 					System.out.println("caught threaddeath and continuing\n");
2:9bbe2e4: 				} else {
1:9bbe2e4: 					fatal = true;
1:9bbe2e4: 					e.printStackTrace();
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:ef9dc99: 		}// end while
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn.close();
1:9bbe2e4: 		} catch (Throwable e) {
1:9bbe2e4: 			e.printStackTrace();
1:9bbe2e4: 		}
1:9bbe2e4: 		System.out.println("Thread finished: " + thread_id);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized void checkrowcount(Connection conn)
1:9bbe2e4: 	throws java.lang.Exception {
1:9bbe2e4: 		int x = Datatypes.get_table_count(conn);
1:9bbe2e4: 		if (x == -1) { // count timed itself out
1:9bbe2e4: 			System.out.println("table count timed out");
1:9bbe2e4: 		} else {
1:9bbe2e4: 			System.out.println("rowcount by select: " + x
1:9bbe2e4: 					+ " client rowcount = " + rowcount);
1:9bbe2e4: 			changerowcount(x - rowcount);
1:9bbe2e4: 		}
1:9bbe2e4: 		conn.commit();
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static public Connection mystartJBMS() throws Throwable {
1:9bbe2e4: 		Connection conn = null;
1:9bbe2e4: 		if (startByIJ == true) {
1:9bbe2e4: 			conn = ij.startJBMS();
2:9bbe2e4: 		} else
1:9bbe2e4: 			try {
1:9bbe2e4: 				conn = DriverManager.getConnection(dbURL + ";create=false");
1:9bbe2e4: 				conn.setAutoCommit(false);
1:9bbe2e4: 				conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				System.out.println("connect failed  for " + dbURL);
1:9bbe2e4: 				JDBCDisplayUtil.ShowException(System.out, se);
1:9bbe2e4: 			}
1:9bbe2e4: 			return (conn);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static synchronized void compress(Connection conn)
1:9bbe2e4: 	throws java.lang.Exception {
1:9bbe2e4: 		System.out.println("compressing table");
1:bbde618: 		boolean autocom = conn.getAutoCommit();
1:9bbe2e4: 		try {
1:bbde618: 			conn.setAutoCommit(true);
1:bbde618: 			CallableStatement cs = conn.prepareCall(
1:bbde618: 				"CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1:bbde618: 			cs.setString(1, "APP");
1:bbde618: 			cs.setString(2, "DATATYPES");
1:bbde618: 			cs.setShort(3, (short) 1);
1:bbde618: 			cs.setShort(4, (short) 1);
1:bbde618: 			cs.setShort(5, (short) 1);
1:bbde618: 			cs.execute();
1:bbde618: 			cs.close();
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			System.out.println("compress table: FAIL -- unexpected exception:");
1:9bbe2e4: 			JDBCDisplayUtil.ShowException(System.out, se);
1:bbde618: 			se.printStackTrace();
1:9bbe2e4: 		}
1:bbde618: 		conn.setAutoCommit(autocom);
1:bbde618: 	}
1:9bbe2e4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: 		Class<?> clazz = Class.forName(driver);
1:         clazz.getConstructor().newInstance();
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:bbde618
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					// compress 
1: 					try {
1: 						compress(conn);
1: 					} catch  (Exception e) {
1: 						System.out.println("unexpected exception during compress");
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 		boolean autocom = conn.getAutoCommit();
1: 			conn.setAutoCommit(true);
1: 			CallableStatement cs = conn.prepareCall(
1: 				"CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1: 			cs.setString(1, "APP");
1: 			cs.setString(2, "DATATYPES");
1: 			cs.setShort(3, (short) 1);
1: 			cs.setShort(4, (short) 1);
1: 			cs.setShort(5, (short) 1);
1: 			cs.execute();
1: 			cs.close();
1: 			se.printStackTrace();
1: 		conn.setAutoCommit(autocom);
1: }
commit:9bbe2e4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * 
1:  * Derby - Class org.apache.derbyTesting.system.sttest.Sttest
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements. See the NOTICE file distributed with this
1:  * work for additional information regarding copyright ownership. The ASF
1:  * licenses this file to You under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  * 
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * 
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
1:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
1:  * License for the specific language governing permissions and limitations under
1:  * the License.
1:  *  
1:  */
1: 
1: package org.apache.derbyTesting.system.sttest;
1: 
1: import java.io.FileInputStream;
1: import java.io.IOException;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.Statement;
1: import java.util.Date;
1: import java.util.Enumeration;
1: import java.util.Properties;
1: import java.util.Random;
1: 
1: import org.apache.derby.tools.JDBCDisplayUtil;
1: import org.apache.derby.tools.ij;
1: import org.apache.derbyTesting.system.sttest.tools.MemCheck;
1: import org.apache.derbyTesting.system.sttest.utils.Datatypes;
1: import org.apache.derbyTesting.system.sttest.utils.Setup;
1: import org.apache.derbyTesting.system.sttest.utils.StStatus;
1: 
1: /*
1:  * * Sttest.java * 'Sttest' is short for 'single table test.' Sttest.java
1:  * supplies * the main entry point and the top level code for controlling the *
1:  * actions of the test, including the ddl for the table and indexes. * The
1:  * purpose of the test is to exercise the store code by running * updates on the
1:  * single table for an indefinitely long time, with * an indefinitely large
1:  * number of user connections, each randomly * executing one of a small number
1:  * of update procedures with random * data. The test sets a minimum and maximum
1:  * number of rows, builds * the table up to the minimum number of rows, and from
1:  * that point * either gradually grows the table to the max size, or gradually *
1:  * shrinks it to the min size. Periodically memory use is reported, * and the
1:  * table is compressed, to keep performance from deteriorating.
1:  */
1: public class Sttest extends Thread {
1: 	
1: 	static int loops = 200;
1: 	
1: 	static int rowcount = 0;
1: 	
1: 	static int testcount = 0;
1: 	
1: 	static int connections_to_make = 250;
1: 	
1: 	static Random rand;
1: 	
1: 	static boolean increase = true;
1: 	
1: 	static boolean not_finished = true;
1: 	
0: 	static int targetmax = 100000; //build up to 1GB database
1: 	
1: 	static int targetmin = 90000;
1: 	
1: 	static int insertsize = 7;
1: 	
1: 	static int updatesize = 1;
1: 	
1: 	static int deletesize = 1;
1: 	
1: 	static boolean fatal = false;
1: 	
1: 	static int rows = 0;
1: 	
1: 	static boolean countlock = false;
1: 	
1: 	static int delete_freq = 1;
1: 	
1: 	static int locker_id = -1;
1: 	
1: 	static final int INIT = 0;
1: 	
1: 	static final int GROW = 1;
1: 	
1: 	static final int SHRINK = 2;
1: 	
1: 	static int mode = INIT;
1: 	
1: 	static int count_timer = 0;
1: 	
1: 	static int inserts_to_try = 0;
1: 	
0: 	static final int INITIAL_CONNECTIONS = 2; //initial connections should be
1: 	
1: 	// low, otherwise deadlock will
1: 	// happen.
1: 	
1: 	static boolean startByIJ = false;
1: 	
1: 	static String dbURL = "jdbc:derby:testDB";
1: 	
1: 	static String driver = "org.apache.derby.jdbc.EmbeddedDriver";
1: 	
1: 	static StStatus status = null;
1: 	
1: 	int thread_id;
1: 	
1: 	int ind = 0;
1: 	
1: 	public static void main(String[] args) throws SQLException, IOException,
1: 	InterruptedException, Exception, Throwable {
1: 		System.getProperties().put("derby.locks.deadlockTimeout", "60");
1: 		System.getProperties().put("derby.locks.waitTimeout", "200");
1: 		System.out.println("Test Sttest starting");
1: 		System.getProperties().put("derby.infolog.append", "true");
1: 		System.getProperties().put("derby.stream.error.logSeverityLevel", "0");
0: 		//get any properties user may have set in Sttest.properties file
0: 		//these will override any of those set above
1: 		userProperties();
0: 		Class.forName(driver).newInstance();
1: 		if (Setup.doit(dbURL) == false)
1: 			System.exit(1);
1: 		status = new StStatus();
1: 		sttTop();
1: 	}
1: 	
1: 	static void userProperties() throws Throwable {
1: 		FileInputStream fileIn = null;
1: 		try {
1: 			fileIn = new FileInputStream("Sttest.properties");
1: 		} catch (Exception e) {
1: 			System.out
1: 			.println("user control file 'Sttest.properties' not found; using defaults");
1: 		}
1: 		if (fileIn != null) {
1: 			Properties props = new Properties();
1: 			props.load(fileIn);
1: 			fileIn.close();
1: 			String prop = null;
1: 			prop = props.getProperty("connections");
1: 			if (prop != null)
1: 				connections_to_make = Integer.parseInt(prop);
1: 			prop = props.getProperty("dbURL");
1: 			if (prop != null)
1: 				dbURL = prop;
1: 			prop = props.getProperty("driver");
1: 			if (prop != null)
1: 				driver = prop;
0: 			//allows us to get any other properties into the system
1: 			Properties sysprops = System.getProperties();
1: 			Enumeration list = props.propertyNames();
1: 			String s = null;
1: 			while (list.hasMoreElements()) {
1: 				s = (String) list.nextElement();
1: 				sysprops.put(s, props.getProperty(s));
1: 			}
1: 		}
1: 		System.out.println("driver = " + driver);
1: 		System.out.println("dbURL = " + dbURL);
1: 		System.out.println("connections = " + connections_to_make);
1: 	}
1: 	
1: 	public static void sttTop() throws SQLException, IOException,
1: 	InterruptedException, Exception, Throwable {
1: 		rand = new Random();
0: 		Datatypes.rand = rand;
0: 		//harder to actually delete rows when there are
0: 		//more connections, so repeat operation more often
1: 		delete_freq = 1 + connections_to_make % 5;
1: 		initial_data();
1: 		Date d = new Date();
0: 		System.out.println("updates starting, loop " + loops + " " + d);
1: 		status.firstMessage(connections_to_make, d);
1: 		// check memory in separate thread-- allows us to monitor
1: 		// usage during database calls
1: 		// 200,000 msec = 3min, 20 sec delay between checks
1: 		MemCheck mc = new MemCheck(200000);
1: 		mc.start();
1: 		Sttest testsessions[] = new Sttest[connections_to_make];
1: 		for (int i = 0; i < connections_to_make; i++) {
1: 			testsessions[i] = new Sttest(i);
1: 			testsessions[i].start();
1: 			sleep(3000);
1: 		}
1: 		for (int i = 0; i < connections_to_make; i++) {
1: 			testsessions[i].join();
1: 		}
1: 		try {
1: 			mc.stopNow = true;
1: 			mc.join();
1: 		} catch (Throwable t) {
1: 			throw (t);
1: 		}
1: 	}
1: 	
1: 	Sttest(int num) throws SQLException {
1: 		this.thread_id = num;
1: 	}
1: 	
1: 	static synchronized void reset_loops(int myloopcount) {
1: 		if (myloopcount == loops)
1: 			loops--;
1: 		// otherwise some other thread got there first and reset it
1: 	}
1: 	
1: 	// available to force synchronization of get_countlock(), ...
1: 	static synchronized void locksync() {
1: 		return;
1: 	}
1: 	
1: 	static synchronized boolean get_countlock() {
1: 		locksync();
1: 		return (countlock);
1: 	}
1: 	
1: 	static synchronized boolean set_countlock(boolean state) {
1: 		locksync();
1: 		if (state == true && countlock == true)
1: 			return (false);
1: 		countlock = state;
1: 		return (true);
1: 	}
1: 	
1: 	static synchronized void changerowcount(int in) {
1: 		rowcount += in;
1: 	}
1: 	
1: 	static synchronized void changerowcount2zero() {
1: 		rowcount = 0;
1: 	}
1: 	
1: 	static void initial_data() throws Exception, Throwable {
0: 		System.out.println("start initial data");
1: 		Connection conn = null;
1: 		int rows = 0;
1: 		try {
1: 			conn = mystartJBMS();
1: 		} catch (Throwable t) {
1: 			throw (t);
1: 		}
1: 		// our goal is to get up to minimum table size
1: 		int x = Datatypes.get_table_count(conn);
1: 		if (x != -1) {
1: 			rows = x;
1: 		}
1: 		if (conn != null) {
1: 			conn.commit();
1: 			conn.close();
1: 		}
0: 		System.out.println("initial rowcount = " + rows);
1: 		rowcount = rows;
1: 		if (rows >= targetmin) {
1: 			mode = GROW;
1: 			System.out.println("initial data not needed");
1: 			return;
1: 		}
1: 		inserts_to_try = targetmin - rows;
0: 		System.out.println("inserts_to_try: " + inserts_to_try);
1: 		Sttest testthreads[] = new Sttest[INITIAL_CONNECTIONS];
1: 		for (int i = 0; i < INITIAL_CONNECTIONS; i++) {
1: 			testthreads[i] = new Sttest(i);
1: 			testthreads[i].start();
1: 		}
1: 		for (int i = 0; i < INITIAL_CONNECTIONS; i++) {
1: 			testthreads[i].join();
1: 		}
1: 		mode = GROW;
1: 		System.out.println("complete initial data");
1: 		return;
1: 	}
1: 	
1: 	public void run() {
1: 		Connection conn = null;
1: 		Date d = null;
1: 		try {
1: 			conn = mystartJBMS();
1: 		} catch (Throwable t) {
1: 			return;
1: 		}
0: 		Runtime rt = null;
0: 		int tick = 0;
1: 		int ind2 = 0;
1: 		int myloops = loops;
1: 		while (not_finished) {
1: 			if (loops <= 0)
1: 				break;// done
1: 			// thread-private copy to be checked against global copy
1: 			// before attempting to update
1: 			myloops = loops;
1: 			if (fatal == true)
1: 				break;
1: 			if (mode == INIT && inserts_to_try <= 0) {
1: 				break;
1: 			}
1: 			// test rowcount
1: 			if (mode == GROW && rowcount > targetmax) {
1: 				System.out.println("hit targetmax with " + rowcount + " " + d);
1: 				d = new Date();
1: 				mode = SHRINK;
1: 				reset_loops(myloops);
1: 				insertsize = 1;
1: 				deletesize = 12;
1: 				if (set_countlock(true) == true) {
0: 					System.out.println("t" + thread_id + " counting");
1: 					try {
1: 						checkrowcount(conn);
1: 						MemCheck.showmem();
1: 						status.updateStatus();
1: 					} catch (Exception e) {
1: 						System.out.println("unexpected exception in rowcount");
1: 						set_countlock(false);
1: 						System.exit(1);
1: 					}
1: 					MemCheck.showmem();
1: 				}
1: 				set_countlock(false);
1: 				yield();
1: 			} else if (mode == GROW && rowcount >= targetmax) {
1: 				d = new Date();
1: 				System.out.println("hit targetmax with " + rowcount + " " + d);
1: 				mode = SHRINK;
1: 				insertsize = 1;
1: 				deletesize = 12;
1: 			} else if (mode == SHRINK && rowcount <= targetmin) {
1: 				d = new Date();
1: 				System.out.println("hit targetmin with " + rowcount + " " + d);
1: 				mode = GROW;
1: 				reset_loops(myloops);
1: 				insertsize = 8;
1: 				deletesize = 1;
1: 				if (set_countlock(true) == true) {
0: 					System.out.println("t" + thread_id + " counting");
1: 					try {
1: 						checkrowcount(conn);
1: 						MemCheck.showmem();
1: 						status.updateStatus();
1: 					} catch (Exception e) {
1: 						System.out.println("unexpected exception in rowcount");
1: 						set_countlock(false);
1: 						System.exit(1);
1: 					}
1: 					MemCheck.showmem();
1: 				}
1: 				set_countlock(false);
1: 				yield();
1: 			}
1: 			// don't interfere with count query
1: 			while (get_countlock() == true) {
1: 				try {
1: 					sleep(1000);
1: 				} catch (java.lang.InterruptedException ex) {
1: 					System.out.println("unexpected sleep interruption");
1: 					break;
1: 				}
1: 			}
1: 			try {
0: 				System.out.println("Thread " + thread_id);
1: 				if (mode == INIT)
1: 					ind = 0;
1: 				else
1: 					ind = Math.abs(rand.nextInt() % 3);
0: 				System.out.println("ind=" + ind);
1: 				switch (ind) {
1: 				case 0:
1: 					ind2 = Math.abs(rand.nextInt() % insertsize);
0: 					System.out.println("t" + thread_id + " insert "
0: 							+ String.valueOf(ind2 + 1));
1: 					for (int i = 0; i <= ind2; i++) {
1: 						Datatypes.add_one_row(conn, thread_id);
1: 						conn.commit();
1: 						if (mode == INIT) {
1: 							inserts_to_try--;
1: 						}
1: 						yield();
1: 						changerowcount(1);
1: 					}
1: 					break;
1: 				case 1:
1: 					ind2 = Math.abs(rand.nextInt() % updatesize);
0: 					System.out.println("t" + thread_id + " update "
0: 							+ String.valueOf(ind2 + 1));
1: 					for (int i = 0; i <= ind2; i++) {
1: 						Datatypes.update_one_row(conn, thread_id);
1: 						conn.commit();
1: 						yield();
1: 					}
1: 					break;
1: 				case 2:
1: 					ind2 = Math.abs(rand.nextInt() % deletesize);
0: 					System.out.println("t" + thread_id + " delete "
0: 							+ String.valueOf(ind2 + 1));
1: 					int del_rows = 0;
1: 					del_rows = Datatypes.delete_some(conn, thread_id, ind2 + 1);
0: 					System.out.println("del_rows after calling delete_some:"
0: 							+ del_rows);
1: 					yield();
1: 					changerowcount(-1 * del_rows);
0: 					//commits are done inside delete_some()
1: 					break;
0: 				} //end switch
1: 				
1: 			} catch (SQLException se) {
1: 				if (se.getSQLState() == null)
1: 					se.printStackTrace();
1: 				if (se.getSQLState().equals("40001")) {
1: 					System.out.println("t" + thread_id + " deadlock op = "
1: 							+ ind);
1: 					continue;
1: 				}
1: 				if (se.getSQLState().equals("40XL1")) {
1: 					System.out
1: 					.println("t" + thread_id + " timeout op = " + ind);
1: 					continue;
1: 				}
1: 				if (se.getSQLState().equals("23500")) {
1: 					System.out.println("t" + thread_id
1: 							+ " duplicate key violation\n");
1: 					continue;
1: 				}
1: 				if (se.getSQLState().equals("23505")) {
1: 					System.out.println("t" + thread_id
1: 							+ " duplicate key violation\n");
1: 					continue;
1: 				}
1: 				System.out.println("t" + thread_id
1: 						+ " FAIL -- unexpected exception:");
1: 				JDBCDisplayUtil.ShowException(System.out, se);
1: 				fatal = true;
1: 				break;
1: 			} catch (Throwable e) {
1: 				e.printStackTrace();
1: 				if (e.getMessage().equals("java.lang.ThreadDeath")) {
1: 					System.out.println("caught threaddeath and continuing\n");
1: 				} else {
1: 					fatal = true;
1: 					e.printStackTrace();
1: 				}
1: 			}
0: 		}//end while
1: 		try {
1: 			conn.close();
1: 		} catch (Throwable e) {
1: 			e.printStackTrace();
1: 		}
1: 		System.out.println("Thread finished: " + thread_id);
1: 	}
1: 	
1: 	static synchronized void checkrowcount(Connection conn)
1: 	throws java.lang.Exception {
1: 		int x = Datatypes.get_table_count(conn);
1: 		if (x == -1) { // count timed itself out
1: 			System.out.println("table count timed out");
1: 		} else {
1: 			System.out.println("rowcount by select: " + x
1: 					+ " client rowcount = " + rowcount);
1: 			changerowcount(x - rowcount);
1: 		}
1: 		conn.commit();
1: 	}
1: 	
1: 	static public Connection mystartJBMS() throws Throwable {
1: 		Connection conn = null;
1: 		if (startByIJ == true) {
1: 			conn = ij.startJBMS();
1: 		} else
1: 			try {
1: 				conn = DriverManager.getConnection(dbURL + ";create=false");
1: 				conn.setAutoCommit(false);
1: 				conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0: 				System.out.println("got the connection in question");
1: 			} catch (SQLException se) {
1: 				System.out.println("connect failed  for " + dbURL);
1: 				JDBCDisplayUtil.ShowException(System.out, se);
1: 			}
1: 			return (conn);
1: 	}
1: 	
1: 	static synchronized void compress(Connection conn)
1: 	throws java.lang.Exception {
0: 		Statement s = null;
0: 		int tick = 1;
0: 		boolean locked = false;
0: 		while (locked == false) {
1: 			try {
0: 				s = conn.createStatement();
0: 				s.execute("lock table Datatypes in exclusive mode");
0: 				s.close();
0: 				locked = true;
1: 			} catch (SQLException se) {
0: 				// not now lockable
0: 				if (se.getSQLState().equals("X0X02")) {
0: 					Thread.sleep(20000);
0: 					if (tick++ < 10) {
1: 						System.out
0: 						.println("compress: cannot lock table, retrying "
0: 								+ tick + "\n");
1: 						continue;
1: 					} else {
0: 						System.out.println("compress timed out\n");
1: 						return;
1: 					}
1: 				} else
1: 					JDBCDisplayUtil.ShowException(System.out, se);
1: 			}
1: 		}
1: 		System.out.println("compressing table");
1: 		try {
0: 			s = conn.createStatement();
0: 			s.execute("alter table Datatypes compress");
1: 			conn.commit();
0: 			System.out.println("table compressed");
1: 		} catch (SQLException se) {
1: 			System.out.println("compress table: FAIL -- unexpected exception:");
1: 			JDBCDisplayUtil.ShowException(System.out, se);
1: 		}
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:ef9dc99
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0:  *
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 	static int targetmax = 100000; // build up to 1GB database
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 	static final int INITIAL_CONNECTIONS = 2; // initial connections should be
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// get any properties user may have set in Sttest.properties file
1: 		// these will override any of those set above
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: 			// allows us to get any other properties into the system
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: 		Datatypes.Rn = rand;
1: 		// harder to actually delete rows when there are
1: 		// more connections, so repeat operation more often
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					int addrows = 0;
1: 						addrows++;
/////////////////////////////////////////////////////////////////////////
1: 					System.out.println(addrows + "  Rows inserted");
1: 					int updaterow = 0;
1: 						updaterow++;
1: 					System.out.println(updaterow + "  rows updated");
1: 					// commits are done inside delete_some()
1: 					System.out.println(del_rows + " rows deleted");
1: 				} // end switch
0: 
/////////////////////////////////////////////////////////////////////////
1: 		}// end while
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:a5430dd
/////////////////////////////////////////////////////////////////////////
============================================================================