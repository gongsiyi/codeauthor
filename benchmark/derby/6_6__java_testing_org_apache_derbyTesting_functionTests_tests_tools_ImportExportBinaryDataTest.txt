1:ea980d3: /*
17:ea980d3: 
1:e23ae38:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.ImportExportBinaryDataTest
1:ea980d3: 
1:ea980d3:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ea980d3:    contributor license agreements.  See the NOTICE file distributed with
1:ea980d3:    this work for additional information regarding copyright ownership.
1:ea980d3:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ea980d3:    (the "License"); you may not use this file except in compliance with
1:ea980d3:    the License.  You may obtain a copy of the License at
1:ea980d3: 
1:ea980d3:       http://www.apache.org/licenses/LICENSE-2.0
1:ea980d3: 
1:ea980d3:    Unless required by applicable law or agreed to in writing, software
1:ea980d3:    distributed under the License is distributed on an "AS IS" BASIS,
1:ea980d3:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ea980d3:    See the License for the specific language governing permissions and
1:ea980d3:    limitations under the License.
1:ea980d3: 
6:ea980d3:  */
1:ea980d3: package org.apache.derbyTesting.functionTests.tests.tools;
1:ea980d3: 
1:1ae02c9: import java.io.IOException;
1:012a72b: import java.sql.Connection;
1:ea980d3: import java.sql.ResultSet;
1:ea980d3: import java.sql.SQLException;
1:ea980d3: import java.sql.Statement;
1:ea980d3: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:ea980d3: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:ea980d3: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:ea980d3: 
5:ea980d3: /**
1:ea980d3:  * This class tests import/export of  a table with simple binary data types 
1:ea980d3:  * CHAR FOR BIT DATA, VARCHAR FOR BIT DATA,  LONG VARCHAR FOR BIT DATA.
1:ea980d3:  */
1:ea980d3: 
1:ffdaf1e: public class ImportExportBinaryDataTest extends ImportExportBaseTest {
1:ea980d3: 
1:ea980d3:     String fileName; // file used to perform import/export.
1:ea980d3: 
1:ea980d3:     public ImportExportBinaryDataTest(String name) {
1:ea980d3:         super(name);
1:ea980d3:         // set the file that is used by the import/export. 
1:ea980d3:         fileName = 
1:ea980d3:             (SupportFilesSetup.getReadWrite("bin_tab.del")).getPath();
6:ea980d3:     }
1:ea980d3: 
1:ea980d3:     /**
1:ea980d3:      * Runs the tests in the default embedded configuration and then
1:ea980d3:      * the client server configuration.
1:ea980d3:      */
1:ea980d3:     public static Test suite()
5:ea980d3:     {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(ImportExportBinaryDataTest.class);
1:1ae02c9: 
1:ea980d3:         suite.addTest(TestConfiguration.clientServerSuite(
1:ea980d3:                       ImportExportBinaryDataTest.class));
1:ea980d3:         Test test = suite;
1:ea980d3:         test = new SupportFilesSetup(test);
1:ea980d3:         return new CleanDatabaseTestSetup(test) {
1:ea980d3:                 protected void decorateSQL(Statement s) throws SQLException {
1:ea980d3:                     // table used to test  export.
1:ea980d3:                     s.execute("CREATE TABLE BIN_TAB (id int," +
1:ea980d3:                               "C_BD CHAR(4) FOR BIT DATA," + 
1:ea980d3:                               "C_VBD VARCHAR(10) FOR BIT DATA, " +
1:ea980d3:                               "C_LVBD LONG VARCHAR FOR BIT DATA)");
1:ea980d3:                     // load some data into the above table. 
1:ea980d3:                     loadData(s);
1:ea980d3:                     // table used to test import. 
1:ea980d3:                     s.execute("CREATE TABLE BIN_TAB_IMP(id int," +
1:ea980d3:                               "C_BD CHAR(4) FOR BIT DATA," + 
1:ea980d3:                               "C_VBD VARCHAR(10) FOR BIT DATA, " +
1:ea980d3:                               "C_LVBD LONG VARCHAR FOR BIT DATA)");
1:7c20bd0:                     // Create a table that holds some invalid hex strings. 
1:7c20bd0:                     s.execute("CREATE TABLE hex_tab(id int," +
1:7c20bd0:                               "C1 varchar(20)," + 
1:7c20bd0:                               "C2 varchar(20)," +
1:7c20bd0:                               "C3 varchar(20))");
1:927ad05: 		    // Create a table to test
1:927ad05: 		    // DERBY-2925: Prevent export from overwriting existing files
1:927ad05: 		    s.execute("create table derby_2925_tab(a varchar( 50 )," +
1:927ad05: 			      "b varchar( 50 ))");
1:927ad05: 
1:ea980d3:                 }
1:ea980d3:             };
1:ea980d3:     }
1:ea980d3: 
1:ea980d3:     
1:ea980d3:     /**
1:ea980d3:      * Simple set up, just empty the import table.
1:ea980d3:      * @throws SQLException 
1:ea980d3:      */
1:ea980d3:     protected void setUp() throws SQLException
1:ea980d3:     {
1:ea980d3:         Statement s  = createStatement();
1:ea980d3:         // delete the rows from the import table.
1:ea980d3:         s.executeUpdate("DELETE FROM BIN_TAB_IMP");
1:ea980d3:         s.close();
1:ea980d3:     }
1:927ad05:     /**
1:927ad05:      * delete export/import files. 
1:927ad05:      * @throws Exception
1:927ad05:      */
1:927ad05:     protected void tearDown() throws Exception {
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:927ad05:         super.tearDown();
1:927ad05: 
1:927ad05:     }
1:ea980d3: 
1:ea980d3:     /**
1:ea980d3:      * Test import/export of a table, using 
1:ea980d3:      * SYSCS_EXPORT_TABLE and SYSCS_IMPORT_TABLE procedures.
1:ea980d3:      */
1:ea980d3:     public void testImportTableExportTable()  
1:ea980d3:         throws SQLException, IOException
1:ea980d3:     {
1:ea980d3:         doExportTable("APP", "BIN_TAB", fileName, null, null , null);
1:ea980d3: 	    doImportTable("APP", "BIN_TAB_IMP", fileName, null, null, null, 0);
1:ea980d3:         verifyData(" * ");
1:ea980d3:     }
1:012a72b:     
1:012a72b:     /**
1:012a72b:      * Bulk insert into a table should recreate the indexes correctly rather
1:012a72b:      * than ignoring the unique nullable property of the index.
1:012a72b:      * In the following test case, we have an empty table in which we are
1:012a72b:      * 	trying to do an import from a file with one row worth's data.
1:012a72b:      * 	This combination used to cause bulk insert functionality to 
1:012a72b:      * 	recreate index incorrectly for unique nullable index. This allowed
1:012a72b:      * 	duplicate rows for unique nullable index. Fix for DERBY-4677 resolves
1:012a72b:      * 	the issue.
1:012a72b:      * @throws SQLException
1:012a72b:      */
1:012a72b:     public void testDerby4677BulkInsertIntoEmptyTable() throws SQLException {
1:012a72b:         Connection con = getConnection();
1:012a72b:         Statement stmt = con.createStatement();
1:012a72b:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:012a72b:         		"name2 int unique not null, name3 int primary key)");
1:012a72b:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:012a72b:         String dataFileName =
1:012a72b:             (SupportFilesSetup.getReadWrite("data_file.dat")).getPath();
1:012a72b:         doExportTable("APP", "TABLE1", dataFileName, null, null, "UTF-16");
1:012a72b:         stmt.executeUpdate("DELETE FROM TABLE1");
1:012a72b:         commit();
1:012a72b:         doImportTable("APP", "TABLE1", dataFileName, null, null, "UTF-16",0);
1:012a72b:         //following should run into problem because of constraint on name1
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:012a72b:         //following should run into problem because of constraint on name2
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:012a72b:         //following should run into problem because of constraint on name3
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:012a72b:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:012a72b:     	SupportFilesSetup.deleteFile(dataFileName);
1:012a72b:     }
1:012a72b:     
1:012a72b:     /**
1:012a72b:      * Bulk insert into a table should recreate the indexes correctly rather
1:012a72b:      * than ignoring the unique nullable property of the index.
1:012a72b:      * In the following test case, we have an empty table in which we are
1:012a72b:      * 	trying to do an import from an empty file with the REPLACE option.
1:012a72b:      * 	This combination used to cause bulk insert functionality to 
1:012a72b:      * 	recreate index incorrectly for unique nullable index. This allowed
1:012a72b:      * 	duplicate rows for unique nullable index. Fix for DERBY-4677 resolves
1:012a72b:      * 	the issue.
1:012a72b:      * @throws SQLException
1:012a72b:      */
1:012a72b:     public void testDerby4677BulkInsertWithReplace() throws SQLException {
1:012a72b:         Connection con = getConnection();
1:012a72b:         Statement stmt = con.createStatement();
1:012a72b:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:012a72b:         		"name2 int unique not null, name3 int primary key)");
1:012a72b:         String emptyFileName =
1:012a72b:             (SupportFilesSetup.getReadWrite("empty_file.dat")).getPath();
1:012a72b:         //there is no data in TABLE1 so empty_file.dat will be empty 
1:012a72b:         //after export. Using following to just create an empty file
1:012a72b:         doExportTable("APP", "TABLE1", emptyFileName, null, null, "UTF-16");
1:012a72b:         commit();
1:012a72b:         doImportTable("APP", "TABLE1", emptyFileName, null, null, "UTF-16",1);
1:012a72b:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:012a72b:         //following should run into problem because of constraint on name1
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:012a72b:         //following should run into problem because of constraint on name2
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:012a72b:         //following should run into problem because of constraint on name3
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:012a72b:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:012a72b:     	SupportFilesSetup.deleteFile(emptyFileName);
1:012a72b:     }
1:ea980d3: 
1:ea980d3:     
1:7c20bd0:     /*
1:ea980d3:      * Test import/export of all the columns using 
1:ea980d3:      * SYSCS_EXPORT_QUERY and SYSCS_IMPORT_DATA procedures.  
1:ea980d3:      */
1:ea980d3:     public void testImportDataExportQuery() 
1:ea980d3:         throws SQLException, IOException
1:ea980d3:     {
1:ea980d3:         doExportQuery("select * from BIN_TAB", fileName,
1:ea980d3:                       null, null , null);
1:ea980d3: 	    doImportData(null, "BIN_TAB_IMP", null, null, fileName, 
1:ea980d3:                      null, null, null, 0);
1:ea980d3:         verifyData(" * ");
1:ea980d3: 
1:ea980d3:         // perform import with column names specified in random order.
1:ea980d3:         doImportData(null, "BIN_TAB_IMP", "C_LVBD, C_VBD, C_BD, ID", 
1:ea980d3:                      "4, 3, 2, 1",  fileName, null, null, null, 1);
1:ea980d3:         verifyData("C_LVBD, C_VBD, C_BD, ID");
1:927ad05: 	
1:927ad05: 	//DERBY-2925: need to delete existing files first.
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:ea980d3: 
1:ea980d3:         // test with  non-default delimiters. 
1:ea980d3:         doExportQuery("select * from BIN_TAB", fileName,
1:ea980d3:                       ";", "%" , null);
1:ea980d3: 	    doImportData(null, "BIN_TAB_IMP", null, null, fileName, 
1:ea980d3:                      ";", "%", null, 1);
1:ea980d3: 
1:ea980d3:     }
1:ea980d3: 
1:ea980d3: 
1:ea980d3:     /*
1:ea980d3:      * Test import of only some columns of the table 
1:ea980d3:      * using  SYSCS_EXPOR_QUERY and IMPORT_DATA procedures.  
1:ea980d3:      */
1:ea980d3:     public void testImportDataExportQueryWithFewColumns() 
1:ea980d3:         throws SQLException, IOException
1:ea980d3:     {
1:ea980d3:         doExportQuery("select id, c_bd, c_vbd, c_lvbd from BIN_TAB",  
1:ea980d3:                       fileName,  null, null, null);
1:ea980d3:         doImportData(null, "BIN_TAB_IMP", "ID,C_LVBD", "1 , 4",
1:ea980d3:                      fileName, null, null, null, 0);
1:ea980d3:         verifyData("ID,C_LVBD");
1:ea980d3:         doImportData(null, "BIN_TAB_IMP", "ID, C_LVBD, C_BD", "1, 4, 2",
1:ea980d3:                      fileName, null, null, null, 1);
1:ea980d3:         verifyData("ID, C_LVBD, C_BD");
1:ea980d3:         doImportData(null, "BIN_TAB_IMP", "ID, C_VBD, C_BD", "1, 3, 2",
1:ea980d3:                      fileName, null, null, null, 1);
1:ea980d3:         verifyData("ID, C_VBD, C_BD");
1:927ad05: 	
1:927ad05: 	//DERBY-2925: need to delete the file first
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:ea980d3:         // test with  non-default delimiters. 
1:ea980d3:         doExportQuery("select id, c_bd, c_vbd, c_lvbd from BIN_TAB",  
1:ea980d3:                       fileName,  "$", "!" , null);
1:ea980d3:         doImportData(null, "BIN_TAB_IMP", "ID,C_LVBD", "1 , 4",
1:ea980d3:                      fileName, "$", "!", null, 0);
1:ea980d3:     }
1:ea980d3: 
1:ea980d3: 
1:ea980d3:     /* 
1:ea980d3:      *  Tests import/export procedures with invalid
1:ea980d3:      *  hex decimal characters (0-9, a-f, A-F)  as delimiters. 
1:ea980d3:      */
1:ea980d3:     public void testImportExportInvalideDelimiters() 
1:ea980d3:          throws SQLException, IOException   
1:ea980d3:     {
1:ea980d3:         try {
1:ea980d3:             doExportTable("APP", "BIN_TAB", fileName, null, "9" , null);
1:94d395e:             fail();
1:ea980d3:         } catch (SQLException e) {
1:ea980d3:             assertSQLState("XIE0J", e);
1:ea980d3:         }
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:ea980d3:         try {
1:ea980d3:             doExportQuery("select * from BIN_TAB", fileName,
1:ea980d3:                           "|", "f", null);
1:94d395e:             fail();
1:ea980d3:         } catch (SQLException e) {
1:ea980d3:             assertSQLState("XIE0J", e);
1:ea980d3:         }
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:ea980d3:         try {
1:ea980d3:             doExportTable("APP", "BIN_TAB", fileName, "B", null , null);
1:94d395e:             fail();
1:ea980d3:         } catch (SQLException e) {
1:ea980d3:             assertSQLState("XIE0J", e);
1:ea980d3:         }
1:927ad05: 	SupportFilesSetup.deleteFile(fileName);
1:ea980d3:         doExportTable("APP", "BIN_TAB", fileName, null, null , null);
1:ea980d3: 
1:ea980d3:         try {
1:ea980d3:             doImportTable("APP", "BIN_TAB_IMP", fileName, "2", null, null, 0);
1:94d395e:             fail();
1:ea980d3:         } catch (SQLException e) {
1:de3b108:              assertSQLState("XIE0J", e);
1:ea980d3:         }
1:ea980d3: 
1:ea980d3:         try {
1:ea980d3:             doImportData(null, "BIN_TAB_IMP", null, 
1:ea980d3:                          null,  fileName, null, "c", null, 1);
1:94d395e:             fail();
1:ea980d3:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0J", e);
1:ea980d3:         }
1:ea980d3:     }
1:ea980d3: 
1:ea980d3: 
1:ea980d3:     /* 
1:7c20bd0:      * Tests import procedures with invalid hex strings in 
1:7c20bd0:      * the import file. 
1:7c20bd0:      */
1:7c20bd0:     public void testImportWitgInvalidHexStrings() 
1:7c20bd0:         throws SQLException   
1:7c20bd0:     {
1:7c20bd0:         Statement s = createStatement();
1:7c20bd0:         // Insert row with correctly formed hex strings.  
1:7c20bd0:         s.executeUpdate("insert into hex_tab " + 
1:7c20bd0:                         "values(1, 'A121', '3122A1F20B', 'B1C201DA')");
1:7c20bd0: 
1:7c20bd0:         // Insert row with an invalid hex string, because 
1:7c20bd0:         // it's length is not a multiple of 2 (B1C201A) , 
1:7c20bd0:         s.executeUpdate("insert into hex_tab " + 
1:7c20bd0:                         "values(2, 'A121', '3122A1F20B', 'B1C201A')");
1:7c20bd0: 
1:7c20bd0:         // Insert row with an invalid hex string that contains 
1:7c20bd0:         // a non-hex character (3122A1F20Z). 
1:7c20bd0:         s.executeUpdate("insert into hex_tab " + 
1:7c20bd0:                         "values(3, '', '3122A1F20Z', 'B1C201DA')");
1:7c20bd0: 
1:7c20bd0:         // Insert row with an invalid hex string that contains 
1:7c20bd0:         // a delimiter character (A1\"21). 
1:7c20bd0:         s.executeUpdate("insert into hex_tab " + 
1:7c20bd0:                         "values(3, 'A1\"21', '3122A1F20Z', 'B1C201DA')");
1:7c20bd0:         s.close();
1:7c20bd0: 
1:7c20bd0:         // export the invalid hex strings from the table to a file. 
1:7c20bd0:         doExportTable("APP", "HEX_TAB", fileName, null, null , null);
1:7c20bd0: 
1:7c20bd0: 
1:7c20bd0:         // attempt to import the invalid hex string data into a table 
1:7c20bd0:         // with binary columns. It should fail.
1:7c20bd0:  
1:7c20bd0:         try {
1:7c20bd0:             // import should fail because of invalied hex string length
1:7c20bd0:             doImportTable("APP", "BIN_TAB_IMP", fileName, null, null, null, 0);
1:7c20bd0:             fail("import did not fail on data with invalid hex string");
1:7c20bd0:         } catch (SQLException e) {
1:de3b108:              assertSQLState("XIE0N", e);
1:7c20bd0:         }
1:7c20bd0: 
1:7c20bd0:         try {
1:7c20bd0:             // import should fail because hex string contains invalid 
1:7c20bd0:             // hex chatacters.
1:7c20bd0:             doImportData(null, "BIN_TAB_IMP", "ID, C_VBD", "1,3",
1:7c20bd0:                          fileName, null, null, null, 1);
1:7c20bd0:             fail("import did not fail on data with invalid hex strings");
1:7c20bd0:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0N", e);
1:7c20bd0:         }
1:7c20bd0:         
1:7c20bd0:         try {
1:7c20bd0:             // import should fail because hex string contains invalid 
1:7c20bd0:             // hex chatacters.
1:7c20bd0:             doImportData(null, "BIN_TAB_IMP", "ID, C_VBD", "1,2",
1:7c20bd0:                          fileName, null, null, null, 1);
1:7c20bd0:             fail("import did not fail on data with invalid hex strings");
1:7c20bd0:         } catch (SQLException e) {
1:de3b108:             assertSQLState("XIE0N", e);
1:7c20bd0:         }
1:7c20bd0:     }
1:927ad05:     /*
1:927ad05:      * DERBY-2925: Prevent export from overwriting existing files
1:927ad05:      * Tests for preventing overwriting existing files
1:927ad05:      * when exporting tables.
1:927ad05:      */
1:927ad05:     public void testDerby2925ExportTable()
1:927ad05:         throws SQLException
1:927ad05:     {
1:927ad05: 	doExportTable("APP", "DERBY_2925_TAB", fileName, null, null , null);
1:927ad05: 	
1:927ad05: 	try {
1:927ad05: 	    doExportTable("APP", "DERBY_2925_TAB", fileName, null, null , null);
1:927ad05: 	    fail("export should have failed on existing data file.");
1:927ad05: 	}
1:927ad05: 	catch (SQLException e) {
1:927ad05: 	    assertSQLState("XIE0S", e);
1:927ad05: 	}
1:7c20bd0: 
1:e23ae38:     // should not be able to subvert the check by turning the file name into an url
1:e23ae38: 	try {
1:e23ae38: 	    doExportTable("APP", "DERBY_2925_TAB", "file:" + fileName, null, null , null);
1:e23ae38: 	    fail("export should have failed on existing data file.");
1:e23ae38: 	}
1:e23ae38: 	catch (SQLException e) {
1:e23ae38: 	    assertSQLState("XIE0S", e);
1:e23ae38: 	}
1:e23ae38: 
1:927ad05:     }
1:927ad05:     /*
1:927ad05:      * DERBY-2925: Prevent export from overwriting existing files
1:927ad05:      * Tests for preventing overwriting existing files
1:927ad05:      * when exporting tables.
1:927ad05:      */
1:927ad05:     public void testDerby2925ExportQuery()
1:927ad05:         throws SQLException
1:927ad05:     {
1:927ad05: 	doExportQuery("select * from DERBY_2925_TAB", fileName,
1:927ad05:                       null, null , null);
1:927ad05:         try {
1:927ad05: 	    doExportQuery("select * from DERBY_2925_TAB", fileName,
1:927ad05:                       	  null, null , null);
1:927ad05:             fail("exportQuery should have failed on existing data file.");
1:927ad05:         }
1:927ad05:         catch (SQLException e) {
1:927ad05:             assertSQLState("XIE0S", e);
1:927ad05:         }
1:ea980d3: 
1:927ad05:     }
1:ea980d3:     /* 
1:ea980d3:      * Verifies data in the import test table (BIN_TAB_IMP) is same 
1:ea980d3:      * as the test table from which the data was exported earlier(BIN_TAB). 
1:ea980d3:      * @param cols  imported columns , if all then " * ", otherwise 
1:ea980d3:      *              comma separated column list. 
1:ea980d3:      * @exception SQLException  if the data does match or if 
1:ea980d3:      *                          any other error during comparision.  
1:ea980d3:      */
1:ea980d3:     private void verifyData(String cols)  
1:ea980d3:         throws SQLException, IOException
1:ea980d3:     {
1:ea980d3:         Statement s1 = createStatement();
1:ea980d3:         ResultSet rsExport = s1.executeQuery("SELECT " + cols  +  
1:ea980d3:                                              " FROM BIN_TAB order by id");
1:ea980d3:         Statement s2 = createStatement();
1:ea980d3:         ResultSet rsImport = s2.executeQuery("SELECT " + cols  +  
1:ea980d3:                                              " FROM BIN_TAB_IMP order by id");
1:ea980d3:         JDBC.assertSameContents(rsExport, rsImport);
1:ea980d3:         
1:ea980d3:         s1.close();
1:ea980d3:         s2.close();
1:ea980d3:     }
1:ea980d3:     
1:ea980d3:     
1:ea980d3:     /*
1:ea980d3:      * Insert data to the into the table, whose data will be exported.
1:ea980d3:      */
1:ea980d3:     private static void loadData(Statement s) throws SQLException {
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(1, X'31', X'3241510B',  X'3743640ADE12337610')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(2, X'33', X'3341610B',  X'3843640ADE12337610')");
1:ea980d3:         // rows with empty strings. 
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(4, X'41', X'42',  X'')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(5, X'41', X'', X'42')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(6, X'', X'42',  X'3233445578990122558820')");
1:ea980d3:         
1:ea980d3:         // rows with a null
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(7, null, X'3341610B',  X'3843640ADE12337610')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(8,  X'3341610B', null,  X'3843640ADE12337610')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(9,  X'3341610B',  X'3843640ADE' , null)");
1:ea980d3: 
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(10, X'', null,  X'3843640ADE12')");
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(11, X'66', null,  X'')");
1:ea980d3:         
1:ea980d3:         // insert data that contains some delimiter characters 
1:ea980d3:         // ( "(x22) ,(x2C) %(x25) ;(x3B) , tab(9) LF(A) )
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(12, X'2C313B09', X'224122',  X'222C23B90A')");
1:ea980d3:         // !(x21) $(24)
1:ea980d3:         s.executeUpdate("insert into bin_tab values " + 
1:ea980d3:                         "(13, X'212C3B24', X'2422412221', " + 
1:ea980d3:                         "  X'212421222C23B90A2124')");
1:927ad05: 	}
1:ea980d3: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(ImportExportBinaryDataTest.class);
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e23ae38
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.ImportExportBinaryDataTest
/////////////////////////////////////////////////////////////////////////
1:     // should not be able to subvert the check by turning the file name into an url
1: 	try {
1: 	    doExportTable("APP", "DERBY_2925_TAB", "file:" + fileName, null, null , null);
1: 	    fail("export should have failed on existing data file.");
1: 	}
1: 	catch (SQLException e) {
1: 	    assertSQLState("XIE0S", e);
1: 	}
1: 
commit:ca42bbe
/////////////////////////////////////////////////////////////////////////
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R": "XIE0N", e);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:012a72b
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Bulk insert into a table should recreate the indexes correctly rather
1:      * than ignoring the unique nullable property of the index.
1:      * In the following test case, we have an empty table in which we are
1:      * 	trying to do an import from a file with one row worth's data.
1:      * 	This combination used to cause bulk insert functionality to 
1:      * 	recreate index incorrectly for unique nullable index. This allowed
1:      * 	duplicate rows for unique nullable index. Fix for DERBY-4677 resolves
1:      * 	the issue.
1:      * @throws SQLException
1:      */
1:     public void testDerby4677BulkInsertIntoEmptyTable() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:         		"name2 int unique not null, name3 int primary key)");
1:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:         String dataFileName =
1:             (SupportFilesSetup.getReadWrite("data_file.dat")).getPath();
1:         doExportTable("APP", "TABLE1", dataFileName, null, null, "UTF-16");
1:         stmt.executeUpdate("DELETE FROM TABLE1");
1:         commit();
1:         doImportTable("APP", "TABLE1", dataFileName, null, null, "UTF-16",0);
1:         //following should run into problem because of constraint on name1
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:         //following should run into problem because of constraint on name2
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:         //following should run into problem because of constraint on name3
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:     	SupportFilesSetup.deleteFile(dataFileName);
1:     }
1:     
1:     /**
1:      * Bulk insert into a table should recreate the indexes correctly rather
1:      * than ignoring the unique nullable property of the index.
1:      * In the following test case, we have an empty table in which we are
1:      * 	trying to do an import from an empty file with the REPLACE option.
1:      * 	This combination used to cause bulk insert functionality to 
1:      * 	recreate index incorrectly for unique nullable index. This allowed
1:      * 	duplicate rows for unique nullable index. Fix for DERBY-4677 resolves
1:      * 	the issue.
1:      * @throws SQLException
1:      */
1:     public void testDerby4677BulkInsertWithReplace() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:         		"name2 int unique not null, name3 int primary key)");
1:         String emptyFileName =
1:             (SupportFilesSetup.getReadWrite("empty_file.dat")).getPath();
1:         //there is no data in TABLE1 so empty_file.dat will be empty 
1:         //after export. Using following to just create an empty file
1:         doExportTable("APP", "TABLE1", emptyFileName, null, null, "UTF-16");
1:         commit();
1:         doImportTable("APP", "TABLE1", emptyFileName, null, null, "UTF-16",1);
1:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:         //following should run into problem because of constraint on name1
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:         //following should run into problem because of constraint on name2
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:         //following should run into problem because of constraint on name3
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:     	SupportFilesSetup.deleteFile(emptyFileName);
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:94d395e
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:              assertSQLState("XIE0J", e);
1:             assertSQLState("XIE0J", e);
/////////////////////////////////////////////////////////////////////////
1:              assertSQLState("XIE0N", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XIE0N", e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XIE0N", e);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:927ad05
/////////////////////////////////////////////////////////////////////////
1: 		    // Create a table to test
1: 		    // DERBY-2925: Prevent export from overwriting existing files
1: 		    s.execute("create table derby_2925_tab(a varchar( 50 )," +
1: 			      "b varchar( 50 ))");
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * delete export/import files. 
1:      * @throws Exception
1:      */
1:     protected void tearDown() throws Exception {
1: 	SupportFilesSetup.deleteFile(fileName);
1:         super.tearDown();
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	//DERBY-2925: need to delete existing files first.
1: 	SupportFilesSetup.deleteFile(fileName);
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	//DERBY-2925: need to delete the file first
1: 	SupportFilesSetup.deleteFile(fileName);
/////////////////////////////////////////////////////////////////////////
1: 	SupportFilesSetup.deleteFile(fileName);
1: 	SupportFilesSetup.deleteFile(fileName);
1: 	SupportFilesSetup.deleteFile(fileName);
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * DERBY-2925: Prevent export from overwriting existing files
1:      * Tests for preventing overwriting existing files
1:      * when exporting tables.
1:      */
1:     public void testDerby2925ExportTable()
1:         throws SQLException
1:     {
1: 	doExportTable("APP", "DERBY_2925_TAB", fileName, null, null , null);
1: 	
1: 	try {
1: 	    doExportTable("APP", "DERBY_2925_TAB", fileName, null, null , null);
1: 	    fail("export should have failed on existing data file.");
1: 	}
1: 	catch (SQLException e) {
1: 	    assertSQLState("XIE0S", e);
1: 	}
1:     }
1:     /*
1:      * DERBY-2925: Prevent export from overwriting existing files
1:      * Tests for preventing overwriting existing files
1:      * when exporting tables.
1:      */
1:     public void testDerby2925ExportQuery()
1:         throws SQLException
1:     {
1: 	doExportQuery("select * from DERBY_2925_TAB", fileName,
1:                       null, null , null);
1:         try {
1: 	    doExportQuery("select * from DERBY_2925_TAB", fileName,
1:                       	  null, null , null);
1:             fail("exportQuery should have failed on existing data file.");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("XIE0S", e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 	}
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1: public class ImportExportBinaryDataTest extends ImportExportBaseTest {
/////////////////////////////////////////////////////////////////////////
commit:7c20bd0
/////////////////////////////////////////////////////////////////////////
1:                     // Create a table that holds some invalid hex strings. 
1:                     s.execute("CREATE TABLE hex_tab(id int," +
1:                               "C1 varchar(20)," + 
1:                               "C2 varchar(20)," +
1:                               "C3 varchar(20))");
/////////////////////////////////////////////////////////////////////////
1:     /* 
1:      * Tests import procedures with invalid hex strings in 
1:      * the import file. 
1:      */
1:     public void testImportWitgInvalidHexStrings() 
1:         throws SQLException   
1:     {
1:         Statement s = createStatement();
1:         // Insert row with correctly formed hex strings.  
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(1, 'A121', '3122A1F20B', 'B1C201DA')");
1: 
1:         // Insert row with an invalid hex string, because 
1:         // it's length is not a multiple of 2 (B1C201A) , 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(2, 'A121', '3122A1F20B', 'B1C201A')");
1: 
1:         // Insert row with an invalid hex string that contains 
1:         // a non-hex character (3122A1F20Z). 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(3, '', '3122A1F20Z', 'B1C201DA')");
1: 
1:         // Insert row with an invalid hex string that contains 
1:         // a delimiter character (A1\"21). 
1:         s.executeUpdate("insert into hex_tab " + 
1:                         "values(3, 'A1\"21', '3122A1F20Z', 'B1C201DA')");
1:         s.close();
1: 
1:         // export the invalid hex strings from the table to a file. 
1:         doExportTable("APP", "HEX_TAB", fileName, null, null , null);
1: 
1: 
1:         // attempt to import the invalid hex string data into a table 
1:         // with binary columns. It should fail.
1:  
1:         try {
1:             // import should fail because of invalied hex string length
1:             doImportTable("APP", "BIN_TAB_IMP", fileName, null, null, null, 0);
1:             fail("import did not fail on data with invalid hex string");
1:         } catch (SQLException e) {
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1: 
1:         try {
1:             // import should fail because hex string contains invalid 
1:             // hex chatacters.
1:             doImportData(null, "BIN_TAB_IMP", "ID, C_VBD", "1,3",
1:                          fileName, null, null, null, 1);
1:             fail("import did not fail on data with invalid hex strings");
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1:         
1:         try {
1:             // import should fail because hex string contains invalid 
1:             // hex chatacters.
1:             doImportData(null, "BIN_TAB_IMP", "ID, C_VBD", "1,2",
1:                          fileName, null, null, null, 1);
1:             fail("import did not fail on data with invalid hex strings");
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0N", e);
1:         }
1:     }
1: 
commit:ea980d3
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.
0:                                          tools.ImportExportBinaryDataTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.tools;
1: 
0: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.io.IOException;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * This class tests import/export of  a table with simple binary data types 
1:  * CHAR FOR BIT DATA, VARCHAR FOR BIT DATA,  LONG VARCHAR FOR BIT DATA.
1:  */
1: 
0: public class ImportExportBinaryDataTest extends BaseJDBCTestCase {
1: 
1:     String fileName; // file used to perform import/export.
1: 
1:     public ImportExportBinaryDataTest(String name) {
1:         super(name);
1:         // set the file that is used by the import/export. 
1:         fileName = 
1:             (SupportFilesSetup.getReadWrite("bin_tab.del")).getPath();
1:     }
1: 
1:     /**
1:      * Runs the tests in the default embedded configuration and then
1:      * the client server configuration.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite(ImportExportBinaryDataTest.class);
1:         suite.addTest(TestConfiguration.clientServerSuite(
1:                       ImportExportBinaryDataTest.class));
1:         Test test = suite;
1:         test = new SupportFilesSetup(test);
1:         return new CleanDatabaseTestSetup(test) {
1:                 protected void decorateSQL(Statement s) throws SQLException {
1:                     // table used to test  export.
1:                     s.execute("CREATE TABLE BIN_TAB (id int," +
1:                               "C_BD CHAR(4) FOR BIT DATA," + 
1:                               "C_VBD VARCHAR(10) FOR BIT DATA, " +
1:                               "C_LVBD LONG VARCHAR FOR BIT DATA)");
1:                     // load some data into the above table. 
1:                     loadData(s);
1:                     // table used to test import. 
1:                     s.execute("CREATE TABLE BIN_TAB_IMP(id int," +
1:                               "C_BD CHAR(4) FOR BIT DATA," + 
1:                               "C_VBD VARCHAR(10) FOR BIT DATA, " +
1:                               "C_LVBD LONG VARCHAR FOR BIT DATA)");
1:                 }
1:             };
1:     }
1: 
1:     
1:     /**
1:      * Simple set up, just empty the import table.
1:      * @throws SQLException 
1:      */
1:     protected void setUp() throws SQLException
1:     {
1:         Statement s  = createStatement();
1:         // delete the rows from the import table.
1:         s.executeUpdate("DELETE FROM BIN_TAB_IMP");
1:         s.close();
1:     }
1:     
1: 
1:     /**
1:      * Test import/export of a table, using 
1:      * SYSCS_EXPORT_TABLE and SYSCS_IMPORT_TABLE procedures.
1:      */
1:     public void testImportTableExportTable()  
1:         throws SQLException, IOException
1:     {
1:         doExportTable("APP", "BIN_TAB", fileName, null, null , null);
1: 	    doImportTable("APP", "BIN_TAB_IMP", fileName, null, null, null, 0);
1:         verifyData(" * ");
1:     }
1: 
1:     
1:     /*
1:      * Test import/export of all the columns using 
1:      * SYSCS_EXPORT_QUERY and SYSCS_IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQuery() 
1:         throws SQLException, IOException
1:     {
1:         doExportQuery("select * from BIN_TAB", fileName,
1:                       null, null , null);
1: 	    doImportData(null, "BIN_TAB_IMP", null, null, fileName, 
1:                      null, null, null, 0);
1:         verifyData(" * ");
1: 
1:         // perform import with column names specified in random order.
1:         doImportData(null, "BIN_TAB_IMP", "C_LVBD, C_VBD, C_BD, ID", 
1:                      "4, 3, 2, 1",  fileName, null, null, null, 1);
1:         verifyData("C_LVBD, C_VBD, C_BD, ID");
1: 
1:         // test with  non-default delimiters. 
1:         doExportQuery("select * from BIN_TAB", fileName,
1:                       ";", "%" , null);
1: 	    doImportData(null, "BIN_TAB_IMP", null, null, fileName, 
1:                      ";", "%", null, 1);
1: 
1:     }
1: 
1: 
1:     /*
1:      * Test import of only some columns of the table 
1:      * using  SYSCS_EXPOR_QUERY and IMPORT_DATA procedures.  
1:      */
1:     public void testImportDataExportQueryWithFewColumns() 
1:         throws SQLException, IOException
1:     {
1:         doExportQuery("select id, c_bd, c_vbd, c_lvbd from BIN_TAB",  
1:                       fileName,  null, null, null);
1:         doImportData(null, "BIN_TAB_IMP", "ID,C_LVBD", "1 , 4",
1:                      fileName, null, null, null, 0);
1:         verifyData("ID,C_LVBD");
1:         doImportData(null, "BIN_TAB_IMP", "ID, C_LVBD, C_BD", "1, 4, 2",
1:                      fileName, null, null, null, 1);
1:         verifyData("ID, C_LVBD, C_BD");
1:         doImportData(null, "BIN_TAB_IMP", "ID, C_VBD, C_BD", "1, 3, 2",
1:                      fileName, null, null, null, 1);
1:         verifyData("ID, C_VBD, C_BD");
1: 
1:         // test with  non-default delimiters. 
1:         doExportQuery("select id, c_bd, c_vbd, c_lvbd from BIN_TAB",  
1:                       fileName,  "$", "!" , null);
1:         doImportData(null, "BIN_TAB_IMP", "ID,C_LVBD", "1 , 4",
1:                      fileName, "$", "!", null, 0);
1:     }
1: 
1: 
1:     /* 
1:      *  Tests import/export procedures with invalid
1:      *  hex decimal characters (0-9, a-f, A-F)  as delimiters. 
1:      */
1:     public void testImportExportInvalideDelimiters() 
1:          throws SQLException, IOException   
1:     {
1:         try {
1:             doExportTable("APP", "BIN_TAB", fileName, null, "9" , null);
1:         } catch (SQLException e) {
1:             assertSQLState("XIE0J", e);
1:         }
1: 
1:         try {
1:             doExportQuery("select * from BIN_TAB", fileName,
1:                           "|", "f", null);
1:         } catch (SQLException e) {
1:             assertSQLState("XIE0J", e);
1:         }
1: 
1:         try {
1:             doExportTable("APP", "BIN_TAB", fileName, "B", null , null);
1:         } catch (SQLException e) {
1:             assertSQLState("XIE0J", e);
1:         }
1: 
1:         doExportTable("APP", "BIN_TAB", fileName, null, null , null);
1: 
0:         /* Currently BaseJDBCTestCase.assertSQLState() is unable
0:          * to find nested SQLSTATEs with 1.6 JVMs, so we have to
0:          * check for the top-level SQLSTATE in that case.  When
0:          * that changes the "JDBC.vmSupportsJDBC4()" call can be
0:          * removed from the following assertSQLState() calls.
0:          * (DERBY-1440)
1:          */
1: 
1:         try {
1:             doImportTable("APP", "BIN_TAB_IMP", fileName, "2", null, null, 0);
1:         } catch (SQLException e) {
0:              assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0J", e);
1:         }
1: 
1:         try {
1:             doImportData(null, "BIN_TAB_IMP", null, 
1:                          null,  fileName, null, "c", null, 1);
1:         } catch (SQLException e) {
0:             assertSQLState(JDBC.vmSupportsJDBC4() ? "38000": "XIE0J", e);
1:         }
1:     }
1: 
1: 
1: 
1:     /* 
1:      * Verifies data in the import test table (BIN_TAB_IMP) is same 
1:      * as the test table from which the data was exported earlier(BIN_TAB). 
1:      * @param cols  imported columns , if all then " * ", otherwise 
1:      *              comma separated column list. 
1:      * @exception SQLException  if the data does match or if 
1:      *                          any other error during comparision.  
1:      */
1:     private void verifyData(String cols)  
1:         throws SQLException, IOException
1:     {
1:         Statement s1 = createStatement();
1:         ResultSet rsExport = s1.executeQuery("SELECT " + cols  +  
1:                                              " FROM BIN_TAB order by id");
1:         Statement s2 = createStatement();
1:         ResultSet rsImport = s2.executeQuery("SELECT " + cols  +  
1:                                              " FROM BIN_TAB_IMP order by id");
1:         JDBC.assertSameContents(rsExport, rsImport);
1:         
1:         s1.close();
1:         s2.close();
1:     }
1:     
1: 
1:     /**
0:      * Perform export using SYSCS_UTIL.SYSCS_EXPORT_TABLE procedure.
1:      */
0:     private void doExportTable(String schemaName, 
0:                                String tableName, 
0:                                String fileName, 
0:                                String colDel , 
0:                                String charDel, 
0:                                String codeset) throws SQLException 
1:     {
0:         String expsql = 
0:             "call SYSCS_UTIL.SYSCS_EXPORT_TABLE (? , ? , ? , ?, ? , ?)";
0:         PreparedStatement ps = prepareStatement(expsql);
0:         ps.setString(1, schemaName);
0:         ps.setString(2, tableName);
0:         ps.setString(3, fileName);
0:         ps.setString(4, colDel);
0:         ps.setString(5, charDel);
0:         ps.setString(6, codeset);
0:         ps.execute();
0:         ps.close();
1:     }
1: 
1:     
1: 
1:     /**
0:      * Perform export using SYSCS_UTIL.SYSCS_EXPORT_QUERY procedure.
1:      */
0:     private void doExportQuery(String query,
0:                                String fileName,
0:                                String colDel , 
0:                                String charDel, 
0:                                String codeset) 
0:         throws SQLException 
1:     {
0:         String expsql = 
0:             "call SYSCS_UTIL.SYSCS_EXPORT_QUERY(? , ? , ? , ?, ?)";
0:         PreparedStatement ps = prepareStatement(expsql);
0:         ps.setString(1, query);
0:         ps.setString(2, fileName);
0:         ps.setString(3, colDel);
0:         ps.setString(4, charDel);
0:         ps.setString(5, codeset);
0:         ps.execute();
0:         ps.close();
1:     }
1: 
1:     /**
0:      * Perform import using SYSCS_UTIL.SYSCS_IMPORT_TABLE procedure.
1:      */
0:     private void doImportTable(String schemaName,
0:                                String tableName, 
0:                                String fileName, 
0:                                String colDel, 
0:                                String charDel , 
0:                                String codeset, 
0:                                int replace) throws SQLException 
1:     {
0:         String impsql = 
0:             "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (?, ?, ?, ?, ?, ?, ?)";
0:         PreparedStatement ps = prepareStatement(impsql);
0:         ps.setString(1 , schemaName);
0:         ps.setString(2, tableName);
0:         ps.setString(3, fileName);
0:         ps.setString(4 , colDel);
0:         ps.setString(5 , charDel);
0:         ps.setString(6 , codeset);
0:         ps.setInt(7, replace);
0:         ps.execute();
0:         ps.close();
1:     }
1: 
1: 
1:     /**
0:      *  Perform import using SYSCS_UTIL.SYSCS_IMPORT_DATA procedure.
1:      */
0:     private void doImportData(String schemaName,
0:                               String tableName, 
0:                               String insertCols,
0:                               String colIndexes, 
0:                               String fileName,
0:                               String colDel, 
0:                               String charDel , 
0:                               String codeset, 
0:                               int replace) throws SQLException 
1:     {
0:         String impsql = 
0:             "call SYSCS_UTIL.SYSCS_IMPORT_DATA(?, ?, ?, ?, ?, ?, ?, ?, ?)";
0:         PreparedStatement ps = prepareStatement(impsql);
0:         ps.setString(1, schemaName);
0:         ps.setString(2, tableName);
0:         ps.setString(3, insertCols);
0:         ps.setString(4, colIndexes);
0:         ps.setString(5, fileName);
0:         ps.setString(6 , colDel);
0:         ps.setString(7 , charDel);
0:         ps.setString(8 , codeset);
0:         ps.setInt(9, replace);
0:         ps.execute();
0:         ps.close();
1:     }
1: 
1:     
1:     /*
1:      * Insert data to the into the table, whose data will be exported.
1:      */
1:     private static void loadData(Statement s) throws SQLException {
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(1, X'31', X'3241510B',  X'3743640ADE12337610')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(2, X'33', X'3341610B',  X'3843640ADE12337610')");
1:         // rows with empty strings. 
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(4, X'41', X'42',  X'')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(5, X'41', X'', X'42')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(6, X'', X'42',  X'3233445578990122558820')");
1:         
1:         // rows with a null
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(7, null, X'3341610B',  X'3843640ADE12337610')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(8,  X'3341610B', null,  X'3843640ADE12337610')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(9,  X'3341610B',  X'3843640ADE' , null)");
1: 
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(10, X'', null,  X'3843640ADE12')");
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(11, X'66', null,  X'')");
1:         
1:         // insert data that contains some delimiter characters 
1:         // ( "(x22) ,(x2C) %(x25) ;(x3B) , tab(9) LF(A) )
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(12, X'2C313B09', X'224122',  X'222C23B90A')");
1:         // !(x21) $(24)
1:         s.executeUpdate("insert into bin_tab values " + 
1:                         "(13, X'212C3B24', X'2422412221', " + 
1:                         "  X'212421222C23B90A2124')");
1:     }
1: }
============================================================================