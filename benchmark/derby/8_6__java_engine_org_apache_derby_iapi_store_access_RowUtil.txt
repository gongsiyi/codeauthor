1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.RowUtil
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:722a889: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: 
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Vector;
1:eac0369: 
2:eac0369: /**
1:eac0369:   A set of static utility methods to work with rows.
1:eac0369:   <P>
1:eac0369:   A row or partial row is described by two or three parameters.
1:eac0369:   <OL>
1:eac0369:   <LI>DataValueDescriptor[] row - an array of objects, one per column.
1:eac0369:   <LI>FormatableBitSet validColumns - 
1:eac0369:       an indication of which objects in row map to which columns
1:eac0369:   </OL>
1:eac0369:   These objects can describe a complete row or a partial row. A partial row is 
1:eac0369:   one where a sub-set (e.g. columns 0, 4 and 7) of the columns are supplied 
1:eac0369:   for update, or requested to be fetched on a read.  Here's an example
1:eac0369:   of code to set up a partial column list to fetch the 0th (type FOO), 
1:eac0369:   4th (type BAR), and 7th (type MMM) columns from a row with 10 columns, note
1:eac0369:   that the format for a partial row changed from a "packed" representation
1:eac0369:   in the 3.0 release to a "sparse" representation in later releases:
1:eac0369: 
1:eac0369:   <blockquote><pre>
1:eac0369: 
1:eac0369:   // allocate/initialize the row 
1:eac0369:   DataValueDescriptor row = new DataValueDescriptor[10]
1:eac0369:   row[0] = new FOO();
1:eac0369:   row[4] = new BAR();
1:eac0369:   row[7] = new MMM();
1:eac0369:   
1:eac0369:   // allocate/initialize the bit set 
1:eac0369:   FormatableBitSet FormatableBitSet = new FormatableBitSet(10);
1:eac0369:   
1:eac0369:   FormatableBitSet.set(0);
1:eac0369:   FormatableBitSet.set(4);
1:eac0369:   FormatableBitSet.set(7);
1:eac0369:   </blockquote></pre>
1:eac0369: 
1:eac0369: 
1:eac0369:   <BR><B>Column mapping<B><BR>
1:eac0369:   When validColumns is null:
1:eac0369:   <UL>
1:eac0369:   <LI> The number of columns is given by row.length
1:eac0369:   <LI> Column N maps to row[N], where column numbers start at zero.
1:eac0369:   </UL>
1:eac0369:   <BR>
1:eac0369:   When validColumns is not null, then
1:eac0369:   <UL>
1:eac0369:   <LI> The number of requested columns is given by the number of bits set in 
1:eac0369:        validColumns.
1:eac0369:   <LI> Column N is not in the partial row if validColumns.isSet(N) 
1:eac0369:        returns false.
1:eac0369:   <LI> Column N is in the partial row if validColumns.isSet(N) returns true.
1:eac0369:   <LI> If column N is in the partial row then it maps to row[N].
1:dbed020: 	   If N &gt;= row.length then the column is taken as non existent for an
1:eac0369: 	   insert or update, and not fetched on a fetch.
1:eac0369:   </UL>
1:eac0369:   If row.length is greater than the number of columns indicated by validColumns
1:eac0369:   the extra entries are ignored.
1:eac0369: 
1:eac0369: **/
1:eac0369: public class RowUtil
6:eac0369: {
1:eac0369: 	private RowUtil() {}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An object that can be used on a fetch to indicate no fields
1:eac0369: 		need to be fetched.
1:eac0369: 	*/
1:eac0369: 	public static final DataValueDescriptor[] EMPTY_ROW = 
1:eac0369:         new DataValueDescriptor[0];
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
1:eac0369: 		need to be fetched.
1:eac0369: 	*/
1:eac0369: 	public static final FormatableBitSet EMPTY_ROW_BITSET  = 
1:eac0369:         new FormatableBitSet(0);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
1:eac0369: 		need to be fetched.
1:eac0369: 	*/
1:eac0369: 	public static final FetchDescriptor EMPTY_ROW_FETCH_DESCRIPTOR  = 
1:eac0369:         new FetchDescriptor(0);
1:eac0369: 
1:18176ce: 	private static final FetchDescriptor[] ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS  =
1:eac0369:         {EMPTY_ROW_FETCH_DESCRIPTOR,
1:eac0369:          new FetchDescriptor(1, 1),
1:eac0369:          new FetchDescriptor(2, 2),
1:eac0369:          new FetchDescriptor(3, 3),
1:eac0369:          new FetchDescriptor(4, 4),
1:eac0369:          new FetchDescriptor(5, 5),
1:eac0369:          new FetchDescriptor(6, 6),
1:eac0369:          new FetchDescriptor(7, 7)};
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the object for a column identifer (0 based) from a complete or 
1:eac0369:         partial row.
1:eac0369: 
1:eac0369: 		@param row the row
1:eac0369: 		@param columnList valid columns in the row
1:eac0369: 		@param columnId which column to return (0 based)
1:eac0369: 
1:eac0369: 		@return the obejct for the column, or null if the column is not represented.
1:eac0369: 	*/
1:eac0369: 	public static DataValueDescriptor getColumn(
2:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 columnList, 
1:eac0369:     int                     columnId) 
1:eac0369:     {
1:eac0369: 
2:eac0369: 		if (columnList == null)
1:eac0369: 			return columnId < row.length ? row[columnId] : null;
1:eac0369: 
1:eac0369: 
1:eac0369: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
1:eac0369: 			return null;
1:eac0369: 
1:eac0369:         return columnId < row.length ? row[columnId] : null;
1:eac0369: 
7:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static Object getColumn(
1:eac0369:     Object[]   row, 
1:eac0369:     FormatableBitSet                 columnList, 
1:eac0369:     int                     columnId) 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (columnList == null)
1:eac0369: 			return columnId < row.length ? row[columnId] : null;
1:eac0369: 
1:eac0369: 
1:eac0369: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
1:eac0369: 			return null;
1:eac0369: 
1:eac0369:         return columnId < row.length ? row[columnId] : null;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a FormatableBitSet representing all the columns represented in
1:eac0369: 		a qualifier list.
1:eac0369: 
1:eac0369: 		@return a FormatableBitSet describing the valid columns.
1:eac0369: 	*/
1:eac0369: 	public static FormatableBitSet getQualifierBitSet(Qualifier[][] qualifiers) 
1:eac0369:     {
1:eac0369: 		FormatableBitSet qualifierColumnList = new FormatableBitSet();
1:eac0369: 
1:eac0369: 		if (qualifiers != null) 
1:eac0369:         {
1:eac0369: 			for (int i = 0; i < qualifiers.length; i++)
1:eac0369: 			{
1:eac0369:                 for (int j = 0; j < qualifiers[i].length; j++)
1:eac0369:                 {
1:eac0369:                     int colId = qualifiers[i][j].getColumnId();
1:eac0369: 
1:eac0369:                     // we are about to set bit colId, need length to be colId+1
1:eac0369:                     qualifierColumnList.grow(colId+1);
1:eac0369:                     qualifierColumnList.set(colId);
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return qualifierColumnList;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the number of columns represented by a FormatableBitSet.
1:eac0369:      * <p>
1:eac0369:      * This is simply a count of the number of bits set in the FormatableBitSet.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param maxColumnNumber Because the FormatableBitSet.size() can't be used as
1:eac0369:      *                        the number of columns, allow caller to tell
1:eac0369:      *                        the maximum column number if it knows.  
1:eac0369:      *                        -1  means caller does not know.
1:dbed020:      *                        &gt;=0 number is the largest column number.
1:eac0369:      *                           
1:eac0369:      * @param columnList valid columns in the row
1:eac0369:      *
1:eac0369: 	 * @return The number of columns represented in the FormatableBitSet.
1:eac0369:      **/
1:eac0369:     public static int getNumberOfColumns(
1:eac0369:     int     maxColumnNumber,
1:eac0369:     FormatableBitSet  columnList)
1:eac0369:     {
2:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(columnList != null);
1:eac0369: 
1:eac0369:         int max_col_number = columnList.getLength();
1:eac0369: 
1:eac0369: 		if (maxColumnNumber > 0 && maxColumnNumber < max_col_number)
1:eac0369: 			max_col_number = maxColumnNumber;
1:eac0369: 
1:eac0369:         int ret_num_cols = 0;
1:eac0369: 
1:eac0369:         for (int i = 0; i < max_col_number; i++)
1:eac0369:         {
2:eac0369:             if (columnList.isSet(i))
1:eac0369:                 ret_num_cols++;
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_num_cols);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		See if a row actually contains no columns.
1:00d8393: 		Returns true if row is null or row.length is zero.
1:eac0369: 
1:00d8393: 		@return true if row is empty.
1:eac0369: 	*/
1:eac0369: 	public static boolean isRowEmpty(
1:00d8393:     DataValueDescriptor[]   row) 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (row == null)
2:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		if (row.length == 0)
1:eac0369: 			return true;
1:eac0369: 
2:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the column number of the first column out of range, or a number
1:eac0369:         less than zero if all columns are in range.
1:eac0369: 	*/
1:eac0369: 	public static int columnOutOfRange(
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 columnList, 
1:eac0369:     int                     maxColumns) 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (columnList == null) {
1:eac0369: 			if (row.length > maxColumns)
1:eac0369: 				return maxColumns;
1:eac0369: 
1:eac0369: 			return -1;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		int size = columnList.getLength();
1:eac0369: 		for (int i = maxColumns; i < size; i++) {
1:eac0369: 			if (columnList.isSet(i))
1:eac0369: 				return i;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the next valid column after or including start column.
1:eac0369: 		Returns -1 if no valid columns exist after startColumn
1:eac0369: 	*/
1:eac0369: 	public static int nextColumn(
1:eac0369:     Object[]   row, 
1:eac0369:     FormatableBitSet                 columnList, 
1:eac0369:     int                     startColumn) 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (columnList != null) {
1:eac0369: 
1:eac0369: 			int size = columnList.getLength();
1:eac0369: 
1:eac0369: 			for (; startColumn < size; startColumn++) {
1:eac0369: 				if (columnList.isSet(startColumn)) {
1:eac0369: 					return startColumn;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return -1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (row == null)
1:eac0369: 			return -1;
1:eac0369: 
1:eac0369: 		return startColumn < row.length ? startColumn : -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return a FetchDescriptor which describes a single column set.
1:eac0369:      * <p>
1:eac0369:      * This routine returns one of a set of constant FetchDescriptor's, and
1:eac0369:      * should not be altered by the caller.
1:eac0369:      **/
1:eac0369:     public static final FetchDescriptor getFetchDescriptorConstant(
1:eac0369:     int     single_column_number)
1:eac0369:     {
1:eac0369:         if (single_column_number < ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS.length)
1:eac0369:         {
1:eac0369:             return(ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS[single_column_number]);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(
1:eac0369:                 new FetchDescriptor(
1:eac0369:                     single_column_number, single_column_number));
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods dealing with cloning and row copying util functions
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:6404cde:      * Generate a template row of DataValueDescriptor's
1:eac0369:      * <p>
1:6404cde:      * Generate an array of DataValueDescriptor objects which will be used to 
1:6404cde:      * make calls to newRowFromClassInfoTemplate(), to repeatedly and
1:eac0369:      * efficiently generate new rows.  This is important for certain 
1:eac0369:      * applications like the sorter and fetchSet which generate large numbers
1:eac0369:      * of "new" empty rows.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The new row.
1:eac0369:      *
1:6404cde:      * @param column_list A bit set indicating which columns to include in row.
1:6404cde:      * @param format_ids  an array of format id's, one per column in row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:6404cde:     public static DataValueDescriptor[] newTemplate(
1:722a889:     DataValueFactory    dvf,
1:722a889:     FormatableBitSet    column_list,
1:722a889:     int[]               format_ids,
1:722a889:     int[]               collation_ids) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:6404cde:         int                   num_cols = format_ids.length;
1:6404cde:         DataValueDescriptor[] ret_row  = new DataValueDescriptor[num_cols];
1:eac0369: 
1:eac0369: 		int column_listSize = 
1:eac0369:             (column_list == null) ? 0 : column_list.getLength();
1:eac0369: 
1:eac0369:         for (int i = 0; i < num_cols; i++)
1:eac0369:         {
1:eac0369:             // does caller want this column?
1:eac0369:             if ((column_list != null)   && 
1:eac0369:                 !((column_listSize > i) && 
1:eac0369:                 (column_list.isSet(i))))
1:eac0369:             {
1:eac0369:                 // no - column should be skipped.
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // yes - create the column 
1:eac0369: 
1:eac0369:                 // get empty instance of object identified by the format id.
1:eac0369: 
1:722a889:                 ret_row[i] = dvf.getNull(format_ids[i], collation_ids[i]);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_row);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:6404cde:      * Generate an "empty" row from an array of DataValueDescriptor objects.
1:eac0369:      * <p>
1:6404cde:      * Generate an array of new'd objects by using the getNewNull()
1:6404cde:      * method on each of the DataValueDescriptor objects.  
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The new row.
1:eac0369:      *
1:6404cde:      * @param  template            An array of DataValueDescriptor objects 
1:6404cde:      *                             each of which can be used to create a new 
1:6404cde:      *                             instance of the appropriate type to build a 
1:6404cde:      *                             new empty template row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:6404cde:     public static DataValueDescriptor[] newRowFromTemplate(
1:6404cde:     DataValueDescriptor[]    template) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 
1:eac0369:         DataValueDescriptor[] columns = 
1:6404cde:             new DataValueDescriptor[template.length];
1:eac0369: 
1:eac0369:         
1:6404cde:         for (int column_index = template.length; column_index-- > 0;)
1:eac0369:         {
1:6404cde:             if (template[column_index] != null)
1:eac0369:             {
1:eac0369:                 // get empty instance of DataValueDescriptor identified by 
1:eac0369:                 // the format id.
1:6404cde:                 columns[column_index] = template[column_index].getNewNull();
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return columns;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * return string version of row.
1:eac0369:      * <p>
1:eac0369:      * For debugging only. 
1:eac0369:      *
1:eac0369: 	 * @return The string version of row.
1:eac0369:      *
2:eac0369:      * @param row The row.
1:eac0369:      *
1:eac0369:      **/
1:eac0369:     public static String toString(Object[] row)
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 
1:4a4b0a8:             String str = "";
1:eac0369: 
1:eac0369:             if (row != null)
1:eac0369:             {
1:eac0369:                 if (row.length == 0)
1:eac0369:                 {
1:eac0369:                     str = "empty row";
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     for (int i = 0; i < row.length; i++)
1:eac0369:                         str += "col[" + i + "]=" + row[i];
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 str = "row is null";
1:eac0369:             }
1:eac0369: 
1:eac0369:             return(str);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(null);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * return string version of a HashTable returned from a FetchSet.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The string version of row.
1:eac0369:      *
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 
1:eac0369:     // For debugging only. 
1:eac0369:     public static String toString(Hashtable hash_table)
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:4a4b0a8:             String str = "";
1:eac0369: 
1:eac0369:             Object  row_or_vector;
1:eac0369: 
1:eac0369:             for (Enumeration e = hash_table.elements(); e.hasMoreElements();)
1:eac0369:             {
1:eac0369:                 row_or_vector = e.nextElement();
1:eac0369: 
1:eac0369:                 if (row_or_vector instanceof Object[])
1:eac0369:                 {
1:eac0369:                     // it's a row
1:eac0369:                     str += RowUtil.toString((Object[]) row_or_vector);
1:eac0369:                     str += "\n";
1:eac0369:                 }
1:eac0369:                 else if (row_or_vector instanceof Vector)
1:eac0369:                 {
1:eac0369:                     // it's a vector
1:eac0369:                     Vector vec = (Vector) row_or_vector;
1:eac0369: 
1:eac0369:                     for (int i = 0; i < vec.size(); i++)
1:eac0369:                     {
1:eac0369:                         str += 
1:eac0369:                             "vec[" + i + "]:" + 
1:a32eb9f:                             RowUtil.toString((Object[]) vec.get(i));
1:eac0369: 
1:eac0369:                         str += "\n";
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     str += "BAD ENTRY\n";
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             return(str);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(null);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Process the qualifier list on the row, return true if it qualifies.
1:eac0369:      * <p>
1:eac0369:      * A two dimensional array is to be used to pass around a AND's and OR's in
1:eac0369:      * conjunctive normal form.  The top slot of the 2 dimensional array is 
1:eac0369:      * optimized for the more frequent where no OR's are present.  The first 
1:eac0369:      * array slot is always a list of AND's to be treated as described above 
1:eac0369:      * for single dimensional AND qualifier arrays.  The subsequent slots are 
1:eac0369:      * to be treated as AND'd arrays or OR's.  Thus the 2 dimensional array 
1:eac0369:      * qual[][] argument is to be treated as the following, note if 
1:eac0369:      * qual.length = 1 then only the first array is valid and it is and an 
1:eac0369:      * array of and clauses:
1:eac0369:      *
1:eac0369:      * (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
1:eac0369:      * and
1:eac0369:      * (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
1:eac0369:      * and
1:eac0369:      * (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
1:eac0369:      * ...
1:eac0369:      * and
1:eac0369:      * (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
1:eac0369:      *
1:eac0369:      * 
1:eac0369: 	 * @return true if the row qualifies.
1:eac0369:      *
1:eac0369:      * @param row               The row being qualified.
1:eac0369:      * @param qual_list         2 dimensional array representing conjunctive
1:eac0369:      *                          normal form of simple qualifiers.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public static final boolean qualifyRow(
1:38bd5de:     DataValueDescriptor[]        row, 
1:eac0369:     Qualifier[][]   qual_list)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         boolean     row_qualifies = true;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(row != null);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // First do the qual[0] which is an array of qualifer terms.
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             // routine should not be called if there is no qualifier
1:eac0369:             SanityManager.ASSERT(qual_list != null);
1:eac0369:             SanityManager.ASSERT(qual_list.length > 0);
1:eac0369:         }
1:eac0369: 
1:eac0369:         for (int i = 0; i < qual_list[0].length; i++)
1:eac0369:         {
1:eac0369:             // process each AND clause 
1:eac0369: 
1:eac0369:             row_qualifies = false;
1:eac0369: 
1:eac0369:             // process each OR clause.
1:eac0369: 
1:eac0369:             Qualifier q = qual_list[0][i];
1:eac0369: 
1:eac0369:             // Get the column from the possibly partial row, of the 
1:eac0369:             // q.getColumnId()'th column in the full row.
1:38bd5de:             DataValueDescriptor columnValue = row[q.getColumnId()];
1:eac0369: 
1:eac0369:             row_qualifies =
1:eac0369:                 columnValue.compare(
1:eac0369:                     q.getOperator(),
1:eac0369:                     q.getOrderable(),
1:eac0369:                     q.getOrderedNulls(),
1:eac0369:                     q.getUnknownRV());
1:eac0369: 
1:eac0369:             if (q.negateCompareResult())
1:eac0369:                 row_qualifies = !row_qualifies;
1:eac0369: 
1:eac0369:             // Once an AND fails the whole Qualification fails - do a return!
1:eac0369:             if (!row_qualifies)
1:eac0369:                 return(false);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // all the qual[0] and terms passed, now process the OR clauses
1:eac0369: 
1:eac0369:         for (int and_idx = 1; and_idx < qual_list.length; and_idx++)
1:eac0369:         {
1:eac0369:             // loop through each of the "and" clause.
1:eac0369: 
1:eac0369:             row_qualifies = false;
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // Each OR clause must be non-empty.
1:eac0369:                 SanityManager.ASSERT(qual_list[and_idx].length > 0);
1:eac0369:             }
1:eac0369: 
1:eac0369:             for (int or_idx = 0; or_idx < qual_list[and_idx].length; or_idx++)
1:eac0369:             {
1:eac0369:                 // Apply one qualifier to the row.
1:eac0369:                 Qualifier q      = qual_list[and_idx][or_idx];
1:eac0369:                 int       col_id = q.getColumnId();
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         (col_id < row.length),
1:eac0369:                         "Qualifier is referencing a column not in the row.");
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // Get the column from the possibly partial row, of the 
1:eac0369:                 // q.getColumnId()'th column in the full row.
1:38bd5de:                 DataValueDescriptor columnValue = row[q.getColumnId()];
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (columnValue == null)
2:eac0369:                         SanityManager.THROWASSERT(
1:eac0369:                             "1:row = " + RowUtil.toString(row) +
1:eac0369:                             "row.length = " + row.length +
1:eac0369:                             ";q.getColumnId() = " + q.getColumnId());
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // do the compare between the column value and value in the
1:eac0369:                 // qualifier.
1:eac0369:                 row_qualifies = 
1:eac0369:                     columnValue.compare(
1:eac0369:                             q.getOperator(),
1:eac0369:                             q.getOrderable(),
1:eac0369:                             q.getOrderedNulls(),
1:eac0369:                             q.getUnknownRV());
1:eac0369: 
1:eac0369:                 if (q.negateCompareResult())
1:eac0369:                     row_qualifies = !row_qualifies;
1:eac0369: 
1:eac0369:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
1:eac0369: 
1:eac0369:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "value = " + row_qualifies);
1:eac0369: 
1:eac0369:                 // processing "OR" clauses, so as soon as one is true, break
1:eac0369:                 // to go and process next AND clause.
1:eac0369:                 if (row_qualifies)
1:eac0369:                     break;
1:eac0369: 
1:eac0369:             }
1:eac0369: 
1:eac0369:             // The qualifier list represented a set of "AND'd" 
1:eac0369:             // qualifications so as soon as one is false processing is done.
1:eac0369:             if (!row_qualifies)
1:eac0369:                 break;
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(row_qualifies);
1:eac0369:     }
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	   If N &gt;= row.length then the column is taken as non existent for an
/////////////////////////////////////////////////////////////////////////
1:      *                        &gt;=0 number is the largest column number.
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:             String str = "";
/////////////////////////////////////////////////////////////////////////
1:             String str = "";
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1:                             RowUtil.toString((Object[]) vec.get(i));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
commit:18176ce
/////////////////////////////////////////////////////////////////////////
1: 	private static final FetchDescriptor[] ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS  =
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:38bd5de
/////////////////////////////////////////////////////////////////////////
1:     DataValueDescriptor[]        row, 
/////////////////////////////////////////////////////////////////////////
1:             DataValueDescriptor columnValue = row[q.getColumnId()];
/////////////////////////////////////////////////////////////////////////
1:                 DataValueDescriptor columnValue = row[q.getColumnId()];
commit:00d8393
/////////////////////////////////////////////////////////////////////////
1: 		Returns true if row is null or row.length is zero.
1: 		@return true if row is empty.
1:     DataValueDescriptor[]   row) 
/////////////////////////////////////////////////////////////////////////
commit:df9af89
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.RowUtil
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.loader.InstanceGetter;
1: 
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: 
0: import java.lang.reflect.InvocationTargetException;
1: 
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.Vector;
1: 
1: /**
1:   A set of static utility methods to work with rows.
1:   <P>
1:   A row or partial row is described by two or three parameters.
1:   <OL>
1:   <LI>DataValueDescriptor[] row - an array of objects, one per column.
1:   <LI>FormatableBitSet validColumns - 
1:       an indication of which objects in row map to which columns
1:   </OL>
1:   These objects can describe a complete row or a partial row. A partial row is 
1:   one where a sub-set (e.g. columns 0, 4 and 7) of the columns are supplied 
1:   for update, or requested to be fetched on a read.  Here's an example
1:   of code to set up a partial column list to fetch the 0th (type FOO), 
1:   4th (type BAR), and 7th (type MMM) columns from a row with 10 columns, note
1:   that the format for a partial row changed from a "packed" representation
1:   in the 3.0 release to a "sparse" representation in later releases:
1: 
1:   <blockquote><pre>
1: 
1:   // allocate/initialize the row 
1:   DataValueDescriptor row = new DataValueDescriptor[10]
1:   row[0] = new FOO();
1:   row[4] = new BAR();
1:   row[7] = new MMM();
1:   
1:   // allocate/initialize the bit set 
1:   FormatableBitSet FormatableBitSet = new FormatableBitSet(10);
1:   
1:   FormatableBitSet.set(0);
1:   FormatableBitSet.set(4);
1:   FormatableBitSet.set(7);
1:   </blockquote></pre>
1: 
1: 
1:   <BR><B>Column mapping<B><BR>
1:   When validColumns is null:
1:   <UL>
1:   <LI> The number of columns is given by row.length
1:   <LI> Column N maps to row[N], where column numbers start at zero.
1:   </UL>
1:   <BR>
1:   When validColumns is not null, then
1:   <UL>
1:   <LI> The number of requested columns is given by the number of bits set in 
1:        validColumns.
1:   <LI> Column N is not in the partial row if validColumns.isSet(N) 
1:        returns false.
1:   <LI> Column N is in the partial row if validColumns.isSet(N) returns true.
1:   <LI> If column N is in the partial row then it maps to row[N].
0: 	   If N >= row.length then the column is taken as non existent for an
1: 	   insert or update, and not fetched on a fetch.
1:   </UL>
1:   If row.length is greater than the number of columns indicated by validColumns
1:   the extra entries are ignored.
1: 
1: **/
1: public class RowUtil
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private RowUtil() {}
1: 
1: 	/**
1: 		An object that can be used on a fetch to indicate no fields
1: 		need to be fetched.
1: 	*/
1: 	public static final DataValueDescriptor[] EMPTY_ROW = 
1:         new DataValueDescriptor[0];
1: 
1: 	/**
1: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
1: 		need to be fetched.
1: 	*/
1: 	public static final FormatableBitSet EMPTY_ROW_BITSET  = 
1:         new FormatableBitSet(0);
1: 
1: 	/**
1: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
1: 		need to be fetched.
1: 	*/
1: 	public static final FetchDescriptor EMPTY_ROW_FETCH_DESCRIPTOR  = 
1:         new FetchDescriptor(0);
1: 
0: 	public static final FetchDescriptor[] ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS  =
1:         {EMPTY_ROW_FETCH_DESCRIPTOR,
1:          new FetchDescriptor(1, 1),
1:          new FetchDescriptor(2, 2),
1:          new FetchDescriptor(3, 3),
1:          new FetchDescriptor(4, 4),
1:          new FetchDescriptor(5, 5),
1:          new FetchDescriptor(6, 6),
1:          new FetchDescriptor(7, 7)};
1: 
1: 
1: 	/**
1: 		Get the object for a column identifer (0 based) from a complete or 
1:         partial row.
1: 
1: 		@param row the row
1: 		@param columnList valid columns in the row
1: 		@param columnId which column to return (0 based)
1: 
1: 		@return the obejct for the column, or null if the column is not represented.
1: 	*/
1: 	public static DataValueDescriptor getColumn(
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 columnList, 
1:     int                     columnId) 
1:     {
1: 
1: 		if (columnList == null)
1: 			return columnId < row.length ? row[columnId] : null;
1: 
1: 
1: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
1: 			return null;
1: 
1:         return columnId < row.length ? row[columnId] : null;
1: 
1: 	}
1: 
1: 	public static Object getColumn(
1:     Object[]   row, 
1:     FormatableBitSet                 columnList, 
1:     int                     columnId) 
1:     {
1: 
1: 		if (columnList == null)
1: 			return columnId < row.length ? row[columnId] : null;
1: 
1: 
1: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
1: 			return null;
1: 
1:         return columnId < row.length ? row[columnId] : null;
1: 
1: 	}
1: 
1: 	/**
1: 		Get a FormatableBitSet representing all the columns represented in
1: 		a qualifier list.
1: 
1: 		@return a FormatableBitSet describing the valid columns.
1: 	*/
1: 	public static FormatableBitSet getQualifierBitSet(Qualifier[][] qualifiers) 
1:     {
1: 		FormatableBitSet qualifierColumnList = new FormatableBitSet();
1: 
1: 		if (qualifiers != null) 
1:         {
1: 			for (int i = 0; i < qualifiers.length; i++)
1: 			{
1:                 for (int j = 0; j < qualifiers[i].length; j++)
1:                 {
1:                     int colId = qualifiers[i][j].getColumnId();
1: 
1:                     // we are about to set bit colId, need length to be colId+1
1:                     qualifierColumnList.grow(colId+1);
1:                     qualifierColumnList.set(colId);
1:                 }
1: 			}
1: 		}
1: 
1: 		return qualifierColumnList;
1: 	}
1: 
1:     /**
1:      * Get the number of columns represented by a FormatableBitSet.
1:      * <p>
1:      * This is simply a count of the number of bits set in the FormatableBitSet.
1:      * <p>
1:      *
1:      * @param maxColumnNumber Because the FormatableBitSet.size() can't be used as
1:      *                        the number of columns, allow caller to tell
1:      *                        the maximum column number if it knows.  
1:      *                        -1  means caller does not know.
0:      *                        >=0 number is the largest column number.
1:      *                           
1:      * @param columnList valid columns in the row
1:      *
1: 	 * @return The number of columns represented in the FormatableBitSet.
1:      **/
1:     public static int getNumberOfColumns(
1:     int     maxColumnNumber,
1:     FormatableBitSet  columnList)
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(columnList != null);
1: 
1:         int max_col_number = columnList.getLength();
1: 
1: 		if (maxColumnNumber > 0 && maxColumnNumber < max_col_number)
1: 			max_col_number = maxColumnNumber;
1: 
1:         int ret_num_cols = 0;
1: 
1:         for (int i = 0; i < max_col_number; i++)
1:         {
1:             if (columnList.isSet(i))
1:                 ret_num_cols++;
1:         }
1: 
1:         return(ret_num_cols);
1:     }
1: 
1: 	/**
1: 		See if a row actually contains no columns.
0: 		Returns true if row is null, row.length is null,
0: 		or columnList is not null but has not bits set.
1: 
0: 		@return true if no columns are selected in this row.
1: 	*/
1: 	public static boolean isRowEmpty(
1:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 columnList) 
1:     {
1: 
1: 		if (row == null)
1: 			return true;
1: 
1: 		if (row.length == 0)
1: 			return true;
1: 
1: 		if (columnList == null)
1: 			return false;
1: 
1: 		int size = columnList.getLength();
0: 		for (int i = 0; i < size; i--) {
1: 			if (columnList.isSet(i))
1: 				return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		Return the column number of the first column out of range, or a number
1:         less than zero if all columns are in range.
1: 	*/
1: 	public static int columnOutOfRange(
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 columnList, 
1:     int                     maxColumns) 
1:     {
1: 
1: 		if (columnList == null) {
1: 			if (row.length > maxColumns)
1: 				return maxColumns;
1: 
1: 			return -1;
1: 		}
1: 
1: 		int size = columnList.getLength();
1: 		for (int i = maxColumns; i < size; i++) {
1: 			if (columnList.isSet(i))
1: 				return i;
1: 		}
1: 
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 		Get the next valid column after or including start column.
1: 		Returns -1 if no valid columns exist after startColumn
1: 	*/
1: 	public static int nextColumn(
1:     Object[]   row, 
1:     FormatableBitSet                 columnList, 
1:     int                     startColumn) 
1:     {
1: 
1: 		if (columnList != null) {
1: 
1: 			int size = columnList.getLength();
1: 
1: 			for (; startColumn < size; startColumn++) {
1: 				if (columnList.isSet(startColumn)) {
1: 					return startColumn;
1: 				}
1: 			}
1: 
1: 			return -1;
1: 		}
1: 
1: 		if (row == null)
1: 			return -1;
1: 
1: 		return startColumn < row.length ? startColumn : -1;
1: 	}
1: 
1:     /**
1:      * Return a FetchDescriptor which describes a single column set.
1:      * <p>
1:      * This routine returns one of a set of constant FetchDescriptor's, and
1:      * should not be altered by the caller.
1:      **/
1:     public static final FetchDescriptor getFetchDescriptorConstant(
1:     int     single_column_number)
1:     {
1:         if (single_column_number < ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS.length)
1:         {
1:             return(ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS[single_column_number]);
1:         }
1:         else
1:         {
1:             return(
1:                 new FetchDescriptor(
1:                     single_column_number, single_column_number));
1:         }
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods dealing with cloning and row copying util functions
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * Generate a row of InstanceGetter objects to be used to generate  "empty" rows.
1:      * <p>
0:      * Generate an array of InstanceGetter objects which will be used to make
0:      * repeated calls to newRowFromClassInfoTemplate(), to repeatedly and
1:      * efficiently generate new rows.  This is important for certain 
1:      * applications like the sorter and fetchSet which generate large numbers
1:      * of "new" empty rows.
1:      * <p>
1:      *
1: 	 * @return The new row.
1:      *
0:      * @param format_ids an array of format id's, one per column in row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public static InstanceGetter[] newClassInfoTemplate(
0:     FormatableBitSet column_list,
0:     int[]    format_ids) 
1:         throws StandardException
1:     {
0:         int         num_cols = format_ids.length;
0:         InstanceGetter[] ret_row  = new InstanceGetter[num_cols];
1: 
1: 		int column_listSize = 
1:             (column_list == null) ? 0 : column_list.getLength();
1: 
1:         for (int i = 0; i < num_cols; i++)
1:         {
1:             // does caller want this column?
1:             if ((column_list != null)   && 
1:                 !((column_listSize > i) && 
1:                 (column_list.isSet(i))))
1:             {
1:                 // no - column should be skipped.
1:             }
1:             else
1:             {
1:                 // yes - create the column 
1: 
1:                 // get empty instance of object identified by the format id.
1: 
0:                 ret_row[i] = Monitor.classFromIdentifier(format_ids[i]);
1:             }
1:         }
1: 
1:         return(ret_row);
1:     }
1: 
1: 
0:     private static void newRowFromClassInfoTemplateError()
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.THROWASSERT(
0:                 "unexpected error in newRowFromClassInfoTemplate()");
1:     }
1: 
1:     /**
0:      * Generate an "empty" row from an array of classInfo objects.
1:      * <p>
0:      * Generate an array of new'd objects by using the getNewInstance()
0:      * method on each of the InstanceGetter objects.  It is more
0:      * efficient to allocate new objects based on this "cache'd"
0:      * InstanceGetter object than to call the Monitor to generate a new class
0:      * from a format id.
1:      * <p>
1:      *
1: 	 * @return The new row.
1:      *
0:      * @param classinfo_template   An array of InstanceGetter objects each of 
0:      *                             which can be used to create a new instance 
0:      *                             of the appropriate type to build a new empty
0:      *                             template row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public static DataValueDescriptor[] newRowFromClassInfoTemplate(
0:     InstanceGetter[]    classinfo_template) 
1:         throws StandardException
1:     {
1: 
1:         DataValueDescriptor[] columns = 
0:             new DataValueDescriptor[classinfo_template.length];
1: 
0:         try
1:         {
0:             for (int column_index = classinfo_template.length; 
0:                  column_index-- > 0;)
1:             {
0:                 if (classinfo_template[column_index] != null)
1:                 {
1:                     // get empty instance of DataValueDescriptor identified by 
1:                     // the format id.
0:                     columns[column_index] = (DataValueDescriptor) 
0:                         classinfo_template[column_index].getNewInstance();
1:                 }
1:             }
1:         }
0:         catch (InstantiationException ie)
1:         {
0:             newRowFromClassInfoTemplateError();
1:         }
0:         catch (IllegalAccessException iae)
1:         {
0:             newRowFromClassInfoTemplateError();
1:         }
0:         catch (InvocationTargetException ite)
1:         {
0:             newRowFromClassInfoTemplateError();
1:         }
1: 
1: 		return columns;
1:     }
1: 
1: 
1:     /**
1:      * return string version of row.
1:      * <p>
1:      * For debugging only. 
1:      *
1: 	 * @return The string version of row.
1:      *
1:      * @param row The row.
1:      *
1:      **/
1:     public static String toString(Object[] row)
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1: 
0:             String str = new String();
1: 
1:             if (row != null)
1:             {
1:                 if (row.length == 0)
1:                 {
1:                     str = "empty row";
1:                 }
1:                 else
1:                 {
1:                     for (int i = 0; i < row.length; i++)
1:                         str += "col[" + i + "]=" + row[i];
1:                 }
1:             }
1:             else
1:             {
1:                 str = "row is null";
1:             }
1: 
1:             return(str);
1:         }
1:         else
1:         {
1:             return(null);
1:         }
1:     }
1: 
1:     /**
1:      * return string version of a HashTable returned from a FetchSet.
1:      * <p>
1:      *
1: 	 * @return The string version of row.
1:      *
1:      * @param row The row.
1:      *
1:      **/
1: 
1:     // For debugging only. 
1:     public static String toString(Hashtable hash_table)
1:     {
1:         if (SanityManager.DEBUG)
1:         {
0:             String str = new String();
1: 
1:             Object  row_or_vector;
0:             Enumeration enum = hash_table.elements();
1: 
1:             for (Enumeration e = hash_table.elements(); e.hasMoreElements();)
1:             {
1:                 row_or_vector = e.nextElement();
1: 
1:                 if (row_or_vector instanceof Object[])
1:                 {
1:                     // it's a row
1:                     str += RowUtil.toString((Object[]) row_or_vector);
1:                     str += "\n";
1:                 }
1:                 else if (row_or_vector instanceof Vector)
1:                 {
1:                     // it's a vector
1:                     Vector vec = (Vector) row_or_vector;
1: 
1:                     for (int i = 0; i < vec.size(); i++)
1:                     {
1:                         str += 
1:                             "vec[" + i + "]:" + 
0:                             RowUtil.toString((Object[]) vec.elementAt(i));
1: 
1:                         str += "\n";
1:                     }
1:                 }
1:                 else
1:                 {
1:                     str += "BAD ENTRY\n";
1:                 }
1:             }
1:             return(str);
1:         }
1:         else
1:         {
1:             return(null);
1:         }
1:     }
1: 
1:     /**
1:      * Process the qualifier list on the row, return true if it qualifies.
1:      * <p>
1:      * A two dimensional array is to be used to pass around a AND's and OR's in
1:      * conjunctive normal form.  The top slot of the 2 dimensional array is 
1:      * optimized for the more frequent where no OR's are present.  The first 
1:      * array slot is always a list of AND's to be treated as described above 
1:      * for single dimensional AND qualifier arrays.  The subsequent slots are 
1:      * to be treated as AND'd arrays or OR's.  Thus the 2 dimensional array 
1:      * qual[][] argument is to be treated as the following, note if 
1:      * qual.length = 1 then only the first array is valid and it is and an 
1:      * array of and clauses:
1:      *
1:      * (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
1:      * and
1:      * (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
1:      * and
1:      * (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
1:      * ...
1:      * and
1:      * (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
1:      *
1:      * 
1: 	 * @return true if the row qualifies.
1:      *
1:      * @param row               The row being qualified.
1:      * @param qual_list         2 dimensional array representing conjunctive
1:      *                          normal form of simple qualifiers.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public static final boolean qualifyRow(
0:     Object[]        row, 
1:     Qualifier[][]   qual_list)
1: 		 throws StandardException
1: 	{
1:         boolean     row_qualifies = true;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(row != null);
1:         }
1: 
1:         // First do the qual[0] which is an array of qualifer terms.
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             // routine should not be called if there is no qualifier
1:             SanityManager.ASSERT(qual_list != null);
1:             SanityManager.ASSERT(qual_list.length > 0);
1:         }
1: 
1:         for (int i = 0; i < qual_list[0].length; i++)
1:         {
1:             // process each AND clause 
1: 
1:             row_qualifies = false;
1: 
1:             // process each OR clause.
1: 
1:             Qualifier q = qual_list[0][i];
1: 
1:             // Get the column from the possibly partial row, of the 
1:             // q.getColumnId()'th column in the full row.
0:             DataValueDescriptor columnValue = 
0:                     (DataValueDescriptor) row[q.getColumnId()];
1: 
1:             row_qualifies =
1:                 columnValue.compare(
1:                     q.getOperator(),
1:                     q.getOrderable(),
1:                     q.getOrderedNulls(),
1:                     q.getUnknownRV());
1: 
1:             if (q.negateCompareResult())
1:                 row_qualifies = !row_qualifies;
1: 
1:             // Once an AND fails the whole Qualification fails - do a return!
1:             if (!row_qualifies)
1:                 return(false);
1:         }
1: 
1:         // all the qual[0] and terms passed, now process the OR clauses
1: 
1:         for (int and_idx = 1; and_idx < qual_list.length; and_idx++)
1:         {
1:             // loop through each of the "and" clause.
1: 
1:             row_qualifies = false;
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // Each OR clause must be non-empty.
1:                 SanityManager.ASSERT(qual_list[and_idx].length > 0);
1:             }
1: 
1:             for (int or_idx = 0; or_idx < qual_list[and_idx].length; or_idx++)
1:             {
1:                 // Apply one qualifier to the row.
1:                 Qualifier q      = qual_list[and_idx][or_idx];
1:                 int       col_id = q.getColumnId();
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(
1:                         (col_id < row.length),
1:                         "Qualifier is referencing a column not in the row.");
1:                 }
1: 
1:                 // Get the column from the possibly partial row, of the 
1:                 // q.getColumnId()'th column in the full row.
0:                 DataValueDescriptor columnValue = 
0:                     (DataValueDescriptor) row[q.getColumnId()];
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     if (columnValue == null)
1:                         SanityManager.THROWASSERT(
1:                             "1:row = " + RowUtil.toString(row) +
1:                             "row.length = " + row.length +
1:                             ";q.getColumnId() = " + q.getColumnId());
1:                 }
1: 
1:                 // do the compare between the column value and value in the
1:                 // qualifier.
1:                 row_qualifies = 
1:                     columnValue.compare(
1:                             q.getOperator(),
1:                             q.getOrderable(),
1:                             q.getOrderedNulls(),
1:                             q.getUnknownRV());
1: 
1:                 if (q.negateCompareResult())
1:                     row_qualifies = !row_qualifies;
1: 
1:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
1: 
1:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "value = " + row_qualifies);
1: 
1:                 // processing "OR" clauses, so as soon as one is true, break
1:                 // to go and process next AND clause.
1:                 if (row_qualifies)
1:                     break;
1: 
1:             }
1: 
1:             // The qualifier list represented a set of "AND'd" 
1:             // qualifications so as soon as one is false processing is done.
1:             if (!row_qualifies)
1:                 break;
1:         }
1: 
1:         return(row_qualifies);
1:     }
1: 
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
/////////////////////////////////////////////////////////////////////////
1:     DataValueFactory    dvf,
1:     FormatableBitSet    column_list,
1:     int[]               format_ids,
1:     int[]               collation_ids) 
/////////////////////////////////////////////////////////////////////////
1:                 ret_row[i] = dvf.getNull(format_ids[i], collation_ids[i]);
commit:6404cde
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Generate a template row of DataValueDescriptor's
1:      * Generate an array of DataValueDescriptor objects which will be used to 
1:      * make calls to newRowFromClassInfoTemplate(), to repeatedly and
/////////////////////////////////////////////////////////////////////////
1:      * @param column_list A bit set indicating which columns to include in row.
1:      * @param format_ids  an array of format id's, one per column in row.
1:     public static DataValueDescriptor[] newTemplate(
0:     int[]            format_ids) 
1:         int                   num_cols = format_ids.length;
1:         DataValueDescriptor[] ret_row  = new DataValueDescriptor[num_cols];
/////////////////////////////////////////////////////////////////////////
0:                 ret_row[i] = (DataValueDescriptor) 
0:                     Monitor.newInstanceFromIdentifier(format_ids[i]);
/////////////////////////////////////////////////////////////////////////
1:      * Generate an "empty" row from an array of DataValueDescriptor objects.
1:      * Generate an array of new'd objects by using the getNewNull()
1:      * method on each of the DataValueDescriptor objects.  
1:      * @param  template            An array of DataValueDescriptor objects 
1:      *                             each of which can be used to create a new 
1:      *                             instance of the appropriate type to build a 
1:      *                             new empty template row.
1:     public static DataValueDescriptor[] newRowFromTemplate(
1:     DataValueDescriptor[]    template) 
1:             new DataValueDescriptor[template.length];
0:         
1:         for (int column_index = template.length; column_index-- > 0;)
1:             if (template[column_index] != null)
0:                 // get empty instance of DataValueDescriptor identified by 
0:                 // the format id.
1:                 columns[column_index] = template[column_index].getNewNull();
commit:f2ee915
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.loader.InstanceGetter;
0: 
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: 
0: import java.lang.reflect.InvocationTargetException;
0: 
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Vector;
0: 
0: /**
0:   A set of static utility methods to work with rows.
0:   <P>
0:   A row or partial row is described by two or three parameters.
0:   <OL>
0:   <LI>DataValueDescriptor[] row - an array of objects, one per column.
0:   <LI>FormatableBitSet validColumns - 
0:       an indication of which objects in row map to which columns
0:   </OL>
0:   These objects can describe a complete row or a partial row. A partial row is 
0:   one where a sub-set (e.g. columns 0, 4 and 7) of the columns are supplied 
0:   for update, or requested to be fetched on a read.  Here's an example
0:   of code to set up a partial column list to fetch the 0th (type FOO), 
0:   4th (type BAR), and 7th (type MMM) columns from a row with 10 columns, note
0:   that the format for a partial row changed from a "packed" representation
0:   in the 3.0 release to a "sparse" representation in later releases:
0: 
0:   <blockquote><pre>
0: 
0:   // allocate/initialize the row 
0:   DataValueDescriptor row = new DataValueDescriptor[10]
0:   row[0] = new FOO();
0:   row[4] = new BAR();
0:   row[7] = new MMM();
0:   
0:   // allocate/initialize the bit set 
0:   FormatableBitSet FormatableBitSet = new FormatableBitSet(10);
0:   
0:   FormatableBitSet.set(0);
0:   FormatableBitSet.set(4);
0:   FormatableBitSet.set(7);
0:   </blockquote></pre>
0: 
0: 
0:   <BR><B>Column mapping<B><BR>
0:   When validColumns is null:
0:   <UL>
0:   <LI> The number of columns is given by row.length
0:   <LI> Column N maps to row[N], where column numbers start at zero.
0:   </UL>
0:   <BR>
0:   When validColumns is not null, then
0:   <UL>
0:   <LI> The number of requested columns is given by the number of bits set in 
0:        validColumns.
0:   <LI> Column N is not in the partial row if validColumns.isSet(N) 
0:        returns false.
0:   <LI> Column N is in the partial row if validColumns.isSet(N) returns true.
0:   <LI> If column N is in the partial row then it maps to row[N].
0: 	   If N >= row.length then the column is taken as non existent for an
0: 	   insert or update, and not fetched on a fetch.
0:   </UL>
0:   If row.length is greater than the number of columns indicated by validColumns
0:   the extra entries are ignored.
0: 
0: **/
0: public class RowUtil
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private RowUtil() {}
0: 
0: 	/**
0: 		An object that can be used on a fetch to indicate no fields
0: 		need to be fetched.
0: 	*/
0: 	public static final DataValueDescriptor[] EMPTY_ROW = 
0:         new DataValueDescriptor[0];
0: 
0: 	/**
0: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
0: 		need to be fetched.
0: 	*/
0: 	public static final FormatableBitSet EMPTY_ROW_BITSET  = 
0:         new FormatableBitSet(0);
0: 
0: 	/**
0: 		An object that can be used on a fetch as a FormatableBitSet to indicate no fields
0: 		need to be fetched.
0: 	*/
0: 	public static final FetchDescriptor EMPTY_ROW_FETCH_DESCRIPTOR  = 
0:         new FetchDescriptor(0);
0: 
0: 	public static final FetchDescriptor[] ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS  =
0:         {EMPTY_ROW_FETCH_DESCRIPTOR,
0:          new FetchDescriptor(1, 1),
0:          new FetchDescriptor(2, 2),
0:          new FetchDescriptor(3, 3),
0:          new FetchDescriptor(4, 4),
0:          new FetchDescriptor(5, 5),
0:          new FetchDescriptor(6, 6),
0:          new FetchDescriptor(7, 7)};
0: 
0: 
0: 	/**
0: 		Get the object for a column identifer (0 based) from a complete or 
0:         partial row.
0: 
0: 		@param row the row
0: 		@param columnList valid columns in the row
0: 		@param columnId which column to return (0 based)
0: 
0: 		@return the obejct for the column, or null if the column is not represented.
0: 	*/
0: 	public static DataValueDescriptor getColumn(
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 columnList, 
0:     int                     columnId) 
0:     {
0: 
0: 		if (columnList == null)
0: 			return columnId < row.length ? row[columnId] : null;
0: 
0: 
0: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
0: 			return null;
0: 
0:         return columnId < row.length ? row[columnId] : null;
0: 
0: 	}
0: 
0: 	public static Object getColumn(
0:     Object[]   row, 
0:     FormatableBitSet                 columnList, 
0:     int                     columnId) 
0:     {
0: 
0: 		if (columnList == null)
0: 			return columnId < row.length ? row[columnId] : null;
0: 
0: 
0: 		if (!(columnList.getLength() > columnId && columnList.isSet(columnId)))
0: 			return null;
0: 
0:         return columnId < row.length ? row[columnId] : null;
0: 
0: 	}
0: 
0: 	/**
0: 		Get a FormatableBitSet representing all the columns represented in
0: 		a qualifier list.
0: 
0: 		@return a FormatableBitSet describing the valid columns.
0: 	*/
0: 	public static FormatableBitSet getQualifierBitSet(Qualifier[][] qualifiers) 
0:     {
0: 		FormatableBitSet qualifierColumnList = new FormatableBitSet();
0: 
0: 		if (qualifiers != null) 
0:         {
0: 			for (int i = 0; i < qualifiers.length; i++)
0: 			{
0:                 for (int j = 0; j < qualifiers[i].length; j++)
0:                 {
0:                     int colId = qualifiers[i][j].getColumnId();
0: 
0:                     // we are about to set bit colId, need length to be colId+1
0:                     qualifierColumnList.grow(colId+1);
0:                     qualifierColumnList.set(colId);
0:                 }
0: 			}
0: 		}
0: 
0: 		return qualifierColumnList;
0: 	}
0: 
0:     /**
0:      * Get the number of columns represented by a FormatableBitSet.
0:      * <p>
0:      * This is simply a count of the number of bits set in the FormatableBitSet.
0:      * <p>
0:      *
0:      * @param maxColumnNumber Because the FormatableBitSet.size() can't be used as
0:      *                        the number of columns, allow caller to tell
0:      *                        the maximum column number if it knows.  
0:      *                        -1  means caller does not know.
0:      *                        >=0 number is the largest column number.
0:      *                           
0:      * @param columnList valid columns in the row
0:      *
0: 	 * @return The number of columns represented in the FormatableBitSet.
0:      **/
0:     public static int getNumberOfColumns(
0:     int     maxColumnNumber,
0:     FormatableBitSet  columnList)
0:     {
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(columnList != null);
0: 
0:         int max_col_number = columnList.getLength();
0: 
0: 		if (maxColumnNumber > 0 && maxColumnNumber < max_col_number)
0: 			max_col_number = maxColumnNumber;
0: 
0:         int ret_num_cols = 0;
0: 
0:         for (int i = 0; i < max_col_number; i++)
0:         {
0:             if (columnList.isSet(i))
0:                 ret_num_cols++;
0:         }
0: 
0:         return(ret_num_cols);
0:     }
0: 
0: 	/**
0: 		See if a row actually contains no columns.
0: 		Returns true if row is null, row.length is null,
0: 		or columnList is not null but has not bits set.
0: 
0: 		@return true if no columns are selected in this row.
0: 	*/
0: 	public static boolean isRowEmpty(
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 columnList) 
0:     {
0: 
0: 		if (row == null)
0: 			return true;
0: 
0: 		if (row.length == 0)
0: 			return true;
0: 
0: 		if (columnList == null)
0: 			return false;
0: 
0: 		int size = columnList.getLength();
0: 		for (int i = 0; i < size; i--) {
0: 			if (columnList.isSet(i))
0: 				return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		Return the column number of the first column out of range, or a number
0:         less than zero if all columns are in range.
0: 	*/
0: 	public static int columnOutOfRange(
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 columnList, 
0:     int                     maxColumns) 
0:     {
0: 
0: 		if (columnList == null) {
0: 			if (row.length > maxColumns)
0: 				return maxColumns;
0: 
0: 			return -1;
0: 		}
0: 
0: 		int size = columnList.getLength();
0: 		for (int i = maxColumns; i < size; i++) {
0: 			if (columnList.isSet(i))
0: 				return i;
0: 		}
0: 
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 		Get the next valid column after or including start column.
0: 		Returns -1 if no valid columns exist after startColumn
0: 	*/
0: 	public static int nextColumn(
0:     Object[]   row, 
0:     FormatableBitSet                 columnList, 
0:     int                     startColumn) 
0:     {
0: 
0: 		if (columnList != null) {
0: 
0: 			int size = columnList.getLength();
0: 
0: 			for (; startColumn < size; startColumn++) {
0: 				if (columnList.isSet(startColumn)) {
0: 					return startColumn;
0: 				}
0: 			}
0: 
0: 			return -1;
0: 		}
0: 
0: 		if (row == null)
0: 			return -1;
0: 
0: 		return startColumn < row.length ? startColumn : -1;
0: 	}
0: 
0:     /**
0:      * Return a FetchDescriptor which describes a single column set.
0:      * <p>
0:      * This routine returns one of a set of constant FetchDescriptor's, and
0:      * should not be altered by the caller.
0:      **/
0:     public static final FetchDescriptor getFetchDescriptorConstant(
0:     int     single_column_number)
0:     {
0:         if (single_column_number < ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS.length)
0:         {
0:             return(ROWUTIL_FETCH_DESCRIPTOR_CONSTANTS[single_column_number]);
0:         }
0:         else
0:         {
0:             return(
0:                 new FetchDescriptor(
0:                     single_column_number, single_column_number));
0:         }
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods dealing with cloning and row copying util functions
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Generate a row of InstanceGetter objects to be used to generate  "empty" rows.
0:      * <p>
0:      * Generate an array of InstanceGetter objects which will be used to make
0:      * repeated calls to newRowFromClassInfoTemplate(), to repeatedly and
0:      * efficiently generate new rows.  This is important for certain 
0:      * applications like the sorter and fetchSet which generate large numbers
0:      * of "new" empty rows.
0:      * <p>
0:      *
0: 	 * @return The new row.
0:      *
0:      * @param format_ids an array of format id's, one per column in row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static InstanceGetter[] newClassInfoTemplate(
0:     FormatableBitSet column_list,
0:     int[]    format_ids) 
0:         throws StandardException
0:     {
0:         int         num_cols = format_ids.length;
0:         InstanceGetter[] ret_row  = new InstanceGetter[num_cols];
0: 
0: 		int column_listSize = 
0:             (column_list == null) ? 0 : column_list.getLength();
0: 
0:         for (int i = 0; i < num_cols; i++)
0:         {
0:             // does caller want this column?
0:             if ((column_list != null)   && 
0:                 !((column_listSize > i) && 
0:                 (column_list.isSet(i))))
0:             {
0:                 // no - column should be skipped.
0:             }
0:             else
0:             {
0:                 // yes - create the column 
0: 
0:                 // get empty instance of object identified by the format id.
0: 
0:                 ret_row[i] = Monitor.classFromIdentifier(format_ids[i]);
0:             }
0:         }
0: 
0:         return(ret_row);
0:     }
0: 
0: 
0:     private static void newRowFromClassInfoTemplateError()
0:     {
0:         if (SanityManager.DEBUG)
0:             SanityManager.THROWASSERT(
0:                 "unexpected error in newRowFromClassInfoTemplate()");
0:     }
0: 
0:     /**
0:      * Generate an "empty" row from an array of classInfo objects.
0:      * <p>
0:      * Generate an array of new'd objects by using the getNewInstance()
0:      * method on each of the InstanceGetter objects.  It is more
0:      * efficient to allocate new objects based on this "cache'd"
0:      * InstanceGetter object than to call the Monitor to generate a new class
0:      * from a format id.
0:      * <p>
0:      *
0: 	 * @return The new row.
0:      *
0:      * @param classinfo_template   An array of InstanceGetter objects each of 
0:      *                             which can be used to create a new instance 
0:      *                             of the appropriate type to build a new empty
0:      *                             template row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static DataValueDescriptor[] newRowFromClassInfoTemplate(
0:     InstanceGetter[]    classinfo_template) 
0:         throws StandardException
0:     {
0: 
0:         DataValueDescriptor[] columns = 
0:             new DataValueDescriptor[classinfo_template.length];
0: 
0:         try
0:         {
0:             for (int column_index = classinfo_template.length; 
0:                  column_index-- > 0;)
0:             {
0:                 if (classinfo_template[column_index] != null)
0:                 {
0:                     // get empty instance of DataValueDescriptor identified by 
0:                     // the format id.
0:                     columns[column_index] = (DataValueDescriptor) 
0:                         classinfo_template[column_index].getNewInstance();
0:                 }
0:             }
0:         }
0:         catch (InstantiationException ie)
0:         {
0:             newRowFromClassInfoTemplateError();
0:         }
0:         catch (IllegalAccessException iae)
0:         {
0:             newRowFromClassInfoTemplateError();
0:         }
0:         catch (InvocationTargetException ite)
0:         {
0:             newRowFromClassInfoTemplateError();
0:         }
0: 
0: 		return columns;
0:     }
0: 
0: 
0:     /**
0:      * return string version of row.
0:      * <p>
0:      * For debugging only. 
0:      *
0: 	 * @return The string version of row.
0:      *
0:      * @param row The row.
0:      *
0:      **/
0:     public static String toString(Object[] row)
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0: 
0:             String str = new String();
0: 
0:             if (row != null)
0:             {
0:                 if (row.length == 0)
0:                 {
0:                     str = "empty row";
0:                 }
0:                 else
0:                 {
0:                     for (int i = 0; i < row.length; i++)
0:                         str += "col[" + i + "]=" + row[i];
0:                 }
0:             }
0:             else
0:             {
0:                 str = "row is null";
0:             }
0: 
0:             return(str);
0:         }
0:         else
0:         {
0:             return(null);
0:         }
0:     }
0: 
0:     /**
0:      * return string version of a HashTable returned from a FetchSet.
0:      * <p>
0:      *
0: 	 * @return The string version of row.
0:      *
0:      * @param row The row.
0:      *
0:      **/
0: 
0:     // For debugging only. 
0:     public static String toString(Hashtable hash_table)
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             String str = new String();
0: 
0:             Object  row_or_vector;
0:             Enumeration enum = hash_table.elements();
0: 
0:             for (Enumeration e = hash_table.elements(); e.hasMoreElements();)
0:             {
0:                 row_or_vector = e.nextElement();
0: 
0:                 if (row_or_vector instanceof Object[])
0:                 {
0:                     // it's a row
0:                     str += RowUtil.toString((Object[]) row_or_vector);
0:                     str += "\n";
0:                 }
0:                 else if (row_or_vector instanceof Vector)
0:                 {
0:                     // it's a vector
0:                     Vector vec = (Vector) row_or_vector;
0: 
0:                     for (int i = 0; i < vec.size(); i++)
0:                     {
0:                         str += 
0:                             "vec[" + i + "]:" + 
0:                             RowUtil.toString((Object[]) vec.elementAt(i));
0: 
0:                         str += "\n";
0:                     }
0:                 }
0:                 else
0:                 {
0:                     str += "BAD ENTRY\n";
0:                 }
0:             }
0:             return(str);
0:         }
0:         else
0:         {
0:             return(null);
0:         }
0:     }
0: 
0:     /**
0:      * Process the qualifier list on the row, return true if it qualifies.
0:      * <p>
0:      * A two dimensional array is to be used to pass around a AND's and OR's in
0:      * conjunctive normal form.  The top slot of the 2 dimensional array is 
0:      * optimized for the more frequent where no OR's are present.  The first 
0:      * array slot is always a list of AND's to be treated as described above 
0:      * for single dimensional AND qualifier arrays.  The subsequent slots are 
0:      * to be treated as AND'd arrays or OR's.  Thus the 2 dimensional array 
0:      * qual[][] argument is to be treated as the following, note if 
0:      * qual.length = 1 then only the first array is valid and it is and an 
0:      * array of and clauses:
0:      *
0:      * (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
0:      * and
0:      * (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
0:      * and
0:      * (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
0:      * ...
0:      * and
0:      * (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
0:      *
0:      * 
0: 	 * @return true if the row qualifies.
0:      *
0:      * @param row               The row being qualified.
0:      * @param qual_list         2 dimensional array representing conjunctive
0:      *                          normal form of simple qualifiers.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public static final boolean qualifyRow(
0:     Object[]        row, 
0:     Qualifier[][]   qual_list)
0: 		 throws StandardException
0: 	{
0:         boolean     row_qualifies = true;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(row != null);
0:         }
0: 
0:         // First do the qual[0] which is an array of qualifer terms.
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             // routine should not be called if there is no qualifier
0:             SanityManager.ASSERT(qual_list != null);
0:             SanityManager.ASSERT(qual_list.length > 0);
0:         }
0: 
0:         for (int i = 0; i < qual_list[0].length; i++)
0:         {
0:             // process each AND clause 
0: 
0:             row_qualifies = false;
0: 
0:             // process each OR clause.
0: 
0:             Qualifier q = qual_list[0][i];
0: 
0:             // Get the column from the possibly partial row, of the 
0:             // q.getColumnId()'th column in the full row.
0:             DataValueDescriptor columnValue = 
0:                     (DataValueDescriptor) row[q.getColumnId()];
0: 
0:             row_qualifies =
0:                 columnValue.compare(
0:                     q.getOperator(),
0:                     q.getOrderable(),
0:                     q.getOrderedNulls(),
0:                     q.getUnknownRV());
0: 
0:             if (q.negateCompareResult())
0:                 row_qualifies = !row_qualifies;
0: 
0:             // Once an AND fails the whole Qualification fails - do a return!
0:             if (!row_qualifies)
0:                 return(false);
0:         }
0: 
0:         // all the qual[0] and terms passed, now process the OR clauses
0: 
0:         for (int and_idx = 1; and_idx < qual_list.length; and_idx++)
0:         {
0:             // loop through each of the "and" clause.
0: 
0:             row_qualifies = false;
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // Each OR clause must be non-empty.
0:                 SanityManager.ASSERT(qual_list[and_idx].length > 0);
0:             }
0: 
0:             for (int or_idx = 0; or_idx < qual_list[and_idx].length; or_idx++)
0:             {
0:                 // Apply one qualifier to the row.
0:                 Qualifier q      = qual_list[and_idx][or_idx];
0:                 int       col_id = q.getColumnId();
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT(
0:                         (col_id < row.length),
0:                         "Qualifier is referencing a column not in the row.");
0:                 }
0: 
0:                 // Get the column from the possibly partial row, of the 
0:                 // q.getColumnId()'th column in the full row.
0:                 DataValueDescriptor columnValue = 
0:                     (DataValueDescriptor) row[q.getColumnId()];
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     if (columnValue == null)
0:                         SanityManager.THROWASSERT(
0:                             "1:row = " + RowUtil.toString(row) +
0:                             "row.length = " + row.length +
0:                             ";q.getColumnId() = " + q.getColumnId());
0:                 }
0: 
0:                 // do the compare between the column value and value in the
0:                 // qualifier.
0:                 row_qualifies = 
0:                     columnValue.compare(
0:                             q.getOperator(),
0:                             q.getOrderable(),
0:                             q.getOrderedNulls(),
0:                             q.getUnknownRV());
0: 
0:                 if (q.negateCompareResult())
0:                     row_qualifies = !row_qualifies;
0: 
0:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
0: 
0:                 // SanityManager.DEBUG_PRINT("StoredPage.qual", "value = " + row_qualifies);
0: 
0:                 // processing "OR" clauses, so as soon as one is true, break
0:                 // to go and process next AND clause.
0:                 if (row_qualifies)
0:                     break;
0: 
0:             }
0: 
0:             // The qualifier list represented a set of "AND'd" 
0:             // qualifications so as soon as one is false processing is done.
0:             if (!row_qualifies)
0:                 break;
0:         }
0: 
0:         return(row_qualifies);
0:     }
0: 
0: }
============================================================================