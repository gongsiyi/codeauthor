2:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.tools.dblook
1:2efac28: 
1:3dc2ce4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:3dc2ce4:    contributor license agreements.  See the NOTICE file distributed with
1:3dc2ce4:    this work for additional information regarding copyright ownership.
1:3dc2ce4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:3dc2ce4:    (the "License"); you may not use this file except in compliance with
1:3dc2ce4:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:985fc85: 
3:fe77ca5:  */
6:fe77ca5: 
1:fe77ca5: package org.apache.derby.tools;
1:fe77ca5: 
1:fe77ca5: import java.io.BufferedReader;
1:fe77ca5: import java.io.StringReader;
1:fe77ca5: 
1:fe77ca5: import java.sql.DriverManager;
1:fe77ca5: import java.sql.ResultSet;
1:fe77ca5: import java.sql.Connection;
1:59f29e4: import java.sql.Driver;
1:fe77ca5: import java.sql.Statement;
1:fe77ca5: import java.sql.PreparedStatement;
1:fe77ca5: import java.sql.SQLException;
1:fe77ca5: import java.sql.Timestamp;
1:fe77ca5: 
1:fe77ca5: import java.util.HashMap;
1:fe77ca5: import java.util.StringTokenizer;
1:fe77ca5: import java.util.ArrayList;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:fe77ca5: 
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Check;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Index;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Jar;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Key;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Table;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Schema;
1:9ce7492: import org.apache.derby.impl.tools.dblook.DB_Sequence;
1:1fa1fd0: import org.apache.derby.impl.tools.dblook.DB_Alias;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_Trigger;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.DB_View;
1:ebad814: import org.apache.derby.impl.tools.dblook.DB_Roles;
1:2efac28: import org.apache.derby.impl.tools.dblook.DB_GrantRevoke;
1:3abc7d4: import org.apache.derby.impl.tools.dblook.Logs;
1:fe77ca5: 
1:2c35cc0: public final class dblook {
1:fe77ca5: 
1:fe77ca5: 	// DB2 enforces a maximum of 30 tables to be specified as part of
1:fe77ca5: 	// the table list.
1:2c35cc0: 	private static final int DB2_MAX_NUMBER_OF_TABLES = 30;
1:fe77ca5: 
1:fe77ca5: 	private Connection conn;
1:fe77ca5: 	private static PreparedStatement getColNameFromNumberQuery;
1:fe77ca5: 
1:fe77ca5: 	// Mappings from id to name for schemas and tables (for ease
1:fe77ca5: 	// of reference).
1:16d3334: 	private static HashMap<String,String> schemaMap;
1:16d3334: 	private static HashMap<String,String> tableIdToNameMap;
1:fe77ca5: 
1:fe77ca5: 	// Command-line Parameters.
1:2c35cc0: 	private static String sourceDBUrl;
1:2c35cc0: 	private static String ddlFileName;
1:2c35cc0: 	private static String stmtDelimiter;
1:2c35cc0: 	private static boolean appendLogs;
1:16d3334: 	private static ArrayList<String> tableList;
1:2c35cc0: 	private static String schemaParam;
1:2c35cc0: 	private static String targetSchema;
1:2c35cc0: 	private static boolean skipViews;
1:2c35cc0: 	private static boolean verbose;
1:fe77ca5: 	private static String sourceDBName;
1:fe77ca5: 
1:fe77ca5: 	private static String lookLogName = "dblook.log";
1:fe77ca5: 
1:fe77ca5: 	private static LocalizedResource langUtil;
1:fe77ca5: 
1:2efac28: 	private static boolean sqlAuthorization;
1:2efac28: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * main:
1:fe77ca5: 	 * Initialize program state by creating a dblook object,
1:fe77ca5: 	 * and then start the DDL generation by calling "go".
1:fe77ca5: 	 * ****/
1:fe77ca5: 
1:fe77ca5: 	public static void main(String[] args) {
1:fe77ca5: 
2:fe77ca5: 		try {
1:97cb351: 			new dblook(args);
1:fe77ca5: 		} catch (Exception e) {
1:97cb351: 		// All "normal" errors are logged and printed to
1:97cb351: 		// console according to command line arguments,
1:97cb351: 		// so if we get here, something unexpected must
1:97cb351: 		// have happened; print to error stream.
1:97cb351: 			e.printStackTrace();
3:fe77ca5: 		}
1:78c2db1: 
1:fe77ca5: 	}
1:2efac28: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * Constructor:
1:fe77ca5: 	 * Parse the command line, initialize logs, echo program variables,
1:3abc7d4: 	 * and load the Derby driver.
1:97cb351: 	 * @param args Array of dblook command-line arguments.
1:fe77ca5: 	 * ****/
1:fe77ca5: 
1:97cb351: 	public dblook(String[] args) throws Exception {
1:fe77ca5: 
1:fe77ca5:         // Adjust the application in accordance with derby.ui.locale
1:fe77ca5: 		// and derby.ui.codeset
1:fe77ca5: 		langUtil = LocalizedResource.getInstance();
1:fe77ca5: 
1:fe77ca5: 		// Initialize class variables.
1:fe77ca5: 		initState();
1:fe77ca5: 
1:fe77ca5: 		// Parse the command line.
1:fe77ca5: 		if (!parseArgs(args)) {
1:8beb7db: 			System.out.println(lookupMessage("DBLOOK_Usage"));
1:97cb351: 			return;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		showVariables();
1:fe77ca5: 
1:fe77ca5: 		if (!loadDriver()) {
1:97cb351: 		// Failed when loading the driver.  We already logged
1:fe77ca5: 		// the exception, so just return.
1:59f29e4:             Logs.cleanup();    // Make sure the error log is flushed to disk.
3:fe77ca5: 			return;
1:fe77ca5: 		}
1:fe77ca5: 
1:16d3334: 		schemaMap = new HashMap<String,String>();
1:16d3334: 		tableIdToNameMap = new HashMap<String,String>();
1:fe77ca5: 
1:97cb351: 		// Now run the utility.
1:97cb351: 		go();
1:97cb351: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * initState:
1:fe77ca5: 	 * Initialize class variables.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private void initState() {
1:fe77ca5: 
1:fe77ca5: 		sourceDBUrl = null;
1:fe77ca5: 		ddlFileName = null;
1:fe77ca5: 		stmtDelimiter = null;
1:fe77ca5: 		appendLogs = false;
1:fe77ca5: 		tableList = null;
1:fe77ca5: 		targetSchema = null;
1:fe77ca5: 		schemaParam = null;
1:fe77ca5: 		skipViews = false;
1:fe77ca5: 		verbose= false;
1:fe77ca5: 		sourceDBName = null;
1:fe77ca5: 		return;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * parseArgs:
1:97cb351: 	 * Parse the command-line arguments.
1:fe77ca5: 	 * @param args args[0] is the url for the source database.
1:fe77ca5: 	 * @return true if all parameters were loaded and the output
1:fe77ca5: 	 *  files were successfully created; false otherwise.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private boolean parseArgs(String[] args) {
1:fe77ca5: 
1:fe77ca5: 		if (args.length < 2)
1:fe77ca5: 		// must have minimum of 2 args: "-d" and "<dbUrl>".
1:fe77ca5: 			return false;
1:fe77ca5: 
1:fe77ca5: 		int st = 0;
1:fe77ca5: 		for (int i = 0; i < args.length; i++) {
1:fe77ca5: 			st = loadParam(args, i);
1:fe77ca5: 			if (st == -1)
1:fe77ca5: 				return false;
1:fe77ca5: 			i = st;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (sourceDBUrl == null) {
1:fe77ca5: 		// must have at least a database url.
1:fe77ca5: 			return false;	
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// At this point, all parameters should have been read into
1:fe77ca5: 		// their respective class variables.  Use those
1:fe77ca5: 		// variables for some further processing.
1:fe77ca5: 
1:fe77ca5: 		// Setup logs.
1:fe77ca5: 		boolean okay = Logs.initLogs(lookLogName, ddlFileName, appendLogs,
1:fe77ca5: 		 	verbose, (stmtDelimiter == null ? ";" : stmtDelimiter));
1:fe77ca5: 
1:fe77ca5: 		// Get database name.
1:fe77ca5: 		sourceDBName = extractDBNameFromUrl(sourceDBUrl);
1:fe77ca5: 
1:fe77ca5: 		// Set up schema restriction.
1:fe77ca5: 		if ((schemaParam != null) && (schemaParam.length() > 0) &&
1:fe77ca5: 			(schemaParam.charAt(0) != '"'))
1:fe77ca5: 		// not quoted, so upper case, then add quotes.
1:fe77ca5: 		{
1:fe77ca5: 			targetSchema = addQuotes(expandDoubleQuotes(
1:fe77ca5: 				schemaParam.toUpperCase(java.util.Locale.ENGLISH)));
1:fe77ca5: 		}
2:fe77ca5: 		else
1:fe77ca5: 			targetSchema = addQuotes(expandDoubleQuotes(stripQuotes(schemaParam)));
1:fe77ca5: 		return okay;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * loadParam:
1:fe77ca5: 	 * Read in a flag and its corresponding values from
1:fe77ca5: 	 * list of command line arguments, starting at
1:fe77ca5: 	 * the start'th argument.
1:fe77ca5: 	 * @return The position of the argument that was
1:fe77ca5: 	 *  most recently processed.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private int loadParam(String [] args, int start) {
1:fe77ca5: 
1:fe77ca5: 		if ((args[start].length() == 0) || args[start].charAt(0) != '-')
1:fe77ca5: 		// starting argument should be a flag; if it's
1:fe77ca5: 		// not, ignore it.
4:fe77ca5: 			return start;
1:fe77ca5: 
1:fe77ca5: 		boolean haveVal = (args.length > start + 1);
1:fe77ca5: 		switch (args[start].charAt(1)) {
1:fe77ca5: 
1:fe77ca5: 			case 'd':
1:fe77ca5: 				if (!haveVal)
1:fe77ca5: 					return -1;
1:1461ebe: 				if (args[start].length() == 2) {
1:1461ebe: 					sourceDBUrl = stripQuotes(args[++start]);
1:1461ebe: 					return start;
1:1461ebe: 				}
1:1461ebe: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			case 'z':
1:fe77ca5: 				if (!haveVal)
1:fe77ca5: 					return -1;
1:1461ebe: 				if (args[start].length() == 2) {
1:fe77ca5: 					schemaParam = args[++start];
1:1461ebe: 					return start;
1:1461ebe: 				}
1:1461ebe: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			case 't':
1:fe77ca5: 				if (!haveVal)
1:fe77ca5: 					return -1;
1:fe77ca5: 				if (args[start].equals("-td")) {
1:fe77ca5: 					stmtDelimiter = args[++start];
1:fe77ca5: 					return start;
1:fe77ca5: 				}
1:fe77ca5: 				else if (args[start].equals("-t"))
1:fe77ca5: 				// list of tables.
1:fe77ca5: 					return extractTableNamesFromList(args, start+1);
1:fe77ca5: 				return -1;
1:97cb351: 
1:fe77ca5: 			case 'o':
1:fe77ca5: 				if (!haveVal)
1:fe77ca5: 					return -1;
1:97cb351: 				if ((args[start].length() == 2) && (args[start+1].length() > 0)) {
1:fe77ca5: 					ddlFileName = args[++start];
1:1461ebe: 					return start;
1:1461ebe: 				}
1:1461ebe: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			case 'a':
1:fe77ca5: 				if (args[start].equals("-append")) {
1:fe77ca5: 					appendLogs = true;
1:fe77ca5: 					return start;
1:fe77ca5: 				}
1:fe77ca5: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			case 'n':
1:fe77ca5: 				if (args[start].equals("-noview")) {
1:fe77ca5: 					skipViews = true;
1:fe77ca5: 					return start;
1:fe77ca5: 				}
1:fe77ca5: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			case 'v':
1:fe77ca5: 				if (args[start].equals("-verbose")) {
1:fe77ca5: 					verbose = true;
1:fe77ca5: 					return start;
1:fe77ca5: 				}
1:fe77ca5: 				return -1;
1:fe77ca5: 
1:fe77ca5: 			default:
1:fe77ca5: 				return -1;
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * loadDriver:
1:d27d2b7: 	 * Load derby driver.
1:fe77ca5: 	 * @param precondition sourceDBUrl has been loaded.
1:fe77ca5: 	 * @return false if anything goes wrong; true otherwise.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private boolean loadDriver() {
1:fe77ca5: 
1:d27d2b7: 		String derbyDriver = System.getProperty("driver");
1:d27d2b7: 		if (derbyDriver == null) {
1:d27d2b7: 			if (sourceDBUrl.indexOf(":net://") != -1)
1:d27d2b7: 				derbyDriver = "com.ibm.db2.jcc.DB2Driver";
1:0bbfdac: 			else if (sourceDBUrl.startsWith("jdbc:derby://"))
1:0bbfdac: 			   derbyDriver = "org.apache.derby.jdbc.ClientDriver";
1:d27d2b7: 			else
1:d27d2b7: 				derbyDriver = "org.apache.derby.jdbc.EmbeddedDriver";
1:d27d2b7: 	    }
1:d27d2b7: 
1:fe77ca5: 		try {
1:59f29e4:             Class<?> klass = Class.forName(derbyDriver);
1:59f29e4:             if (Driver.class.isAssignableFrom(klass)) {
1:4469400:                 klass.getConstructor().newInstance();
1:59f29e4:             } else {
1:59f29e4:                 Logs.debug(
1:59f29e4:                         "TL_notInstanceOf",
1:59f29e4:                         new String[] { derbyDriver, Driver.class.getName() });
1:59f29e4:                 return false;
1:59f29e4:             }
1:d27d2b7: 	    }
1:d27d2b7: 		catch (Exception e)
1:fe77ca5: 		{
2:fe77ca5: 			Logs.debug(e);
1:fe77ca5: 			return false;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return true;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * extractDBNameFromUrl:
1:fe77ca5: 	 * Given a database url, parse out the actual name
1:fe77ca5: 	 * of the database.  This is required for creation
1:fe77ca5: 	 * the DB2JJARS directory (the database name is part
1:fe77ca5: 	 * of the path to the jar).
1:fe77ca5: 	 * @param dbUrl The database url from which to extract the
1:fe77ca5: 	 *  the database name.
1:fe77ca5: 	 * @return the name of the database (including its
1:fe77ca5: 	 *  path, if provided) that is referenced by the url.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:2c35cc0: 	private String extractDBNameFromUrl(String dbUrl) {
1:fe77ca5: 
1:fe77ca5: 		if (dbUrl == null)
1:fe77ca5: 		// shouldn't happen; ignore it here, as an error
1:fe77ca5: 		// will be thrown we try to connect.
1:fe77ca5: 			return "";
1:fe77ca5: 
1:fe77ca5: 		int start = dbUrl.indexOf("jdbc:derby:");
1:fe77ca5: 		if (start == -1)
1:fe77ca5: 		// not a valid url; just ignore it (an error
1:fe77ca5: 		// will be thrown when we try to connect).
1:fe77ca5: 			return "";
1:fe77ca5: 
1:0bbfdac: 		start = dbUrl.indexOf("://");
1:fe77ca5: 		if (start == -1)
1:fe77ca5: 		// standard url (jdbc:derby:<dbname>).  Database
1:1461ebe: 		// name starts right after "derby:".  The "6" in
1:1461ebe: 		// the following line is the length of "derby:".
1:1461ebe: 			start = dbUrl.indexOf("derby:") + 6;
1:fe77ca5: 		else
1:fe77ca5: 		// Network Server url.  Database name starts right
1:fe77ca5: 		// after next slash (":net://hostname:port/<dbname>).
1:0bbfdac: 		// The "3" in the following line is the length of
1:0bbfdac: 		// "://".
1:0bbfdac: 			start = dbUrl.indexOf("/", start+3) + 1;
1:fe77ca5: 
1:fe77ca5: 		int stop = -1;
1:fe77ca5: 		if (dbUrl.charAt(start) == '"') {
1:fe77ca5: 		// database name is quoted; end of the name is the
1:fe77ca5: 		// closing quote.
1:fe77ca5: 			start++;
1:fe77ca5: 			stop = dbUrl.indexOf("\"", start);
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 		// Database name ends with the start of a list of connection	
1:fe77ca5: 		// attributes.  This list can begin with either a colon
1:fe77ca5: 		// or a semi-colon.
1:fe77ca5: 			stop = dbUrl.indexOf(":", start);
1:fe77ca5: 			if (stop != -1) {
1:fe77ca5: 				if ((dbUrl.charAt(stop+1) == '/') ||
1:fe77ca5: 						(dbUrl.charAt(stop+1) == '\\'))
1:fe77ca5: 				// then this colon is part of the path (ex. "C:"),
1:fe77ca5: 				// so ignore it.
1:fe77ca5: 					stop = dbUrl.indexOf(":", stop+2);
1:fe77ca5: 			}
1:fe77ca5: 			int stop2 = dbUrl.length();
1:fe77ca5: 			if (stop == -1)
1:fe77ca5: 			// no colons; see if we can find a semi-colon.
1:fe77ca5: 				stop = dbUrl.indexOf(";", start);
1:fe77ca5: 			else
1:fe77ca5: 				stop2 = dbUrl.indexOf(";", start);
1:fe77ca5: 			stop = (stop <= stop2 ? stop : stop2);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (stop == -1)
1:fe77ca5: 		// we have a url that ends with database name (no
1:fe77ca5: 		// other attributes appended).
1:fe77ca5: 			stop = dbUrl.length();
1:fe77ca5: 
1:fe77ca5: 		return dbUrl.substring(start, stop);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * extractTableNamesFromList:
1:fe77ca5: 	 * Given an array of command line arguments containing
1:fe77ca5: 	 * a list of table names beginning at start'th position,
1:fe77ca5: 	 * read the list of table names and store them as
1:fe77ca5: 	 * our target table list.  Names without quotes are
1:fe77ca5: 	 * turned into ALL CAPS and then double quotes are
1:fe77ca5: 	 * added; names whcih already have double quotes are
1:fe77ca5: 	 * stored exactly as they are. NOTE: DB2 enforces
1:fe77ca5: 	 * maximum of 30 tables, and ignores the rest; so
1:fe77ca5: 	 * do we.
1:fe77ca5: 	 * @param args Array of command line arguments.
1:fe77ca5: 	 * @start Position of the start of the list of tables
1:fe77ca5: 	 *  with the args array.
1:fe77ca5: 	 * @return The position of the last table name in
1:fe77ca5: 	 *  the list of table names.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private int extractTableNamesFromList(String [] args,
1:fe77ca5: 		int start)
1:fe77ca5: 	{
1:fe77ca5: 
1:fe77ca5: 		int argIndex = start;
1:fe77ca5: 		int count = 0;
1:16d3334: 		tableList = new ArrayList<String>();
1:fe77ca5: 		while (argIndex < args.length) {
1:fe77ca5: 
1:fe77ca5: 			if (((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '-')) ||
1:fe77ca5: 				(++count > DB2_MAX_NUMBER_OF_TABLES))
1:fe77ca5: 			// we're done with the table list.
1:fe77ca5: 				break;
1:fe77ca5: 
1:fe77ca5: 			if ((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '"'))
1:fe77ca5: 			// it's quoted.
1:fe77ca5: 				tableList.add(addQuotes(expandDoubleQuotes(
1:fe77ca5: 					stripQuotes(args[argIndex++]))));
1:fe77ca5: 			else
1:fe77ca5: 			// not quoted, so make it all caps, then add
1:fe77ca5: 			// quotes.
1:fe77ca5: 				tableList.add(addQuotes(
1:fe77ca5: 					expandDoubleQuotes(args[argIndex++].toUpperCase(
1:fe77ca5: 					java.util.Locale.ENGLISH))));
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (tableList.size() == 0)
1:fe77ca5: 			tableList = null;
1:fe77ca5: 
1:fe77ca5: 		return argIndex - 1;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * showVariables:
1:fe77ca5: 	 * Echo primary variables to output, so user can see
1:fe77ca5: 	 * what s/he specified.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private void showVariables() {
1:fe77ca5: 
1:fe77ca5: 		if (ddlFileName != null) {
1:fe77ca5: 			Logs.reportString("============================\n");
1:8beb7db: 			Logs.reportMessage("DBLOOK_FileCreation");
1:fe77ca5: 			if (verbose)
1:8beb7db: 				writeVerboseOutput("DBLOOK_OutputLocation",
1:fe77ca5: 					ddlFileName);
1:fe77ca5: 		}
1:fe77ca5: 
1:8beb7db: 		Logs.reportMessage("DBLOOK_Timestamp",
1:fe77ca5: 			new Timestamp(System.currentTimeMillis()).toString());
1:8beb7db: 		Logs.reportMessage("DBLOOK_DBName", sourceDBName);
1:8beb7db: 		Logs.reportMessage("DBLOOK_DBUrl", sourceDBUrl);
1:fe77ca5: 		if (tableList != null)
1:8beb7db: 			Logs.reportMessage("DBLOOK_TargetTables");
1:fe77ca5: 		if (schemaParam != null)
1:8beb7db: 			Logs.reportMessage("DBLOOK_TargetSchema", stripQuotes(schemaParam));
1:fe77ca5: 		Logs.reportString("appendLogs: " + appendLogs + "\n");
1:fe77ca5: 		return;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * go:
1:fe77ca5: 	 * Connect to the source database, prepare statements,
1:fe77ca5: 	 * and load a list of table id-to-name mappings.  Then,
1:fe77ca5: 	 * generate the DDL for the various objects in the
1:fe77ca5: 	 * database by making calls to static methods of helper
1:fe77ca5: 	 * classes (one helper class for each type of database
1:fe77ca5: 	 * object).  If a particular object type should not be
1:fe77ca5: 	 * generated (because of the user-specified command-
1:fe77ca5: 	 * line), then we enforce that here.
1:fe77ca5: 	 * @precondition all user-specified parameters have
1:fe77ca5: 	 *  been loaded.
1:fe77ca5: 	 * @return DDL for the source database has been
1:fe77ca5: 	 *  generated and printed to output, subject to
1:fe77ca5: 	 *  user-specified restrictions.
1:fe77ca5: 	 * ****/
1:fe77ca5: 
1:97cb351: 	private void go()
1:fe77ca5: 		throws Exception
1:fe77ca5: 	{
1:fe77ca5: 
1:fe77ca5: 		try
1:fe77ca5: 		{
1:fe77ca5: 			// Connect to the database, prepare statements,
1:fe77ca5: 			// and load id-to-name mappings.
1:97cb351: 			this.conn = DriverManager.getConnection(sourceDBUrl);
1:97cb351: 			prepForDump();
1:fe77ca5: 
1:9ce7492:             boolean at10_6 = atVersion( conn, 10, 6 );
1:78c2db1:             boolean at10_9 = atVersion( conn, 10, 9 );
1:ea25568:             boolean at10_11 = atVersion(conn, 10, 11);
1:9ce7492: 
1:fe77ca5: 			// Generate DDL.
1:fe77ca5: 
1:fe77ca5: 			// Start with schemas, since we might need them to
1:fe77ca5: 			// exist for jars to load properly.
1:fe77ca5: 			DB_Schema.doSchemas(this.conn,
1:fe77ca5: 				(tableList != null) && (targetSchema == null));
1:9ce7492: 
1:80e55fc:             if ( at10_6 ) { DB_Sequence.doSequences( conn ); }
1:fe77ca5: 
1:fe77ca5: 			if (tableList == null) {
1:fe77ca5: 			// Don't do these if user just wants table-related objects.
1:78c2db1:                 DB_Jar.doJars(sourceDBName, this.conn, at10_9);
1:22d64f5: 				DB_Alias.doPFAU(this.conn, at10_6 );
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			DB_Table.doTables(this.conn, tableIdToNameMap);
1:fe77ca5: 			DB_Index.doIndexes(this.conn);
1:1fa1fd0: 			DB_Alias.doSynonyms(this.conn);
1:fe77ca5: 			DB_Key.doKeys(this.conn);
1:fe77ca5: 			DB_Check.doChecks(this.conn);
1:fe77ca5: 
1:fe77ca5: 			if (!skipViews)
1:fe77ca5: 				DB_View.doViews(this.conn);
1:fe77ca5: 
1:ea25568:             DB_Trigger.doTriggers(this.conn, at10_11);
1:fe77ca5: 
1:ebad814: 			DB_Roles.doRoles(this.conn);
1:9ce7492: 			DB_GrantRevoke.doAuthorizations(this.conn, at10_6);
1:fe77ca5: 
1:fe77ca5: 			// That's it; we're done.
1:fe77ca5: 			if (getColNameFromNumberQuery != null)
1:fe77ca5: 				getColNameFromNumberQuery.close();
3:fe77ca5: 			Logs.cleanup();
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 		catch (SQLException sqlE)
1:fe77ca5: 		{
2:fe77ca5: 			Logs.debug(sqlE);
2:fe77ca5: 			Logs.debug(Logs.unRollExceptions(sqlE), (String)null);
1:fe77ca5: 			Logs.cleanup();
1:97cb351: 			return;
1:fe77ca5: 		}
1:fe77ca5: 		catch (Exception e)
1:fe77ca5: 		{
1:fe77ca5: 			Logs.debug(e);
1:fe77ca5: 			Logs.cleanup();
1:97cb351: 			return;
1:fe77ca5: 		}
1:fe77ca5: 		finally {
1:fe77ca5: 		// Close our connection.
1:97cb351: 			if (conn != null) {
1:97cb351: 				conn.commit();
1:97cb351: 				conn.close();
1:97cb351: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * prepForDump:
1:fe77ca5: 	 * Prepare any useful statements (i.e. statements that
1:fe77ca5: 	 * are required by more than one helper class) and load
1:fe77ca5: 	 * the id-to-name mappings for the source database.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private void prepForDump() throws Exception {
1:fe77ca5: 
1:fe77ca5: 		// We're only SELECTing throughout all of this, so no need
1:fe77ca5: 		// to commit (plus, disabling commit makes it easier to
1:fe77ca5: 		// have multiple ResultSets open on the same connection).
1:fe77ca5: 		this.conn.setAutoCommit(false);
1:fe77ca5: 
1:cd8191c: 		// Set the system schema to ensure that UCS_BASIC collation is used.
1:cd8191c: 		Statement stmt = conn.createStatement();
1:cd8191c: 		stmt.executeUpdate("SET SCHEMA SYS");
1:cd8191c: 
1:fe77ca5: 		// Prepare statements.
1:fe77ca5: 		getColNameFromNumberQuery = conn.prepareStatement(
1:fe77ca5: 			"SELECT COLUMNNAME FROM SYS.SYSCOLUMNS WHERE " +
1:fe77ca5: 			"REFERENCEID = ? AND COLUMNNUMBER = ?");
1:fe77ca5: 
1:fe77ca5: 		// Load list of user tables and table ids, for general use.
1:fe77ca5: 		ResultSet rs = stmt.executeQuery("SELECT T.TABLEID, T.TABLENAME, " +
1:fe77ca5: 				"S.SCHEMANAME FROM SYS.SYSTABLES T, SYS.SYSSCHEMAS S " + 
1:fe77ca5: 				"WHERE T.TABLETYPE = 'T' AND T.SCHEMAID = S.SCHEMAID");
1:fe77ca5: 
1:fe77ca5: 		while (rs.next()) {
1:fe77ca5: 			String tableName = addQuotes(expandDoubleQuotes(rs.getString(2)));
1:fe77ca5: 			String schemaName = addQuotes(expandDoubleQuotes(rs.getString(3)));
1:fe77ca5: 			tableIdToNameMap.put(rs.getString(1), 
1:fe77ca5: 				schemaName + "." + tableName);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// Load schema id's and names.
1:fe77ca5: 		rs = stmt.executeQuery("SELECT SCHEMAID, SCHEMANAME FROM " +
1:fe77ca5: 			"SYS.SYSSCHEMAS");
1:fe77ca5: 		while (rs.next()) {
1:fe77ca5: 			schemaMap.put(rs.getString(1),
1:fe77ca5: 				addQuotes(expandDoubleQuotes(rs.getString(2))));
1:fe77ca5: 		}
1:fe77ca5: 
1:2efac28: 		// Check if sqlAuthorization mode is on. If so, need to generate
1:2efac28: 		// authorization statements.
1:2efac28: 		rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY" +
1:2efac28: 						"('derby.database.sqlAuthorization')");
1:2efac28: 		if (rs.next())
1:2efac28: 		{
1:2efac28: 			String sqlAuth = rs.getString(1);
1:2efac28: 			if (Boolean.valueOf(sqlAuth).booleanValue())
1:2efac28: 				sqlAuthorization = true;
1:2efac28: 		}
1:fe77ca5: 		stmt.close();
1:fe77ca5: 
1:fe77ca5: 		// Load default property values.
1:fe77ca5: 		return;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * getColumnListFromDescription:
1:fe77ca5: 	 * Takes string description of column numbers in the
1:fe77ca5: 	 * form of "(2, 1, 3...)" and the id of the table
1:fe77ca5: 	 * having those columns, and then returns a string
1:fe77ca5: 	 * with the column numbers replaced by their actual
1:fe77ca5: 	 * names ('2' is replaced with the 2nd column in the
1:fe77ca5: 	 * table, '1' with the first column, etc.).
1:fe77ca5: 	 * @param tableId the id of the table to which the column
1:fe77ca5: 	 *   numbers should be applied.
1:fe77ca5: 	 * @param description a string holding a list of column
1:fe77ca5: 	 *  numbers, enclosed in parentheses and separated
1:fe77ca5: 	 *  by commas.
1:fe77ca5: 	 * @return a new string with the column numbers in
1:fe77ca5: 	 *  'description' replaced by their column names;
1:fe77ca5: 	 *  also, the parentheses have been stripped off.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String getColumnListFromDescription(String tableId,
1:fe77ca5: 		String description) throws SQLException
1:fe77ca5: 	{
1:fe77ca5: 
1:fe77ca5: 		StringBuffer sb = new StringBuffer();
1:fe77ca5: 		StringTokenizer tokenizer = new StringTokenizer(
1:fe77ca5: 			description.substring(description.indexOf("(") + 1,
1:fe77ca5: 				description.lastIndexOf(")")), " ,", true);
1:fe77ca5: 
1:fe77ca5: 		boolean firstCol = true;
1:fe77ca5: 		while (tokenizer.hasMoreTokens()) {
1:fe77ca5: 
1:fe77ca5: 			String tok = tokenizer.nextToken().trim();
1:fe77ca5: 			if (tok.equals(""))
1:fe77ca5: 				continue;
1:fe77ca5: 			else if (tok.equals(",")) {
1:fe77ca5: 				firstCol = false;
1:fe77ca5: 				continue;
1:fe77ca5: 			}
1:fe77ca5: 			try {
1:fe77ca5: 				String colName = getColNameFromNumber(tableId,
1:eb7e251: 					(Integer.parseInt(tok)));
1:fe77ca5: 				if (!firstCol)
1:fe77ca5: 					sb.append(", ");
1:fe77ca5: 				sb.append(colName);
1:fe77ca5: 			} catch (NumberFormatException e) {
1:fe77ca5: 			// not a number; could be "ASC" or "DESC" tag,
1:fe77ca5: 			// which is okay; otherwise, something's wrong.
1:fe77ca5: 				tok = tok.toUpperCase();
1:fe77ca5: 				if (tok.equals("DESC") || tok.equals("ASC"))
1:fe77ca5: 				// then this is okay; just add the token to result.
1:fe77ca5: 					sb.append(" " + tok);
1:fe77ca5: 				else
1:fe77ca5: 				// shouldn't happen.
1:fe77ca5: 					Logs.debug("INTERNAL ERROR: read a non-number (" +
1:fe77ca5: 						tok + ") when a column number was expected:\n" +
1:fe77ca5: 						description, (String)null);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return sb.toString();
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * getColNameFromNumber:
1:fe77ca5: 	 * Takes a tableid and a column number colNum, and
1:fe77ca5: 	 * returns the name of the colNum'th column in the
1:fe77ca5: 	 * table with tableid.
1:fe77ca5: 	 * @param tableid id of the table.
1:fe77ca5: 	 * @param colNum number of the column for which we want
1:fe77ca5: 	 *  the name.
1:fe77ca5: 	 * @return The name of the colNum'th column in the
1:fe77ca5: 	 *  table with tableid.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String getColNameFromNumber(String tableId,
1:fe77ca5: 		int colNum) throws SQLException
1:fe77ca5: 	{
1:fe77ca5: 
1:fe77ca5: 		getColNameFromNumberQuery.setString(1, tableId);
1:fe77ca5: 		getColNameFromNumberQuery.setInt(2, colNum);
1:fe77ca5: 		ResultSet rs = getColNameFromNumberQuery.executeQuery();
1:fe77ca5: 
1:fe77ca5: 		if (!rs.next()) {
1:fe77ca5: 		// shouldn't happen.
1:fe77ca5: 			Logs.debug("INTERNAL ERROR: Failed column number " +
1:fe77ca5: 				"lookup for table " + lookupTableId(tableId) +
1:fe77ca5: 				", column " + colNum, (String)null);
1:fe77ca5: 			rs.close();
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			String colName = addQuotes(expandDoubleQuotes(rs.getString(1)));
1:fe77ca5: 			rs.close();
1:fe77ca5: 			return colName;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * addQuotes:
1:fe77ca5: 	 * Add quotes to the received object name, and return
1:fe77ca5: 	 * the result.
1:fe77ca5: 	 * @param name the name to which to add quotes.
1:fe77ca5: 	 * @return the name with double quotes around it.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String addQuotes(String name) {
1:fe77ca5: 
1:fe77ca5: 		if (name == null)
1:fe77ca5: 			return null;
1:fe77ca5: 
1:fe77ca5: 		return "\"" + name + "\"";
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:2efac28: 	public static String addSingleQuotes(String name) {
1:2efac28: 
1:2efac28: 		if (name == null)
1:2efac28: 			return null;
1:2efac28: 
1:2efac28: 		return "'" + name + "'";
1:2efac28: 	}
1:2efac28: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * stripQuotes:
1:fe77ca5: 	 * Takes a name and, if the name is enclosed in
1:fe77ca5: 	 * quotes, strips the quotes off.  This method
1:fe77ca5: 	 * assumes that the received String either has no quotes,
1:fe77ca5: 	 * or has a quote (double or single) as the very first
1:fe77ca5: 	 * AND very last character.
1:fe77ca5: 	 * @param quotedName a name with quotes as the first
1:fe77ca5: 	 *  and last character, or else with no quotes at all.
1:fe77ca5: 	 * @return quotedName, without the quotes.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String stripQuotes(String quotedName) {
1:fe77ca5: 
1:fe77ca5: 		if (quotedName == null)
1:fe77ca5: 			return null;
1:fe77ca5: 
1:97cb351: 		if (!(quotedName.startsWith("'") || quotedName.startsWith("\"")))
1:97cb351: 		// name doesn't _start_ with a quote, so we do nothing.
1:fe77ca5: 			return quotedName;
1:fe77ca5: 
1:97cb351: 		if (!(quotedName.endsWith("'") || quotedName.endsWith("\"")))
1:97cb351: 		// name doesn't _end_ with a quote, so we do nothing.
1:97cb351: 			return quotedName;
1:97cb351: 
1:97cb351: 		// Remove starting and ending quotes.
1:fe77ca5: 		return quotedName.substring(1, quotedName.length() - 1);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * isExcludedTable:
1:fe77ca5: 	 * Takes a table name and determines whether or not
1:fe77ca5: 	 * the DDL for objects related to that table should be
1:fe77ca5: 	 * generated.
1:fe77ca5: 	 * @param tableName name of the table to check.
1:fe77ca5: 	 * @return true if 1) the user specified a table list
1:fe77ca5: 	 *  and that list does NOT include the received name; or
1:fe77ca5: 	 *  2) if the user specified a schema restriction and
1:fe77ca5: 	 *  the received name does NOT have that schema; false
1:fe77ca5: 	 *  otherwise.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static boolean isExcludedTable(String tableName) {
1:fe77ca5: 
1:fe77ca5: 		if (tableName == null)
1:fe77ca5: 			return true;
1:fe77ca5: 
1:fe77ca5: 		int dot = tableName.indexOf(".");
1:fe77ca5: 		if (dot != -1) {
1:fe77ca5: 		// strip off the schema part of the name, and see if we're
1:fe77ca5: 		// okay to use it.
1:fe77ca5: 			if (isIgnorableSchema(tableName.substring(0, dot)))
1:fe77ca5: 			// then we exclude this table.
1:fe77ca5: 				return true;
1:fe77ca5: 			tableName = tableName.substring(dot + 1,
1:fe77ca5: 				tableName.length());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return ((tableList != null) && !tableList.contains(tableName));
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * Takes a schema name and determines whether or
1:fe77ca5: 	 * not the DDL for objects with that schema should
1:fe77ca5: 	 * be generated.
1:fe77ca5: 	 * @param schemaName schema name to be checked.
1:fe77ca5: 	 * @return true if 1) the user specified a target
1:fe77ca5: 	 *  schema and that target is NOT the same as the
1:fe77ca5: 	 *  received schema name, or 2) the schema is a
1:fe77ca5: 	 *  system schema (SYS, SYSVISUAL, or SYSIBM);
1:fe77ca5: 	 *  false otherwise;
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:2c35cc0:     private static final String[] ignorableSchemaNames = {
1:fe77ca5:         "SYSIBM",
1:fe77ca5:         "SYS",
1:fe77ca5:         "SYSVISUAL",
1:fe77ca5:         "SYSCAT",
1:fe77ca5:         "SYSFUN",
1:fe77ca5:         "SYSPROC",
1:fe77ca5:         "SYSSTAT",
1:fe77ca5:         "NULLID",
1:fe77ca5:         "SYSCS_ADMIN",
1:fe77ca5:         "SYSCS_DIAG",
1:fe77ca5:         "SYSCS_UTIL",
1:fe77ca5:         "SQLJ"};
1:fe77ca5: 
1:fe77ca5: 	public static boolean isIgnorableSchema(String schemaName) {
1:fe77ca5: 
1:fe77ca5: 		if ((targetSchema != null) && (!schemaName.equals(targetSchema)))
1:fe77ca5: 			return true;
1:fe77ca5: 
1:fe77ca5: 		schemaName = stripQuotes(schemaName);
1:fe77ca5: 
1:fe77ca5:         boolean ret = false;
1:fe77ca5: 
1:fe77ca5:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
1:fe77ca5:         {
1:fe77ca5:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
1:fe77ca5:                 break;
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         return(ret);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * Takes a string and determines whether or not that
1:fe77ca5: 	 * string makes reference to any of the table names
1:fe77ca5: 	 * in the user-specified table list.
1:fe77ca5: 	 * @param str The string in which to search for table names.
1:fe77ca5: 	 * @return true if 1) the user didn't specify a
1:fe77ca5: 	 *  target table list, or 2) the received string
1:fe77ca5: 	 *  contains at least one of the table names in the
1:fe77ca5: 	 *  user-specified target list; false otherwise.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static boolean stringContainsTargetTable(String str) {
1:fe77ca5: 
1:fe77ca5: 		if (str == null)
1:fe77ca5: 		// if the string is null, it can't possibly contain
1:fe77ca5: 		// any table names.
1:fe77ca5: 			return false;
1:fe77ca5: 
1:fe77ca5: 		if (tableList == null)
1:fe77ca5: 		// if we have no target tables, then default to true.
1:fe77ca5: 			return true;
1:fe77ca5: 
1:fe77ca5: 		int strLen = str.length();
1:fe77ca5: 		for (int i = 0; i < tableList.size(); i++) {
1:fe77ca5: 
1:16d3334: 			String tableName = tableList.get(i);
1:fe77ca5: 			tableName = expandDoubleQuotes(stripQuotes(tableName));
1:fe77ca5: 			int nameLen = tableName.length();
1:fe77ca5: 			String strCopy;
1:fe77ca5: 			if (tableName.equals(tableName.toUpperCase(
1:fe77ca5: 				java.util.Locale.ENGLISH)))
1:fe77ca5: 			// case doesn't matter.
1:fe77ca5: 				strCopy = str.toUpperCase();
1:fe77ca5: 			else
1:fe77ca5: 				strCopy = str;
1:fe77ca5: 			int pos = strCopy.indexOf(tableName);
1:fe77ca5: 			while (pos != -1) {
1:fe77ca5: 
1:fe77ca5: 				// If we found it, make sure it's really a match.
1:fe77ca5: 				// First, see if it's part of another word.
1:fe77ca5: 				if (!partOfWord(str, pos, nameLen, strLen)) {
1:fe77ca5: 
1:fe77ca5: 					// See if the match is in quotes--if so, then
1:fe77ca5: 					// it should match the table name's case.
1:fe77ca5: 					if ((pos >= 1) && (strCopy.charAt(pos-1) == '"') &&
1:fe77ca5: 					  (pos + nameLen < strCopy.length()) &&
1:fe77ca5: 					  (strCopy.charAt(pos+nameLen) == '"'))
1:fe77ca5: 					{ // match is quoted; check it's case.
1:fe77ca5: 						if (str.substring(pos,
1:fe77ca5: 							pos + nameLen).equals(tableName))
1:fe77ca5: 						// everything checks out.
1:fe77ca5: 							return true;
1:fe77ca5: 					}
1:fe77ca5: 					else
1:fe77ca5: 					// match isn't quoted, so we're okay as is.
1:fe77ca5: 						return true;
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5: 				pos = str.indexOf(tableName, pos + nameLen);
1:fe77ca5: 
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// If we get here, we didn't find it.
1:fe77ca5: 		return false;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * partOfWord:
1:fe77ca5: 	 * Returns true if the part of the string given by
1:fe77ca5: 	 * str.substring(pos, pos + nameLen) is part of
1:fe77ca5: 	 * another word.
1:fe77ca5: 	 * @param str The string in which we're looking.
1:fe77ca5: 	 * @param pos The position at which the substring in
1:fe77ca5: 	 *  question begins.
1:fe77ca5: 	 * @param nameLen the length of the substring in
1:fe77ca5: 	 *  question.
1:fe77ca5: 	 * @param strLen The length of the string in which
1:fe77ca5: 	 *  we're looking.
1:fe77ca5: 	 * @return true if the substring from pos to
1:fe77ca5: 	 *  pos+nameLen is part of larger word (i.e.
1:fe77ca5: 	 *  if it has a letter/digit immediately before
1:fe77ca5: 	 *  or after); false otherwise.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	private static boolean partOfWord (String str,
1:fe77ca5: 		int pos, int nameLen, int strLen)
1:fe77ca5: 	{
1:fe77ca5: 
1:fe77ca5: 		boolean somethingBefore = false;
1:fe77ca5: 		if (pos > 0) {
1:fe77ca5: 			char c = str.charAt(pos-1);
1:fe77ca5: 			somethingBefore = ((c == '_') ||
1:fe77ca5: 				Character.isLetterOrDigit(c));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		boolean somethingAfter = false;
1:fe77ca5: 		if (pos + nameLen < strLen) {
1:fe77ca5: 			char c = str.charAt(pos + nameLen);
1:fe77ca5: 			somethingAfter = ((c == '_') ||
1:fe77ca5: 				Character.isLetterOrDigit(c));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return (somethingBefore || somethingAfter);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * expandDoubleQuotes:
1:fe77ca5: 	 * If the received SQL id contains a quote, we have
1:fe77ca5: 	 * to expand it into TWO quotes so that it can be
1:fe77ca5: 	 * treated correctly at parse time.
1:fe77ca5: 	 * @param name Id that we want to print.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String expandDoubleQuotes(String name) {
1:fe77ca5: 
1:fe77ca5: 		if ((name == null) || (name.indexOf("\"") < 0))
2:fe77ca5: 		// nothing to do.
1:fe77ca5: 			return name;
1:fe77ca5: 
1:fe77ca5: 		char [] cA = name.toCharArray();
1:fe77ca5: 
1:fe77ca5: 		// Worst (and extremely unlikely) case is every 
1:fe77ca5: 		// character is a double quote, which means the
1:fe77ca5: 		// escaped string would need to be 2 times as long.
1:fe77ca5: 		char [] result = new char[2*cA.length];
1:fe77ca5: 
1:fe77ca5: 		int j = 0;
1:fe77ca5: 		for (int i = 0; i < cA.length; i++) {
1:fe77ca5: 
1:fe77ca5: 			if (cA[i] == '"') {
1:fe77ca5: 				result[j++] = '"';
1:fe77ca5: 				result[j++] = '"';
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 				result[j++] = cA[i];
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return new String(result, 0, j);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:9ce7492:     /**
1:78c2db1:      * inverse of expandDoubleQuotes
1:78c2db1:      */
1:78c2db1:     public static String unExpandDoubleQuotes(String name) {
1:78c2db1: 
1:78c2db1:         if ((name == null) || (name.indexOf("\"") < 0))
1:78c2db1:         // nothing to do.
1:78c2db1:             return name;
1:78c2db1: 
1:78c2db1:         char [] cA = name.toCharArray();
1:78c2db1: 
1:78c2db1:         char [] result = new char[cA.length];
1:78c2db1: 
1:78c2db1:         int j = 0;
1:78c2db1:         for (int i = 0; i < cA.length; i++) {
1:78c2db1: 
1:78c2db1:             if (cA[i] == '"') {
1:78c2db1:                 result[j++] = cA[i];
1:78c2db1:                 j++; // skip next char which must be " also
1:78c2db1:             }
1:78c2db1:             else
1:78c2db1:                 result[j++] = cA[i];
1:78c2db1: 
1:78c2db1:         }
1:78c2db1: 
1:78c2db1:         return new String(result, 0, j);
1:78c2db1: 
1:78c2db1:     }
1:78c2db1: 
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * lookupSchemaId:
1:fe77ca5: 	 * Return the schema name corresponding to the
1:fe77ca5: 	 * received schema id.
1:fe77ca5: 	 * @param schemaId The id to look up.
1:fe77ca5: 	 * @return the schema name.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String lookupSchemaId(String schemaId) {
1:fe77ca5: 
1:16d3334: 		return schemaMap.get(schemaId);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * lookupTableId:
1:fe77ca5: 	 * Return the table name corresponding to the
1:fe77ca5: 	 * received table id.
1:fe77ca5: 	 * @param tableId The id to look up.
1:fe77ca5: 	 * @return the table name.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String lookupTableId(String tableId) {
1:fe77ca5: 
1:16d3334: 		return tableIdToNameMap.get(tableId);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * writeVerboseOutput:
1:fe77ca5: 	 * Writes the received string as "verbose" output,
1:fe77ca5: 	 * meaning that we write it to System.err.  We
1:fe77ca5: 	 * choose System.err so that the string doesn't
1:fe77ca5: 	 * show up if the user pipes dblook output to
1:fe77ca5: 	 * a file (unless s/he explicitly pipes System.err
1:fe77ca5: 	 * output to that file, as well).
1:fe77ca5: 	 * @param key Key for the message to be printed as
1:fe77ca5: 	 *  verbose output.
1:fe77ca5: 	 * @param value Value to be substituted into the
1:fe77ca5: 	 *  message.
1:fe77ca5: 	 * @return message for received key has been printed
1:fe77ca5: 	 *  to System.err.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static void writeVerboseOutput(String key,
1:fe77ca5: 		String value) {
1:fe77ca5: 
1:fe77ca5: 		if (value == null)
1:fe77ca5: 			System.err.println(lookupMessage(key));
1:fe77ca5: 		else
1:fe77ca5: 			System.err.println(lookupMessage(key,
1:fe77ca5: 				new String [] {value}));
1:fe77ca5: 		return;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * lookupMessage:
1:fe77ca5: 	 * Retrieve a localized message.
1:fe77ca5: 	 * @param key The key for the localized message.
1:fe77ca5: 	 * @return the message corresponding to the received
1:fe77ca5: 	 *  key.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String lookupMessage(String key) {
1:fe77ca5: 
1:fe77ca5: 		return lookupMessage(key, null);
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * lookupMessage:
1:fe77ca5: 	 * Retreive a localized message.
1:fe77ca5: 	 * @param key The key for the localized message.
1:fe77ca5: 	 * @param vals Array of values to be used in the
1:fe77ca5: 	 *   message.
1:fe77ca5: 	 * @return the message corresponding to the received
1:fe77ca5: 	 *  key, with the received values substituted where
1:fe77ca5: 	 *  appropriate.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String lookupMessage(String key, String[] vals) {
1:fe77ca5: 	
1:fe77ca5: 		String msg = "";
1:fe77ca5: 		if (vals == null)
1:fe77ca5: 			msg = langUtil.getTextMessage(key);
1:fe77ca5: 		else {
1:fe77ca5: 			switch (vals.length) {
1:fe77ca5: 				case 1: msg = langUtil.getTextMessage(
1:fe77ca5: 							key, vals[0]);
1:fe77ca5: 						break;
1:fe77ca5: 				case 2: msg = langUtil.getTextMessage(
1:fe77ca5: 							key, vals[0], vals[1]);
1:fe77ca5: 						break;
1:fe77ca5: 				default: /* shouldn't happen */
1:fe77ca5: 						break;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return msg;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* ************************************************
1:fe77ca5: 	 * removeNewlines:
1:fe77ca5: 	 * Remove any newline characters from the received
1:fe77ca5: 	 * string (replace them with spaces).
1:fe77ca5: 	 * @param str The string from which we are removing
1:fe77ca5: 	 *  all newline characters.
1:fe77ca5: 	 * @return The string, with all newline characters
1:fe77ca5: 	 *  replaced with spaces.
1:fe77ca5: 	 ****/
1:fe77ca5: 
1:fe77ca5: 	public static String removeNewlines(String str) {
1:fe77ca5: 
1:fe77ca5: 		if (str == null)
1:fe77ca5: 		// don't do anything.
1:fe77ca5: 			return null;
1:fe77ca5: 
1:fe77ca5: 		StringBuffer result = null;
1:fe77ca5: 		try {
1:fe77ca5: 
1:fe77ca5: 			BufferedReader strVal = new BufferedReader (new StringReader(str));
1:fe77ca5: 			for (String txt = strVal.readLine(); txt != null;
1:fe77ca5: 				txt = strVal.readLine())
1:fe77ca5: 			{
1:fe77ca5: 				if (result == null)
1:fe77ca5: 					result = new StringBuffer(txt);
1:fe77ca5: 				else {
1:fe77ca5: 					result.append(" ");
1:fe77ca5: 					result.append(txt);
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			return result.toString();
1:fe77ca5: 
1:fe77ca5: 		} catch (Exception e) {
1:fe77ca5: 		// if something went wrong, just return the string as is--
1:fe77ca5: 		// worst case is that the generated DDL is correct, it just
1:97cb351: 		// can't be run in some SQL script apps (because of the newline
1:fe77ca5: 		// characters).
1:fe77ca5: 			return str;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:78c2db1:     /**
1:9ce7492:      * Return true if we are at 10.6 or later.
1:9ce7492:      */
1:9ce7492:     private static boolean atVersion( Connection conn, int major, int minor ) throws SQLException
1:9ce7492:     {
1:9ce7492:         PreparedStatement ps = null;
1:9ce7492:         ResultSet rs =  null;
1:9ce7492:         try {
1:9ce7492:             ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );
1:9ce7492:             rs = ps.executeQuery();
1:9ce7492: 
1:9ce7492:             rs.next();
1:9ce7492: 
1:9ce7492:             String versionString = rs.getString( 1 );
1:9ce7492:             int  dotIdx = versionString.indexOf( '.' );
1:9ce7492:             int actualMajor = Integer.parseInt( versionString.substring( 0, dotIdx ) );
1:9ce7492:             int actualMinor = Integer.parseInt( versionString.substring( dotIdx + 1, versionString.length() ) );
1:9ce7492: 
1:9ce7492:             if ( actualMajor > major ) { return true; }
1:9ce7492:             if ( actualMajor < major ) { return false; }
1:9ce7492: 
1:9ce7492:             boolean result = ( actualMinor >= minor );
1:9ce7492:             
1:9ce7492:             return result;
1:9ce7492:         }
1:9ce7492:         finally
1:9ce7492:         {
1:9ce7492:             if ( rs != null ) { rs.close(); }
1:9ce7492:             if ( ps != null ) { ps.close(); }
1:9ce7492:         }
1:9ce7492:     }
1:9ce7492: 	
1:fe77ca5: }
1:fe77ca5: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                 klass.getConstructor().newInstance();
commit:16d3334
/////////////////////////////////////////////////////////////////////////
1: 	private static HashMap<String,String> schemaMap;
1: 	private static HashMap<String,String> tableIdToNameMap;
1: 	private static ArrayList<String> tableList;
/////////////////////////////////////////////////////////////////////////
1: 		schemaMap = new HashMap<String,String>();
1: 		tableIdToNameMap = new HashMap<String,String>();
/////////////////////////////////////////////////////////////////////////
1: 		tableList = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1: 			String tableName = tableList.get(i);
/////////////////////////////////////////////////////////////////////////
1: 		return schemaMap.get(schemaId);
/////////////////////////////////////////////////////////////////////////
1: 		return tableIdToNameMap.get(tableId);
commit:22d64f5
/////////////////////////////////////////////////////////////////////////
1: 				DB_Alias.doPFAU(this.conn, at10_6 );
commit:80e55fc
/////////////////////////////////////////////////////////////////////////
1:             if ( at10_6 ) { DB_Sequence.doSequences( conn ); }
commit:9ce7492
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.tools.dblook.DB_Sequence;
/////////////////////////////////////////////////////////////////////////
1:             boolean at10_6 = atVersion( conn, 10, 6 );
1: 
/////////////////////////////////////////////////////////////////////////
0:             DB_Sequence.doSequences( conn );
1: 
0: 				DB_Alias.doProceduresFunctionsAndUDTs(this.conn, at10_6 );
/////////////////////////////////////////////////////////////////////////
1: 			DB_GrantRevoke.doAuthorizations(this.conn, at10_6);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return true if we are at 10.6 or later.
1:      */
1:     private static boolean atVersion( Connection conn, int major, int minor ) throws SQLException
1:     {
1:         PreparedStatement ps = null;
1:         ResultSet rs =  null;
1:         try {
1:             ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );
1:             rs = ps.executeQuery();
1: 
1:             rs.next();
1: 
1:             String versionString = rs.getString( 1 );
1:             int  dotIdx = versionString.indexOf( '.' );
1:             int actualMajor = Integer.parseInt( versionString.substring( 0, dotIdx ) );
1:             int actualMinor = Integer.parseInt( versionString.substring( dotIdx + 1, versionString.length() ) );
1: 
1:             if ( actualMajor > major ) { return true; }
1:             if ( actualMajor < major ) { return false; }
1: 
1:             boolean result = ( actualMinor >= minor );
1:             
1:             return result;
1:         }
1:         finally
1:         {
1:             if ( rs != null ) { rs.close(); }
1:             if ( ps != null ) { ps.close(); }
1:         }
1:     }
1: 	
commit:ef1ecee
/////////////////////////////////////////////////////////////////////////
0: 				DB_Alias.doProceduresFunctionsAndUDTs(this.conn);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:59f29e4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Driver;
/////////////////////////////////////////////////////////////////////////
1:             Logs.cleanup();    // Make sure the error log is flushed to disk.
/////////////////////////////////////////////////////////////////////////
1:             Class<?> klass = Class.forName(derbyDriver);
1:             if (Driver.class.isAssignableFrom(klass)) {
0:                 klass.newInstance();
1:             } else {
1:                 Logs.debug(
1:                         "TL_notInstanceOf",
1:                         new String[] { derbyDriver, Driver.class.getName() });
1:                 return false;
1:             }
commit:ea25568
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             boolean at10_11 = atVersion(conn, 10, 11);
/////////////////////////////////////////////////////////////////////////
1:             DB_Trigger.doTriggers(this.conn, at10_11);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1:             boolean at10_9 = atVersion( conn, 10, 9 );
/////////////////////////////////////////////////////////////////////////
1:                 DB_Jar.doJars(sourceDBName, this.conn, at10_9);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * inverse of expandDoubleQuotes
1:      */
1:     public static String unExpandDoubleQuotes(String name) {
1: 
1:         if ((name == null) || (name.indexOf("\"") < 0))
1:         // nothing to do.
1:             return name;
1: 
1:         char [] cA = name.toCharArray();
1: 
1:         char [] result = new char[cA.length];
1: 
1:         int j = 0;
1:         for (int i = 0; i < cA.length; i++) {
1: 
1:             if (cA[i] == '"') {
1:                 result[j++] = cA[i];
1:                 j++; // skip next char which must be " also
1:             }
1:             else
1:                 result[j++] = cA[i];
1: 
1:         }
1: 
1:         return new String(result, 0, j);
1: 
1:     }
1: 
1: 
commit:ebad814
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.tools.dblook.DB_Roles;
/////////////////////////////////////////////////////////////////////////
1: 			DB_Roles.doRoles(this.conn);
author:Lily Wei
-------------------------------------------------------------------------------
commit:eb7e251
/////////////////////////////////////////////////////////////////////////
1: 					(Integer.parseInt(tok)));
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cd8191c
/////////////////////////////////////////////////////////////////////////
1: 		// Set the system schema to ensure that UCS_BASIC collation is used.
1: 		Statement stmt = conn.createStatement();
1: 		stmt.executeUpdate("SET SCHEMA SYS");
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3dc2ce4
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:97cb351
/////////////////////////////////////////////////////////////////////////
1: 			new dblook(args);
1: 		// All "normal" errors are logged and printed to
1: 		// console according to command line arguments,
1: 		// so if we get here, something unexpected must
1: 		// have happened; print to error stream.
1: 			e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
1: 	 * @param args Array of dblook command-line arguments.
1: 	public dblook(String[] args) throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 			return;
1: 		// Failed when loading the driver.  We already logged
/////////////////////////////////////////////////////////////////////////
1: 		// Now run the utility.
1: 		go();
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Parse the command-line arguments.
/////////////////////////////////////////////////////////////////////////
1: 
1: 				if ((args[start].length() == 2) && (args[start+1].length() > 0)) {
/////////////////////////////////////////////////////////////////////////
1: 	private void go()
/////////////////////////////////////////////////////////////////////////
1: 			this.conn = DriverManager.getConnection(sourceDBUrl);
1: 			prepForDump();
/////////////////////////////////////////////////////////////////////////
0: 				DB_Jar.doJars(sourceDBName, this.conn);
/////////////////////////////////////////////////////////////////////////
1: 			return;
1: 			return;
1: 			if (conn != null) {
1: 				conn.commit();
1: 				conn.close();
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		if (!(quotedName.startsWith("'") || quotedName.startsWith("\"")))
1: 		// name doesn't _start_ with a quote, so we do nothing.
1: 		if (!(quotedName.endsWith("'") || quotedName.endsWith("\"")))
1: 		// name doesn't _end_ with a quote, so we do nothing.
1: 			return quotedName;
1: 
1: 		// Remove starting and ending quotes.
/////////////////////////////////////////////////////////////////////////
1: 		// can't be run in some SQL script apps (because of the newline
commit:8beb7db
/////////////////////////////////////////////////////////////////////////
1: 			System.out.println(lookupMessage("DBLOOK_Usage"));
/////////////////////////////////////////////////////////////////////////
1: 			Logs.reportMessage("DBLOOK_FileCreation");
1: 				writeVerboseOutput("DBLOOK_OutputLocation",
1: 		Logs.reportMessage("DBLOOK_Timestamp",
1: 		Logs.reportMessage("DBLOOK_DBName", sourceDBName);
1: 		Logs.reportMessage("DBLOOK_DBUrl", sourceDBUrl);
1: 			Logs.reportMessage("DBLOOK_TargetTables");
1: 			Logs.reportMessage("DBLOOK_TargetSchema", stripQuotes(schemaParam));
commit:3abc7d4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.tools.dblook.DB_Check;
1: import org.apache.derby.impl.tools.dblook.DB_Index;
1: import org.apache.derby.impl.tools.dblook.DB_Jar;
1: import org.apache.derby.impl.tools.dblook.DB_Key;
1: import org.apache.derby.impl.tools.dblook.DB_Table;
1: import org.apache.derby.impl.tools.dblook.DB_Schema;
0: import org.apache.derby.impl.tools.dblook.DB_StoredProcedure;
1: import org.apache.derby.impl.tools.dblook.DB_Trigger;
1: import org.apache.derby.impl.tools.dblook.DB_View;
1: import org.apache.derby.impl.tools.dblook.Logs;
/////////////////////////////////////////////////////////////////////////
1: 	 * and load the Derby driver.
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2efac28
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.tools.dblook.DB_GrantRevoke;
/////////////////////////////////////////////////////////////////////////
1: 	private static boolean sqlAuthorization;
1: 
/////////////////////////////////////////////////////////////////////////
0: 			DB_GrantRevoke.doAuthorizations(this.conn);
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// Check if sqlAuthorization mode is on. If so, need to generate
1: 		// authorization statements.
1: 		rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY" +
1: 						"('derby.database.sqlAuthorization')");
1: 		if (rs.next())
1: 		{
1: 			String sqlAuth = rs.getString(1);
1: 			if (Boolean.valueOf(sqlAuth).booleanValue())
1: 				sqlAuthorization = true;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public static String addSingleQuotes(String name) {
1: 
1: 		if (name == null)
1: 			return null;
1: 
1: 		return "'" + name + "'";
1: 	}
1: 
commit:1fa1fd0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.tools.dblook.DB_Alias;
/////////////////////////////////////////////////////////////////////////
0: 				DB_Alias.doProceduresAndFunctions(this.conn);
1: 			DB_Alias.doSynonyms(this.conn);
commit:582425f
/////////////////////////////////////////////////////////////////////////
0: 			DB_StoredProcedure.doSynonyms(this.conn);
commit:d27d2b7
/////////////////////////////////////////////////////////////////////////
1: 	 * Load derby driver.
1: 		String derbyDriver = System.getProperty("driver");
1: 		if (derbyDriver == null) {
1: 			if (sourceDBUrl.indexOf(":net://") != -1)
1: 				derbyDriver = "com.ibm.db2.jcc.DB2Driver";
1: 			else
1: 				derbyDriver = "org.apache.derby.jdbc.EmbeddedDriver";
1: 	    }
1: 
0: 			Class.forName(derbyDriver).newInstance();
1: 	    }
1: 		catch (Exception e)
commit:1461ebe
/////////////////////////////////////////////////////////////////////////
1: 				if (args[start].length() == 2) {
1: 					sourceDBUrl = stripQuotes(args[++start]);
1: 					return start;
1: 				}
1: 				return -1;
1: 				if (args[start].length() == 2) {
1: 					return start;
1: 				}
1: 				return -1;
/////////////////////////////////////////////////////////////////////////
0: 				if ((args[start].length() == 2) && (args[start+1].length() > 0)){
1: 					return start;
1: 				}
1: 				return -1;
/////////////////////////////////////////////////////////////////////////
1: 		// name starts right after "derby:".  The "6" in
1: 		// the following line is the length of "derby:".
1: 			start = dbUrl.indexOf("derby:") + 6;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2c35cc0
/////////////////////////////////////////////////////////////////////////
1: public final class dblook {
1: 	private static final int DB2_MAX_NUMBER_OF_TABLES = 30;
0: 	private static HashMap schemaMap;
0: 	private static HashMap tableIdToNameMap;
1: 	private static String sourceDBUrl;
1: 	private static String ddlFileName;
1: 	private static String stmtDelimiter;
1: 	private static boolean appendLogs;
0: 	private static ArrayList tableList;
1: 	private static String schemaParam;
1: 	private static String targetSchema;
1: 	private static boolean skipViews;
1: 	private static boolean verbose;
/////////////////////////////////////////////////////////////////////////
1: 	private String extractDBNameFromUrl(String dbUrl) {
/////////////////////////////////////////////////////////////////////////
1:     private static final String[] ignorableSchemaNames = {
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.tools.dblook
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.tools
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.tools;
1: 
1: import java.io.BufferedReader;
1: import java.io.StringReader;
1: 
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.Connection;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Timestamp;
1: 
1: import java.util.HashMap;
1: import java.util.StringTokenizer;
1: import java.util.ArrayList;
1: 
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1: 
0: import org.apache.derby.impl.tools.cslook.DB_Check;
0: import org.apache.derby.impl.tools.cslook.DB_Index;
0: import org.apache.derby.impl.tools.cslook.DB_Jar;
0: import org.apache.derby.impl.tools.cslook.DB_Key;
0: import org.apache.derby.impl.tools.cslook.DB_Table;
0: import org.apache.derby.impl.tools.cslook.DB_Schema;
0: import org.apache.derby.impl.tools.cslook.DB_StoredProcedure;
0: import org.apache.derby.impl.tools.cslook.DB_Trigger;
0: import org.apache.derby.impl.tools.cslook.DB_View;
0: import org.apache.derby.impl.tools.cslook.Logs;
1: 
0: public class dblook {
1: 
1: 	/* 
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 	// DB2 enforces a maximum of 30 tables to be specified as part of
1: 	// the table list.
0: 	public static final int DB2_MAX_NUMBER_OF_TABLES = 30;
1: 
1: 	private Connection conn;
1: 	private static PreparedStatement getColNameFromNumberQuery;
1: 
1: 	// Mappings from id to name for schemas and tables (for ease
1: 	// of reference).
0: 	protected static HashMap schemaMap;
0: 	protected static HashMap tableIdToNameMap;
1: 
1: 	// Command-line Parameters.
0: 	protected static String sourceDBUrl;
0: 	protected static String ddlFileName;
0: 	protected static String stmtDelimiter;
0: 	protected static boolean appendLogs;
0: 	protected static ArrayList tableList;
0: 	protected static String schemaParam;
0: 	protected static String targetSchema;
0: 	protected static boolean skipViews;
0: 	protected static boolean verbose;
1: 	private static String sourceDBName;
1: 
1: 	private static String lookLogName = "dblook.log";
1: 
0: 	private final static String DEFAULT_LOCALE= "en";
0: 	private final static String DEFAULT_LOCALE_COUNTRY="US";
1: 	private static LocalizedResource langUtil;
1: 
1: 	/* ************************************************
1: 	 * main:
1: 	 * Initialize program state by creating a dblook object,
1: 	 * and then start the DDL generation by calling "go".
1: 	 * ****/
1: 
1: 	public static void main(String[] args) {
1: 
0: 		dblook looker = new dblook(args);
1: 		try {
0: 			looker.go(sourceDBUrl, sourceDBName);
1: 		} catch (Exception e) {
0: 		// Errors are logged and printed to console according
0: 		// to command line arguments, so just ignore here.
1: 		}
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * Constructor:
1: 	 * Parse the command line, initialize logs, echo program variables,
0: 	 * and load the Cloudscape driver.
0: 	 * @param args args[0] is the database URL.  All other command-line
0: 	 *  parameters are read as system properties.
1: 	 * ****/
1: 
0: 	public dblook(String[] args) {
1: 
1:         // Adjust the application in accordance with derby.ui.locale
1: 		// and derby.ui.codeset
1: 		langUtil = LocalizedResource.getInstance();
1: 
1: 		// Initialize class variables.
1: 		initState();
1: 
1: 		// Parse the command line.
1: 		if (!parseArgs(args)) {
0: 			System.out.println(lookupMessage("CSLOOK_Usage"));
0: 			System.exit(1);
1: 		}
1: 
1: 		showVariables();
1: 
1: 		if (!loadDriver()) {
0: 		// Failed when loading the driver.  We already printed
1: 		// the exception, so just return.
1: 			return;
1: 		}
1: 
0: 		schemaMap = new HashMap();
0: 		tableIdToNameMap = new HashMap();
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * initState:
1: 	 * Initialize class variables.
1: 	 ****/
1: 
1: 	private void initState() {
1: 
1: 		sourceDBUrl = null;
1: 		ddlFileName = null;
1: 		stmtDelimiter = null;
1: 		appendLogs = false;
1: 		tableList = null;
1: 		targetSchema = null;
1: 		schemaParam = null;
1: 		skipViews = false;
1: 		verbose= false;
1: 		sourceDBName = null;
1: 		return;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * parseArgs:
0: 	 * Parse the command-line arguments.  There is only one
0: 	 * actual argument (database url); the rest of the parameters
0: 	 * are read in as System properties.
1: 	 * @param args args[0] is the url for the source database.
1: 	 * @return true if all parameters were loaded and the output
1: 	 *  files were successfully created; false otherwise.
1: 	 ****/
1: 
1: 	private boolean parseArgs(String[] args) {
1: 
1: 		if (args.length < 2)
1: 		// must have minimum of 2 args: "-d" and "<dbUrl>".
1: 			return false;
1: 
1: 		int st = 0;
1: 		for (int i = 0; i < args.length; i++) {
1: 			st = loadParam(args, i);
1: 			if (st == -1)
1: 				return false;
1: 			i = st;
1: 		}
1: 
1: 		if (sourceDBUrl == null) {
1: 		// must have at least a database url.
1: 			return false;	
1: 		}
1: 
1: 		// At this point, all parameters should have been read into
1: 		// their respective class variables.  Use those
1: 		// variables for some further processing.
1: 
1: 		// Setup logs.
1: 		boolean okay = Logs.initLogs(lookLogName, ddlFileName, appendLogs,
1: 		 	verbose, (stmtDelimiter == null ? ";" : stmtDelimiter));
1: 
1: 		// Get database name.
1: 		sourceDBName = extractDBNameFromUrl(sourceDBUrl);
1: 
1: 		// Set up schema restriction.
1: 		if ((schemaParam != null) && (schemaParam.length() > 0) &&
1: 			(schemaParam.charAt(0) != '"'))
1: 		// not quoted, so upper case, then add quotes.
1: 		{
1: 			targetSchema = addQuotes(expandDoubleQuotes(
1: 				schemaParam.toUpperCase(java.util.Locale.ENGLISH)));
1: 		}
1: 		else
1: 			targetSchema = addQuotes(expandDoubleQuotes(stripQuotes(schemaParam)));
1: 		return okay;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * loadParam:
1: 	 * Read in a flag and its corresponding values from
1: 	 * list of command line arguments, starting at
1: 	 * the start'th argument.
1: 	 * @return The position of the argument that was
1: 	 *  most recently processed.
1: 	 ****/
1: 
1: 	private int loadParam(String [] args, int start) {
1: 
1: 		if ((args[start].length() == 0) || args[start].charAt(0) != '-')
1: 		// starting argument should be a flag; if it's
1: 		// not, ignore it.
1: 			return start;
1: 
1: 		boolean haveVal = (args.length > start + 1);
1: 		switch (args[start].charAt(1)) {
1: 
1: 			case 'd':
1: 				if (!haveVal)
1: 					return -1;
0: 				if (args[start].length() == 2)
0: 					sourceDBUrl = args[++start];
1: 				return start;
1: 
1: 			case 'z':
1: 				if (!haveVal)
1: 					return -1;
0: 				if (args[start].length() == 2)
1: 					schemaParam = args[++start];
1: 				return start;
1: 
1: 			case 't':
1: 				if (!haveVal)
1: 					return -1;
1: 				if (args[start].equals("-td")) {
1: 					stmtDelimiter = args[++start];
1: 					return start;
1: 				}
1: 				else if (args[start].equals("-t"))
1: 				// list of tables.
1: 					return extractTableNamesFromList(args, start+1);
1: 				return -1;
1: 			case 'o':
1: 				if (!haveVal)
1: 					return -1;
0: 				if ((args[start].length() == 2) && (args[start+1].length() > 0))
1: 					ddlFileName = args[++start];
1: 				return start;
1: 
1: 			case 'a':
1: 				if (args[start].equals("-append")) {
1: 					appendLogs = true;
1: 					return start;
1: 				}
1: 				return -1;
1: 
1: 			case 'n':
1: 				if (args[start].equals("-noview")) {
1: 					skipViews = true;
1: 					return start;
1: 				}
1: 				return -1;
1: 
1: 			case 'v':
1: 				if (args[start].equals("-verbose")) {
1: 					verbose = true;
1: 					return start;
1: 				}
1: 				return -1;
1: 
1: 			default:
1: 				return -1;
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * loadDriver:
0: 	 * Load db2j driver.
1: 	 * @param precondition sourceDBUrl has been loaded.
1: 	 * @return false if anything goes wrong; true otherwise.
1: 	 ****/
1: 
1: 	private boolean loadDriver() {
1: 
0: 		String db2jDriver;
0: 		if (sourceDBUrl.indexOf(":net://") != -1)
0: 			db2jDriver = "com.ibm.db2.jcc.DB2Driver";
1: 		else
0: 			db2jDriver = "org.apache.derby.jdbc.EmbeddedDriver";
1: 		try {
0: 			Class.forName(db2jDriver).newInstance();
0: 		} catch (Exception e)
1: 		{
1: 			Logs.debug(e);
1: 			return false;
1: 		}
1: 
1: 		return true;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * extractDBNameFromUrl:
1: 	 * Given a database url, parse out the actual name
1: 	 * of the database.  This is required for creation
1: 	 * the DB2JJARS directory (the database name is part
1: 	 * of the path to the jar).
1: 	 * @param dbUrl The database url from which to extract the
1: 	 *  the database name.
1: 	 * @return the name of the database (including its
1: 	 *  path, if provided) that is referenced by the url.
1: 	 ****/
1: 
0: 	protected String extractDBNameFromUrl(String dbUrl) {
1: 
1: 		if (dbUrl == null)
1: 		// shouldn't happen; ignore it here, as an error
1: 		// will be thrown we try to connect.
1: 			return "";
1: 
1: 		int start = dbUrl.indexOf("jdbc:derby:");
1: 		if (start == -1)
1: 		// not a valid url; just ignore it (an error
1: 		// will be thrown when we try to connect).
1: 			return "";
1: 
0: 		start = dbUrl.indexOf("net://");
1: 		if (start == -1)
1: 		// standard url (jdbc:derby:<dbname>).  Database
0: 		// name starts right after "cloudscape:".  The "11" in
0: 		// the following line is the length of "cloudscape:".
0: 			start = dbUrl.indexOf("cloudscape:") + 11;
1: 		else
1: 		// Network Server url.  Database name starts right
1: 		// after next slash (":net://hostname:port/<dbname>).
0: 		// The "6" in the following line is the length of
0: 		// "net://".
0: 			start = dbUrl.indexOf("/", start+6) + 1;
1: 
1: 		int stop = -1;
1: 		if (dbUrl.charAt(start) == '"') {
1: 		// database name is quoted; end of the name is the
1: 		// closing quote.
1: 			start++;
1: 			stop = dbUrl.indexOf("\"", start);
1: 		}
1: 		else {
1: 		// Database name ends with the start of a list of connection	
1: 		// attributes.  This list can begin with either a colon
1: 		// or a semi-colon.
1: 			stop = dbUrl.indexOf(":", start);
1: 			if (stop != -1) {
1: 				if ((dbUrl.charAt(stop+1) == '/') ||
1: 						(dbUrl.charAt(stop+1) == '\\'))
1: 				// then this colon is part of the path (ex. "C:"),
1: 				// so ignore it.
1: 					stop = dbUrl.indexOf(":", stop+2);
1: 			}
1: 			int stop2 = dbUrl.length();
1: 			if (stop == -1)
1: 			// no colons; see if we can find a semi-colon.
1: 				stop = dbUrl.indexOf(";", start);
1: 			else
1: 				stop2 = dbUrl.indexOf(";", start);
1: 			stop = (stop <= stop2 ? stop : stop2);
1: 		}
1: 
1: 		if (stop == -1)
1: 		// we have a url that ends with database name (no
1: 		// other attributes appended).
1: 			stop = dbUrl.length();
1: 
1: 		return dbUrl.substring(start, stop);
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * extractTableNamesFromList:
1: 	 * Given an array of command line arguments containing
1: 	 * a list of table names beginning at start'th position,
1: 	 * read the list of table names and store them as
1: 	 * our target table list.  Names without quotes are
1: 	 * turned into ALL CAPS and then double quotes are
1: 	 * added; names whcih already have double quotes are
1: 	 * stored exactly as they are. NOTE: DB2 enforces
1: 	 * maximum of 30 tables, and ignores the rest; so
1: 	 * do we.
1: 	 * @param args Array of command line arguments.
1: 	 * @start Position of the start of the list of tables
1: 	 *  with the args array.
1: 	 * @return The position of the last table name in
1: 	 *  the list of table names.
1: 	 ****/
1: 
1: 	private int extractTableNamesFromList(String [] args,
1: 		int start)
1: 	{
1: 
1: 		int argIndex = start;
1: 		int count = 0;
0: 		tableList = new ArrayList();
1: 		while (argIndex < args.length) {
1: 
1: 			if (((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '-')) ||
1: 				(++count > DB2_MAX_NUMBER_OF_TABLES))
1: 			// we're done with the table list.
1: 				break;
1: 
1: 			if ((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '"'))
1: 			// it's quoted.
1: 				tableList.add(addQuotes(expandDoubleQuotes(
1: 					stripQuotes(args[argIndex++]))));
1: 			else
1: 			// not quoted, so make it all caps, then add
1: 			// quotes.
1: 				tableList.add(addQuotes(
1: 					expandDoubleQuotes(args[argIndex++].toUpperCase(
1: 					java.util.Locale.ENGLISH))));
1: 
1: 		}
1: 
1: 		if (tableList.size() == 0)
1: 			tableList = null;
1: 
1: 		return argIndex - 1;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * showVariables:
1: 	 * Echo primary variables to output, so user can see
1: 	 * what s/he specified.
1: 	 ****/
1: 
1: 	private void showVariables() {
1: 
1: 		if (ddlFileName != null) {
1: 			Logs.reportString("============================\n");
0: 			Logs.reportMessage("CSLOOK_FileCreation");
1: 			if (verbose)
0: 				writeVerboseOutput("CSLOOK_OutputLocation",
1: 					ddlFileName);
1: 		}
1: 
0: 		Logs.reportMessage("CSLOOK_Timestamp",
1: 			new Timestamp(System.currentTimeMillis()).toString());
0: 		Logs.reportMessage("CSLOOK_DBName", sourceDBName);
0: 		Logs.reportMessage("CSLOOK_DBUrl", sourceDBUrl);
1: 		if (tableList != null)
0: 			Logs.reportMessage("CSLOOK_TargetTables");
1: 		if (schemaParam != null)
0: 			Logs.reportMessage("CSLOOK_TargetSchema", stripQuotes(schemaParam));
1: 		Logs.reportString("appendLogs: " + appendLogs + "\n");
1: 		return;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * go:
1: 	 * Connect to the source database, prepare statements,
1: 	 * and load a list of table id-to-name mappings.  Then,
1: 	 * generate the DDL for the various objects in the
1: 	 * database by making calls to static methods of helper
1: 	 * classes (one helper class for each type of database
1: 	 * object).  If a particular object type should not be
1: 	 * generated (because of the user-specified command-
1: 	 * line), then we enforce that here.
1: 	 * @precondition all user-specified parameters have
1: 	 *  been loaded.
0: 	 * @param srcUrl The full url of the database, as obtained
0: 	 *  from parseArgs().
0: 	 * @param srcName The name of the database (as opposed to
0: 	 *  the URL), as obtained from parseArgs().  This is
0: 	 *  needed for locating any jar files that might'
0: 	 *  exist in the source database.
1: 	 * @return DDL for the source database has been
1: 	 *  generated and printed to output, subject to
1: 	 *  user-specified restrictions.
1: 	 * ****/
1: 
0: 	public void go(String srcUrl, String srcName)
1: 		throws Exception
1: 	{
1: 
1: 		try
1: 		{
1: 
1: 			// Connect to the database, prepare statements,
1: 			// and load id-to-name mappings.
0: 			this.conn = DriverManager.getConnection(srcUrl);
1: 			try {
0: 				prepForDump();
0: 			} catch (SQLException sqlE) {
1: 				Logs.debug(sqlE);
1: 				Logs.debug(Logs.unRollExceptions(sqlE), (String)null);
1: 				Logs.cleanup();
1: 				return;
1: 			}
0: 			catch (Exception e) {
1: 				Logs.debug(e);
1: 				Logs.cleanup();
1: 				return;
1: 			}
1: 
1: 			// Generate DDL.
1: 
1: 			// Start with schemas, since we might need them to
1: 			// exist for jars to load properly.
1: 			DB_Schema.doSchemas(this.conn,
1: 				(tableList != null) && (targetSchema == null));
1: 
1: 			if (tableList == null) {
1: 			// Don't do these if user just wants table-related objects.
0: 				DB_Jar.doJars(srcName, this.conn);
0: 				DB_StoredProcedure.doStoredProcedures(this.conn);
1: 			}
1: 
1: 			DB_Table.doTables(this.conn, tableIdToNameMap);
1: 			DB_Index.doIndexes(this.conn);
1: 			DB_Key.doKeys(this.conn);
1: 			DB_Check.doChecks(this.conn);
1: 
1: 			if (!skipViews)
1: 				DB_View.doViews(this.conn);
1: 
0: 			DB_Trigger.doTriggers(this.conn);
1: 
1: 			// That's it; we're done.
1: 			if (getColNameFromNumberQuery != null)
1: 				getColNameFromNumberQuery.close();
1: 			Logs.cleanup();
1: 
1: 		}
1: 		catch (SQLException sqlE)
1: 		{
1: 			Logs.debug(sqlE);
1: 			Logs.debug(Logs.unRollExceptions(sqlE), (String)null);
1: 			Logs.cleanup();
0: 			throw sqlE;
1: 		}
1: 		catch (Exception e)
1: 		{
1: 			Logs.debug(e);
1: 			Logs.cleanup();
0: 			throw e;
1: 		}
1: 		finally {
1: 		// Close our connection.
0: 			conn.commit();
0: 			conn.close();
1: 		}
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * prepForDump:
1: 	 * Prepare any useful statements (i.e. statements that
1: 	 * are required by more than one helper class) and load
1: 	 * the id-to-name mappings for the source database.
1: 	 ****/
1: 
1: 	private void prepForDump() throws Exception {
1: 
1: 		// We're only SELECTing throughout all of this, so no need
1: 		// to commit (plus, disabling commit makes it easier to
1: 		// have multiple ResultSets open on the same connection).
1: 		this.conn.setAutoCommit(false);
1: 
1: 		// Prepare statements.
1: 		getColNameFromNumberQuery = conn.prepareStatement(
1: 			"SELECT COLUMNNAME FROM SYS.SYSCOLUMNS WHERE " +
1: 			"REFERENCEID = ? AND COLUMNNUMBER = ?");
1: 
1: 		// Load list of user tables and table ids, for general use.
0: 		Statement stmt = conn.createStatement();
1: 		ResultSet rs = stmt.executeQuery("SELECT T.TABLEID, T.TABLENAME, " +
1: 				"S.SCHEMANAME FROM SYS.SYSTABLES T, SYS.SYSSCHEMAS S " + 
1: 				"WHERE T.TABLETYPE = 'T' AND T.SCHEMAID = S.SCHEMAID");
1: 
1: 		while (rs.next()) {
1: 			String tableName = addQuotes(expandDoubleQuotes(rs.getString(2)));
1: 			String schemaName = addQuotes(expandDoubleQuotes(rs.getString(3)));
1: 			tableIdToNameMap.put(rs.getString(1), 
1: 				schemaName + "." + tableName);
1: 		}
1: 
1: 		// Load schema id's and names.
1: 		rs = stmt.executeQuery("SELECT SCHEMAID, SCHEMANAME FROM " +
1: 			"SYS.SYSSCHEMAS");
1: 		while (rs.next()) {
1: 			schemaMap.put(rs.getString(1),
1: 				addQuotes(expandDoubleQuotes(rs.getString(2))));
1: 		}
1: 
1: 		stmt.close();
1: 
1: 		// Load default property values.
1: 		return;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * getColumnListFromDescription:
1: 	 * Takes string description of column numbers in the
1: 	 * form of "(2, 1, 3...)" and the id of the table
1: 	 * having those columns, and then returns a string
1: 	 * with the column numbers replaced by their actual
1: 	 * names ('2' is replaced with the 2nd column in the
1: 	 * table, '1' with the first column, etc.).
1: 	 * @param tableId the id of the table to which the column
1: 	 *   numbers should be applied.
1: 	 * @param description a string holding a list of column
1: 	 *  numbers, enclosed in parentheses and separated
1: 	 *  by commas.
1: 	 * @return a new string with the column numbers in
1: 	 *  'description' replaced by their column names;
1: 	 *  also, the parentheses have been stripped off.
1: 	 ****/
1: 
1: 	public static String getColumnListFromDescription(String tableId,
1: 		String description) throws SQLException
1: 	{
1: 
1: 		StringBuffer sb = new StringBuffer();
1: 		StringTokenizer tokenizer = new StringTokenizer(
1: 			description.substring(description.indexOf("(") + 1,
1: 				description.lastIndexOf(")")), " ,", true);
1: 
1: 		boolean firstCol = true;
1: 		while (tokenizer.hasMoreTokens()) {
1: 
1: 			String tok = tokenizer.nextToken().trim();
1: 			if (tok.equals(""))
1: 				continue;
1: 			else if (tok.equals(",")) {
1: 				firstCol = false;
1: 				continue;
1: 			}
1: 			try {
1: 				String colName = getColNameFromNumber(tableId,
0: 					(Integer.valueOf(tok)).intValue());
1: 				if (!firstCol)
1: 					sb.append(", ");
1: 				sb.append(colName);
1: 			} catch (NumberFormatException e) {
1: 			// not a number; could be "ASC" or "DESC" tag,
1: 			// which is okay; otherwise, something's wrong.
1: 				tok = tok.toUpperCase();
1: 				if (tok.equals("DESC") || tok.equals("ASC"))
1: 				// then this is okay; just add the token to result.
1: 					sb.append(" " + tok);
1: 				else
1: 				// shouldn't happen.
1: 					Logs.debug("INTERNAL ERROR: read a non-number (" +
1: 						tok + ") when a column number was expected:\n" +
1: 						description, (String)null);
1: 			}
1: 
1: 		}
1: 
1: 		return sb.toString();
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * getColNameFromNumber:
1: 	 * Takes a tableid and a column number colNum, and
1: 	 * returns the name of the colNum'th column in the
1: 	 * table with tableid.
1: 	 * @param tableid id of the table.
1: 	 * @param colNum number of the column for which we want
1: 	 *  the name.
1: 	 * @return The name of the colNum'th column in the
1: 	 *  table with tableid.
1: 	 ****/
1: 
1: 	public static String getColNameFromNumber(String tableId,
1: 		int colNum) throws SQLException
1: 	{
1: 
1: 		getColNameFromNumberQuery.setString(1, tableId);
1: 		getColNameFromNumberQuery.setInt(2, colNum);
1: 		ResultSet rs = getColNameFromNumberQuery.executeQuery();
1: 
1: 		if (!rs.next()) {
1: 		// shouldn't happen.
1: 			Logs.debug("INTERNAL ERROR: Failed column number " +
1: 				"lookup for table " + lookupTableId(tableId) +
1: 				", column " + colNum, (String)null);
1: 			rs.close();
1: 			return "";
1: 		}
1: 		else {
1: 			String colName = addQuotes(expandDoubleQuotes(rs.getString(1)));
1: 			rs.close();
1: 			return colName;
1: 		}
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * addQuotes:
1: 	 * Add quotes to the received object name, and return
1: 	 * the result.
1: 	 * @param name the name to which to add quotes.
1: 	 * @return the name with double quotes around it.
1: 	 ****/
1: 
1: 	public static String addQuotes(String name) {
1: 
1: 		if (name == null)
1: 			return null;
1: 
1: 		return "\"" + name + "\"";
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * stripQuotes:
1: 	 * Takes a name and, if the name is enclosed in
1: 	 * quotes, strips the quotes off.  This method
1: 	 * assumes that the received String either has no quotes,
1: 	 * or has a quote (double or single) as the very first
1: 	 * AND very last character.
1: 	 * @param quotedName a name with quotes as the first
1: 	 *  and last character, or else with no quotes at all.
1: 	 * @return quotedName, without the quotes.
1: 	 ****/
1: 
1: 	public static String stripQuotes(String quotedName) {
1: 
1: 		if (quotedName == null)
1: 			return null;
1: 
0: 		if ((quotedName.indexOf("\"") == -1) &&
0: 			(quotedName.indexOf("'") == -1))
1: 		// nothing to do.
1: 			return quotedName;
1: 
1: 		return quotedName.substring(1, quotedName.length() - 1);
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * isExcludedTable:
1: 	 * Takes a table name and determines whether or not
1: 	 * the DDL for objects related to that table should be
1: 	 * generated.
1: 	 * @param tableName name of the table to check.
1: 	 * @return true if 1) the user specified a table list
1: 	 *  and that list does NOT include the received name; or
1: 	 *  2) if the user specified a schema restriction and
1: 	 *  the received name does NOT have that schema; false
1: 	 *  otherwise.
1: 	 ****/
1: 
1: 	public static boolean isExcludedTable(String tableName) {
1: 
1: 		if (tableName == null)
1: 			return true;
1: 
1: 		int dot = tableName.indexOf(".");
1: 		if (dot != -1) {
1: 		// strip off the schema part of the name, and see if we're
1: 		// okay to use it.
1: 			if (isIgnorableSchema(tableName.substring(0, dot)))
1: 			// then we exclude this table.
1: 				return true;
1: 			tableName = tableName.substring(dot + 1,
1: 				tableName.length());
1: 		}
1: 
1: 		return ((tableList != null) && !tableList.contains(tableName));
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * Takes a schema name and determines whether or
1: 	 * not the DDL for objects with that schema should
1: 	 * be generated.
1: 	 * @param schemaName schema name to be checked.
1: 	 * @return true if 1) the user specified a target
1: 	 *  schema and that target is NOT the same as the
1: 	 *  received schema name, or 2) the schema is a
1: 	 *  system schema (SYS, SYSVISUAL, or SYSIBM);
1: 	 *  false otherwise;
1: 	 ****/
1: 
0:     public static final String[] ignorableSchemaNames = {
1:         "SYSIBM",
1:         "SYS",
1:         "SYSVISUAL",
1:         "SYSCAT",
1:         "SYSFUN",
1:         "SYSPROC",
1:         "SYSSTAT",
1:         "NULLID",
1:         "SYSCS_ADMIN",
1:         "SYSCS_DIAG",
1:         "SYSCS_UTIL",
1:         "SQLJ"};
1: 
1: 	public static boolean isIgnorableSchema(String schemaName) {
1: 
1: 		if ((targetSchema != null) && (!schemaName.equals(targetSchema)))
1: 			return true;
1: 
1: 		schemaName = stripQuotes(schemaName);
1: 
1:         boolean ret = false;
1: 
1:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
1:         {
1:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
1:                 break;
1:         }
1: 
1:         return(ret);
1: 	}
1: 
1: 	/* ************************************************
1: 	 * Takes a string and determines whether or not that
1: 	 * string makes reference to any of the table names
1: 	 * in the user-specified table list.
1: 	 * @param str The string in which to search for table names.
1: 	 * @return true if 1) the user didn't specify a
1: 	 *  target table list, or 2) the received string
1: 	 *  contains at least one of the table names in the
1: 	 *  user-specified target list; false otherwise.
1: 	 ****/
1: 
1: 	public static boolean stringContainsTargetTable(String str) {
1: 
1: 		if (str == null)
1: 		// if the string is null, it can't possibly contain
1: 		// any table names.
1: 			return false;
1: 
1: 		if (tableList == null)
1: 		// if we have no target tables, then default to true.
1: 			return true;
1: 
1: 		int strLen = str.length();
1: 		for (int i = 0; i < tableList.size(); i++) {
1: 
0: 			String tableName = (String)tableList.get(i);
1: 			tableName = expandDoubleQuotes(stripQuotes(tableName));
1: 			int nameLen = tableName.length();
1: 			String strCopy;
1: 			if (tableName.equals(tableName.toUpperCase(
1: 				java.util.Locale.ENGLISH)))
1: 			// case doesn't matter.
1: 				strCopy = str.toUpperCase();
1: 			else
1: 				strCopy = str;
1: 			int pos = strCopy.indexOf(tableName);
1: 			while (pos != -1) {
1: 
1: 				// If we found it, make sure it's really a match.
1: 				// First, see if it's part of another word.
1: 				if (!partOfWord(str, pos, nameLen, strLen)) {
1: 
1: 					// See if the match is in quotes--if so, then
1: 					// it should match the table name's case.
1: 					if ((pos >= 1) && (strCopy.charAt(pos-1) == '"') &&
1: 					  (pos + nameLen < strCopy.length()) &&
1: 					  (strCopy.charAt(pos+nameLen) == '"'))
1: 					{ // match is quoted; check it's case.
1: 						if (str.substring(pos,
1: 							pos + nameLen).equals(tableName))
1: 						// everything checks out.
1: 							return true;
1: 					}
1: 					else
1: 					// match isn't quoted, so we're okay as is.
1: 						return true;
1: 				}
1: 
1: 				pos = str.indexOf(tableName, pos + nameLen);
1: 
1: 			}
1: 		}
1: 
1: 		// If we get here, we didn't find it.
1: 		return false;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * partOfWord:
1: 	 * Returns true if the part of the string given by
1: 	 * str.substring(pos, pos + nameLen) is part of
1: 	 * another word.
1: 	 * @param str The string in which we're looking.
1: 	 * @param pos The position at which the substring in
1: 	 *  question begins.
1: 	 * @param nameLen the length of the substring in
1: 	 *  question.
1: 	 * @param strLen The length of the string in which
1: 	 *  we're looking.
1: 	 * @return true if the substring from pos to
1: 	 *  pos+nameLen is part of larger word (i.e.
1: 	 *  if it has a letter/digit immediately before
1: 	 *  or after); false otherwise.
1: 	 ****/
1: 
1: 	private static boolean partOfWord (String str,
1: 		int pos, int nameLen, int strLen)
1: 	{
1: 
1: 		boolean somethingBefore = false;
1: 		if (pos > 0) {
1: 			char c = str.charAt(pos-1);
1: 			somethingBefore = ((c == '_') ||
1: 				Character.isLetterOrDigit(c));
1: 		}
1: 
1: 		boolean somethingAfter = false;
1: 		if (pos + nameLen < strLen) {
1: 			char c = str.charAt(pos + nameLen);
1: 			somethingAfter = ((c == '_') ||
1: 				Character.isLetterOrDigit(c));
1: 		}
1: 
1: 		return (somethingBefore || somethingAfter);
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * expandDoubleQuotes:
1: 	 * If the received SQL id contains a quote, we have
1: 	 * to expand it into TWO quotes so that it can be
1: 	 * treated correctly at parse time.
1: 	 * @param name Id that we want to print.
1: 	 ****/
1: 
1: 	public static String expandDoubleQuotes(String name) {
1: 
1: 		if ((name == null) || (name.indexOf("\"") < 0))
1: 		// nothing to do.
1: 			return name;
1: 
1: 		char [] cA = name.toCharArray();
1: 
1: 		// Worst (and extremely unlikely) case is every 
1: 		// character is a double quote, which means the
1: 		// escaped string would need to be 2 times as long.
1: 		char [] result = new char[2*cA.length];
1: 
1: 		int j = 0;
1: 		for (int i = 0; i < cA.length; i++) {
1: 
1: 			if (cA[i] == '"') {
1: 				result[j++] = '"';
1: 				result[j++] = '"';
1: 			}
1: 			else
1: 				result[j++] = cA[i];
1: 
1: 		}
1: 
1: 		return new String(result, 0, j);
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * lookupSchemaId:
1: 	 * Return the schema name corresponding to the
1: 	 * received schema id.
1: 	 * @param schemaId The id to look up.
1: 	 * @return the schema name.
1: 	 ****/
1: 
1: 	public static String lookupSchemaId(String schemaId) {
1: 
0: 		return (String)(schemaMap.get(schemaId));
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * lookupTableId:
1: 	 * Return the table name corresponding to the
1: 	 * received table id.
1: 	 * @param tableId The id to look up.
1: 	 * @return the table name.
1: 	 ****/
1: 
1: 	public static String lookupTableId(String tableId) {
1: 
0: 		return (String)(tableIdToNameMap.get(tableId));
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * writeVerboseOutput:
1: 	 * Writes the received string as "verbose" output,
1: 	 * meaning that we write it to System.err.  We
1: 	 * choose System.err so that the string doesn't
1: 	 * show up if the user pipes dblook output to
1: 	 * a file (unless s/he explicitly pipes System.err
1: 	 * output to that file, as well).
1: 	 * @param key Key for the message to be printed as
1: 	 *  verbose output.
1: 	 * @param value Value to be substituted into the
1: 	 *  message.
1: 	 * @return message for received key has been printed
1: 	 *  to System.err.
1: 	 ****/
1: 
1: 	public static void writeVerboseOutput(String key,
1: 		String value) {
1: 
1: 		if (value == null)
1: 			System.err.println(lookupMessage(key));
1: 		else
1: 			System.err.println(lookupMessage(key,
1: 				new String [] {value}));
1: 		return;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * lookupMessage:
1: 	 * Retrieve a localized message.
1: 	 * @param key The key for the localized message.
1: 	 * @return the message corresponding to the received
1: 	 *  key.
1: 	 ****/
1: 
1: 	public static String lookupMessage(String key) {
1: 
1: 		return lookupMessage(key, null);
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * lookupMessage:
1: 	 * Retreive a localized message.
1: 	 * @param key The key for the localized message.
1: 	 * @param vals Array of values to be used in the
1: 	 *   message.
1: 	 * @return the message corresponding to the received
1: 	 *  key, with the received values substituted where
1: 	 *  appropriate.
1: 	 ****/
1: 
1: 	public static String lookupMessage(String key, String[] vals) {
1: 	
1: 		String msg = "";
1: 		if (vals == null)
1: 			msg = langUtil.getTextMessage(key);
1: 		else {
1: 			switch (vals.length) {
1: 				case 1: msg = langUtil.getTextMessage(
1: 							key, vals[0]);
1: 						break;
1: 				case 2: msg = langUtil.getTextMessage(
1: 							key, vals[0], vals[1]);
1: 						break;
1: 				default: /* shouldn't happen */
1: 						break;
1: 			}
1: 		}
1: 
1: 		return msg;
1: 
1: 	}
1: 
1: 	/* ************************************************
1: 	 * removeNewlines:
1: 	 * Remove any newline characters from the received
1: 	 * string (replace them with spaces).
1: 	 * @param str The string from which we are removing
1: 	 *  all newline characters.
1: 	 * @return The string, with all newline characters
1: 	 *  replaced with spaces.
1: 	 ****/
1: 
1: 	public static String removeNewlines(String str) {
1: 
1: 		if (str == null)
1: 		// don't do anything.
1: 			return null;
1: 
1: 		StringBuffer result = null;
1: 		try {
1: 
1: 			BufferedReader strVal = new BufferedReader (new StringReader(str));
1: 			for (String txt = strVal.readLine(); txt != null;
1: 				txt = strVal.readLine())
1: 			{
1: 				if (result == null)
1: 					result = new StringBuffer(txt);
1: 				else {
1: 					result.append(" ");
1: 					result.append(txt);
1: 				}
1: 			}
1: 
1: 			return result.toString();
1: 
1: 		} catch (Exception e) {
1: 		// if something went wrong, just return the string as is--
1: 		// worst case is that the generated DDL is correct, it just
0: 		// can't be run in a DB2 CLP script (because of the newline
1: 		// characters).
1: 			return str;
1: 		}
1: 
1: 	}
1: 
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
1: 			else if (sourceDBUrl.startsWith("jdbc:derby://"))
1: 			   derbyDriver = "org.apache.derby.jdbc.ClientDriver";
/////////////////////////////////////////////////////////////////////////
1: 		start = dbUrl.indexOf("://");
/////////////////////////////////////////////////////////////////////////
1: 		// The "3" in the following line is the length of
1: 		// "://".
1: 			start = dbUrl.indexOf("/", start+3) + 1;
/////////////////////////////////////////////////////////////////////////
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.tools
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.tools;
0: 
0: import java.io.BufferedReader;
0: import java.io.StringReader;
0: 
0: import java.sql.DriverManager;
0: import java.sql.ResultSet;
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Timestamp;
0: 
0: import java.util.HashMap;
0: import java.util.StringTokenizer;
0: import java.util.ArrayList;
0: 
0: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
0: 
0: import org.apache.derby.impl.tools.cslook.DB_Check;
0: import org.apache.derby.impl.tools.cslook.DB_Index;
0: import org.apache.derby.impl.tools.cslook.DB_Jar;
0: import org.apache.derby.impl.tools.cslook.DB_Key;
0: import org.apache.derby.impl.tools.cslook.DB_Table;
0: import org.apache.derby.impl.tools.cslook.DB_Schema;
0: import org.apache.derby.impl.tools.cslook.DB_StoredProcedure;
0: import org.apache.derby.impl.tools.cslook.DB_Trigger;
0: import org.apache.derby.impl.tools.cslook.DB_View;
0: import org.apache.derby.impl.tools.cslook.Logs;
0: 
0: public class dblook {
0: 
0: 	/* 
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 	// DB2 enforces a maximum of 30 tables to be specified as part of
0: 	// the table list.
0: 	public static final int DB2_MAX_NUMBER_OF_TABLES = 30;
0: 
0: 	private Connection conn;
0: 	private static PreparedStatement getColNameFromNumberQuery;
0: 
0: 	// Mappings from id to name for schemas and tables (for ease
0: 	// of reference).
0: 	protected static HashMap schemaMap;
0: 	protected static HashMap tableIdToNameMap;
0: 
0: 	// Command-line Parameters.
0: 	protected static String sourceDBUrl;
0: 	protected static String ddlFileName;
0: 	protected static String stmtDelimiter;
0: 	protected static boolean appendLogs;
0: 	protected static ArrayList tableList;
0: 	protected static String schemaParam;
0: 	protected static String targetSchema;
0: 	protected static boolean skipViews;
0: 	protected static boolean verbose;
0: 	private static String sourceDBName;
0: 
0: 	private static String lookLogName = "dblook.log";
0: 
0: 	private final static String DEFAULT_LOCALE= "en";
0: 	private final static String DEFAULT_LOCALE_COUNTRY="US";
0: 	private static LocalizedResource langUtil;
0: 
0: 	/* ************************************************
0: 	 * main:
0: 	 * Initialize program state by creating a dblook object,
0: 	 * and then start the DDL generation by calling "go".
0: 	 * ****/
0: 
0: 	public static void main(String[] args) {
0: 
0: 		dblook looker = new dblook(args);
0: 		try {
0: 			looker.go(sourceDBUrl, sourceDBName);
0: 		} catch (Exception e) {
0: 		// Errors are logged and printed to console according
0: 		// to command line arguments, so just ignore here.
0: 		}
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * Constructor:
0: 	 * Parse the command line, initialize logs, echo program variables,
0: 	 * and load the Cloudscape driver.
0: 	 * @param args args[0] is the database URL.  All other command-line
0: 	 *  parameters are read as system properties.
0: 	 * ****/
0: 
0: 	public dblook(String[] args) {
0: 
0:         // Adjust the application in accordance with derby.ui.locale
0: 		// and derby.ui.codeset
0: 		langUtil = LocalizedResource.getInstance();
0: 
0: 		// Initialize class variables.
0: 		initState();
0: 
0: 		// Parse the command line.
0: 		if (!parseArgs(args)) {
0: 			System.out.println(lookupMessage("CSLOOK_Usage"));
0: 			System.exit(1);
0: 		}
0: 
0: 		showVariables();
0: 
0: 		if (!loadDriver()) {
0: 		// Failed when loading the driver.  We already printed
0: 		// the exception, so just return.
0: 			return;
0: 		}
0: 
0: 		schemaMap = new HashMap();
0: 		tableIdToNameMap = new HashMap();
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * initState:
0: 	 * Initialize class variables.
0: 	 ****/
0: 
0: 	private void initState() {
0: 
0: 		sourceDBUrl = null;
0: 		ddlFileName = null;
0: 		stmtDelimiter = null;
0: 		appendLogs = false;
0: 		tableList = null;
0: 		targetSchema = null;
0: 		schemaParam = null;
0: 		skipViews = false;
0: 		verbose= false;
0: 		sourceDBName = null;
0: 		return;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * parseArgs:
0: 	 * Parse the command-line arguments.  There is only one
0: 	 * actual argument (database url); the rest of the parameters
0: 	 * are read in as System properties.
0: 	 * @param args args[0] is the url for the source database.
0: 	 * @return true if all parameters were loaded and the output
0: 	 *  files were successfully created; false otherwise.
0: 	 ****/
0: 
0: 	private boolean parseArgs(String[] args) {
0: 
0: 		if (args.length < 2)
0: 		// must have minimum of 2 args: "-d" and "<dbUrl>".
0: 			return false;
0: 
0: 		int st = 0;
0: 		for (int i = 0; i < args.length; i++) {
0: 			st = loadParam(args, i);
0: 			if (st == -1)
0: 				return false;
0: 			i = st;
0: 		}
0: 
0: 		if (sourceDBUrl == null) {
0: 		// must have at least a database url.
0: 			return false;	
0: 		}
0: 
0: 		// At this point, all parameters should have been read into
0: 		// their respective class variables.  Use those
0: 		// variables for some further processing.
0: 
0: 		// Setup logs.
0: 		boolean okay = Logs.initLogs(lookLogName, ddlFileName, appendLogs,
0: 		 	verbose, (stmtDelimiter == null ? ";" : stmtDelimiter));
0: 
0: 		// Get database name.
0: 		sourceDBName = extractDBNameFromUrl(sourceDBUrl);
0: 
0: 		// Set up schema restriction.
0: 		if ((schemaParam != null) && (schemaParam.length() > 0) &&
0: 			(schemaParam.charAt(0) != '"'))
0: 		// not quoted, so upper case, then add quotes.
0: 		{
0: 			targetSchema = addQuotes(expandDoubleQuotes(
0: 				schemaParam.toUpperCase(java.util.Locale.ENGLISH)));
0: 		}
0: 		else
0: 			targetSchema = addQuotes(expandDoubleQuotes(stripQuotes(schemaParam)));
0: 		return okay;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * loadParam:
0: 	 * Read in a flag and its corresponding values from
0: 	 * list of command line arguments, starting at
0: 	 * the start'th argument.
0: 	 * @return The position of the argument that was
0: 	 *  most recently processed.
0: 	 ****/
0: 
0: 	private int loadParam(String [] args, int start) {
0: 
0: 		if ((args[start].length() == 0) || args[start].charAt(0) != '-')
0: 		// starting argument should be a flag; if it's
0: 		// not, ignore it.
0: 			return start;
0: 
0: 		boolean haveVal = (args.length > start + 1);
0: 		switch (args[start].charAt(1)) {
0: 
0: 			case 'd':
0: 				if (!haveVal)
0: 					return -1;
0: 				if (args[start].length() == 2)
0: 					sourceDBUrl = args[++start];
0: 				return start;
0: 
0: 			case 'z':
0: 				if (!haveVal)
0: 					return -1;
0: 				if (args[start].length() == 2)
0: 					schemaParam = args[++start];
0: 				return start;
0: 
0: 			case 't':
0: 				if (!haveVal)
0: 					return -1;
0: 				if (args[start].equals("-td")) {
0: 					stmtDelimiter = args[++start];
0: 					return start;
0: 				}
0: 				else if (args[start].equals("-t"))
0: 				// list of tables.
0: 					return extractTableNamesFromList(args, start+1);
0: 				return -1;
0: 			case 'o':
0: 				if (!haveVal)
0: 					return -1;
0: 				if ((args[start].length() == 2) && (args[start+1].length() > 0))
0: 					ddlFileName = args[++start];
0: 				return start;
0: 
0: 			case 'a':
0: 				if (args[start].equals("-append")) {
0: 					appendLogs = true;
0: 					return start;
0: 				}
0: 				return -1;
0: 
0: 			case 'n':
0: 				if (args[start].equals("-noview")) {
0: 					skipViews = true;
0: 					return start;
0: 				}
0: 				return -1;
0: 
0: 			case 'v':
0: 				if (args[start].equals("-verbose")) {
0: 					verbose = true;
0: 					return start;
0: 				}
0: 				return -1;
0: 
0: 			default:
0: 				return -1;
0: 
0: 		}
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * loadDriver:
0: 	 * Load db2j driver.
0: 	 * @param precondition sourceDBUrl has been loaded.
0: 	 * @return false if anything goes wrong; true otherwise.
0: 	 ****/
0: 
0: 	private boolean loadDriver() {
0: 
0: 		String db2jDriver;
0: 		if (sourceDBUrl.indexOf(":net://") != -1)
0: 			db2jDriver = "com.ibm.db2.jcc.DB2Driver";
0: 		else
0: 			db2jDriver = "org.apache.derby.jdbc.EmbeddedDriver";
0: 		try {
0: 			Class.forName(db2jDriver).newInstance();
0: 		} catch (Exception e)
0: 		{
0: 			Logs.debug(e);
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * extractDBNameFromUrl:
0: 	 * Given a database url, parse out the actual name
0: 	 * of the database.  This is required for creation
0: 	 * the DB2JJARS directory (the database name is part
0: 	 * of the path to the jar).
0: 	 * @param dbUrl The database url from which to extract the
0: 	 *  the database name.
0: 	 * @return the name of the database (including its
0: 	 *  path, if provided) that is referenced by the url.
0: 	 ****/
0: 
0: 	protected String extractDBNameFromUrl(String dbUrl) {
0: 
0: 		if (dbUrl == null)
0: 		// shouldn't happen; ignore it here, as an error
0: 		// will be thrown we try to connect.
0: 			return "";
0: 
0: 		int start = dbUrl.indexOf("jdbc:derby:");
0: 		if (start == -1)
0: 		// not a valid url; just ignore it (an error
0: 		// will be thrown when we try to connect).
0: 			return "";
0: 
0: 		start = dbUrl.indexOf("net://");
0: 		if (start == -1)
0: 		// standard url (jdbc:derby:<dbname>).  Database
0: 		// name starts right after "cloudscape:".  The "11" in
0: 		// the following line is the length of "cloudscape:".
0: 			start = dbUrl.indexOf("cloudscape:") + 11;
0: 		else
0: 		// Network Server url.  Database name starts right
0: 		// after next slash (":net://hostname:port/<dbname>).
0: 		// The "6" in the following line is the length of
0: 		// "net://".
0: 			start = dbUrl.indexOf("/", start+6) + 1;
0: 
0: 		int stop = -1;
0: 		if (dbUrl.charAt(start) == '"') {
0: 		// database name is quoted; end of the name is the
0: 		// closing quote.
0: 			start++;
0: 			stop = dbUrl.indexOf("\"", start);
0: 		}
0: 		else {
0: 		// Database name ends with the start of a list of connection	
0: 		// attributes.  This list can begin with either a colon
0: 		// or a semi-colon.
0: 			stop = dbUrl.indexOf(":", start);
0: 			if (stop != -1) {
0: 				if ((dbUrl.charAt(stop+1) == '/') ||
0: 						(dbUrl.charAt(stop+1) == '\\'))
0: 				// then this colon is part of the path (ex. "C:"),
0: 				// so ignore it.
0: 					stop = dbUrl.indexOf(":", stop+2);
0: 			}
0: 			int stop2 = dbUrl.length();
0: 			if (stop == -1)
0: 			// no colons; see if we can find a semi-colon.
0: 				stop = dbUrl.indexOf(";", start);
0: 			else
0: 				stop2 = dbUrl.indexOf(";", start);
0: 			stop = (stop <= stop2 ? stop : stop2);
0: 		}
0: 
0: 		if (stop == -1)
0: 		// we have a url that ends with database name (no
0: 		// other attributes appended).
0: 			stop = dbUrl.length();
0: 
0: 		return dbUrl.substring(start, stop);
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * extractTableNamesFromList:
0: 	 * Given an array of command line arguments containing
0: 	 * a list of table names beginning at start'th position,
0: 	 * read the list of table names and store them as
0: 	 * our target table list.  Names without quotes are
0: 	 * turned into ALL CAPS and then double quotes are
0: 	 * added; names whcih already have double quotes are
0: 	 * stored exactly as they are. NOTE: DB2 enforces
0: 	 * maximum of 30 tables, and ignores the rest; so
0: 	 * do we.
0: 	 * @param args Array of command line arguments.
0: 	 * @start Position of the start of the list of tables
0: 	 *  with the args array.
0: 	 * @return The position of the last table name in
0: 	 *  the list of table names.
0: 	 ****/
0: 
0: 	private int extractTableNamesFromList(String [] args,
0: 		int start)
0: 	{
0: 
0: 		int argIndex = start;
0: 		int count = 0;
0: 		tableList = new ArrayList();
0: 		while (argIndex < args.length) {
0: 
0: 			if (((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '-')) ||
0: 				(++count > DB2_MAX_NUMBER_OF_TABLES))
0: 			// we're done with the table list.
0: 				break;
0: 
0: 			if ((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '"'))
0: 			// it's quoted.
0: 				tableList.add(addQuotes(expandDoubleQuotes(
0: 					stripQuotes(args[argIndex++]))));
0: 			else
0: 			// not quoted, so make it all caps, then add
0: 			// quotes.
0: 				tableList.add(addQuotes(
0: 					expandDoubleQuotes(args[argIndex++].toUpperCase(
0: 					java.util.Locale.ENGLISH))));
0: 
0: 		}
0: 
0: 		if (tableList.size() == 0)
0: 			tableList = null;
0: 
0: 		return argIndex - 1;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * showVariables:
0: 	 * Echo primary variables to output, so user can see
0: 	 * what s/he specified.
0: 	 ****/
0: 
0: 	private void showVariables() {
0: 
0: 		if (ddlFileName != null) {
0: 			Logs.reportString("============================\n");
0: 			Logs.reportMessage("CSLOOK_FileCreation");
0: 			if (verbose)
0: 				writeVerboseOutput("CSLOOK_OutputLocation",
0: 					ddlFileName);
0: 		}
0: 
0: 		Logs.reportMessage("CSLOOK_Timestamp",
0: 			new Timestamp(System.currentTimeMillis()).toString());
0: 		Logs.reportMessage("CSLOOK_DBName", sourceDBName);
0: 		Logs.reportMessage("CSLOOK_DBUrl", sourceDBUrl);
0: 		if (tableList != null)
0: 			Logs.reportMessage("CSLOOK_TargetTables");
0: 		if (schemaParam != null)
0: 			Logs.reportMessage("CSLOOK_TargetSchema", stripQuotes(schemaParam));
0: 		Logs.reportString("appendLogs: " + appendLogs + "\n");
0: 		return;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * go:
0: 	 * Connect to the source database, prepare statements,
0: 	 * and load a list of table id-to-name mappings.  Then,
0: 	 * generate the DDL for the various objects in the
0: 	 * database by making calls to static methods of helper
0: 	 * classes (one helper class for each type of database
0: 	 * object).  If a particular object type should not be
0: 	 * generated (because of the user-specified command-
0: 	 * line), then we enforce that here.
0: 	 * @precondition all user-specified parameters have
0: 	 *  been loaded.
0: 	 * @param srcUrl The full url of the database, as obtained
0: 	 *  from parseArgs().
0: 	 * @param srcName The name of the database (as opposed to
0: 	 *  the URL), as obtained from parseArgs().  This is
0: 	 *  needed for locating any jar files that might'
0: 	 *  exist in the source database.
0: 	 * @return DDL for the source database has been
0: 	 *  generated and printed to output, subject to
0: 	 *  user-specified restrictions.
0: 	 * ****/
0: 
0: 	public void go(String srcUrl, String srcName)
0: 		throws Exception
0: 	{
0: 
0: 		try
0: 		{
0: 
0: 			// Connect to the database, prepare statements,
0: 			// and load id-to-name mappings.
0: 			this.conn = DriverManager.getConnection(srcUrl);
0: 			try {
0: 				prepForDump();
0: 			} catch (SQLException sqlE) {
0: 				Logs.debug(sqlE);
0: 				Logs.debug(Logs.unRollExceptions(sqlE), (String)null);
0: 				Logs.cleanup();
0: 				return;
0: 			}
0: 			catch (Exception e) {
0: 				Logs.debug(e);
0: 				Logs.cleanup();
0: 				return;
0: 			}
0: 
0: 			// Generate DDL.
0: 
0: 			// Start with schemas, since we might need them to
0: 			// exist for jars to load properly.
0: 			DB_Schema.doSchemas(this.conn,
0: 				(tableList != null) && (targetSchema == null));
0: 
0: 			if (tableList == null) {
0: 			// Don't do these if user just wants table-related objects.
0: 				DB_Jar.doJars(srcName, this.conn);
0: 				DB_StoredProcedure.doStoredProcedures(this.conn);
0: 			}
0: 
0: 			DB_Table.doTables(this.conn, tableIdToNameMap);
0: 			DB_Index.doIndexes(this.conn);
0: 			DB_Key.doKeys(this.conn);
0: 			DB_Check.doChecks(this.conn);
0: 
0: 			if (!skipViews)
0: 				DB_View.doViews(this.conn);
0: 
0: 			DB_Trigger.doTriggers(this.conn);
0: 
0: 			// That's it; we're done.
0: 			if (getColNameFromNumberQuery != null)
0: 				getColNameFromNumberQuery.close();
0: 			Logs.cleanup();
0: 
0: 		}
0: 		catch (SQLException sqlE)
0: 		{
0: 			Logs.debug(sqlE);
0: 			Logs.debug(Logs.unRollExceptions(sqlE), (String)null);
0: 			Logs.cleanup();
0: 			throw sqlE;
0: 		}
0: 		catch (Exception e)
0: 		{
0: 			Logs.debug(e);
0: 			Logs.cleanup();
0: 			throw e;
0: 		}
0: 		finally {
0: 		// Close our connection.
0: 			conn.commit();
0: 			conn.close();
0: 		}
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * prepForDump:
0: 	 * Prepare any useful statements (i.e. statements that
0: 	 * are required by more than one helper class) and load
0: 	 * the id-to-name mappings for the source database.
0: 	 ****/
0: 
0: 	private void prepForDump() throws Exception {
0: 
0: 		// We're only SELECTing throughout all of this, so no need
0: 		// to commit (plus, disabling commit makes it easier to
0: 		// have multiple ResultSets open on the same connection).
0: 		this.conn.setAutoCommit(false);
0: 
0: 		// Prepare statements.
0: 		getColNameFromNumberQuery = conn.prepareStatement(
0: 			"SELECT COLUMNNAME FROM SYS.SYSCOLUMNS WHERE " +
0: 			"REFERENCEID = ? AND COLUMNNUMBER = ?");
0: 
0: 		// Load list of user tables and table ids, for general use.
0: 		Statement stmt = conn.createStatement();
0: 		ResultSet rs = stmt.executeQuery("SELECT T.TABLEID, T.TABLENAME, " +
0: 				"S.SCHEMANAME FROM SYS.SYSTABLES T, SYS.SYSSCHEMAS S " + 
0: 				"WHERE T.TABLETYPE = 'T' AND T.SCHEMAID = S.SCHEMAID");
0: 
0: 		while (rs.next()) {
0: 			String tableName = addQuotes(expandDoubleQuotes(rs.getString(2)));
0: 			String schemaName = addQuotes(expandDoubleQuotes(rs.getString(3)));
0: 			tableIdToNameMap.put(rs.getString(1), 
0: 				schemaName + "." + tableName);
0: 		}
0: 
0: 		// Load schema id's and names.
0: 		rs = stmt.executeQuery("SELECT SCHEMAID, SCHEMANAME FROM " +
0: 			"SYS.SYSSCHEMAS");
0: 		while (rs.next()) {
0: 			schemaMap.put(rs.getString(1),
0: 				addQuotes(expandDoubleQuotes(rs.getString(2))));
0: 		}
0: 
0: 		stmt.close();
0: 
0: 		// Load default property values.
0: 		return;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * getColumnListFromDescription:
0: 	 * Takes string description of column numbers in the
0: 	 * form of "(2, 1, 3...)" and the id of the table
0: 	 * having those columns, and then returns a string
0: 	 * with the column numbers replaced by their actual
0: 	 * names ('2' is replaced with the 2nd column in the
0: 	 * table, '1' with the first column, etc.).
0: 	 * @param tableId the id of the table to which the column
0: 	 *   numbers should be applied.
0: 	 * @param description a string holding a list of column
0: 	 *  numbers, enclosed in parentheses and separated
0: 	 *  by commas.
0: 	 * @return a new string with the column numbers in
0: 	 *  'description' replaced by their column names;
0: 	 *  also, the parentheses have been stripped off.
0: 	 ****/
0: 
0: 	public static String getColumnListFromDescription(String tableId,
0: 		String description) throws SQLException
0: 	{
0: 
0: 		StringBuffer sb = new StringBuffer();
0: 		StringTokenizer tokenizer = new StringTokenizer(
0: 			description.substring(description.indexOf("(") + 1,
0: 				description.lastIndexOf(")")), " ,", true);
0: 
0: 		boolean firstCol = true;
0: 		while (tokenizer.hasMoreTokens()) {
0: 
0: 			String tok = tokenizer.nextToken().trim();
0: 			if (tok.equals(""))
0: 				continue;
0: 			else if (tok.equals(",")) {
0: 				firstCol = false;
0: 				continue;
0: 			}
0: 			try {
0: 				String colName = getColNameFromNumber(tableId,
0: 					(Integer.valueOf(tok)).intValue());
0: 				if (!firstCol)
0: 					sb.append(", ");
0: 				sb.append(colName);
0: 			} catch (NumberFormatException e) {
0: 			// not a number; could be "ASC" or "DESC" tag,
0: 			// which is okay; otherwise, something's wrong.
0: 				tok = tok.toUpperCase();
0: 				if (tok.equals("DESC") || tok.equals("ASC"))
0: 				// then this is okay; just add the token to result.
0: 					sb.append(" " + tok);
0: 				else
0: 				// shouldn't happen.
0: 					Logs.debug("INTERNAL ERROR: read a non-number (" +
0: 						tok + ") when a column number was expected:\n" +
0: 						description, (String)null);
0: 			}
0: 
0: 		}
0: 
0: 		return sb.toString();
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * getColNameFromNumber:
0: 	 * Takes a tableid and a column number colNum, and
0: 	 * returns the name of the colNum'th column in the
0: 	 * table with tableid.
0: 	 * @param tableid id of the table.
0: 	 * @param colNum number of the column for which we want
0: 	 *  the name.
0: 	 * @return The name of the colNum'th column in the
0: 	 *  table with tableid.
0: 	 ****/
0: 
0: 	public static String getColNameFromNumber(String tableId,
0: 		int colNum) throws SQLException
0: 	{
0: 
0: 		getColNameFromNumberQuery.setString(1, tableId);
0: 		getColNameFromNumberQuery.setInt(2, colNum);
0: 		ResultSet rs = getColNameFromNumberQuery.executeQuery();
0: 
0: 		if (!rs.next()) {
0: 		// shouldn't happen.
0: 			Logs.debug("INTERNAL ERROR: Failed column number " +
0: 				"lookup for table " + lookupTableId(tableId) +
0: 				", column " + colNum, (String)null);
0: 			rs.close();
0: 			return "";
0: 		}
0: 		else {
0: 			String colName = addQuotes(expandDoubleQuotes(rs.getString(1)));
0: 			rs.close();
0: 			return colName;
0: 		}
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * addQuotes:
0: 	 * Add quotes to the received object name, and return
0: 	 * the result.
0: 	 * @param name the name to which to add quotes.
0: 	 * @return the name with double quotes around it.
0: 	 ****/
0: 
0: 	public static String addQuotes(String name) {
0: 
0: 		if (name == null)
0: 			return null;
0: 
0: 		return "\"" + name + "\"";
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * stripQuotes:
0: 	 * Takes a name and, if the name is enclosed in
0: 	 * quotes, strips the quotes off.  This method
0: 	 * assumes that the received String either has no quotes,
0: 	 * or has a quote (double or single) as the very first
0: 	 * AND very last character.
0: 	 * @param quotedName a name with quotes as the first
0: 	 *  and last character, or else with no quotes at all.
0: 	 * @return quotedName, without the quotes.
0: 	 ****/
0: 
0: 	public static String stripQuotes(String quotedName) {
0: 
0: 		if (quotedName == null)
0: 			return null;
0: 
0: 		if ((quotedName.indexOf("\"") == -1) &&
0: 			(quotedName.indexOf("'") == -1))
0: 		// nothing to do.
0: 			return quotedName;
0: 
0: 		return quotedName.substring(1, quotedName.length() - 1);
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * isExcludedTable:
0: 	 * Takes a table name and determines whether or not
0: 	 * the DDL for objects related to that table should be
0: 	 * generated.
0: 	 * @param tableName name of the table to check.
0: 	 * @return true if 1) the user specified a table list
0: 	 *  and that list does NOT include the received name; or
0: 	 *  2) if the user specified a schema restriction and
0: 	 *  the received name does NOT have that schema; false
0: 	 *  otherwise.
0: 	 ****/
0: 
0: 	public static boolean isExcludedTable(String tableName) {
0: 
0: 		if (tableName == null)
0: 			return true;
0: 
0: 		int dot = tableName.indexOf(".");
0: 		if (dot != -1) {
0: 		// strip off the schema part of the name, and see if we're
0: 		// okay to use it.
0: 			if (isIgnorableSchema(tableName.substring(0, dot)))
0: 			// then we exclude this table.
0: 				return true;
0: 			tableName = tableName.substring(dot + 1,
0: 				tableName.length());
0: 		}
0: 
0: 		return ((tableList != null) && !tableList.contains(tableName));
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * Takes a schema name and determines whether or
0: 	 * not the DDL for objects with that schema should
0: 	 * be generated.
0: 	 * @param schemaName schema name to be checked.
0: 	 * @return true if 1) the user specified a target
0: 	 *  schema and that target is NOT the same as the
0: 	 *  received schema name, or 2) the schema is a
0: 	 *  system schema (SYS, SYSVISUAL, or SYSIBM);
0: 	 *  false otherwise;
0: 	 ****/
0: 
0:     public static final String[] ignorableSchemaNames = {
0:         "SYSIBM",
0:         "SYS",
0:         "SYSVISUAL",
0:         "SYSCAT",
0:         "SYSFUN",
0:         "SYSPROC",
0:         "SYSSTAT",
0:         "NULLID",
0:         "SYSCS_ADMIN",
0:         "SYSCS_DIAG",
0:         "SYSCS_UTIL",
0:         "SQLJ"};
0: 
0: 	public static boolean isIgnorableSchema(String schemaName) {
0: 
0: 		if ((targetSchema != null) && (!schemaName.equals(targetSchema)))
0: 			return true;
0: 
0: 		schemaName = stripQuotes(schemaName);
0: 
0:         boolean ret = false;
0: 
0:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
0:         {
0:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
0:                 break;
0:         }
0: 
0:         return(ret);
0: 	}
0: 
0: 	/* ************************************************
0: 	 * Takes a string and determines whether or not that
0: 	 * string makes reference to any of the table names
0: 	 * in the user-specified table list.
0: 	 * @param str The string in which to search for table names.
0: 	 * @return true if 1) the user didn't specify a
0: 	 *  target table list, or 2) the received string
0: 	 *  contains at least one of the table names in the
0: 	 *  user-specified target list; false otherwise.
0: 	 ****/
0: 
0: 	public static boolean stringContainsTargetTable(String str) {
0: 
0: 		if (str == null)
0: 		// if the string is null, it can't possibly contain
0: 		// any table names.
0: 			return false;
0: 
0: 		if (tableList == null)
0: 		// if we have no target tables, then default to true.
0: 			return true;
0: 
0: 		int strLen = str.length();
0: 		for (int i = 0; i < tableList.size(); i++) {
0: 
0: 			String tableName = (String)tableList.get(i);
0: 			tableName = expandDoubleQuotes(stripQuotes(tableName));
0: 			int nameLen = tableName.length();
0: 			String strCopy;
0: 			if (tableName.equals(tableName.toUpperCase(
0: 				java.util.Locale.ENGLISH)))
0: 			// case doesn't matter.
0: 				strCopy = str.toUpperCase();
0: 			else
0: 				strCopy = str;
0: 			int pos = strCopy.indexOf(tableName);
0: 			while (pos != -1) {
0: 
0: 				// If we found it, make sure it's really a match.
0: 				// First, see if it's part of another word.
0: 				if (!partOfWord(str, pos, nameLen, strLen)) {
0: 
0: 					// See if the match is in quotes--if so, then
0: 					// it should match the table name's case.
0: 					if ((pos >= 1) && (strCopy.charAt(pos-1) == '"') &&
0: 					  (pos + nameLen < strCopy.length()) &&
0: 					  (strCopy.charAt(pos+nameLen) == '"'))
0: 					{ // match is quoted; check it's case.
0: 						if (str.substring(pos,
0: 							pos + nameLen).equals(tableName))
0: 						// everything checks out.
0: 							return true;
0: 					}
0: 					else
0: 					// match isn't quoted, so we're okay as is.
0: 						return true;
0: 				}
0: 
0: 				pos = str.indexOf(tableName, pos + nameLen);
0: 
0: 			}
0: 		}
0: 
0: 		// If we get here, we didn't find it.
0: 		return false;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * partOfWord:
0: 	 * Returns true if the part of the string given by
0: 	 * str.substring(pos, pos + nameLen) is part of
0: 	 * another word.
0: 	 * @param str The string in which we're looking.
0: 	 * @param pos The position at which the substring in
0: 	 *  question begins.
0: 	 * @param nameLen the length of the substring in
0: 	 *  question.
0: 	 * @param strLen The length of the string in which
0: 	 *  we're looking.
0: 	 * @return true if the substring from pos to
0: 	 *  pos+nameLen is part of larger word (i.e.
0: 	 *  if it has a letter/digit immediately before
0: 	 *  or after); false otherwise.
0: 	 ****/
0: 
0: 	private static boolean partOfWord (String str,
0: 		int pos, int nameLen, int strLen)
0: 	{
0: 
0: 		boolean somethingBefore = false;
0: 		if (pos > 0) {
0: 			char c = str.charAt(pos-1);
0: 			somethingBefore = ((c == '_') ||
0: 				Character.isLetterOrDigit(c));
0: 		}
0: 
0: 		boolean somethingAfter = false;
0: 		if (pos + nameLen < strLen) {
0: 			char c = str.charAt(pos + nameLen);
0: 			somethingAfter = ((c == '_') ||
0: 				Character.isLetterOrDigit(c));
0: 		}
0: 
0: 		return (somethingBefore || somethingAfter);
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * expandDoubleQuotes:
0: 	 * If the received SQL id contains a quote, we have
0: 	 * to expand it into TWO quotes so that it can be
0: 	 * treated correctly at parse time.
0: 	 * @param name Id that we want to print.
0: 	 ****/
0: 
0: 	public static String expandDoubleQuotes(String name) {
0: 
0: 		if ((name == null) || (name.indexOf("\"") < 0))
0: 		// nothing to do.
0: 			return name;
0: 
0: 		char [] cA = name.toCharArray();
0: 
0: 		// Worst (and extremely unlikely) case is every 
0: 		// character is a double quote, which means the
0: 		// escaped string would need to be 2 times as long.
0: 		char [] result = new char[2*cA.length];
0: 
0: 		int j = 0;
0: 		for (int i = 0; i < cA.length; i++) {
0: 
0: 			if (cA[i] == '"') {
0: 				result[j++] = '"';
0: 				result[j++] = '"';
0: 			}
0: 			else
0: 				result[j++] = cA[i];
0: 
0: 		}
0: 
0: 		return new String(result, 0, j);
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * lookupSchemaId:
0: 	 * Return the schema name corresponding to the
0: 	 * received schema id.
0: 	 * @param schemaId The id to look up.
0: 	 * @return the schema name.
0: 	 ****/
0: 
0: 	public static String lookupSchemaId(String schemaId) {
0: 
0: 		return (String)(schemaMap.get(schemaId));
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * lookupTableId:
0: 	 * Return the table name corresponding to the
0: 	 * received table id.
0: 	 * @param tableId The id to look up.
0: 	 * @return the table name.
0: 	 ****/
0: 
0: 	public static String lookupTableId(String tableId) {
0: 
0: 		return (String)(tableIdToNameMap.get(tableId));
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * writeVerboseOutput:
0: 	 * Writes the received string as "verbose" output,
0: 	 * meaning that we write it to System.err.  We
0: 	 * choose System.err so that the string doesn't
0: 	 * show up if the user pipes dblook output to
0: 	 * a file (unless s/he explicitly pipes System.err
0: 	 * output to that file, as well).
0: 	 * @param key Key for the message to be printed as
0: 	 *  verbose output.
0: 	 * @param value Value to be substituted into the
0: 	 *  message.
0: 	 * @return message for received key has been printed
0: 	 *  to System.err.
0: 	 ****/
0: 
0: 	public static void writeVerboseOutput(String key,
0: 		String value) {
0: 
0: 		if (value == null)
0: 			System.err.println(lookupMessage(key));
0: 		else
0: 			System.err.println(lookupMessage(key,
0: 				new String [] {value}));
0: 		return;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * lookupMessage:
0: 	 * Retrieve a localized message.
0: 	 * @param key The key for the localized message.
0: 	 * @return the message corresponding to the received
0: 	 *  key.
0: 	 ****/
0: 
0: 	public static String lookupMessage(String key) {
0: 
0: 		return lookupMessage(key, null);
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * lookupMessage:
0: 	 * Retreive a localized message.
0: 	 * @param key The key for the localized message.
0: 	 * @param vals Array of values to be used in the
0: 	 *   message.
0: 	 * @return the message corresponding to the received
0: 	 *  key, with the received values substituted where
0: 	 *  appropriate.
0: 	 ****/
0: 
0: 	public static String lookupMessage(String key, String[] vals) {
0: 	
0: 		String msg = "";
0: 		if (vals == null)
0: 			msg = langUtil.getTextMessage(key);
0: 		else {
0: 			switch (vals.length) {
0: 				case 1: msg = langUtil.getTextMessage(
0: 							key, vals[0]);
0: 						break;
0: 				case 2: msg = langUtil.getTextMessage(
0: 							key, vals[0], vals[1]);
0: 						break;
0: 				default: /* shouldn't happen */
0: 						break;
0: 			}
0: 		}
0: 
0: 		return msg;
0: 
0: 	}
0: 
0: 	/* ************************************************
0: 	 * removeNewlines:
0: 	 * Remove any newline characters from the received
0: 	 * string (replace them with spaces).
0: 	 * @param str The string from which we are removing
0: 	 *  all newline characters.
0: 	 * @return The string, with all newline characters
0: 	 *  replaced with spaces.
0: 	 ****/
0: 
0: 	public static String removeNewlines(String str) {
0: 
0: 		if (str == null)
0: 		// don't do anything.
0: 			return null;
0: 
0: 		StringBuffer result = null;
0: 		try {
0: 
0: 			BufferedReader strVal = new BufferedReader (new StringReader(str));
0: 			for (String txt = strVal.readLine(); txt != null;
0: 				txt = strVal.readLine())
0: 			{
0: 				if (result == null)
0: 					result = new StringBuffer(txt);
0: 				else {
0: 					result.append(" ");
0: 					result.append(txt);
0: 				}
0: 			}
0: 
0: 			return result.toString();
0: 
0: 		} catch (Exception e) {
0: 		// if something went wrong, just return the string as is--
0: 		// worst case is that the generated DDL is correct, it just
0: 		// can't be run in a DB2 CLP script (because of the newline
0: 		// characters).
0: 			return str;
0: 		}
0: 
0: 	}
0: 
0: }
0: 
============================================================================