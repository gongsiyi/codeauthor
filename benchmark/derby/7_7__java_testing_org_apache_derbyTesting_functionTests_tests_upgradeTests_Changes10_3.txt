1:cdda215: /*
1:cdda215: 
1:cdda215: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_3
1:cdda215: 
1:cdda215: Licensed to the Apache Software Foundation (ASF) under one or more
1:cdda215: contributor license agreements.  See the NOTICE file distributed with
1:cdda215: this work for additional information regarding copyright ownership.
1:cdda215: The ASF licenses this file to You under the Apache License, Version 2.0
1:cdda215: (the "License"); you may not use this file except in compliance with
1:cdda215: the License.  You may obtain a copy of the License at
1:cdda215: 
1:cdda215:    http://www.apache.org/licenses/LICENSE-2.0
1:cdda215: 
1:cdda215: Unless required by applicable law or agreed to in writing, software
1:cdda215: distributed under the License is distributed on an "AS IS" BASIS,
1:cdda215: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cdda215: See the License for the specific language governing permissions and
1:cdda215: limitations under the License.
1:cdda215: 
1:cdda215: */
1:cdda215: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:cdda215: 
1:cdda215: import java.sql.DatabaseMetaData;
1:daf5fa3: import java.sql.PreparedStatement;
1:cdda215: import java.sql.ResultSet;
1:cdda215: import java.sql.SQLException;
1:daf5fa3: import java.sql.Statement;
1:cdda215: import junit.framework.Test;
1:bbe895f: import org.apache.derbyTesting.functionTests.tests.jdbcapi.BlobStoredProcedureTest;
1:bbe895f: import org.apache.derbyTesting.functionTests.tests.jdbcapi.ClobStoredProcedureTest;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:927ad05: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:cdda215: 
1:cdda215: 
1:cdda215: /**
1:cdda215:  * Upgrade test cases for changes made in 10.3.
1:daf5fa3:  * If the old version is 10.3 or later then these tests
1:daf5fa3:  * will not be run.
1:daf5fa3: 
1:cdda215:  * <BR>
1:cdda215:  * 10.3 Upgrade issues
1:cdda215:  */
1:cdda215: public class Changes10_3 extends UpgradeChange {
1:cdda215: 
1:dc09534:     private static  final   String  UNKNOWN_PROCEDURE = "42Y03";
1:cdda215:    
1:bdd93c5:     /**
1:bbe895f:      * Return the suite of tests to test the changes made in 10.3.
1:bbe895f:      * @param phase an integer that indicates the current phase in
1:bbe895f:      *              the upgrade test.
1:bbe895f:      * @return the test suite created.
1:bdd93c5:      */   
1:bbe895f:     public static Test suite(int phase) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade changes for 10.3");
1:cdda215:         
1:cdda215:         suite.addTestSuite(Changes10_3.class);
1:cdda215:         
1:bbe895f:         //Add the tests for the Stored procedures related to the locator
1:bbe895f:         //implementation of the LOB related JDBC methods. This needs to be done
1:bbe895f:         //only during the hard(full) upgrade phase.
1:bbe895f:         if(phase == PH_HARD_UPGRADE) {
1:af9a439:             if (JDBC.vmSupportsJDBC3())
1:bdd93c5:             {
1:af9a439:                 //Tests for the Blob related locator StoredProcedures
1:af9a439:                 suite.addTestSuite(BlobStoredProcedureTest.class);
1:af9a439:                 //Tests for the Clob related locator StoredProcedures
1:af9a439:                 suite.addTestSuite(ClobStoredProcedureTest.class);
1:cdda215:             }
1:bdd93c5:         }
1:cdda215:         
1:fef20ca:         return new SupportFilesSetup((Test) suite);
1:bdd93c5:     }
1:cdda215: 
1:cdda215:     public Changes10_3(String name) {
1:cdda215:         super(name);
1:cdda215:     }
1:cdda215:     
1:cdda215:     /**
1:cdda215:      * Verify the compilation schema is nullable after upgrade to 10.3
1:cdda215:      * or later. (See DERBY-630)
1:cdda215:      * @throws SQLException
1:cdda215:      */
1:cdda215:     public void testCompilationSchema() throws SQLException
1:cdda215:     {        
1:cdda215:         switch (getPhase())
1:cdda215:         {
1:cdda215:             case PH_CREATE:
1:cdda215:             case PH_POST_SOFT_UPGRADE:
1:cdda215:                 // 10.0-10.2 inclusive had the system schema incorrect.
1:cdda215:                 if (!oldAtLeast(10, 3))
1:cdda215:                     return;
1:cdda215:                 break;
1:cdda215:         }
1:cdda215: 
1:cdda215:         DatabaseMetaData dmd = getConnection().getMetaData();
1:cdda215: 
1:cdda215:         ResultSet rs = dmd.getColumns(null, "SYS", "SYSSTATEMENTS", "COMPILATIONSCHEMAID");
1:cdda215:         rs.next();
1:cdda215:         assertEquals("SYS.SYSSTATEMENTS.COMPILATIONSCHEMAID IS_NULLABLE",
1:cdda215:                         "YES", rs.getString("IS_NULLABLE"));
1:cdda215:         rs.close();
1:cdda215: 
1:cdda215:         rs = dmd.getColumns(null, "SYS", "SYSVIEWS", "COMPILATIONSCHEMAID");
1:cdda215:         rs.next();
1:cdda215:         assertEquals("SYS.SYSVIEWS.COMPILATIONSCHEMAID IS_NULLABLE",
1:cdda215:                         "YES", rs.getString("IS_NULLABLE"));
1:cdda215:     }
1:daf5fa3:     /**
1:daf5fa3:      * In 10.3: We will write a LogRecord with a different format 
1:daf5fa3:      * that can also write negative values.
1:daf5fa3:      * 
1:daf5fa3:      * Verify here that a 10.2 Database does not malfunction from this and
1:daf5fa3:      * 10.2 Databases will work with the old LogRecord format.
1:daf5fa3:      */
1:daf5fa3:     public void testNegValueSupportedLogRecord()
1:daf5fa3:         throws SQLException
1:daf5fa3:     {
1:daf5fa3:         switch(getPhase()) {
1:daf5fa3:             case PH_CREATE: {
1:927ad05: 
1:daf5fa3:                 // This case is derived from OnlineCompressTest.test6.
1:daf5fa3:                 Statement s = createStatement();
1:daf5fa3:                 s.execute("create table case606(keycol int, indcol1 int,"+
1:0ba46a7:                     "indcol2 int, data1 char(24), data2 char(24), " +
1:0ba46a7:                     "data3 char(24)," +
1:daf5fa3:                     "data4 char(24), data5 char(24), data6 char(24),"+
1:daf5fa3:                     "data7 char(24), data8 char(24), data9 char(24)," + 
1:daf5fa3:                     "data10 char(24), inddec1 decimal(8), indcol3 int,"+
1:daf5fa3:                     "indcol4 int, data11 varchar(50))");
1:daf5fa3:                 s.close();
1:bdd93c5: 
1:daf5fa3:                 break;
1:daf5fa3:             }
1:0ba46a7: 
1:daf5fa3:             case PH_SOFT_UPGRADE:
1:0ba46a7:                 // in place compress was added in 10.1 release, don't check
1:0ba46a7:                 // upgrade of it from 10.0 release.
1:0ba46a7:                 if (!oldAtLeast(10, 1))
1:0ba46a7:                     return;
1:0ba46a7: 
1:daf5fa3:                 // Ensure that the old Log Record format is written
1:daf5fa3:                 // by Newer release without throwing any exceptions.
1:daf5fa3:                 checkDataToCase606(0, 2000);
1:daf5fa3:                 break;
1:0ba46a7: 
1:daf5fa3:             case PH_POST_SOFT_UPGRADE:
1:0ba46a7:                 // in place compress was added in 10.1 release, don't check
1:0ba46a7:                 // upgrade of it from 10.0 release.
1:0ba46a7:                 if (!oldAtLeast(10, 1))
1:0ba46a7:                     return;
1:0ba46a7: 
1:daf5fa3:                 // We are now back to Old release
1:daf5fa3:                 checkDataToCase606(0, 1000);
1:daf5fa3:                 break;
1:daf5fa3: 
1:daf5fa3:             case PH_HARD_UPGRADE:
1:0ba46a7:                 // in place compress was added in 10.1 release, don't check
1:0ba46a7:                 // upgrade of it from 10.0 release.
1:0ba46a7:                 if (!oldAtLeast(10, 1))
1:0ba46a7:                     return;
1:0ba46a7: 
1:daf5fa3:                 // Create the Derby606 bug scenario and test that
1:daf5fa3:                 // the error does not occur in Hard Upgrade
1:daf5fa3:                 checkDataToCase606(0, 94000);
1:daf5fa3: 
1:daf5fa3:                 break;
1:daf5fa3:         }
1:daf5fa3:     }
1:daf5fa3:     
1:daf5fa3:     private void checkDataToCase606(int start_value, int end_value)
1:daf5fa3:             throws SQLException {
1:95c67a5:         getConnection().setAutoCommit(false);
1:daf5fa3:         Statement s = createStatement();
1:daf5fa3:         PreparedStatement insert_stmt = prepareStatement("insert into case606 values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:daf5fa3:         char[] data_dt = new char[24];
1:daf5fa3:         char[] data_dt2 = new char[50];
1:daf5fa3:         for (int i = 0; i < data_dt.length; i++)
1:daf5fa3:             data_dt[i] = 'a';
1:daf5fa3:         for (int i = 0; i < data_dt2.length; i++)
1:daf5fa3:             data_dt2[i] = 'z';
1:daf5fa3:         String data1_str = new String(data_dt);
1:daf5fa3:         String data2_str = new String(data_dt2);
1:daf5fa3: 
1:daf5fa3:         for (int i = start_value; i < end_value; i++) {
1:daf5fa3:             insert_stmt.setInt(1, i); // keycol
1:daf5fa3:             insert_stmt.setInt(2, i * 10); // indcol1
1:daf5fa3:             insert_stmt.setInt(3, i * 100); // indcol2
1:daf5fa3:             insert_stmt.setString(4, data1_str); // data1_data
1:daf5fa3:             insert_stmt.setString(5, data1_str); // data2_data
1:daf5fa3:             insert_stmt.setString(6, data1_str); // data3_data
1:daf5fa3:             insert_stmt.setString(7, data1_str); // data4_data
1:daf5fa3:             insert_stmt.setString(8, data1_str); // data5_data
1:daf5fa3:             insert_stmt.setString(9, data1_str); // data6_data
1:daf5fa3:             insert_stmt.setString(10, data1_str); // data7_data
1:daf5fa3:             insert_stmt.setString(11, data1_str); // data8_data
1:daf5fa3:             insert_stmt.setString(12, data1_str); // data9_data
1:daf5fa3:             insert_stmt.setString(13, data1_str); // data10_data
1:daf5fa3:             insert_stmt.setInt(14, i * 20); // indcol3
1:daf5fa3:             insert_stmt.setInt(15, i * 200); // indcol4
1:daf5fa3:             insert_stmt.setInt(16, i * 50);
1:daf5fa3:             insert_stmt.setString(17, data2_str); // data11_data
1:daf5fa3: 
1:daf5fa3:             insert_stmt.execute();
1:daf5fa3:         }
1:daf5fa3:         insert_stmt.close();
1:daf5fa3:         commit();
1:daf5fa3: 
1:daf5fa3:         s.execute("delete from case606 where case606.keycol > 10000");
1:daf5fa3:         commit();
1:daf5fa3:         
1:daf5fa3:         String schema = getTestConfiguration().getUserName();
1:daf5fa3: 
1:daf5fa3:         s.execute(
1:daf5fa3:                 "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('"
1:daf5fa3:                  + schema + "', 'CASE606',1,1,1)");
1:daf5fa3:         s.close();
1:daf5fa3:         commit();
1:daf5fa3: 
1:daf5fa3:     }
1:0ba46a7: 
1:0ba46a7: 
1:bbe895f: 
1:bbe895f:     /**
1:fef20ca:      * Simple test to ensure new import/export procedures added in 10.3 
1:fef20ca:      * are working on hard upgrade to 10.3 from previous derby versions.
1:bbe895f:      */
1:fef20ca:     public void testImportExportLobsProcedures()
1:fef20ca:         throws SQLException
1:bdd93c5:     {
1:bbe895f:     
1:fef20ca:         switch(getPhase()) {
1:0ba46a7:         case PH_CREATE: {
1:0ba46a7:             Statement s = createStatement();
1:fef20ca:             s.execute("create table iet1(id int , content clob , pic blob)");
1:fef20ca:             s.executeUpdate("insert into iet1 values " + 
1:fef20ca:                             "(1, 'SQL Tips', cast(X'4231a2' as blob))");
1:0ba46a7:             s.close();
1:fef20ca:             commit();
1:0ba46a7:             break;
1:cdda215:         }
1:fef20ca:         case PH_SOFT_UPGRADE: {
1:fef20ca:             // new import export procedure should not be found 
1:fef20ca:             // on soft-upgrade.
2:fef20ca:             Statement s = createStatement();
1:fef20ca:             assertStatementError("42Y03", s, 
1:c8f894e:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE" +  
1:fef20ca:                 "(null , 'IET1' , 'iet1.del' , null, " + 
1:fef20ca:                 "null, null, 'iet1_lobs.dat')");
2:fef20ca:             s.close();
1:0ba46a7:             break;
1:0ba46a7:         }
1:0ba46a7:         case PH_POST_SOFT_UPGRADE: 
1:0ba46a7:             break;
1:fef20ca:         case PH_HARD_UPGRADE: {
1:fef20ca:             //  main file used to perform import/export.
1:fef20ca:             String fileName =  
1:fef20ca:                 (SupportFilesSetup.getReadWrite("iet1.del")).getPath();
1:fef20ca:             // external file name used to store lobs.
1:fef20ca:             String lobsFileName =
1:fef20ca:                 (SupportFilesSetup.getReadWrite("iet1_lobs.dat")).getPath();
1:927ad05: 
1:fef20ca:             Statement s = createStatement();
1:bbe895f: 
1:927ad05: 	    //DERBY-2925: need to delete existing files first.
1:927ad05:             SupportFilesSetup.deleteFile(fileName);
1:927ad05:             SupportFilesSetup.deleteFile(lobsFileName);
1:927ad05: 
1:fef20ca:             s.execute(
1:c8f894e:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE" +  
1:fef20ca:                 "(null , 'IET1' , '"  +  fileName  + 
1:fef20ca:                 "' , null, null, null, '" + lobsFileName + "')");
1:c8f894e:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE(" + 
1:fef20ca:                       "null, 'IET1' , '" + fileName + 
1:fef20ca:                       "', null, null, null, 0)");
1:927ad05: 
1:927ad05: 	    //DERBY-2925: need to delete existing files first.
1:927ad05:             SupportFilesSetup.deleteFile(fileName);
1:927ad05:             SupportFilesSetup.deleteFile(lobsFileName);
1:bbe895f: 
1:c8f894e:             s.execute("call SYSCS_UTIL.SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE(" +
1:fef20ca:                       "'select * from IET1', '" +  fileName + 
1:fef20ca:                       "' , null, null, null, '" + lobsFileName + "')");
1:c8f894e:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE(" + 
1:fef20ca:                       "null, 'IET1','ID, CONTENT, PIC', '1,2,3'," + 
1:fef20ca:                       "'" + fileName +"', null, null, null, 1)") ;
1:dc09534:             
1:fef20ca:             // verify table has correct data after performing import/export.
1:fef20ca:             ResultSet rs = s.executeQuery("select * from iet1");
1:fef20ca:             JDBC.assertFullResultSet(rs, new String[][]
1:fef20ca:                 {{"1", "SQL Tips", "4231a2"},
1:fef20ca:                  {"1", "SQL Tips", "4231a2"}});
1:fef20ca:             s.close();
1:bdd93c5:             break;
1:af9a439:         }
1:dc09534:         
1:bbe895f:         }
2:dc09534:     }
1:fef20ca: 
1:dc09534:     /**
1:dc09534:      * Ensure that the new policy-file-reloading procedure works after
1:dc09534:      * hard upgrade to 10.3 from previous derby versions.
1:dc09534:      */
1:dc09534:     public void testPolicyReloadingProcedure()
1:dc09534:         throws SQLException
1:bdd93c5:     {
1:dc09534:         int         currentPhase = getPhase();
1:dc09534:     
1:dc09534:         switch( currentPhase )
1:af9a439:         {
1:dc09534:             
1:dc09534:             case PH_CREATE:
1:0ba46a7:             case PH_SOFT_UPGRADE: 
1:dc09534:             case PH_POST_SOFT_UPGRADE: 
1:dc09534:                 assertPolicyReloaderDoesNotExist();
1:0ba46a7:                 break;
1:dc09534:                 
1:0ba46a7:             case PH_HARD_UPGRADE:
1:dc09534:                 assertPolicyReloaderExists();
2:dc09534:                 break;
1:dc09534:             
1:dc09534:             default:
1:dc09534:                 throw new SQLException( "Unknown upgrade phase: " + currentPhase );
1:dc09534:          
1:dc09534:         }
1:dc09534:     }
1:dc09534: 
1:dc09534:     /**
1:dc09534:      * Verify that the policy-reloading procedure exists.
1:dc09534:      */
1:dc09534:     private void assertPolicyReloaderExists()
1:dc09534:         throws SQLException
3:dc09534:     {
1:dc09534:         tryReloading( true, null );
1:dc09534:     }
1:dc09534:     
1:dc09534:     /**
1:dc09534:      * Verify whether the policy-reloading procedure exists.
1:dc09534:      */
1:dc09534:     private void assertPolicyReloaderDoesNotExist()
1:dc09534:         throws SQLException
1:dc09534:     {
1:dc09534:         tryReloading( false, UNKNOWN_PROCEDURE );
1:dc09534:     }
1:dc09534:     
1:dc09534:     /**
1:dc09534:      * Call the policy reloading procedure.
1:dc09534:      */
1:dc09534:     private void tryReloading( boolean shouldSucceed, String expectedSQLState )
1:dc09534:         throws SQLException
1:dc09534:     {
1:dc09534:         boolean didSucceed = false;
1:dc09534:         
2:bdd93c5:         try {
1:dc09534:             Statement s = createStatement();
1:dc09534:             s.execute("call SYSCS_UTIL.SYSCS_RELOAD_SECURITY_POLICY()");
1:dc09534: 
1:dc09534:             didSucceed = true;
1:bdd93c5:         }
1:dc09534:         catch (SQLException se)
1:dc09534:         {
1:dc09534:             assertSQLState( expectedSQLState, se );
1:bdd93c5:         }
1:dc09534: 
1:dc09534:         assertEquals( "Reloading results.", shouldSucceed, didSucceed );
1:dc09534:     }
1:bdd93c5: 
1:bdd93c5:     /**
1:bdd93c5:      * Check if we can open the heap.
1:bdd93c5:      * <p>
1:bdd93c5:      * This test just does a simple select to verify that 10.3 heap conglomerate
1:bdd93c5:      * format id's are working right for all the various upgrade scenarios.
1:bdd93c5:      **/
1:bdd93c5:     private void checkNewHeap(
1:bdd93c5:     String  tableName,
1:bdd93c5:     String  value)
1:bdd93c5:         throws SQLException
1:bdd93c5:     {
1:bdd93c5:         // verify table has correct data after performing import/export.
1:bdd93c5:         Statement s = createStatement();
1:bdd93c5:         ResultSet rs = s.executeQuery("select * from " + tableName);
1:bdd93c5:         JDBC.assertFullResultSet(rs, new String[][] {{value}});
1:bdd93c5:         s.close();
2:bdd93c5:         rs.close();
1:bdd93c5:     }
1:bdd93c5: 
1:bdd93c5:     /**
1:bdd93c5:      * Test that new format id for Heap is not used in soft upgrade.
1:bdd93c5:      **/
1:bdd93c5:     public void testNewHeap()
1:bdd93c5:         throws SQLException
1:bdd93c5:     {
1:bdd93c5:         // create tables in all 3 phases: boot old db, after 1st soft upgrade,
1:bdd93c5:         // and after hard upgrade.
1:bdd93c5:         switch (getPhase())
1:bdd93c5:         {
1:bdd93c5:             case PH_CREATE: 
1:bdd93c5:             {
1:bdd93c5:                 // setup create of testNewHeap1 in old db
1:bdd93c5: 
1:bdd93c5:                 Statement s = createStatement();
1:bdd93c5:                 s.execute("create table testNewHeap1(keycol char(20))");
1:bdd93c5:                 s.close();
1:bdd93c5:                 PreparedStatement insert_stmt = 
1:bdd93c5:                     prepareStatement("insert into testNewHeap1 values(?)");;
1:bdd93c5:                 insert_stmt.setString(1, "create"); 
1:bdd93c5:                 insert_stmt.execute();
1:bdd93c5:                 insert_stmt.close();
1:bdd93c5: 
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5: 
1:bdd93c5:             case PH_SOFT_UPGRADE:
1:bdd93c5:             {
1:bdd93c5:                 // setup create of testNewHeap2 once soft upgrade to current
1:bdd93c5:                 // version has happened.
1:bdd93c5: 
1:bdd93c5:                 Statement s = createStatement();
1:bdd93c5:                 s.execute("create table testNewHeap2(keycol char(20))");
1:bdd93c5:                 s.close();
1:bdd93c5:                 PreparedStatement insert_stmt = 
1:bdd93c5:                     prepareStatement("insert into testNewHeap2 values(?)");;
1:bdd93c5:                 insert_stmt.setString(1, "soft"); 
1:bdd93c5:                 insert_stmt.execute();
1:bdd93c5:                 insert_stmt.close();
1:bdd93c5: 
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5: 
1:bdd93c5:             case PH_HARD_UPGRADE:
1:bdd93c5:             {
1:bdd93c5:                 // setup create of testNewHeap3 once hard upgrade to current
1:bdd93c5:                 // version has happened.
1:bdd93c5: 
1:bdd93c5:                 Statement s = createStatement();
1:bdd93c5:                 s.execute("create table testNewHeap3(keycol char(20))");
1:bdd93c5:                 s.close();
1:bdd93c5:                 PreparedStatement insert_stmt = 
1:bdd93c5:                     prepareStatement("insert into testNewHeap3 values(?)");
1:bdd93c5:                 insert_stmt.setString(1, "hard"); 
1:bdd93c5:                 insert_stmt.execute();
1:bdd93c5:                 insert_stmt.close();
1:bdd93c5: 
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5:         }
1:bdd93c5: 
1:bdd93c5:         // Now verify you can access the tables 
1:bdd93c5:         switch (getPhase())
1:bdd93c5:         {
1:bdd93c5:             case PH_CREATE: 
1:bdd93c5:             {
2:bdd93c5:                 checkNewHeap("testNewHeap1", "create");
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5:             case PH_SOFT_UPGRADE:
1:bdd93c5:             {
1:bdd93c5:                 checkNewHeap("testNewHeap1", "create");
2:bdd93c5:                 checkNewHeap("testNewHeap2", "soft");
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5:             case PH_POST_SOFT_UPGRADE:
1:bdd93c5:             {
1:bdd93c5:                 checkNewHeap("testNewHeap1", "create");
1:bdd93c5:                 checkNewHeap("testNewHeap2", "soft");
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5:             case PH_HARD_UPGRADE:
1:bdd93c5:             {
1:bdd93c5:                 checkNewHeap("testNewHeap1", "create");
1:bdd93c5:                 checkNewHeap("testNewHeap2", "soft");
2:bdd93c5:                 checkNewHeap("testNewHeap3", "hard");
1:bdd93c5:                 break;
1:bdd93c5:             }
1:bdd93c5:         }
1:bdd93c5: 
1:bdd93c5:     }
1:bdd93c5:     
1:bdd93c5: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade changes for 10.3");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:42aa1d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:95c67a5
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
commit:daf5fa3
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.Statement;
1:  * If the old version is 10.3 or later then these tests
1:  * will not be run.
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * In 10.3: We will write a LogRecord with a different format 
1:      * that can also write negative values.
1:      * 
1:      * Verify here that a 10.2 Database does not malfunction from this and
1:      * 10.2 Databases will work with the old LogRecord format.
1:      */
1:     public void testNegValueSupportedLogRecord()
1:         throws SQLException
1:     {
1:         switch(getPhase()) {
1:         case PH_CREATE: {
1:             // This case is derived from OnlineCompressTest.test6.
1:             Statement s = createStatement();
1:             s.execute("create table case606(keycol int, indcol1 int,"+
0:                 "indcol2 int, data1 char(24), data2 char(24), data3 char(24)," +
1:                 "data4 char(24), data5 char(24), data6 char(24),"+
1:                 "data7 char(24), data8 char(24), data9 char(24)," + 
1:                 "data10 char(24), inddec1 decimal(8), indcol3 int,"+
1:                 "indcol4 int, data11 varchar(50))");
1:             s.close();
1:             break;
1:         }
1:         case PH_SOFT_UPGRADE:
1:             // Ensure that the old Log Record format is written
1:             // by Newer release without throwing any exceptions.
1:             checkDataToCase606(0, 2000);
1:             break;
1:         case PH_POST_SOFT_UPGRADE:
1:             // We are now back to Old release
1:             checkDataToCase606(0, 1000);
1:             break;
1: 
1:         case PH_HARD_UPGRADE:
1:             // Create the Derby606 bug scenario and test that
1:             // the error does not occur in Hard Upgrade
1:             checkDataToCase606(0, 94000);
1: 
1:             break;
1:         }
1:     }
1:     
1:     private void checkDataToCase606(int start_value, int end_value)
1:             throws SQLException {
1:         Statement s = createStatement();
1:         PreparedStatement insert_stmt = prepareStatement("insert into case606 values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:         char[] data_dt = new char[24];
1:         char[] data_dt2 = new char[50];
1:         for (int i = 0; i < data_dt.length; i++)
1:             data_dt[i] = 'a';
1:         for (int i = 0; i < data_dt2.length; i++)
1:             data_dt2[i] = 'z';
1:         String data1_str = new String(data_dt);
1:         String data2_str = new String(data_dt2);
1: 
1:         for (int i = start_value; i < end_value; i++) {
1:             insert_stmt.setInt(1, i); // keycol
1:             insert_stmt.setInt(2, i * 10); // indcol1
1:             insert_stmt.setInt(3, i * 100); // indcol2
1:             insert_stmt.setString(4, data1_str); // data1_data
1:             insert_stmt.setString(5, data1_str); // data2_data
1:             insert_stmt.setString(6, data1_str); // data3_data
1:             insert_stmt.setString(7, data1_str); // data4_data
1:             insert_stmt.setString(8, data1_str); // data5_data
1:             insert_stmt.setString(9, data1_str); // data6_data
1:             insert_stmt.setString(10, data1_str); // data7_data
1:             insert_stmt.setString(11, data1_str); // data8_data
1:             insert_stmt.setString(12, data1_str); // data9_data
1:             insert_stmt.setString(13, data1_str); // data10_data
1:             insert_stmt.setInt(14, i * 20); // indcol3
1:             insert_stmt.setInt(15, i * 200); // indcol4
1:             insert_stmt.setInt(16, i * 50);
1:             insert_stmt.setString(17, data2_str); // data11_data
1: 
1:             insert_stmt.execute();
1:         }
1:         insert_stmt.close();
1:         commit();
1: 
1:         s.execute("delete from case606 where case606.keycol > 10000");
1:         commit();
1:         
1:         String schema = getTestConfiguration().getUserName();
1: 
1:         s.execute(
1:                 "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('"
1:                  + schema + "', 'CASE606',1,1,1)");
1:         s.close();
1:         commit();
1: 
1:     }
commit:cdda215
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_3
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
1: import java.sql.DatabaseMetaData;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Upgrade test cases for changes made in 10.3.
1:  * <BR>
1:  * 10.3 Upgrade issues
1:  */
1: public class Changes10_3 extends UpgradeChange {
1:     
0:     public static Test suite() {
0:         TestSuite suite = new TestSuite("Upgrade changes for 10.3");
1:         
1:         suite.addTestSuite(Changes10_3.class);
1:         
0:         return suite;
1:     }
1: 
1:     public Changes10_3(String name) {
1:         super(name);
1:     }
1:     
1: 
1:     
1:     /**
1:      * Verify the compilation schema is nullable after upgrade to 10.3
1:      * or later. (See DERBY-630)
1:      * @throws SQLException
1:      */
1:     public void testCompilationSchema() throws SQLException
1:     {        
1:        switch (getPhase())
1:         {
1:             case PH_CREATE:
1:             case PH_POST_SOFT_UPGRADE:
0:             case PH_POST_HARD_UPGRADE:
1:                 // 10.0-10.2 inclusive had the system schema incorrect.
1:                 if (!oldAtLeast(10, 3))
1:                     return;
1:                 break;
1:         }
1: 
1:         DatabaseMetaData dmd = getConnection().getMetaData();
1: 
1:         ResultSet rs = dmd.getColumns(null, "SYS", "SYSSTATEMENTS", "COMPILATIONSCHEMAID");
1:         rs.next();
1:         assertEquals("SYS.SYSSTATEMENTS.COMPILATIONSCHEMAID IS_NULLABLE",
1:                         "YES", rs.getString("IS_NULLABLE"));
1:         rs.close();
1: 
1:         rs = dmd.getColumns(null, "SYS", "SYSVIEWS", "COMPILATIONSCHEMAID");
1:         rs.next();
1:         assertEquals("SYS.SYSVIEWS.COMPILATIONSCHEMAID IS_NULLABLE",
1:                         "YES", rs.getString("IS_NULLABLE"));
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:927ad05
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	    //DERBY-2925: need to delete existing files first.
1:             SupportFilesSetup.deleteFile(fileName);
1:             SupportFilesSetup.deleteFile(lobsFileName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	    //DERBY-2925: need to delete existing files first.
1:             SupportFilesSetup.deleteFile(fileName);
1:             SupportFilesSetup.deleteFile(lobsFileName);
1: 
commit:db85ee3
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bdd93c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBCDataSource;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Make sure table created in soft upgrade mode can be 
0:      * accessed after shutdown.  DERBY-2931
0:      * @throws SQLException
1:      */
0:     public void testCreateTable() throws SQLException
1:     {
1:         
0:         Statement stmt = createStatement();
1:         try {
0:             stmt.executeUpdate("DROP table t");
0:         } catch (SQLException se) {
0:             // ignore table does not exist error on
0:             // on drop table.
0:             assertSQLState("42Y55",se ); 
1:         }
0:         stmt.executeUpdate("CREATE TABLE T (I INT)");
0:         TestConfiguration.getCurrent().shutdownDatabase();
0:         stmt = createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT * from t");
0:         JDBC.assertEmpty(rs);  
1:         rs.close();
1:     }
0:     public void testIndex() throws SQLException 
1:     {
0:         Statement stmt = createStatement();
1:         try {
0:             stmt.executeUpdate("DROP table ti");
0:         } catch (SQLException se) {
0:             // ignore table does not exist error on
0:             // on drop table.
0:             assertSQLState("42Y55",se ); 
1:         }
0:         stmt.executeUpdate("CREATE TABLE TI (I INT primary key not null)");
0:         stmt.executeUpdate("INSERT INTO  TI values(1)");
0:         stmt.executeUpdate("INSERT INTO  TI values(2)");
0:         stmt.executeUpdate("INSERT INTO  TI values(3)");
0:         TestConfiguration.getCurrent().shutdownDatabase();
0:         stmt = createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT * from TI ORDER BY I");
0:         JDBC.assertFullResultSet(rs, new String[][] {{"1"},{"2"},{"3"}});
1:         rs.close();        
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check if we can open the heap.
1:      * <p>
1:      * This test just does a simple select to verify that 10.3 heap conglomerate
1:      * format id's are working right for all the various upgrade scenarios.
1:      **/
1:     private void checkNewHeap(
1:     String  tableName,
1:     String  value)
1:         throws SQLException
1:     {
1:         // verify table has correct data after performing import/export.
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery("select * from " + tableName);
1:         JDBC.assertFullResultSet(rs, new String[][] {{value}});
1:         s.close();
0:         rs.close();
1:     }
1: 
1:     /**
1:      * Test that new format id for Heap is not used in soft upgrade.
1:      **/
1:     public void testNewHeap()
1:         throws SQLException
1:     {
1:         // create tables in all 3 phases: boot old db, after 1st soft upgrade,
1:         // and after hard upgrade.
1:         switch (getPhase())
1:         {
1:             case PH_CREATE: 
1:             {
1:                 // setup create of testNewHeap1 in old db
1: 
1:                 Statement s = createStatement();
1:                 s.execute("create table testNewHeap1(keycol char(20))");
1:                 s.close();
1:                 PreparedStatement insert_stmt = 
1:                     prepareStatement("insert into testNewHeap1 values(?)");;
1:                 insert_stmt.setString(1, "create"); 
1:                 insert_stmt.execute();
1:                 insert_stmt.close();
1: 
1:                 break;
1:             }
1: 
1:             case PH_SOFT_UPGRADE:
1:             {
1:                 // setup create of testNewHeap2 once soft upgrade to current
1:                 // version has happened.
1: 
1:                 Statement s = createStatement();
1:                 s.execute("create table testNewHeap2(keycol char(20))");
1:                 s.close();
1:                 PreparedStatement insert_stmt = 
1:                     prepareStatement("insert into testNewHeap2 values(?)");;
1:                 insert_stmt.setString(1, "soft"); 
1:                 insert_stmt.execute();
1:                 insert_stmt.close();
1: 
1:                 break;
1:             }
1: 
1:             case PH_HARD_UPGRADE:
1:             {
1:                 // setup create of testNewHeap3 once hard upgrade to current
1:                 // version has happened.
1: 
1:                 Statement s = createStatement();
1:                 s.execute("create table testNewHeap3(keycol char(20))");
1:                 s.close();
1:                 PreparedStatement insert_stmt = 
1:                     prepareStatement("insert into testNewHeap3 values(?)");
1:                 insert_stmt.setString(1, "hard"); 
1:                 insert_stmt.execute();
1:                 insert_stmt.close();
1: 
1:                 break;
1:             }
1:         }
1: 
1:         // Now verify you can access the tables 
1:         switch (getPhase())
1:         {
1:             case PH_CREATE: 
1:             {
1:                 checkNewHeap("testNewHeap1", "create");
1:                 break;
1:             }
1:             case PH_SOFT_UPGRADE:
1:             {
1:                 checkNewHeap("testNewHeap1", "create");
1:                 checkNewHeap("testNewHeap2", "soft");
1:                 break;
1:             }
1:             case PH_POST_SOFT_UPGRADE:
1:             {
1:                 checkNewHeap("testNewHeap1", "create");
1:                 checkNewHeap("testNewHeap2", "soft");
1:                 break;
1:             }
1:             case PH_HARD_UPGRADE:
1:             {
1:                 checkNewHeap("testNewHeap1", "create");
1:                 checkNewHeap("testNewHeap2", "soft");
1:                 checkNewHeap("testNewHeap3", "hard");
1:                 break;
1:             }
1: 
0:             case PH_POST_HARD_UPGRADE:
1:             {
1:                 checkNewHeap("testNewHeap1", "create");
1:                 checkNewHeap("testNewHeap2", "soft");
1:                 checkNewHeap("testNewHeap3", "hard");
1:                 break;
1:             }
1:         }
1: 
1:     }
commit:0ba46a7
/////////////////////////////////////////////////////////////////////////
0:         switch (getPhase())
/////////////////////////////////////////////////////////////////////////
1:             case PH_CREATE: {
0:                 // This case is derived from OnlineCompressTest.test6.
1:                 Statement s = createStatement();
0:                 s.execute("create table case606(keycol int, indcol1 int,"+
1:                     "indcol2 int, data1 char(24), data2 char(24), " +
1:                     "data3 char(24)," +
0:                     "data4 char(24), data5 char(24), data6 char(24),"+
0:                     "data7 char(24), data8 char(24), data9 char(24)," + 
0:                     "data10 char(24), inddec1 decimal(8), indcol3 int,"+
0:                     "indcol4 int, data11 varchar(50))");
1:                 s.close();
1:                 break;
1:             }
1: 
1:             case PH_SOFT_UPGRADE:
1:                 // in place compress was added in 10.1 release, don't check
1:                 // upgrade of it from 10.0 release.
1:                 if (!oldAtLeast(10, 1))
1:                     return;
1: 
0:                 // Ensure that the old Log Record format is written
0:                 // by Newer release without throwing any exceptions.
0:                 checkDataToCase606(0, 2000);
1:                 break;
1: 
1:             case PH_POST_SOFT_UPGRADE:
1:                 // in place compress was added in 10.1 release, don't check
1:                 // upgrade of it from 10.0 release.
1:                 if (!oldAtLeast(10, 1))
1:                     return;
1: 
0:                 // We are now back to Old release
0:                 checkDataToCase606(0, 1000);
1:                 break;
1: 
1:             case PH_HARD_UPGRADE:
1:                 // in place compress was added in 10.1 release, don't check
1:                 // upgrade of it from 10.0 release.
1:                 if (!oldAtLeast(10, 1))
1:                     return;
1: 
0:                 // Create the Derby606 bug scenario and test that
0:                 // the error does not occur in Hard Upgrade
0:                 checkDataToCase606(0, 94000);
1: 
1:                 break;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:af9a439
/////////////////////////////////////////////////////////////////////////
1:             if (JDBC.vmSupportsJDBC3())
1:             {
1:                 //Tests for the Blob related locator StoredProcedures
1:                 suite.addTestSuite(BlobStoredProcedureTest.class);
1:                 //Tests for the Clob related locator StoredProcedures
1:                 suite.addTestSuite(ClobStoredProcedureTest.class);
1:             }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:bbe895f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.BlobStoredProcedureTest;
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.ClobStoredProcedureTest;
1: 
/////////////////////////////////////////////////////////////////////////
1:    
1:     /**
1:      * Return the suite of tests to test the changes made in 10.3.
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
1:      */   
1:     public static Test suite(int phase) {
1:         
1:         //Add the tests for the Stored procedures related to the locator
1:         //implementation of the LOB related JDBC methods. This needs to be done
1:         //only during the hard(full) upgrade phase.
1:         if(phase == PH_HARD_UPGRADE) {
0:             //Tests for the Blob related locator StoredProcedures
0:             suite.addTestSuite(BlobStoredProcedureTest.class);
0:             //Tests for the Clob related locator StoredProcedures
0:             suite.addTestSuite(ClobStoredProcedureTest.class);
1:         }
1:         
commit:dc09534
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  UNKNOWN_PROCEDURE = "42Y03";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Ensure that the new policy-file-reloading procedure works after
1:      * hard upgrade to 10.3 from previous derby versions.
1:      */
1:     public void testPolicyReloadingProcedure()
1:         throws SQLException
1:     {
1:         int         currentPhase = getPhase();
1:     
1:         switch( currentPhase )
1:         {
1:             
1:             case PH_CREATE:
0:             case PH_SOFT_UPGRADE: 
1:             case PH_POST_SOFT_UPGRADE: 
1:                 assertPolicyReloaderDoesNotExist();
1:                 break;
1:                 
0:             case PH_HARD_UPGRADE:
0:             case PH_POST_HARD_UPGRADE:
1:                 assertPolicyReloaderExists();
1:                 break;
1:             
1:             default:
1:                 throw new SQLException( "Unknown upgrade phase: " + currentPhase );
1:          
1:         }
1:     }
1: 
1:     /**
1:      * Verify that the policy-reloading procedure exists.
1:      */
1:     private void assertPolicyReloaderExists()
1:         throws SQLException
1:     {
1:         tryReloading( true, null );
1:     }
1:     
1:     /**
1:      * Verify whether the policy-reloading procedure exists.
1:      */
1:     private void assertPolicyReloaderDoesNotExist()
1:         throws SQLException
1:     {
1:         tryReloading( false, UNKNOWN_PROCEDURE );
1:     }
1:     
1:     /**
1:      * Call the policy reloading procedure.
1:      */
1:     private void tryReloading( boolean shouldSucceed, String expectedSQLState )
1:         throws SQLException
1:     {
1:         boolean didSucceed = false;
1:         
0:         try {
1:             Statement s = createStatement();
1:             s.execute("call SYSCS_UTIL.SYSCS_RELOAD_SECURITY_POLICY()");
1: 
1:             didSucceed = true;
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( expectedSQLState, se );
1:         }
1: 
1:         assertEquals( "Reloading results.", shouldSucceed, didSucceed );
1:     }
1:     
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:c8f894e
/////////////////////////////////////////////////////////////////////////
1:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE" +  
/////////////////////////////////////////////////////////////////////////
1:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_TO_EXTFILE" +  
1:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_TABLE_LOBS_FROM_EXTFILE(" + 
1:             s.execute("call SYSCS_UTIL.SYSCS_EXPORT_QUERY_LOBS_TO_EXTFILE(" +
1:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_DATA_LOBS_FROM_EXTFILE(" + 
commit:fef20ca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
/////////////////////////////////////////////////////////////////////////
1:         return new SupportFilesSetup((Test) suite);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0:     /**
1:      * Simple test to ensure new import/export procedures added in 10.3 
1:      * are working on hard upgrade to 10.3 from previous derby versions.
0:      */
1:     public void testImportExportLobsProcedures()
1:         throws SQLException
0:     {
0:     
1:         switch(getPhase()) {
0:         case PH_CREATE: {
1:             Statement s = createStatement();
1:             s.execute("create table iet1(id int , content clob , pic blob)");
1:             s.executeUpdate("insert into iet1 values " + 
1:                             "(1, 'SQL Tips', cast(X'4231a2' as blob))");
1:             s.close();
1:             commit();
0:             break;
0:         }
1:         case PH_SOFT_UPGRADE: {
1:             // new import export procedure should not be found 
1:             // on soft-upgrade.
1:             Statement s = createStatement();
1:             assertStatementError("42Y03", s, 
0:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_IN_EXTFILE" +  
1:                 "(null , 'IET1' , 'iet1.del' , null, " + 
1:                 "null, null, 'iet1_lobs.dat')");
1:             s.close();
0:             break;
0:         }
0:         case PH_POST_SOFT_UPGRADE: 
0:             break;
1:         case PH_HARD_UPGRADE: {
1:             //  main file used to perform import/export.
1:             String fileName =  
1:                 (SupportFilesSetup.getReadWrite("iet1.del")).getPath();
1:             // external file name used to store lobs.
1:             String lobsFileName =
1:                 (SupportFilesSetup.getReadWrite("iet1_lobs.dat")).getPath();
0: 
1:             Statement s = createStatement();
1:             s.execute(
0:                 "call SYSCS_UTIL.SYSCS_EXPORT_TABLE_LOBS_IN_EXTFILE" +  
1:                 "(null , 'IET1' , '"  +  fileName  + 
1:                 "' , null, null, null, '" + lobsFileName + "')");
0:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_TABLE_LOBS_IN_EXTFILE(" + 
1:                       "null, 'IET1' , '" + fileName + 
1:                       "', null, null, null, 0)");
0:             s.execute("call SYSCS_UTIL.SYSCS_EXPORT_QUERY_LOBS_IN_EXTFILE(" +
1:                       "'select * from IET1', '" +  fileName + 
1:                       "' , null, null, null, '" + lobsFileName + "')");
0:             s.execute("call SYSCS_UTIL.SYSCS_IMPORT_DATA_LOBS_IN_EXTFILE(" + 
1:                       "null, 'IET1','ID, CONTENT, PIC', '1,2,3'," + 
1:                       "'" + fileName +"', null, null, null, 1)") ;
0:             
1:             // verify table has correct data after performing import/export.
1:             ResultSet rs = s.executeQuery("select * from iet1");
1:             JDBC.assertFullResultSet(rs, new String[][]
1:                 {{"1", "SQL Tips", "4231a2"},
1:                  {"1", "SQL Tips", "4231a2"}});
1:             s.close();
0:             break;
0:         }
0:         
0:         }
0:     }
0: 
============================================================================