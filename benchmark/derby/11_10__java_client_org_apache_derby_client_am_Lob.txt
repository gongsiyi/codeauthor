1:33776ff: /*
2:70f7692: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Lob
1:fefd864: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:fefd864: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:fefd864: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:70f7692: 
1:8055511: */
1:70f7692: 
1:33776ff: package org.apache.derby.client.am;
1:70f7692: 
1:956354d: import java.io.InputStream;
1:956354d: import java.io.IOException;
1:fefd864: import java.sql.SQLException;
1:956354d: import java.util.ArrayList;
1:69e3d06: import java.util.Iterator;
1:956354d: 
1:fefd864: import org.apache.derby.client.net.NetConfiguration;
1:fefd864: import org.apache.derby.client.net.NetConnection;
1:fefd864: 
1:4ac6a1c: import org.apache.derby.shared.common.reference.SQLState;
1:4ac6a1c: 
1:70f7692: public abstract class Lob implements UnitOfWorkListener {
1:70f7692:     // The following flags specify the data type(s) a LOB instance currently contains
1:0326967:     static final int STRING = 2;
1:0326967:     static final int ASCII_STREAM = 4;
1:0326967:     static final int UNICODE_STREAM = 8;
1:0326967:     static final int CHARACTER_STREAM = 16;
1:0326967:     static final int BINARY_STREAM = 32;
1:0326967:     static final int BINARY_STRING = 64;
1:0326967:     static final int LOCATOR = 128;
1:70f7692: 
1:c720ff6:     public static final int INVALID_LOCATOR = -1;
1:70f7692:     //---------------------navigational members-----------------------------------
1:70f7692:     protected Agent agent_;
1:70f7692: 
1:70f7692:     //-----------------------------state------------------------------------------
1:70f7692:     protected int dataType_ = 0;      // data type(s) the LOB instance currently contains
1:c720ff6:     protected int locator_ = INVALID_LOCATOR; // locator id for this LOB
1:70f7692: 
1:2ef245a:     private long sqlLength_;// length of the LOB value, as defined by the server
1:2ef245a:     private boolean lengthObtained_;
1:70f7692:     
1:2ef245a:     /**
1:8055511:      * This boolean variable indicates whether the Lob object has been
1:8055511:      * invalidated by calling free() on it
1:8055511:      */
1:8055511:     protected boolean isValid_ = true;
1:66a9818: 
1:fefd864:     final private boolean willBeLayerBStreamed_;
1:a8908bd:     
1:a8908bd:         
1:a8908bd:     //A running counter that keeps track
1:a8908bd:     //of whether a update has been done
1:a8908bd:     //on this LOB value. We do not need
1:a8908bd:     //to bother about the limit imposed
1:a8908bd:     //by this counter because we just check
1:a8908bd:     //whether its latest value matches hence
1:a8908bd:     //for all practical purposes there is no 
1:a8908bd:     //limit imposed.
1:a8908bd:     private long updateCount;
1:8055511: 
1:2ef245a:     /**
1:8055511:      * This integer identifies which transaction the Lob is associated with
1:8055511:      */
1:8055511:     private int transactionID_;
1:66a9818: 
1:fefd864:     //-----------------------------messageId------------------------------------------
1:b565f41:     final static private ClientMessageId LOB_OBJECT_LENGTH_UNKNOWN_YET =
1:fefd864:         new ClientMessageId( SQLState.LOB_OBJECT_LENGTH_UNKNOWN_YET );
1:8055511:     
1:fefd864:     
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:fefd864:     protected Lob(Agent agent,
1:fefd864:                   boolean willBeLayerBStreamed) {
1:70f7692:         agent_ = agent;
1:70f7692:         lengthObtained_ = false;
1:fefd864:         willBeLayerBStreamed_ = willBeLayerBStreamed;
1:8055511:         transactionID_ = agent_.connection_.getTransactionID();
6:70f7692:     }
1:a8908bd: 
1:70f7692:     // ---------------------------jdbc 2------------------------------------------
1:a8908bd: 
1:a8908bd:     /**
1:1a66a1a:      * Return the length of the Lob value represented by this Lob
1:1a66a1a:      * object.  If length is not already known, and Lob is locator
1:1a66a1a:      * based, length will be retrieved from the server.  If not,
1:1a66a1a:      * locator based, Lob will first be materialized.  NOTE: The
1:1a66a1a:      * caller needs to deal with synchronization.
1:2ef245a:      *
1:2ef245a:      * @throws SqlException on execution errors while materializing the stream, 
1:1a66a1a:      *         or if Layer B streaming is used and length not yet obtained.
1:2ef245a:      * @return length of Lob value
1:2ef245a:      */
1:2ef245a:     long sqlLength() throws SqlException 
1:2ef245a:     {
1:66a9818:         if (lengthObtained_) return sqlLength_;
1:956354d:         
1:1a66a1a:         if (isLocator()) {
1:1a66a1a:             sqlLength_ = getLocatorLength();
1:1a66a1a:             lengthObtained_ = true;
1:c720ff6:         } else if (willBeLayerBStreamed()) {
1:2ef245a:             throw new SqlException(agent_.logWriter_,
1:2ef245a:                                    LOB_OBJECT_LENGTH_UNKNOWN_YET);
1:c720ff6:         } else {
1:c720ff6:             materializeStream();  // Will set sqlLength_
1:1a66a1a:         }
1:1a66a1a: 
1:70f7692:         return sqlLength_;
1:2ef245a:     }
1:2ef245a: 
1:1a66a1a:     /**
1:2ef245a:      * Update the registered length of the Lob value.  To be called by
1:2ef245a:      * methods that make changes to the length of the Lob.
2:2ef245a:      * NOTE: The caller needs to deal with synchronization.
1:2ef245a:      *
1:36ab2b0:      * @param length the new length of the Lob value
1:2ef245a:      */
1:2ef245a:     void setSqlLength(long length)
1:2ef245a:     {
1:2ef245a:         sqlLength_ = length;
1:2ef245a:         lengthObtained_ = true;
1:2ef245a:     }
1:2ef245a: 
1:956354d:     /**
1:1a66a1a:      * Get the length of locator based Lob from the server.  This is a
1:1a66a1a:      * dummy implementation that is supposed to be overridden by
1:1a66a1a:      * subclasses.  A stored procedure call will be made to get the
1:1a66a1a:      * length from the server.
1:1a66a1a:      * 
1:1a66a1a:      * @return length of Lob
1:1a66a1a:      */
1:1a66a1a:     long getLocatorLength() throws SqlException
1:1a66a1a:     {
1:1a66a1a:         return -1;
1:1a66a1a:     }
1:1a66a1a: 
1:1a66a1a: 
1:70f7692:     //-----------------------event callback methods-------------------------------
1:8055511: 
1:70f7692:     public void listenToUnitOfWork() {
1:dd7d579:         agent_.connection_.CommitAndRollbackListeners_.put(this,null);
1:8055511:     }
1:8055511: 
1:69e3d06:     public void completeLocalCommit(Iterator listenerIterator) {
1:70f7692:         listenerIterator.remove();
1:fefd864:     }
1:fefd864: 
1:69e3d06:     public void completeLocalRollback(Iterator listenerIterator) {
1:70f7692:         listenerIterator.remove();
1:70f7692:     }
1:fefd864: 
1:70f7692:     //----------------------------helper methods----------------------------------
1:70f7692: 
1:70f7692:     public Agent getAgent() {
1:70f7692:         return agent_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     void checkForClosedConnection() throws SqlException {
1:70f7692:         if (agent_.connection_.isClosedX()) {
1:70f7692:             agent_.checkForDeferredExceptions();
1:c9382f0:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.LOB_METHOD_ON_CLOSED_CONNECTION));
1:70f7692:         } else {
1:70f7692:             agent_.checkForDeferredExceptions();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:2ef245a:     /**
1:2ef245a:      * Method to be implemented by subclasses, so that
1:2ef245a:      * #materializedStream(InputStream, String) can be called with subclass
1:2ef245a:      * specific parameters and the result assigned to the right stream.
1:2ef245a:      *
1:2ef245a:      * @throws SqlException
1:2ef245a:      */
1:2ef245a:     protected abstract void materializeStream() throws SqlException;
1:2ef245a: 
1:2ef245a: 
1:8055511:     /**
1:956354d:      * Materialize the given stream into memory and update the internal
1:956354d:      * length variable.
1:956354d:      *
1:956354d:      * @param is stream to use for input
1:956354d:      * @param typeDesc description of the data type we are inserting,
1:956354d:      *      for instance <code>java.sql.Clob</code>
1:956354d:      * @return a stream whose source is the materialized data
1:956354d:      * @throws SqlException if the stream exceeds 2 GB, or an error happens
1:956354d:      *      while reading from the stream
1:956354d:      */
1:956354d:     protected InputStream materializeStream(InputStream is, String typeDesc)
1:956354d:             throws SqlException {
1:956354d:         final int GROWBY = 32 * 1024; // 32 KB
1:4772c7e:         ArrayList<byte[]> byteArrays = new ArrayList<byte[]>();
1:956354d:         byte[] curBytes = new byte[GROWBY];
1:956354d:         int totalLength = 0;
1:956354d:         int partLength = 0;
1:956354d:         // Read all data from the stream, storing it in a number of arrays.
1:956354d:         try {
1:956354d:             do {
1:956354d:                 partLength = is.read(curBytes, 0, curBytes.length);
1:956354d:                 if (partLength == curBytes.length) {
2:956354d:                     byteArrays.add(curBytes);
1:956354d:                     // Make sure we don't exceed 2 GB by checking for overflow.
1:956354d:                     int newLength = totalLength + GROWBY;
1:956354d:                     if (newLength < 0 || newLength == Integer.MAX_VALUE) {
1:956354d:                         curBytes = new byte[Integer.MAX_VALUE - totalLength];
1:956354d:                     } else {
1:956354d:                         curBytes = new byte[GROWBY];
1:956354d:                     }
1:956354d:                 }
1:ef4a7ba:                 if (partLength > 0) {
1:ef4a7ba:                     totalLength += partLength;
1:ef4a7ba:                 }
1:956354d:             } while (partLength == GROWBY);
1:956354d:             // Make sure stream is exhausted.
1:956354d:             if (is.read() != -1) {
1:956354d:                 // We have exceeded 2 GB.
1:956354d:                 throw new SqlException(
1:956354d:                             null,
1:956354d:                             new ClientMessageId(
1:956354d:                                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:956354d:                                 typeDesc
1:956354d:                         );
1:ef4a7ba:             }
1:ef4a7ba:             if (partLength > 0) {
1:ef4a7ba:                 byteArrays.add(curBytes);
1:956354d:             }
1:956354d: 
1:956354d:             // Cleanup and set state.
1:956354d:             curBytes = null;
1:956354d:             sqlLength_ = totalLength;
1:956354d:             lengthObtained_ = true;
1:956354d:             // Return a stream whose source is a list of byte arrays. 
1:956354d:             // This avoids having to copy all the data into a single big array.
1:956354d:             return new ByteArrayCombinerStream(byteArrays, totalLength);
1:956354d:         } catch (IOException ioe) {
1:956354d:             throw new SqlException(null,
1:956354d:                         new ClientMessageId(
1:956354d:                             SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION),
1:e1a79c3:                             ioe,
1:e1a79c3:                             typeDesc
1:956354d:                     );
1:956354d:         }
1:956354d:     }
1:b6ee24b: 
1:fefd864:     public abstract long length() throws SQLException;
1:fefd864:     
1:fefd864:     protected static boolean isLayerBStreamingPossible( Agent agent ){
1:fefd864:         
1:fefd864:         final NetConnection netConn = 
1:fefd864:             ( NetConnection  ) agent.connection_ ;
1:fefd864:         
1:fefd864:         final int securityMechanism = 
1:fefd864:             netConn.getSecurityMechanism();
1:fefd864: 
1:fefd864:         return 
1:fefd864:             netConn.serverSupportsLayerBStreaming() &&
1:fefd864:             securityMechanism != NetConfiguration.SECMEC_EUSRIDDTA &&
1:fefd864:             securityMechanism != NetConfiguration.SECMEC_EUSRPWDDTA;
1:fefd864:         
1:fefd864:     }
1:fefd864:     
1:fefd864:     public boolean willBeLayerBStreamed() {
1:fefd864:         return willBeLayerBStreamed_;
1:fefd864:     }
1:fefd864: 
1:c9382f0:     /**
1:1a66a1a:      * Check whether this Lob is based on a locator
1:1a66a1a:      * @return true if Lob is based on locator, false otherwise
1:1a66a1a:      */
1:1a66a1a:     public boolean isLocator() {
1:1a66a1a:         return ((dataType_ & LOCATOR) == LOCATOR);
1:1a66a1a:     }
1:1a66a1a: 
1:1a66a1a:     /**
1:1a66a1a:      * Get locator for this Lob
1:c720ff6:      * @return locator for this Lob, INVALID_LOCATOR if Lob is not
1:c720ff6:      *         based on locator
1:1a66a1a:      */
1:1a66a1a:     public int getLocator() {
1:1a66a1a:         return locator_;
1:1a66a1a:     }
1:1a66a1a: 
1:1a66a1a: 
1:1a66a1a:     /**
1:c9382f0:      * Checks the <code>pos</code> and <code>length</code>.
1:c9382f0:      *
1:c9382f0:      * @param pos a long that contains the position that needs to be checked
1:c9382f0:      * @param length a long that contains the length that needs to be checked
1:c9382f0:      * @throws SQLException if
1:dbed020:      *         a) pos &lt;= 0
1:dbed020:      *         b) pos &gt; (length of LOB)
1:dbed020:      *         c) length &lt; 0
1:dbed020:      *         d) (pos -1) + length &gt; (length of LOB)
1:c9382f0:      */
1:c9382f0:     protected void checkPosAndLength(long pos, long length)
1:c9382f0:     throws SQLException {
1:c9382f0:         if (pos <= 0) {
1:c9382f0:             throw new SqlException(agent_.logWriter_,
1:c9382f0:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION),
1:66527ec:                 pos).getSQLException();
1:c9382f0:         }
1:c9382f0:         if (length < 0) {
1:c9382f0:             throw new SqlException(agent_.logWriter_,
1:c9382f0:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
1:66527ec:                 length).getSQLException();
1:c9382f0:         }
1:aeb4325:         if (length > (this.length() - (pos -1))) {
1:c9382f0:             throw new SqlException(agent_.logWriter_,
1:c9382f0:                 new ClientMessageId(SQLState.POS_AND_LENGTH_GREATER_THAN_LOB),
1:66527ec:                 pos, length).getSQLException();
1:c9382f0:         }
1:c9382f0:     }
1:70f7692:     
1:70f7692:         
1:8055511:     /**
1:a8908bd:      * Increments and returns the new updateCount 
1:a8908bd:      * of this <code>Lob</code>. The method needs to be 
1:a8908bd:      * synchronized since multiple updates can 
1:a8908bd:      * happen on this <code>Lob</code> simultaneously. 
1:a8908bd:      * It will be called from the
1:a8908bd:      * 1) Locator Writers
1:a8908bd:      * 2) Locator OutputStreams
1:a8908bd:      * 3) From the update methods
1:a8908bd:      *    within the Lobs like setString, truncate.
1:a8908bd:      * since all of the above acesses are inside
1:a8908bd:      * the am package, this method will have
1:a8908bd:      * default access. We do not need to worry
1:a8908bd:      * about the non-locator streams since
1:a8908bd:      * non-locator InputStreams would not
1:a8908bd:      * depend on updateCount for invalidation
1:a8908bd:      */
1:a8908bd:     protected synchronized void incrementUpdateCount() {
1:a8908bd:         updateCount++;
1:a8908bd:     }
1:a8908bd:     
1:a8908bd:     /**
1:a8908bd:      * Returns the current updateCount of the Clob.
1:a8908bd:      */
1:a8908bd:     long getUpdateCount() {
1:a8908bd:         return updateCount;
1:a8908bd:     }
1:a8908bd:     
1:a8908bd:     /**
1:a8908bd:      * Calls SqlLength() to check if the Locator associated
1:a8908bd:      * with the underlying Lob is valid. If it is not
1:a8908bd:      * it throws an exception.
1:a8908bd:      *
1:a8908bd:      * @throws SqlException
1:a8908bd:      * 
1:a8908bd:      */
1:a8908bd:     void checkForLocatorValidity() throws SqlException {
1:a8908bd:         // As of now there is no other way of determining that
1:a8908bd:         //the locator associated with the underlying LOB is not
1:a8908bd:         //valid
1:a8908bd:         sqlLength();
1:a8908bd:     }
1:8055511:     
2:8055511:     /**
1:66a9818:      * Checks if isValid is true and whether the transaction that
1:66a9818:      * created the Lob is still active. If any of which is not true throws
1:8055511:      * a SQLException stating that a method has been called on
1:66a9818:      * an invalid LOB object.
1:8055511:      *
1:66a9818:      * @throws SQLException if isValid is not true or the transaction that
1:66a9818:      * created the Lob is not active
1:8055511:      */
1:8055511:     protected void checkValidity() throws SQLException{
1:66a9818: 
1:66a9818:         // If there isn't an open connection, the Lob is invalid.
1:66a9818:         try {
1:66a9818:             agent_.connection_.checkForClosedConnection();
1:66a9818:         } catch (SqlException se) {
1:66a9818:             throw se.getSQLException();
1:66a9818:         }
1:66a9818: 
1:8b8fe9f:         if(!isValid_ || (isLocator()  && 
1:6eb29f6:                 (transactionID_ != agent_.connection_.getTransactionID())))
1:8055511:             throw new SqlException(null,new ClientMessageId(SQLState.LOB_OBJECT_INVALID))
1:8055511:                                                   .getSQLException();
1:c9382f0:     }
1:8055511: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *         a) pos &lt;= 0
1:      *         b) pos &gt; (length of LOB)
1:      *         c) length &lt; 0
1:      *         d) (pos -1) + length &gt; (length of LOB)
commit:a8908bd
/////////////////////////////////////////////////////////////////////////
1:     
1:         
1:     //A running counter that keeps track
1:     //of whether a update has been done
1:     //on this LOB value. We do not need
1:     //to bother about the limit imposed
1:     //by this counter because we just check
1:     //whether its latest value matches hence
1:     //for all practical purposes there is no 
1:     //limit imposed.
1:     private long updateCount;
/////////////////////////////////////////////////////////////////////////
1:     
1:         
1:     /**
1:      * Increments and returns the new updateCount 
1:      * of this <code>Lob</code>. The method needs to be 
1:      * synchronized since multiple updates can 
1:      * happen on this <code>Lob</code> simultaneously. 
1:      * It will be called from the
1:      * 1) Locator Writers
1:      * 2) Locator OutputStreams
1:      * 3) From the update methods
1:      *    within the Lobs like setString, truncate.
1:      * since all of the above acesses are inside
1:      * the am package, this method will have
1:      * default access. We do not need to worry
1:      * about the non-locator streams since
1:      * non-locator InputStreams would not
1:      * depend on updateCount for invalidation
1:      */
1:     protected synchronized void incrementUpdateCount() {
1:         updateCount++;
1:     }
1:     
1:     /**
1:      * Returns the current updateCount of the Clob.
1:      */
1:     long getUpdateCount() {
1:         return updateCount;
1:     }
1:     
1:     /**
1:      * Calls SqlLength() to check if the Locator associated
1:      * with the underlying Lob is valid. If it is not
1:      * it throws an exception.
1:      *
1:      * @throws SqlException
1:      * 
1:      */
1:     void checkForLocatorValidity() throws SqlException {
1:         // As of now there is no other way of determining that
1:         //the locator associated with the underlying LOB is not
1:         //valid
1:         sqlLength();
1:     }
commit:c720ff6
/////////////////////////////////////////////////////////////////////////
1:     public static final int INVALID_LOCATOR = -1;
1:     protected int locator_ = INVALID_LOCATOR; // locator id for this LOB
/////////////////////////////////////////////////////////////////////////
1:         } else if (willBeLayerBStreamed()) {
1:         } else {
1:             materializeStream();  // Will set sqlLength_
/////////////////////////////////////////////////////////////////////////
1:      * @return locator for this Lob, INVALID_LOCATOR if Lob is not
1:      *         based on locator
commit:1a66a1a
/////////////////////////////////////////////////////////////////////////
0:     public static final int LOCATOR = 128;
0:     protected int locator_ = -1;   // locator id for this LOB, -1 if not locator
/////////////////////////////////////////////////////////////////////////
1:      * Return the length of the Lob value represented by this Lob
1:      * object.  If length is not already known, and Lob is locator
1:      * based, length will be retrieved from the server.  If not,
1:      * locator based, Lob will first be materialized.  NOTE: The
1:      * caller needs to deal with synchronization.
1:      *         or if Layer B streaming is used and length not yet obtained.
1:         if (isLocator()) {
1:             sqlLength_ = getLocatorLength();
1:             lengthObtained_ = true;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the length of locator based Lob from the server.  This is a
1:      * dummy implementation that is supposed to be overridden by
1:      * subclasses.  A stored procedure call will be made to get the
1:      * length from the server.
1:      * 
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return length of Lob
1:      */
1:     long getLocatorLength() throws SqlException
1:     {
1:         return -1;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Check whether this Lob is based on a locator
1:      * @return true if Lob is based on locator, false otherwise
1:      */
1:     public boolean isLocator() {
1:         return ((dataType_ & LOCATOR) == LOCATOR);
1:     }
1: 
1:     /**
1:      * Get locator for this Lob
0:      * @return locator for this Lob, -1 is Lob is not based on locator
1:      */
1:     public int getLocator() {
1:         return locator_;
1:     }
1: 
1: 
1:     /**
commit:ef4a7ba
/////////////////////////////////////////////////////////////////////////
1:                 if (partLength > 0) {
1:                     totalLength += partLength;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (partLength > 0) {
1:                 byteArrays.add(curBytes);
1:             }
commit:956354d
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Materialize the given stream into memory and update the internal
1:      * length variable.
1:      *
1:      * @param is stream to use for input
1:      * @param typeDesc description of the data type we are inserting,
1:      *      for instance <code>java.sql.Clob</code>
1:      * @return a stream whose source is the materialized data
1:      * @throws SqlException if the stream exceeds 2 GB, or an error happens
1:      *      while reading from the stream
1:      */
1:     protected InputStream materializeStream(InputStream is, String typeDesc)
1:             throws SqlException {
1:         final int GROWBY = 32 * 1024; // 32 KB
0:         ArrayList byteArrays = new ArrayList();
1:         byte[] curBytes = new byte[GROWBY];
1:         int totalLength = 0;
1:         int partLength = 0;
1:         // Read all data from the stream, storing it in a number of arrays.
1:         try {
1:             do {
1:                 partLength = is.read(curBytes, 0, curBytes.length);
1:                 if (partLength == curBytes.length) {
1:                     byteArrays.add(curBytes);
1:                     // Make sure we don't exceed 2 GB by checking for overflow.
1:                     int newLength = totalLength + GROWBY;
1:                     if (newLength < 0 || newLength == Integer.MAX_VALUE) {
1:                         curBytes = new byte[Integer.MAX_VALUE - totalLength];
1:                     } else {
1:                         curBytes = new byte[GROWBY];
1:                     }
1:                 }
0:                 totalLength += partLength;
1:             } while (partLength == GROWBY);
1:             // Make sure stream is exhausted.
1:             if (is.read() != -1) {
1:                 // We have exceeded 2 GB.
1:                 throw new SqlException(
1:                             null,
1:                             new ClientMessageId(
1:                                 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:                                 typeDesc
1:                         );
1:             }
1:             byteArrays.add(curBytes);
1: 
1:             // Cleanup and set state.
1:             curBytes = null;
1:             sqlLength_ = totalLength;
1:             lengthObtained_ = true;
1:             // Return a stream whose source is a list of byte arrays. 
1:             // This avoids having to copy all the data into a single big array.
1:             return new ByteArrayCombinerStream(byteArrays, totalLength);
1:         } catch (IOException ioe) {
1:             throw new SqlException(null,
1:                         new ClientMessageId(
1:                             SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION),
0:                         typeDesc,
0:                         ioe
1:                     );
1:         }
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                             ioe,
1:                             typeDesc
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 pos).getSQLException();
1:                 length).getSQLException();
1:                 pos, length).getSQLException();
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<byte[]> byteArrays = new ArrayList<byte[]>();
commit:735e4a0
/////////////////////////////////////////////////////////////////////////
commit:9c20c50
/////////////////////////////////////////////////////////////////////////
0:                             typeDesc,
0:                             ioe
commit:c50ba59
/////////////////////////////////////////////////////////////////////////
commit:66a9818
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (lengthObtained_) return sqlLength_;
/////////////////////////////////////////////////////////////////////////
1:      * Checks if isValid is true and whether the transaction that
1:      * created the Lob is still active. If any of which is not true throws
1:      * an invalid LOB object.
1:      * @throws SQLException if isValid is not true or the transaction that
1:      * created the Lob is not active
1: 
1:         // If there isn't an open connection, the Lob is invalid.
1:         try {
1:             agent_.connection_.checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1: 
commit:9c7c512
/////////////////////////////////////////////////////////////////////////
0:         if (length > (this.length() - pos)) {
commit:c9382f0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks the <code>pos</code> and <code>length</code>.
1:      *
1:      * @param pos a long that contains the position that needs to be checked
1:      * @param length a long that contains the length that needs to be checked
1:      * @throws SQLException if
0:      *         a) pos <= 0
0:      *         b) pos > (length of LOB)
0:      *         c) length < 0
0:      *         d) pos + length > (length of LOB)
1:      */
1:     protected void checkPosAndLength(long pos, long length)
1:     throws SQLException {
1:         if (pos <= 0) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.BLOB_BAD_POSITION),
0:                 new Long(pos)).getSQLException();
1:         }
0:         if (pos > this.length()) {
1:             throw new SqlException(agent_.logWriter_,
0:                 new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE),
0:                 new Long(pos)).getSQLException();
1:         }
1:         if (length < 0) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                 new Integer((int)length)).getSQLException();
1:         }
0:         if ((pos + length) > this.length()) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.POS_AND_LENGTH_GREATER_THAN_LOB),
0:                 new Long(pos), new Long(length)).getSQLException();
1:         }
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     final static private ClientMessageId LOB_OBJECT_LENGTH_UNKNOWN_YET =
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     static final int STRING = 2;
1:     static final int ASCII_STREAM = 4;
1:     static final int UNICODE_STREAM = 8;
1:     static final int CHARACTER_STREAM = 16;
1:     static final int BINARY_STREAM = 32;
1:     static final int BINARY_STRING = 64;
1:     static final int LOCATOR = 128;
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     public void completeLocalCommit(Iterator listenerIterator) {
1:     public void completeLocalRollback(Iterator listenerIterator) {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
commit:36ab2b0
/////////////////////////////////////////////////////////////////////////
1:      * @param length the new length of the Lob value
commit:2ef245a
/////////////////////////////////////////////////////////////////////////
1:     private long sqlLength_;// length of the LOB value, as defined by the server
1:     private boolean lengthObtained_;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Return the length of the Lob value represented by this Lob object.
0:      * If length is not already known, Lob will first be materialized.
1:      * NOTE: The caller needs to deal with synchronization.
1:      *
1:      * @throws SqlException on execution errors while materializing the stream, 
0:      *         or if Layer B streaming is used and length not already obtained.
1:      * @return length of Lob value
1:      */
1:     long sqlLength() throws SqlException 
1:     {
0:         if (lengthObtained_) return sqlLength_;
1:         
0:         if (willBeLayerBStreamed()) {
1:             throw new SqlException(agent_.logWriter_,
1:                                    LOB_OBJECT_LENGTH_UNKNOWN_YET);
1:         }
0:         materializeStream();  // Will set sqlLength_
1:     /**
1:      * Update the registered length of the Lob value.  To be called by
1:      * methods that make changes to the length of the Lob.
1:      * NOTE: The caller needs to deal with synchronization.
1:      *
0:      * @param the new length of the Lob value
1:      */
1:     void setSqlLength(long length)
1:     {
1:         sqlLength_ = length;
1:         lengthObtained_ = true;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Method to be implemented by subclasses, so that
1:      * #materializedStream(InputStream, String) can be called with subclass
1:      * specific parameters and the result assigned to the right stream.
1:      *
1:      * @throws SqlException
1:      */
1:     protected abstract void materializeStream() throws SqlException;
1: 
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:                 (transactionID_ != agent_.connection_.getTransactionID())))
commit:8b8fe9f
/////////////////////////////////////////////////////////////////////////
1:         if(!isValid_ || (isLocator()  && 
0:         		(transactionID_ != agent_.connection_.getTransactionID())))
commit:8055511
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This boolean variable indicates whether the Lob object has been
1:      * invalidated by calling free() on it
1:      */
1:     protected boolean isValid_ = true;
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This integer identifies which transaction the Lob is associated with
1:      */
1:     private int transactionID_;
1:     
/////////////////////////////////////////////////////////////////////////
1:         transactionID_ = agent_.connection_.getTransactionID();
/////////////////////////////////////////////////////////////////////////
0:     	if (lengthObtained_) return sqlLength_;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Checks is isValid is true and whether the transaction that
0:      * created the Lob is still active. If any of which is not true throws 
1:      * a SQLException stating that a method has been called on
0:      * an invalid LOB object
1:      *
0:      * @throws SQLException if isValid is not true
1:      */
1:     protected void checkValidity() throws SQLException{
1:     	
1:     	/**
0:     	 * If there isn't an open connection, the Lob is invalid.
1:     	 */
0:     	try{
0:     		agent_.connection_.checkForClosedConnection();
0:     	}catch(SqlException se){
0:     		throw se.getSQLException();
1:     	}
1:     	
0:         if(!isValid_ || transactionID_ != agent_.connection_.getTransactionID())
1:             throw new SqlException(null,new ClientMessageId(SQLState.LOB_OBJECT_INVALID))
1:                                                   .getSQLException();
1:     }
commit:dd7d579
/////////////////////////////////////////////////////////////////////////
1:         agent_.connection_.CommitAndRollbackListeners_.put(this,null);
commit:64b55c2
/////////////////////////////////////////////////////////////////////////
0:         agent_.connection_.CommitAndRollbackListeners_.add(this);
commit:cff2860
/////////////////////////////////////////////////////////////////////////
0:         agent_.connection_.CommitAndRollbackListeners_.put(this,null);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:86fd405
/////////////////////////////////////////////////////////////////////////
0:                             ioe,
0:                             typeDesc
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aeb4325
/////////////////////////////////////////////////////////////////////////
0:      *         d) (pos -1) + length > (length of LOB)
/////////////////////////////////////////////////////////////////////////
1:         if (length > (this.length() - (pos -1))) {
commit:b6ee24b
/////////////////////////////////////////////////////////////////////////
1: 
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
1: import org.apache.derby.client.net.NetConfiguration;
1: import org.apache.derby.client.net.NetConnection;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     final private boolean willBeLayerBStreamed_;
1:     //-----------------------------messageId------------------------------------------
0:     final static protected ClientMessageId LOB_OBJECT_LENGTH_UNKNOWN_YET =
1:         new ClientMessageId( SQLState.LOB_OBJECT_LENGTH_UNKNOWN_YET );
1:     
1:     
1:     protected Lob(Agent agent,
1:                   boolean willBeLayerBStreamed) {
1:         willBeLayerBStreamed_ = willBeLayerBStreamed;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static boolean isLengthObtained(Lob l){
0:         return l.lengthObtained_;
1:     }
1:     
1:     public abstract long length() throws SQLException;
1:     
1:     protected static boolean isLayerBStreamingPossible( Agent agent ){
1:         
1:         final NetConnection netConn = 
1:             ( NetConnection  ) agent.connection_ ;
1:         
1:         final int securityMechanism = 
1:             netConn.getSecurityMechanism();
1: 
1:         return 
1:             netConn.serverSupportsLayerBStreaming() &&
1:             securityMechanism != NetConfiguration.SECMEC_EUSRIDDTA &&
1:             securityMechanism != NetConfiguration.SECMEC_EUSRPWDDTA;
1:         
1:     }
1:     
1:     public boolean willBeLayerBStreamed() {
1:         return willBeLayerBStreamed_;
1:     }
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.LOB_METHOD_ON_CLOSED_CONNECTION));
commit:4ac6a1c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.LOB_METHOD_ON_CLOSED_CONNECTION));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public abstract class Lob implements UnitOfWorkListener {
1:     // The following flags specify the data type(s) a LOB instance currently contains
0:     public static final int STRING = 2;
0:     public static final int ASCII_STREAM = 4;
0:     public static final int UNICODE_STREAM = 8;
0:     public static final int CHARACTER_STREAM = 16;
0:     public static final int BINARY_STREAM = 32;
0:     public static final int BINARY_STRING = 64;
1:     //---------------------navigational members-----------------------------------
1:     protected Agent agent_;
1:     //-----------------------------state------------------------------------------
1:     protected int dataType_ = 0;      // data type(s) the LOB instance currently contains
0:     protected long sqlLength_;      // length of the LOB value, as defined by the server
0:     protected boolean lengthObtained_;
1:     //---------------------constructors/finalizer---------------------------------
0:     protected Lob(Agent agent) {
1:         agent_ = agent;
1:         lengthObtained_ = false;
0:     protected void finalize() throws java.lang.Throwable {
0:         super.finalize();
1:     }
1: 
1:     // ---------------------------jdbc 2------------------------------------------
1: 
0:     // should only be called by a synchronized method.
1: 
1: 
0:     // should only be called by a synchronized method.
0:     public long sqlLength() throws SqlException {
0:         checkForClosedConnection();
1: 
1:         return sqlLength_;
1:     }
1: 
1: 
1:     //-----------------------event callback methods-------------------------------
1: 
1:     public void listenToUnitOfWork() {
0:         agent_.connection_.CommitAndRollbackListeners_.add(this);
1:     }
1: 
0:     public void completeLocalCommit(java.util.Iterator listenerIterator) {
1:         listenerIterator.remove();
1:     }
1: 
0:     public void completeLocalRollback(java.util.Iterator listenerIterator) {
1:         listenerIterator.remove();
1:     }
1: 
1:     //----------------------------helper methods----------------------------------
1: 
1:     public Agent getAgent() {
1:         return agent_;
1:     }
1: 
1:     void checkForClosedConnection() throws SqlException {
1:         if (agent_.connection_.isClosedX()) {
1:             agent_.checkForDeferredExceptions();
0:             throw new SqlException(agent_.logWriter_, "Lob method called after connection was closed");
1:         } else {
1:             agent_.checkForDeferredExceptions();
1:         }
1:     }
1: 
0:     void completeLocalRollback() {
0:         ;
1:     }
1: 
0:     void completeLocalCommit() {
0:         ;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derby.client.am.Lob
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: */
0: 
1: package org.apache.derby.client.am;
0: 
0: public abstract class Lob implements UnitOfWorkListener
0: {
0:   // The following flags specify the data type(s) a LOB instance currently contains
0:   public static final int STRING = 2;
0:   public static final int ASCII_STREAM = 4;
0:   public static final int UNICODE_STREAM = 8;
0:   public static final int CHARACTER_STREAM = 16;
0:   public static final int BINARY_STREAM = 32;
0:   public static final int BINARY_STRING = 64;
0: 
0:   //---------------------navigational members-----------------------------------
0:   protected Agent agent_;
0: 
0:   //-----------------------------state------------------------------------------
0:   protected int dataType_ = 0;      // data type(s) the LOB instance currently contains
0: 
0:   protected long sqlLength_;      // length of the LOB value, as defined by the server
0:   protected boolean lengthObtained_;
0: 
0:   //---------------------constructors/finalizer---------------------------------
0:   protected Lob (Agent agent)
0:   {
0:     agent_ = agent;
0:     lengthObtained_ = false;
0:   }
0: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     super.finalize();
0:   }
0: 
0:   // ---------------------------jdbc 2------------------------------------------
0: 
0:   // should only be called by a synchronized method.
0: 
0: 
0:   // should only be called by a synchronized method.
0:   public long sqlLength () throws SqlException
0:   {
0:     checkForClosedConnection ();
0: 
0:     return sqlLength_;
0:   }
0: 
0: 
0:   //-----------------------event callback methods-------------------------------
0: 
0:   public void listenToUnitOfWork()
0:   {
0:     agent_.connection_.CommitAndRollbackListeners_.add (this);
0:   }
0: 
0:   public void completeLocalCommit (java.util.Iterator listenerIterator)
0:   {
0:     listenerIterator.remove();
0:   }
0: 
0:   public void completeLocalRollback (java.util.Iterator listenerIterator)
0:   {
0:     listenerIterator.remove();
0:   }
0: 
0:   //----------------------------helper methods----------------------------------
0: 
0:   public Agent getAgent () { return agent_; }
0: 
0:   void checkForClosedConnection () throws SqlException
0:   {
0:     if (agent_.connection_.isClosedX()) {
0:       agent_.checkForDeferredExceptions();
0:       throw new SqlException (agent_.logWriter_, "Lob method called after connection was closed");
0:     }
0:     else {
0:       agent_.checkForDeferredExceptions();
0:     }
0:   }
0: 
0:   void completeLocalRollback() { ; }
0:   void completeLocalCommit() { ; }
0: }
============================================================================