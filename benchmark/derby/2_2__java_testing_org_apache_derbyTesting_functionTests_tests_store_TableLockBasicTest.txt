1:a5006eb: /*
1:a5006eb:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.TableLockBasicTest
1:a5006eb: 
1:a5006eb:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a5006eb:    contributor license agreements.  See the NOTICE file distributed with
1:a5006eb:    this work for additional information regarding copyright ownership.
1:a5006eb:    The ASF licenses this file to You under the Apache License, Version 2.0
1:a5006eb:    (the "License"); you may not use this file except in compliance with
1:a5006eb:    the License.  You may obtain a copy of the License at
1:a5006eb: 
1:a5006eb:       http://www.apache.org/licenses/LICENSE-2.0
1:a5006eb: 
1:a5006eb:    Unless required by applicable law or agreed to in writing, software
1:a5006eb:    distributed under the License is distributed on an "AS IS" BASIS,
1:a5006eb:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a5006eb:    See the License for the specific language governing permissions and
1:a5006eb:    limitations under the License.
1:a5006eb: 
1:a5006eb:  */
1:a5006eb: package org.apache.derbyTesting.functionTests.tests.store;
1:a5006eb: 
1:a5006eb: import java.sql.Connection;
1:a5006eb: import java.sql.PreparedStatement;
1:a5006eb: import java.sql.ResultSet;
1:a5006eb: import java.sql.SQLException;
1:a5006eb: import java.sql.Statement;
1:a5006eb: import java.util.Locale;
1:a5006eb: 
1:a5006eb: import junit.framework.Test;
1:a5006eb: 
1:a5006eb: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:a5006eb: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:a5006eb: import org.apache.derbyTesting.junit.JDBC;
1:a5006eb: import org.apache.derbyTesting.junit.LocaleTestSetup;
1:a5006eb: import org.apache.derbyTesting.junit.TestConfiguration;
1:a5006eb: 
1:a5006eb: /**
1:a5006eb: * Very basic single user testing of table locking, verify that the right locks
1:a5006eb: * are obtained for simple operations.  This test only looks at table and
1:a5006eb: * row logical locks, it does not verify physical latches or lock ordering.
1:a5006eb: --
1:a5006eb: * The basic methodology is:
1:a5006eb: *    start transaction
1:a5006eb: *    simple operation
1:a5006eb: *    print lock table which should match the master
1:a5006eb: *    end transation
1:a5006eb:  *
1:a5006eb:  */
1:a5006eb: public class TableLockBasicTest extends BaseJDBCTestCase {
1:a5006eb:     public TableLockBasicTest(String name) {
1:a5006eb:         super(name);
1:a5006eb:     }
1:a5006eb:    
1:a5006eb:     public static Test suite() {        
1:a5006eb:         Test test = TestConfiguration.defaultSuite(TableLockBasicTest.class);
1:a5006eb:         test = DatabasePropertyTestSetup.singleProperty(test, 
1:a5006eb:                 "derby.storage.rowLocking", "false", true);
1:a5006eb:         test = new LocaleTestSetup(test, Locale.ENGLISH);
1:a5006eb:         return TestConfiguration.singleUseDatabaseDecorator(test);
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     protected void setUp() throws SQLException {            
1:a5006eb:             Statement s = createStatement();
1:a5006eb:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:a5006eb:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME "
1:a5006eb:                     + "'org.apache.derbyTesting.functionTests.util.Formatters"
1:a5006eb:                     + ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:a5006eb:             createLockTableQueryEntries(s);
1:a5006eb:             s.close();
1:a5006eb:             
1:a5006eb:             getConnection().setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:a5006eb:             getConnection().setAutoCommit(false);
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     private void createLockTableQueryEntries(Statement s) throws SQLException {
1:a5006eb:         s.execute("create view lock_table as "
1:a5006eb:                 + "select "
1:a5006eb:                 + "cast(username as char(8)) as username,"
1:a5006eb:                 + "cast(t.type as char(8)) as trantype,"
1:a5006eb:                 + "cast(l.type as char(8)) as type,"
1:a5006eb:                 + "cast(lockcount as char(3)) as cnt,"
1:a5006eb:                 + "mode,"
1:a5006eb:                 + "cast(tablename as char(12)) as tabname,"
1:a5006eb:                 + "cast(lockname as char(10)) as lockname,"
1:a5006eb:                 + "state,"
1:a5006eb:                 + "status "
1:a5006eb:                 + "from "
1:a5006eb:                 + "syscs_diag.lock_table l  right outer join syscs_diag.transaction_table t "
1:a5006eb:                 + "on l.xid = t.xid where l.tableType <> 'S' and t.type='UserTransaction'");
1:a5006eb:         
1:a5006eb:         //lock table with system catalog locks included.
1:a5006eb:         s.execute("create view full_lock_table as "
1:a5006eb:                 + "select "
1:a5006eb:                 + "cast(username as char(8)) as username, "
1:a5006eb:                 + "cast(t.type as char(8)) as trantype,"
1:a5006eb:                 + "cast(l.type as char(8)) as type,"
1:a5006eb:                 + "cast(lockcount as char(3)) as cnt,"
1:a5006eb:                 + "mode, "
1:a5006eb:                 + "cast(tablename as char(12)) as tabname,"
1:a5006eb:                 + "cast(lockname as char(10)) as lockname,"
1:a5006eb:                 + "state,"
1:a5006eb:                 + "status "
1:a5006eb:                 + "from "
1:a5006eb:                 + "syscs_diag.lock_table l right outer join syscs_diag.transaction_table t "
1:a5006eb:                 + "on l.xid = t.xid where l.tableType <> 'S' ");
1:a5006eb:         
1:a5006eb:         //lock table with no join.
1:a5006eb:         s.execute("create view lock_table2 as "
1:a5006eb:                 + "select "
1:a5006eb:                 + "cast(l.xid as char(8)) as xid,"
1:a5006eb:                 + "cast(l.type as char(8)) as type,"
1:a5006eb:                 + "cast(lockcount as char(3)) as cnt,"
1:a5006eb:                 + "mode,"
1:a5006eb:                 + "cast(tablename as char(12)) as tabname,"
1:a5006eb:                 + "cast(lockname as char(10)) as lockname,"
1:a5006eb:                 + "state "
1:a5006eb:                 + "from "
1:a5006eb:                 + "syscs_diag.lock_table l "
1:a5006eb:                 + "where l.tableType <> 'S' ");
1:a5006eb:         
1:a5006eb:         //-- transaction table with no join.
1:a5006eb:         s.execute("create view tran_table as "
1:a5006eb:                 + "select "
1:a5006eb:                 + "* "
1:a5006eb:                 + "from "
1:a5006eb:                 + "syscs_diag.transaction_table");        
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     public void tearDown() throws Exception {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         st.executeUpdate("DROP FUNCTION PADSTRING");
1:a5006eb:         
1:a5006eb:         st.execute("drop view lock_table");
1:a5006eb:         st.execute("drop view full_lock_table");
1:a5006eb:         st.execute("drop view lock_table2");
1:a5006eb:         st.execute("drop view tran_table");
1:a5006eb:         
1:a5006eb:         st.close();
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         super.tearDown();
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     public void testInsertIntoHeap() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         st.execute("create table heap_only (a int)");
1:a5006eb:         commit();    
1:a5006eb: 
1:a5006eb:         //Test insert into empty heap, should just get table lock
1:a5006eb:         st.execute("insert into heap_only values (1)");        
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         //Test insert into heap with one row, just get table lock
1:a5006eb:         st.execute("insert into heap_only values (2)");        
1:a5006eb:         rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         st.close();        
1:a5006eb:         dropTable("heap_only");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     /**
1:a5006eb:      * Test select from a heap, should get shared table lock.
1:a5006eb:      */
1:a5006eb:     public void testSelectFromHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();        
1:a5006eb:         constructHeap(st);
1:a5006eb:                 
1:a5006eb:         ResultSet rs = st.executeQuery("select a from heap_only where a = 1");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"1"},
1:a5006eb:         });
1:a5006eb:         rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "S", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"}
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         dropTable("heap_only");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     private void constructHeap(Statement st) throws SQLException {
1:a5006eb:         st.execute("create table heap_only (a int)");
1:a5006eb:         commit();    
1:a5006eb:         
1:a5006eb:         st.execute("insert into heap_only values (1)");
1:a5006eb:         commit();
1:a5006eb:         st.execute("insert into heap_only values (2)");
1:a5006eb:         commit();
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     /**
1:a5006eb:      * Test delete from a heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testDelectFromHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructHeap(st);
1:a5006eb:         
1:a5006eb:         st.execute("delete from heap_only where a = 1");
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "2", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         dropTable("heap_only");
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test update to heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testUpdateToHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructHeap(st);
1:a5006eb:         
1:a5006eb:         st.execute("update heap_only set a = 1000 where a = 2");
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "2", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         dropTable("heap_only");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     /**
1:a5006eb:      * Test drop of heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testDropHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructHeap(st);
1:a5006eb:         
1:a5006eb:         st.execute("drop table heap_only");
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "3", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         dropTable("heap_only");
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     public void testCreateIndex() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         
1:a5006eb:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', '4096')");
1:a5006eb:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:a5006eb:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', NULL)");
1:a5006eb:         
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb:                 
1:a5006eb:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', '4096')");
1:a5006eb:         st.execute("create index a_idx on indexed_heap (a, b)");
1:a5006eb:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', NULL)");
1:a5006eb:         rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "4", "S", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},        });
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         st.close();
1:a5006eb:         
1:a5006eb:         dropTable("indexed_heap");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     public void testInsertIntoEmtpyIndexedHeaP() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         
1:a5006eb:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:a5006eb:         commit();
1:a5006eb:         st.execute("create index a_idx on indexed_heap (a, b)");
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         // Test insert into indexed heap, should just get table lock
1:a5006eb:         st.execute("insert into indexed_heap (a) values (1)");
1:a5006eb:         ResultSet rs = st.executeQuery(" select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][] { 
1:a5006eb:                 {"APP", "UserTran", "TABLE", "2", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"}, 
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         // Test insert into indexed heap with one row, just get table lock
1:a5006eb:         st.execute("insert into indexed_heap (a) values (2)");
1:a5006eb:         rs = st.executeQuery(" select * from lock_table order by tabname, type "
1:a5006eb:                         + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][] { 
1:a5006eb:                 {"APP", "UserTran", "TABLE", "2", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"} 
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         
1:a5006eb:         dropTable("indexed_heap");
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test select from a indexed heap, should get shared table lock.
1:a5006eb:      */
1:a5006eb:     public void testSelectFromIndexedHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructIndexedHeap(st);
1:a5006eb:                
1:a5006eb:         ResultSet rs = st.executeQuery("select a from indexed_heap where a = 1");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"1"},
1:a5006eb:         });
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "S", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         
1:a5006eb:         dropTable("indexed_heap");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     private void constructIndexedHeap(Statement st) throws SQLException {
1:a5006eb:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:a5006eb:         st.execute("create index a_idx on indexed_heap (a, b)");
1:a5006eb: 
1:a5006eb:         st.execute("insert into indexed_heap (a) values (1)");
1:a5006eb:         st.execute("insert into indexed_heap (a) values (2)");
1:a5006eb:         
1:a5006eb:         commit();
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test delete from a indexed heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testDeleteFromIndexedHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructIndexedHeap(st);
1:a5006eb:                
1:a5006eb:         st.execute("delete from indexed_heap where a = 1");
1:a5006eb: 
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "3", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         
1:a5006eb:         dropTable("indexed_heap");
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     /**
1:a5006eb:      * Test update to indexed heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testUpdateToIndexedHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructIndexedHeap(st);
1:a5006eb:                
1:a5006eb:         st.execute("update indexed_heap set a = 1000 where a = 2");
1:a5006eb: 
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "4", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         
1:a5006eb:         dropTable("indexed_heap");
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test drop of indexed heap, should get exclusive table lock.
1:a5006eb:      */
1:a5006eb:     public void testDropIndexedHeap () throws SQLException { 
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         constructIndexedHeap(st);
1:a5006eb:                
1:a5006eb:         st.execute("drop table indexed_heap");
1:a5006eb: 
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:                 {"APP", "UserTran", "TABLE", "4", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         commit();
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test LOCK TABLE statement
1:a5006eb:      */
1:a5006eb:     public void testLockTableStatement() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         
1:a5006eb:         st.execute("create table t1(c1 int)");
1:a5006eb:         commit();        
1:a5006eb:         
1:a5006eb:         PreparedStatement pst = prepareStatement("lock table t1 in exclusive mode");
1:a5006eb:         pst.execute();
1:a5006eb:         
1:a5006eb:         ResultSet rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "X", "T1", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         
1:a5006eb:         //verify that statement gets recompiled correctly
1:a5006eb:         st.execute("drop table t1");
1:a5006eb:         st.execute("create table t1(c1 int)");
1:a5006eb:         pst.execute();
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         st.execute("lock table t1 in share mode");
1:a5006eb:         rs = st.executeQuery(
1:a5006eb:                 " select * from lock_table order by tabname, type "
1:a5006eb:                 + "desc, mode, cnt, lockname");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"APP", "UserTran", "TABLE", "1", "S", "T1", "Tablelock", "GRANT", "ACTIVE"},
1:a5006eb:         });
1:a5006eb:         
1:a5006eb:         st.execute("drop table t1");
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         st.close();
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * verify that lock table not allowed in sys schema
1:a5006eb:      */
1:a5006eb:     public void testLockTableInSysSchema() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         
1:a5006eb:         assertStatementError("42X62", st,
1:a5006eb:                 "lock table sys.systables in exclusive mode");
1:a5006eb:         
1:a5006eb:         st.close();
1:a5006eb:     }
1:a5006eb:     
1:a5006eb:     /**
1:a5006eb:      * Test RTS output when table locking configured
1:a5006eb:      */
1:a5006eb:     public void testRTSOutput() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         
1:a5006eb:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:a5006eb:         st.execute("create table rts(c1 int)");
1:a5006eb:         st.execute("insert into rts values 1");
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         ResultSet rs = st.executeQuery("select * from rts with cs");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"1"}
1:a5006eb:         });
1:a5006eb:         
1:a5006eb:         rs =  st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C3\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from rts with cs\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for RTS at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 1\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time in milliseconds/row = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=1\n"
1:a5006eb:                     + "	Number of rows visited=1\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 },
1:a5006eb:         });
1:a5006eb: 
1:a5006eb:         st.execute("drop table rts");
1:a5006eb:         commit();
1:a5006eb:         
1:a5006eb:         st.close();
1:a5006eb:     }
1:a5006eb: 
1:a5006eb:     public void testDDLTableLockMode() throws SQLException {
1:a5006eb:         Statement st = createStatement();
1:a5006eb:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:a5006eb:         
1:a5006eb:         st.execute("create table default_granularity(c1 int)");
1:a5006eb:         st.execute("create table row_granularity(c1 int)");
1:a5006eb:         st.execute("alter table row_granularity locksize row");
1:a5006eb:         st.execute("create table table_granularity(c1 int)");
1:a5006eb:         st.execute("alter table table_granularity locksize table");
1:a5006eb:         
1:a5006eb:         ResultSet rs = st.executeQuery("select * from default_granularity with cs");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from default_granularity with cs\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("select * from default_granularity with rr");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from default_granularity with rr\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("select * from default_granularity with cs");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from default_granularity with cs\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("select * from row_granularity with rr");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from row_granularity with rr\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for ROW_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("select * from table_granularity with cs");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from table_granularity with cs\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for TABLE_GRANULARITY at read committed isolation level using instantaneous share table locking chosen by the optimizer\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("select * from table_granularity with rr");
1:a5006eb:         JDBC.assertEmpty(rs);
1:a5006eb:         
1:a5006eb:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:a5006eb:         JDBC.assertFullResultSet(rs, new String[][]{
1:a5006eb:                 {"Statement Name: \n"
1:a5006eb:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:a5006eb:                     + "Statement Text: \n"
1:a5006eb:                     + "	select * from table_granularity with rr\n"
1:a5006eb:                     + "Parse Time: 0\n"
1:a5006eb:                     + "Bind Time: 0\n"
1:a5006eb:                     + "Optimize Time: 0\n"
1:a5006eb:                     + "Generate Time: 0\n"
1:a5006eb:                     + "Compile Time: 0\n"
1:a5006eb:                     + "Execute Time: 0\n"
1:a5006eb:                     + "Begin Compilation Timestamp : null\n"
1:a5006eb:                     + "End Compilation Timestamp : null\n"
1:a5006eb:                     + "Begin Execution Timestamp : null\n"
1:a5006eb:                     + "End Execution Timestamp : null\n"
1:a5006eb:                     + "Statement Execution Plan Text: \n"
1:a5006eb:                     + "Table Scan ResultSet for TABLE_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:a5006eb:                     + "Number of opens = 1\n"
1:a5006eb:                     + "Rows seen = 0\n"
1:a5006eb:                     + "Rows filtered = 0\n"
1:a5006eb:                     + "Fetch Size = 16\n"
1:a5006eb:                     + "	constructor time (milliseconds) = 0\n"
1:a5006eb:                     + "	open time (milliseconds) = 0\n"
1:a5006eb:                     + "	next time (milliseconds) = 0\n"
1:a5006eb:                     + "	close time (milliseconds) = 0\n\n"
1:a5006eb:                     + "scan information:\n"
1:a5006eb:                     + "	Bit set of columns fetched=All\n"
1:a5006eb:                     + "	Number of columns fetched=1\n"
1:a5006eb:                     + "	Number of pages visited=1\n"
1:a5006eb:                     + "	Number of rows qualified=0\n"
1:a5006eb:                     + "	Number of rows visited=0\n"
1:a5006eb:                     + "	Scan type=heap\n"
1:a5006eb:                     + "	start position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	stop position:\n"
1:a5006eb:                     + "		null\n"
1:a5006eb:                     + "	qualifiers:\n"
1:a5006eb:                     + "		None\n"
1:df9ed37:                     + "	optimizer estimated row count: 6.00\n"
1:df9ed37:                     + "	optimizer estimated cost: 100.40"
1:a5006eb:                 }
1:a5006eb:         }        
1:a5006eb:         );
1:a5006eb:         
1:a5006eb: 
1:a5006eb:         st.close();
1:a5006eb:         rollback();
1:a5006eb:     }
1:a5006eb: 
1:a5006eb: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:df9ed37
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
/////////////////////////////////////////////////////////////////////////
1:                     + "	optimizer estimated row count: 6.00\n"
1:                     + "	optimizer estimated cost: 100.40"
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:a5006eb
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.TableLockBasicTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Locale;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.LocaleTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1: * Very basic single user testing of table locking, verify that the right locks
1: * are obtained for simple operations.  This test only looks at table and
1: * row logical locks, it does not verify physical latches or lock ordering.
1: --
1: * The basic methodology is:
1: *    start transaction
1: *    simple operation
1: *    print lock table which should match the master
1: *    end transation
1:  *
1:  */
1: public class TableLockBasicTest extends BaseJDBCTestCase {
1:     public TableLockBasicTest(String name) {
1:         super(name);
1:     }
1:    
1:     public static Test suite() {        
1:         Test test = TestConfiguration.defaultSuite(TableLockBasicTest.class);
1:         test = DatabasePropertyTestSetup.singleProperty(test, 
1:                 "derby.storage.rowLocking", "false", true);
1:         test = new LocaleTestSetup(test, Locale.ENGLISH);
1:         return TestConfiguration.singleUseDatabaseDecorator(test);
1:     }
1:     
1:     protected void setUp() throws SQLException {            
1:             Statement s = createStatement();
1:             s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:                     + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME "
1:                     + "'org.apache.derbyTesting.functionTests.util.Formatters"
1:                     + ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:             createLockTableQueryEntries(s);
1:             s.close();
1:             
1:             getConnection().setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:             getConnection().setAutoCommit(false);
1:     }
1:     
1:     private void createLockTableQueryEntries(Statement s) throws SQLException {
1:         s.execute("create view lock_table as "
1:                 + "select "
1:                 + "cast(username as char(8)) as username,"
1:                 + "cast(t.type as char(8)) as trantype,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode,"
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state,"
1:                 + "status "
1:                 + "from "
1:                 + "syscs_diag.lock_table l  right outer join syscs_diag.transaction_table t "
1:                 + "on l.xid = t.xid where l.tableType <> 'S' and t.type='UserTransaction'");
1:         
1:         //lock table with system catalog locks included.
1:         s.execute("create view full_lock_table as "
1:                 + "select "
1:                 + "cast(username as char(8)) as username, "
1:                 + "cast(t.type as char(8)) as trantype,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode, "
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state,"
1:                 + "status "
1:                 + "from "
1:                 + "syscs_diag.lock_table l right outer join syscs_diag.transaction_table t "
1:                 + "on l.xid = t.xid where l.tableType <> 'S' ");
1:         
1:         //lock table with no join.
1:         s.execute("create view lock_table2 as "
1:                 + "select "
1:                 + "cast(l.xid as char(8)) as xid,"
1:                 + "cast(l.type as char(8)) as type,"
1:                 + "cast(lockcount as char(3)) as cnt,"
1:                 + "mode,"
1:                 + "cast(tablename as char(12)) as tabname,"
1:                 + "cast(lockname as char(10)) as lockname,"
1:                 + "state "
1:                 + "from "
1:                 + "syscs_diag.lock_table l "
1:                 + "where l.tableType <> 'S' ");
1:         
1:         //-- transaction table with no join.
1:         s.execute("create view tran_table as "
1:                 + "select "
1:                 + "* "
1:                 + "from "
1:                 + "syscs_diag.transaction_table");        
1:     }
1: 
1:     public void tearDown() throws Exception {
1:         Statement st = createStatement();
1:         st.executeUpdate("DROP FUNCTION PADSTRING");
1:         
1:         st.execute("drop view lock_table");
1:         st.execute("drop view full_lock_table");
1:         st.execute("drop view lock_table2");
1:         st.execute("drop view tran_table");
1:         
1:         st.close();
1:         commit();
1:         
1:         super.tearDown();
1:     }
1:     
1:     public void testInsertIntoHeap() throws SQLException {
1:         Statement st = createStatement();
1:         st.execute("create table heap_only (a int)");
1:         commit();    
1: 
1:         //Test insert into empty heap, should just get table lock
1:         st.execute("insert into heap_only values (1)");        
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1:         
1:         
1:         //Test insert into heap with one row, just get table lock
1:         st.execute("insert into heap_only values (2)");        
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1:         
1:         
1:         st.close();        
1:         dropTable("heap_only");
1:     }
1: 
1:     /**
1:      * Test select from a heap, should get shared table lock.
1:      */
1:     public void testSelectFromHeap () throws SQLException { 
1:         Statement st = createStatement();        
1:         constructHeap(st);
1:                 
1:         ResultSet rs = st.executeQuery("select a from heap_only where a = 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:         });
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "S", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"}
1:         });
1:         commit();
1: 
1:         st.close();
1:         dropTable("heap_only");
1:     }
1: 
1:     private void constructHeap(Statement st) throws SQLException {
1:         st.execute("create table heap_only (a int)");
1:         commit();    
1:         
1:         st.execute("insert into heap_only values (1)");
1:         commit();
1:         st.execute("insert into heap_only values (2)");
1:         commit();
1:     }
1: 
1:     /**
1:      * Test delete from a heap, should get exclusive table lock.
1:      */
1:     public void testDelectFromHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructHeap(st);
1:         
1:         st.execute("delete from heap_only where a = 1");
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         dropTable("heap_only");
1:     }
1:     
1:     /**
1:      * Test update to heap, should get exclusive table lock.
1:      */
1:     public void testUpdateToHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructHeap(st);
1:         
1:         st.execute("update heap_only set a = 1000 where a = 2");
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "2", "X", "HEAP_ONLY", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         dropTable("heap_only");
1:     }
1: 
1:     /**
1:      * Test drop of heap, should get exclusive table lock.
1:      */
1:     public void testDropHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructHeap(st);
1:         
1:         st.execute("drop table heap_only");
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "3", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         dropTable("heap_only");
1:     }
1:     
1:     public void testCreateIndex() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', '4096')");
1:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', NULL)");
1:         
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1:                 
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', '4096')");
1:         st.execute("create index a_idx on indexed_heap (a, b)");
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', NULL)");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "4", "S", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "1", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},        });
1:         commit();
1:         
1:         st.close();
1:         
1:         dropTable("indexed_heap");
1:     }
1: 
1:     public void testInsertIntoEmtpyIndexedHeaP() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:         commit();
1:         st.execute("create index a_idx on indexed_heap (a, b)");
1:         commit();
1: 
1:         // Test insert into indexed heap, should just get table lock
1:         st.execute("insert into indexed_heap (a) values (1)");
1:         ResultSet rs = st.executeQuery(" select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][] { 
1:                 {"APP", "UserTran", "TABLE", "2", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"}, 
1:         });
1:         commit();
1: 
1:         // Test insert into indexed heap with one row, just get table lock
1:         st.execute("insert into indexed_heap (a) values (2)");
1:         rs = st.executeQuery(" select * from lock_table order by tabname, type "
1:                         + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][] { 
1:                 {"APP", "UserTran", "TABLE", "2", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"} 
1:         });
1:         commit();
1: 
1:         st.close();
1:         
1:         dropTable("indexed_heap");
1:     }
1:     
1:     /**
1:      * Test select from a indexed heap, should get shared table lock.
1:      */
1:     public void testSelectFromIndexedHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructIndexedHeap(st);
1:                
1:         ResultSet rs = st.executeQuery("select a from indexed_heap where a = 1");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"},
1:         });
1:         
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "S", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         
1:         dropTable("indexed_heap");
1:     }
1: 
1:     private void constructIndexedHeap(Statement st) throws SQLException {
1:         st.execute("create table indexed_heap (a int, b varchar(1000))");
1:         st.execute("create index a_idx on indexed_heap (a, b)");
1: 
1:         st.execute("insert into indexed_heap (a) values (1)");
1:         st.execute("insert into indexed_heap (a) values (2)");
1:         
1:         commit();
1:     }
1:     
1:     /**
1:      * Test delete from a indexed heap, should get exclusive table lock.
1:      */
1:     public void testDeleteFromIndexedHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructIndexedHeap(st);
1:                
1:         st.execute("delete from indexed_heap where a = 1");
1: 
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "3", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         
1:         dropTable("indexed_heap");
1:     }
1: 
1:     /**
1:      * Test update to indexed heap, should get exclusive table lock.
1:      */
1:     public void testUpdateToIndexedHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructIndexedHeap(st);
1:                
1:         st.execute("update indexed_heap set a = 1000 where a = 2");
1: 
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "4", "X", "INDEXED_HEAP", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:         
1:         dropTable("indexed_heap");
1:     }
1:     
1:     /**
1:      * Test drop of indexed heap, should get exclusive table lock.
1:      */
1:     public void testDropIndexedHeap () throws SQLException { 
1:         Statement st = createStatement();
1:         constructIndexedHeap(st);
1:                
1:         st.execute("drop table indexed_heap");
1: 
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:                 {"APP", "UserTran", "TABLE", "4", "X", "*** TRANSIEN", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         commit();
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test LOCK TABLE statement
1:      */
1:     public void testLockTableStatement() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         st.execute("create table t1(c1 int)");
1:         commit();        
1:         
1:         PreparedStatement pst = prepareStatement("lock table t1 in exclusive mode");
1:         pst.execute();
1:         
1:         ResultSet rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "X", "T1", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         
1:         //verify that statement gets recompiled correctly
1:         st.execute("drop table t1");
1:         st.execute("create table t1(c1 int)");
1:         pst.execute();
1:         commit();
1:         
1:         st.execute("lock table t1 in share mode");
1:         rs = st.executeQuery(
1:                 " select * from lock_table order by tabname, type "
1:                 + "desc, mode, cnt, lockname");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"APP", "UserTran", "TABLE", "1", "S", "T1", "Tablelock", "GRANT", "ACTIVE"},
1:         });
1:         
1:         st.execute("drop table t1");
1:         commit();
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * verify that lock table not allowed in sys schema
1:      */
1:     public void testLockTableInSysSchema() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42X62", st,
1:                 "lock table sys.systables in exclusive mode");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test RTS output when table locking configured
1:      */
1:     public void testRTSOutput() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         st.execute("create table rts(c1 int)");
1:         st.execute("insert into rts values 1");
1:         commit();
1:         
1:         ResultSet rs = st.executeQuery("select * from rts with cs");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"1"}
1:         });
1:         
1:         rs =  st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C3\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from rts with cs\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for RTS at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 1\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n"
1:                     + "	next time in milliseconds/row = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=1\n"
1:                     + "	Number of rows visited=1\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 },
1:         });
1: 
1:         st.execute("drop table rts");
1:         commit();
1:         
1:         st.close();
1:     }
1: 
1:     public void testDDLTableLockMode() throws SQLException {
1:         Statement st = createStatement();
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         st.execute("create table default_granularity(c1 int)");
1:         st.execute("create table row_granularity(c1 int)");
1:         st.execute("alter table row_granularity locksize row");
1:         st.execute("create table table_granularity(c1 int)");
1:         st.execute("alter table table_granularity locksize table");
1:         
1:         ResultSet rs = st.executeQuery("select * from default_granularity with cs");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from default_granularity with cs\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1:         
1:         rs = st.executeQuery("select * from default_granularity with rr");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from default_granularity with rr\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1:         rs = st.executeQuery("select * from default_granularity with cs");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from default_granularity with cs\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for DEFAULT_GRANULARITY at read committed isolation level using instantaneous share row locking chosen by the optimizer (Actual locking used: table level locking.)\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1:         
1:         rs = st.executeQuery("select * from row_granularity with rr");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from row_granularity with rr\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for ROW_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1:         
1:         rs = st.executeQuery("select * from table_granularity with cs");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from table_granularity with cs\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for TABLE_GRANULARITY at read committed isolation level using instantaneous share table locking chosen by the optimizer\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1:         
1:         rs = st.executeQuery("select * from table_granularity with rr");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = st.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         JDBC.assertFullResultSet(rs, new String[][]{
1:                 {"Statement Name: \n"
1:                     + "	" + (getTestConfiguration().getJDBCClient().isEmbedded() ? "null\n" : "SQL_CURLH000C2\n")
1:                     + "Statement Text: \n"
1:                     + "	select * from table_granularity with rr\n"
1:                     + "Parse Time: 0\n"
1:                     + "Bind Time: 0\n"
1:                     + "Optimize Time: 0\n"
1:                     + "Generate Time: 0\n"
1:                     + "Compile Time: 0\n"
1:                     + "Execute Time: 0\n"
1:                     + "Begin Compilation Timestamp : null\n"
1:                     + "End Compilation Timestamp : null\n"
1:                     + "Begin Execution Timestamp : null\n"
1:                     + "End Execution Timestamp : null\n"
1:                     + "Statement Execution Plan Text: \n"
1:                     + "Table Scan ResultSet for TABLE_GRANULARITY at serializable isolation level using share table locking chosen by the optimizer\n"
1:                     + "Number of opens = 1\n"
1:                     + "Rows seen = 0\n"
1:                     + "Rows filtered = 0\n"
1:                     + "Fetch Size = 16\n"
1:                     + "	constructor time (milliseconds) = 0\n"
1:                     + "	open time (milliseconds) = 0\n"
1:                     + "	next time (milliseconds) = 0\n"
1:                     + "	close time (milliseconds) = 0\n\n"
1:                     + "scan information:\n"
1:                     + "	Bit set of columns fetched=All\n"
1:                     + "	Number of columns fetched=1\n"
1:                     + "	Number of pages visited=1\n"
1:                     + "	Number of rows qualified=0\n"
1:                     + "	Number of rows visited=0\n"
1:                     + "	Scan type=heap\n"
1:                     + "	start position:\n"
1:                     + "		null\n"
1:                     + "	stop position:\n"
1:                     + "		null\n"
1:                     + "	qualifiers:\n"
1:                     + "		None\n"
0:                     + "	optimizer estimated row count:            6.00\n"
0:                     + "	optimizer estimated cost:          100.40"
1:                 }
1:         }        
1:         );
1:         
1: 
1:         st.close();
1:         rollback();
1:     }
1: 
1: }
============================================================================