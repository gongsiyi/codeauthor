1:166e695: /*
3:166e695: 
1:166e695:    Derby - Class org.apache.derby.security.DatabasePermission
1:166e695: 
1:166e695:    Licensed to the Apache Software Foundation (ASF) under one or more
1:166e695:    contributor license agreements.  See the NOTICE file distributed with
1:166e695:    this work for additional information regarding copyright ownership.
1:166e695:    The ASF licenses this file to You under the Apache License, Version 2.0
1:166e695:    (the "License"); you may not use this file except in compliance with
1:166e695:    the License.  You may obtain a copy of the License at
1:166e695: 
1:166e695:       http://www.apache.org/licenses/LICENSE-2.0
1:166e695: 
1:166e695:    Unless required by applicable law or agreed to in writing, software
1:166e695:    distributed under the License is distributed on an "AS IS" BASIS,
1:166e695:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:166e695:    See the License for the specific language governing permissions and
1:166e695:    limitations under the License.
1:166e695: 
1:166e695:  */
1:166e695: 
1:166e695: package org.apache.derby.security;
1:166e695: 
1:166e695: import java.security.Permission;
1:c0052e0: import java.security.PrivilegedAction;
1:c0052e0: import java.security.PrivilegedExceptionAction;
1:c0052e0: import java.security.PrivilegedActionException;
1:c0052e0: import java.security.AccessController;
1:166e695: 
1:3c23476: import java.util.ArrayList;
1:3c23476: import java.util.List;
1:166e695: import java.util.Set;
1:166e695: 
1:166e695: import java.io.File;
1:166e695: import java.io.IOException;
1:166e695: import java.io.ObjectInputStream;
1:166e695: import java.io.ObjectOutputStream;
1:166e695: 
1:166e695: 
1:166e695: /**
1:166e695:  * This class represents access to database-scoped privileges.
1:166e695:  *
1:166e695:  * An example of database-scoped privileges is the permission to create
1:166e695:  * a database under a specified directory path.
1:166e695:  * <p>
1:166e695:  * A DatabasePermission is defined by two string attributes, similar to
1:166e695:  * a java.io.FilePermission:
1:166e695:  * <ul>
1:166e695:  * <li> <i>URL</i> - a location description of or for a Derby database
1:166e695:  * <li> <i>Actions</i> - a list of granted administrative actions
1:166e695:  * </ul>
1:166e695:  * The database location URL may contain certain wildcard characters.
1:166e695:  * The currently only supported database action is <i>create</i>.
1:166e695:  *
1:a469215:  * @see DatabasePermission#DatabasePermission(String,String)
1:166e695:  * @see SystemPermission
1:166e695:  * @see java.io.FilePermission
1:166e695:  */
1:c0052e0: final public class DatabasePermission extends Permission {
1:166e695: 
1:166e695:     /**
1:166e695:      * The URL protocol scheme specifying a directory location.
1:166e695:      */
1:166e695:     static public final String URL_PROTOCOL_DIRECTORY = "directory:";
1:166e695: 
1:166e695:     /**
1:c0052e0:      * The location text matching any database anywhere.
1:c0052e0:      */
1:c0052e0:     static public final String URL_PATH_INCLUSIVE_STRING = "<<ALL FILES>>";
1:166e695: 
1:c0052e0:     /**
1:c0052e0:      * The path type character matching any database anywhere.
1:c0052e0:      */
1:c0052e0:     static public final char URL_PATH_INCLUSIVE_CHAR = 'I';
1:166e695: 
1:c0052e0:     /**
1:166e695:      * The URL file path separator character.
1:166e695:      */
1:166e695:     static public final char URL_PATH_SEPARATOR_CHAR = '/';
1:166e695: 
1:166e695:     /**
1:166e695:      * The relative path character.
1:166e695:      */
1:166e695:     static public final char URL_PATH_RELATIVE_CHAR = '.';
1:166e695: 
1:166e695:     /**
1:c0052e0:      * The wildcard character matching any database in a directory.
1:166e695:      */
1:166e695:     static public final char URL_PATH_WILDCARD_CHAR = '*';
1:166e695: 
1:166e695:     /**
1:c0052e0:      * The wildcard character matching any database under a directory
1:c0052e0:      * or its subdirectories.
1:166e695:      */
1:166e695:     static public final char URL_PATH_RECURSIVE_CHAR = '-';
1:166e695: 
1:166e695:     // derived path type constants
1:166e695:     static public final String URL_PATH_SEPARATOR_STRING
1:166e695:         = String.valueOf(URL_PATH_SEPARATOR_CHAR);
1:166e695:     static public final String URL_PATH_RELATIVE_STRING
1:166e695:         = String.valueOf(URL_PATH_RELATIVE_CHAR);
1:166e695:     static public final String URL_PATH_RELATIVE_PREFIX
1:166e695:         = (URL_PATH_RELATIVE_STRING + URL_PATH_SEPARATOR_CHAR);
1:166e695:     static public final String URL_PATH_WILDCARD_STRING
1:166e695:         = String.valueOf(URL_PATH_WILDCARD_CHAR);
1:166e695:     static public final String URL_PATH_WILDCARD_SUFFIX
1:166e695:         = (URL_PATH_SEPARATOR_STRING + URL_PATH_WILDCARD_CHAR);
1:166e695:     static public final String URL_PATH_RECURSIVE_STRING
1:166e695:         = String.valueOf(URL_PATH_RECURSIVE_CHAR);
1:166e695:     static public final String URL_PATH_RECURSIVE_SUFFIX
1:166e695:         = (URL_PATH_SEPARATOR_STRING + URL_PATH_RECURSIVE_CHAR);
1:166e695: 
1:166e695:     /**
1:166e695:      * The create database permission.
1:166e695:      */
1:166e695:     static public final String CREATE = "create";
1:166e695: 
1:166e695:     /**
1:166e695:      * The legal database permission action names.
1:166e695:      */
1:3c23476:     static protected final List<String> LEGAL_ACTIONS = new ArrayList<String>();
1:166e695:     static {
1:09c890c:         // when adding new actions, check: implies(Permission), getActions()
1:166e695:         LEGAL_ACTIONS.add(CREATE);
1:166e695:     };
1:166e695: 
1:166e695:     /**
1:3c23476:      * The actions of this permission, as returned by {@link #getActions()}.
1:166e695:      */
1:3c23476:     private String actions;
1:166e695: 
1:166e695:     /**
1:166e695:      * This permission's canonical directory path.
1:166e695:      *
1:166e695:      * The path consists of a canonicalized form of the user-specified URL,
1:166e695:      * stripped off the protocol specification and any recursive/wildcard
1:c0052e0:      * characters, or {@code "<<ALL FILES>>"} for the "anywhere" permission.
1:c0052e0:      * The canonical path is used when testing permissions with implies(),
1:c0052e0:      * where real directory locations, not just notational differences,
1:c0052e0:      * ought to be compared.  Analog to java.io.FilePermission, the
1:c0052e0:      * canonical path is also used by equals() and hashCode() to support
1:166e695:      * hashing and mapping of permissions by their real directory locations.
1:166e695:      *
1:166e695:      * Because canonical file paths are platform dependent, this field
1:166e695:      * must not be serialized (hence transient) but be recomputed from
1:166e695:      * the original URL upon deserialization.
1:166e695:      */
1:166e695:     private transient String path;
1:166e695: 
1:166e695:     /**
1:166e695:      * The parent directory of this permission's canonical directory path,
1:c0052e0:      * or null if this permission's path does not have a parent directory.
1:166e695:      *
1:166e695:      * Because canonical file paths are platform dependent, this field
1:166e695:      * must not be serialized (hence transient) but be recomputed from
1:166e695:      * the original URL upon deserialization.
1:166e695:      */
1:166e695:     private transient String parentPath;
1:166e695: 
1:166e695:     /**
1:c0052e0:      * Indicates whether the path denotes an inclusive, recursive, wildcard,
1:c0052e0:      * or single location.
1:166e695:      *
1:c0052e0:      * If the path denotes an inclusive, recursive or wildcard location,
1:c0052e0:      * this field's value is URL_PATH_INCLUSIVE_CHAR, URL_PATH_RECURSIVE_CHAR,
1:c0052e0:      * or URL_PATH_WILDCARD_CHAR, respectively; otherwise, it's
1:c0052e0:      * URL_PATH_SEPARATOR_CHAR denoting a single location.
1:3c23476:      *
1:3c23476:      * This field gets recomputed upon deserialization.
1:166e695:      */
1:3c23476:     private transient char pathType;
1:166e695: 
1:166e695:     /**
1:166e695:      * Creates a new DatabasePermission with the specified URL and actions.
1:166e695:      * <P>
1:166e695:      * <i>actions</i> contains a comma-separated list of the desired actions
1:166e695:      * granted on a database. Currently, the only supported action is
1:166e695:      * <code>create</code>.
1:166e695:      * <P>
1:166e695:      * <i>URL</i> denotes a database location URL, which, at this time, must
1:166e695:      * start with <code>directory:</code> followed by a directory pathname.
1:166e695:      * Note that in a URL, the separator character is always "/" rather than
1:166e695:      * the file separator of the operating-system.  The directory path may
1:166e695:      * be absolute or relative, in which case it is prefixed with the current
1:166e695:      * user directory. In addition, similar to java.io.FilePermission, the
1:166e695:      * directory pathname may end with a wildcard character to allow for
1:166e695:      * arbitrarily named databases under a path:
1:166e695:      * <ul>
1:166e695:      * <li> "directory:location" - refers to a database called
1:166e695:      *      <i>location</i>,
1:c0052e0:      * <li> "directory:location/*" - matches any database in the
1:166e695:      *      directory <i>location</i>,
1:c0052e0:      * <li> "directory:location/-" - matches any database under
1:166e695:      *      <i>location</i> or its subdirectories.
1:c0052e0:      * <li> "directory:*" - matches any database in the user's current
1:166e695:      *      working directory.
1:c0052e0:      * <li> "directory:-" - matches any database under the
1:166e695:      *      user's current working directory or its subdirectories.
1:c0052e0:      * <li> {@code "directory:<<ALL FILES>>"} matches any database anywhere.
1:166e695:      * </ul>
1:166e695:      *
1:166e695:      * @param url the database URL
1:166e695:      * @param actions the action string
1:166e695:      * @throws NullPointerException if an argument is null
1:166e695:      * @throws IllegalArgumentException if an argument is not legal
1:166e695:      * @throws IOException if the location URL cannot be canonicalized
1:a469215:      * @see Permission#Permission(String)
1:a469215:      * @see java.io.FilePermission#FilePermission(String,String)
1:166e695:      */
1:166e695:     public DatabasePermission(String url, String actions)
1:166e695:         throws IOException {
1:166e695:         super(url);
1:166e695:         initActions(actions);
2:166e695:         initLocation(url);
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Parses the list of database actions.
1:166e695:      *
1:166e695:      * @param actions the comma-separated action list
1:166e695:      * @throws NullPointerException if actions is null
1:166e695:      * @throws IllegalArgumentException if not a list of legal actions
1:166e695:      */
1:166e695:     protected void initActions(String actions) {
1:166e695:         // analog to java.security.BasicPermission, we check that actions
1:166e695:         // is not null nor empty
1:166e695:         if (actions == null) {
1:166e695:             throw new NullPointerException("actions can't be null");
1:166e695:         }
1:166e695:         if (actions.length() == 0) {
1:166e695:             throw new IllegalArgumentException("actions can't be empty");
1:166e695:         }
1:166e695: 
1:3c23476:         // Get all the actions specified in the actions string
1:3c23476:         Set<String> actionSet = SystemPermission.parseActions(actions);
1:3c23476: 
1:166e695:         // check for any illegal actions
1:3c23476:         for (String action : actionSet) {
1:166e695:             if (!LEGAL_ACTIONS.contains(action)) {
1:166e695:                 // report illegal action
1:166e695:                 final String msg = "Illegal action '" + action + "'";
1:166e695:                 throw new IllegalArgumentException(msg);
1:166e695:             }
1:166e695:         }
1:3c23476: 
1:3c23476:         // Get all the legal actions that are in actionSet, in the order
1:3c23476:         // of LEGAL_ACTIONS.
1:3c23476:         List<String> legalActions = new ArrayList<String>(LEGAL_ACTIONS);
1:3c23476:         legalActions.retainAll(actionSet);
1:3c23476: 
1:3c23476:         this.actions = SystemPermission.buildActionsString(legalActions);
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Parses the database location URL.
1:166e695:      *
1:166e695:      * @param url the database URL
1:166e695:      * @throws NullPointerException if the URL is null
1:166e695:      * @throws IllegalArgumentException if the URL is not well-formed
1:166e695:      * @throws IOException if the location URL cannot be canonicalized
1:166e695:      */
1:166e695:     protected void initLocation(String url)
1:166e695:         throws IOException {
1:166e695:         // analog to java.security.BasicPermission, we check that URL
1:166e695:         // is not null nor empty
1:166e695:         if (url == null) {
1:166e695:             throw new NullPointerException("URL can't be null");
1:166e695:         }
1:166e695:         if (url.length() == 0) {
1:166e695:             throw new IllegalArgumentException("URL can't be empty");
1:166e695:         }
1:166e695: 
1:166e695:         // check URL's protocol scheme and initialize path
1:166e695:         if (!url.startsWith(URL_PROTOCOL_DIRECTORY)) {
1:166e695:             final String msg = "Unsupported protocol in URL '" + url + "'";
1:166e695:             throw new IllegalArgumentException(msg);
1:166e695:         }
1:166e695:         String p = url.substring(URL_PROTOCOL_DIRECTORY.length());
1:166e695: 
1:c0052e0:         // check path for inclusive/relative/recursive/wildcard specifications,
1:166e695:         // split path into real pathname and the path type
1:c0052e0:         if (p.equals(URL_PATH_INCLUSIVE_STRING)) {
1:c0052e0:             // inclusive:  "<<ALL FILES>>" --> 'I', "<<ALL FILES>>"
1:c0052e0:             pathType = URL_PATH_INCLUSIVE_CHAR;
1:c0052e0:             // p = p;
1:c0052e0:         } else if (p.equals(URL_PATH_RECURSIVE_STRING)) {
1:166e695:             // relative & recursive:  "-" --> '-', "./"
1:166e695:             pathType = URL_PATH_RECURSIVE_CHAR;
1:166e695:             p = URL_PATH_RELATIVE_PREFIX;
1:166e695:         } else if (p.equals(URL_PATH_WILDCARD_STRING)) {
1:166e695:             // relative & wildcard:   "*" --> '*', "./"
1:166e695:             pathType = URL_PATH_WILDCARD_CHAR;
1:166e695:             p = URL_PATH_RELATIVE_PREFIX;
1:166e695:         } else if (p.endsWith(URL_PATH_RECURSIVE_SUFFIX)) {
1:166e695:             // absolute & recursive:  "<path>/-" --> '-', "<path>/"
1:166e695:             pathType = URL_PATH_RECURSIVE_CHAR;
1:166e695:             p = p.substring(0, p.length() - 1);
1:166e695:         } else if (p.endsWith(URL_PATH_WILDCARD_SUFFIX)) {
1:166e695:             // absolute & wildcard:   "<path>/*" --> '*', "<path>/"
1:166e695:             pathType = URL_PATH_WILDCARD_CHAR;
1:166e695:             p = p.substring(0, p.length() - 1);
1:166e695:         } else {
1:166e695:             // absolute | relative:   "<path>" --> '/', "<path>"
1:166e695:             pathType = URL_PATH_SEPARATOR_CHAR;
1:166e695:             // p = p;
1:166e695:         }
1:166e695: 
1:c0052e0:         // canonicalize the path and assign parentPath
1:c0052e0:         if (pathType == URL_PATH_INCLUSIVE_CHAR) {
1:c0052e0:             path = URL_PATH_INCLUSIVE_STRING;
1:c0052e0:             //assert(parentPath == null);
1:c0052e0:         } else {
1:c0052e0:             // resolve against user's working directory if relative pathname;
1:c0052e0:             // the read access to the system property is encapsulated in a
1:c0052e0:             // doPrivileged() block to allow for confined codebase permission
1:c0052e0:             // grants
1:166e695:             if (p.startsWith(URL_PATH_RELATIVE_PREFIX)) {
1:400f6eb:                 final String cwd = AccessController.doPrivileged(
1:400f6eb:                     new PrivilegedAction<String>() {
1:400f6eb:                         public String run() {
1:c0052e0:                             return System.getProperty("user.dir");
1:c0052e0:                         }
1:c0052e0:                     });
1:166e695:                 // concatenated path "<cwd>/./<path>" will be canonicalized
1:166e695:                 p = cwd + URL_PATH_SEPARATOR_STRING + p;
1:166e695:             }
1:c0052e0:             final String absPath = p;
1:166e695: 
1:166e695:             // store canonicalized path as required for implies(Permission);
1:c0052e0:             // may throw IOException; canonicalization reads the "user.dir"
1:c0052e0:             // system property, which we encapsulate in a doPrivileged()
1:c0052e0:             // block to allow for confined codebase permission grants
1:c0052e0:             final File f;
1:c0052e0:             try {
1:400f6eb:                 f = AccessController.doPrivileged(
1:400f6eb:                     new PrivilegedExceptionAction<File>() {
1:400f6eb:                         public File run() throws IOException {
1:c0052e0:                             return (new File(absPath)).getCanonicalFile();
1:c0052e0:                         }
1:c0052e0:                     });
1:c0052e0:             } catch (PrivilegedActionException pae) {
1:c0052e0:                 // pae.getCause() should be an instance of IOException,
1:c0052e0:                 // as only checked exceptions will be wrapped
1:c0052e0:                 throw (IOException)pae.getCause();
1:c0052e0:             }
1:c0052e0:             path = f.getPath();
1:166e695: 
1:166e695:             // store canonicalized path of parent file as required for
1:166e695:             // implies(Permission); may throw IOException; note that
1:166e695:             // the path already denotes parent directory if of wildcard type:
1:166e695:             // for example, the parent of "/a/-" or "/a/*" is "/a"
1:c0052e0:             parentPath = ((pathType != URL_PATH_SEPARATOR_CHAR)
1:166e695:                           ? path : f.getParent());
1:166e695:         }
1:166e695: 
1:c0052e0:         //assert(pathType == URL_PATH_SEPARATOR_CHAR
1:c0052e0:         //       || pathType == URL_PATH_WILDCARD_CHAR
1:c0052e0:         //       || pathType == URL_PATH_RECURSIVE_CHAR
1:c0052e0:         //       || pathType == URL_PATH_INCLUSIVE_CHAR);
1:c0052e0:         //assert(path != null);
1:c0052e0:         //assert(parentPath == null || parentPath != null);
1:c0052e0:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Checks if this DatabasePermission implies a specified permission.
1:166e695:      * <P>
1:166e695:      * This method returns true if:<p>
1:166e695:      * <ul>
1:166e695:      * <li> <i>p</i> is an instanceof DatabasePermission and<p>
1:166e695:      * <li> <i>p</i>'s directory pathname is implied by this object's
1:166e695:      *      pathname. For example, "/tmp/*" implies "/tmp/foo", since
1:166e695:      *      "/tmp/*" encompasses the "/tmp" directory and all files in that
1:166e695:      *      directory, including the one named "foo".
1:166e695:      * </ul>
1:166e695:      * @param p the permission to check against
1:166e695:      * @return true if the specified permission is implied by this object,
1:166e695:      * false if not
1:a469215:      * @see Permission#implies(Permission)
1:166e695:      */
1:166e695:     public boolean implies(Permission p) {
1:166e695:         // can only imply other DatabasePermissions
1:166e695:         if (!(p instanceof DatabasePermission)) {
1:166e695:             return false;
1:166e695:         }
1:166e695:         final DatabasePermission that = (DatabasePermission)p;
1:166e695: 
1:c0052e0:         // an inclusive permission implies any other
1:c0052e0:         if (this.pathType == URL_PATH_INCLUSIVE_CHAR) {
1:c0052e0:             return true;
1:c0052e0:         }
1:c0052e0:         //assert(this.pathType != URL_PATH_INCLUSIVE_CHAR);
1:166e695: 
1:c0052e0:         // a non-inclusive permission cannot imply an inclusive one
1:c0052e0:         if (that.pathType == URL_PATH_INCLUSIVE_CHAR) {
1:c0052e0:             return false;
1:c0052e0:         }
1:c0052e0:         //assert(that.pathType != URL_PATH_INCLUSIVE_CHAR);
1:166e695: 
1:166e695:         // a recursive permission implies any other if a path prefix
1:166e695:         if (this.pathType == URL_PATH_RECURSIVE_CHAR) {
1:166e695:             return (that.parentPath != null
1:166e695:                     && that.parentPath.startsWith(this.path));
1:166e695:         }
1:c0052e0:         //assert(this.pathType != URL_PATH_RECURSIVE_CHAR);
1:166e695: 
1:166e695:         // a non-recursive permission cannot imply a recursive one
1:166e695:         if (that.pathType == URL_PATH_RECURSIVE_CHAR) {
1:166e695:             return false;
1:166e695:         }
1:c0052e0:         //assert(that.pathType != URL_PATH_RECURSIVE_CHAR);
1:166e695: 
1:166e695:         // a wildcard permission implies another if a parent directory
1:166e695:         if (this.pathType == URL_PATH_WILDCARD_CHAR) {
1:166e695:             return this.path.equals(that.parentPath);
1:166e695:         }
1:c0052e0:         //assert(this.pathType != URL_PATH_WILDCARD_CHAR);
1:166e695: 
1:166e695:         // a non-wildcard permission cannot imply a wildcard one
1:166e695:         if (that.pathType == URL_PATH_WILDCARD_CHAR) {
1:166e695:             return false;
1:166e695:         }
1:c0052e0:         //assert(that.pathType != URL_PATH_WILDCARD_CHAR);
1:166e695: 
1:166e695:         // non-recursive, non-wildcard permissions imply when paths are equal
1:c0052e0:         //assert(this.pathType == URL_PATH_SEPARATOR_CHAR);
1:c0052e0:         //assert(that.pathType == URL_PATH_SEPARATOR_CHAR);
1:166e695:         return this.path.equals(that.path);
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Checks two DatabasePermission objects for equality.
1:166e695:      * <P>
1:166e695:      * Checks that <i>obj</i> is a DatabasePermission and has the same
1:166e695:      * canonizalized URL and actions as this object.
1:166e695:      * <P>
1:166e695:      * @param obj the object we are testing for equality with this object
1:166e695:      * @return true if obj is a DatabasePermission, and has the same URL and
1:166e695:      * actions as this DatabasePermission object, false if not
1:166e695:      *
1:a469215:      * @see Permission#equals(Object)
1:166e695:      */
1:166e695:     public boolean equals(Object obj) {
1:166e695:         if (obj == this) {
1:166e695:             return true;
1:166e695:         }
1:166e695: 
1:166e695:         if (!(obj instanceof DatabasePermission)) {
1:166e695:             return false;
1:166e695:         }
1:166e695:         final DatabasePermission that = (DatabasePermission)obj;
1:166e695: 
1:166e695:         // compare canonicalized URLs
1:c0052e0:         return (pathType == that.pathType && path.equals(that.path));
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Returns the hash code value for this object.
1:166e695:      *
1:166e695:      * @return a hash code value for this object
1:a469215:      * @see Permission#hashCode()
1:166e695:      */
1:166e695:     public int hashCode() {
1:166e695:         // hash canonicalized URL
1:166e695:         return (path.hashCode() ^ pathType);
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Returns the "canonical string representation" of the actions.
1:166e695:      *
1:166e695:      * @return the canonical string representation of the actions
1:a469215:      * @see Permission#getActions()
1:166e695:      */
1:166e695:     public String getActions() {
1:3c23476:         return actions;
1:166e695:     }
1:166e695: 
1:166e695: 
1:166e695:     /**
1:166e695:      * Called upon Serialization for saving the state of this
1:166e695:      * DatabasePermission to a stream.
1:166e695:      */
1:166e695:     private void writeObject(ObjectOutputStream s)
1:166e695:         throws IOException {
1:166e695:         // write the non-static and non-transient fields to the stream
1:166e695:         s.defaultWriteObject();
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Called upon Deserialization for restoring the state of this
1:166e695:      * DatabasePermission from a stream.
1:166e695:      */
1:166e695:     private void readObject(ObjectInputStream s)
1:166e695:          throws IOException, ClassNotFoundException
1:166e695:     {
1:166e695:         // read the non-static and non-transient fields from the stream
1:166e695:         s.defaultReadObject();
1:3c23476: 
1:3c23476:         // Validate the URL read from the object stream, and
1:166e695:         // restore the platform-dependent path from the original URL
1:3c23476:         initLocation(getName());
1:3c23476: 
1:3c23476:         // Validate and normalize the actions read from the stream.
1:3c23476:         initActions(getActions());
1:166e695:     }
1:166e695: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3c23476
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     static protected final List<String> LEGAL_ACTIONS = new ArrayList<String>();
1:      * The actions of this permission, as returned by {@link #getActions()}.
1:     private String actions;
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * This field gets recomputed upon deserialization.
1:     private transient char pathType;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Get all the actions specified in the actions string
1:         Set<String> actionSet = SystemPermission.parseActions(actions);
1: 
1:         for (String action : actionSet) {
1: 
1:         // Get all the legal actions that are in actionSet, in the order
1:         // of LEGAL_ACTIONS.
1:         List<String> legalActions = new ArrayList<String>(LEGAL_ACTIONS);
1:         legalActions.retainAll(actionSet);
1: 
1:         this.actions = SystemPermission.buildActionsString(legalActions);
/////////////////////////////////////////////////////////////////////////
1:         return actions;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Validate the URL read from the object stream, and
1:         initLocation(getName());
1: 
1:         // Validate and normalize the actions read from the stream.
1:         initActions(getActions());
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
0:     static protected final Set<String> LEGAL_ACTIONS = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1:                 final String cwd = AccessController.doPrivileged(
1:                     new PrivilegedAction<String>() {
1:                         public String run() {
/////////////////////////////////////////////////////////////////////////
1:                 f = AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<File>() {
1:                         public File run() throws IOException {
commit:09c890c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.StringUtil;
0: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:         // when adding new actions, check: implies(Permission), getActions()
/////////////////////////////////////////////////////////////////////////
0:         actions = actions.toLowerCase(Locale.ENGLISH);
0:         final String[] s = StringUtil.split(actions, ',');
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:166e695
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.security.DatabasePermission
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.security;
1: 
1: import java.security.Permission;
1: 
1: import java.util.Set;
0: import java.util.HashSet;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: 
1: 
1: /**
1:  * This class represents access to database-scoped privileges.
1:  *
1:  * An example of database-scoped privileges is the permission to create
1:  * a database under a specified directory path.
1:  * <p>
1:  * A DatabasePermission is defined by two string attributes, similar to
1:  * a java.io.FilePermission:
1:  * <ul>
1:  * <li> <i>URL</i> - a location description of or for a Derby database
1:  * <li> <i>Actions</i> - a list of granted administrative actions
1:  * </ul>
1:  * The database location URL may contain certain wildcard characters.
1:  * The currently only supported database action is <i>create</i>.
1:  *
0:  * @see DatabasePermission(String,String)
1:  * @see SystemPermission
1:  * @see java.io.FilePermission
1:  */
0: public class DatabasePermission extends Permission {
1: 
1:     /**
1:      * The URL protocol scheme specifying a directory location.
1:      */
1:     static public final String URL_PROTOCOL_DIRECTORY = "directory:";
1: 
1:     /**
1:      * The URL file path separator character.
1:      */
1:     static public final char URL_PATH_SEPARATOR_CHAR = '/';
1: 
1:     /**
1:      * The relative path character.
1:      */
1:     static public final char URL_PATH_RELATIVE_CHAR = '.';
1: 
1:     /**
0:      * The wildcard character specifying arbitrarily named databases
0:      * under a directory path.
1:      */
1:     static public final char URL_PATH_WILDCARD_CHAR = '*';
1: 
1:     /**
0:      * The wildcard character specifying arbitrarily named databases
0:      * anywhere under a path and its subdirectories.
1:      */
1:     static public final char URL_PATH_RECURSIVE_CHAR = '-';
1: 
1:     // derived path type constants
1:     static public final String URL_PATH_SEPARATOR_STRING
1:         = String.valueOf(URL_PATH_SEPARATOR_CHAR);
1:     static public final String URL_PATH_RELATIVE_STRING
1:         = String.valueOf(URL_PATH_RELATIVE_CHAR);
1:     static public final String URL_PATH_RELATIVE_PREFIX
1:         = (URL_PATH_RELATIVE_STRING + URL_PATH_SEPARATOR_CHAR);
1:     static public final String URL_PATH_WILDCARD_STRING
1:         = String.valueOf(URL_PATH_WILDCARD_CHAR);
1:     static public final String URL_PATH_WILDCARD_SUFFIX
1:         = (URL_PATH_SEPARATOR_STRING + URL_PATH_WILDCARD_CHAR);
1:     static public final String URL_PATH_RECURSIVE_STRING
1:         = String.valueOf(URL_PATH_RECURSIVE_CHAR);
1:     static public final String URL_PATH_RECURSIVE_SUFFIX
1:         = (URL_PATH_SEPARATOR_STRING + URL_PATH_RECURSIVE_CHAR);
1: 
1:     /**
1:      * The create database permission.
1:      */
1:     static public final String CREATE = "create";
1: 
1:     /**
1:      * The legal database permission action names.
1:      */
0:     static protected final Set LEGAL_ACTIONS = new HashSet();
1:     static {
0:         // when adding new actions, check method: implies(Permission)
1:         LEGAL_ACTIONS.add(CREATE);
1:     };
1: 
1:     /**
0:      * The original location URL passed to constructor.
1:      */
0:     private final String url;
1: 
1:     /**
1:      * This permission's canonical directory path.
1:      *
1:      * The path consists of a canonicalized form of the user-specified URL,
1:      * stripped off the protocol specification and any recursive/wildcard
0:      * characters.  The canonical path is used when testing permissions
0:      * with implies(), where real directory locations, not just notational
0:      * differences, ought to be compared.  Analog to java.io.FilePermission,
0:      * the canonical path is also used by equals() and hashCode() to support
1:      * hashing and mapping of permissions by their real directory locations.
1:      *
1:      * Because canonical file paths are platform dependent, this field
1:      * must not be serialized (hence transient) but be recomputed from
1:      * the original URL upon deserialization.
1:      */
1:     private transient String path;
1: 
1:     /**
1:      * The parent directory of this permission's canonical directory path,
0:      * or null if this permission's path does not name a parent directory.
1:      *
1:      * Because canonical file paths are platform dependent, this field
1:      * must not be serialized (hence transient) but be recomputed from
1:      * the original URL upon deserialization.
1:      */
1:     private transient String parentPath;
1: 
1:     /**
0:      * Indicates whether the path denotes a recursive, wildcard, or single
0:      * location.
1:      *
0:      * If the path denotes a recursive or wildcard location, this field's
0:      * value is URL_PATH_RECURSIVE_CHAR or URL_PATH_WILDCARD_CHAR,
0:      * respectively; otherwise, it's URL_PATH_SEPARATOR_CHAR denoting a
0:      * single location.
1:      */
0:     private char pathType;
1: 
1:     /**
1:      * Creates a new DatabasePermission with the specified URL and actions.
1:      * <P>
1:      * <i>actions</i> contains a comma-separated list of the desired actions
1:      * granted on a database. Currently, the only supported action is
1:      * <code>create</code>.
1:      * <P>
1:      * <i>URL</i> denotes a database location URL, which, at this time, must
1:      * start with <code>directory:</code> followed by a directory pathname.
1:      * Note that in a URL, the separator character is always "/" rather than
1:      * the file separator of the operating-system.  The directory path may
1:      * be absolute or relative, in which case it is prefixed with the current
1:      * user directory. In addition, similar to java.io.FilePermission, the
1:      * directory pathname may end with a wildcard character to allow for
1:      * arbitrarily named databases under a path:
1:      * <ul>
1:      * <li> "directory:location" - refers to a database called
1:      *      <i>location</i>,
0:      * <li> "directory:location/*" - refers to any database in the
1:      *      directory <i>location</i>,
0:      * <li> "directory:location/-" - refers to any database anywhere under
1:      *      <i>location</i> or its subdirectories.
0:      * <li> "directory:*" - refers to any database in the user's current
1:      *      working directory.
0:      * <li> "directory:-" - refers to any database anywhere under the
1:      *      user's current working directory or its subdirectories.
1:      * </ul>
0:      * Note that in contrast to FilePermission, there is no reasonable use
0:      * for a special pathname "<<ALL FILES>>" matching all locations.
1:      *
1:      * @param url the database URL
1:      * @param actions the action string
1:      * @throws NullPointerException if an argument is null
1:      * @throws IllegalArgumentException if an argument is not legal
1:      * @throws IOException if the location URL cannot be canonicalized
0:      * @see Permission(String)
0:      * @see FilePermission(String,String)
1:      */
1:     public DatabasePermission(String url, String actions)
1:         throws IOException {
1:         super(url);
1:         initActions(actions);
1:         initLocation(url);
1: 
0:         // store original URL for reconstructing path at deserialization
0:         this.url = url;
1:     }
1: 
1:     /**
1:      * Parses the list of database actions.
1:      *
1:      * @param actions the comma-separated action list
1:      * @throws NullPointerException if actions is null
1:      * @throws IllegalArgumentException if not a list of legal actions
1:      */
1:     protected void initActions(String actions) {
0:         // note that exception messages on the action list aren't localized,
0:         // as is the general rule with runtime exceptions indicating
0:         // internal coding errors
1: 
1:         // analog to java.security.BasicPermission, we check that actions
1:         // is not null nor empty
1: 	if (actions == null) {
1: 	    throw new NullPointerException("actions can't be null");
1:         }
1: 	if (actions.length() == 0) {
1: 	    throw new IllegalArgumentException("actions can't be empty");
1: 	}
1: 
0:         // splitting the comma-separated list into the individual actions
0:         // may throw a java.util.regex.PatternSyntaxException, which is a
0:         // java.lang.IllegalArgumentException, hence directly applicable
0:         final String[] s = actions.split(",");
1: 
1:         // check for any illegal actions
0:         for (int i = 0; i < s.length; i++) {
0:             final String action = s[i].trim();
1:             if (!LEGAL_ACTIONS.contains(action)) {
1:                 // report illegal action
1:                 final String msg = "Illegal action '" + action + "'";
0:                 //System.out.println("DatabasePermission: " + msg);
1:                 throw new IllegalArgumentException(msg);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Parses the database location URL.
1:      *
1:      * @param url the database URL
1:      * @throws NullPointerException if the URL is null
1:      * @throws IllegalArgumentException if the URL is not well-formed
1:      * @throws IOException if the location URL cannot be canonicalized
1:      */
1:     protected void initLocation(String url)
1:         throws IOException {
0:         // note that exception messages on the URL aren't localized,
0:         // as is the general rule with runtime exceptions indicating
0:         // internal coding errors
1: 
1:         // analog to java.security.BasicPermission, we check that URL
1:         // is not null nor empty
1: 	if (url == null) {
1: 	    throw new NullPointerException("URL can't be null");
1:         }
1: 	if (url.length() == 0) {
1: 	    throw new IllegalArgumentException("URL can't be empty");
1: 	}
1: 
1:         // check URL's protocol scheme and initialize path
1:         if (!url.startsWith(URL_PROTOCOL_DIRECTORY)) {
1:             final String msg = "Unsupported protocol in URL '" + url + "'";
0:             //System.out.println("DatabasePermission: " + msg);
1:             throw new IllegalArgumentException(msg);
1:         }
1:         String p = url.substring(URL_PROTOCOL_DIRECTORY.length());
1: 
0:         // check path for relative/recursive/wildcard specifications,
1:         // split path into real pathname and the path type
0:         if (p.equals(URL_PATH_RECURSIVE_STRING)) {
1:             // relative & recursive:  "-" --> '-', "./"
1:             pathType = URL_PATH_RECURSIVE_CHAR;
1:             p = URL_PATH_RELATIVE_PREFIX;
1:         } else if (p.equals(URL_PATH_WILDCARD_STRING)) {
1:             // relative & wildcard:   "*" --> '*', "./"
1:             pathType = URL_PATH_WILDCARD_CHAR;
1:             p = URL_PATH_RELATIVE_PREFIX;
1:         } else if (p.endsWith(URL_PATH_RECURSIVE_SUFFIX)) {
1:             // absolute & recursive:  "<path>/-" --> '-', "<path>/"
1:             pathType = URL_PATH_RECURSIVE_CHAR;
1:             p = p.substring(0, p.length() - 1);
1:         } else if (p.endsWith(URL_PATH_WILDCARD_SUFFIX)) {
1:             // absolute & wildcard:   "<path>/*" --> '*', "<path>/"
1:             pathType = URL_PATH_WILDCARD_CHAR;
1:             p = p.substring(0, p.length() - 1);
1:         } else {
1:             // absolute | relative:   "<path>" --> '/', "<path>"
1:             pathType = URL_PATH_SEPARATOR_CHAR;
1:             // p = p;
1:         }
1: 
0:         // resolve against user's working directory if relative pathname
1:         if (p.startsWith(URL_PATH_RELATIVE_PREFIX)) {
0:             final String cwd = System.getProperty("user.dir");
1:             // concatenated path "<cwd>/./<path>" will be canonicalized
1:             p = cwd + URL_PATH_SEPARATOR_STRING + p;
1:         }
1: 
1:         // store canonicalized path as required for implies(Permission);
0:         // may throw IOException 
0:         final File f = (new File(p)).getCanonicalFile();
0:         this.path = f.getPath();
1: 
1:         // store canonicalized path of parent file as required for
1:         // implies(Permission); may throw IOException; note that
1:         // the path already denotes parent directory if of wildcard type:
1:         // for example, the parent of "/a/-" or "/a/*" is "/a"
0:         this.parentPath = ((pathType != URL_PATH_SEPARATOR_CHAR)
1:                            ? path : f.getParent());
1: 
0:         //assert (pathType == URL_PATH_SEPARATOR_CHAR
0:         //        || pathType == URL_PATH_WILDCARD_CHAR
0:         //        || pathType == URL_PATH_RECURSIVE_CHAR);
0:         //assert (path != null);
1:     }
1: 
1:     /**
1:      * Checks if this DatabasePermission implies a specified permission.
1:      * <P>
1:      * This method returns true if:<p>
1:      * <ul>
1:      * <li> <i>p</i> is an instanceof DatabasePermission and<p>
1:      * <li> <i>p</i>'s directory pathname is implied by this object's
1:      *      pathname. For example, "/tmp/*" implies "/tmp/foo", since
1:      *      "/tmp/*" encompasses the "/tmp" directory and all files in that
1:      *      directory, including the one named "foo".
1:      * </ul>
1:      * @param p the permission to check against
1:      * @return true if the specified permission is implied by this object,
1:      * false if not
0:      * @see Permission.implies(Permission)
1:      */
1:     public boolean implies(Permission p) {
0:         //System.out.println("this = " + this);
0:         //System.out.println("that = " + p);
1: 
1:         // can only imply other DatabasePermissions
1:         if (!(p instanceof DatabasePermission)) {
1:             return false;
1:         }
1:         final DatabasePermission that = (DatabasePermission)p;
1: 
1:         // a recursive permission implies any other if a path prefix
1:         if (this.pathType == URL_PATH_RECURSIVE_CHAR) {
1:             return (that.parentPath != null
1:                     && that.parentPath.startsWith(this.path));
1:         }
0:         //assert (this.pathType != URL_PATH_RECURSIVE_CHAR);
1: 
1:         // a non-recursive permission cannot imply a recursive one
1:         if (that.pathType == URL_PATH_RECURSIVE_CHAR) {
1:             return false;
1:         }
0:         //assert (that.pathType != URL_PATH_RECURSIVE_CHAR);
1: 
0:         //System.out.println("");
1:         
1:         // a wildcard permission implies another if a parent directory
1:         if (this.pathType == URL_PATH_WILDCARD_CHAR) {
1:             return this.path.equals(that.parentPath);
1:         }
0:         //assert (this.pathType != URL_PATH_WILDCARD_CHAR);
1: 
1:         // a non-wildcard permission cannot imply a wildcard one
1:         if (that.pathType == URL_PATH_WILDCARD_CHAR) {
1:             return false;
1:         }
0:         //assert (that.pathType != URL_PATH_WILDCARD_CHAR);
1: 
1:         // non-recursive, non-wildcard permissions imply when paths are equal
0:         //assert (this.pathType == URL_PATH_SEPARATOR_CHAR);
0:         //assert (that.pathType == URL_PATH_SEPARATOR_CHAR);
1:         return this.path.equals(that.path);
1:     }
1: 
1:     /**
1:      * Checks two DatabasePermission objects for equality.
1:      * <P>
1:      * Checks that <i>obj</i> is a DatabasePermission and has the same
1:      * canonizalized URL and actions as this object.
1:      * <P>
1:      * @param obj the object we are testing for equality with this object
1:      * @return true if obj is a DatabasePermission, and has the same URL and
1:      * actions as this DatabasePermission object, false if not
1:      *
0:      * @see Permission.equals(Object)
1:      */
1:     public boolean equals(Object obj) {
1:         if (obj == this) {
1:             return true;
1:         }
1: 
1:         if (!(obj instanceof DatabasePermission)) {
1:             return false;
1:         }
1:         final DatabasePermission that = (DatabasePermission)obj;
1: 
1:         // compare canonicalized URLs
0:         return (path.equals(that.path) && pathType == that.pathType);
1:     }
1: 
1:     /**
1:      * Returns the hash code value for this object.
1:      *
1:      * @return a hash code value for this object
0:      * @see Permission.hashCode()
1:      */
1:     public int hashCode() {
1:         // hash canonicalized URL
1:         return (path.hashCode() ^ pathType);
1:     }
1: 
1:     /**
1:      * Returns the "canonical string representation" of the actions.
1:      *
1:      * @return the canonical string representation of the actions
0:      * @see Permission.getActions()
1:      */
1:     public String getActions() {
0:         // currently, the only supported action
0:         return CREATE;
1:     }
1: 
1: 
1:     /**
1:      * Called upon Serialization for saving the state of this
1:      * DatabasePermission to a stream.
1:      */
1:     private void writeObject(ObjectOutputStream s)
1:         throws IOException {
1:         // write the non-static and non-transient fields to the stream
1:         s.defaultWriteObject();
1:     }
1: 
1:     /**
1:      * Called upon Deserialization for restoring the state of this
1:      * DatabasePermission from a stream.
1:      */
1:     private void readObject(ObjectInputStream s)
1:          throws IOException, ClassNotFoundException
1:     {
1:         // read the non-static and non-transient fields from the stream
1:         s.defaultReadObject();
1:         // restore the platform-dependent path from the original URL
1:         initLocation(url);
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c0052e0
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
1: import java.security.PrivilegedActionException;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: final public class DatabasePermission extends Permission {
/////////////////////////////////////////////////////////////////////////
1:      * The location text matching any database anywhere.
1:      */
1:     static public final String URL_PATH_INCLUSIVE_STRING = "<<ALL FILES>>";
0: 
1:     /**
1:      * The path type character matching any database anywhere.
1:      */
1:     static public final char URL_PATH_INCLUSIVE_CHAR = 'I';
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * The wildcard character matching any database in a directory.
1:      * The wildcard character matching any database under a directory
1:      * or its subdirectories.
/////////////////////////////////////////////////////////////////////////
1:      * characters, or {@code "<<ALL FILES>>"} for the "anywhere" permission.
1:      * The canonical path is used when testing permissions with implies(),
1:      * where real directory locations, not just notational differences,
1:      * ought to be compared.  Analog to java.io.FilePermission, the
1:      * canonical path is also used by equals() and hashCode() to support
/////////////////////////////////////////////////////////////////////////
1:      * or null if this permission's path does not have a parent directory.
/////////////////////////////////////////////////////////////////////////
1:      * Indicates whether the path denotes an inclusive, recursive, wildcard,
1:      * or single location.
1:      * If the path denotes an inclusive, recursive or wildcard location,
1:      * this field's value is URL_PATH_INCLUSIVE_CHAR, URL_PATH_RECURSIVE_CHAR,
1:      * or URL_PATH_WILDCARD_CHAR, respectively; otherwise, it's
1:      * URL_PATH_SEPARATOR_CHAR denoting a single location.
/////////////////////////////////////////////////////////////////////////
1:      * <li> "directory:location/*" - matches any database in the
1:      * <li> "directory:location/-" - matches any database under
1:      * <li> "directory:*" - matches any database in the user's current
1:      * <li> "directory:-" - matches any database under the
1:      * <li> {@code "directory:<<ALL FILES>>"} matches any database anywhere.
/////////////////////////////////////////////////////////////////////////
0:         if (actions == null) {
0:             throw new NullPointerException("actions can't be null");
0:         if (actions.length() == 0) {
0:             throw new IllegalArgumentException("actions can't be empty");
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (url == null) {
0:             throw new NullPointerException("URL can't be null");
0:         if (url.length() == 0) {
0:             throw new IllegalArgumentException("URL can't be empty");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // check path for inclusive/relative/recursive/wildcard specifications,
1:         if (p.equals(URL_PATH_INCLUSIVE_STRING)) {
1:             // inclusive:  "<<ALL FILES>>" --> 'I', "<<ALL FILES>>"
1:             pathType = URL_PATH_INCLUSIVE_CHAR;
1:             // p = p;
1:         } else if (p.equals(URL_PATH_RECURSIVE_STRING)) {
/////////////////////////////////////////////////////////////////////////
1:         // canonicalize the path and assign parentPath
1:         if (pathType == URL_PATH_INCLUSIVE_CHAR) {
1:             path = URL_PATH_INCLUSIVE_STRING;
1:             //assert(parentPath == null);
1:         } else {
1:             // resolve against user's working directory if relative pathname;
1:             // the read access to the system property is encapsulated in a
1:             // doPrivileged() block to allow for confined codebase permission
1:             // grants
0:             if (p.startsWith(URL_PATH_RELATIVE_PREFIX)) {
0:                 final String cwd = (String)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
1:                             return System.getProperty("user.dir");
1:                         }
1:                     });
0:                 // concatenated path "<cwd>/./<path>" will be canonicalized
0:                 p = cwd + URL_PATH_SEPARATOR_STRING + p;
1:             }
1:             final String absPath = p;
0: 
0:             // store canonicalized path as required for implies(Permission);
1:             // may throw IOException; canonicalization reads the "user.dir"
1:             // system property, which we encapsulate in a doPrivileged()
1:             // block to allow for confined codebase permission grants
1:             final File f;
1:             try {
0:                 f = (File)AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                         public Object run() throws IOException {
1:                             return (new File(absPath)).getCanonicalFile();
1:                         }
1:                     });
1:             } catch (PrivilegedActionException pae) {
1:                 // pae.getCause() should be an instance of IOException,
1:                 // as only checked exceptions will be wrapped
1:                 throw (IOException)pae.getCause();
1:             }
1:             path = f.getPath();
0: 
0:             // store canonicalized path of parent file as required for
0:             // implies(Permission); may throw IOException; note that
0:             // the path already denotes parent directory if of wildcard type:
0:             // for example, the parent of "/a/-" or "/a/*" is "/a"
1:             parentPath = ((pathType != URL_PATH_SEPARATOR_CHAR)
0:                           ? path : f.getParent());
1:         //assert(pathType == URL_PATH_SEPARATOR_CHAR
1:         //       || pathType == URL_PATH_WILDCARD_CHAR
1:         //       || pathType == URL_PATH_RECURSIVE_CHAR
1:         //       || pathType == URL_PATH_INCLUSIVE_CHAR);
1:         //assert(path != null);
1:         //assert(parentPath == null || parentPath != null);
/////////////////////////////////////////////////////////////////////////
1:         // an inclusive permission implies any other
1:         if (this.pathType == URL_PATH_INCLUSIVE_CHAR) {
1:             return true;
0:         }
1:         //assert(this.pathType != URL_PATH_INCLUSIVE_CHAR);
0: 
1:         // a non-inclusive permission cannot imply an inclusive one
1:         if (that.pathType == URL_PATH_INCLUSIVE_CHAR) {
1:             return false;
0:         }
1:         //assert(that.pathType != URL_PATH_INCLUSIVE_CHAR);
0: 
1:         //assert(this.pathType != URL_PATH_RECURSIVE_CHAR);
1:         //assert(that.pathType != URL_PATH_RECURSIVE_CHAR);
1:         //assert(this.pathType != URL_PATH_WILDCARD_CHAR);
1:         //assert(that.pathType != URL_PATH_WILDCARD_CHAR);
1:         //assert(this.pathType == URL_PATH_SEPARATOR_CHAR);
1:         //assert(that.pathType == URL_PATH_SEPARATOR_CHAR);
/////////////////////////////////////////////////////////////////////////
1:         return (pathType == that.pathType && path.equals(that.path));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a469215
/////////////////////////////////////////////////////////////////////////
1:  * @see DatabasePermission#DatabasePermission(String,String)
/////////////////////////////////////////////////////////////////////////
1:      * @see Permission#Permission(String)
1:      * @see java.io.FilePermission#FilePermission(String,String)
/////////////////////////////////////////////////////////////////////////
1:      * @see Permission#implies(Permission)
/////////////////////////////////////////////////////////////////////////
1:      * @see Permission#equals(Object)
/////////////////////////////////////////////////////////////////////////
1:      * @see Permission#hashCode()
/////////////////////////////////////////////////////////////////////////
1:      * @see Permission#getActions()
============================================================================