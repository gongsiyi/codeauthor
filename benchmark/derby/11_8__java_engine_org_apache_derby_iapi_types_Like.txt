2:eac0369: /*
51:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.Like
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: // RESOLVE: MOVE THIS CLASS TO PROTOCOL (See LikeOperatorNode)
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.text.CollationElementIterator;
1:eac0369: import java.text.Collator;
1:eac0369: import java.text.RuleBasedCollator;
1:eac0369: import java.util.Locale;
1:eac0369: 
7:eac0369: /**
1:eac0369: 	Like matching algorithm. Not too speedy for %s.
1:eac0369: 
1:eac0369: 	SQL92 says the escape character can only and must be followed
1:eac0369: 	by itself, %, or _.  So if you choose % or _ as the escape character,
1:eac0369: 	you can no longer do that sort of matching.
1:eac0369: 
1:eac0369: 	Not the most recent Like -- missing the unit tests
1:eac0369: 
1:eac0369:  */
1:eac0369: public class Like {
1:eac0369: 	private static final char anyChar = '_';
1:eac0369: 	private static final char anyString = '%';
1:eac0369: 
1:eac0369: 	private static final String SUPER_STRING = "\uffff";
1:eac0369: 
1:eac0369: 	private Like() { // do not instantiate
67:eac0369: 	}
1:f148f1f: 
1:f148f1f: 	/**
1:eac0369: 	  
1:f148f1f: 	 This method gets called for UCS_BASIC and territory based character
1:f148f1f: 	 string types to look for a pattern in a value string. It also deals
1:f148f1f: 	 with escape character if user has provided one.
1:f148f1f: 	  
2:eac0369: 		@param val value to compare. if null, result is null.
2:eac0369: 		@param valLength length of val
2:eac0369: 		@param pat pattern to compare. if null, result is null.
2:eac0369: 		@param patLength length of pat
2:eac0369: 		@param escape escape character. Must be 1 char long.
2:eac0369: 			if null, no escape character is used.
2:eac0369: 		@param escapeLength length of escape
1:f148f1f: 		@param collator null if we are dealing with UCS_BASIC 
1:f148f1f: 		    character string types. If not null, then we use it to 
1:f148f1f: 		    get collation elements for characters in val and 
1:f148f1f: 		    non-metacharacters in pat to do the comparison.
1:eac0369: 
2:eac0369: 		@return null if val or pat null, otherwise true if match
2:eac0369: 		and false if not.
2:eac0369: 		@exception StandardException thrown if data invalid
1:eac0369: 	 */
2:eac0369: 	public static Boolean like
3:eac0369: 	(
1:eac0369: 		char[] 	val, 
2:eac0369: 		int 	valLength, 
1:eac0369: 		char[] 	pat, 
2:eac0369: 		int 	patLength, 
1:eac0369: 		char[] 	escape,
1:f148f1f: 		int 	escapeLength,
1:f148f1f: 		RuleBasedCollator collator
3:eac0369: 	) throws StandardException 
67:eac0369: 	{
1:f148f1f: 		return like(val, 0, valLength, pat, 0, patLength, escape, 
1:f148f1f: 				escapeLength, collator);
1:eac0369: 	}
1:eac0369: 
1:f148f1f: 	/* For character string types with UCS_BASIC and territory based
1:111785f: 	 * collation. */
2:eac0369: 	private static Boolean like
1:eac0369: 	(
1:eac0369: 		char[] 	val, 
2:eac0369: 		int 	vLoc, 	// start at val[vLoc]
2:eac0369: 		int 	vEnd, 	// end at val[vEnd]
1:eac0369: 		char[] 	pat, 
2:eac0369: 		int 	pLoc, 	// start at pat[pLoc]
2:eac0369: 		int 	pEnd, 	// end at pat[pEnd]
1:eac0369: 		char[] 	escape,
1:f148f1f: 		int 	escapeLength,
1:f148f1f: 		RuleBasedCollator collator
1:eac0369: 	) throws StandardException 
1:eac0369: 	{
1:eac0369: 		char escChar = ' ';
2:eac0369: 		boolean haveEsc = true;
1:eac0369: 		
2:eac0369: 		if (val == null) return null;
2:eac0369: 		if (pat == null) return null;
1:eac0369: 
3:eac0369: 		if (escape == null)
1:eac0369: 		{
2:eac0369: 			haveEsc = false;
1:eac0369: 		}
10:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			escChar = escape[0];
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		Boolean result;
1:eac0369: 
1:eac0369: 		while (true) {
1:eac0369: 
1:eac0369: 			if ((result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd)) != null) 
1:eac0369: 			{
5:eac0369: 				return result;
1:eac0369: 			}
1:eac0369: 
2:eac0369: 			// go until we get a special char in the pattern or hit EOS
1:eac0369: 			while (pat[pLoc] != anyChar && pat[pLoc] != anyString &&
1:eac0369: 					((! haveEsc) || pat[pLoc] != escChar)) {
1:f148f1f: 				if (checkEquality(val, vLoc, pat, pLoc, collator)) {
2:eac0369: 					vLoc++; pLoc++;
1:f148f1f: 					
1:eac0369: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
5:eac0369: 					if (result != null) 
1:eac0369: 						return result;
1:f148f1f: 				} else
5:eac0369: 					return Boolean.FALSE;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// deal with escChar first, as it can be escaping a special char
2:eac0369: 			// and can be a special char itself.
1:eac0369: 			if (haveEsc && pat[pLoc] == escChar) {
1:eac0369: 				pLoc++;
1:eac0369: 				if (pLoc == pEnd) {
2:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1:eac0369: 				}
1:eac0369: 				if (pat[pLoc] != escChar &&
1:eac0369: 				    pat[pLoc] != anyChar &&
1:eac0369: 				    pat[pLoc] != anyString) {
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1:eac0369: 				}
2:eac0369: 				// regardless of the char in pat, it must match exactly:
1:f148f1f: 				if (checkEquality(val, vLoc, pat, pLoc, collator)) {
1:eac0369: 					vLoc++; pLoc++;
1:eac0369: 	
1:eac0369: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
1:eac0369: 					if (result != null) 
1:eac0369: 						return result;
1:eac0369: 				}
1:eac0369: 				else return Boolean.FALSE;
1:eac0369: 			}
1:eac0369: 			else if (pat[pLoc] == anyChar) {
2:eac0369: 				// regardless of the char, it matches
1:eac0369: 				vLoc++; pLoc++;
1:eac0369: 	
1:eac0369: 				result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
1:eac0369: 				if (result != null) 
1:eac0369: 					return result;
1:eac0369: 			}
1:eac0369: 			else if (pat[pLoc] == anyString) {
2:eac0369: 				// catch the simple cases -- end of the pattern or of the string
2:eac0369: 				if (pLoc+1 == pEnd)
6:eac0369: 					return Boolean.TRUE;
1:eac0369: 
2:eac0369: 				// would return true, but caught in checkLengths above
3:eac0369: 				if (SanityManager.DEBUG)
2:eac0369: 					SanityManager.ASSERT(vLoc!=vEnd, 
2:eac0369: 						"Should have been found already");
1:eac0369: 
1:eac0369: 				//if (vLoc == vEnd) // caught in checkLengths
1:eac0369: 					//return Boolean.TRUE;
2:eac0369: 				// check if remainder of pattern is anyString's
2:eac0369: 				// if escChar == anyString, we couldn't be here
1:eac0369: 				boolean anys = true;
2:eac0369: 				for (int i=pLoc+1;i<pEnd;i++)
1:eac0369: 					if (pat[i]!=anyString) {
1:eac0369: 						anys=false;
1:c1bc742: 						break;
1:eac0369: 					}
1:eac0369: 				if (anys) return Boolean.TRUE;
1:eac0369: 
2:eac0369: 				// pattern can match 0 or more chars in value.
2:eac0369: 				// to test that, we take the remainder of pattern and
2:eac0369: 				// apply it to ever-shorter  remainders of value until
2:eac0369: 				// we hit a match.
1:eac0369: 
2:eac0369: 				// the loop never continues from this point -- we will
2:eac0369: 				// always generate an answer here.
1:eac0369: 
2:eac0369: 				// REMIND: there are smarter ways to pick the remainders
2:eac0369: 				// and do this matching.
1:eac0369: 
2:eac0369: 				// num chars left in value includes current char
2:eac0369: 				int vRem = vEnd - vLoc;
1:eac0369: 
2:eac0369: 				int n=0;
1:eac0369: 
1:eac0369: 				// num chars left in pattern excludes the anychar
1:eac0369: 				int minLen = getMinLen(pat, pLoc+1, pEnd, haveEsc, escChar);
2:eac0369: 				for (int i=vRem; i>=minLen; i--) 
1:eac0369: 				{
1:f148f1f: 					Boolean restResult = Like.like(val, vLoc+n, vLoc+n+i, pat,
1:f148f1f: 							pLoc+1, pEnd, escape, escapeLength, collator);
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
2:eac0369: 						if (restResult == null)
1:eac0369: 						{
1:eac0369: 							String vStr = new String(val,vLoc+n,i);
1:eac0369: 							String pStr = new String(pat,pLoc+1,pEnd-(pLoc+1));
1:eac0369: 							SanityManager.THROWASSERT("null result on like(value = "+vStr+", pat = "+pStr+")");
1:eac0369: 						}
1:eac0369: 					}
2:eac0369: 					if (restResult.booleanValue())
2:eac0369: 						return restResult;
1:eac0369: 
2:eac0369: 					n++;
1:eac0369: 				}
2:eac0369: 				// none of the possibilities worked 
1:eac0369: 				return Boolean.FALSE;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d0edfdc: 	 * If the character in val matches the character in pat, then it does not
1:d0edfdc: 	 * matter if the database is UCS_BASIC or territory based, we simply return 
1:d0edfdc: 	 * TRUE from the method. 
1:d0edfdc: 	 * If the characters do not match and we are running with UCS_BASIC 
1:d0edfdc: 	 * collation, then we will return FALSE. 
1:d0edfdc: 	 * But if the database is territory based, then we want to use the Collator 
1:d0edfdc: 	 * for the territory to determine if the Collator treats the 2 characters 
1:d0edfdc: 	 * as equal (ie if their collation elements match, then the 2 characters 
1:d0edfdc: 	 * are equal even if they  are not the same character).
1:f148f1f: 	 * 
1:f148f1f: 	 * @param val value to compare.
1:f148f1f: 	 * @param vLoc character position in val.
1:f148f1f: 	 * @param pat pattern to look for in val.
1:f148f1f: 	 * @param pLoc character position in pat.
1:f148f1f: 	 * @param collator null if we are dealing with UCS_BASIC character string
1:d0edfdc: 	 *   types. If not null, then we use it to determine the equality of the
1:d0edfdc: 	 *   2 characters in pat and val if they are not same.
1:479bbb7: 	 * @return TRUE if the character in val and vLoc match based on straight
1:479bbb7: 	 *   equality or collation element based equality. Otherwise we will 
1:479bbb7: 	 *   return FALSE.
1:f148f1f: 	 */
1:f148f1f: 	private static boolean checkEquality(char[] val, int vLoc,
1:f148f1f: 			char[] pat, int pLoc, RuleBasedCollator collator) {
1:f148f1f: 
1:d0edfdc: 		if (val[vLoc] == pat[pLoc]) { 
1:d0edfdc: 	        // same character, so two strings consisting of this 
1:d0edfdc: 	        // single character must be equal regardless of territory 
1:d0edfdc: 	        return true; 
1:d0edfdc: 	    } else if (collator == null) { 
1:d0edfdc: 	        // not same character, must be unequal in UCS_BASIC 
1:d0edfdc: 	        return false; 
1:d0edfdc: 	    } 
1:d0edfdc: 
1:d0edfdc: 		//Check if the Collator for this database's territory considers these
1:d0edfdc: 		//2 characters as equal based on their collation elements
1:d0edfdc: 	    String s1 = new String(val, vLoc, 1); 
1:d0edfdc: 	    String s2 = new String(pat, pLoc, 1); 
1:d0edfdc: 
1:d0edfdc: 	    return collator.compare(s1, s2) == 0; 
1:f148f1f: 	}
1:f148f1f: 
1:baef65a: 	/**
1:111785f: 		Calculate the shortest length string that could match this pattern
1:eac0369: 	 */
1:eac0369: 	static int getMinLen(char[] pattern, int pStart, int pEnd, boolean haveEsc, char escChar) 
1:f148f1f: 	{
2:eac0369: 		int m=0;
2:eac0369: 		for (int l = pStart; l<pEnd; ) 
1:eac0369: 		{
1:eac0369: 			if (haveEsc && pattern[l] == escChar) { // need one char
1:eac0369: 				l+=2;
1:eac0369: 				m++;
1:f148f1f: 			}
1:eac0369: 			else if (pattern[l] == anyString) {
1:eac0369: 				l++; // anyString, nothing needed
1:f148f1f: 			}
1:eac0369: 			else { // anyChar or other chars, need one char
2:eac0369: 				l++; m++;
1:eac0369: 			}
1:eac0369: 		}
2:eac0369: 		return m;
1:eac0369: 	}
1:f148f1f: 
1:eac0369: 	/**
1:111785f: 	 * checkLengths  
10:eac0369: 	 *
2:eac0369: 	 * Returns null if we are not done.
2:eac0369: 	 * Returns true if we are at the end of our value and pattern
2:eac0369: 	 * Returns false if there is more pattern left but out of input value
1:eac0369: 	 *
1:eac0369: 	 * @param vLoc current index into char[] val
2:eac0369: 	 * @param vEnd end index or our value
1:eac0369: 	 * @param pLoc current index into our char[] pattern
1:eac0369: 	 * @param pat  pattern char []
2:eac0369: 	 * @param pEnd end index of our pattern []
1:eac0369: 	 */
1:baef65a: 
2:eac0369: 	static Boolean checkLengths(int vLoc, int vEnd,
1:eac0369: 			int pLoc, char[] pat, int pEnd) 
1:eac0369: 	{
3:eac0369: 		if (vLoc == vEnd) 
1:eac0369: 		{
3:eac0369: 			if (pLoc == pEnd) 
1:eac0369: 			{
1:eac0369: 				return Boolean.TRUE;
1:eac0369: 			}
1:f148f1f: 			else 
1:eac0369: 			{
2:eac0369: 				// if remainder of pattern is anyString chars, ok
1:eac0369: 				for (int i=pLoc; i<pEnd; i++) 
1:eac0369: 				{
1:eac0369: 					if (pat[i] != anyString)
1:eac0369: 					{
1:eac0369: 						return Boolean.FALSE; // more to match
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				return Boolean.TRUE;
1:eac0369: 			}
1:eac0369: 		}
2:eac0369: 		else if (pLoc == pEnd)
1:eac0369: 		{
2:eac0369: 			return Boolean.FALSE; // ran out of pattern
1:eac0369: 		}
2:eac0369: 		else return null; // still have strings to match, not done
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:f148f1f: 		Most typical interface for character string types with UCS_BASIC and 
1:111785f: 		territory based collation.
1:eac0369: 	 */
1:f148f1f: 	public static Boolean like(char[] value, int valueLength, char[] pattern, 
1:f148f1f: 			int patternLength, RuleBasedCollator collator) 
1:f148f1f: 	throws StandardException { 
2:eac0369: 		if (value == null || pattern == null) return null;
1:f148f1f: 		return like(value, valueLength, pattern, patternLength, null, 0, 
1:f148f1f: 				collator);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// Methods for LIKE transformation at preprocess time:
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether or not this LIKE can be transformed into optimizable
1:dd611b8: 	 * clauses.  It can if the pattern is non-null and if the length == 0 or
1:eac0369: 	 * the first character is not a wild card.
1:eac0369: 	 *
2:eac0369: 	 * @param pattern	The right side of the LIKE
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not the LIKE can be transformed
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public static boolean isOptimizable(String pattern)
1:eac0369: 	{
1:dd611b8: 		if (pattern == null)
1:eac0369: 		{
1:f148f1f: 			return false;
1:eac0369: 		}
1:eac0369: 
1:dd611b8:         if (pattern.length() == 0) {
1:f148f1f:             return true;
1:dd611b8:         }
1:dd611b8: 
1:eac0369: 		// if we have pattern matching at start of string, no optimization
1:eac0369: 		char firstChar = pattern.charAt(0);
1:eac0369: 
1:eac0369: 		return (firstChar != anyChar && firstChar != anyString);
1:eac0369: 	}
1:eac0369: 
1:baef65a: 	public static String greaterEqualStringFromParameter(String pattern, int maxWidth)
1:eac0369: 		throws StandardException {
1:eac0369: 
2:eac0369: 		if (pattern == null)
5:eac0369: 			return null;
1:eac0369: 
1:baef65a: 		return greaterEqualString(pattern, (String) null, maxWidth);
1:eac0369: 	}
1:eac0369: 
1:baef65a: 	public static String greaterEqualStringFromParameterWithEsc(String pattern, String escape, int maxWidth)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		if (pattern == null)
1:eac0369: 			return null;
1:eac0369: 
1:baef65a: 		return greaterEqualString(pattern, escape, maxWidth);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * Return the substring from the pattern for the optimization &gt;= clause.
1:eac0369: 	 *
1:eac0369: 	 * @param pattern	The right side of the LIKE
1:eac0369: 	 * @param escape	The escape clause
1:baef65a: 	 * @param maxWidth	Maximum length of column, for null padding
1:eac0369: 	 *
1:dbed020: 	 * @return	The String for the &gt;= clause
1:eac0369: 	 */
1:baef65a: 	public static String greaterEqualString(String pattern, String escape, int maxWidth)
4:eac0369: 	    throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		int firstAnyChar = pattern.indexOf(anyChar);
1:eac0369: 		int firstAnyString = pattern.indexOf(anyString);
1:eac0369: 
3:eac0369: 		// 
1:eac0369: 		// For Escape we don't utilize any of the stylish code
1:eac0369: 		// below but brute force walk the pattern to find out
1:eac0369: 		// what is there, while stripping escapes
1:eac0369: 		//
1:eac0369: 
1:1c53539: 		if ((escape != null) && (escape.length() != 0))
1:eac0369: 		{
1:eac0369: 			char escChar = escape.charAt(0);
1:eac0369: 			if (pattern.indexOf(escChar) != -1)
1:eac0369: 			{
1:eac0369: 				// we return a string stripping out the escape char
1:eac0369: 				// leaving the _? in place as normal chars.
1:eac0369:                 
1:baef65a: 				return padWithNulls(greaterEqualString(pattern, escChar), maxWidth);
1:eac0369: 			}
1:eac0369: 			// drop through if no escape found
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		if (firstAnyChar == -1)
1:eac0369: 		{
1:baef65a: 			if (firstAnyString != -1) // no _, found %
1:eac0369: 			{
1:baef65a: 				pattern = pattern.substring(0, firstAnyString);
1:eac0369: 			}
1:eac0369: 		}
2:eac0369: 		else if (firstAnyString == -1)
1:eac0369: 		{
1:baef65a: 			pattern = pattern.substring(0, firstAnyChar);
1:eac0369: 		}
1:f148f1f: 		else
1:eac0369: 		{
1:baef65a: 			pattern = pattern.substring(0, (firstAnyChar > firstAnyString) ? 
1:baef65a: 											firstAnyString :
1:baef65a: 											firstAnyChar);
1:eac0369: 		}
1:baef65a: 		return padWithNulls(pattern, maxWidth);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /** 
1:eac0369:      *  greaterEqualString -- for Escape clause only
1:eac0369:      *  
1:eac0369:      *  Walk the pattern character by character
1:eac0369:      *  @param pattern like pattern to build from
1:eac0369:      *  @param escChar the escape character in the pattern
1:eac0369:      */
1:eac0369: 
1:eac0369: 	private static String greaterEqualString(String pattern, char escChar)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int patternLen = pattern.length();
2:eac0369: 		char[] patternChars = new char[patternLen];
2:eac0369: 		char[] result = new char[patternLen];
1:eac0369: 		pattern.getChars(0, patternLen, patternChars, 0);
1:eac0369: 
2:eac0369: 		int r = 0;
1:eac0369: 		for (int p = 0; p < patternLen && r < patternLen; p++)
1:eac0369: 		{
1:eac0369:             char c = patternChars[p];
1:eac0369: 		    if (c == escChar)
1:eac0369: 			{
2:eac0369: 				p++;		// don't copy the escape char
1:eac0369: 
1:eac0369: 				// run out?
1:eac0369: 				if (p >= patternLen)
3:eac0369: 					throw StandardException.newException(
3:eac0369: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
3:eac0369: 				result[r++] = patternChars[p];
2:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// stop on first pattern matching char
1:eac0369: 			if (c == anyChar || c == anyString)
1:eac0369: 			{
1:eac0369: 				return new String(result, 0, r);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			result[r++] = patternChars[p];
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // no pattern chars
1:eac0369: 		return new String(result, 0, r);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * stripEscapesNoPatternChars
1:eac0369: 	 *
1:eac0369: 	 * @param pattern	pattern String to search
1:eac0369: 	 * @param escChar	the escape character
1:eac0369: 	 *
1:eac0369: 	 * @return a stripped of ESC char string if no pattern chars, null otherwise
2:eac0369: 	 * @exception StandardException thrown if data invalid
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public static String
1:eac0369:         stripEscapesNoPatternChars(String pattern, char escChar)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int patternLen = pattern.length();
1:eac0369: 		char[] patternChars = new char[patternLen];
1:eac0369: 		char[] result = new char[patternLen];
1:eac0369: 		pattern.getChars(0, patternLen, patternChars, 0);
1:eac0369: 
1:eac0369: 		int r = 0;
1:eac0369: 		for (int p = 0; p < patternLen && r < patternLen; p++)
1:eac0369: 		{
1:eac0369: 			char c = pattern.charAt(p);
1:eac0369: 		    if (c == escChar)
1:eac0369: 			{
1:eac0369: 				p++;		// don't copy the escape char
1:eac0369: 
1:eac0369: 				// run out?
1:eac0369: 				if (p >= patternLen)
1:eac0369: 					throw StandardException.newException(
1:eac0369: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1:eac0369: 				result[r++] = patternChars[p];
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// die on first pattern matching char
1:eac0369: 			if (c == anyChar || c == anyString)
1:eac0369: 			{
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			result[r++] = patternChars[p];
1:eac0369: 		}
1:eac0369: 		return new String(result, 0, r);
1:eac0369: 	}
1:eac0369: 
1:baef65a: 	public static String lessThanStringFromParameter(String pattern, int maxWidth)
1:baef65a: 		throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (pattern == null)
1:eac0369: 			return null;
1:baef65a: 		return lessThanString(pattern, null, maxWidth);
1:baef65a: 	}
1:baef65a: 
1:baef65a: 	public static String lessThanStringFromParameterWithEsc(String pattern, String escape, int maxWidth)
1:baef65a: 		throws StandardException
1:baef65a: 	{
1:baef65a: 		if (pattern == null)
1:baef65a: 			return null;
1:baef65a: 		return lessThanString(pattern, escape, maxWidth);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * Return the substring from the pattern for the &lt; clause.
1:eac0369: 	 *
1:eac0369: 	 * @param pattern	The right side of the LIKE
1:eac0369: 	 * @param escape	The escape clause
1:baef65a: 	 * @param maxWidth	Maximum length of column, for null padding
1:eac0369: 	 *
1:dbed020: 	 * @return	The String for the &lt; clause
1:eac0369: 	 * @exception StandardException thrown if data invalid
1:eac0369: 	 */
1:baef65a: 	public static String lessThanString(String pattern, String escape, int maxWidth)
1:eac0369: 		throws StandardException
1:eac0369: 	{
2:eac0369: 		int		lastUsableChar;
2:eac0369: 		char	oldLastChar;
2:eac0369: 		char	newLastChar;
1:c1bc742: 		final int escChar;
1:eac0369: 
1:1c53539: 		if ((escape != null) && (escape.length() !=0))
1:eac0369: 		{
1:eac0369: 			escChar = escape.charAt(0);
1:eac0369: 		}
1:c1bc742: 		else {
1:c1bc742: 			// Set escape character to a value outside the char range,
1:c1bc742: 			// so that comparison with a char always evaluates to false.
1:c1bc742: 			escChar = -1;
1:c1bc742: 		}
1:eac0369: 
1:eac0369: 		/* Find the last non-wildcard character in the pattern
1:eac0369: 		 * and increment it.  In the most common case,
1:eac0369: 		 * "asdf%" becomes "asdg".  However, we need to 
1:eac0369: 		 * handle the following:
1:eac0369: 		 *
1:eac0369: 		 *	pattern			return
1:eac0369: 		 *	-------			------
1:dd611b8: 		 *	""				SUPER_STRING (match against super string)
1:eac0369: 		 *	"%..."			SUPER_STRING (match against super string)
1:eac0369: 		 *	"_..."			SUPER_STRING (match against super string)
1:eac0369: 		 *	"asdf%"			"asdg"
1:eac0369: 		 */
1:eac0369: 
1:c1bc742: 		StringBuffer upperLimit = new StringBuffer(maxWidth);
1:eac0369: 
1:c1bc742: 		// Extract the string leading up to the first wildcard.
1:c1bc742: 		for (int i = 0; i < pattern.length(); i++) {
1:c1bc742: 			char c = pattern.charAt(i);
1:c1bc742: 			if (c == escChar) {
1:c1bc742: 				if (++i >= pattern.length()) {
1:c1bc742: 					throw StandardException.newException(
1:c1bc742: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1:c1bc742: 				}
1:c1bc742: 				c = pattern.charAt(i);
1:c1bc742: 			} else if (c == anyChar || c == anyString) {
1:f148f1f: 				break;
1:c1bc742: 			}
1:c1bc742: 			upperLimit.append(c);
1:eac0369: 		}
1:eac0369: 
1:dd611b8: 		// Pattern is empty or starts with wildcard.
1:c1bc742: 		if (upperLimit.length() == 0) {
1:c1bc742: 			return SUPER_STRING;
1:eac0369: 		}
1:eac0369: 
1:c1bc742: 		// Increment the last non-wildcard character.
1:c1bc742: 		lastUsableChar = upperLimit.length() - 1;
1:c1bc742: 		oldLastChar = upperLimit.charAt(lastUsableChar);
2:eac0369: 		newLastChar = oldLastChar;
2:eac0369: 		newLastChar++;
1:eac0369: 
2:eac0369: 		// Check for degenerate roll over
2:eac0369: 		if (newLastChar < oldLastChar)
1:eac0369: 		{
4:eac0369: 			return SUPER_STRING;
1:eac0369: 		}
1:eac0369: 
1:c1bc742: 		upperLimit.setCharAt(lastUsableChar, newLastChar);
1:eac0369: 
1:c1bc742: 		// Pad the string with nulls.
1:c1bc742: 		if (upperLimit.length() < maxWidth) {
1:c1bc742: 			upperLimit.setLength(maxWidth);
1:eac0369: 		}
1:eac0369: 
1:c1bc742: 		return upperLimit.toString();
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369:  	 * Return whether or not the like comparison is still needed after
1:eac0369: 	 * performing the like transformation on a constant string.  The
1:eac0369: 	 * comparison is not needed if the constant string is of the form:
1:eac0369: 	 *		CONSTANT%  (constant followed by a trailing %)
1:eac0369: 	 *
1:eac0369: 	 * @param pattern	The right side of the LIKE
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the like comparison is still needed.
1:eac0369: 	 */
1:eac0369: 	public static boolean isLikeComparisonNeeded(String pattern)
1:eac0369: 	{
2:eac0369: 		int		firstAnyChar = pattern.indexOf(anyChar);
2:eac0369: 		int		firstAnyString = pattern.indexOf(anyString);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(pattern.length() != 0,
1:eac0369: 				"pattern expected to be non-zero length");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if no pattern matching characters, no LIKE needed
1:eac0369: 		if (firstAnyChar == -1 && firstAnyString == -1)
1:f148f1f: 			return false;
1:eac0369: 
1:eac0369: 		/* Needed if string containts anyChar */
1:eac0369: 		if (firstAnyChar != -1)
1:eac0369: 		{
1:f148f1f: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Needed if string contains and anyString in any place
1:eac0369: 		 * other than the last character.
1:eac0369: 		 */
1:eac0369: 		if (firstAnyString != pattern.length() - 1)
1:eac0369: 		{
1:dd611b8: 			return true;
1:eac0369: 		}
1:eac0369: 
4:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:baef65a: 	 * Pad a string with null characters, in order to make it &gt; and &lt;
1:baef65a: 	 * comparable with SQLChar.
1:baef65a: 	 * 
1:baef65a: 	 * @param string	The string to pad
1:baef65a: 	 * @param len		Max number of characters to pad to
1:1387d1d: 	 * @return the string padded with 0s up to the given length
1:baef65a: 	 */
1:baef65a: 	private static String padWithNulls(String string, int len) 
1:baef65a: 	{
1:baef65a: 		if(string.length() >= len)
1:baef65a: 			return string;
1:baef65a: 
1:baef65a: 		StringBuffer buf = new StringBuffer(len).append(string);
1:baef65a: 		buf.setLength(len);
1:baef65a: 		
1:baef65a: 		return buf.toString();
1:baef65a: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * Return the substring from the pattern for the optimization &gt;= clause.
1: 	 * @return	The String for the &gt;= clause
/////////////////////////////////////////////////////////////////////////
1: 	 * Return the substring from the pattern for the &lt; clause.
1: 	 * @return	The String for the &lt; clause
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
1: 	 * collation. */
/////////////////////////////////////////////////////////////////////////
1: 		Calculate the shortest length string that could match this pattern
/////////////////////////////////////////////////////////////////////////
1: 	 * checkLengths  
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		territory based collation.
/////////////////////////////////////////////////////////////////////////
commit:d0edfdc
/////////////////////////////////////////////////////////////////////////
1: 	 * If the character in val matches the character in pat, then it does not
1: 	 * matter if the database is UCS_BASIC or territory based, we simply return 
1: 	 * TRUE from the method. 
1: 	 * If the characters do not match and we are running with UCS_BASIC 
1: 	 * collation, then we will return FALSE. 
1: 	 * But if the database is territory based, then we want to use the Collator 
1: 	 * for the territory to determine if the Collator treats the 2 characters 
1: 	 * as equal (ie if their collation elements match, then the 2 characters 
1: 	 * are equal even if they  are not the same character).
1: 	 *   types. If not null, then we use it to determine the equality of the
1: 	 *   2 characters in pat and val if they are not same.
1: 		if (val[vLoc] == pat[pLoc]) { 
1: 	        // same character, so two strings consisting of this 
1: 	        // single character must be equal regardless of territory 
1: 	        return true; 
1: 	    } else if (collator == null) { 
1: 	        // not same character, must be unequal in UCS_BASIC 
1: 	        return false; 
1: 	    } 
1: 
1: 		//Check if the Collator for this database's territory considers these
1: 		//2 characters as equal based on their collation elements
1: 	    String s1 = new String(val, vLoc, 1); 
1: 	    String s2 = new String(pat, pLoc, 1); 
1: 
1: 	    return collator.compare(s1, s2) == 0; 
commit:479bbb7
/////////////////////////////////////////////////////////////////////////
0: 	 *   types. If not null, then we use it to get collation elements for 
0: 	 *   character in val and pat to do the equality comparison.
1: 	 * @return TRUE if the character in val and vLoc match based on straight
1: 	 *   equality or collation element based equality. Otherwise we will 
1: 	 *   return FALSE.
commit:f148f1f
/////////////////////////////////////////////////////////////////////////
1: 	  
1: 	 This method gets called for UCS_BASIC and territory based character
1: 	 string types to look for a pattern in a value string. It also deals
1: 	 with escape character if user has provided one.
1: 	  
/////////////////////////////////////////////////////////////////////////
1: 		@param collator null if we are dealing with UCS_BASIC 
1: 		    character string types. If not null, then we use it to 
1: 		    get collation elements for characters in val and 
1: 		    non-metacharacters in pat to do the comparison.
/////////////////////////////////////////////////////////////////////////
1: 		int 	escapeLength,
1: 		RuleBasedCollator collator
1: 		return like(val, 0, valLength, pat, 0, patLength, escape, 
1: 				escapeLength, collator);
/////////////////////////////////////////////////////////////////////////
1: 	/* For character string types with UCS_BASIC and territory based
0: 	 * collation. There is a different method for non-national chars */
/////////////////////////////////////////////////////////////////////////
1: 		int 	escapeLength,
1: 		RuleBasedCollator collator
/////////////////////////////////////////////////////////////////////////
1: 				if (checkEquality(val, vLoc, pat, pLoc, collator)) {
1: 					
1: 				} else
/////////////////////////////////////////////////////////////////////////
1: 				if (checkEquality(val, vLoc, pat, pLoc, collator)) {
/////////////////////////////////////////////////////////////////////////
1: 					Boolean restResult = Like.like(val, vLoc+n, vLoc+n+i, pat,
1: 							pLoc+1, pEnd, escape, escapeLength, collator);
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Make sure that the character in val matches the character in pat.
0: 	 * If we are dealing with UCS_BASIC character string (ie collator is null)
0: 	 * then we can just do simple character equality check. But if we are
0: 	 * dealing with territory based character string type, then we need to 
0: 	 * convert the character in val and pat into it's collation element(s)
0: 	 * and then do collation element equality comparison.
1: 	 * 
1: 	 * @param val value to compare.
1: 	 * @param vLoc character position in val.
1: 	 * @param pat pattern to look for in val.
1: 	 * @param pLoc character position in pat.
1: 	 * @param collator null if we are dealing with UCS_BASIC character string
0: 	 * types. If not null, then we use it to get collation elements for 
0: 	 * character in val and pat to do the equality comparison.
0: 	 * @return
1: 	 */
1: 	private static boolean checkEquality(char[] val, int vLoc,
1: 			char[] pat, int pLoc, RuleBasedCollator collator) {
0: 		CollationElementIterator patternIterator;
0: 		int curCollationElementInPattern;
0: 		CollationElementIterator valueIterator;
0: 		int curCollationElementInValue;
1: 
0: 		if (collator == null) {//dealing with UCS_BASIC character string
0: 			if (val[vLoc] == pat[pLoc]) 
1: 				return true;
1: 			else 
1: 				return false;
0: 		} else {//dealing with territory based character string
0: 			patternIterator = collator.getCollationElementIterator(
0: 					new String(pat, pLoc, 1));
0: 			valueIterator = collator.getCollationElementIterator(
0: 					new String(val, vLoc, 1));
0: 			curCollationElementInPattern = patternIterator.next(); 
0: 			curCollationElementInValue = valueIterator.next();
0: 			while (curCollationElementInPattern == curCollationElementInValue)
1: 			{
0: 				if (curCollationElementInPattern == CollationElementIterator.NULLORDER)
1: 					break;
0: 				curCollationElementInPattern = patternIterator.next(); 
0: 				curCollationElementInValue = valueIterator.next(); 
1: 			}
0: 			//If the current collation element for the character in pattern 
0: 			//and value do not match, then we have found a mismatach and it
0: 			//is time to return FALSE from this method.
0: 			if (curCollationElementInPattern != curCollationElementInValue)
1: 				return false;
1: 			else
1: 				return true;
1: 		}
1: 		
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		Most typical interface for character string types with UCS_BASIC and 
0: 		territory based collation. There is a different method for non-national 
0: 		chars.
1: 	public static Boolean like(char[] value, int valueLength, char[] pattern, 
1: 			int patternLength, RuleBasedCollator collator) 
1: 	throws StandardException { 
1: 		return like(value, valueLength, pattern, patternLength, null, 0, 
1: 				collator);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:dd611b8
/////////////////////////////////////////////////////////////////////////
1: 	 * clauses.  It can if the pattern is non-null and if the length == 0 or
/////////////////////////////////////////////////////////////////////////
1: 		if (pattern == null)
1:         if (pattern.length() == 0) {
1:             return true;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		 *	""				SUPER_STRING (match against super string)
/////////////////////////////////////////////////////////////////////////
1: 		// Pattern is empty or starts with wildcard.
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c1bc742
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * (NOTE: This may be null if the pattern is an empty string.)
/////////////////////////////////////////////////////////////////////////
1: 		final int escChar;
0: 		if (pattern.length() == 0)
/////////////////////////////////////////////////////////////////////////
1: 		else {
1: 			// Set escape character to a value outside the char range,
1: 			// so that comparison with a char always evaluates to false.
1: 			escChar = -1;
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		 *	""				null
1: 		StringBuffer upperLimit = new StringBuffer(maxWidth);
1: 		// Extract the string leading up to the first wildcard.
1: 		for (int i = 0; i < pattern.length(); i++) {
1: 			char c = pattern.charAt(i);
1: 			if (c == escChar) {
1: 				if (++i >= pattern.length()) {
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				}
1: 				c = pattern.charAt(i);
1: 			} else if (c == anyChar || c == anyString) {
1: 				break;
1: 			}
1: 			upperLimit.append(c);
0: 		// Pattern starts with wildcard.
1: 		if (upperLimit.length() == 0) {
1: 			return SUPER_STRING;
1: 		// Increment the last non-wildcard character.
1: 		lastUsableChar = upperLimit.length() - 1;
1: 		oldLastChar = upperLimit.charAt(lastUsableChar);
/////////////////////////////////////////////////////////////////////////
1: 		upperLimit.setCharAt(lastUsableChar, newLastChar);
1: 		// Pad the string with nulls.
1: 		if (upperLimit.length() < maxWidth) {
1: 			upperLimit.setLength(maxWidth);
1: 		return upperLimit.toString();
commit:baef65a
/////////////////////////////////////////////////////////////////////////
1: 	public static String greaterEqualStringFromParameter(String pattern, int maxWidth)
1: 		return greaterEqualString(pattern, (String) null, maxWidth);
1: 	public static String greaterEqualStringFromParameterWithEsc(String pattern, String escape, int maxWidth)
1: 		return greaterEqualString(pattern, escape, maxWidth);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param maxWidth	Maximum length of column, for null padding
1: 	public static String greaterEqualString(String pattern, String escape, int maxWidth)
/////////////////////////////////////////////////////////////////////////
1: 				return padWithNulls(greaterEqualString(pattern, escChar), maxWidth);
1: 			if (firstAnyString != -1) // no _, found %
1: 				pattern = pattern.substring(0, firstAnyString);
1: 			pattern = pattern.substring(0, firstAnyChar);
1: 			pattern = pattern.substring(0, (firstAnyChar > firstAnyString) ? 
1: 											firstAnyString :
1: 											firstAnyChar);
1: 		return padWithNulls(pattern, maxWidth);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param maxWidth	Maximum length of column, for null padding
0: 	public static String lessThanString(String pattern, int maxWidth)
/////////////////////////////////////////////////////////////////////////
0: 		return padWithNulls(new String(charArray), maxWidth);
1: 	public static String lessThanStringFromParameter(String pattern, int maxWidth)
1: 		throws StandardException 
1: 		return lessThanString(pattern, null, maxWidth);
1: 	}
1: 
1: 	public static String lessThanStringFromParameterWithEsc(String pattern, String escape, int maxWidth)
1: 		throws StandardException
1: 	{
1: 		if (pattern == null)
1: 			return null;
1: 		return lessThanString(pattern, escape, maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 	 * @param maxWidth	Maximum length of column, for null padding
1: 	public static String lessThanString(String pattern, String escape, int maxWidth)
/////////////////////////////////////////////////////////////////////////
0: 			return padWithNulls(new String(charArray), maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 		return padWithNulls(gt, maxWidth);
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Pad a string with null characters, in order to make it &gt; and &lt;
1: 	 * comparable with SQLChar.
1: 	 * 
1: 	 * @param string	The string to pad
1: 	 * @param len		Max number of characters to pad to
0: 	 * @returns the string padded with 0s up to the given length
1: 	 */
1: 	private static String padWithNulls(String string, int len) 
1: 	{
1: 		if(string.length() >= len)
1: 			return string;
1: 
1: 		StringBuffer buf = new StringBuffer(len).append(string);
1: 		buf.setLength(len);
1: 		
1: 		return buf.toString();
1: 	}
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:1387d1d
/////////////////////////////////////////////////////////////////////////
1: 	 * @return the string padded with 0s up to the given length
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.Like
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: // RESOLVE: MOVE THIS CLASS TO PROTOCOL (See LikeOperatorNode)
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.text.CollationElementIterator;
1: import java.text.Collator;
1: import java.text.RuleBasedCollator;
1: import java.util.Locale;
1: 
1: /**
1: 	Like matching algorithm. Not too speedy for %s.
1: 
1: 	SQL92 says the escape character can only and must be followed
1: 	by itself, %, or _.  So if you choose % or _ as the escape character,
1: 	you can no longer do that sort of matching.
1: 
1: 	Not the most recent Like -- missing the unit tests
1: 
0: 	@author ames
1:  */
1: public class Like {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	private static final char anyChar = '_';
1: 	private static final char anyString = '%';
1: 
1: 	private static final String SUPER_STRING = "\uffff";
1: 
1: 	private Like() { // do not instantiate
1: 	}
1: 
1: 	/**
1: 		@param val value to compare. if null, result is null.
1: 		@param valLength length of val
1: 		@param pat pattern to compare. if null, result is null.
1: 		@param patLength length of pat
1: 		@param escape escape character. Must be 1 char long.
1: 			if null, no escape character is used.
1: 		@param escapeLength length of escape
1: 
1: 		@return null if val or pat null, otherwise true if match
1: 		and false if not.
1: 		@exception StandardException thrown if data invalid
1: 	 */
1: 	public static Boolean like
1: 	(
1: 		char[] 	val, 
1: 		int 	valLength, 
1: 		char[] 	pat, 
1: 		int 	patLength, 
1: 		char[] 	escape,
0: 		int 	escapeLength
1: 	) throws StandardException 
1: 	{
0: 		return like(val, 0, valLength, pat, 0, patLength, escape, escapeLength);
1: 	}
1: 
1: 	/**
0: 		For national chars.
1: 		@param val value to compare. if null, result is null.
1: 		@param valLength length of val
1: 		@param pat pattern to compare. if null, result is null.
1: 		@param patLength length of pat
1: 		@param escape escape character. Must be 1 char long.
1: 			if null, no escape character is used.
1: 		@param escapeLength length of escape
0: 		@param collator	The collator to use.
1: 
1: 		@return null if val or pat null, otherwise true if match
1: 		and false if not.
1: 		@exception StandardException thrown if data invalid
1: 	 */
1: 	public static Boolean like
1: 	(
0: 		int[] 	val, 
1: 		int 	valLength, 
0: 		int[] 	pat, 
1: 		int 	patLength, 
0: 		int[] 	escape,
0: 		int 	escapeLength,
0: 		RuleBasedCollator collator
1: 	) throws StandardException 
1: 	{
0: 		return like(val, 0, valLength, pat, 0, patLength, escape, escapeLength, collator);
1: 	}
1: 
0: 	/* non-national chars */
1: 	private static Boolean like
1: 	(
1: 		char[] 	val, 
1: 		int 	vLoc, 	// start at val[vLoc]
1: 		int 	vEnd, 	// end at val[vEnd]
1: 		char[] 	pat, 
1: 		int 	pLoc, 	// start at pat[pLoc]
1: 		int 	pEnd, 	// end at pat[pEnd]
1: 		char[] 	escape,
0: 		int 	escapeLength
1: 	) throws StandardException 
1: 	{
1: 		char escChar = ' ';
1: 		boolean haveEsc = true;
1: 		
1: 		if (val == null) return null;
1: 		if (pat == null) return null;
1: 
1: 		if (escape == null)
1: 		{
1: 			haveEsc = false;
1: 		}
1: 		else
1: 		{
1: 			escChar = escape[0];
1: 		}
1: 
1: 		Boolean result;
1: 
1: 		while (true) {
1: 
1: 			if ((result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd)) != null) 
1: 			{
1: 				return result;
1: 			}
1: 
1: 			// go until we get a special char in the pattern or hit EOS
1: 			while (pat[pLoc] != anyChar && pat[pLoc] != anyString &&
1: 					((! haveEsc) || pat[pLoc] != escChar)) {
0: 				if (val[vLoc] == pat[pLoc]) 
1: 				{
1: 					vLoc++; pLoc++;
1: 	
1: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
1: 					if (result != null) 
1: 						return result;
1: 				}
1: 				else 
1: 				{
1: 					return Boolean.FALSE;
1: 				}
1: 			}
1: 
1: 			// deal with escChar first, as it can be escaping a special char
1: 			// and can be a special char itself.
1: 			if (haveEsc && pat[pLoc] == escChar) {
1: 				pLoc++;
1: 				if (pLoc == pEnd) {
1: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				}
1: 				if (pat[pLoc] != escChar &&
1: 				    pat[pLoc] != anyChar &&
1: 				    pat[pLoc] != anyString) {
1: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				}
1: 				// regardless of the char in pat, it must match exactly:
0: 				if (val[vLoc] == pat[pLoc]) {
1: 					vLoc++; pLoc++;
1: 	
1: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
1: 					if (result != null) 
1: 						return result;
1: 				}
1: 				else return Boolean.FALSE;
1: 			}
1: 			else if (pat[pLoc] == anyChar) {
1: 				// regardless of the char, it matches
1: 				vLoc++; pLoc++;
1: 	
1: 				result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
1: 				if (result != null) 
1: 					return result;
1: 			}
1: 			else if (pat[pLoc] == anyString) {
1: 				// catch the simple cases -- end of the pattern or of the string
1: 				if (pLoc+1 == pEnd)
1: 					return Boolean.TRUE;
1: 
1: 				// would return true, but caught in checkLengths above
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(vLoc!=vEnd, 
1: 						"Should have been found already");
1: 
1: 				//if (vLoc == vEnd) // caught in checkLengths
1: 					//return Boolean.TRUE;
1: 				// check if remainder of pattern is anyString's
1: 				// if escChar == anyString, we couldn't be here
1: 				boolean anys = true;
1: 				for (int i=pLoc+1;i<pEnd;i++)
1: 					if (pat[i]!=anyString) {
1: 						anys=false;
0: 						break;
1: 					}
1: 				if (anys) return Boolean.TRUE;
1: 
1: 				// pattern can match 0 or more chars in value.
1: 				// to test that, we take the remainder of pattern and
1: 				// apply it to ever-shorter  remainders of value until
1: 				// we hit a match.
1: 
1: 				// the loop never continues from this point -- we will
1: 				// always generate an answer here.
1: 
1: 				// REMIND: there are smarter ways to pick the remainders
1: 				// and do this matching.
1: 
1: 				// num chars left in value includes current char
1: 				int vRem = vEnd - vLoc;
1: 
1: 				int n=0;
1: 
1: 				// num chars left in pattern excludes the anychar
1: 				int minLen = getMinLen(pat, pLoc+1, pEnd, haveEsc, escChar);
1: 				for (int i=vRem; i>=minLen; i--) 
1: 				{
0: 					Boolean restResult = Like.like(val,vLoc+n,vLoc+n+i,pat,pLoc+1,pEnd,escape,escapeLength);
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (restResult == null)
1: 						{
1: 							String vStr = new String(val,vLoc+n,i);
1: 							String pStr = new String(pat,pLoc+1,pEnd-(pLoc+1));
1: 							SanityManager.THROWASSERT("null result on like(value = "+vStr+", pat = "+pStr+")");
1: 						}
1: 					}
1: 					if (restResult.booleanValue())
1: 						return restResult;
1: 
1: 					n++;
1: 				}
1: 				// none of the possibilities worked 
1: 				return Boolean.FALSE;
1: 			}
1: 		}
1: 	}
1: 
0: 	/* national chars */
1: 	private static Boolean like
1: 	(
0: 		int[] 	val, 
1: 		int 	vLoc, 	// start at val[vLoc]
1: 		int 	vEnd, 	// end at val[vEnd]
0: 		int[] 	pat, 
1: 		int 	pLoc, 	// start at pat[pLoc]
1: 		int 	pEnd, 	// end at pat[pEnd]
0: 		int[] 	escape,
0: 		int 	escapeLength,
0: 		RuleBasedCollator	collator
1: 	) throws StandardException 
1: 	{
0: 		int[] escCharInts = null;
1: 		boolean haveEsc = true;
0: 		int[] anyCharInts = new int[1];	// assume only 1 int
0: 		int[] anyStringInts = new int[1];	// assume only 1 int
1: 		
1: 		if (val == null) return null;
1: 		if (pat == null) return null;
1: 
1: 		if (escape == null)
1: 		{
1: 			haveEsc = false;
1: 		}
1: 		else
1: 		{
0: 			escCharInts = escape;
1: 		}
1: 
1: 		Boolean result;
1: 
0: 		// get the collation integer representing "_"
0: 		CollationElementIterator cei =
0: 									collator.getCollationElementIterator("_");
0: 		anyCharInts[0] = cei.next();
1: 		{
0: 			int nextInt;
1: 
0: 			// There may be multiple ints representing this character
0: 			while ((nextInt = cei.next()) != CollationElementIterator.NULLORDER)
1: 			{
0: 				int[] temp = new int[anyCharInts.length + 1];
0: 				for (int index = 0; index < anyCharInts.length; index++)
1: 				{
0: 					temp[index] = anyCharInts[index];
1: 				}
0: 				temp[anyCharInts.length] = nextInt;
0: 				anyCharInts = temp;
1: 			}
1: 		}
0: 		// get the collation integer representing "%"
0: 		cei = collator.getCollationElementIterator("%");
0: 		anyStringInts[0] = cei.next();
1: 		{
0: 			int nextInt;
1: 
0: 			// There may be multiple ints representing this character
0: 			while ((nextInt = cei.next()) != CollationElementIterator.NULLORDER)
1: 			{
0: 				int[] temp = new int[anyStringInts.length + 1];
0: 				for (int index = 0; index < anyStringInts.length; index++)
1: 				{
0: 					temp[index] = anyStringInts[index];
1: 				}
0: 				temp[anyStringInts.length] = nextInt;
0: 				anyStringInts = temp;
1: 			}
1: 		}
1: 
0: 		while (true) 
1: 		{
0: 			// returns null if more work to do, otherwise match Boolean
0: 			result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd, anyStringInts);
1: 			if (result != null) 
1: 				return result;
1: 
1: 			// go until we get a special char in the pattern or hit EOS
0: 			while ( (! matchSpecial(pat, pLoc, pEnd, anyCharInts)) &&
0: 					(! matchSpecial(pat, pLoc, pEnd, anyStringInts)) &&
0: 					((! haveEsc)
0: 						|| (! matchSpecial(pat, pLoc, pEnd, escCharInts))))
1: 			{
0: 				if (val[vLoc] == pat[pLoc]) 
1: 				{
1: 					vLoc++; pLoc++;
1: 	
0: 					result = checkLengths(vLoc, vEnd, pLoc,
0: 								pat, pEnd, anyStringInts);
1: 					if (result != null) 
1: 					{
1: 						return result;
1: 					}
1: 				}
1: 				else 
1: 				{
1: 					return Boolean.FALSE;
1: 				}
1: 			}
1: 
0: 			// deal with escCharInt first, as it can be escaping a special char
1: 			// and can be a special char itself.
0: 			if (haveEsc && matchSpecial(pat, pLoc, pEnd, escCharInts))
1: 			{
0: 				pLoc += escCharInts.length;
1: 				if (pLoc == pEnd) 
1: 				{
1: 					throw StandardException.newException(
1: 						SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				}
1: 
0: 				int[] specialInts = null;
0: 				if (matchSpecial(pat, pLoc, pEnd, escCharInts))
1: 				{
0: 					specialInts = escCharInts;
1: 				}
0: 				if (matchSpecial(pat, pLoc, pEnd, anyCharInts))
1: 				{
0: 					specialInts = anyCharInts;
1: 				}
0: 				if (matchSpecial(pat, pLoc, pEnd, anyStringInts))
1: 				{
0: 					specialInts = anyStringInts;
1: 				}
0: 				if (specialInts == null)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				}
1: 				// regardless of the char in pat, it must match exactly:
0: 				for (int index = 0; index < specialInts.length; index++)
1: 				{
0: 					if (val[vLoc + index] != pat[pLoc + index])
1: 					{
1: 						return Boolean.FALSE;
1: 					}
1: 				}
1: 
0: 				vLoc += specialInts.length; 
0: 				pLoc += specialInts.length; 
1: 	
0: 				// returns null if more work to do, otherwise match Boolean
0: 				result = checkLengths(vLoc, vEnd,
0: 						pLoc, pat, pEnd, anyStringInts);
1: 
1: 				if (result != null) 
1: 					return result;
1: 			}
0: 			else if (matchSpecial(pat, pLoc, pEnd, anyCharInts))
1: 			{
1: 				// regardless of the char, it matches
0: 				vLoc += anyCharInts.length; 
0: 				pLoc += anyCharInts.length; 
1: 	
0: 				result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd, anyStringInts);
1: 				if (result != null) 
1: 					return result;
1: 			}
0: 			else if (matchSpecial(pat, pLoc, pEnd, anyStringInts))
1: 			{
1: 				// catch the simple cases -- end of the pattern or of the string
1: 				if (pLoc+1 == pEnd)
1: 					return Boolean.TRUE;
1: 
1: 				// would return true, but caught in checkLengths above
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(vLoc!=vEnd, 
1: 						"Should have been found already");
1: 
1: 				if (vLoc == vEnd)
1: 					return Boolean.TRUE;
1: 
1: 				// check if remainder of pattern is anyString's
1: 				// if escChar == anyString, we couldn't be here
0: 				// If there is an escape in the pattern we break
0: 				boolean allPercentChars = true;
1: 				for (int i=pLoc+1;i<pEnd;i++)
1: 				{
0: 					if (! matchSpecial(pat, i, pEnd, anyStringInts))
1: 					{
0: 						allPercentChars=false;
0: 						break;
1: 					}
1: 				}
0: 				if (allPercentChars)
1: 					return Boolean.TRUE;
1: 
1: 				// pattern can match 0 or more chars in value.
1: 				// to test that, we take the remainder of pattern and
1: 				// apply it to ever-shorter  remainders of value until
1: 				// we hit a match.
1: 
1: 				// the loop never continues from this point -- we will
1: 				// always generate an answer here.
1: 
1: 				// REMIND: there are smarter ways to pick the remainders
1: 				// and do this matching.
1: 
1: 				// num chars left in value includes current char
1: 				int vRem = vEnd - vLoc;
1: 
1: 				int n=0;
1: 
0: 				// num chars left in pattern excludes the anyString
0: 				int minLen = getMinLen(pat, pLoc+1, pEnd, haveEsc, escCharInts, anyStringInts);
1: 				for (int i=vRem; i>=minLen; i--) 
1: 				{
0: 					Boolean restResult = Like.like(val,vLoc+n,vLoc+n+i,pat,pLoc+1,pEnd,escape,escapeLength, collator);
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (restResult == null)
1: 						{
0: 							SanityManager.THROWASSERT("null result on like(vLoc+n = "+(vLoc+n)+", i = "+i+
0: 													  ", pLoc+1 = " + (pLoc+1) + ", pEnd-(pLoc+1) = " + 
0: 													  (pEnd-(pLoc+1)) + ")");
1: 						}
1: 					}
1: 					if (restResult.booleanValue())
1: 						return restResult;
1: 
1: 					n++;
1: 				}
1: 				// none of the possibilities worked 
1: 				return Boolean.FALSE;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 		Calculate the shortest length string that could match this pattern for non-national chars
1: 	 */
1: 	static int getMinLen(char[] pattern, int pStart, int pEnd, boolean haveEsc, char escChar) 
1: 	{
1: 		int m=0;
1: 		for (int l = pStart; l<pEnd; ) 
1: 		{
1: 			if (haveEsc && pattern[l] == escChar) { // need one char
1: 				l+=2;
1: 				m++;
1: 			}
1: 			else if (pattern[l] == anyString) {
1: 				l++; // anyString, nothing needed
1: 			}
1: 			else { // anyChar or other chars, need one char
1: 				l++; m++;
1: 			}
1: 		}
1: 		return m;
1: 	}
1: 
1: 	/**
0: 		Calculate the shortest length string that could match this pattern for national chars
1: 	 */
0: 	static int getMinLen(int[] pattern, int pStart, int pEnd, boolean haveEsc, 
0: 						 int[] escCharInts, int[] anyStringInts) 
1: 	{
1: 		int m=0;
1: 		for (int l = pStart; l<pEnd; ) 
1: 		{
0: 			if (haveEsc && matchSpecial(pattern, l, pEnd, escCharInts))
1: 			{ 
0: 				l += escCharInts.length + 1;
0: 				m += escCharInts.length;
1: 			}
0: 			else if (matchSpecial(pattern, l, pEnd, anyStringInts)) 
1: 			{
0: 				l += anyStringInts.length; // anyString, nothing needed
1: 			}
1: 			else 
0: 			{ // anyChar or other chars, need one char
1: 				l++; m++;
1: 			}
1: 		}
1: 		return m;
1: 	}
1: 
1: 	/**
0: 	 * checkLengths -- non-national chars 
1: 	 *
1: 	 * Returns null if we are not done.
1: 	 * Returns true if we are at the end of our value and pattern
1: 	 * Returns false if there is more pattern left but out of input value
1: 	 *
1: 	 * @param vLoc current index into char[] val
1: 	 * @param vEnd end index or our value
1: 	 * @param pLoc current index into our char[] pattern
1: 	 * @param pat  pattern char []
1: 	 * @param pEnd end index of our pattern []
1: 	 */
1: 
1: 	static Boolean checkLengths(int vLoc, int vEnd,
1: 			int pLoc, char[] pat, int pEnd) 
1: 	{
1: 		if (vLoc == vEnd) 
1: 		{
1: 			if (pLoc == pEnd) 
1: 			{
1: 				return Boolean.TRUE;
1: 			}
1: 			else 
1: 			{
1: 				// if remainder of pattern is anyString chars, ok
1: 				for (int i=pLoc; i<pEnd; i++) 
1: 				{
1: 					if (pat[i] != anyString)
1: 					{
1: 						return Boolean.FALSE; // more to match
1: 					}
1: 				}
1: 				return Boolean.TRUE;
1: 			}
1: 		}
1: 		else if (pLoc == pEnd)
1: 		{
1: 			return Boolean.FALSE; // ran out of pattern
1: 		}
1: 		else return null; // still have strings to match, not done
1: 	}
1: 
1: 	/**
0: 	 * checkLengths -- national chars 
1: 	 *
1: 	 * Returns null if we are not done.
1: 	 * Returns true if we are at the end of our value and pattern
1: 	 * Returns false if there is more pattern left but out of input value
1: 	 *
0: 	 * @param vLoc current index into int[] val
1: 	 * @param vEnd end index or our value
0: 	 * @param pLoc current index into our int[] pattern
0: 	 * @param pat  pattern int []
1: 	 * @param pEnd end index of our pattern []
1: 	 */
1: 
1: 	static Boolean checkLengths(int vLoc, int vEnd,
0: 			int pLoc, int[] pat, int pEnd, int[] anyStringInts) 
1: 	{
1: 		if (vLoc == vEnd) 
1: 		{
1: 			if (pLoc == pEnd) 
1: 			{
1: 				return Boolean.TRUE;
1: 			}
1: 			else 
1: 			{
1: 				// if remainder of pattern is anyString chars, ok
0: 				for (int i=pLoc; i<pEnd; i += anyStringInts.length) 
1: 				{
0: 					if (! matchSpecial(pat, i, pEnd, anyStringInts))
1: 					{
1: 						return Boolean.FALSE;
1: 					}
1: 				}
1: 				return Boolean.TRUE;
1: 			}
1: 		}
1: 		else if (pLoc == pEnd)
1: 		{
1: 			return Boolean.FALSE; // ran out of pattern
1: 		}
1: 		else return null; // still have strings to match, not done
1: 	}
1: 
1: 	/**
0: 	 * matchSpecial
1: 	 *
0: 	 *	check the pattern against the various special character arrays.
0: 	 *  The array can be anyStringInts, anyCharInts or anyEscChars (always 1)
1: 	 */
1: 
0: 	private static boolean matchSpecial(int[] pat, int patStart, int patEnd, int[] specialInts)
1: 	{
1: 		//
0: 		// multi-collation units per char can exceed the pattern length
0: 		// and we fall around the 2nd if statement and falsely return true.
1: 		//
0: 		if (specialInts.length > patEnd - patStart)
1: 		    return false;
0: 		if (specialInts.length <= patEnd - patStart)
1: 		{
0: 			for (int index = 0; index < specialInts.length; index++)
1: 			{
0: 				if (pat[patStart + index] != specialInts[index])
1: 				{
0: 					return false; // more to match
1: 				}
1: 			}
1: 		}
0: 		return true;
1: 	}
1: 
1: 
1: 	/*
0: 		Most typical interface for non-national chars
1: 	 */
0: 	public static Boolean like(char[] value, int valueLength, char[] pattern, int patternLength) throws StandardException { 
1: 		if (value == null || pattern == null) return null;
0: 		return like(value, valueLength, pattern, patternLength, null, 0);
1: 	}
1: 
1: 	/*
0: 		Most typical interface for national chars
1: 	 */
0: 	public static Boolean like(int[] value, int valueLength, int[] pattern, int patternLength, RuleBasedCollator collator) 
1: 		throws StandardException 
1: 	{ 
1: 		if (value == null || pattern == null) return null;
0: 		return like(value, valueLength, pattern, patternLength, null, 0, collator);
1: 	}
1: 
1: 	// Methods for LIKE transformation at preprocess time:
1: 
1: 	/**
1: 	 * Determine whether or not this LIKE can be transformed into optimizable
0: 	 * clauses.  It can if the pattern is non-null, of length > 0 and
1: 	 * the first character is not a wild card.
1: 	 *
1: 	 * @param pattern	The right side of the LIKE
1: 	 *
1: 	 * @return	Whether or not the LIKE can be transformed
1: 	 */
1: 
1: 	public static boolean isOptimizable(String pattern)
1: 	{
0: 		if (pattern == null || (pattern.length() == 0))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		// if we have pattern matching at start of string, no optimization
1: 		char firstChar = pattern.charAt(0);
1: 
1: 		return (firstChar != anyChar && firstChar != anyString);
1: 	}
1: 
0: 	public static String greaterEqualStringFromParameter(String pattern)
1: 		throws StandardException {
1: 
1: 		if (pattern == null)
1: 			return null;
1: 
0: 		return greaterEqualString(pattern, (String) null);
1: 	}
1: 
0: 	public static String greaterEqualStringFromParameterWithEsc(String pattern, String escape)
1: 		throws StandardException {
1: 
1: 		if (pattern == null)
1: 			return null;
1: 
0: 		return greaterEqualString(pattern, escape);
1: 	}
1: 
1: 	/**
0: 	 * Return the substring from the pattern for the optimization >= clause.
1: 	 *
1: 	 * @param pattern	The right side of the LIKE
1: 	 * @param escape	The escape clause
1: 	 *
0: 	 * @return	The String for the >= clause
1: 	 */
0: 	public static String greaterEqualString(String pattern, String escape)
1: 	    throws StandardException
1: 	{
1: 
1: 		int firstAnyChar = pattern.indexOf(anyChar);
1: 		int firstAnyString = pattern.indexOf(anyString);
1: 
1: 		// 
1: 		// For Escape we don't utilize any of the stylish code
1: 		// below but brute force walk the pattern to find out
1: 		// what is there, while stripping escapes
1: 		//
1: 
0: 		if (escape != null)
1: 		{
1: 			char escChar = escape.charAt(0);
1: 			if (pattern.indexOf(escChar) != -1)
1: 			{
1: 				// we return a string stripping out the escape char
1: 				// leaving the _? in place as normal chars.
1:                 
0: 				return greaterEqualString(pattern, escChar);
1: 			}
1: 			// drop through if no escape found
1: 		}
1: 
1: 		if (firstAnyChar == -1)
1: 		{
0: 			if (firstAnyString == -1)
1: 			{
0: 				return pattern;
1: 			}
0: 			else	// no _, found %
1: 			{
0: 				return pattern.substring(0, firstAnyString);
1: 			}
1: 		}
1: 		else if (firstAnyString == -1)
1: 		{
0: 			return pattern.substring(0, firstAnyChar);
1: 		}
1: 		else
1: 		{
0: 			return pattern.substring(0, (firstAnyChar > firstAnyString) ? 
0: 										firstAnyString :
0: 										firstAnyChar);
1: 		}
1: 	}
1: 
1:     /** 
1:      *  greaterEqualString -- for Escape clause only
1:      *  
1:      *  Walk the pattern character by character
1:      *  @param pattern like pattern to build from
1:      *  @param escChar the escape character in the pattern
1:      */
1: 
1: 	private static String greaterEqualString(String pattern, char escChar)
1: 		throws StandardException
1: 	{
1: 		int patternLen = pattern.length();
1: 		char[] patternChars = new char[patternLen];
1: 		char[] result = new char[patternLen];
1: 		pattern.getChars(0, patternLen, patternChars, 0);
1: 
1: 		int r = 0;
1: 		for (int p = 0; p < patternLen && r < patternLen; p++)
1: 		{
1:             char c = patternChars[p];
1: 		    if (c == escChar)
1: 			{
1: 				p++;		// don't copy the escape char
1: 
1: 				// run out?
1: 				if (p >= patternLen)
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				result[r++] = patternChars[p];
1: 				continue;
1: 			}
1: 
1: 			// stop on first pattern matching char
1: 			if (c == anyChar || c == anyString)
1: 			{
1: 				return new String(result, 0, r);
1: 			}
1: 
1: 			result[r++] = patternChars[p];
1: 		}
1: 
1:         // no pattern chars
1: 		return new String(result, 0, r);
1: 	}
1: 
1: 	/**
1: 	 * stripEscapesNoPatternChars
1: 	 *
1: 	 * @param pattern	pattern String to search
1: 	 * @param escChar	the escape character
1: 	 *
1: 	 * @return a stripped of ESC char string if no pattern chars, null otherwise
1: 	 * @exception StandardException thrown if data invalid
1: 	 */
1: 
1: 	public static String
1:         stripEscapesNoPatternChars(String pattern, char escChar)
1: 		throws StandardException
1: 	{
1: 		int patternLen = pattern.length();
1: 		char[] patternChars = new char[patternLen];
1: 		char[] result = new char[patternLen];
1: 		pattern.getChars(0, patternLen, patternChars, 0);
1: 
1: 		int r = 0;
1: 		for (int p = 0; p < patternLen && r < patternLen; p++)
1: 		{
1: 			char c = pattern.charAt(p);
1: 		    if (c == escChar)
1: 			{
1: 				p++;		// don't copy the escape char
1: 
1: 				// run out?
1: 				if (p >= patternLen)
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				result[r++] = patternChars[p];
1: 				continue;
1: 			}
1: 
1: 			// die on first pattern matching char
1: 			if (c == anyChar || c == anyString)
1: 			{
1: 				return null;
1: 			}
1: 
1: 			result[r++] = patternChars[p];
1: 		}
1: 		return new String(result, 0, r);
1: 	}
1: 
1: 	/**
0: 	 * Return the substring from the pattern for the < clause.
0: 	 * (NOTE: This may be null in the degenerate case where the
0: 	 * last char before the first wild card can't be incremented.)
1: 	 *
0: 	 *		Optimized for ESCAPE
1: 	 *
0: 	 * This function uses the greaterThanString, and bumps its last
0: 	 * character by one.   This string has no escape characters, they
0: 	 * were stripped out, and ends just before any real pattern chars or
0: 	 * at the end of the pattern literal.    See LikeEscapeOp*Node.preprocess.
1: 	 *
1: 	 * @param pattern	The right side of the LIKE
1: 	 *
0: 	 * @return	The String for the < clause
1: 	 * @exception StandardException thrown if data invalid
1: 	 */
0: 	public static String lessThanString(String pattern)
1: 		throws StandardException
1: 	{
0: 		//int		firstAnyChar = pattern.indexOf(anyChar);
0: 		//int		firstAnyString = pattern.indexOf(anyString);
1: 		int		lastUsableChar;
0: 		int		patternLen;
1: 		char	oldLastChar;
1: 		char	newLastChar;
0: 		char[]	charArray;
1: 
0: 		if ((patternLen = pattern.length()) == 0)
1: 		{
0: 			// pattern is ""
1: 			return null;
1: 		}
1: 		
0: 		lastUsableChar = patternLen -1;
0: 		oldLastChar = pattern.charAt(lastUsableChar);
1: 		newLastChar = oldLastChar;
1: 		newLastChar++;
1: 
1: 		// Check for degenerate roll over
1: 		if (newLastChar < oldLastChar)
1: 		{
1: 			return null;
1: 		}
1: 
0: 		charArray = pattern.substring(0, lastUsableChar + 1).toCharArray();
0: 		charArray[lastUsableChar] = newLastChar;
1: 
0: 		return new String(charArray);
1: 	}
1: 
0: 	public static String lessThanStringFromParameter(String pattern) throws StandardException {
1: 		if (pattern == null)
1: 			return null;
0: 		return lessThanString(pattern, null);
1: 	}
1: 
0: 	public static String lessThanStringFromParameterWithEsc(String pattern, String escape)
1: 		 throws StandardException
1: 	{
1: 		if (pattern == null)
1: 			return null;
0: 		return lessThanString(pattern, escape);
1: 	}
1: 
1: 	/**
0: 	 * Return the substring from the pattern for the < clause.
0: 	 * (NOTE: This may be null in the degenerate case where the
0: 	 * last char before the first wild card can't be incremented.)
1: 	 *
0: 	 * 		This is unoptimized for ESCAPE.
1: 	 *
1: 	 *
1: 	 * @param pattern	The right side of the LIKE
1: 	 * @param escape	The escape clause
1: 	 *
0: 	 * @return	The String for the < clause
1: 	 * @exception StandardException thrown if data invalid
1: 	 */
0: 	public static String lessThanString(String pattern, String escape)
1: 		throws StandardException
1: 	{
1: 		int		lastUsableChar;
0: 		int		patternLen;
1: 		char	oldLastChar;
1: 		char	newLastChar;
0: 		char[]	charArray;
0: 		char escChar = 'a';
1: 
0: 		if ((patternLen = pattern.length()) == 0)
1: 		{
0: 			// pattern is ""
1: 			return null;
1: 		}
1: 
0: 		if (escape != null)
1: 		{
1: 			escChar = escape.charAt(0);
1: 		}
1: 
1: 		/* Find the last non-wildcard character in the pattern
1: 		 * and increment it.  In the most common case,
1: 		 * "asdf%" becomes "asdg".  However, we need to 
1: 		 * handle the following:
1: 		 *
1: 		 *	pattern			return
1: 		 *	-------			------
0: 		 *	""				SUPER_STRING (match against super string)
1: 		 *	"%..."			SUPER_STRING (match against super string)
1: 		 *	"_..."			SUPER_STRING (match against super string)
1: 		 *	"asdf%"			"asdg"
1: 		 */
1: 
1: 		int		firstAnyChar = pattern.indexOf(anyChar);
1: 		int		firstAnyString = pattern.indexOf(anyString);
1: 
1: 
0: 		if (escape != null)
1: 		{
0: 			while (firstAnyChar > 0 && pattern.charAt(firstAnyChar-1) == escChar)
0: 				firstAnyChar = pattern.indexOf(anyChar, firstAnyChar+1);
0: 			while (firstAnyString > 0 && pattern.charAt(firstAnyString-1) == escChar)
0: 				firstAnyString = pattern.indexOf(anyString, firstAnyString+1);
1: 		}
1: 
1: 		if (firstAnyChar == -1)
1: 		{
0: 			if (firstAnyString == -1)
1: 			{
0: 				lastUsableChar = pattern.length() -1;
1: 			}
0: 			else if (firstAnyString == 0)
1: 			{
0: 				// pattern is "%"
1: 				return SUPER_STRING;
1: 			}
1: 			else
1: 			{
0: 				lastUsableChar = firstAnyString - 1;
1: 			}
1: 		}
1: 		else if (firstAnyString == -1)
1: 		{
0: 			if (firstAnyChar == 0)
1: 			{
0: 				// pattern is "_"
1: 				return SUPER_STRING;
1: 			}
0: 			lastUsableChar = firstAnyChar - 1;
1: 		}
1: 		else
1: 		{
0: 			// both _ and % present
0: 			lastUsableChar = ((firstAnyChar > firstAnyString) ? 
0: 										firstAnyString :
0: 										firstAnyChar) - 1;
1: 
0: 			if (lastUsableChar == -1)
1: 			{
0: 				// pattern starts with a wildcard
1: 				return SUPER_STRING;
1: 			}
1: 		}
1: 
0: 		oldLastChar = pattern.charAt(lastUsableChar);
1: 		newLastChar = oldLastChar;
1: 		newLastChar++;
1: 
1: 		// Check for degenerate roll over
1: 		if (newLastChar < oldLastChar)
1: 		{
1: 			return SUPER_STRING;
1: 		}
1: 
1: 		if (escape == null)
1: 		{
0: 			charArray = pattern.substring(0, lastUsableChar + 1).toCharArray();
0: 			charArray[lastUsableChar] = newLastChar;
1: 
0: 			return new String(charArray);
1: 		}
1: 		char[] patternChars = new char[patternLen];
1: 		char[] result = new char[patternLen];
0: 		pattern.getChars(0, patternLen, patternChars, 0) ;
1: 
1: 		int r = 0;
0: 		for (int p = 0; p < lastUsableChar; p++)
1: 		{
0: 		    if (patternChars[p] == escChar)
1: 			{
1: 				p++;		// don't copy the escape char
1: 
0: 				// run out: eg.  Escape char last char?
0: 				if (p >= patternLen-1)
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
1: 				result[r++] = patternChars[p];
1: 				continue;
1: 			}
1: 
1: 			result[r++] = patternChars[p];
1: 		}
0: 		result[r++] = newLastChar;
0: 		String gt = new String(result, 0, r);
0: 		return gt;
1: 	}
1: 	
1: 	/**
1:  	 * Return whether or not the like comparison is still needed after
1: 	 * performing the like transformation on a constant string.  The
1: 	 * comparison is not needed if the constant string is of the form:
1: 	 *		CONSTANT%  (constant followed by a trailing %)
1: 	 *
1: 	 * @param pattern	The right side of the LIKE
1: 	 *
1: 	 * @return Whether or not the like comparison is still needed.
1: 	 */
1: 	public static boolean isLikeComparisonNeeded(String pattern)
1: 	{
1: 		int		firstAnyChar = pattern.indexOf(anyChar);
1: 		int		firstAnyString = pattern.indexOf(anyString);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(pattern.length() != 0,
1: 				"pattern expected to be non-zero length");
1: 		}
1: 
1: 		// if no pattern matching characters, no LIKE needed
1: 		if (firstAnyChar == -1 && firstAnyString == -1)
1: 			return false;
1: 
1: 		/* Needed if string containts anyChar */
1: 		if (firstAnyChar != -1)
1: 		{
0: 			return true;
1: 		}
1: 
1: 		/* Needed if string contains and anyString in any place
1: 		 * other than the last character.
1: 		 */
1: 		if (firstAnyString != pattern.length() - 1)
1: 		{
0: 			return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:1c53539
/////////////////////////////////////////////////////////////////////////
1: 		if ((escape != null) && (escape.length() != 0))
/////////////////////////////////////////////////////////////////////////
1: 		if ((escape != null) && (escape.length() !=0))
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: // RESOLVE: MOVE THIS CLASS TO PROTOCOL (See LikeOperatorNode)
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.text.CollationElementIterator;
0: import java.text.Collator;
0: import java.text.RuleBasedCollator;
0: import java.util.Locale;
0: 
0: /**
0: 	Like matching algorithm. Not too speedy for %s.
0: 
0: 	SQL92 says the escape character can only and must be followed
0: 	by itself, %, or _.  So if you choose % or _ as the escape character,
0: 	you can no longer do that sort of matching.
0: 
0: 	Not the most recent Like -- missing the unit tests
0: 
0: 	@author ames
0:  */
0: public class Like {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private static final char anyChar = '_';
0: 	private static final char anyString = '%';
0: 
0: 	private static final String SUPER_STRING = "\uffff";
0: 
0: 	private Like() { // do not instantiate
0: 	}
0: 
0: 	/**
0: 		@param val value to compare. if null, result is null.
0: 		@param valLength length of val
0: 		@param pat pattern to compare. if null, result is null.
0: 		@param patLength length of pat
0: 		@param escape escape character. Must be 1 char long.
0: 			if null, no escape character is used.
0: 		@param escapeLength length of escape
0: 
0: 		@return null if val or pat null, otherwise true if match
0: 		and false if not.
0: 		@exception StandardException thrown if data invalid
0: 	 */
0: 	public static Boolean like
0: 	(
0: 		char[] 	val, 
0: 		int 	valLength, 
0: 		char[] 	pat, 
0: 		int 	patLength, 
0: 		char[] 	escape,
0: 		int 	escapeLength
0: 	) throws StandardException 
0: 	{
0: 		return like(val, 0, valLength, pat, 0, patLength, escape, escapeLength);
0: 	}
0: 
0: 	/**
0: 		For national chars.
0: 		@param val value to compare. if null, result is null.
0: 		@param valLength length of val
0: 		@param pat pattern to compare. if null, result is null.
0: 		@param patLength length of pat
0: 		@param escape escape character. Must be 1 char long.
0: 			if null, no escape character is used.
0: 		@param escapeLength length of escape
0: 		@param collator	The collator to use.
0: 
0: 		@return null if val or pat null, otherwise true if match
0: 		and false if not.
0: 		@exception StandardException thrown if data invalid
0: 	 */
0: 	public static Boolean like
0: 	(
0: 		int[] 	val, 
0: 		int 	valLength, 
0: 		int[] 	pat, 
0: 		int 	patLength, 
0: 		int[] 	escape,
0: 		int 	escapeLength,
0: 		RuleBasedCollator collator
0: 	) throws StandardException 
0: 	{
0: 		return like(val, 0, valLength, pat, 0, patLength, escape, escapeLength, collator);
0: 	}
0: 
0: 	/* non-national chars */
0: 	private static Boolean like
0: 	(
0: 		char[] 	val, 
0: 		int 	vLoc, 	// start at val[vLoc]
0: 		int 	vEnd, 	// end at val[vEnd]
0: 		char[] 	pat, 
0: 		int 	pLoc, 	// start at pat[pLoc]
0: 		int 	pEnd, 	// end at pat[pEnd]
0: 		char[] 	escape,
0: 		int 	escapeLength
0: 	) throws StandardException 
0: 	{
0: 		char escChar = ' ';
0: 		boolean haveEsc = true;
0: 		
0: 		if (val == null) return null;
0: 		if (pat == null) return null;
0: 
0: 		if (escape == null)
0: 		{
0: 			haveEsc = false;
0: 		}
0: 		else
0: 		{
0: 			escChar = escape[0];
0: 		}
0: 
0: 		Boolean result;
0: 
0: 		while (true) {
0: 
0: 			if ((result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd)) != null) 
0: 			{
0: 				return result;
0: 			}
0: 
0: 			// go until we get a special char in the pattern or hit EOS
0: 			while (pat[pLoc] != anyChar && pat[pLoc] != anyString &&
0: 					((! haveEsc) || pat[pLoc] != escChar)) {
0: 				if (val[vLoc] == pat[pLoc]) 
0: 				{
0: 					vLoc++; pLoc++;
0: 	
0: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
0: 					if (result != null) 
0: 						return result;
0: 				}
0: 				else 
0: 				{
0: 					return Boolean.FALSE;
0: 				}
0: 			}
0: 
0: 			// deal with escChar first, as it can be escaping a special char
0: 			// and can be a special char itself.
0: 			if (haveEsc && pat[pLoc] == escChar) {
0: 				pLoc++;
0: 				if (pLoc == pEnd) {
0: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				}
0: 				if (pat[pLoc] != escChar &&
0: 				    pat[pLoc] != anyChar &&
0: 				    pat[pLoc] != anyString) {
0: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				}
0: 				// regardless of the char in pat, it must match exactly:
0: 				if (val[vLoc] == pat[pLoc]) {
0: 					vLoc++; pLoc++;
0: 	
0: 					result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
0: 					if (result != null) 
0: 						return result;
0: 				}
0: 				else return Boolean.FALSE;
0: 			}
0: 			else if (pat[pLoc] == anyChar) {
0: 				// regardless of the char, it matches
0: 				vLoc++; pLoc++;
0: 	
0: 				result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd);
0: 				if (result != null) 
0: 					return result;
0: 			}
0: 			else if (pat[pLoc] == anyString) {
0: 				// catch the simple cases -- end of the pattern or of the string
0: 				if (pLoc+1 == pEnd)
0: 					return Boolean.TRUE;
0: 
0: 				// would return true, but caught in checkLengths above
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(vLoc!=vEnd, 
0: 						"Should have been found already");
0: 
0: 				//if (vLoc == vEnd) // caught in checkLengths
0: 					//return Boolean.TRUE;
0: 				// check if remainder of pattern is anyString's
0: 				// if escChar == anyString, we couldn't be here
0: 				boolean anys = true;
0: 				for (int i=pLoc+1;i<pEnd;i++)
0: 					if (pat[i]!=anyString) {
0: 						anys=false;
0: 						break;
0: 					}
0: 				if (anys) return Boolean.TRUE;
0: 
0: 				// pattern can match 0 or more chars in value.
0: 				// to test that, we take the remainder of pattern and
0: 				// apply it to ever-shorter  remainders of value until
0: 				// we hit a match.
0: 
0: 				// the loop never continues from this point -- we will
0: 				// always generate an answer here.
0: 
0: 				// REMIND: there are smarter ways to pick the remainders
0: 				// and do this matching.
0: 
0: 				// num chars left in value includes current char
0: 				int vRem = vEnd - vLoc;
0: 
0: 				int n=0;
0: 
0: 				// num chars left in pattern excludes the anychar
0: 				int minLen = getMinLen(pat, pLoc+1, pEnd, haveEsc, escChar);
0: 				for (int i=vRem; i>=minLen; i--) 
0: 				{
0: 					Boolean restResult = Like.like(val,vLoc+n,vLoc+n+i,pat,pLoc+1,pEnd,escape,escapeLength);
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (restResult == null)
0: 						{
0: 							String vStr = new String(val,vLoc+n,i);
0: 							String pStr = new String(pat,pLoc+1,pEnd-(pLoc+1));
0: 							SanityManager.THROWASSERT("null result on like(value = "+vStr+", pat = "+pStr+")");
0: 						}
0: 					}
0: 					if (restResult.booleanValue())
0: 						return restResult;
0: 
0: 					n++;
0: 				}
0: 				// none of the possibilities worked 
0: 				return Boolean.FALSE;
0: 			}
0: 		}
0: 	}
0: 
0: 	/* national chars */
0: 	private static Boolean like
0: 	(
0: 		int[] 	val, 
0: 		int 	vLoc, 	// start at val[vLoc]
0: 		int 	vEnd, 	// end at val[vEnd]
0: 		int[] 	pat, 
0: 		int 	pLoc, 	// start at pat[pLoc]
0: 		int 	pEnd, 	// end at pat[pEnd]
0: 		int[] 	escape,
0: 		int 	escapeLength,
0: 		RuleBasedCollator	collator
0: 	) throws StandardException 
0: 	{
0: 		int[] escCharInts = null;
0: 		boolean haveEsc = true;
0: 		int[] anyCharInts = new int[1];	// assume only 1 int
0: 		int[] anyStringInts = new int[1];	// assume only 1 int
0: 		
0: 		if (val == null) return null;
0: 		if (pat == null) return null;
0: 
0: 		if (escape == null)
0: 		{
0: 			haveEsc = false;
0: 		}
0: 		else
0: 		{
0: 			escCharInts = escape;
0: 		}
0: 
0: 		Boolean result;
0: 
0: 		// get the collation integer representing "_"
0: 		CollationElementIterator cei =
0: 									collator.getCollationElementIterator("_");
0: 		anyCharInts[0] = cei.next();
0: 		{
0: 			int nextInt;
0: 
0: 			// There may be multiple ints representing this character
0: 			while ((nextInt = cei.next()) != CollationElementIterator.NULLORDER)
0: 			{
0: 				int[] temp = new int[anyCharInts.length + 1];
0: 				for (int index = 0; index < anyCharInts.length; index++)
0: 				{
0: 					temp[index] = anyCharInts[index];
0: 				}
0: 				temp[anyCharInts.length] = nextInt;
0: 				anyCharInts = temp;
0: 			}
0: 		}
0: 		// get the collation integer representing "%"
0: 		cei = collator.getCollationElementIterator("%");
0: 		anyStringInts[0] = cei.next();
0: 		{
0: 			int nextInt;
0: 
0: 			// There may be multiple ints representing this character
0: 			while ((nextInt = cei.next()) != CollationElementIterator.NULLORDER)
0: 			{
0: 				int[] temp = new int[anyStringInts.length + 1];
0: 				for (int index = 0; index < anyStringInts.length; index++)
0: 				{
0: 					temp[index] = anyStringInts[index];
0: 				}
0: 				temp[anyStringInts.length] = nextInt;
0: 				anyStringInts = temp;
0: 			}
0: 		}
0: 
0: 		while (true) 
0: 		{
0: 			// returns null if more work to do, otherwise match Boolean
0: 			result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd, anyStringInts);
0: 			if (result != null) 
0: 				return result;
0: 
0: 			// go until we get a special char in the pattern or hit EOS
0: 			while ( (! matchSpecial(pat, pLoc, pEnd, anyCharInts)) &&
0: 					(! matchSpecial(pat, pLoc, pEnd, anyStringInts)) &&
0: 					((! haveEsc)
0: 						|| (! matchSpecial(pat, pLoc, pEnd, escCharInts))))
0: 			{
0: 				if (val[vLoc] == pat[pLoc]) 
0: 				{
0: 					vLoc++; pLoc++;
0: 	
0: 					result = checkLengths(vLoc, vEnd, pLoc,
0: 								pat, pEnd, anyStringInts);
0: 					if (result != null) 
0: 					{
0: 						return result;
0: 					}
0: 				}
0: 				else 
0: 				{
0: 					return Boolean.FALSE;
0: 				}
0: 			}
0: 
0: 			// deal with escCharInt first, as it can be escaping a special char
0: 			// and can be a special char itself.
0: 			if (haveEsc && matchSpecial(pat, pLoc, pEnd, escCharInts))
0: 			{
0: 				pLoc += escCharInts.length;
0: 				if (pLoc == pEnd) 
0: 				{
0: 					throw StandardException.newException(
0: 						SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				}
0: 
0: 				int[] specialInts = null;
0: 				if (matchSpecial(pat, pLoc, pEnd, escCharInts))
0: 				{
0: 					specialInts = escCharInts;
0: 				}
0: 				if (matchSpecial(pat, pLoc, pEnd, anyCharInts))
0: 				{
0: 					specialInts = anyCharInts;
0: 				}
0: 				if (matchSpecial(pat, pLoc, pEnd, anyStringInts))
0: 				{
0: 					specialInts = anyStringInts;
0: 				}
0: 				if (specialInts == null)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				}
0: 				// regardless of the char in pat, it must match exactly:
0: 				for (int index = 0; index < specialInts.length; index++)
0: 				{
0: 					if (val[vLoc + index] != pat[pLoc + index])
0: 					{
0: 						return Boolean.FALSE;
0: 					}
0: 				}
0: 
0: 				vLoc += specialInts.length; 
0: 				pLoc += specialInts.length; 
0: 	
0: 				// returns null if more work to do, otherwise match Boolean
0: 				result = checkLengths(vLoc, vEnd,
0: 						pLoc, pat, pEnd, anyStringInts);
0: 
0: 				if (result != null) 
0: 					return result;
0: 			}
0: 			else if (matchSpecial(pat, pLoc, pEnd, anyCharInts))
0: 			{
0: 				// regardless of the char, it matches
0: 				vLoc += anyCharInts.length; 
0: 				pLoc += anyCharInts.length; 
0: 	
0: 				result = checkLengths(vLoc, vEnd, pLoc, pat, pEnd, anyStringInts);
0: 				if (result != null) 
0: 					return result;
0: 			}
0: 			else if (matchSpecial(pat, pLoc, pEnd, anyStringInts))
0: 			{
0: 				// catch the simple cases -- end of the pattern or of the string
0: 				if (pLoc+1 == pEnd)
0: 					return Boolean.TRUE;
0: 
0: 				// would return true, but caught in checkLengths above
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(vLoc!=vEnd, 
0: 						"Should have been found already");
0: 
0: 				if (vLoc == vEnd)
0: 					return Boolean.TRUE;
0: 
0: 				// check if remainder of pattern is anyString's
0: 				// if escChar == anyString, we couldn't be here
0: 				// If there is an escape in the pattern we break
0: 				boolean allPercentChars = true;
0: 				for (int i=pLoc+1;i<pEnd;i++)
0: 				{
0: 					if (! matchSpecial(pat, i, pEnd, anyStringInts))
0: 					{
0: 						allPercentChars=false;
0: 						break;
0: 					}
0: 				}
0: 				if (allPercentChars)
0: 					return Boolean.TRUE;
0: 
0: 				// pattern can match 0 or more chars in value.
0: 				// to test that, we take the remainder of pattern and
0: 				// apply it to ever-shorter  remainders of value until
0: 				// we hit a match.
0: 
0: 				// the loop never continues from this point -- we will
0: 				// always generate an answer here.
0: 
0: 				// REMIND: there are smarter ways to pick the remainders
0: 				// and do this matching.
0: 
0: 				// num chars left in value includes current char
0: 				int vRem = vEnd - vLoc;
0: 
0: 				int n=0;
0: 
0: 				// num chars left in pattern excludes the anyString
0: 				int minLen = getMinLen(pat, pLoc+1, pEnd, haveEsc, escCharInts, anyStringInts);
0: 				for (int i=vRem; i>=minLen; i--) 
0: 				{
0: 					Boolean restResult = Like.like(val,vLoc+n,vLoc+n+i,pat,pLoc+1,pEnd,escape,escapeLength, collator);
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (restResult == null)
0: 						{
0: 							SanityManager.THROWASSERT("null result on like(vLoc+n = "+(vLoc+n)+", i = "+i+
0: 													  ", pLoc+1 = " + (pLoc+1) + ", pEnd-(pLoc+1) = " + 
0: 													  (pEnd-(pLoc+1)) + ")");
0: 						}
0: 					}
0: 					if (restResult.booleanValue())
0: 						return restResult;
0: 
0: 					n++;
0: 				}
0: 				// none of the possibilities worked 
0: 				return Boolean.FALSE;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Calculate the shortest length string that could match this pattern for non-national chars
0: 	 */
0: 	static int getMinLen(char[] pattern, int pStart, int pEnd, boolean haveEsc, char escChar) 
0: 	{
0: 		int m=0;
0: 		for (int l = pStart; l<pEnd; ) 
0: 		{
0: 			if (haveEsc && pattern[l] == escChar) { // need one char
0: 				l+=2;
0: 				m++;
0: 			}
0: 			else if (pattern[l] == anyString) {
0: 				l++; // anyString, nothing needed
0: 			}
0: 			else { // anyChar or other chars, need one char
0: 				l++; m++;
0: 			}
0: 		}
0: 		return m;
0: 	}
0: 
0: 	/**
0: 		Calculate the shortest length string that could match this pattern for national chars
0: 	 */
0: 	static int getMinLen(int[] pattern, int pStart, int pEnd, boolean haveEsc, 
0: 						 int[] escCharInts, int[] anyStringInts) 
0: 	{
0: 		int m=0;
0: 		for (int l = pStart; l<pEnd; ) 
0: 		{
0: 			if (haveEsc && matchSpecial(pattern, l, pEnd, escCharInts))
0: 			{ 
0: 				l += escCharInts.length + 1;
0: 				m += escCharInts.length;
0: 			}
0: 			else if (matchSpecial(pattern, l, pEnd, anyStringInts)) 
0: 			{
0: 				l += anyStringInts.length; // anyString, nothing needed
0: 			}
0: 			else 
0: 			{ // anyChar or other chars, need one char
0: 				l++; m++;
0: 			}
0: 		}
0: 		return m;
0: 	}
0: 
0: 	/**
0: 	 * checkLengths -- non-national chars 
0: 	 *
0: 	 * Returns null if we are not done.
0: 	 * Returns true if we are at the end of our value and pattern
0: 	 * Returns false if there is more pattern left but out of input value
0: 	 *
0: 	 * @param vLoc current index into char[] val
0: 	 * @param vEnd end index or our value
0: 	 * @param pLoc current index into our char[] pattern
0: 	 * @param pat  pattern char []
0: 	 * @param pEnd end index of our pattern []
0: 	 */
0: 
0: 	static Boolean checkLengths(int vLoc, int vEnd,
0: 			int pLoc, char[] pat, int pEnd) 
0: 	{
0: 		if (vLoc == vEnd) 
0: 		{
0: 			if (pLoc == pEnd) 
0: 			{
0: 				return Boolean.TRUE;
0: 			}
0: 			else 
0: 			{
0: 				// if remainder of pattern is anyString chars, ok
0: 				for (int i=pLoc; i<pEnd; i++) 
0: 				{
0: 					if (pat[i] != anyString)
0: 					{
0: 						return Boolean.FALSE; // more to match
0: 					}
0: 				}
0: 				return Boolean.TRUE;
0: 			}
0: 		}
0: 		else if (pLoc == pEnd)
0: 		{
0: 			return Boolean.FALSE; // ran out of pattern
0: 		}
0: 		else return null; // still have strings to match, not done
0: 	}
0: 
0: 	/**
0: 	 * checkLengths -- national chars 
0: 	 *
0: 	 * Returns null if we are not done.
0: 	 * Returns true if we are at the end of our value and pattern
0: 	 * Returns false if there is more pattern left but out of input value
0: 	 *
0: 	 * @param vLoc current index into int[] val
0: 	 * @param vEnd end index or our value
0: 	 * @param pLoc current index into our int[] pattern
0: 	 * @param pat  pattern int []
0: 	 * @param pEnd end index of our pattern []
0: 	 */
0: 
0: 	static Boolean checkLengths(int vLoc, int vEnd,
0: 			int pLoc, int[] pat, int pEnd, int[] anyStringInts) 
0: 	{
0: 		if (vLoc == vEnd) 
0: 		{
0: 			if (pLoc == pEnd) 
0: 			{
0: 				return Boolean.TRUE;
0: 			}
0: 			else 
0: 			{
0: 				// if remainder of pattern is anyString chars, ok
0: 				for (int i=pLoc; i<pEnd; i += anyStringInts.length) 
0: 				{
0: 					if (! matchSpecial(pat, i, pEnd, anyStringInts))
0: 					{
0: 						return Boolean.FALSE;
0: 					}
0: 				}
0: 				return Boolean.TRUE;
0: 			}
0: 		}
0: 		else if (pLoc == pEnd)
0: 		{
0: 			return Boolean.FALSE; // ran out of pattern
0: 		}
0: 		else return null; // still have strings to match, not done
0: 	}
0: 
0: 	/**
0: 	 * matchSpecial
0: 	 *
0: 	 *	check the pattern against the various special character arrays.
0: 	 *  The array can be anyStringInts, anyCharInts or anyEscChars (always 1)
0: 	 */
0: 
0: 	private static boolean matchSpecial(int[] pat, int patStart, int patEnd, int[] specialInts)
0: 	{
0: 		//
0: 		// multi-collation units per char can exceed the pattern length
0: 		// and we fall around the 2nd if statement and falsely return true.
0: 		//
0: 		if (specialInts.length > patEnd - patStart)
0: 		    return false;
0: 		if (specialInts.length <= patEnd - patStart)
0: 		{
0: 			for (int index = 0; index < specialInts.length; index++)
0: 			{
0: 				if (pat[patStart + index] != specialInts[index])
0: 				{
0: 					return false; // more to match
0: 				}
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 
0: 	/*
0: 		Most typical interface for non-national chars
0: 	 */
0: 	public static Boolean like(char[] value, int valueLength, char[] pattern, int patternLength) throws StandardException { 
0: 		if (value == null || pattern == null) return null;
0: 		return like(value, valueLength, pattern, patternLength, null, 0);
0: 	}
0: 
0: 	/*
0: 		Most typical interface for national chars
0: 	 */
0: 	public static Boolean like(int[] value, int valueLength, int[] pattern, int patternLength, RuleBasedCollator collator) 
0: 		throws StandardException 
0: 	{ 
0: 		if (value == null || pattern == null) return null;
0: 		return like(value, valueLength, pattern, patternLength, null, 0, collator);
0: 	}
0: 
0: 	// Methods for LIKE transformation at preprocess time:
0: 
0: 	/**
0: 	 * Determine whether or not this LIKE can be transformed into optimizable
0: 	 * clauses.  It can if the pattern is non-null, of length > 0 and
0: 	 * the first character is not a wild card.
0: 	 *
0: 	 * @param pattern	The right side of the LIKE
0: 	 *
0: 	 * @return	Whether or not the LIKE can be transformed
0: 	 */
0: 
0: 	public static boolean isOptimizable(String pattern)
0: 	{
0: 		if (pattern == null || (pattern.length() == 0))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		// if we have pattern matching at start of string, no optimization
0: 		char firstChar = pattern.charAt(0);
0: 
0: 		return (firstChar != anyChar && firstChar != anyString);
0: 	}
0: 
0: 	public static String greaterEqualStringFromParameter(String pattern)
0: 		throws StandardException {
0: 
0: 		if (pattern == null)
0: 			return null;
0: 
0: 		return greaterEqualString(pattern, (String) null);
0: 	}
0: 
0: 	public static String greaterEqualStringFromParameterWithEsc(String pattern, String escape)
0: 		throws StandardException {
0: 
0: 		if (pattern == null)
0: 			return null;
0: 
0: 		return greaterEqualString(pattern, escape);
0: 	}
0: 
0: 	/**
0: 	 * Return the substring from the pattern for the optimization >= clause.
0: 	 *
0: 	 * @param pattern	The right side of the LIKE
0: 	 * @param escape	The escape clause
0: 	 *
0: 	 * @return	The String for the >= clause
0: 	 */
0: 	public static String greaterEqualString(String pattern, String escape)
0: 	    throws StandardException
0: 	{
0: 
0: 		int firstAnyChar = pattern.indexOf(anyChar);
0: 		int firstAnyString = pattern.indexOf(anyString);
0: 
0: 		// 
0: 		// For Escape we don't utilize any of the stylish code
0: 		// below but brute force walk the pattern to find out
0: 		// what is there, while stripping escapes
0: 		//
0: 
0: 		if (escape != null)
0: 		{
0: 			char escChar = escape.charAt(0);
0: 			if (pattern.indexOf(escChar) != -1)
0: 			{
0: 				// we return a string stripping out the escape char
0: 				// leaving the _? in place as normal chars.
0:                 
0: 				return greaterEqualString(pattern, escChar);
0: 			}
0: 			// drop through if no escape found
0: 		}
0: 
0: 		if (firstAnyChar == -1)
0: 		{
0: 			if (firstAnyString == -1)
0: 			{
0: 				return pattern;
0: 			}
0: 			else	// no _, found %
0: 			{
0: 				return pattern.substring(0, firstAnyString);
0: 			}
0: 		}
0: 		else if (firstAnyString == -1)
0: 		{
0: 			return pattern.substring(0, firstAnyChar);
0: 		}
0: 		else
0: 		{
0: 			return pattern.substring(0, (firstAnyChar > firstAnyString) ? 
0: 										firstAnyString :
0: 										firstAnyChar);
0: 		}
0: 	}
0: 
0:     /** 
0:      *  greaterEqualString -- for Escape clause only
0:      *  
0:      *  Walk the pattern character by character
0:      *  @param pattern like pattern to build from
0:      *  @param escChar the escape character in the pattern
0:      */
0: 
0: 	private static String greaterEqualString(String pattern, char escChar)
0: 		throws StandardException
0: 	{
0: 		int patternLen = pattern.length();
0: 		char[] patternChars = new char[patternLen];
0: 		char[] result = new char[patternLen];
0: 		pattern.getChars(0, patternLen, patternChars, 0);
0: 
0: 		int r = 0;
0: 		for (int p = 0; p < patternLen && r < patternLen; p++)
0: 		{
0:             char c = patternChars[p];
0: 		    if (c == escChar)
0: 			{
0: 				p++;		// don't copy the escape char
0: 
0: 				// run out?
0: 				if (p >= patternLen)
0: 					throw StandardException.newException(
0: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				result[r++] = patternChars[p];
0: 				continue;
0: 			}
0: 
0: 			// stop on first pattern matching char
0: 			if (c == anyChar || c == anyString)
0: 			{
0: 				return new String(result, 0, r);
0: 			}
0: 
0: 			result[r++] = patternChars[p];
0: 		}
0: 
0:         // no pattern chars
0: 		return new String(result, 0, r);
0: 	}
0: 
0: 	/**
0: 	 * stripEscapesNoPatternChars
0: 	 *
0: 	 * @param pattern	pattern String to search
0: 	 * @param escChar	the escape character
0: 	 *
0: 	 * @return a stripped of ESC char string if no pattern chars, null otherwise
0: 	 * @exception StandardException thrown if data invalid
0: 	 */
0: 
0: 	public static String
0:         stripEscapesNoPatternChars(String pattern, char escChar)
0: 		throws StandardException
0: 	{
0: 		int patternLen = pattern.length();
0: 		char[] patternChars = new char[patternLen];
0: 		char[] result = new char[patternLen];
0: 		pattern.getChars(0, patternLen, patternChars, 0);
0: 
0: 		int r = 0;
0: 		for (int p = 0; p < patternLen && r < patternLen; p++)
0: 		{
0: 			char c = pattern.charAt(p);
0: 		    if (c == escChar)
0: 			{
0: 				p++;		// don't copy the escape char
0: 
0: 				// run out?
0: 				if (p >= patternLen)
0: 					throw StandardException.newException(
0: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				result[r++] = patternChars[p];
0: 				continue;
0: 			}
0: 
0: 			// die on first pattern matching char
0: 			if (c == anyChar || c == anyString)
0: 			{
0: 				return null;
0: 			}
0: 
0: 			result[r++] = patternChars[p];
0: 		}
0: 		return new String(result, 0, r);
0: 	}
0: 
0: 	/**
0: 	 * Return the substring from the pattern for the < clause.
0: 	 * (NOTE: This may be null in the degenerate case where the
0: 	 * last char before the first wild card can't be incremented.)
0: 	 *
0: 	 *		Optimized for ESCAPE
0: 	 *
0: 	 * This function uses the greaterThanString, and bumps its last
0: 	 * character by one.   This string has no escape characters, they
0: 	 * were stripped out, and ends just before any real pattern chars or
0: 	 * at the end of the pattern literal.    See LikeEscapeOp*Node.preprocess.
0: 	 *
0: 	 * @param pattern	The right side of the LIKE
0: 	 *
0: 	 * @return	The String for the < clause
0: 	 * @exception StandardException thrown if data invalid
0: 	 */
0: 	public static String lessThanString(String pattern)
0: 		throws StandardException
0: 	{
0: 		//int		firstAnyChar = pattern.indexOf(anyChar);
0: 		//int		firstAnyString = pattern.indexOf(anyString);
0: 		int		lastUsableChar;
0: 		int		patternLen;
0: 		char	oldLastChar;
0: 		char	newLastChar;
0: 		char[]	charArray;
0: 
0: 		if ((patternLen = pattern.length()) == 0)
0: 		{
0: 			// pattern is ""
0: 			return null;
0: 		}
0: 		
0: 		lastUsableChar = patternLen -1;
0: 		oldLastChar = pattern.charAt(lastUsableChar);
0: 		newLastChar = oldLastChar;
0: 		newLastChar++;
0: 
0: 		// Check for degenerate roll over
0: 		if (newLastChar < oldLastChar)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		charArray = pattern.substring(0, lastUsableChar + 1).toCharArray();
0: 		charArray[lastUsableChar] = newLastChar;
0: 
0: 		return new String(charArray);
0: 	}
0: 
0: 	public static String lessThanStringFromParameter(String pattern) throws StandardException {
0: 		if (pattern == null)
0: 			return null;
0: 		return lessThanString(pattern, null);
0: 	}
0: 
0: 	public static String lessThanStringFromParameterWithEsc(String pattern, String escape)
0: 		 throws StandardException
0: 	{
0: 		if (pattern == null)
0: 			return null;
0: 		return lessThanString(pattern, escape);
0: 	}
0: 
0: 	/**
0: 	 * Return the substring from the pattern for the < clause.
0: 	 * (NOTE: This may be null in the degenerate case where the
0: 	 * last char before the first wild card can't be incremented.)
0: 	 *
0: 	 * 		This is unoptimized for ESCAPE.
0: 	 *
0: 	 *
0: 	 * @param pattern	The right side of the LIKE
0: 	 * @param escape	The escape clause
0: 	 *
0: 	 * @return	The String for the < clause
0: 	 * @exception StandardException thrown if data invalid
0: 	 */
0: 	public static String lessThanString(String pattern, String escape)
0: 		throws StandardException
0: 	{
0: 		int		lastUsableChar;
0: 		int		patternLen;
0: 		char	oldLastChar;
0: 		char	newLastChar;
0: 		char[]	charArray;
0: 		char escChar = 'a';
0: 
0: 		if ((patternLen = pattern.length()) == 0)
0: 		{
0: 			// pattern is ""
0: 			return null;
0: 		}
0: 
0: 		if (escape != null)
0: 		{
0: 			escChar = escape.charAt(0);
0: 		}
0: 
0: 		/* Find the last non-wildcard character in the pattern
0: 		 * and increment it.  In the most common case,
0: 		 * "asdf%" becomes "asdg".  However, we need to 
0: 		 * handle the following:
0: 		 *
0: 		 *	pattern			return
0: 		 *	-------			------
0: 		 *	""				SUPER_STRING (match against super string)
0: 		 *	"%..."			SUPER_STRING (match against super string)
0: 		 *	"_..."			SUPER_STRING (match against super string)
0: 		 *	"asdf%"			"asdg"
0: 		 */
0: 
0: 		int		firstAnyChar = pattern.indexOf(anyChar);
0: 		int		firstAnyString = pattern.indexOf(anyString);
0: 
0: 
0: 		if (escape != null)
0: 		{
0: 			while (firstAnyChar > 0 && pattern.charAt(firstAnyChar-1) == escChar)
0: 				firstAnyChar = pattern.indexOf(anyChar, firstAnyChar+1);
0: 			while (firstAnyString > 0 && pattern.charAt(firstAnyString-1) == escChar)
0: 				firstAnyString = pattern.indexOf(anyString, firstAnyString+1);
0: 		}
0: 
0: 		if (firstAnyChar == -1)
0: 		{
0: 			if (firstAnyString == -1)
0: 			{
0: 				lastUsableChar = pattern.length() -1;
0: 			}
0: 			else if (firstAnyString == 0)
0: 			{
0: 				// pattern is "%"
0: 				return SUPER_STRING;
0: 			}
0: 			else
0: 			{
0: 				lastUsableChar = firstAnyString - 1;
0: 			}
0: 		}
0: 		else if (firstAnyString == -1)
0: 		{
0: 			if (firstAnyChar == 0)
0: 			{
0: 				// pattern is "_"
0: 				return SUPER_STRING;
0: 			}
0: 			lastUsableChar = firstAnyChar - 1;
0: 		}
0: 		else
0: 		{
0: 			// both _ and % present
0: 			lastUsableChar = ((firstAnyChar > firstAnyString) ? 
0: 										firstAnyString :
0: 										firstAnyChar) - 1;
0: 
0: 			if (lastUsableChar == -1)
0: 			{
0: 				// pattern starts with a wildcard
0: 				return SUPER_STRING;
0: 			}
0: 		}
0: 
0: 		oldLastChar = pattern.charAt(lastUsableChar);
0: 		newLastChar = oldLastChar;
0: 		newLastChar++;
0: 
0: 		// Check for degenerate roll over
0: 		if (newLastChar < oldLastChar)
0: 		{
0: 			return SUPER_STRING;
0: 		}
0: 
0: 		if (escape == null)
0: 		{
0: 			charArray = pattern.substring(0, lastUsableChar + 1).toCharArray();
0: 			charArray[lastUsableChar] = newLastChar;
0: 
0: 			return new String(charArray);
0: 		}
0: 		char[] patternChars = new char[patternLen];
0: 		char[] result = new char[patternLen];
0: 		pattern.getChars(0, patternLen, patternChars, 0) ;
0: 
0: 		int r = 0;
0: 		for (int p = 0; p < lastUsableChar; p++)
0: 		{
0: 		    if (patternChars[p] == escChar)
0: 			{
0: 				p++;		// don't copy the escape char
0: 
0: 				// run out: eg.  Escape char last char?
0: 				if (p >= patternLen-1)
0: 					throw StandardException.newException(
0: 							SQLState.LANG_INVALID_ESCAPE_SEQUENCE);
0: 				result[r++] = patternChars[p];
0: 				continue;
0: 			}
0: 
0: 			result[r++] = patternChars[p];
0: 		}
0: 		result[r++] = newLastChar;
0: 		String gt = new String(result, 0, r);
0: 		return gt;
0: 	}
0: 	
0: 	/**
0:  	 * Return whether or not the like comparison is still needed after
0: 	 * performing the like transformation on a constant string.  The
0: 	 * comparison is not needed if the constant string is of the form:
0: 	 *		CONSTANT%  (constant followed by a trailing %)
0: 	 *
0: 	 * @param pattern	The right side of the LIKE
0: 	 *
0: 	 * @return Whether or not the like comparison is still needed.
0: 	 */
0: 	public static boolean isLikeComparisonNeeded(String pattern)
0: 	{
0: 		int		firstAnyChar = pattern.indexOf(anyChar);
0: 		int		firstAnyString = pattern.indexOf(anyString);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(pattern.length() != 0,
0: 				"pattern expected to be non-zero length");
0: 		}
0: 
0: 		// if no pattern matching characters, no LIKE needed
0: 		if (firstAnyChar == -1 && firstAnyString == -1)
0: 			return false;
0: 
0: 		/* Needed if string containts anyChar */
0: 		if (firstAnyChar != -1)
0: 		{
0: 			return true;
0: 		}
0: 
0: 		/* Needed if string contains and anyString in any place
0: 		 * other than the last character.
0: 		 */
0: 		if (firstAnyString != pattern.length() - 1)
0: 		{
0: 			return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: }
============================================================================