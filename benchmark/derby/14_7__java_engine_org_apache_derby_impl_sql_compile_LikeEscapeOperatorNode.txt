1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.LikeEscapeOperatorNode
1:5d769a1: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:eac0369:  */
29:eac0369: 
1:d61b68f: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.sql.Types;
1:1c6c2e8: import java.util.Arrays;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:8ab61cc: import org.apache.derby.iapi.reference.Limits;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.Like;
1:3bb140c: import org.apache.derby.iapi.types.StringDataValue;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
2:eac0369: /**
1:eb0cea2:     This node represents a like comparison operator (no escape)
1:eac0369: 
1:eac0369:     If the like pattern is a constant or a parameter then if possible
1:dbed020:     the like is modified to include a &gt;= and &lt; operator. In some cases
1:dbed020:     the like can be eliminated.  By adding =, &gt;= or &lt; operators it may
1:eb0cea2:     allow indexes to be used to greatly narrow the search range of the
1:eb0cea2:     query, and allow optimizer to estimate number of rows to affected.
1:eac0369: 
1:eac0369: 
1:eb0cea2:     constant or parameter LIKE pattern with prefix followed by optional wild 
1:eb0cea2:     card e.g. Derby%
1:eac0369: 
1:dbed020:     CHAR(n), VARCHAR(n) where n &lt; 255
1:eac0369: 
1:dbed020:         &gt;=   prefix padded with '\u0000' to length n -- e.g. Derby\u0000\u0000
1:dbed020:         &lt;=   prefix appended with '\uffff' -- e.g. Derby\uffff
1:eac0369: 
1:eac0369:         [ can eliminate LIKE if constant. ]
1:eac0369: 
1:eac0369: 
1:dbed020:     CHAR(n), VARCHAR(n), LONG VARCHAR where n &gt;= 255
1:eac0369: 
1:dbed020:         &gt;= prefix backed up one characer
1:dbed020:         &lt;= prefix appended with '\uffff'
1:eac0369: 
1:eac0369:         no elimination of like
1:eac0369: 
1:eac0369: 
1:eb0cea2:     parameter like pattern starts with wild card e.g. %Derby
1:eac0369: 
1:dbed020:     CHAR(n), VARCHAR(n) where n &lt;= 256
1:eac0369: 
1:dbed020:         &gt;= '\u0000' padded with '\u0000' to length n
1:dbed020:         &lt;= '\uffff'
1:eac0369: 
1:eac0369:         no elimination of like
1:eac0369: 
1:dbed020:     CHAR(n), VARCHAR(n), LONG VARCHAR where n &gt; 256
1:eac0369: 
1:dbed020:         &gt;= NULL
1:eac0369: 
1:dbed020:         &lt;= '\uffff'
1:eac0369: 
1:eac0369: 
1:eb0cea2:     Note that the Unicode value '\uffff' is defined as not a character value
1:eac0369:     and can be used by a program for any purpose. We use it to set an upper
1:eac0369:     bound on a character range with a less than predicate. We only need a single
1:eb0cea2:     '\uffff' appended because the string 'Derby\uffff\uffff' is not a valid
1:eac0369:     String because '\uffff' is not a valid character.
1:eac0369: 
1:eb0cea2: **/
1:eac0369: 
1:eac0369: public final class LikeEscapeOperatorNode extends TernaryOperatorNode
1:eac0369: {
1:eb0cea2:     /**************************************************************************
1:eb0cea2:     * Fields of the class
1:eb0cea2:     **************************************************************************
1:eac0369:     */
1:eac0369:     boolean addedEquals;
1:eb0cea2:     String  escape;
1:eac0369: 
1:eac0369:     /**
1:3bb140c:      * Constructor for a LikeEscapeOperatorNode
1:eac0369:      *
1:eb0cea2:      * receiver like pattern [ escape escapeValue ]
1:eac0369:      *
1:d61b68f:      * @param receiver      The left operand of the like: 
1:eb0cea2:      *                              column, CharConstant or Parameter
1:d61b68f:      * @param leftOperand   The right operand of the like: the pattern
1:d61b68f:      * @param rightOperand  The optional escape clause, null if not present
1:3bb140c:      * @param cm            The context manager
1:eac0369:      */
1:3bb140c:     LikeEscapeOperatorNode(
1:3bb140c:             ValueNode receiver,
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             ContextManager cm)
1:eac0369:     {
1:eac0369:         /* By convention, the method name for the like operator is "like" */
1:3bb140c:         super(receiver,
1:3bb140c:               leftOperand,
1:3bb140c:               rightOperand,
1:2706d1f:               TernaryOperatorNode.K_LIKE,
1:3bb140c:               cm);
2:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eb0cea2:      * implement binding for like expressions.
1:eb0cea2:      * <p>
1:eac0369:      * overrides BindOperatorNode.bindExpression because like has special
1:eac0369:      * requirements for parameter binding.
1:eac0369:      *
1:d61b68f:      * @return  The new top of the expression tree.
1:eac0369:      *
1:eac0369:      * @exception StandardException thrown on failure
1:eac0369:      */
1:2706d1f:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:     FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369:         throws StandardException
1:eac0369:     {
1:09c2697:         super.bindExpression(fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369:         String pattern = null;
1:eac0369: 
1:eac0369:         // pattern must be a string or a parameter
1:eac0369: 
1:eb0cea2:         if (!(leftOperand.requiresTypeFromContext()) && 
1:eb0cea2:              !(leftOperand.getTypeId().isStringTypeId()))
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
1:eac0369:         }
1:eac0369: 
1:eac0369:         // escape must be a string or a parameter
1:eb0cea2:         if ((rightOperand != null) && 
1:eb0cea2:             !(rightOperand.requiresTypeFromContext()) && 
1:eb0cea2:             !(rightOperand.getTypeId().isStringTypeId()))
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
1:eac0369:         }
1:eac0369: 
1:eac0369:         // deal with operand parameters
1:eac0369: 
1:eac0369:         /* 
1:eb0cea2:         *  Is there a ? parameter on the left? ie. "? like 'Derby'"
1:eac0369:         *
1:eac0369:         *  Do left first because its length is always maximum;
1:eac0369:         *  a parameter on the right copies its length from
1:eac0369:         *  the left, since it won't match if it is any longer than it.
1:eac0369:         */
1:eb0cea2:         if (receiver.requiresTypeFromContext())
1:eac0369:         {
1:eb0cea2:             receiver.setType(
1:eb0cea2:                 new DataTypeDescriptor(
1:eb0cea2:                     TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1:f122488:             //check if this parameter can pick up it's collation from pattern
1:f122488:             //or escape clauses in that order. If not, then it will take it's
1:f122488:             //collation from the compilation schema.
1:f122488:             if (!leftOperand.requiresTypeFromContext()) {
1:b25481f:                 receiver.setCollationInfo(leftOperand.getTypeServices());
1:b25481f: 
1:f122488:             } else if (rightOperand != null && !rightOperand.requiresTypeFromContext()) {
1:b25481f:                 receiver.setCollationInfo(rightOperand.getTypeServices());          	
1:f122488:             } else {
1:9ed7c4d:     			receiver.setCollationUsingCompilationSchema();            	
1:f122488:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* 
1:eb0cea2:          *  Is there a ? parameter for the PATTERN of LIKE? ie. "column like ?"
1:2c77aa2:          *  
1:eac0369:          *  Copy from the receiver -- legal if both are parameters,
1:eac0369:          *  both will be max length.
1:eac0369:          *  REMIND: should nullability be copied, or set to true?
1:eac0369:          */
1:eb0cea2:         if (leftOperand.requiresTypeFromContext())
1:eac0369:         {
1:eac0369:             /*
1:eac0369:             * Set the pattern to the type of the left parameter, if
1:eac0369:             * the left is a string, otherwise set it to be VARCHAR. 
1:eac0369:             */
1:eac0369:             if (receiver.getTypeId().isStringTypeId())
1:eac0369:             {
1:eb0cea2:                 leftOperand.setType(receiver.getTypeServices());
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eb0cea2:                 leftOperand.setType(
1:eb0cea2:                     new DataTypeDescriptor(
1:eb0cea2:                         TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1:eac0369:             }
1:f122488: 			//collation of ? operand should be picked up from the context.
1:f122488:             //By the time we come here, receiver will have correct collation
1:f122488:             //set on it and hence we can rely on it to get correct collation
1:f122488:             //for the other ? in LIKE clause
1:b25481f:             leftOperand.setCollationInfo(receiver.getTypeServices());          	
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* 
1:eac0369:          *  Is there a ? parameter for the ESCAPE of LIKE?
1:eac0369:          *  Copy from the receiver -- legal if both are parameters,
1:eac0369:          *  both will be max length.  nullability is set to true.
1:eac0369:          */
1:eac0369: 
1:eb0cea2:         if (rightOperand != null && rightOperand.requiresTypeFromContext())
1:eac0369:         {
1:eac0369:             /*
1:eac0369:              * Set the pattern to the type of the left parameter, if
1:eac0369:              * the left is a string, otherwise set it to be VARCHAR. 
1:eac0369:              */
1:eac0369:             if (receiver.getTypeId().isStringTypeId())
1:eac0369:             {
1:eb0cea2:                 rightOperand.setType(receiver.getTypeServices());
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eb0cea2:                 rightOperand.setType(
1:eb0cea2:                     new DataTypeDescriptor(
1:eb0cea2:                         TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1:eac0369:             }
1:f122488: 			//collation of ? operand should be picked up from the context.
1:f122488:             //By the time we come here, receiver will have correct collation
1:f122488:             //set on it and hence we can rely on it to get correct collation
1:f122488:             //for the other ? in LIKE clause
1:b25481f:             rightOperand.setCollationInfo(receiver.getTypeServices());    	
1:eac0369:         }
1:eac0369: 
1:eac0369:         bindToBuiltIn();
1:eac0369: 
1:eac0369:         /* The receiver must be a string type
1:eac0369:         */
1:eac0369:         if (! receiver.getTypeId().isStringTypeId())
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* If either the left or right operands are non-string types,
1:eac0369:          * then we generate an implicit cast to VARCHAR.
1:eac0369:          */
1:eb0cea2:         if (!leftOperand.getTypeId().isStringTypeId())
1:eac0369:         {
1:eac0369:             leftOperand = castArgToString(leftOperand);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (rightOperand != null)
1:eac0369:         {
1:eac0369:             rightOperand = castArgToString(rightOperand);
1:eac0369:         }
1:eac0369: 
6:eb0cea2:         /* 
1:eb0cea2:          * Remember whether or not the right side (the like pattern) is a string 
1:eb0cea2:          * constant.  We need to remember here so that we can transform LIKE 
1:eb0cea2:          * 'constant' into = 'constant' for non unicode based collation columns.
1:eac0369:          */
1:eac0369:         boolean leftConstant = (leftOperand instanceof CharConstantNode);
1:eac0369:         if (leftConstant)
1:eac0369:         {
2:eac0369:             pattern = ((CharConstantNode) leftOperand).getString();
1:eac0369:         }
1:eac0369: 
1:eac0369:         boolean rightConstant = (rightOperand instanceof CharConstantNode);
1:eac0369: 
1:eac0369:         if (rightConstant)
1:eac0369:         {
1:eac0369:             escape = ((CharConstantNode) rightOperand).getString();
1:eac0369:             if (escape.length() != 1)
1:eac0369:             {
1:eb0cea2:                 throw StandardException.newException(
1:eb0cea2:                     SQLState.LANG_INVALID_ESCAPE_CHARACTER, escape);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else if (rightOperand == null)
1:eac0369:         {
1:eac0369:             // No Escape clause: Let optimization continue for the = case below
1:eac0369:             rightConstant = true;
1:eac0369:         }
1:eac0369: 
1:111785f:         /* If we are comparing a UCS_BASIC char with a terriotry based char 
1:111785f:          * then we generate a cast above the receiver to force preprocess to
1:eac0369:          * not attempt any of the > <= optimizations since there is no
1:eac0369:          * way to determine the 'next' character for the <= operand.
1:ec2b8d1:          *
1:ec2b8d1:          * TODO-COLLATE - probably need to do something about different 
1:ec2b8d1:          *                collation types here.
1:eac0369:          */
1:eac0369: 
1:12f2b05:         // The left and the pattern of the LIKE must be same collation type
1:12f2b05:         // and derivation.
1:5d769a1:         if (!receiver.getTypeServices().compareCollationInfo(
1:5d769a1:         		leftOperand.getTypeServices()))
1:eac0369:         {
1:ec2b8d1:             // throw error.
1:ec2b8d1:             throw StandardException.newException(
1:ec2b8d1:                         SQLState.LANG_LIKE_COLLATION_MISMATCH, 
1:ec2b8d1:                         receiver.getTypeServices().getSQLstring(),
1:ec2b8d1:                         receiver.getTypeServices().getCollationName(),
1:ec2b8d1:                         leftOperand.getTypeServices().getSQLstring(),
1:ec2b8d1:                         leftOperand.getTypeServices().getCollationName());
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         /* If the left side of LIKE is a ColumnReference and right side is a 
1:eb0cea2:          * string constant without a wildcard (eg. column LIKE 'Derby') then we 
1:eb0cea2:          * transform the LIKE into the equivalent LIKE AND =.  
1:eb0cea2:          * If we have an escape clause it also must be a constant 
1:eb0cea2:          * (eg. column LIKE 'Derby' ESCAPE '%').
7:eb0cea2:          *
1:eb0cea2:          * These types of transformations are normally done at preprocess time, 
1:eb0cea2:          * but we make an exception and do this one at bind time because we 
1:eb0cea2:          * transform a NOT LIKE 'a' into (a LIKE 'a') = false prior to 
1:eac0369:          * preprocessing.  
1:eb0cea2:          *
1:eac0369:          * The transformed tree will become:
1:eb0cea2:          *
1:d61b68f:          *        AND
1:d61b68f:          *       /   \
1:d61b68f:          *     LIKE   =
1:eac0369:          */
1:eac0369: 
1:eb0cea2:         if ((receiver instanceof ColumnReference) && 
1:eb0cea2:             leftConstant                          && 
1:eb0cea2:             rightConstant)
1:eac0369:         {
1:eac0369:             if (Like.isOptimizable(pattern))
1:eac0369:             {
1:eac0369:                 String newPattern = null;
1:eac0369: 
1:eac0369:                 /*
1:eac0369:                  * If our pattern has no pattern chars (after stripping them out
1:eac0369:                  * for the ESCAPE case), we are good to apply = to this match
1:eac0369:                  */
1:eac0369: 
1:eac0369:                 if (escape != null)
1:eac0369:                 {
1:eac0369:                     /* we return a new pattern stripped of ESCAPE chars */
1:eac0369:                     newPattern =
1:eb0cea2:                         Like.stripEscapesNoPatternChars(
1:eb0cea2:                             pattern, escape.charAt(0));
1:eac0369:                 }
1:eb0cea2:                 else if (pattern.indexOf('_') == -1 && 
1:eb0cea2:                          pattern.indexOf('%') == -1)
1:eac0369:                 {
1:eb0cea2:                     // no pattern characters.
1:eac0369:                     newPattern = pattern;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 if (newPattern != null)
1:eac0369:                 {
1:eb0cea2:                     // met all conditions, transform LIKE into a "LIKE and ="
1:eac0369: 
1:eac0369:                     ValueNode leftClone = receiver.getClone();
1:eac0369: 
1:eac0369:                     // Remember that we did xform, see preprocess()
1:eac0369:                     addedEquals = true;
1:eac0369: 
1:eb0cea2:                     // create equals node of the form (eg. column like 'Derby' :
1:eb0cea2:                     //       =
1:eb0cea2:                     //     /   \
1:eb0cea2:                     //  column  'Derby'
1:eb0cea2:                     BinaryComparisonOperatorNode equals = 
1:3bb140c:                         new BinaryRelationalOperatorNode(
1:2706d1f:                             BinaryRelationalOperatorNode.K_EQUALS,
1:eac0369:                             leftClone, 
1:3bb140c:                             new CharConstantNode(newPattern,
1:3bb140c:                                                  getContextManager()),
1:3bb140c:                             false,
12:eac0369:                             getContextManager());
1:eac0369: 
1:eac0369:                     // Set forQueryRewrite to bypass comparability checks
1:eac0369:                     equals.setForQueryRewrite(true);
1:eac0369: 
1:eb0cea2:                     equals = (BinaryComparisonOperatorNode) 
1:eb0cea2:                         equals.bindExpression(
1:09c2697:                             fromList, subqueryList, aggregates);
1:eac0369: 
1:eb0cea2:                     // create new and node and hook in "equals" the new "=' node
1:eac0369:                     //
1:d61b68f:                     //        AND
1:d61b68f:                     //       /   \
1:d61b68f:                     //     LIKE   = 
1:d61b68f:                     //           / \
1:d61b68f:                     //       column 'Derby'
1:eac0369: 
1:3bb140c:                     AndNode newAnd =
1:3bb140c:                             new AndNode(this, equals, getContextManager());
1:eac0369: 
1:eac0369:                     finishBindExpr();
1:eac0369:                     newAnd.postBindFixup();
1:eac0369: 
1:eac0369:                     return newAnd;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         finishBindExpr();
1:eac0369: 
1:eac0369:         return this;
1:eac0369:     }
1:eac0369: 
1:eac0369:   
1:eac0369: 
1:eac0369:     private void finishBindExpr()
1:eac0369:     throws StandardException
1:eac0369:     {
1:eac0369:         // deal with compatability of operands and result type
1:eac0369:         bindComparisonOperator();
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** The result type of LIKE is Boolean
1:eac0369:         */
1:eac0369: 
1:eac0369:         boolean nullableResult =
1:eb0cea2:             receiver.getTypeServices().isNullable() || 
1:eb0cea2:             leftOperand.getTypeServices().isNullable();
1:eac0369: 
1:eac0369:         if (rightOperand != null)
1:eac0369:         {
1:eac0369:             nullableResult |= rightOperand.getTypeServices().isNullable();
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, nullableResult));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     * Bind this operator
1:eac0369:     *
1:d61b68f:     * @exception StandardException  Thrown on error
1:eac0369:     */
1:eac0369: 
1:eac0369:     public void bindComparisonOperator()
1:eac0369:         throws StandardException
1:eac0369:     {
1:d61b68f:         TypeId receiverType = receiver.getTypeId();
1:d61b68f:         TypeId leftType     = leftOperand.getTypeId();
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** Check the type of the operands - this function is allowed only on
1:eac0369:         ** string types.
1:eac0369:         */
1:eac0369: 
1:eb0cea2:         if (!receiverType.isStringTypeId())
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_LIKE_BAD_TYPE, receiverType.getSQLTypeName());
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         if (!leftType.isStringTypeId())
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_LIKE_BAD_TYPE, leftType.getSQLTypeName());
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (rightOperand != null && ! rightOperand.getTypeId().isStringTypeId())
1:eac0369:         {
1:eb0cea2:             throw StandardException.newException(
1:eb0cea2:                 SQLState.LANG_LIKE_BAD_TYPE, 
1:eac0369:                 rightOperand.getTypeId().getSQLTypeName());
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     * Preprocess an expression tree.  We do a number of transformations
1:eac0369:     * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369:     * subquery flattening.
1:eac0369:     * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369:     *
1:d61b68f:     * @param numTables          Number of tables in the DML Statement
1:d61b68f:     * @param outerFromList      FromList from outer query block
1:d61b68f:     * @param outerSubqueryList  SubqueryList from outer query block
1:d61b68f:     * @param outerPredicateList PredicateList from outer query block
1:eac0369:     *
1:d61b68f:     * @return The modified expression
1:eac0369:     *
1:d61b68f:     * @exception StandardException  Thrown on error
1:eac0369:     */
1:3bb140c:     @Override
1:2706d1f:     ValueNode preprocess(
1:eb0cea2:     int             numTables,
1:eb0cea2:     FromList        outerFromList,
1:eb0cea2:     SubqueryList    outerSubqueryList,
1:eb0cea2:     PredicateList   outerPredicateList) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean eliminateLikeComparison = false;
1:d61b68f:         String  greaterEqualString      = null;
1:eb0cea2:         String  lessThanString          = null;
1:eac0369: 
1:eac0369:         /* We must 1st preprocess the component parts */
1:eb0cea2:         super.preprocess(
1:eb0cea2:             numTables, outerFromList, outerSubqueryList, outerPredicateList);
1:eac0369: 
1:eb0cea2:         /* Don't try to optimize for (C)LOB type since it doesn't allow 
1:eb0cea2:          * comparison.
1:eb0cea2:          * RESOLVE: should this check be for LONG VARCHAR also?
1:eac0369:          */
1:eb0cea2:         if (receiver.getTypeId().getSQLTypeName().equals("CLOB")) 
1:eac0369:         {
1:eac0369:             return this;
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         /* No need to consider transformation if we already did transformation 
1:eb0cea2:          * that added = * at bind time.
1:eac0369:          */
1:eac0369:         if (addedEquals)
1:eac0369:         {
1:eac0369:             return this;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eb0cea2:         /* if like pattern is not a constant and not a parameter, 
1:eb0cea2:          * then can't optimize, eg. column LIKE column
1:eac0369:          */
1:eac0369:         if (!(leftOperand instanceof CharConstantNode) && 
1:eb0cea2:                 !(leftOperand.requiresTypeFromContext()))
1:eac0369:         {
1:eac0369:             return this;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* This transformation is only worth doing if it is pushable, ie, if
1:eac0369:          * the receiver is a ColumnReference.
1:eac0369:          */
1:eac0369:         if (!(receiver instanceof ColumnReference))
1:eac0369:         {
1:eb0cea2:             // We also do an early return here if in bindExpression we found 
1:111785f:             // we had a territory based Char and put a CAST above the receiver.
1:eac0369:             //
1:eac0369:             return this;
1:eac0369:         }
1:eac0369: 
1:2c77aa2:         /* 
1:2c77aa2:          * In first implementation of non default collation don't attempt
1:2c77aa2:          * any transformations for LIKE.  
1:eac0369:          *
1:2c77aa2:          * Future possibilities:
1:2c77aa2:          * o is it valid to produce a >= clause for a leading constant with
1:2c77aa2:          *   a wildcard that works across all possible collations?  Is 
1:2c77aa2:          *   c1 like a% the same as c1 like a% and c1 >= a'\u0000''\u0000',... ?
1:2c77aa2:          *
1:2c77aa2:          *   This is what was done for national char's.  It seems like a 
1:2c77aa2:          *   given collation could sort: ab, a'\u0000'.  Is there any guarantee
1:2c77aa2:          *   about the sort of the unicode '\u0000'.
1:2c77aa2:          *
1:111785f:          * o National char's didn't try to produce a < than, is there a way
1:2c77aa2:          *   in collation?
1:eac0369:          */
1:ec2b8d1:         if (receiver.getTypeServices().getCollationType() != 
1:2c77aa2:                 StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:eac0369:         {
1:2c77aa2:             // don't do any < or >= transformations for non default collations.
1:2c77aa2:             return this;
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         /* This is where we do the transformation for LIKE to make it 
1:eb0cea2:          * optimizable.
1:eac0369:          * c1 LIKE 'asdf%' -> c1 LIKE 'asdf%' AND c1 >= 'asdf' AND c1 < 'asdg'
1:eb0cea2:          * c1 LIKE ?       -> c1 LIKE ? and c1 >= ?
1:eb0cea2:          *     where ? gets calculated at the beginning of execution.
1:eac0369:          */
1:eac0369: 
1:eb0cea2:         // Build String constants if right side (pattern) is a constant
1:eac0369:         if (leftOperand instanceof CharConstantNode)
1:eac0369:         {
1:eb0cea2:             String pattern = ((CharConstantNode) leftOperand).getString();
1:eac0369: 
1:eb0cea2:             if (!Like.isOptimizable(pattern))
1:eac0369:             {
1:eac0369:                 return this;
1:eac0369:             }
1:eac0369: 
1:baef65a:             int maxWidth = receiver.getTypeServices().getMaximumWidth();
1:eac0369: 
1:8ab61cc:             // DERBY-6477: Skip this optimization if the receiver column has
1:8ab61cc:             // a very high maximum width (typically columns in the system
1:8ab61cc:             // tables, as they don't have the same restrictions as columns
1:8ab61cc:             // in user tables). Since greaterEqualString and lessThanString
1:8ab61cc:             // are padded to the maximum width, this optimization may cause
1:8ab61cc:             // OOME if the maximum width is high.
1:8ab61cc:             if (maxWidth > Limits.DB2_LONGVARCHAR_MAXWIDTH) {
1:8ab61cc:                 return this;
1:8ab61cc:             }
1:8ab61cc: 
1:eb0cea2:             greaterEqualString = 
1:eb0cea2:                 Like.greaterEqualString(pattern, escape, maxWidth);
1:eac0369: 
1:111785f:             lessThanString          = 
1:111785f:                 Like.lessThanString(pattern, escape, maxWidth);
1:111785f:             eliminateLikeComparison = 
1:111785f:                 !Like.isLikeComparisonNeeded(pattern);
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* For some unknown reason we need to clone the receiver if it is
1:eac0369:          * a ColumnReference because reusing them in Qualifiers for a scan
1:eac0369:          * does not work.  
1:eac0369:          */
1:eac0369: 
1:eac0369:         /* The transformed tree has to be normalized.  Either:
1:d61b68f:          *        AND                   AND
1:d61b68f:          *       /   \                 /   \
1:d61b68f:          *     LIKE   AND     OR:   LIKE   AND
1:d61b68f:          *           /   \                /   \
1:d61b68f:          *          >=    AND           >=    TRUE
1:d61b68f:          *               /   \
1:d61b68f:          *              <     TRUE
1:eac0369:          * unless the like string is of the form CONSTANT%, in which
1:eac0369:          * case we can do away with the LIKE altogether:
1:d61b68f:          *        AND                   AND
1:d61b68f:          *       /   \                 /   \
1:d61b68f:          *      >=   AND      OR:     >=  TRUE
1:d61b68f:          *          /   \
1:d61b68f:          *         <    TRUE
1:eac0369:          */
1:eac0369: 
1:d61b68f:         AndNode   newAnd   = null;
1:3bb140c:         ValueNode trueNode = new BooleanConstantNode(true, getContextManager());
1:eac0369: 
1:eb0cea2:         /* Create the AND <, if lessThanString is non-null or 
1:111785f:          * leftOperand is a parameter.
1:eac0369:          */
1:eb0cea2:         if (lessThanString != null || 
1:111785f:             leftOperand.requiresTypeFromContext())
1:eac0369:         {
1:3bb140c:             ValueNode likeLTopt;
1:eb0cea2:             if (leftOperand.requiresTypeFromContext())
1:eac0369:             {
1:eb0cea2:                 // pattern string is a parameter 
1:eac0369: 
1:eb0cea2:                 likeLTopt = 
1:eb0cea2:                     setupOptimizeStringFromParameter(
1:eb0cea2:                         leftOperand, 
1:eb0cea2:                         rightOperand, 
1:eb0cea2:                         "lessThanStringFromParameter", 
1:eb0cea2:                         receiver.getTypeServices().getMaximumWidth());
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eb0cea2:                 // pattern string is a constant
1:eb0cea2:                 likeLTopt = 
1:3bb140c:                     new CharConstantNode(lessThanString, getContextManager());
1:eac0369:             }
1:eac0369: 
1:eac0369:             BinaryComparisonOperatorNode lessThan = 
1:3bb140c:                 new BinaryRelationalOperatorNode(
1:2706d1f:                     BinaryRelationalOperatorNode.K_LESS_THAN,
1:eac0369:                     receiver.getClone(), 
1:eac0369:                     likeLTopt,
1:3bb140c:                     false,
1:3bb140c:                     getContextManager());
1:eac0369: 
1:eac0369:             // Disable comparability checks
1:eac0369:             lessThan.setForQueryRewrite(true);
1:eac0369:             /* Set type info for the operator node */
1:eac0369:             lessThan.bindComparisonOperator();
1:eac0369: 
1:eac0369:             // Use between selectivity for the <
1:eac0369:             lessThan.setBetweenSelectivity();
1:eac0369: 
1:eac0369:             /* Create the AND */
1:3bb140c:             newAnd = new AndNode(lessThan, trueNode, getContextManager());
1:eac0369: 
1:eac0369:             newAnd.postBindFixup();
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         /* Create the AND >=.  Right side could be a CharConstantNode or a 
1:eb0cea2:          * ParameterNode.
1:eac0369:          */
1:eac0369: 
1:eac0369:         ValueNode likeGEopt;
1:eb0cea2:         if (leftOperand.requiresTypeFromContext()) 
1:eac0369:         {
1:eb0cea2:             // the pattern is a ?, eg. c1 LIKE ?
1:eac0369: 
1:eac0369:             // Create an expression off the parameter
1:eac0369:             // new SQLChar(Like.greaterEqualString(?));
1:eac0369: 
1:eb0cea2:             likeGEopt    = 
1:eb0cea2:                 setupOptimizeStringFromParameter(
1:eb0cea2:                     leftOperand, 
1:eb0cea2:                     rightOperand, 
1:eb0cea2:                     "greaterEqualStringFromParameter", 
1:eb0cea2:                     receiver.getTypeServices().getMaximumWidth());
1:eac0369:         } 
2:eb0cea2:         else 
1:ec2b8d1:         {
1:eb0cea2:             // the pattern is a constant, eg. c1 LIKE 'Derby'
1:eac0369: 
1:eb0cea2:             likeGEopt = 
1:3bb140c:                 new CharConstantNode(greaterEqualString, getContextManager());
1:eac0369:         }
1:eac0369: 
1:eb0cea2:         // greaterEqual from (reciever LIKE pattern):
1:eb0cea2:         //       >=
1:eb0cea2:         //      /   \
1:eb0cea2:         //  reciever pattern
1:eac0369:         BinaryComparisonOperatorNode greaterEqual = 
1:3bb140c:             new BinaryRelationalOperatorNode(
1:2706d1f:                 BinaryRelationalOperatorNode.K_GREATER_EQUALS,
1:eac0369:                 receiver.getClone(), 
1:eac0369:                 likeGEopt,
1:3bb140c:                 false,
1:8c15184:                 getContextManager());
1:eac0369: 
1:eac0369: 
1:eac0369:         // Disable comparability checks
1:eac0369:         greaterEqual.setForQueryRewrite(true);
1:eac0369:         /* Set type info for the operator node */
1:eac0369:         greaterEqual.bindComparisonOperator();
1:eac0369: 
1:eac0369:         // Use between selectivity for the >=
1:eac0369:         greaterEqual.setBetweenSelectivity();
1:eac0369: 
1:eac0369:         /* Create the AND */
1:eac0369:         if (newAnd == null)
1:eac0369:         {
1:3bb140c:             newAnd = new AndNode(greaterEqual, trueNode, getContextManager());
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:3bb140c:             newAnd = new AndNode(greaterEqual, newAnd, getContextManager());
1:eac0369:         }
1:eac0369:         newAnd.postBindFixup();
1:eac0369: 
1:eb0cea2:         /* Finally, we put an AND LIKE on top of the left deep tree, but
1:eac0369:          * only if it is still necessary.
1:eac0369:          */
1:eb0cea2:         if (!eliminateLikeComparison)
1:eac0369:         {
1:3bb140c:             newAnd = new AndNode(this, newAnd, getContextManager());
1:eac0369:             newAnd.postBindFixup();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* Mark this node as transformed so that we don't get
1:eb0cea2:         * calculated into the selectivity multiple times.
1:eac0369:         */
1:eac0369:         setTransformed();
1:eac0369: 
1:eac0369:         return newAnd;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Do code generation for this binary operator.
1:eac0369:      *
1:d61b68f:      * This code was copied from BinaryOperatorNode and stripped down
1:eac0369:      *
1:d61b68f:      * @param acb   The ExpressionClassBuilder for the class we're generating
1:d61b68f:      * @param mb    The method the code to place the code
1:eac0369:      *
1:eac0369:      *
1:d61b68f:      * @exception StandardException Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(
1:8fe3166:     ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** if i have a operator.getOrderableType() == constant, then just cache 
1:eac0369:         ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
1:eac0369:         ** cache it in something that is initialized each execution,
1:eac0369:         ** but how?
1:eac0369:         */
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** let the receiver type be determined by an
1:eac0369:         ** overridable method so that if methods are
1:eac0369:         ** not implemented on the lowest interface of
1:eac0369:         ** a class, they can note that in the implementation
1:eac0369:         ** of the node that uses the method.
1:eac0369:         */
1:eac0369:         // receiverType = getReceiverInterfaceName();
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** Generate LHS (field = <receiver operand>). This assignment is
1:eac0369:         ** used as the receiver of the method call for this operator.
1:eac0369:         **
1:d61b68f:         ** (<receiver operand>).method(
1:d61b68f:         **     <left operand>, 
1:d61b68f:         **     <right operand>, 
1:d61b68f:         **     [<escaperightOp>,] 
1:d61b68f:         **     result field>)
1:eac0369:         */
1:eac0369: 
1:d61b68f:         receiver.generateExpression(acb, mb);   // first arg
1:eac0369: 
1:eac0369:         receiverInterfaceType = receiver.getTypeCompiler().interfaceName();
1:eac0369: 
1:d61b68f:         mb.upCast(receiverInterfaceType);       // cast the method instance
1:eac0369: 
1:eac0369:         leftOperand.generateExpression(acb, mb);
1:d61b68f:         mb.upCast(leftInterfaceType);           // first arg with cast
1:eac0369: 
1:eac0369:         if (rightOperand != null)
1:eac0369:         {
1:eac0369:             rightOperand.generateExpression(acb, mb);
1:d61b68f:             mb.upCast(rightInterfaceType);      // second arg with cast
1:eac0369:         }
1:eac0369: 
1:eac0369:         /* Figure out the result type name */
1:eac0369:         // resultTypeName = getTypeCompiler().interfaceName();
1:eac0369: 
1:eb0cea2:         mb.callMethod(
1:eb0cea2:             VMOpcode.INVOKEINTERFACE, 
1:eb0cea2:             null, 
2:eb0cea2:             methodName, 
1:eb0cea2:             resultInterfaceType, 
1:eac0369:             rightOperand == null ? 1 : 2);
1:eac0369:     }
1:eac0369: 
1:eb0cea2:     private ValueNode setupOptimizeStringFromParameter(
1:eb0cea2:     ValueNode   parameterNode, 
1:eb0cea2:     ValueNode   escapeNode,
1:eb0cea2:     String      methodName, 
1:eb0cea2:     int         maxWidth)
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 
2:eac0369:         if (escapeNode != null)
1:2c77aa2:         {
1:eac0369:             methodName += "WithEsc";
1:eac0369:         }
1:baef65a: 
1:3bb140c:         StaticMethodCallNode methodCall = new StaticMethodCallNode(
1:eac0369:                 methodName,
1:eac0369:                 "org.apache.derby.iapi.types.Like",
1:baef65a:                 getContextManager());
1:eac0369: 
1:eac0369:         // using a method call directly, thus need internal sql capability
1:eac0369:         methodCall.internalCall = true;
1:eac0369: 
1:3bb140c:         NumericConstantNode maxWidthNode = new NumericConstantNode(
1:3bb140c:             TypeId.getBuiltInTypeId(Types.INTEGER),
1:3bb140c:             Integer.valueOf(maxWidth),
1:eac0369:             getContextManager());
1:eac0369: 
1:3bb140c:         ValueNode[] param = (escapeNode == null) ?
1:3bb140c:             new ValueNode[] { parameterNode, maxWidthNode } :
1:3bb140c:             new ValueNode[] { parameterNode, escapeNode, maxWidthNode };
1:eac0369: 
1:1c6c2e8:         methodCall.addParms(Arrays.asList(param));
1:eac0369: 
1:eb0cea2:         ValueNode java2SQL = 
1:3bb140c:                 new JavaToSQLValueNode(methodCall, getContextManager());
1:eac0369: 
1:3bb140c:         java2SQL = java2SQL.bindExpression(null, null, null);
1:eac0369: 
1:3bb140c:         CastNode likeOpt = new CastNode(
1:eac0369:             java2SQL,
1:eac0369:             parameterNode.getTypeServices(),
1:eac0369:             getContextManager());
1:eac0369: 
1:eac0369:         likeOpt.bindCastNodeOnly();
1:eac0369: 
1:eac0369:         return likeOpt;
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:     the like is modified to include a &gt;= and &lt; operator. In some cases
1:     the like can be eliminated.  By adding =, &gt;= or &lt; operators it may
/////////////////////////////////////////////////////////////////////////
1:     CHAR(n), VARCHAR(n) where n &lt; 255
1:         &gt;=   prefix padded with '\u0000' to length n -- e.g. Derby\u0000\u0000
1:         &lt;=   prefix appended with '\uffff' -- e.g. Derby\uffff
1:     CHAR(n), VARCHAR(n), LONG VARCHAR where n &gt;= 255
1:         &gt;= prefix backed up one characer
1:         &lt;= prefix appended with '\uffff'
1:     CHAR(n), VARCHAR(n) where n &lt;= 256
1:         &gt;= '\u0000' padded with '\u0000' to length n
1:         &lt;= '\uffff'
1:     CHAR(n), VARCHAR(n), LONG VARCHAR where n &gt; 256
1:         &gt;= NULL
1:         &lt;= '\uffff'
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8ab61cc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-6477: Skip this optimization if the receiver column has
1:             // a very high maximum width (typically columns in the system
1:             // tables, as they don't have the same restrictions as columns
1:             // in user tables). Since greaterEqualString and lessThanString
1:             // are padded to the maximum width, this optimization may cause
1:             // OOME if the maximum width is high.
1:             if (maxWidth > Limits.DB2_LONGVARCHAR_MAXWIDTH) {
1:                 return this;
1:             }
1: 
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(
1:     ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(
0:     FromList fromList, SubqueryList subqueryList, List aggregates)
1:         super.bindExpression(fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
1:                             fromList, subqueryList, aggregates);
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         QueryTreeNode[] param = (escapeNode == null) ?
0:             new QueryTreeNode[] { parameterNode, maxWidthNode } :
0:             new QueryTreeNode[] { parameterNode, escapeNode, maxWidthNode };
1:         methodCall.addParms(Arrays.asList(param));
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     List            aggregateVector)
commit:e6a9998
/////////////////////////////////////////////////////////////////////////
0:                     (QueryTreeNode) getNodeFactory().getNode(
/////////////////////////////////////////////////////////////////////////
0:         QueryTreeNode maxWidthNode = (QueryTreeNode) getNodeFactory().getNode(
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0:         param.add(parameterNode);
0:             param.add(escapeNode);
0:         param.add(maxWidthNode);
commit:baef65a
/////////////////////////////////////////////////////////////////////////
1: 			int maxWidth = receiver.getTypeServices().getMaximumWidth();
0: 			greaterEqualString = Like.greaterEqualString(pattern, escape, 
0: 														 maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 				lessThanString = Like.lessThanString(pattern, escape, maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 				int maxWidth = receiver.getTypeServices().getMaximumWidth();
0: 								"lessThanStringFromParameter", maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 			int maxWidth = receiver.getTypeServices().getMaximumWidth();
0: 								"greaterEqualStringFromParameter", maxWidth);
/////////////////////////////////////////////////////////////////////////
0: 						ValueNode escapeNode,String methodName, int maxWidth)
/////////////////////////////////////////////////////////////////////////
0: 		QueryTreeNode maxWidthNode = getNodeFactory().getNode(
0: 										C_NodeTypes.INT_CONSTANT_NODE,
0: 										new Integer(maxWidth),
1: 										getContextManager());
0: 		param.addElement(maxWidthNode);
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:               TernaryOperatorNode.K_LIKE,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                             BinaryRelationalOperatorNode.K_EQUALS,
/////////////////////////////////////////////////////////////////////////
1:     ValueNode preprocess(
/////////////////////////////////////////////////////////////////////////
1:                     BinaryRelationalOperatorNode.K_LESS_THAN,
/////////////////////////////////////////////////////////////////////////
1:                 BinaryRelationalOperatorNode.K_GREATER_EQUALS,
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.Like;
1: import org.apache.derby.iapi.types.StringDataValue;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a LikeEscapeOperatorNode
/////////////////////////////////////////////////////////////////////////
1:      * @param cm            The context manager
1:     LikeEscapeOperatorNode(
1:             ValueNode receiver,
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             ContextManager cm)
1:         super(receiver,
1:               leftOperand,
1:               rightOperand,
0:               TernaryOperatorNode.LIKE,
0:               -1, // default trimType
1:               cm);
0:         setNodeType(C_NodeTypes.LIKE_ESCAPE_OPERATOR_NODE);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         new BinaryRelationalOperatorNode(
1:                             new CharConstantNode(newPattern,
1:                                                  getContextManager()),
1:                             false,
/////////////////////////////////////////////////////////////////////////
1:                     AndNode newAnd =
1:                             new AndNode(this, equals, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         ValueNode trueNode = new BooleanConstantNode(true, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             ValueNode likeLTopt;
/////////////////////////////////////////////////////////////////////////
1:                     new CharConstantNode(lessThanString, getContextManager());
1:                 new BinaryRelationalOperatorNode(
1:                     false,
1:                     getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             newAnd = new AndNode(lessThan, trueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 new CharConstantNode(greaterEqualString, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             new BinaryRelationalOperatorNode(
1:                 false,
/////////////////////////////////////////////////////////////////////////
1:             newAnd = new AndNode(greaterEqual, trueNode, getContextManager());
1:             newAnd = new AndNode(greaterEqual, newAnd, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             newAnd = new AndNode(this, newAnd, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         StaticMethodCallNode methodCall = new StaticMethodCallNode(
/////////////////////////////////////////////////////////////////////////
1:         NumericConstantNode maxWidthNode = new NumericConstantNode(
1:             TypeId.getBuiltInTypeId(Types.INTEGER),
1:             Integer.valueOf(maxWidth),
1:         ValueNode[] param = (escapeNode == null) ?
1:             new ValueNode[] { parameterNode, maxWidthNode } :
1:             new ValueNode[] { parameterNode, escapeNode, maxWidthNode };
1:                 new JavaToSQLValueNode(methodCall, getContextManager());
1:         java2SQL = java2SQL.bindExpression(null, null, null);
1:         CastNode likeOpt = new CastNode(
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0:                                 Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0:                     Boolean.FALSE,
1:                    getContextManager());
/////////////////////////////////////////////////////////////////////////
0:                 Boolean.FALSE,
commit:111785f
/////////////////////////////////////////////////////////////////////////
1:         /* If we are comparing a UCS_BASIC char with a terriotry based char 
1:          * then we generate a cast above the receiver to force preprocess to
/////////////////////////////////////////////////////////////////////////
1:             // we had a territory based Char and put a CAST above the receiver.
/////////////////////////////////////////////////////////////////////////
1:          * o National char's didn't try to produce a < than, is there a way
/////////////////////////////////////////////////////////////////////////
1:             lessThanString          = 
1:                 Like.lessThanString(pattern, escape, maxWidth);
1:             eliminateLikeComparison = 
1:                 !Like.isLikeComparisonNeeded(pattern);
/////////////////////////////////////////////////////////////////////////
1:          * leftOperand is a parameter.
1:             leftOperand.requiresTypeFromContext())
commit:5d769a1
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:         if (!receiver.getTypeServices().compareCollationInfo(
1:         		leftOperand.getTypeServices()))
commit:f122488
/////////////////////////////////////////////////////////////////////////
1:             //check if this parameter can pick up it's collation from pattern
1:             //or escape clauses in that order. If not, then it will take it's
1:             //collation from the compilation schema.
1:             if (!leftOperand.requiresTypeFromContext()) {
0:             	receiver.getTypeServices().setCollationDerivation(
0:             			leftOperand.getTypeServices().getCollationDerivation());
0:             	receiver.getTypeServices().setCollationType(
0:             			leftOperand.getTypeServices().getCollationType());
1:             } else if (rightOperand != null && !rightOperand.requiresTypeFromContext()) {
0:             	receiver.getTypeServices().setCollationDerivation(
0:             			rightOperand.getTypeServices().getCollationDerivation());
0:             	receiver.getTypeServices().setCollationType(
0:             			rightOperand.getTypeServices().getCollationType());            	
1:             } else {
0:     			receiver.setCollationUsingCompilationSchema(
0:     					StringDataValue.COLLATION_DERIVATION_IMPLICIT);            	
1:             }
/////////////////////////////////////////////////////////////////////////
1: 			//collation of ? operand should be picked up from the context.
1:             //By the time we come here, receiver will have correct collation
1:             //set on it and hence we can rely on it to get correct collation
1:             //for the other ? in LIKE clause
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					receiver.getTypeServices().getCollationDerivation());
0: 			leftOperand.getTypeServices().setCollationType(
0:         			receiver.getTypeServices().getCollationType());            	
/////////////////////////////////////////////////////////////////////////
1: 			//collation of ? operand should be picked up from the context.
1:             //By the time we come here, receiver will have correct collation
1:             //set on it and hence we can rely on it to get correct collation
1:             //for the other ? in LIKE clause
0: 			rightOperand.getTypeServices().setCollationDerivation(
0: 					receiver.getTypeServices().getCollationDerivation());
0: 			rightOperand.getTypeServices().setCollationType(
0:         			receiver.getTypeServices().getCollationType());            	
commit:12f2b05
/////////////////////////////////////////////////////////////////////////
1:         // The left and the pattern of the LIKE must be same collation type
1:         // and derivation.
0:                 leftOperand.getTypeServices().getCollationType() ||
0:                 receiver.getTypeServices().getCollationDerivation() !=
0:                 	leftOperand.getTypeServices().getCollationDerivation()
0:                 )
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			receiver.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			leftOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			rightOperand.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			receiver.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			receiver.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			leftOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			rightOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			rightOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1:     			receiver.setCollationUsingCompilationSchema();            	
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:                 receiver.setCollationInfo(leftOperand.getTypeServices());
1: 
1:                 receiver.setCollationInfo(rightOperand.getTypeServices());          	
/////////////////////////////////////////////////////////////////////////
1:             leftOperand.setCollationInfo(receiver.getTypeServices());          	
/////////////////////////////////////////////////////////////////////////
1:             rightOperand.setCollationInfo(receiver.getTypeServices());    	
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.LikeEscapeOperatorNode
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
0: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.types.Like;
1: 
1: import java.sql.Types;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import java.util.Vector;
1: 
1: 
1: /**
0:  * This node represents a like comparison operator (no escape)
1: 
1: 
1: 	If the like pattern is a constant or a parameter then if possible
0: 	the like is modified to include a >= and < operator. In some cases
0: 	the like can be eliminated.
1: 
1: 
0: 	constant or parameter LIKE pattern with prefix followed by optional wild card
0: 	e.g. Cloudscape%
1: 
0: 	CHAR(n), VARCHAR(n) where n < 255
1: 
0: 		>=   prefix padded with '\u0000' to length n -- e.g. Cloudscape\u0000\u0000
0: 		<=   prefix appended with '\uffff' -- e.g. Cloudscape\uffff
1: 		
1: 		[ can eliminate LIKE if constant. ]
1: 
1: 	
0: 	CHAR(n), VARCHAR(n), LONG VARCHAR where n >= 255
1: 
0: 	    >= prefix backed up one characer
0: 		<= prefix appended with '\uffff'
1: 
1: 		no elimination of like
1: 
1: 
0: 	parameter like pattern starts with wild card
1: 
0: 		CHAR(n), VARCHAR(n) where n <= 256
1: 
0: 		>= '\u0000' padded with '\u0000' to length n
0: 		<= '\uffff'
1: 
1: 		no elimination of like
1: 
0: 	CHAR(n), VARCHAR(n), LONG VARCHAR where n > 256
1: 
1: 
0: 		>= NULL
1: 
0: 		<= '\uffff'
1: 	
1: 	    
0: 	Note that the Unicode value is '\uffff' is defined as not a character value
1: 	and can be used by a program for any purpose. We use it to set an upper
1: 	bound on a character range with a less than predicate. We only need a single
0: 	'\uffff' appended because the string 'Cloudscape\uffff\uffff' is not a valid
1: 	String because '\uffff' is not a valid character.
1: 		
1: 
1: 
1: 
1: 	
1: 
1: 		
1: 
1: 
1:  *
0:  * @author ames
0:  * 		converted to TernaryOperatorNode by been
1:  */
1: 
1: public final class LikeEscapeOperatorNode extends TernaryOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 	boolean addedEquals;
0: 	String escape;
1: 
1: 	/**
0: 	 * Initializer for a LikeEscapeOperatorNode
1: 	 *
0: 	 *	receiver like pattern [ escape escapeValue ]
1: 	 *
0: 	 * @param receiver   		The left operand of the like, column, CharConstant or Parameter
0: 	 * @param leftOperand		The right operand of the like, the pattern
0: 	 * @param rightOperand		The optional escape clause, null if not present
1: 	 */
1: 
0: 	public void init(
0: 			Object receiver,
0: 			Object leftOperand,
0: 			Object rightOperand)
1: 	{
1: 		/* By convention, the method name for the like operator is "like" */
0: 		// super.init(leftOperand, rightOperand, new Integer(LIKE), null, null);
0: 		super.init(receiver, leftOperand, rightOperand, ReuseFactory.getInteger(TernaryOperatorNode.LIKE), null); 
1: 	}
1: 
1: 	/**
1: 	 * overrides BindOperatorNode.bindExpression because like has special
1: 	 * requirements for parameter binding.
1: 	 *
0: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
0: 		super.bindExpression(fromList, subqueryList, aggregateVector);
1: 
1: 		String pattern = null;
1: 
0: 		// pattern cannot be a column
0: 		if (leftOperand instanceof ColumnReference)
0: 			throw StandardException.newException(SQLState.LANG_DB2_LIKE_SYNTAX_ERROR);
1: 
1: 		// pattern must be a string or a parameter
0: 		if (!(leftOperand instanceof CharConstantNode) && !(leftOperand.isParameterNode()))
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
0: 													 "LIKE", "FUNCTION");
1: 
0: 		// escape cannot be a column
0: 		if (rightOperand != null && rightOperand instanceof ColumnReference)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_CHARACTER,
0: 										 ((ColumnReference) rightOperand).getColumnName());
1: 		}
1: 
1: 		// escape must be a string or a parameter
0: 		if (rightOperand != null && !(rightOperand instanceof CharConstantNode) && !(rightOperand.isParameterNode()))
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
0: 										 "LIKE", "FUNCTION");
1: 		}
1: 
1: 		// deal with operand parameters
1: 
1: 		/* 
0: 		 *  Is there a ? parameter on the left?
1: 		 *  Do left first because its length is always maximum;
1: 		 *  a parameter on the right copies its length from
1: 		 *  the left, since it won't match if it is any longer than it.
1: 		 */
1: 
0: 		if (receiver.isParameterNode())
1: 		{
0: 			((ParameterNode) receiver).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1: 		}
1: 
1: 		/* 
0: 		 *  Is there a ? parameter for the PATTERN of LIKE?
1: 		 *  Copy from the receiver -- legal if both are parameters,
1: 		 *  both will be max length.
1: 		 *  REMIND: should nullability be copied, or set to true?
1: 		 */
1: 
0: 		if (leftOperand.isParameterNode())
1: 		{
1: 			/*
1: 			 * Set the pattern to the type of the left parameter, if
1: 			 * the left is a string, otherwise set it to be VARCHAR. 
1: 			 */
1: 			if (receiver.getTypeId().isStringTypeId())
1: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(receiver.getTypeServices());
1: 			}
1: 			else
1: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1: 			}
1: 		}
1: 
1: 		/* 
1: 		 *  Is there a ? parameter for the ESCAPE of LIKE?
1: 		 *  Copy from the receiver -- legal if both are parameters,
1: 		 *  both will be max length.  nullability is set to true.
1: 		 */
1: 
0: 		if (rightOperand != null && rightOperand.isParameterNode())
1: 		{
1: 			/*
1: 			 * Set the pattern to the type of the left parameter, if
1: 			 * the left is a string, otherwise set it to be VARCHAR. 
1: 			 */
1: 			if (receiver.getTypeId().isStringTypeId())
1: 			{
0: 				((ParameterNode) rightOperand).setDescriptor(receiver.getTypeServices());
1: 			}
1: 			else
1: 			{
0: 				((ParameterNode) rightOperand).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
1: 			}
1: 		}
1: 
1: 		bindToBuiltIn();
1: 
0: 		TypeCompiler receiverTC = receiver.getTypeCompiler();
0: 		TypeCompiler leftTC = leftOperand.getTypeCompiler();
1: 
1: 		/* The receiver must be a string type
1: 		 */
1: 		if (! receiver.getTypeId().isStringTypeId())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
1: 
1: 		}
1: 
1: 		/* If either the left or right operands are non-string types,
1: 		 * then we generate an implicit cast to VARCHAR.
1: 		 */
0: 		if (! leftOperand.getTypeId().isStringTypeId())
1: 		{
1: 			leftOperand = castArgToString(leftOperand);
0: 			leftTC = leftOperand.getTypeCompiler();
1: 		}
1: 
1: 		if (rightOperand != null)
1: 		{
1: 			rightOperand = castArgToString(rightOperand);
1: 		}
1: 
0: 		/* Remember whether or not right side is a string constant.
0: 		 * We need to remember here so that we can transform 
0: 		 * LIKE 'constant' into = 'constant' for national char
0: 		 * columns.
1: 		 */
1: 		boolean leftConstant = (leftOperand instanceof CharConstantNode);
1: 		if (leftConstant)
1: 		{
1: 			pattern = ((CharConstantNode) leftOperand).getString();
1: 		}
1: 
1: 		boolean rightConstant = (rightOperand instanceof CharConstantNode);
1: 
1: 		if (rightConstant)
1: 		{
1: 			escape = ((CharConstantNode) rightOperand).getString();
1: 			if (escape.length() != 1)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_CHARACTER,
0: 						escape);
1: 			}
1: 		}
1: 		else if (rightOperand == null)
1: 		{
1: 			// No Escape clause: Let optimization continue for the = case below
1: 			rightConstant = true;
1: 		}
1: 
0: 		/* If the left side of LIKE is a ColumnReference and
0: 		 * the right side is a string constant without 
0: 		 * a wildcard then we transform the LIKE into the 
0: 		 * equivalent LIKE AND =.  
0: 		 * If we have an escape clause it also must be a constant.
0: 		 * These types of transformations are normally done 
0: 		 * at preprocess time, but we make an exception 
0: 		 * and do this one at bind time because we transform
0: 		 * a NOT LIKE 'a' into (a LIKE 'a') = false prior to 
1: 		 * preprocessing.
1: 		 * The transformed tree will become:
0: 		 *			AND
0: 		 *		   /   \
0: 		 *	     LIKE   =
1: 		 */
1: 
0: 		if (receiver instanceof ColumnReference &&
0: 			leftConstant && rightConstant)
1: 		{
1: 			if (Like.isOptimizable(pattern))
1: 			{
1: 				String newPattern = null;
1: 
1:                 /*
1:                  * If our pattern has no pattern chars (after stripping them out
1:                  * for the ESCAPE case), we are good to apply = to this match
1:                  */
1: 
1:                 if (escape != null)
1:                 {
1:                     /* we return a new pattern stripped of ESCAPE chars */
1:                     newPattern =
0:                             Like.stripEscapesNoPatternChars(pattern, escape.charAt(0));
1:                 }
0:                 else if (pattern.indexOf('_') == -1 && pattern.indexOf('%') == -1)
1:                 {
1:                     newPattern = pattern;
1:                 }
1: 
1:                 if (newPattern != null)
1: 				{
0: 					AndNode	  newAnd = null;
0: 					BinaryComparisonOperatorNode equals = null;
1: 					ValueNode leftClone = receiver.getClone();
1: 
1: 					// Remember that we did xform, see preprocess()
1: 					addedEquals = true;
1: 
0: 					equals = 
0: 						(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
1: 							leftClone, 
0: 							(ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												newPattern,
0: 												getContextManager()),
1: 							getContextManager());
1: 
1: 					// Set forQueryRewrite to bypass comparability checks
1: 					equals.setForQueryRewrite(true);
0: 					equals = (BinaryComparisonOperatorNode) equals.bindExpression(fromList, subqueryList, aggregateVector);
1: 					
0: 					newAnd = (AndNode) getNodeFactory().getNode(
0: 														C_NodeTypes.AND_NODE,
0: 														this,
0: 														equals,
1: 														getContextManager());
1: 					finishBindExpr();
1: 					newAnd.postBindFixup();
1: 					return newAnd;
1: 				}
1: 			}
1: 		}
1: 
0: 		/* If we are comparing a char with a national char then
0: 		 * we generate a cast above the reciever to force preprocess to
1: 		 * not attempt any of the > <= optimizations since there is no
1: 		 * way to determine the 'next' character for the <= operand.
1: 		 */
1: 
0: 		TypeId leftTypeId = leftOperand.getTypeId();
0: 		TypeId receiverTypeId = receiver.getTypeId();
1: 
0: 		if (receiverTypeId.isNationalStringTypeId() && ! leftTypeId.isNationalStringTypeId())
1: 		{
0: 			receiver = castArgToNationalString(receiver, receiverTC, receiverTypeId);
1: 		}
0: 		else if (leftTypeId.isNationalStringTypeId() && ! receiverTypeId.isNationalStringTypeId())
1: 		{
0: 			leftOperand = castArgToNationalString(leftOperand, leftTC, leftTypeId);
1: 		}
1: 
1: 		finishBindExpr();
1: 
1: 		return this;
1: 	}
0: 	private ValueNode castArgToNationalString(ValueNode vn, TypeCompiler vnTC, TypeId vnTypeId)
1: 		throws StandardException
1: 	{
0: 		ValueNode newNode =  (ValueNode)
0: 			getNodeFactory().getNode(
0: 			C_NodeTypes.CAST_NODE,
0: 			vn, 
0: 			new DataTypeDescriptor(vnTypeId, 
0: 			true,
0: 			vnTC.getCastToCharWidth(vn.getTypeServices())), getContextManager());
0: 		((CastNode) newNode).bindCastNodeOnly();
0: 		return newNode;
1: 	}
1: 	private void finishBindExpr()
1: 		throws StandardException
1: 	{
1: 		// deal with compatability of operands and result type
1: 		bindComparisonOperator();
1: 
1: 		/*
1: 		** The result type of LIKE is Boolean
1: 		*/
1: 
1: 		boolean nullableResult =
0: 			receiver.getTypeServices().isNullable() || leftOperand.getTypeServices().isNullable();
1: 
1: 		if (rightOperand != null)
1: 		{
1: 			nullableResult |= rightOperand.getTypeServices().isNullable();
1: 		}
1: 
0: 		setType(new DataTypeDescriptor(
0: 						TypeId.BOOLEAN_ID,
0: 						nullableResult
0: 					)
0: 				);
1: 	}
1: 
1: 	/**
1: 	 * Bind this operator
1: 	 *
0: 	 * @return	Nothing
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public void bindComparisonOperator()
1: 			throws StandardException
1: 	{
0: 		TypeId	receiverType = receiver.getTypeId();
0: 		TypeId	leftType = leftOperand.getTypeId();
1: 
1: 		/*
1: 		** Check the type of the operands - this function is allowed only on
1: 		** string types.
1: 		*/
1: 
0: 		if ( ! receiverType.isStringTypeId())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
0: 												receiverType.getSQLTypeName());
1: 		}
1: 
0: 		if (! leftType.isStringTypeId())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
0: 												leftType.getSQLTypeName());
1: 		}
1: 
1: 		if (rightOperand != null && ! rightOperand.getTypeId().isStringTypeId())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
1: 												rightOperand.getTypeId().getSQLTypeName());
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
0: 	 * @return		The modified expression
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		boolean eliminateLikeComparison = false;
0: 		String	greaterEqualString = null;
0: 		String  lessThanString = null;
0: 		String  pattern;
1: 
1: 		/* We must 1st preprocess the component parts */
0: 		super.preprocess(numTables,
0: 						 outerFromList, outerSubqueryList,
0: 						 outerPredicateList);
1: 
0:         /* Don't try to optimize for (C)LOB type since it
0:          * doesn't allow comparison.
1:          */
0:         if (receiver.getTypeId().getSQLTypeName().equals("CLOB")) {
1:             return this;
1:         }
0: 		/* No need to consider transformation if we
0: 		 * already did transformation that added =
0: 		 * at bind time.
1: 		 */
1: 		if (addedEquals)
1: 		{
1: 			return this;
1: 		}
1: 
0: 		/* This is where we do the transformation for LIKE to make it optimizable.
1: 		 * c1 LIKE 'asdf%' -> c1 LIKE 'asdf%' AND c1 >= 'asdf' AND c1 < 'asdg'
0: 		 * c1 LIKE ? -> c1 LIKE ? and c1 >= ?', where ?' gets calculated at the
0: 		 * beginning of execution.
1: 		 */
1: 		if (!(leftOperand instanceof CharConstantNode) &&
0: 			!(leftOperand.isParameterNode()))
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/* This transformation is only worth doing if it is pushable, ie, if
1: 		 * the receiver is a ColumnReference.
1: 		 */
1: 		if (!(receiver instanceof ColumnReference))
1: 		{
1: 			//
0: 			// We also do an early return here if in bindExpression we found we had
0: 			// a National Char and put a CAST above the receiver.
1: 			//
1: 			return this;
1: 		}
1: 
1: 
0: 		// Build String constants if right side is a constant
1: 		if (leftOperand instanceof CharConstantNode)
1: 		{
1: 			pattern = ((CharConstantNode) leftOperand).getString();
1: 
0: 			if (! Like.isOptimizable(pattern))
1: 			{
1: 				return this;
1: 			}
1: 
0: 			greaterEqualString = Like.greaterEqualString(pattern, escape);
1: 
1: 
1: 
0: 			/* We do not generate the < and we cannot drop the LIKE
0: 			 * when doing LIKE on a national char column.
1: 			 */
0:             if ( ! receiver.getTypeId().isNationalStringTypeId() )
1: 			{
0: 				lessThanString = Like.lessThanString(greaterEqualString);
0: 				eliminateLikeComparison = ! Like.isLikeComparisonNeeded(pattern);
1: 			}
1: 		}
1: 
0: 		//System.out.println(receiver.getTypeServices());
0: 		//System.out.println("MAX WIDTH " + receiver.getTypeServices().getMaximumWidth());
1: 
1: 		/* For some unknown reason we need to clone the receiver if it is
1: 		 * a ColumnReference because reusing them in Qualifiers for a scan
1: 		 * does not work.  
1: 		 */
1: 
1: 		/* The transformed tree has to be normalized.  Either:
0: 		 *			AND									AND
0: 		 *		   /   \							   /   \
0: 		 *	     LIKE   AND				OR:			 LIKE	AND
0: 		 *			   /   \							   /   \
0: 		 *			  >=    AND							  >=    TRUE
0: 		 *				   /   \
0: 		 *				  <     TRUE
1: 		 * unless the like string is of the form CONSTANT%, in which
1: 		 * case we can do away with the LIKE altogether:
0: 		 *			AND									AND
0: 		 *		   /   \							   /   \
0: 		 *	     >=     AND				OR:			 >=  	TRUE
0: 		 *			   /   \
0: 		 *			  <    TRUE
1: 		 */
1: 
0: 		AndNode	  newAnd = null;
0:         ValueNode trueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.TRUE,
1: 											getContextManager());
1: 
0: 		/* Create the AND <, if lessThanString is non-null  or 
0: 		 * leftOperand is a parameter.
0: 		   Currently for a national string we do not add a < than operator
0: 		   since we don't know (?) how to calculate such a string.
1: 		 */
0: 		if ( lessThanString != null || ( leftOperand.isParameterNode() &&
0:                                          ! receiver.getTypeId().isNationalStringTypeId() ))
1: 		{
0: 			QueryTreeNode likeLTopt;
0: 			if (leftOperand.isParameterNode())
1: 			{
0: 				likeLTopt = setupOptimizeStringFromParameter(leftOperand, rightOperand,
0: 								"lessThanStringFromParameter");
1: 			}
1: 			else
1: 			{
0: 				likeLTopt = getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												lessThanString,
1: 												getContextManager());
1: 			}
1: 
1: 			BinaryComparisonOperatorNode lessThan = 
0: 					(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
1: 							receiver.getClone(), 
1: 							likeLTopt,
1: 							getContextManager());
1: 
1: 			// Disable comparability checks
1: 			lessThan.setForQueryRewrite(true);
1: 			/* Set type info for the operator node */
1: 			lessThan.bindComparisonOperator();
1: 
1: 			// Use between selectivity for the <
1: 			lessThan.setBetweenSelectivity();
1: 
1: 			/* Create the AND */
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													lessThan,
0: 													trueNode,
1: 													getContextManager());
1: 			newAnd.postBindFixup();
1: 		}
1: 
0: 		/* Create the AND >=.  Right side could
0: 		 * be a CharConstantNode or a ParameterNode.
1: 		 */
1: 
1: 		ValueNode likeGEopt;
0: 		if (leftOperand.isParameterNode()) {
1: 
1: 			// Create an expression off the parameter
1: 			// new SQLChar(Like.greaterEqualString(?));
1: 
0: 			likeGEopt = setupOptimizeStringFromParameter(leftOperand, rightOperand,
0: 									"greaterEqualStringFromParameter");
1: 
0: 		} else {
1: 
1: 
1: 
0: 			likeGEopt = (ValueNode) getNodeFactory().getNode(C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												greaterEqualString,
1: 												getContextManager());
1: 		}
1: 
1: 		BinaryComparisonOperatorNode greaterEqual = 
0: 				(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
1: 						receiver.getClone(), 
1: 						likeGEopt,
1: 						getContextManager());
1: 
1: 
1: 		// Disable comparability checks
1: 		greaterEqual.setForQueryRewrite(true);
1: 		/* Set type info for the operator node */
1: 		greaterEqual.bindComparisonOperator();
1: 
1: 		// Use between selectivity for the >=
1: 		greaterEqual.setBetweenSelectivity();
1: 
1: 		/* Create the AND */
1: 		if (newAnd == null)
1: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													greaterEqual,
0: 													trueNode,
1: 													getContextManager());
1: 		}
1: 		else
1: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													greaterEqual,
0: 													newAnd,
1: 													getContextManager());
1: 		}
1: 		newAnd.postBindFixup();
1: 
0: 		/* Finally, we put a AND LIKE on top of the left deep tree, but
1: 		 * only if it is still necessary.
1: 	     */
0: 		if (! eliminateLikeComparison)
1: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													this,
0: 													newAnd,
1: 													getContextManager());
1: 			newAnd.postBindFixup();
1: 		}
1: 
1: 		/* Mark this node as transformed so that we don't get
0: 		 * calculated into the selectivity mulitple times.
1: 		 */
1: 		setTransformed();
1: 
1: 		return newAnd;
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this binary operator.
1: 	 *
0: 	 *		This code was copied from BinaryOperatorNode and stripped down
1: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the code to place the code
1: 	 *
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 		throws StandardException
1: 	{
1: 
1: /*
1: ** if i have a operator.getOrderableType() == constant, then just cache 
1: ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
1: ** cache it in something that is initialized each execution,
1: ** but how?
1: */
1: 
1: 		/*
1: 		** let the receiver type be determined by an
1: 		** overridable method so that if methods are
1: 		** not implemented on the lowest interface of
1: 		** a class, they can note that in the implementation
1: 		** of the node that uses the method.
1: 		*/
1: 		// receiverType = getReceiverInterfaceName();
1: 
1: 		/*
1: 		** Generate LHS (field = <receiver operand>). This assignment is
1: 		** used as the receiver of the method call for this operator.
1: 		**
0: 		**	(<receiver operand>).method(<left operand>,
0: 		**                      <right operand>, [<escaperightOp>,]
0: 		**						<result field>)
1: 		*/
1: 
0: 		receiver.generateExpression(acb, mb);	// first arg
1: 
1: 		receiverInterfaceType = receiver.getTypeCompiler().interfaceName();
1: 
0: 		mb.upCast(receiverInterfaceType); 		// cast the method instance
1: 
1: 		leftOperand.generateExpression(acb, mb);
0: 		mb.upCast(leftInterfaceType); 			// first arg with cast
1: 
1: 		if (rightOperand != null)
1: 		{
1: 			rightOperand.generateExpression(acb, mb);
0: 			mb.upCast(rightInterfaceType); 		// second arg with cast
1: 		}
1: 
1: 		/* Figure out the result type name */
1: 		// resultTypeName = getTypeCompiler().interfaceName();
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 			methodName, resultInterfaceType,
1: 			rightOperand == null ? 1 : 2);
1: 	}
1: 
0: 	private ValueNode setupOptimizeStringFromParameter(ValueNode parameterNode,
0: 						ValueNode escapeNode,String methodName)
0: 		throws StandardException {
1: 
0: 		Vector param;
1: 
1: 		if (escapeNode != null)
1: 		{
0: 			param = new Vector(2);
1: 			methodName += "WithEsc";
1: 		}
0: 		else param = new Vector(1);
1: 
0: 		StaticMethodCallNode methodCall = (StaticMethodCallNode)
0: 						getNodeFactory().getNode(C_NodeTypes.STATIC_METHOD_CALL_NODE,
1: 											methodName,
1: 											"org.apache.derby.iapi.types.Like",
1: 											getContextManager());
1: 
1: 		// using a method call directly, thus need internal sql capability
1: 		methodCall.internalCall = true;
1: 
0: 		param.addElement(parameterNode);
1: 		if (escapeNode != null)
0: 			param.addElement(escapeNode);
1: 
0: 		methodCall.addParms(param);
1: 
1: 
0: 		ValueNode java2SQL = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									methodCall,
1: 									getContextManager());
1: 
1: 
0: 		java2SQL = (ValueNode) java2SQL.bindExpression(null, null, null);
1: 
0: 		CastNode likeOpt = (CastNode)
0: 			getNodeFactory().getNode(
0: 				C_NodeTypes.CAST_NODE,
1: 				java2SQL,
1: 				parameterNode.getTypeServices(),
1: 				getContextManager());
1: 
1: 		likeOpt.bindCastNodeOnly();
1: 
1: 		return likeOpt;
1: 	}
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:d9b6192
/////////////////////////////////////////////////////////////////////////
0:   
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ec2b8d1
/////////////////////////////////////////////////////////////////////////
0:         /* If we are comparing a char with a national char then
0:          * we generate a cast above the receiver to force preprocess to
0:          * not attempt any of the > <= optimizations since there is no
0:          * way to determine the 'next' character for the <= operand.
1:          *
1:          * TODO-COLLATE - probably need to do something about different 
1:          *                collation types here.
0:          */
0: 
0:         // The left and the pattern of the LIKE must be same collation type.
1:         if (receiver.getTypeServices().getCollationType() !=
0:                 leftOperand.getTypeServices().getCollationType())
1:         {
1:             // throw error.
1:             throw StandardException.newException(
1:                         SQLState.LANG_LIKE_COLLATION_MISMATCH, 
1:                         receiver.getTypeServices().getSQLstring(),
1:                         receiver.getTypeServices().getCollationName(),
1:                         leftOperand.getTypeServices().getSQLstring(),
1:                         leftOperand.getTypeServices().getCollationName());
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
commit:2c77aa2
/////////////////////////////////////////////////////////////////////////
1:         /* 
1:          * In first implementation of non default collation don't attempt
1:          * any transformations for LIKE.  
1:          *
1:          * Future possibilities:
1:          * o is it valid to produce a >= clause for a leading constant with
1:          *   a wildcard that works across all possible collations?  Is 
1:          *   c1 like a% the same as c1 like a% and c1 >= a'\u0000''\u0000',... ?
1:          *
1:          *   This is what was done for national char's.  It seems like a 
1:          *   given collation could sort: ab, a'\u0000'.  Is there any guarantee
1:          *   about the sort of the unicode '\u0000'.
1:          *
0:          * o National char's don't try to produce a < than, is there a way
1:          *   in collation?
0:          */
0:         if (receiver.getTypeServices().getCollationType() != 
1:                 StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:         {
1:             // don't do any < or >= transformations for non default collations.
1:             return this;
0:         }
0: 
commit:d61b68f
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.sql.compile;
/////////////////////////////////////////////////////////////////////////
1:      * @param receiver      The left operand of the like: 
1:      * @param leftOperand   The right operand of the like: the pattern
1:      * @param rightOperand  The optional escape clause, null if not present
/////////////////////////////////////////////////////////////////////////
1:      * @return  The new top of the expression tree.
/////////////////////////////////////////////////////////////////////////
1:          *        AND
1:          *       /   \
1:          *     LIKE   =
/////////////////////////////////////////////////////////////////////////
1:                     //        AND
1:                     //       /   \
1:                     //     LIKE   = 
1:                     //           / \
1:                     //       column 'Derby'
/////////////////////////////////////////////////////////////////////////
1:     * @exception StandardException  Thrown on error
1:         TypeId receiverType = receiver.getTypeId();
1:         TypeId leftType     = leftOperand.getTypeId();
/////////////////////////////////////////////////////////////////////////
1:     * @param numTables          Number of tables in the DML Statement
1:     * @param outerFromList      FromList from outer query block
1:     * @param outerSubqueryList  SubqueryList from outer query block
1:     * @param outerPredicateList PredicateList from outer query block
1:     * @return The modified expression
1:     * @exception StandardException  Thrown on error
/////////////////////////////////////////////////////////////////////////
1:         String  greaterEqualString      = null;
/////////////////////////////////////////////////////////////////////////
1:          *        AND                   AND
1:          *       /   \                 /   \
1:          *     LIKE   AND     OR:   LIKE   AND
1:          *           /   \                /   \
1:          *          >=    AND           >=    TRUE
1:          *               /   \
1:          *              <     TRUE
1:          *        AND                   AND
1:          *       /   \                 /   \
1:          *      >=   AND      OR:     >=  TRUE
1:          *          /   \
1:          *         <    TRUE
1:         AndNode   newAnd   = null;
/////////////////////////////////////////////////////////////////////////
0:         BinaryComparisonOperatorNode greaterEqual = 
/////////////////////////////////////////////////////////////////////////
1:      * This code was copied from BinaryOperatorNode and stripped down
1:      * @param acb   The ExpressionClassBuilder for the class we're generating
1:      * @param mb    The method the code to place the code
1:      * @exception StandardException Thrown on error
/////////////////////////////////////////////////////////////////////////
1:         ** (<receiver operand>).method(
1:         **     <left operand>, 
1:         **     <right operand>, 
1:         **     [<escaperightOp>,] 
1:         **     result field>)
1:         receiver.generateExpression(acb, mb);   // first arg
1:         mb.upCast(receiverInterfaceType);       // cast the method instance
1:         mb.upCast(leftInterfaceType);           // first arg with cast
1:             mb.upCast(rightInterfaceType);      // second arg with cast
commit:eb0cea2
/////////////////////////////////////////////////////////////////////////
1:     This node represents a like comparison operator (no escape)
0: 
0:     If the like pattern is a constant or a parameter then if possible
0:     the like is modified to include a >= and < operator. In some cases
0:     the like can be eliminated.  By adding =, >= or < operators it may
1:     allow indexes to be used to greatly narrow the search range of the
1:     query, and allow optimizer to estimate number of rows to affected.
1:     constant or parameter LIKE pattern with prefix followed by optional wild 
1:     card e.g. Derby%
0: 
0:     CHAR(n), VARCHAR(n) where n < 255
0: 
0:         >=   prefix padded with '\u0000' to length n -- e.g. Derby\u0000\u0000
0:         <=   prefix appended with '\uffff' -- e.g. Derby\uffff
0: 
0:         [ can eliminate LIKE if constant. ]
0:     CHAR(n), VARCHAR(n), LONG VARCHAR where n >= 255
0:         >= prefix backed up one characer
0:         <= prefix appended with '\uffff'
0:         no elimination of like
1:     parameter like pattern starts with wild card e.g. %Derby
0:     CHAR(n), VARCHAR(n) where n <= 256
0:         >= '\u0000' padded with '\u0000' to length n
0:         <= '\uffff'
0:         no elimination of like
0:     CHAR(n), VARCHAR(n), LONG VARCHAR where n > 256
0: 
0:         >= NULL
0: 
0:         <= '\uffff'
1:     Note that the Unicode value '\uffff' is defined as not a character value
0:     and can be used by a program for any purpose. We use it to set an upper
0:     bound on a character range with a less than predicate. We only need a single
1:     '\uffff' appended because the string 'Derby\uffff\uffff' is not a valid
0:     String because '\uffff' is not a valid character.
1: **/
1:     /**************************************************************************
1:     * Fields of the class
1:     **************************************************************************
0:     */
0:     boolean addedEquals;
1:     String  escape;
0:     /**
0:      * Initializer for a LikeEscapeOperatorNode
1:      *
1:      * receiver like pattern [ escape escapeValue ]
1:      *
0:      * @param receiver   		The left operand of the like: 
1:      *                              column, CharConstant or Parameter
0:      * @param leftOperand		The right operand of the like: the pattern
0:      * @param rightOperand		The optional escape clause, null if not present
0:      */
0:     public void init(
0:     Object receiver,
0:     Object leftOperand,
0:     Object rightOperand)
0:     {
0:         /* By convention, the method name for the like operator is "like" */
0:         super.init(
0:             receiver, leftOperand, rightOperand, 
0:             ReuseFactory.getInteger(TernaryOperatorNode.LIKE), null); 
0:     }
0:     /**
1:      * implement binding for like expressions.
1:      * <p>
0:      * overrides BindOperatorNode.bindExpression because like has special
0:      * requirements for parameter binding.
1:      *
0:      * @return	The new top of the expression tree.
1:      *
0:      * @exception StandardException thrown on failure
0:      */
0:     public ValueNode bindExpression(
0:     FromList        fromList, 
0:     SubqueryList    subqueryList,
0:     Vector          aggregateVector) 
0:         throws StandardException
0:     {
0:         super.bindExpression(fromList, subqueryList, aggregateVector);
0:         String pattern = null;
0:         // pattern must be a string or a parameter
1:         if (!(leftOperand.requiresTypeFromContext()) && 
1:              !(leftOperand.getTypeId().isStringTypeId()))
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
0:         }
0:         // escape must be a string or a parameter
1:         if ((rightOperand != null) && 
1:             !(rightOperand.requiresTypeFromContext()) && 
1:             !(rightOperand.getTypeId().isStringTypeId()))
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
0:         }
0:         // deal with operand parameters
1:         /* 
1:         *  Is there a ? parameter on the left? ie. "? like 'Derby'"
1:         *
0:         *  Do left first because its length is always maximum;
0:         *  a parameter on the right copies its length from
0:         *  the left, since it won't match if it is any longer than it.
0:         */
1:         if (receiver.requiresTypeFromContext())
0:         {
1:             receiver.setType(
1:                 new DataTypeDescriptor(
1:                     TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0:         }
1:         /* 
1:          *  Is there a ? parameter for the PATTERN of LIKE? ie. "column like ?"
1:          *  
0:          *  Copy from the receiver -- legal if both are parameters,
0:          *  both will be max length.
0:          *  REMIND: should nullability be copied, or set to true?
0:          */
1:         if (leftOperand.requiresTypeFromContext())
0:         {
1:             /*
0:             * Set the pattern to the type of the left parameter, if
0:             * the left is a string, otherwise set it to be VARCHAR. 
0:             */
0:             if (receiver.getTypeId().isStringTypeId())
0:             {
1:                 leftOperand.setType(receiver.getTypeServices());
0:             }
1:             else
0:             {
1:                 leftOperand.setType(
1:                     new DataTypeDescriptor(
1:                         TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0:             }
0:         }
1:         /* 
0:          *  Is there a ? parameter for the ESCAPE of LIKE?
0:          *  Copy from the receiver -- legal if both are parameters,
0:          *  both will be max length.  nullability is set to true.
0:          */
1:         if (rightOperand != null && rightOperand.requiresTypeFromContext())
0:         {
1:             /*
0:              * Set the pattern to the type of the left parameter, if
0:              * the left is a string, otherwise set it to be VARCHAR. 
0:              */
0:             if (receiver.getTypeId().isStringTypeId())
0:             {
1:                 rightOperand.setType(receiver.getTypeServices());
0:             }
1:             else
0:             {
1:                 rightOperand.setType(
1:                     new DataTypeDescriptor(
1:                         TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0:             }
0:         }
0:         bindToBuiltIn();
0:         TypeCompiler receiverTC = receiver.getTypeCompiler();
0:         TypeCompiler leftTC     = leftOperand.getTypeCompiler();
0:         /* The receiver must be a string type
0:         */
0:         if (! receiver.getTypeId().isStringTypeId())
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
0:         }
0:         /* If either the left or right operands are non-string types,
0:          * then we generate an implicit cast to VARCHAR.
0:          */
1:         if (!leftOperand.getTypeId().isStringTypeId())
0:         {
0:             leftOperand = castArgToString(leftOperand);
0:             leftTC      = leftOperand.getTypeCompiler();
0:         }
0:         if (rightOperand != null)
0:         {
0:             rightOperand = castArgToString(rightOperand);
0:         }
1:         /* 
1:          * Remember whether or not the right side (the like pattern) is a string 
1:          * constant.  We need to remember here so that we can transform LIKE 
1:          * 'constant' into = 'constant' for non unicode based collation columns.
0:          */
0:         boolean leftConstant = (leftOperand instanceof CharConstantNode);
0:         if (leftConstant)
0:         {
0:             pattern = ((CharConstantNode) leftOperand).getString();
0:         }
0:         boolean rightConstant = (rightOperand instanceof CharConstantNode);
0:         if (rightConstant)
0:         {
0:             escape = ((CharConstantNode) rightOperand).getString();
0:             if (escape.length() != 1)
0:             {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_ESCAPE_CHARACTER, escape);
0:             }
0:         }
0:         else if (rightOperand == null)
0:         {
0:             // No Escape clause: Let optimization continue for the = case below
0:             rightConstant = true;
0:         }
1:         /* If the left side of LIKE is a ColumnReference and right side is a 
1:          * string constant without a wildcard (eg. column LIKE 'Derby') then we 
1:          * transform the LIKE into the equivalent LIKE AND =.  
1:          * If we have an escape clause it also must be a constant 
1:          * (eg. column LIKE 'Derby' ESCAPE '%').
1:          *
1:          * These types of transformations are normally done at preprocess time, 
1:          * but we make an exception and do this one at bind time because we 
1:          * transform a NOT LIKE 'a' into (a LIKE 'a') = false prior to 
0:          * preprocessing.  
1:          *
0:          * The transformed tree will become:
1:          *
0:          *			AND
0:          *		   /   \
0:          *	     LIKE   =
0:          */
1:         if ((receiver instanceof ColumnReference) && 
1:             leftConstant                          && 
1:             rightConstant)
0:         {
0:             if (Like.isOptimizable(pattern))
0:             {
0:                 String newPattern = null;
/////////////////////////////////////////////////////////////////////////
1:                         Like.stripEscapesNoPatternChars(
1:                             pattern, escape.charAt(0));
1:                 else if (pattern.indexOf('_') == -1 && 
1:                          pattern.indexOf('%') == -1)
1:                     // no pattern characters.
0:                 {
1:                     // met all conditions, transform LIKE into a "LIKE and ="
0:                     ValueNode leftClone = receiver.getClone();
0:                     // Remember that we did xform, see preprocess()
0:                     addedEquals = true;
1:                     // create equals node of the form (eg. column like 'Derby' :
1:                     //       =
1:                     //     /   \
1:                     //  column  'Derby'
1:                     BinaryComparisonOperatorNode equals = 
0:                         (BinaryComparisonOperatorNode) getNodeFactory().getNode(
0:                             C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0:                             leftClone, 
0:                             (ValueNode) getNodeFactory().getNode(
0:                                 C_NodeTypes.CHAR_CONSTANT_NODE,
0:                                 newPattern,
0:                                 getContextManager()),
0:                             getContextManager());
0:                     // Set forQueryRewrite to bypass comparability checks
0:                     equals.setForQueryRewrite(true);
1:                     equals = (BinaryComparisonOperatorNode) 
1:                         equals.bindExpression(
0:                             fromList, subqueryList, aggregateVector);
1:                     // create new and node and hook in "equals" the new "=' node
0:                     //
0:                     //			AND
0:                     //		   /   \
0:                     //	     LIKE  = 
0:                     //	          / \
0:                     //	    column  'Derby'
0:                     AndNode newAnd = 
0:                         (AndNode) getNodeFactory().getNode(
0:                                     C_NodeTypes.AND_NODE,
0:                                     this,
0:                                     equals,
0:                                     getContextManager());
0:                     finishBindExpr();
0:                     newAnd.postBindFixup();
0:                     return newAnd;
0:                 }
0:             }
0:         }
0:         /* If we are comparing a char with a national char then
0:          * we generate a cast above the receiver to force preprocess to
0:          * not attempt any of the > <= optimizations since there is no
0:          * way to determine the 'next' character for the <= operand.
0:          *
0:          * TODO-COLLATE - probably need to do something about different 
0:          *                collation types here.
0: 
0:         TypeId leftTypeId     = leftOperand.getTypeId();
0:         TypeId receiverTypeId = receiver.getTypeId();
0: 
0:         if (receiverTypeId.isNationalStringTypeId() && 
0:             !leftTypeId.isNationalStringTypeId())
0:         {
0:             // if column is national column and pattern is not national column
0:             receiver = 
0:                 castArgToNationalString(receiver, receiverTC, receiverTypeId);
0:         }
0:         else if (leftTypeId.isNationalStringTypeId() && 
0:                  !receiverTypeId.isNationalStringTypeId())
0:         {
0:             // if patern is national column and column is not national column
0:             leftOperand = 
0:                 castArgToNationalString(leftOperand, leftTC, leftTypeId);
0:         }
0: 
0:         finishBindExpr();
0: 
0:         return this;
0:     }
0: 
0:     private ValueNode castArgToNationalString(
0:     ValueNode       vn, 
0:     TypeCompiler    vnTC, 
0:     TypeId          vnTypeId)
0:         throws StandardException
0:     {
0:         ValueNode newNode =  (ValueNode)
0:             getNodeFactory().getNode(
0:                 C_NodeTypes.CAST_NODE,
0:                 vn, 
0:                 new DataTypeDescriptor(vnTypeId, 
0:                 true,
0:                 vnTC.getCastToCharWidth(vn.getTypeServices())), 
0:                 getContextManager());
0: 
0:         ((CastNode) newNode).bindCastNodeOnly();
0: 
0:         return newNode;
0:     }
0: 
0:     private void finishBindExpr()
0:     throws StandardException
0:     {
0:         // deal with compatability of operands and result type
0:         bindComparisonOperator();
0: 
0:         /*
0:         ** The result type of LIKE is Boolean
0:         */
0: 
0:         boolean nullableResult =
1:             receiver.getTypeServices().isNullable() || 
1:             leftOperand.getTypeServices().isNullable();
0: 
0:         if (rightOperand != null)
0:         {
0:             nullableResult |= rightOperand.getTypeServices().isNullable();
0:         }
0: 
1:         setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, nullableResult));
0:     }
0: 
0:     /**
0:     * Bind this operator
0:     *
0:     * @exception StandardException		Thrown on error
0:     */
0: 
0:     public void bindComparisonOperator()
0:         throws StandardException
0:     {
0:         TypeId	receiverType = receiver.getTypeId();
0:         TypeId	leftType     = leftOperand.getTypeId();
0: 
0:         /*
0:         ** Check the type of the operands - this function is allowed only on
0:         ** string types.
0:         */
0: 
1:         if (!receiverType.isStringTypeId())
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_LIKE_BAD_TYPE, receiverType.getSQLTypeName());
0:         }
0: 
1:         if (!leftType.isStringTypeId())
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_LIKE_BAD_TYPE, leftType.getSQLTypeName());
0:         }
0: 
0:         if (rightOperand != null && ! rightOperand.getTypeId().isStringTypeId())
0:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_LIKE_BAD_TYPE, 
0:                 rightOperand.getTypeId().getSQLTypeName());
0:         }
0:     }
0: 
0:     /**
0:     * Preprocess an expression tree.  We do a number of transformations
0:     * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0:     * subquery flattening.
0:     * NOTE: This is done before the outer ResultSetNode is preprocessed.
0:     *
0:     * @param	numTables			Number of tables in the DML Statement
0:     * @param	outerFromList		FromList from outer query block
0:     * @param	outerSubqueryList	SubqueryList from outer query block
0:     * @param	outerPredicateList	PredicateList from outer query block
0:     *
0:     * @return		The modified expression
0:     *
0:     * @exception StandardException		Thrown on error
0:     */
0:     public ValueNode preprocess(
1:     int             numTables,
1:     FromList        outerFromList,
1:     SubqueryList    outerSubqueryList,
1:     PredicateList   outerPredicateList) 
0:         throws StandardException
0:     {
0:         boolean eliminateLikeComparison = false;
0:         String	greaterEqualString      = null;
1:         String  lessThanString          = null;
0: 
0:         /* We must 1st preprocess the component parts */
1:         super.preprocess(
1:             numTables, outerFromList, outerSubqueryList, outerPredicateList);
0: 
1:         /* Don't try to optimize for (C)LOB type since it doesn't allow 
1:          * comparison.
1:          * RESOLVE: should this check be for LONG VARCHAR also?
0:          */
1:         if (receiver.getTypeId().getSQLTypeName().equals("CLOB")) 
0:         {
1:         /* No need to consider transformation if we already did transformation 
1:          * that added = * at bind time.
0:          */
0:         if (addedEquals)
0:         {
0:             return this;
0:         }
1:         /* if like pattern is not a constant and not a parameter, 
1:          * then can't optimize, eg. column LIKE column
0:          */
0:         if (!(leftOperand instanceof CharConstantNode) && 
1:                 !(leftOperand.requiresTypeFromContext()))
0:         {
0:             return this;
0:         }
0:         /* This transformation is only worth doing if it is pushable, ie, if
0:          * the receiver is a ColumnReference.
0:          */
0:         if (!(receiver instanceof ColumnReference))
0:         {
1:             // We also do an early return here if in bindExpression we found 
0:             // we had a National Char and put a CAST above the receiver.
0:             //
0:             return this;
0:         }
1:         /* This is where we do the transformation for LIKE to make it 
1:          * optimizable.
0:          * c1 LIKE 'asdf%' -> c1 LIKE 'asdf%' AND c1 >= 'asdf' AND c1 < 'asdg'
1:          * c1 LIKE ?       -> c1 LIKE ? and c1 >= ?
1:          *     where ? gets calculated at the beginning of execution.
0:          */
1:         // Build String constants if right side (pattern) is a constant
0:         if (leftOperand instanceof CharConstantNode)
0:         {
1:             String pattern = ((CharConstantNode) leftOperand).getString();
1:             if (!Like.isOptimizable(pattern))
0:             {
0:                 return this;
0:             }
0:             int maxWidth = receiver.getTypeServices().getMaximumWidth();
1:             greaterEqualString = 
1:                 Like.greaterEqualString(pattern, escape, maxWidth);
0:             /* We do not generate the < and we cannot drop the LIKE
0:              * when doing LIKE on a national char column.
0:              */
0:             if (!receiver.getTypeId().isNationalStringTypeId())
0:             {
0:                 lessThanString          = 
0:                     Like.lessThanString(pattern, escape, maxWidth);
0:                 eliminateLikeComparison = 
0:                     !Like.isLikeComparisonNeeded(pattern);
0:             }
0:         }
0:         /* For some unknown reason we need to clone the receiver if it is
0:          * a ColumnReference because reusing them in Qualifiers for a scan
0:          * does not work.  
0:          */
0:         /* The transformed tree has to be normalized.  Either:
0:          *			AND									AND
0:          *		   /   \							   /   \
0:          *	     LIKE   AND				OR:			 LIKE	AND
0:          *			   /   \							   /   \
0:          *			  >=    AND							  >=    TRUE
0:          *				   /   \
0:          *				  <     TRUE
0:          * unless the like string is of the form CONSTANT%, in which
0:          * case we can do away with the LIKE altogether:
0:          *			AND									AND
0:          *		   /   \							   /   \
0:          *	     >=     AND				OR:			 >=  	TRUE
0:          *			   /   \
0:          *			  <    TRUE
0:          */
0:         AndNode	  newAnd   = null;
0:         ValueNode trueNode = 
0:             (ValueNode) getNodeFactory().getNode(
0:                             C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0:                             Boolean.TRUE,
0:                             getContextManager());
1:         /* Create the AND <, if lessThanString is non-null or 
0:          * (leftOperand is a parameter and not a national string).
0:          *
0:          * Currently for a national string we do not add a < than operator 
0:          * since we don't know (?) how to calculate such a string.
0:          */
1:         if (lessThanString != null || 
0:             (leftOperand.requiresTypeFromContext() && 
0:              !receiver.getTypeId().isNationalStringTypeId()))
0:         {
0:             QueryTreeNode likeLTopt;
1:             if (leftOperand.requiresTypeFromContext())
0:             {
1:                 // pattern string is a parameter 
1:                 likeLTopt = 
1:                     setupOptimizeStringFromParameter(
1:                         leftOperand, 
1:                         rightOperand, 
1:                         "lessThanStringFromParameter", 
1:                         receiver.getTypeServices().getMaximumWidth());
0:             }
0:             else
0:             {
1:                 // pattern string is a constant
1:                 likeLTopt = 
0:                     getNodeFactory().getNode(
0:                         C_NodeTypes.CHAR_CONSTANT_NODE,
0:                         lessThanString,
0:                         getContextManager());
0:             }
0:             BinaryComparisonOperatorNode lessThan = 
0:                 (BinaryComparisonOperatorNode) getNodeFactory().getNode(
0:                     C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
0:                     receiver.getClone(), 
0:                     likeLTopt,
0:                     getContextManager());
0:             // Disable comparability checks
0:             lessThan.setForQueryRewrite(true);
0:             /* Set type info for the operator node */
0:             lessThan.bindComparisonOperator();
0:             // Use between selectivity for the <
0:             lessThan.setBetweenSelectivity();
0:             /* Create the AND */
0:             newAnd = (AndNode) getNodeFactory().getNode(
0:                 C_NodeTypes.AND_NODE,
0:                 lessThan,
0:                 trueNode,
0:                 getContextManager());
0:             newAnd.postBindFixup();
0:         }
1:         /* Create the AND >=.  Right side could be a CharConstantNode or a 
1:          * ParameterNode.
0:          */
0:         ValueNode likeGEopt;
1:         if (leftOperand.requiresTypeFromContext()) 
0:         {
1:             // the pattern is a ?, eg. c1 LIKE ?
0:             // Create an expression off the parameter
0:             // new SQLChar(Like.greaterEqualString(?));
1:             likeGEopt    = 
1:                 setupOptimizeStringFromParameter(
1:                     leftOperand, 
1:                     rightOperand, 
1:                     "greaterEqualStringFromParameter", 
1:                     receiver.getTypeServices().getMaximumWidth());
0:         } 
0:         else 
0:         {
1:             // the pattern is a constant, eg. c1 LIKE 'Derby'
1:             likeGEopt = 
0:                 (ValueNode) getNodeFactory().getNode(
0:                     C_NodeTypes.CHAR_CONSTANT_NODE,
0:                     greaterEqualString,
0:                     getContextManager());
0:         }
1:         // greaterEqual from (reciever LIKE pattern):
1:         //       >=
1:         //      /   \
1:         //  reciever pattern
0:             (BinaryComparisonOperatorNode) getNodeFactory().getNode(
0:                 C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
0:                 receiver.getClone(), 
0:                 likeGEopt,
0:                 getContextManager());
0:         // Disable comparability checks
0:         greaterEqual.setForQueryRewrite(true);
0:         /* Set type info for the operator node */
0:         greaterEqual.bindComparisonOperator();
0:         // Use between selectivity for the >=
0:         greaterEqual.setBetweenSelectivity();
0:         /* Create the AND */
0:         if (newAnd == null)
0:         {
0:             newAnd = (AndNode) getNodeFactory().getNode(
0:                 C_NodeTypes.AND_NODE,
0:                 greaterEqual,
0:                 trueNode,
0:                 getContextManager());
0:         }
0:         else
0:         {
0:             newAnd = (AndNode) getNodeFactory().getNode(
0:                 C_NodeTypes.AND_NODE,
0:                 greaterEqual,
0:                 newAnd,
0:                 getContextManager());
0:         }
0:         newAnd.postBindFixup();
1:         /* Finally, we put an AND LIKE on top of the left deep tree, but
0:          * only if it is still necessary.
0:          */
1:         if (!eliminateLikeComparison)
0:         {
0:             newAnd = (AndNode) 
0:                 getNodeFactory().getNode(
0:                     C_NodeTypes.AND_NODE,
0:                     this,
0:                     newAnd,
0:                     getContextManager());
0:             newAnd.postBindFixup();
0:         }
0:         /* Mark this node as transformed so that we don't get
1:         * calculated into the selectivity multiple times.
0:         */
0:         setTransformed();
0:         return newAnd;
0:     }
0:     /**
0:      * Do code generation for this binary operator.
0:      *
0:      *		This code was copied from BinaryOperatorNode and stripped down
0:      *
0:      * @param acb	The ExpressionClassBuilder for the class we're generating
0:      * @param mb	The method the code to place the code
0:      *
0:      *
0:      * @exception StandardException		Thrown on error
0:      */
0:     public void generateExpression(
0:     ExpressionClassBuilder  acb,
0:     MethodBuilder           mb)
0:         throws StandardException
0:     {
0:         /*
0:         ** if i have a operator.getOrderableType() == constant, then just cache 
0:         ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
0:         ** cache it in something that is initialized each execution,
0:         ** but how?
0:         */
0:         /*
0:         ** let the receiver type be determined by an
0:         ** overridable method so that if methods are
0:         ** not implemented on the lowest interface of
0:         ** a class, they can note that in the implementation
0:         ** of the node that uses the method.
0:         */
0:         // receiverType = getReceiverInterfaceName();
0:         /*
0:         ** Generate LHS (field = <receiver operand>). This assignment is
0:         ** used as the receiver of the method call for this operator.
0:         **
0:         **	(<receiver operand>).method(<left operand>,
0:         **                      <right operand>, [<escaperightOp>,]
0:         **						<result field>)
0:         */
0:         receiver.generateExpression(acb, mb);	// first arg
0:         receiverInterfaceType = receiver.getTypeCompiler().interfaceName();
0:         mb.upCast(receiverInterfaceType); 		// cast the method instance
0:         leftOperand.generateExpression(acb, mb);
0:         mb.upCast(leftInterfaceType); 			// first arg with cast
0:         if (rightOperand != null)
0:         {
0:             rightOperand.generateExpression(acb, mb);
0:             mb.upCast(rightInterfaceType); 		// second arg with cast
0:         }
0:         /* Figure out the result type name */
0:         // resultTypeName = getTypeCompiler().interfaceName();
1:         mb.callMethod(
1:             VMOpcode.INVOKEINTERFACE, 
1:             null, 
1:             methodName, 
1:             resultInterfaceType, 
0:             rightOperand == null ? 1 : 2);
0:     }
1:     private ValueNode setupOptimizeStringFromParameter(
1:     ValueNode   parameterNode, 
1:     ValueNode   escapeNode,
1:     String      methodName, 
1:     int         maxWidth)
0:         throws StandardException 
0:     {
0:         Vector param;
0:         if (escapeNode != null)
0:         {
0:             param = new Vector(2);
0:             methodName += "WithEsc";
0:         }
0:         else
0:         {
0:             param = new Vector(1);
0:         }
0:         StaticMethodCallNode methodCall = (StaticMethodCallNode)
0:             getNodeFactory().getNode(
0:                 C_NodeTypes.STATIC_METHOD_CALL_NODE,
1:                 methodName,
0:                 "org.apache.derby.iapi.types.Like",
0:                 getContextManager());
0:         // using a method call directly, thus need internal sql capability
0:         methodCall.internalCall = true;
0:         param.addElement(parameterNode);
0:         if (escapeNode != null)
0:             param.addElement(escapeNode);
0:         QueryTreeNode maxWidthNode = getNodeFactory().getNode(
0:             C_NodeTypes.INT_CONSTANT_NODE,
0:             new Integer(maxWidth),
0:             getContextManager());
0:         param.addElement(maxWidthNode);
0: 
0:         methodCall.addParms(param);
1:         ValueNode java2SQL = 
0:             (ValueNode) getNodeFactory().getNode(
0:                 C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0:                 methodCall,
0:                 getContextManager());
0:         java2SQL = (ValueNode) java2SQL.bindExpression(null, null, null);
0:         CastNode likeOpt = (CastNode)
0:         getNodeFactory().getNode(
0:             C_NodeTypes.CAST_NODE,
0:             java2SQL,
0:             parameterNode.getTypeServices(),
0:             getContextManager());
0:         likeOpt.bindCastNodeOnly();
0:         return likeOpt;
0:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
0: 	e.g. Derby%
0: 		>=   prefix padded with '\u0000' to length n -- e.g. Derby\u0000\u0000
0: 		<=   prefix appended with '\uffff' -- e.g. Derby\uffff
/////////////////////////////////////////////////////////////////////////
0: 	'\uffff' appended because the string 'Derby\uffff\uffff' is not a valid
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:4e388b4
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 		if (!(leftOperand.requiresTypeFromContext()) && !(leftOperand.getTypeId().isStringTypeId()))
/////////////////////////////////////////////////////////////////////////
0: 			!(rightOperand.requiresTypeFromContext()) && 
/////////////////////////////////////////////////////////////////////////
0: 		if (receiver.requiresTypeFromContext())
0: 			receiver.setType(
/////////////////////////////////////////////////////////////////////////
0: 		if (leftOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 				leftOperand.setType(receiver.getTypeServices());
0: 				leftOperand.setType(
/////////////////////////////////////////////////////////////////////////
0: 		if (rightOperand != null && rightOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 				rightOperand.setType(receiver.getTypeServices());
0: 				rightOperand.setType(
/////////////////////////////////////////////////////////////////////////
0: 			!(leftOperand.requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
0: 		if ( lessThanString != null || ( leftOperand.requiresTypeFromContext() &&
0: 			if (leftOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 		if (leftOperand.requiresTypeFromContext()) {
commit:3561497
/////////////////////////////////////////////////////////////////////////
0: 
0: 		if (!(leftOperand.isParameterNode()) && !(leftOperand.getTypeId().isStringTypeId()))
/////////////////////////////////////////////////////////////////////////
0: 		if ((rightOperand != null) && 
0: 			!(rightOperand.isParameterNode()) && 
0: 			!(rightOperand.getTypeId().isStringTypeId()))
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.types.Like;
0: 
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import java.util.Vector;
0: 
0: 
0: /**
0:  * This node represents a like comparison operator (no escape)
0: 
0: 
0: 	If the like pattern is a constant or a parameter then if possible
0: 	the like is modified to include a >= and < operator. In some cases
0: 	the like can be eliminated.
0: 
0: 
0: 	constant or parameter LIKE pattern with prefix followed by optional wild card
0: 	e.g. Cloudscape%
0: 
0: 	CHAR(n), VARCHAR(n) where n < 255
0: 
0: 		>=   prefix padded with '\u0000' to length n -- e.g. Cloudscape\u0000\u0000
0: 		<=   prefix appended with '\uffff' -- e.g. Cloudscape\uffff
0: 		
0: 		[ can eliminate LIKE if constant. ]
0: 
0: 	
0: 	CHAR(n), VARCHAR(n), LONG VARCHAR where n >= 255
0: 
0: 	    >= prefix backed up one characer
0: 		<= prefix appended with '\uffff'
0: 
0: 		no elimination of like
0: 
0: 
0: 	parameter like pattern starts with wild card
0: 
0: 		CHAR(n), VARCHAR(n) where n <= 256
0: 
0: 		>= '\u0000' padded with '\u0000' to length n
0: 		<= '\uffff'
0: 
0: 		no elimination of like
0: 
0: 	CHAR(n), VARCHAR(n), LONG VARCHAR where n > 256
0: 
0: 
0: 		>= NULL
0: 
0: 		<= '\uffff'
0: 	
0: 	    
0: 	Note that the Unicode value is '\uffff' is defined as not a character value
0: 	and can be used by a program for any purpose. We use it to set an upper
0: 	bound on a character range with a less than predicate. We only need a single
0: 	'\uffff' appended because the string 'Cloudscape\uffff\uffff' is not a valid
0: 	String because '\uffff' is not a valid character.
0: 		
0: 
0: 
0: 
0: 	
0: 
0: 		
0: 
0: 
0:  *
0:  * @author ames
0:  * 		converted to TernaryOperatorNode by been
0:  */
0: 
0: public final class LikeEscapeOperatorNode extends TernaryOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 	boolean addedEquals;
0: 	String escape;
0: 
0: 	/**
0: 	 * Initializer for a LikeEscapeOperatorNode
0: 	 *
0: 	 *	receiver like pattern [ escape escapeValue ]
0: 	 *
0: 	 * @param receiver   		The left operand of the like, column, CharConstant or Parameter
0: 	 * @param leftOperand		The right operand of the like, the pattern
0: 	 * @param rightOperand		The optional escape clause, null if not present
0: 	 */
0: 
0: 	public void init(
0: 			Object receiver,
0: 			Object leftOperand,
0: 			Object rightOperand)
0: 	{
0: 		/* By convention, the method name for the like operator is "like" */
0: 		// super.init(leftOperand, rightOperand, new Integer(LIKE), null, null);
0: 		super.init(receiver, leftOperand, rightOperand, ReuseFactory.getInteger(TernaryOperatorNode.LIKE), null); 
0: 	}
0: 
0: 	/**
0: 	 * overrides BindOperatorNode.bindExpression because like has special
0: 	 * requirements for parameter binding.
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		super.bindExpression(fromList, subqueryList, aggregateVector);
0: 
0: 		String pattern = null;
0: 
0: 		// pattern cannot be a column
0: 		if (leftOperand instanceof ColumnReference)
0: 			throw StandardException.newException(SQLState.LANG_DB2_LIKE_SYNTAX_ERROR);
0: 
0: 		// pattern must be a string or a parameter
0: 		if (!(leftOperand instanceof CharConstantNode) && !(leftOperand.isParameterNode()))
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
0: 													 "LIKE", "FUNCTION");
0: 
0: 		// escape cannot be a column
0: 		if (rightOperand != null && rightOperand instanceof ColumnReference)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_CHARACTER,
0: 										 ((ColumnReference) rightOperand).getColumnName());
0: 		}
0: 
0: 		// escape must be a string or a parameter
0: 		if (rightOperand != null && !(rightOperand instanceof CharConstantNode) && !(rightOperand.isParameterNode()))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
0: 										 "LIKE", "FUNCTION");
0: 		}
0: 
0: 		// deal with operand parameters
0: 
0: 		/* 
0: 		 *  Is there a ? parameter on the left?
0: 		 *  Do left first because its length is always maximum;
0: 		 *  a parameter on the right copies its length from
0: 		 *  the left, since it won't match if it is any longer than it.
0: 		 */
0: 
0: 		if (receiver.isParameterNode())
0: 		{
0: 			((ParameterNode) receiver).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0: 		}
0: 
0: 		/* 
0: 		 *  Is there a ? parameter for the PATTERN of LIKE?
0: 		 *  Copy from the receiver -- legal if both are parameters,
0: 		 *  both will be max length.
0: 		 *  REMIND: should nullability be copied, or set to true?
0: 		 */
0: 
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			/*
0: 			 * Set the pattern to the type of the left parameter, if
0: 			 * the left is a string, otherwise set it to be VARCHAR. 
0: 			 */
0: 			if (receiver.getTypeId().isStringTypeId())
0: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(receiver.getTypeServices());
0: 			}
0: 			else
0: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0: 			}
0: 		}
0: 
0: 		/* 
0: 		 *  Is there a ? parameter for the ESCAPE of LIKE?
0: 		 *  Copy from the receiver -- legal if both are parameters,
0: 		 *  both will be max length.  nullability is set to true.
0: 		 */
0: 
0: 		if (rightOperand != null && rightOperand.isParameterNode())
0: 		{
0: 			/*
0: 			 * Set the pattern to the type of the left parameter, if
0: 			 * the left is a string, otherwise set it to be VARCHAR. 
0: 			 */
0: 			if (receiver.getTypeId().isStringTypeId())
0: 			{
0: 				((ParameterNode) rightOperand).setDescriptor(receiver.getTypeServices());
0: 			}
0: 			else
0: 			{
0: 				((ParameterNode) rightOperand).setDescriptor(
0: 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
0: 			}
0: 		}
0: 
0: 		bindToBuiltIn();
0: 
0: 		TypeCompiler receiverTC = receiver.getTypeCompiler();
0: 		TypeCompiler leftTC = leftOperand.getTypeCompiler();
0: 
0: 		/* The receiver must be a string type
0: 		 */
0: 		if (! receiver.getTypeId().isStringTypeId())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "LIKE", "FUNCTION");
0: 
0: 		}
0: 
0: 		/* If either the left or right operands are non-string types,
0: 		 * then we generate an implicit cast to VARCHAR.
0: 		 */
0: 		if (! leftOperand.getTypeId().isStringTypeId())
0: 		{
0: 			leftOperand = castArgToString(leftOperand);
0: 			leftTC = leftOperand.getTypeCompiler();
0: 		}
0: 
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand = castArgToString(rightOperand);
0: 		}
0: 
0: 		/* Remember whether or not right side is a string constant.
0: 		 * We need to remember here so that we can transform 
0: 		 * LIKE 'constant' into = 'constant' for national char
0: 		 * columns.
0: 		 */
0: 		boolean leftConstant = (leftOperand instanceof CharConstantNode);
0: 		if (leftConstant)
0: 		{
0: 			pattern = ((CharConstantNode) leftOperand).getString();
0: 		}
0: 
0: 		boolean rightConstant = (rightOperand instanceof CharConstantNode);
0: 
0: 		if (rightConstant)
0: 		{
0: 			escape = ((CharConstantNode) rightOperand).getString();
0: 			if (escape.length() != 1)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_ESCAPE_CHARACTER,
0: 						escape);
0: 			}
0: 		}
0: 		else if (rightOperand == null)
0: 		{
0: 			// No Escape clause: Let optimization continue for the = case below
0: 			rightConstant = true;
0: 		}
0: 
0: 		/* If the left side of LIKE is a ColumnReference and
0: 		 * the right side is a string constant without 
0: 		 * a wildcard then we transform the LIKE into the 
0: 		 * equivalent LIKE AND =.  
0: 		 * If we have an escape clause it also must be a constant.
0: 		 * These types of transformations are normally done 
0: 		 * at preprocess time, but we make an exception 
0: 		 * and do this one at bind time because we transform
0: 		 * a NOT LIKE 'a' into (a LIKE 'a') = false prior to 
0: 		 * preprocessing.
0: 		 * The transformed tree will become:
0: 		 *			AND
0: 		 *		   /   \
0: 		 *	     LIKE   =
0: 		 */
0: 
0: 		if (receiver instanceof ColumnReference &&
0: 			leftConstant && rightConstant)
0: 		{
0: 			if (Like.isOptimizable(pattern))
0: 			{
0: 				String newPattern = null;
0: 
0:                 /*
0:                  * If our pattern has no pattern chars (after stripping them out
0:                  * for the ESCAPE case), we are good to apply = to this match
0:                  */
0: 
0:                 if (escape != null)
0:                 {
0:                     /* we return a new pattern stripped of ESCAPE chars */
0:                     newPattern =
0:                             Like.stripEscapesNoPatternChars(pattern, escape.charAt(0));
0:                 }
0:                 else if (pattern.indexOf('_') == -1 && pattern.indexOf('%') == -1)
0:                 {
0:                     newPattern = pattern;
0:                 }
0: 
0:                 if (newPattern != null)
0: 				{
0: 					AndNode	  newAnd = null;
0: 					BinaryComparisonOperatorNode equals = null;
0: 					ValueNode leftClone = receiver.getClone();
0: 
0: 					// Remember that we did xform, see preprocess()
0: 					addedEquals = true;
0: 
0: 					equals = 
0: 						(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 							leftClone, 
0: 							(ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												newPattern,
0: 												getContextManager()),
0: 							getContextManager());
0: 
0: 					// Set forQueryRewrite to bypass comparability checks
0: 					equals.setForQueryRewrite(true);
0: 					equals = (BinaryComparisonOperatorNode) equals.bindExpression(fromList, subqueryList, aggregateVector);
0: 					
0: 					newAnd = (AndNode) getNodeFactory().getNode(
0: 														C_NodeTypes.AND_NODE,
0: 														this,
0: 														equals,
0: 														getContextManager());
0: 					finishBindExpr();
0: 					newAnd.postBindFixup();
0: 					return newAnd;
0: 				}
0: 			}
0: 		}
0: 
0: 		/* If we are comparing a char with a national char then
0: 		 * we generate a cast above the reciever to force preprocess to
0: 		 * not attempt any of the > <= optimizations since there is no
0: 		 * way to determine the 'next' character for the <= operand.
0: 		 */
0: 
0: 		TypeId leftTypeId = leftOperand.getTypeId();
0: 		TypeId receiverTypeId = receiver.getTypeId();
0: 
0: 		if (receiverTypeId.isNationalStringTypeId() && ! leftTypeId.isNationalStringTypeId())
0: 		{
0: 			receiver = castArgToNationalString(receiver, receiverTC, receiverTypeId);
0: 		}
0: 		else if (leftTypeId.isNationalStringTypeId() && ! receiverTypeId.isNationalStringTypeId())
0: 		{
0: 			leftOperand = castArgToNationalString(leftOperand, leftTC, leftTypeId);
0: 		}
0: 
0: 		finishBindExpr();
0: 
0: 		return this;
0: 	}
0: 	private ValueNode castArgToNationalString(ValueNode vn, TypeCompiler vnTC, TypeId vnTypeId)
0: 		throws StandardException
0: 	{
0: 		ValueNode newNode =  (ValueNode)
0: 			getNodeFactory().getNode(
0: 			C_NodeTypes.CAST_NODE,
0: 			vn, 
0: 			new DataTypeDescriptor(vnTypeId, 
0: 			true,
0: 			vnTC.getCastToCharWidth(vn.getTypeServices())), getContextManager());
0: 		((CastNode) newNode).bindCastNodeOnly();
0: 		return newNode;
0: 	}
0: 	private void finishBindExpr()
0: 		throws StandardException
0: 	{
0: 		// deal with compatability of operands and result type
0: 		bindComparisonOperator();
0: 
0: 		/*
0: 		** The result type of LIKE is Boolean
0: 		*/
0: 
0: 		boolean nullableResult =
0: 			receiver.getTypeServices().isNullable() || leftOperand.getTypeServices().isNullable();
0: 
0: 		if (rightOperand != null)
0: 		{
0: 			nullableResult |= rightOperand.getTypeServices().isNullable();
0: 		}
0: 
0: 		setType(new DataTypeDescriptor(
0: 						TypeId.BOOLEAN_ID,
0: 						nullableResult
0: 					)
0: 				);
0: 	}
0: 
0: 	/**
0: 	 * Bind this operator
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindComparisonOperator()
0: 			throws StandardException
0: 	{
0: 		TypeId	receiverType = receiver.getTypeId();
0: 		TypeId	leftType = leftOperand.getTypeId();
0: 
0: 		/*
0: 		** Check the type of the operands - this function is allowed only on
0: 		** string types.
0: 		*/
0: 
0: 		if ( ! receiverType.isStringTypeId())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
0: 												receiverType.getSQLTypeName());
0: 		}
0: 
0: 		if (! leftType.isStringTypeId())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
0: 												leftType.getSQLTypeName());
0: 		}
0: 
0: 		if (rightOperand != null && ! rightOperand.getTypeId().isStringTypeId())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_LIKE_BAD_TYPE, 
0: 												rightOperand.getTypeId().getSQLTypeName());
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		boolean eliminateLikeComparison = false;
0: 		String	greaterEqualString = null;
0: 		String  lessThanString = null;
0: 		String  pattern;
0: 
0: 		/* We must 1st preprocess the component parts */
0: 		super.preprocess(numTables,
0: 						 outerFromList, outerSubqueryList,
0: 						 outerPredicateList);
0: 
0:         /* Don't try to optimize for (C)LOB type since it
0:          * doesn't allow comparison.
0:          */
0:         if (receiver.getTypeId().getSQLTypeName().equals("CLOB")) {
0:             return this;
0:         }
0: 		/* No need to consider transformation if we
0: 		 * already did transformation that added =
0: 		 * at bind time.
0: 		 */
0: 		if (addedEquals)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* This is where we do the transformation for LIKE to make it optimizable.
0: 		 * c1 LIKE 'asdf%' -> c1 LIKE 'asdf%' AND c1 >= 'asdf' AND c1 < 'asdg'
0: 		 * c1 LIKE ? -> c1 LIKE ? and c1 >= ?', where ?' gets calculated at the
0: 		 * beginning of execution.
0: 		 */
0: 		if (!(leftOperand instanceof CharConstantNode) &&
0: 			!(leftOperand.isParameterNode()))
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* This transformation is only worth doing if it is pushable, ie, if
0: 		 * the receiver is a ColumnReference.
0: 		 */
0: 		if (!(receiver instanceof ColumnReference))
0: 		{
0: 			//
0: 			// We also do an early return here if in bindExpression we found we had
0: 			// a National Char and put a CAST above the receiver.
0: 			//
0: 			return this;
0: 		}
0: 
0: 
0: 		// Build String constants if right side is a constant
0: 		if (leftOperand instanceof CharConstantNode)
0: 		{
0: 			pattern = ((CharConstantNode) leftOperand).getString();
0: 
0: 			if (! Like.isOptimizable(pattern))
0: 			{
0: 				return this;
0: 			}
0: 
0: 			greaterEqualString = Like.greaterEqualString(pattern, escape);
0: 
0: 
0: 
0: 			/* We do not generate the < and we cannot drop the LIKE
0: 			 * when doing LIKE on a national char column.
0: 			 */
0:             if ( ! receiver.getTypeId().isNationalStringTypeId() )
0: 			{
0: 				lessThanString = Like.lessThanString(greaterEqualString);
0: 				eliminateLikeComparison = ! Like.isLikeComparisonNeeded(pattern);
0: 			}
0: 		}
0: 
0: 		//System.out.println(receiver.getTypeServices());
0: 		//System.out.println("MAX WIDTH " + receiver.getTypeServices().getMaximumWidth());
0: 
0: 		/* For some unknown reason we need to clone the receiver if it is
0: 		 * a ColumnReference because reusing them in Qualifiers for a scan
0: 		 * does not work.  
0: 		 */
0: 
0: 		/* The transformed tree has to be normalized.  Either:
0: 		 *			AND									AND
0: 		 *		   /   \							   /   \
0: 		 *	     LIKE   AND				OR:			 LIKE	AND
0: 		 *			   /   \							   /   \
0: 		 *			  >=    AND							  >=    TRUE
0: 		 *				   /   \
0: 		 *				  <     TRUE
0: 		 * unless the like string is of the form CONSTANT%, in which
0: 		 * case we can do away with the LIKE altogether:
0: 		 *			AND									AND
0: 		 *		   /   \							   /   \
0: 		 *	     >=     AND				OR:			 >=  	TRUE
0: 		 *			   /   \
0: 		 *			  <    TRUE
0: 		 */
0: 
0: 		AndNode	  newAnd = null;
0:         ValueNode trueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.TRUE,
0: 											getContextManager());
0: 
0: 		/* Create the AND <, if lessThanString is non-null  or 
0: 		 * leftOperand is a parameter.
0: 		   Currently for a national string we do not add a < than operator
0: 		   since we don't know (?) how to calculate such a string.
0: 		 */
0: 		if ( lessThanString != null || ( leftOperand.isParameterNode() &&
0:                                          ! receiver.getTypeId().isNationalStringTypeId() ))
0: 		{
0: 			QueryTreeNode likeLTopt;
0: 			if (leftOperand.isParameterNode())
0: 			{
0: 				likeLTopt = setupOptimizeStringFromParameter(leftOperand, rightOperand,
0: 								"lessThanStringFromParameter");
0: 			}
0: 			else
0: 			{
0: 				likeLTopt = getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												lessThanString,
0: 												getContextManager());
0: 			}
0: 
0: 			BinaryComparisonOperatorNode lessThan = 
0: 					(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 							C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE,
0: 							receiver.getClone(), 
0: 							likeLTopt,
0: 							getContextManager());
0: 
0: 			// Disable comparability checks
0: 			lessThan.setForQueryRewrite(true);
0: 			/* Set type info for the operator node */
0: 			lessThan.bindComparisonOperator();
0: 
0: 			// Use between selectivity for the <
0: 			lessThan.setBetweenSelectivity();
0: 
0: 			/* Create the AND */
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													lessThan,
0: 													trueNode,
0: 													getContextManager());
0: 			newAnd.postBindFixup();
0: 		}
0: 
0: 		/* Create the AND >=.  Right side could
0: 		 * be a CharConstantNode or a ParameterNode.
0: 		 */
0: 
0: 		ValueNode likeGEopt;
0: 		if (leftOperand.isParameterNode()) {
0: 
0: 			// Create an expression off the parameter
0: 			// new SQLChar(Like.greaterEqualString(?));
0: 
0: 			likeGEopt = setupOptimizeStringFromParameter(leftOperand, rightOperand,
0: 									"greaterEqualStringFromParameter");
0: 
0: 		} else {
0: 
0: 
0: 
0: 			likeGEopt = (ValueNode) getNodeFactory().getNode(C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												greaterEqualString,
0: 												getContextManager());
0: 		}
0: 
0: 		BinaryComparisonOperatorNode greaterEqual = 
0: 				(BinaryComparisonOperatorNode) getNodeFactory().getNode(
0: 						C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE,
0: 						receiver.getClone(), 
0: 						likeGEopt,
0: 						getContextManager());
0: 
0: 
0: 		// Disable comparability checks
0: 		greaterEqual.setForQueryRewrite(true);
0: 		/* Set type info for the operator node */
0: 		greaterEqual.bindComparisonOperator();
0: 
0: 		// Use between selectivity for the >=
0: 		greaterEqual.setBetweenSelectivity();
0: 
0: 		/* Create the AND */
0: 		if (newAnd == null)
0: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													greaterEqual,
0: 													trueNode,
0: 													getContextManager());
0: 		}
0: 		else
0: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													greaterEqual,
0: 													newAnd,
0: 													getContextManager());
0: 		}
0: 		newAnd.postBindFixup();
0: 
0: 		/* Finally, we put a AND LIKE on top of the left deep tree, but
0: 		 * only if it is still necessary.
0: 	     */
0: 		if (! eliminateLikeComparison)
0: 		{
0: 			newAnd = (AndNode) getNodeFactory().getNode(
0: 													C_NodeTypes.AND_NODE,
0: 													this,
0: 													newAnd,
0: 													getContextManager());
0: 			newAnd.postBindFixup();
0: 		}
0: 
0: 		/* Mark this node as transformed so that we don't get
0: 		 * calculated into the selectivity mulitple times.
0: 		 */
0: 		setTransformed();
0: 
0: 		return newAnd;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this binary operator.
0: 	 *
0: 	 *		This code was copied from BinaryOperatorNode and stripped down
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the code to place the code
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 
0: /*
0: ** if i have a operator.getOrderableType() == constant, then just cache 
0: ** it in a field.  if i have QUERY_INVARIANT, then it would be good to
0: ** cache it in something that is initialized each execution,
0: ** but how?
0: */
0: 
0: 		/*
0: 		** let the receiver type be determined by an
0: 		** overridable method so that if methods are
0: 		** not implemented on the lowest interface of
0: 		** a class, they can note that in the implementation
0: 		** of the node that uses the method.
0: 		*/
0: 		// receiverType = getReceiverInterfaceName();
0: 
0: 		/*
0: 		** Generate LHS (field = <receiver operand>). This assignment is
0: 		** used as the receiver of the method call for this operator.
0: 		**
0: 		**	(<receiver operand>).method(<left operand>,
0: 		**                      <right operand>, [<escaperightOp>,]
0: 		**						<result field>)
0: 		*/
0: 
0: 		receiver.generateExpression(acb, mb);	// first arg
0: 
0: 		receiverInterfaceType = receiver.getTypeCompiler().interfaceName();
0: 
0: 		mb.upCast(receiverInterfaceType); 		// cast the method instance
0: 
0: 		leftOperand.generateExpression(acb, mb);
0: 		mb.upCast(leftInterfaceType); 			// first arg with cast
0: 
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand.generateExpression(acb, mb);
0: 			mb.upCast(rightInterfaceType); 		// second arg with cast
0: 		}
0: 
0: 		/* Figure out the result type name */
0: 		// resultTypeName = getTypeCompiler().interfaceName();
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 			methodName, resultInterfaceType,
0: 			rightOperand == null ? 1 : 2);
0: 	}
0: 
0: 	private ValueNode setupOptimizeStringFromParameter(ValueNode parameterNode,
0: 						ValueNode escapeNode,String methodName)
0: 		throws StandardException {
0: 
0: 		Vector param;
0: 
0: 		if (escapeNode != null)
0: 		{
0: 			param = new Vector(2);
0: 			methodName += "WithEsc";
0: 		}
0: 		else param = new Vector(1);
0: 
0: 		StaticMethodCallNode methodCall = (StaticMethodCallNode)
0: 						getNodeFactory().getNode(C_NodeTypes.STATIC_METHOD_CALL_NODE,
0: 											methodName,
0: 											"org.apache.derby.iapi.types.Like",
0: 											getContextManager());
0: 
0: 		// using a method call directly, thus need internal sql capability
0: 		methodCall.internalCall = true;
0: 
0: 		param.addElement(parameterNode);
0: 		if (escapeNode != null)
0: 			param.addElement(escapeNode);
0: 
0: 		methodCall.addParms(param);
0: 
0: 
0: 		ValueNode java2SQL = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									methodCall,
0: 									getContextManager());
0: 
0: 
0: 		java2SQL = (ValueNode) java2SQL.bindExpression(null, null, null);
0: 
0: 		CastNode likeOpt = (CastNode)
0: 			getNodeFactory().getNode(
0: 				C_NodeTypes.CAST_NODE,
0: 				java2SQL,
0: 				parameterNode.getTypeServices(),
0: 				getContextManager());
0: 
0: 		likeOpt.bindCastNodeOnly();
0: 
0: 		return likeOpt;
0: 	}
0: }
============================================================================