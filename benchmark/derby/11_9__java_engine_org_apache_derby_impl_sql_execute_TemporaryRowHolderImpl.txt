1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.TemporaryRowHolderImpl
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:81b9853: import org.apache.derby.iapi.sql.Activation;
1:c69c8b0: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.SQLRef;
1:eac0369: import org.apache.derby.iapi.types.SQLLongint;
1:eac0369: 
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This is a class that is used to temporarily
1:eac0369:  * (non-persistently) hold rows that are used in
1:eac0369:  * language execution.  It will store them in an
1:eac0369:  * array, or a temporary conglomerate, depending
1:eac0369:  * on the number of rows.  
1:eac0369:  * <p>
1:eac0369:  * It is used for deferred DML processing.
1:eac0369:  *
1:eac0369:  */
1:81b9853: class TemporaryRowHolderImpl implements TemporaryRowHolder
1:eac0369: {
1:eac0369: 	public static final int DEFAULT_OVERFLOWTHRESHOLD = 5;
1:eac0369: 
1:eac0369: 	protected static final int STATE_UNINIT = 0;
1:eac0369: 	protected static final int STATE_INSERT = 1;
1:eac0369: 	protected static final int STATE_DRAIN = 2;
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected ExecRow[] 	rowArray;
1:eac0369: 	protected int 		lastArraySlot;
1:eac0369: 	private int			numRowsIn;
1:eac0369: 	protected int		state = STATE_UNINIT;
1:eac0369: 
1:2a31ed9: 	private	long				    CID;
1:eac0369: 	private boolean					conglomCreated;
1:eac0369: 	private ConglomerateController	cc;
1:eac0369: 	private Properties				properties;
1:eac0369: 	private ScanController			scan;
1:c69c8b0: 	private	ResultDescription		resultDescription;
1:81b9853: 	/** Activation object with local state information. */
1:81b9853: 	Activation						activation;
1:88bb146: 
1:eac0369: 	private boolean     isUniqueStream;
1:eac0369: 
1:eac0369: 	/* beetle 3865 updateable cursor use index. A virtual memory heap is a heap that has in-memory
1:eac0369: 	 * part to get better performance, less overhead. No position index needed. We read from and write
1:eac0369: 	 * to the in-memory part as much as possible. And we can insert after we start retrieving results.
1:eac0369: 	 * Could be used for other things too.
1:eac0369: 	 */
1:eac0369: 	private boolean     isVirtualMemHeap;
1:eac0369: 	private boolean     uniqueIndexCreated;
1:eac0369: 	private boolean     positionIndexCreated;
1:eac0369: 	private long        uniqueIndexConglomId;
1:eac0369: 	private long        positionIndexConglomId;
1:eac0369: 	private ConglomerateController uniqueIndex_cc;
1:eac0369: 	private ConglomerateController positionIndex_cc;
1:eac0369: 	private DataValueDescriptor[]  uniqueIndexRow = null;
1:eac0369: 	private DataValueDescriptor[]  positionIndexRow = null;
1:eac0369: 	private RowLocation            destRowLocation; //row location in the temporary conglomerate
1:eac0369: 	private SQLLongint             position_sqllong;
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Uses the default overflow to
1:eac0369:  	 * a conglomerate threshold (5).
1:eac0369: 	 *
1:81b9853: 	 * @param activation the activation
1:eac0369: 	 * @param properties the properties of the original table.  Used
1:eac0369: 	 *		to help the store use optimal page size, etc.
1:c69c8b0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1:c69c8b0: 	 * 		call on the result set returned by getResultSet.  May be null
1:eac0369: 	 */
1:c69c8b0: 	public TemporaryRowHolderImpl
1:eac0369: 	(
1:81b9853: 		Activation				activation, 
1:c69c8b0: 		Properties 				properties, 
1:c69c8b0: 		ResultDescription		resultDescription
1:eac0369: 	) 
1:eac0369: 	{
1:c69c8b0: 		this(activation, properties, resultDescription,
1:81b9853: 			 DEFAULT_OVERFLOWTHRESHOLD, false, false);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Uses the default overflow to
1:eac0369:  	 * a conglomerate threshold (5).
1:eac0369: 	 *
1:81b9853: 	 * @param activation the activation
1:eac0369: 	 * @param properties the properties of the original table.  Used
1:eac0369: 	 *		to help the store use optimal page size, etc.
1:c69c8b0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1:c69c8b0: 	 * 		call on the result set returned by getResultSet.  May be null
1:eac0369: 	 * @param isUniqueStream - true , if it has to be temporary row holder unique stream
1:eac0369: 	 */
1:c69c8b0: 	public TemporaryRowHolderImpl
1:eac0369: 	(
1:81b9853: 		Activation				activation, 
2:eac0369: 		Properties 				properties, 
1:c69c8b0: 		ResultDescription		resultDescription,
1:eac0369: 		boolean                 isUniqueStream
1:eac0369: 	) 
1:eac0369: 	{
1:c69c8b0: 		this(activation, properties, resultDescription, 1, isUniqueStream,
1:81b9853: 			 false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a temporary row holder with the defined overflow to conglom
1:eac0369: 	 *
1:81b9853: 	 * @param activation the activation
1:eac0369: 	 * @param properties the properties of the original table.  Used
1:eac0369: 	 *		to help the store use optimal page size, etc.
1:c69c8b0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1:c69c8b0: 	 * 		call on the result set returned by getResultSet.  May be null
1:6b50965: 	 * @param overflowToConglomThreshold on an attempt to insert
1:eac0369: 	 * 		this number of rows, the rows will be put
1:eac0369:  	 *		into a temporary conglomerate.
1:eac0369: 	 */
1:c69c8b0: 	public TemporaryRowHolderImpl
1:eac0369: 	(
1:81b9853: 		Activation			 	activation, 
1:eac0369: 		Properties				properties,
1:c69c8b0: 		ResultDescription		resultDescription,
1:eac0369: 		int 					overflowToConglomThreshold,
1:eac0369: 		boolean                 isUniqueStream,
1:eac0369: 		boolean					isVirtualMemHeap
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (overflowToConglomThreshold <= 0)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("It is assumed that "+
1:eac0369: 					"the overflow threshold is > 0.  "+
1:eac0369: 					"If you you need to change this you have to recode some of "+
1:eac0369: 					"this class.");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:81b9853: 		this.activation = activation;
1:eac0369: 		this.properties = properties;
1:c69c8b0: 		this.resultDescription = resultDescription;
1:eac0369: 		this.isUniqueStream = isUniqueStream;
1:eac0369: 		this.isVirtualMemHeap = isVirtualMemHeap;
1:eac0369: 		rowArray = new ExecRow[overflowToConglomThreshold];
2:eac0369: 		lastArraySlot = -1;
1:eac0369: 	}
1:eac0369: 
1:d7aa761:     /* Avoid materializing a stream just because it goes through a temp table.
1:d7aa761:      * It is OK to have a stream in the temp table (in memory or spilled to
1:d7aa761:      * disk). The assumption is that one stream does not appear in two rows.
1:d7aa761:      * For "update", one stream can be in two rows and the materialization is
1:d7aa761:      * done in UpdateResultSet. Note to future users of this class who may
1:d7aa761:      * insert a stream into this temp holder:
1:d7aa761:      *   (1) As mentioned above, one un-materialized stream can't appear in two
1:d7aa761:      *       rows; you need to objectify it first otherwise.
1:d7aa761:      *   (2) If you need to retrieve an un-materialized stream more than once
1:d7aa761:      *       from the temp holder, you need to either materialize the stream
1:d7aa761:      *       the first time, or, if there's a memory constraint, in the first
1:d7aa761:      *       time create a RememberBytesInputStream with the byte holder being
1:d7aa761:      *       BackingStoreByteHolder, finish it, and reset it after usage.
1:d7aa761:      *       A third option is to create a stream clone, but this requires that
1:d7aa761:      *       the container handles are kept open until the streams have been
1:d7aa761:      *       drained.
1:d7aa761:      *
1:d7aa761:      * Beetle 4896.
1:d7aa761:      */
1:eac0369: 	private ExecRow cloneRow(ExecRow inputRow)
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] cols = inputRow.getRowArray();
1:eac0369: 		int ncols = cols.length;
1:eac0369: 		ExecRow cloned = ((ValueRow) inputRow).cloneMe();
1:eac0369: 		for (int i = 0; i < ncols; i++)
1:eac0369: 		{
1:eac0369: 			if (cols[i] != null)
1:eac0369: 			{
1:eac0369: 				/* Rows are 1-based, cols[] is 0-based */
1:d7aa761:                 cloned.setColumn(i + 1, cols[i].cloneHolder());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (inputRow instanceof IndexValueRow)
1:eac0369: 			return new IndexValueRow(cloned);
1:eac0369: 		else
1:eac0369: 			return cloned;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Insert a row
1:eac0369: 	 *
1:6b50965: 	 * @param inputRow the row to insert 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369:  	 */
1:eac0369: 	public void insert(ExecRow inputRow)
1:92268ac: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if(!isUniqueStream && !isVirtualMemHeap)
1:eac0369: 				SanityManager.ASSERT(state != STATE_DRAIN, "you cannot insert rows after starting to drain");
1:eac0369: 		}
1:eac0369: 		if (! isVirtualMemHeap)
1:eac0369: 			state = STATE_INSERT;
1:eac0369: 
1:eac0369: 		if(uniqueIndexCreated)
1:eac0369: 		{
1:eac0369: 			if(isRowAlreadyExist(inputRow))
1:eac0369: 				return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		numRowsIn++;
1:eac0369: 
1:eac0369: 		if (lastArraySlot + 1 < rowArray.length)
1:eac0369: 		{
1:eac0369: 			rowArray[++lastArraySlot] = cloneRow(inputRow);
1:eac0369: 			
1:eac0369: 			//In case of unique stream we push every thing into the
1:eac0369: 			// conglomerates for time being, we keep one row in the array for
1:eac0369: 			// the template.
1:2a31ed9:             if (!isUniqueStream) {
1:eac0369: 				return;  
1:2a31ed9:             }
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		if (!conglomCreated)
1:eac0369: 		{
1:81b9853: 			TransactionController tc = activation.getTransactionController();
1:81b9853: 
1:b61f876:             // TODO-COLLATE, I think collation needs to get set always correctly
1:b61f876:             // but did see what to get collate id when there was no result
1:b61f876:             // description.  The problem comes if row holder is used to stream
1:b61f876:             // row to temp disk, then row is read from disk using an interface
1:b61f876:             // where store creates the DataValueDescriptor template itself, 
1:b61f876:             // and subsquently the returned column is used for some sort of
1:b61f876:             // comparison.  Also could be a problem is reader of tempoary 
1:b61f876:             // table uses qualifiers, that would result in comparisons internal
1:b61f876:             // to store.  I believe the below impl is incomplete - either
1:b61f876:             // it should always be default, or real collate_ids should be 
1:b61f876:             // passed in.
1:eac0369: 
1:b61f876:             // null collate_ids in createConglomerate call indicates to use all
1:b61f876:             // default collate ids.
1:b61f876:             int collation_ids[] = null;
1:eac0369: 
1:eac0369:             /*
1:b61f876:             TODO-COLLATE - if we could count on resultDescription I think the
1:b61f876:             following would work.
2:b61f876: 
1:b61f876:             if (resultDescription != null)
1:eac0369:             {
1:b61f876:                 // init collation id info from resultDescription for create call
1:b61f876:                 collation_ids = new int[resultDescription.getColumnCount()];
1:b61f876: 
1:b61f876:                 for (int i = 0; i < collation_ids.length; i++)
2:b61f876:                 {
1:b61f876:                     collation_ids[i] = 
1:b61f876:                         resultDescription.getColumnDescriptor(
1:b61f876:                             i + 1).getType().getCollationType();
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             */
1:b61f876: 
1:b61f876: 
1:eac0369: 			/*
1:eac0369: 			** Create the conglomerate with the template row.
1:eac0369: 			*/
1:b61f876: 			CID = 
1:b61f876:                 tc.createConglomerate(
1:b61f876:                     "heap",
1:eac0369:                     inputRow.getRowArray(),
1:eac0369:                     null, //column sort order - not required for heap
1:b61f876:                     collation_ids,
1:eac0369:                     properties,
3:eac0369:                     TransactionController.IS_TEMPORARY | 
3:eac0369:                     TransactionController.IS_KEPT);
1:b61f876: 
1:eac0369: 			conglomCreated = true;
1:eac0369: 
1:eac0369: 			cc = tc.openConglomerate(CID, 
1:eac0369:                                 false,
1:eac0369:                                 TransactionController.OPENMODE_FORUPDATE,
1:eac0369:                                 TransactionController.MODE_TABLE,
1:eac0369:                                 TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 			if(isUniqueStream)
1:eac0369: 			   destRowLocation = cc.newRowLocationTemplate();
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int status = 0;
1:eac0369: 		if(isUniqueStream)
1:eac0369: 		{
1:eac0369: 			cc.insertAndFetchLocation(inputRow.getRowArray(), destRowLocation);
1:eac0369: 			insertToPositionIndex(numRowsIn -1, destRowLocation);
1:eac0369: 			//create the unique index based on input row ROW Location
1:eac0369: 			if(!uniqueIndexCreated)
1:eac0369: 				isRowAlreadyExist(inputRow);
1:eac0369: 
1:eac0369: 		}else
1:eac0369: 		{
1:0c5bc3a:             status = cc.insert(inputRow.getRowArray());
1:eac0369: 			if (isVirtualMemHeap)
1:eac0369: 				state = STATE_INSERT;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (status != 0)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("got funky status ("+status+") back from "+
1:eac0369: 						"ConglomerateConstroller.insert()");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Maintain an unique index based on the input row's row location in the
1:eac0369: 	 * base table, this index make sures that we don't insert duplicate rows 
1:eac0369: 	 * into the temporary heap.
1:eac0369: 	 * @param inputRow  the row we are inserting to temporary row holder 
1:eac0369: 	 * @exception StandardException on error
1:eac0369:  	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	private boolean isRowAlreadyExist(ExecRow inputRow) throws  StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor		rlColumn;
1:eac0369: 		RowLocation	baseRowLocation;
1:eac0369: 		rlColumn = inputRow.getColumn(inputRow.nColumns());
1:eac0369: 
1:eac0369: 		if(CID!=0 && rlColumn instanceof SQLRef)
1:eac0369: 		{
1:eac0369: 			baseRowLocation = 
1:eac0369: 				(RowLocation) (rlColumn).getObject();
1:eac0369: 		
1:eac0369: 			if(!uniqueIndexCreated)
1:eac0369: 			{
1:81b9853: 				TransactionController tc =
1:81b9853: 					activation.getTransactionController();
1:eac0369: 				int numKeys = 2;
1:eac0369: 				uniqueIndexRow = new DataValueDescriptor[numKeys];
1:eac0369: 				uniqueIndexRow[0] = baseRowLocation;
1:eac0369: 				uniqueIndexRow[1] = baseRowLocation;
1:eac0369: 				Properties props = makeIndexProperties(uniqueIndexRow, CID);
1:eac0369: 				uniqueIndexConglomId =
1:b61f876: 					tc.createConglomerate(
1:b61f876:                         "BTREE",
1:b61f876:                         uniqueIndexRow, 
1:b61f876:                         null,  
1:b61f876:                         null, // no collation needed for index on row locations.
1:b61f876:                         props, 
1:b61f876:                         (TransactionController.IS_TEMPORARY | 
1:b61f876:                          TransactionController.IS_KEPT));
1:b61f876: 
1:eac0369: 				uniqueIndex_cc = tc.openConglomerate(
1:eac0369: 								uniqueIndexConglomId, 
1:eac0369: 								false,
1:eac0369: 								TransactionController.OPENMODE_FORUPDATE,
1:eac0369: 								TransactionController.MODE_TABLE,
1:eac0369: 								TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 				uniqueIndexCreated = true;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			uniqueIndexRow[0] = baseRowLocation;
1:eac0369: 			uniqueIndexRow[1] = baseRowLocation;
1:eac0369: 			// Insert the row into the secondary index.
1:eac0369: 			int status;
1:0c5bc3a:             if ((status = uniqueIndex_cc.insert(uniqueIndexRow))!= 0)
1:eac0369: 			{
1:eac0369: 				if(status == ConglomerateController.ROWISDUPLICATE)
1:eac0369: 				{
1:eac0369: 					return true ; // okay; we don't insert duplicates
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						if (status != 0)
1:eac0369: 						{
1:eac0369: 							SanityManager.THROWASSERT("got funky status ("+status+") back from "+
1:eac0369: 													  "Unique Index insert()");
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Maintain an index that will allow us to read  from the 
1:eac0369: 	 * temporary heap in the order we inserted.
1:eac0369: 	 * @param position - the number of the row we are inserting into heap
1:eac0369: 	 * @param rl the row to Location in the temporary heap 
1:eac0369: 	 * @exception StandardException on error
1:eac0369:  	 */
1:eac0369: 
1:eac0369: 	private void insertToPositionIndex(int position, RowLocation rl ) throws  StandardException
1:eac0369: 	{
1:eac0369: 		if(!positionIndexCreated)
1:eac0369: 		{
1:81b9853: 			TransactionController tc = activation.getTransactionController();
1:eac0369: 			int numKeys = 2;
1:eac0369: 			position_sqllong = new SQLLongint();
1:eac0369: 			positionIndexRow = new DataValueDescriptor[numKeys];
1:eac0369: 			positionIndexRow[0] = position_sqllong;
1:eac0369: 			positionIndexRow[1] = rl;				
1:eac0369: 			Properties props = makeIndexProperties(positionIndexRow, CID);
1:eac0369: 			positionIndexConglomId =
1:b61f876:                 tc.createConglomerate(
1:b61f876:                     "BTREE",
1:b61f876:                     positionIndexRow, 
1:b61f876:                     null,  
1:b61f876:                     null, // no collation needed for index on row locations.
1:b61f876:                     props, 
1:b61f876:                     (TransactionController.IS_TEMPORARY | 
1:b61f876:                      TransactionController.IS_KEPT));
1:eac0369: 
1:b61f876: 			positionIndex_cc = 
1:b61f876:                 tc.openConglomerate(
1:eac0369:                     positionIndexConglomId, 
1:eac0369:                     false,
1:eac0369:                     TransactionController.OPENMODE_FORUPDATE,
1:eac0369:                     TransactionController.MODE_TABLE,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 
1:eac0369: 			positionIndexCreated = true;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		position_sqllong.setValue(position);
1:eac0369: 		positionIndexRow[0] = position_sqllong;
1:eac0369: 		positionIndexRow[1] = rl;
1:eac0369: 		//insert the row location to position index
1:0c5bc3a:         positionIndex_cc.insert(positionIndexRow);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a result set for scanning what has been inserted
1:eac0369:  	 * so far.
1:eac0369: 	 *
1:eac0369: 	 * @return a result set to use
1:eac0369: 	 */
1:eac0369: 	public CursorResultSet getResultSet()
1:eac0369: 	{
1:eac0369: 		state = STATE_DRAIN;
1:81b9853: 		TransactionController tc = activation.getTransactionController();
1:eac0369: 		if(isUniqueStream)
1:eac0369: 		{
1:eac0369: 			return new TemporaryRowHolderResultSet(tc, rowArray,
1:c69c8b0: 												   resultDescription, isVirtualMemHeap,
1:eac0369: 												   true, positionIndexConglomId, this);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:c69c8b0: 			return new TemporaryRowHolderResultSet(tc, rowArray, resultDescription, isVirtualMemHeap, this);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Purge the row holder of all its rows.
1:eac0369: 	 * Resets the row holder so that it can
1:eac0369: 	 * accept new inserts.  A cheap way to
1:eac0369: 	 * recycle a row holder.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void truncate() throws StandardException
1:eac0369: 	{
1:eac0369: 		close();
1:2a31ed9:         if (SanityManager.DEBUG) {
1:2a31ed9:             SanityManager.ASSERT(lastArraySlot == -1);
1:2a31ed9:             SanityManager.ASSERT(state == STATE_UNINIT);
1:2a31ed9:             SanityManager.ASSERT(!conglomCreated);
1:2a31ed9:             SanityManager.ASSERT(CID == 0);
1:2a31ed9:         }
1:eac0369: 		for (int i = 0; i < rowArray.length; i++)
1:eac0369: 		{
1:eac0369: 			rowArray[i] = null;
1:eac0369: 		}
1:eac0369: 
1:2a31ed9: 		numRowsIn = 0;
1:eac0369: 	}
1:eac0369: 
1:2a31ed9:     /**
1:2a31ed9:      * Accessor to get the id of the temporary conglomerate. Temporary 
1:2a31ed9:      * conglomerates have negative ids. An id equal to zero means that no 
1:2a31ed9:      * temporary conglomerate has been created.
1:2a31ed9:      * @return Conglomerate ID of temporary conglomerate
1:2a31ed9:      */
1:eac0369: 	public long getTemporaryConglomId()
1:eac0369: 	{
1:2a31ed9:         if (SanityManager.DEBUG) {
1:2a31ed9:             SanityManager.ASSERT(CID == 0 && !conglomCreated || 
1:2a31ed9:                     CID < 0 && conglomCreated);
1:2a31ed9:         }
1:eac0369: 		return CID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public long getPositionIndexConglomId()
1:eac0369: 	{
1:eac0369: 		return positionIndexConglomId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	private Properties makeIndexProperties(DataValueDescriptor[]
1:eac0369: 											   indexRowArray, long conglomId ) throws StandardException {
1:eac0369: 		int nCols = indexRowArray.length;
1:eac0369: 		Properties props = new Properties();
1:eac0369: 		props.put("allowDuplicates", "false");
1:eac0369: 		// all columns form the key, (currently) required
1:eac0369: 		props.put("nKeyFields", String.valueOf(nCols));
1:eac0369: 		props.put("nUniqueColumns", String.valueOf(nCols-1));
1:eac0369: 		props.put("rowLocationColumn", String.valueOf(nCols-1));
1:eac0369: 		props.put("baseConglomerateId", String.valueOf(conglomId));
1:eac0369: 		return props;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setRowHolderTypeToUniqueStream()
1:eac0369: 	{
1:eac0369: 		isUniqueStream = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clean up
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void close() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			scan.close();
1:eac0369: 			scan = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (cc != null)
1:eac0369: 		{
1:eac0369: 			cc.close();
1:eac0369: 			cc = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (uniqueIndex_cc != null)
1:eac0369: 		{
1:eac0369: 			uniqueIndex_cc.close();
1:eac0369: 			uniqueIndex_cc = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (positionIndex_cc != null)
1:eac0369: 		{
1:eac0369: 			positionIndex_cc.close();
1:eac0369: 			positionIndex_cc = null;
1:eac0369: 		}
1:81b9853: 
1:81b9853: 		TransactionController tc = activation.getTransactionController();
1:eac0369: 
1:eac0369: 		if (uniqueIndexCreated)
1:eac0369: 		{
1:eac0369: 			tc.dropConglomerate(uniqueIndexConglomId);
2:eac0369: 			uniqueIndexCreated = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (positionIndexCreated)
1:eac0369: 		{
1:eac0369: 			tc.dropConglomerate(positionIndexConglomId);
1:2ee9046: 			positionIndexCreated = false;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		if (conglomCreated)
1:eac0369: 		{
2:eac0369: 			tc.dropConglomerate(CID);
2:eac0369: 			conglomCreated = false;
1:2a31ed9:             CID = 0;
1:2a31ed9: 		} 
1:2a31ed9:         else 
1:2a31ed9:         {
1:2a31ed9:             if (SanityManager.DEBUG) {
1:2a31ed9:                 SanityManager.ASSERT(CID == 0, "CID(" + CID + ")==0");
1:2a31ed9:             }
1:2a31ed9:         }
2:eac0369: 		state = STATE_UNINIT;
1:eac0369: 		lastArraySlot = -1;
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:             status = cc.insert(inputRow.getRowArray());
/////////////////////////////////////////////////////////////////////////
1:             if ((status = uniqueIndex_cc.insert(uniqueIndexRow))!= 0)
/////////////////////////////////////////////////////////////////////////
1:         positionIndex_cc.insert(positionIndexRow);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	private	ResultDescription		resultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1: 	 * 		call on the result set returned by getResultSet.  May be null
1: 	public TemporaryRowHolderImpl
1: 		Properties 				properties, 
1: 		ResultDescription		resultDescription
1: 		this(activation, properties, resultDescription,
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1: 	 * 		call on the result set returned by getResultSet.  May be null
1: 	public TemporaryRowHolderImpl
1: 		ResultDescription		resultDescription,
1: 		this(activation, properties, resultDescription, 1, isUniqueStream,
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1: 	 * 		call on the result set returned by getResultSet.  May be null
1: 	public TemporaryRowHolderImpl
1: 		ResultDescription		resultDescription,
/////////////////////////////////////////////////////////////////////////
1: 		this.resultDescription = resultDescription;
/////////////////////////////////////////////////////////////////////////
1: 												   resultDescription, isVirtualMemHeap,
1: 			return new TemporaryRowHolderResultSet(tc, rowArray, resultDescription, isVirtualMemHeap, this);
commit:2ee9046
/////////////////////////////////////////////////////////////////////////
1: 			positionIndexCreated = false;
commit:81b9853
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
1: class TemporaryRowHolderImpl implements TemporaryRowHolder
/////////////////////////////////////////////////////////////////////////
1: 	/** Activation object with local state information. */
1: 	Activation						activation;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param activation the activation
/////////////////////////////////////////////////////////////////////////
1: 		Activation				activation, 
0: 		this(activation, properties, resultDescription,
1: 			 DEFAULT_OVERFLOWTHRESHOLD, false, false);
1: 	 * @param activation the activation
/////////////////////////////////////////////////////////////////////////
1: 		Activation				activation, 
0: 		this(activation, properties, resultDescription, 1, isUniqueStream,
1: 			 false);
1: 	 * @param activation the activation
/////////////////////////////////////////////////////////////////////////
1: 		Activation			 	activation, 
/////////////////////////////////////////////////////////////////////////
1: 		this.activation = activation;
/////////////////////////////////////////////////////////////////////////
1: 			TransactionController tc = activation.getTransactionController();
1: 
/////////////////////////////////////////////////////////////////////////
1: 				TransactionController tc =
1: 					activation.getTransactionController();
/////////////////////////////////////////////////////////////////////////
1: 			TransactionController tc = activation.getTransactionController();
/////////////////////////////////////////////////////////////////////////
1: 		TransactionController tc = activation.getTransactionController();
/////////////////////////////////////////////////////////////////////////
1: 			TransactionController tc = activation.getTransactionController();
/////////////////////////////////////////////////////////////////////////
0: 		TransactionController tc = activation.getTransactionController();
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d7aa761
/////////////////////////////////////////////////////////////////////////
1:     /* Avoid materializing a stream just because it goes through a temp table.
1:      * It is OK to have a stream in the temp table (in memory or spilled to
1:      * disk). The assumption is that one stream does not appear in two rows.
1:      * For "update", one stream can be in two rows and the materialization is
1:      * done in UpdateResultSet. Note to future users of this class who may
1:      * insert a stream into this temp holder:
1:      *   (1) As mentioned above, one un-materialized stream can't appear in two
1:      *       rows; you need to objectify it first otherwise.
1:      *   (2) If you need to retrieve an un-materialized stream more than once
1:      *       from the temp holder, you need to either materialize the stream
1:      *       the first time, or, if there's a memory constraint, in the first
1:      *       time create a RememberBytesInputStream with the byte holder being
1:      *       BackingStoreByteHolder, finish it, and reset it after usage.
1:      *       A third option is to create a stream clone, but this requires that
1:      *       the container handles are kept open until the streams have been
1:      *       drained.
1:      *
1:      * Beetle 4896.
1:      */
/////////////////////////////////////////////////////////////////////////
1:                 cloned.setColumn(i + 1, cols[i].cloneHolder());
commit:b4e2eb7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 cloned.setColumn(i + 1, cols[i].cloneObject());
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:2a31ed9
/////////////////////////////////////////////////////////////////////////
1: 	private	long				    CID;
/////////////////////////////////////////////////////////////////////////
1:             if (!isUniqueStream) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(lastArraySlot == -1);
1:             SanityManager.ASSERT(state == STATE_UNINIT);
1:             SanityManager.ASSERT(!conglomCreated);
1:             SanityManager.ASSERT(CID == 0);
1:         }
1: 		numRowsIn = 0;
1:     /**
1:      * Accessor to get the id of the temporary conglomerate. Temporary 
1:      * conglomerates have negative ids. An id equal to zero means that no 
1:      * temporary conglomerate has been created.
1:      * @return Conglomerate ID of temporary conglomerate
1:      */
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(CID == 0 && !conglomCreated || 
1:                     CID < 0 && conglomCreated);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             CID = 0;
1: 		} 
1:         else 
1:         {
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(CID == 0, "CID(" + CID + ")==0");
1:             }
1:         }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:88bb146
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 	TemporaryRowHolderImpl
0: 		Properties 				properties
0: 		this(activation, properties,
/////////////////////////////////////////////////////////////////////////
0: 	TemporaryRowHolderImpl
0: 		this(activation, properties, 1, isUniqueStream,
/////////////////////////////////////////////////////////////////////////
0: 	TemporaryRowHolderImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 												   isVirtualMemHeap,
0: 			return new TemporaryRowHolderResultSet(tc, rowArray, isVirtualMemHeap, this);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.TemporaryRowHolderImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.types.CloneableObject;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.SQLRef;
1: import org.apache.derby.iapi.types.SQLLongint;
1: 
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import java.util.Properties;
1: 
1: /**
1:  * This is a class that is used to temporarily
1:  * (non-persistently) hold rows that are used in
1:  * language execution.  It will store them in an
1:  * array, or a temporary conglomerate, depending
1:  * on the number of rows.  
1:  * <p>
1:  * It is used for deferred DML processing.
1:  *
0:  * @author jamie
1:  */
0: public class TemporaryRowHolderImpl implements TemporaryRowHolder
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	public static final int DEFAULT_OVERFLOWTHRESHOLD = 5;
1: 
1: 	protected static final int STATE_UNINIT = 0;
1: 	protected static final int STATE_INSERT = 1;
1: 	protected static final int STATE_DRAIN = 2;
1: 
1: 
1: 	protected ExecRow[] 	rowArray;
1: 	protected int 		lastArraySlot;
1: 	private int			numRowsIn;
1: 	protected int		state = STATE_UNINIT;
1: 
0: 	protected	long				CID;
1: 	private boolean					conglomCreated;
1: 	private ConglomerateController	cc;
1: 	private Properties				properties;
1: 	private ScanController			scan;
0: 	private TransactionController	tc;
0: 	private	ResultDescription		resultDescription;
1: 
1: 	private boolean     isUniqueStream;
1: 
1: 	/* beetle 3865 updateable cursor use index. A virtual memory heap is a heap that has in-memory
1: 	 * part to get better performance, less overhead. No position index needed. We read from and write
1: 	 * to the in-memory part as much as possible. And we can insert after we start retrieving results.
1: 	 * Could be used for other things too.
1: 	 */
1: 	private boolean     isVirtualMemHeap;
1: 	private boolean     uniqueIndexCreated;
1: 	private boolean     positionIndexCreated;
1: 	private long        uniqueIndexConglomId;
1: 	private long        positionIndexConglomId;
1: 	private ConglomerateController uniqueIndex_cc;
1: 	private ConglomerateController positionIndex_cc;
1: 	private DataValueDescriptor[]  uniqueIndexRow = null;
1: 	private DataValueDescriptor[]  positionIndexRow = null;
1: 	private RowLocation            destRowLocation; //row location in the temporary conglomerate
1: 	private SQLLongint             position_sqllong;
1: 	
1: 
1: 	/**
1: 	 * Uses the default overflow to
1:  	 * a conglomerate threshold (5).
1: 	 *
0: 	 * @param tc the xact controller
1: 	 * @param properties the properties of the original table.  Used
1: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
1: 	 */
0: 	public TemporaryRowHolderImpl
1: 	(
0: 		TransactionController	tc, 
1: 		Properties 				properties, 
0: 		ResultDescription		resultDescription
1: 	) 
1: 	{
0: 		this(tc, properties, resultDescription, DEFAULT_OVERFLOWTHRESHOLD, false, false);
1: 	}
1: 	
1: 	/**
1: 	 * Uses the default overflow to
1:  	 * a conglomerate threshold (5).
1: 	 *
0: 	 * @param tc the xact controller
1: 	 * @param properties the properties of the original table.  Used
1: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
1: 	 * @param isUniqueStream - true , if it has to be temporary row holder unique stream
1: 	 */
0: 	public TemporaryRowHolderImpl
1: 	(
0: 		TransactionController	tc, 
1: 		Properties 				properties, 
0: 		ResultDescription		resultDescription,
1: 		boolean                 isUniqueStream
1: 	) 
1: 	{
0: 		this(tc, properties, resultDescription, 1, isUniqueStream, false);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Create a temporary row holder with the defined overflow to conglom
1: 	 *
0: 	 * @param tc the xact controller
1: 	 * @param properties the properties of the original table.  Used
1: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
0: 	 * @param spillToConglomSize on an attempt to insert
1: 	 * 		this number of rows, the rows will be put
1:  	 *		into a temporary conglomerate.
1: 	 */
0: 	public TemporaryRowHolderImpl
1: 	(
0: 		TransactionController 	tc, 
1: 		Properties				properties,
0: 		ResultDescription		resultDescription,
1: 		int 					overflowToConglomThreshold,
1: 		boolean                 isUniqueStream,
1: 		boolean					isVirtualMemHeap
1: 	)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (overflowToConglomThreshold <= 0)
1: 			{
1: 				SanityManager.THROWASSERT("It is assumed that "+
1: 					"the overflow threshold is > 0.  "+
1: 					"If you you need to change this you have to recode some of "+
1: 					"this class.");
1: 			}
1: 		}
1: 
0: 		this.tc = tc;
1: 		this.properties = properties;
0: 		this.resultDescription = resultDescription;
1: 		this.isUniqueStream = isUniqueStream;
1: 		this.isVirtualMemHeap = isVirtualMemHeap;
1: 		rowArray = new ExecRow[overflowToConglomThreshold];
1: 		lastArraySlot = -1;
1: 	}
1: 
0: 	/* Avoid materializing a stream just because it goes through a temp table.  It is OK to
0: 	 * have a stream in the temp table (in memory or spilled to disk).  The assumption is
0: 	 * that one stream does not appear in two rows.  For "update", one stream can be in two
0: 	 * rows and the materialization is done in UpdateResultSet.  Note to future users of this
0: 	 * class who may insert a stream into this temp holder: (1) As mentioned above, one
0: 	 * un-materialized stream can't appear in two rows; you need to objectify it first otherwise.
0: 	 * (2) If you need to retrieve a un-materialized stream more than once from the temp holder,
0: 	 * you need to either materialize the stream the first time, or, if there's a memory constraint,
0: 	 * in the first time create a RememberBytesInputStream with the byte holder being
0: 	 * BackingStoreByteHolder, finish it, and reset it after usage.
0: 	 * beetle 4896.
1: 	 */
1: 	private ExecRow cloneRow(ExecRow inputRow)
1: 	{
1: 		DataValueDescriptor[] cols = inputRow.getRowArray();
1: 		int ncols = cols.length;
1: 		ExecRow cloned = ((ValueRow) inputRow).cloneMe();
1: 		for (int i = 0; i < ncols; i++)
1: 		{
1: 			if (cols[i] != null)
1: 			{
1: 				/* Rows are 1-based, cols[] is 0-based */
0: 				cloned.setColumn(i + 1, (DataValueDescriptor)((CloneableObject) cols[i]).cloneObject());
1: 			}
1: 		}
1: 		if (inputRow instanceof IndexValueRow)
1: 			return new IndexValueRow(cloned);
1: 		else
1: 			return cloned;
1: 	}
1: 
1: 	/**
1: 	 * Insert a row
1: 	 *
0: 	 * @param ef	ExecutionFactory to use for cloning.
0: 	 * @param row the row to insert 
1: 	 *
1: 	 * @exception StandardException on error
1:  	 */
1: 	public void insert(ExecRow inputRow)
0: 		throws StandardException
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if(!isUniqueStream && !isVirtualMemHeap)
1: 				SanityManager.ASSERT(state != STATE_DRAIN, "you cannot insert rows after starting to drain");
1: 		}
1: 		if (! isVirtualMemHeap)
1: 			state = STATE_INSERT;
1: 
1: 		if(uniqueIndexCreated)
1: 		{
1: 			if(isRowAlreadyExist(inputRow))
1: 				return;
1: 		}
1: 
1: 		numRowsIn++;
1: 
1: 		if (lastArraySlot + 1 < rowArray.length)
1: 		{
1: 			rowArray[++lastArraySlot] = cloneRow(inputRow);
1: 			
1: 			//In case of unique stream we push every thing into the
1: 			// conglomerates for time being, we keep one row in the array for
1: 			// the template.
0: 			if(!isUniqueStream)
1: 				return;  
1: 		}
1: 			
1: 		if (!conglomCreated)
1: 		{
1: 			/*
1: 			** Create the conglomerate with the template row.
1: 			*/
0: 			CID = tc.createConglomerate("heap",
1: 										inputRow.getRowArray(),
1: 										null, //column sort order - not required for heap
1: 										properties,
1: 										TransactionController.IS_TEMPORARY | 
1: 										TransactionController.IS_KEPT);
1: 			conglomCreated = true;
1: 
1: 			cc = tc.openConglomerate(CID, 
1:                                 false,
1:                                 TransactionController.OPENMODE_FORUPDATE,
1:                                 TransactionController.MODE_TABLE,
1:                                 TransactionController.ISOLATION_SERIALIZABLE);
1: 			if(isUniqueStream)
1: 			   destRowLocation = cc.newRowLocationTemplate();
1: 
1: 		}
1: 
1: 		int status = 0;
1: 		if(isUniqueStream)
1: 		{
1: 			cc.insertAndFetchLocation(inputRow.getRowArray(), destRowLocation);
1: 			insertToPositionIndex(numRowsIn -1, destRowLocation);
1: 			//create the unique index based on input row ROW Location
1: 			if(!uniqueIndexCreated)
1: 				isRowAlreadyExist(inputRow);
1: 
1: 		}else
1: 		{
0: 			status = cc.insert(inputRow.getRowArray());
1: 			if (isVirtualMemHeap)
1: 				state = STATE_INSERT;
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (status != 0)
1: 			{
1: 				SanityManager.THROWASSERT("got funky status ("+status+") back from "+
1: 						"ConglomerateConstroller.insert()");
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Maintain an unique index based on the input row's row location in the
1: 	 * base table, this index make sures that we don't insert duplicate rows 
1: 	 * into the temporary heap.
1: 	 * @param inputRow  the row we are inserting to temporary row holder 
1: 	 * @exception StandardException on error
1:  	 */
1: 
1: 
1: 	private boolean isRowAlreadyExist(ExecRow inputRow) throws  StandardException
1: 	{
1: 		DataValueDescriptor		rlColumn;
1: 		RowLocation	baseRowLocation;
1: 		rlColumn = inputRow.getColumn(inputRow.nColumns());
1: 
1: 		if(CID!=0 && rlColumn instanceof SQLRef)
1: 		{
1: 			baseRowLocation = 
1: 				(RowLocation) (rlColumn).getObject();
1: 		
1: 			if(!uniqueIndexCreated)
1: 			{
1: 				int numKeys = 2;
1: 				uniqueIndexRow = new DataValueDescriptor[numKeys];
1: 				uniqueIndexRow[0] = baseRowLocation;
1: 				uniqueIndexRow[1] = baseRowLocation;
1: 				Properties props = makeIndexProperties(uniqueIndexRow, CID);
1: 				uniqueIndexConglomId =
0: 					tc.createConglomerate("BTREE",uniqueIndexRow , null,  props, 
1: 										  TransactionController.IS_TEMPORARY | 
1: 										  TransactionController.IS_KEPT);
1: 				uniqueIndex_cc = tc.openConglomerate(
1: 								uniqueIndexConglomId, 
1: 								false,
1: 								TransactionController.OPENMODE_FORUPDATE,
1: 								TransactionController.MODE_TABLE,
1: 								TransactionController.ISOLATION_SERIALIZABLE);
1: 				uniqueIndexCreated = true;
1: 			}
1: 
1: 			uniqueIndexRow[0] = baseRowLocation;
1: 			uniqueIndexRow[1] = baseRowLocation;
1: 			// Insert the row into the secondary index.
1: 			int status;
0: 			if ((status = uniqueIndex_cc.insert(uniqueIndexRow))!= 0)
1: 			{
1: 				if(status == ConglomerateController.ROWISDUPLICATE)
1: 				{
1: 					return true ; // okay; we don't insert duplicates
1: 				}
1: 				else
1: 				{
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (status != 0)
1: 						{
1: 							SanityManager.THROWASSERT("got funky status ("+status+") back from "+
1: 													  "Unique Index insert()");
1: 						}
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Maintain an index that will allow us to read  from the 
1: 	 * temporary heap in the order we inserted.
1: 	 * @param position - the number of the row we are inserting into heap
1: 	 * @param rl the row to Location in the temporary heap 
1: 	 * @exception StandardException on error
1:  	 */
1: 
1: 	private void insertToPositionIndex(int position, RowLocation rl ) throws  StandardException
1: 	{
1: 		if(!positionIndexCreated)
1: 		{
1: 			int numKeys = 2;
1: 			position_sqllong = new SQLLongint();
1: 			positionIndexRow = new DataValueDescriptor[numKeys];
1: 			positionIndexRow[0] = position_sqllong;
1: 			positionIndexRow[1] = rl;				
1: 			Properties props = makeIndexProperties(positionIndexRow, CID);
1: 			positionIndexConglomId =
0: 				tc.createConglomerate("BTREE", positionIndexRow, null,  props, 
1: 									  TransactionController.IS_TEMPORARY |
1: 									  TransactionController.IS_KEPT);
0: 			positionIndex_cc = tc.openConglomerate(
1: 													positionIndexConglomId, 
1: 													false,
1: 													TransactionController.OPENMODE_FORUPDATE,
1: 													TransactionController.MODE_TABLE,
1: 													TransactionController.ISOLATION_SERIALIZABLE);
1: 			positionIndexCreated = true;
1: 		}
1: 		
1: 		position_sqllong.setValue(position);
1: 		positionIndexRow[0] = position_sqllong;
1: 		positionIndexRow[1] = rl;
1: 		//insert the row location to position index
0: 		positionIndex_cc.insert(positionIndexRow);
1: 	}
1: 
1: 	/**
1: 	 * Get a result set for scanning what has been inserted
1:  	 * so far.
1: 	 *
1: 	 * @return a result set to use
1: 	 */
1: 	public CursorResultSet getResultSet()
1: 	{
1: 		state = STATE_DRAIN;
1: 		if(isUniqueStream)
1: 		{
1: 			return new TemporaryRowHolderResultSet(tc, rowArray,
0: 												   resultDescription, isVirtualMemHeap,
1: 												   true, positionIndexConglomId, this);
1: 		}
1: 		else
1: 		{
0: 			return new TemporaryRowHolderResultSet(tc, rowArray, resultDescription, isVirtualMemHeap, this);
1: 
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Purge the row holder of all its rows.
1: 	 * Resets the row holder so that it can
1: 	 * accept new inserts.  A cheap way to
1: 	 * recycle a row holder.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void truncate() throws StandardException
1: 	{
1: 		close();
1: 
1: 		for (int i = 0; i < rowArray.length; i++)
1: 		{
1: 			rowArray[i] = null;
1: 		}
1: 		lastArraySlot = -1;
0: 		numRowsIn = 0;
1: 		state = STATE_UNINIT;
1: 
1: 		/*
0: 		** We are not expecting this to be called
0: 		** when we have a temporary conglomerate
0: 		** but just to be on the safe side, drop
0: 		** it.  We'd like do something cheaper,
0: 		** but there is no truncate on congloms.
1: 		*/
1: 		if (conglomCreated)
1: 		{
1: 			tc.dropConglomerate(CID);
1: 			conglomCreated = false;
1: 		}
1: 	}
1: 
1: 	public long getTemporaryConglomId()
1: 	{
1: 		return CID;
1: 	}
1: 
1: 	public long getPositionIndexConglomId()
1: 	{
1: 		return positionIndexConglomId;
1: 	}
1: 
1: 
1: 
1: 	private Properties makeIndexProperties(DataValueDescriptor[]
1: 											   indexRowArray, long conglomId ) throws StandardException {
1: 		int nCols = indexRowArray.length;
1: 		Properties props = new Properties();
1: 		props.put("allowDuplicates", "false");
1: 		// all columns form the key, (currently) required
1: 		props.put("nKeyFields", String.valueOf(nCols));
1: 		props.put("nUniqueColumns", String.valueOf(nCols-1));
1: 		props.put("rowLocationColumn", String.valueOf(nCols-1));
1: 		props.put("baseConglomerateId", String.valueOf(conglomId));
1: 		return props;
1: 	}
1: 
1: 	public void setRowHolderTypeToUniqueStream()
1: 	{
1: 		isUniqueStream = true;
1: 	}
1: 
1: 	/**
1: 	 * Clean up
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void close() throws StandardException
1: 	{
1: 		if (scan != null)
1: 		{
1: 			scan.close();
1: 			scan = null;
1: 		}
1: 
1: 		if (cc != null)
1: 		{
1: 			cc.close();
1: 			cc = null;
1: 		}
1: 
1: 		if (uniqueIndex_cc != null)
1: 		{
1: 			uniqueIndex_cc.close();
1: 			uniqueIndex_cc = null;
1: 		}
1: 
1: 		if (positionIndex_cc != null)
1: 		{
1: 			positionIndex_cc.close();
1: 			positionIndex_cc = null;
1: 		}
1: 
1: 		if (uniqueIndexCreated)
1: 		{
1: 			tc.dropConglomerate(uniqueIndexConglomId);
1: 			uniqueIndexCreated = false;
1: 		}
1: 
1: 		if (positionIndexCreated)
1: 		{
1: 			tc.dropConglomerate(positionIndexConglomId);
1: 			uniqueIndexCreated = false;
1: 		}
1: 
1: 		if (conglomCreated)
1: 		{
1: 			tc.dropConglomerate(CID);
1: 			conglomCreated = false;
1: 		}
1: 
1: 		state = STATE_UNINIT;
1: 		lastArraySlot = -1;
1: 	}
1: }
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:             // TODO-COLLATE, I think collation needs to get set always correctly
1:             // but did see what to get collate id when there was no result
1:             // description.  The problem comes if row holder is used to stream
1:             // row to temp disk, then row is read from disk using an interface
1:             // where store creates the DataValueDescriptor template itself, 
1:             // and subsquently the returned column is used for some sort of
1:             // comparison.  Also could be a problem is reader of tempoary 
1:             // table uses qualifiers, that would result in comparisons internal
1:             // to store.  I believe the below impl is incomplete - either
1:             // it should always be default, or real collate_ids should be 
1:             // passed in.
1: 
1:             // null collate_ids in createConglomerate call indicates to use all
1:             // default collate ids.
1:             int collation_ids[] = null;
1: 
0:             /*
1:             TODO-COLLATE - if we could count on resultDescription I think the
1:             following would work.
1: 
1:             if (resultDescription != null)
1:             {
1:                 // init collation id info from resultDescription for create call
1:                 collation_ids = new int[resultDescription.getColumnCount()];
1: 
1:                 for (int i = 0; i < collation_ids.length; i++)
1:                 {
1:                     collation_ids[i] = 
1:                         resultDescription.getColumnDescriptor(
1:                             i + 1).getType().getCollationType();
0:                 }
0:             }
0:             */
1: 
1: 
1: 			CID = 
1:                 tc.createConglomerate(
1:                     "heap",
0:                     inputRow.getRowArray(),
0:                     null, //column sort order - not required for heap
1:                     collation_ids,
0:                     properties,
0:                     TransactionController.IS_TEMPORARY | 
0:                     TransactionController.IS_KEPT);
1: 
/////////////////////////////////////////////////////////////////////////
1: 					tc.createConglomerate(
1:                         "BTREE",
1:                         uniqueIndexRow, 
1:                         null,  
1:                         null, // no collation needed for index on row locations.
1:                         props, 
1:                         (TransactionController.IS_TEMPORARY | 
1:                          TransactionController.IS_KEPT));
0: 
/////////////////////////////////////////////////////////////////////////
1:                 tc.createConglomerate(
1:                     "BTREE",
1:                     positionIndexRow, 
1:                     null,  
1:                     null, // no collation needed for index on row locations.
1:                     props, 
1:                     (TransactionController.IS_TEMPORARY | 
1:                      TransactionController.IS_KEPT));
0: 
1: 			positionIndex_cc = 
1:                 tc.openConglomerate(
0:                     positionIndexConglomId, 
0:                     false,
0:                     TransactionController.OPENMODE_FORUPDATE,
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_SERIALIZABLE);
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
/////////////////////////////////////////////////////////////////////////
0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
/////////////////////////////////////////////////////////////////////////
0: 	 * @param resultDescription the result description.  Relevant for the getResultDescription
1: 	 * @param overflowToConglomThreshold on an attempt to insert
/////////////////////////////////////////////////////////////////////////
1: 	 * @param inputRow the row to insert 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.SQLRef;
0: import org.apache.derby.iapi.types.SQLLongint;
0: 
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.util.Properties;
0: 
0: /**
0:  * This is a class that is used to temporarily
0:  * (non-persistently) hold rows that are used in
0:  * language execution.  It will store them in an
0:  * array, or a temporary conglomerate, depending
0:  * on the number of rows.  
0:  * <p>
0:  * It is used for deferred DML processing.
0:  *
0:  * @author jamie
0:  */
0: public class TemporaryRowHolderImpl implements TemporaryRowHolder
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	public static final int DEFAULT_OVERFLOWTHRESHOLD = 5;
0: 
0: 	protected static final int STATE_UNINIT = 0;
0: 	protected static final int STATE_INSERT = 1;
0: 	protected static final int STATE_DRAIN = 2;
0: 
0: 
0: 	protected ExecRow[] 	rowArray;
0: 	protected int 		lastArraySlot;
0: 	private int			numRowsIn;
0: 	protected int		state = STATE_UNINIT;
0: 
0: 	protected	long				CID;
0: 	private boolean					conglomCreated;
0: 	private ConglomerateController	cc;
0: 	private Properties				properties;
0: 	private ScanController			scan;
0: 	private TransactionController	tc;
0: 	private	ResultDescription		resultDescription;
0: 
0: 	private boolean     isUniqueStream;
0: 
0: 	/* beetle 3865 updateable cursor use index. A virtual memory heap is a heap that has in-memory
0: 	 * part to get better performance, less overhead. No position index needed. We read from and write
0: 	 * to the in-memory part as much as possible. And we can insert after we start retrieving results.
0: 	 * Could be used for other things too.
0: 	 */
0: 	private boolean     isVirtualMemHeap;
0: 	private boolean     uniqueIndexCreated;
0: 	private boolean     positionIndexCreated;
0: 	private long        uniqueIndexConglomId;
0: 	private long        positionIndexConglomId;
0: 	private ConglomerateController uniqueIndex_cc;
0: 	private ConglomerateController positionIndex_cc;
0: 	private DataValueDescriptor[]  uniqueIndexRow = null;
0: 	private DataValueDescriptor[]  positionIndexRow = null;
0: 	private RowLocation            destRowLocation; //row location in the temporary conglomerate
0: 	private SQLLongint             position_sqllong;
0: 	
0: 
0: 	/**
0: 	 * Uses the default overflow to
0:  	 * a conglomerate threshold (5).
0: 	 *
0: 	 * @param tc the xact controller
0: 	 * @param properties the properties of the original table.  Used
0: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
0: 	 */
0: 	public TemporaryRowHolderImpl
0: 	(
0: 		TransactionController	tc, 
0: 		Properties 				properties, 
0: 		ResultDescription		resultDescription
0: 	) 
0: 	{
0: 		this(tc, properties, resultDescription, DEFAULT_OVERFLOWTHRESHOLD, false, false);
0: 	}
0: 	
0: 	/**
0: 	 * Uses the default overflow to
0:  	 * a conglomerate threshold (5).
0: 	 *
0: 	 * @param tc the xact controller
0: 	 * @param properties the properties of the original table.  Used
0: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
0: 	 * @param isUniqueStream - true , if it has to be temporary row holder unique stream
0: 	 */
0: 	public TemporaryRowHolderImpl
0: 	(
0: 		TransactionController	tc, 
0: 		Properties 				properties, 
0: 		ResultDescription		resultDescription,
0: 		boolean                 isUniqueStream
0: 	) 
0: 	{
0: 		this(tc, properties, resultDescription, 1, isUniqueStream, false);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Create a temporary row holder with the defined overflow to conglom
0: 	 *
0: 	 * @param tc the xact controller
0: 	 * @param properties the properties of the original table.  Used
0: 	 *		to help the store use optimal page size, etc.
0: 	 * @param the result description.  Relevant for the getResultDescription
0: 	 * 		call on the result set returned by getResultSet.  May be null
0: 	 * @param spillToConglomSize on an attempt to insert
0: 	 * 		this number of rows, the rows will be put
0:  	 *		into a temporary conglomerate.
0: 	 */
0: 	public TemporaryRowHolderImpl
0: 	(
0: 		TransactionController 	tc, 
0: 		Properties				properties,
0: 		ResultDescription		resultDescription,
0: 		int 					overflowToConglomThreshold,
0: 		boolean                 isUniqueStream,
0: 		boolean					isVirtualMemHeap
0: 	)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (overflowToConglomThreshold <= 0)
0: 			{
0: 				SanityManager.THROWASSERT("It is assumed that "+
0: 					"the overflow threshold is > 0.  "+
0: 					"If you you need to change this you have to recode some of "+
0: 					"this class.");
0: 			}
0: 		}
0: 
0: 		this.tc = tc;
0: 		this.properties = properties;
0: 		this.resultDescription = resultDescription;
0: 		this.isUniqueStream = isUniqueStream;
0: 		this.isVirtualMemHeap = isVirtualMemHeap;
0: 		rowArray = new ExecRow[overflowToConglomThreshold];
0: 		lastArraySlot = -1;
0: 	}
0: 
0: 	/* Avoid materializing a stream just because it goes through a temp table.  It is OK to
0: 	 * have a stream in the temp table (in memory or spilled to disk).  The assumption is
0: 	 * that one stream does not appear in two rows.  For "update", one stream can be in two
0: 	 * rows and the materialization is done in UpdateResultSet.  Note to future users of this
0: 	 * class who may insert a stream into this temp holder: (1) As mentioned above, one
0: 	 * un-materialized stream can't appear in two rows; you need to objectify it first otherwise.
0: 	 * (2) If you need to retrieve a un-materialized stream more than once from the temp holder,
0: 	 * you need to either materialize the stream the first time, or, if there's a memory constraint,
0: 	 * in the first time create a RememberBytesInputStream with the byte holder being
0: 	 * BackingStoreByteHolder, finish it, and reset it after usage.
0: 	 * beetle 4896.
0: 	 */
0: 	private ExecRow cloneRow(ExecRow inputRow)
0: 	{
0: 		DataValueDescriptor[] cols = inputRow.getRowArray();
0: 		int ncols = cols.length;
0: 		ExecRow cloned = ((ValueRow) inputRow).cloneMe();
0: 		for (int i = 0; i < ncols; i++)
0: 		{
0: 			if (cols[i] != null)
0: 			{
0: 				/* Rows are 1-based, cols[] is 0-based */
0: 				cloned.setColumn(i + 1, (DataValueDescriptor)((CloneableObject) cols[i]).cloneObject());
0: 			}
0: 		}
0: 		if (inputRow instanceof IndexValueRow)
0: 			return new IndexValueRow(cloned);
0: 		else
0: 			return cloned;
0: 	}
0: 
0: 	/**
0: 	 * Insert a row
0: 	 *
0: 	 * @param ef	ExecutionFactory to use for cloning.
0: 	 * @param row the row to insert 
0: 	 *
0: 	 * @exception StandardException on error
0:  	 */
0: 	public void insert(ExecRow inputRow)
0: 		throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if(!isUniqueStream && !isVirtualMemHeap)
0: 				SanityManager.ASSERT(state != STATE_DRAIN, "you cannot insert rows after starting to drain");
0: 		}
0: 		if (! isVirtualMemHeap)
0: 			state = STATE_INSERT;
0: 
0: 		if(uniqueIndexCreated)
0: 		{
0: 			if(isRowAlreadyExist(inputRow))
0: 				return;
0: 		}
0: 
0: 		numRowsIn++;
0: 
0: 		if (lastArraySlot + 1 < rowArray.length)
0: 		{
0: 			rowArray[++lastArraySlot] = cloneRow(inputRow);
0: 			
0: 			//In case of unique stream we push every thing into the
0: 			// conglomerates for time being, we keep one row in the array for
0: 			// the template.
0: 			if(!isUniqueStream)
0: 				return;  
0: 		}
0: 			
0: 		if (!conglomCreated)
0: 		{
0: 			/*
0: 			** Create the conglomerate with the template row.
0: 			*/
0: 			CID = tc.createConglomerate("heap",
0: 										inputRow.getRowArray(),
0: 										null, //column sort order - not required for heap
0: 										properties,
0: 										TransactionController.IS_TEMPORARY | 
0: 										TransactionController.IS_KEPT);
0: 			conglomCreated = true;
0: 
0: 			cc = tc.openConglomerate(CID, 
0:                                 false,
0:                                 TransactionController.OPENMODE_FORUPDATE,
0:                                 TransactionController.MODE_TABLE,
0:                                 TransactionController.ISOLATION_SERIALIZABLE);
0: 			if(isUniqueStream)
0: 			   destRowLocation = cc.newRowLocationTemplate();
0: 
0: 		}
0: 
0: 		int status = 0;
0: 		if(isUniqueStream)
0: 		{
0: 			cc.insertAndFetchLocation(inputRow.getRowArray(), destRowLocation);
0: 			insertToPositionIndex(numRowsIn -1, destRowLocation);
0: 			//create the unique index based on input row ROW Location
0: 			if(!uniqueIndexCreated)
0: 				isRowAlreadyExist(inputRow);
0: 
0: 		}else
0: 		{
0: 			status = cc.insert(inputRow.getRowArray());
0: 			if (isVirtualMemHeap)
0: 				state = STATE_INSERT;
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (status != 0)
0: 			{
0: 				SanityManager.THROWASSERT("got funky status ("+status+") back from "+
0: 						"ConglomerateConstroller.insert()");
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Maintain an unique index based on the input row's row location in the
0: 	 * base table, this index make sures that we don't insert duplicate rows 
0: 	 * into the temporary heap.
0: 	 * @param inputRow  the row we are inserting to temporary row holder 
0: 	 * @exception StandardException on error
0:  	 */
0: 
0: 
0: 	private boolean isRowAlreadyExist(ExecRow inputRow) throws  StandardException
0: 	{
0: 		DataValueDescriptor		rlColumn;
0: 		RowLocation	baseRowLocation;
0: 		rlColumn = inputRow.getColumn(inputRow.nColumns());
0: 
0: 		if(CID!=0 && rlColumn instanceof SQLRef)
0: 		{
0: 			baseRowLocation = 
0: 				(RowLocation) (rlColumn).getObject();
0: 		
0: 			if(!uniqueIndexCreated)
0: 			{
0: 				int numKeys = 2;
0: 				uniqueIndexRow = new DataValueDescriptor[numKeys];
0: 				uniqueIndexRow[0] = baseRowLocation;
0: 				uniqueIndexRow[1] = baseRowLocation;
0: 				Properties props = makeIndexProperties(uniqueIndexRow, CID);
0: 				uniqueIndexConglomId =
0: 					tc.createConglomerate("BTREE",uniqueIndexRow , null,  props, 
0: 										  TransactionController.IS_TEMPORARY | 
0: 										  TransactionController.IS_KEPT);
0: 				uniqueIndex_cc = tc.openConglomerate(
0: 								uniqueIndexConglomId, 
0: 								false,
0: 								TransactionController.OPENMODE_FORUPDATE,
0: 								TransactionController.MODE_TABLE,
0: 								TransactionController.ISOLATION_SERIALIZABLE);
0: 				uniqueIndexCreated = true;
0: 			}
0: 
0: 			uniqueIndexRow[0] = baseRowLocation;
0: 			uniqueIndexRow[1] = baseRowLocation;
0: 			// Insert the row into the secondary index.
0: 			int status;
0: 			if ((status = uniqueIndex_cc.insert(uniqueIndexRow))!= 0)
0: 			{
0: 				if(status == ConglomerateController.ROWISDUPLICATE)
0: 				{
0: 					return true ; // okay; we don't insert duplicates
0: 				}
0: 				else
0: 				{
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (status != 0)
0: 						{
0: 							SanityManager.THROWASSERT("got funky status ("+status+") back from "+
0: 													  "Unique Index insert()");
0: 						}
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Maintain an index that will allow us to read  from the 
0: 	 * temporary heap in the order we inserted.
0: 	 * @param position - the number of the row we are inserting into heap
0: 	 * @param rl the row to Location in the temporary heap 
0: 	 * @exception StandardException on error
0:  	 */
0: 
0: 	private void insertToPositionIndex(int position, RowLocation rl ) throws  StandardException
0: 	{
0: 		if(!positionIndexCreated)
0: 		{
0: 			int numKeys = 2;
0: 			position_sqllong = new SQLLongint();
0: 			positionIndexRow = new DataValueDescriptor[numKeys];
0: 			positionIndexRow[0] = position_sqllong;
0: 			positionIndexRow[1] = rl;				
0: 			Properties props = makeIndexProperties(positionIndexRow, CID);
0: 			positionIndexConglomId =
0: 				tc.createConglomerate("BTREE", positionIndexRow, null,  props, 
0: 									  TransactionController.IS_TEMPORARY |
0: 									  TransactionController.IS_KEPT);
0: 			positionIndex_cc = tc.openConglomerate(
0: 													positionIndexConglomId, 
0: 													false,
0: 													TransactionController.OPENMODE_FORUPDATE,
0: 													TransactionController.MODE_TABLE,
0: 													TransactionController.ISOLATION_SERIALIZABLE);
0: 			positionIndexCreated = true;
0: 		}
0: 		
0: 		position_sqllong.setValue(position);
0: 		positionIndexRow[0] = position_sqllong;
0: 		positionIndexRow[1] = rl;
0: 		//insert the row location to position index
0: 		positionIndex_cc.insert(positionIndexRow);
0: 	}
0: 
0: 	/**
0: 	 * Get a result set for scanning what has been inserted
0:  	 * so far.
0: 	 *
0: 	 * @return a result set to use
0: 	 */
0: 	public CursorResultSet getResultSet()
0: 	{
0: 		state = STATE_DRAIN;
0: 		if(isUniqueStream)
0: 		{
0: 			return new TemporaryRowHolderResultSet(tc, rowArray,
0: 												   resultDescription, isVirtualMemHeap,
0: 												   true, positionIndexConglomId, this);
0: 		}
0: 		else
0: 		{
0: 			return new TemporaryRowHolderResultSet(tc, rowArray, resultDescription, isVirtualMemHeap, this);
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Purge the row holder of all its rows.
0: 	 * Resets the row holder so that it can
0: 	 * accept new inserts.  A cheap way to
0: 	 * recycle a row holder.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void truncate() throws StandardException
0: 	{
0: 		close();
0: 
0: 		for (int i = 0; i < rowArray.length; i++)
0: 		{
0: 			rowArray[i] = null;
0: 		}
0: 		lastArraySlot = -1;
0: 		numRowsIn = 0;
0: 		state = STATE_UNINIT;
0: 
0: 		/*
0: 		** We are not expecting this to be called
0: 		** when we have a temporary conglomerate
0: 		** but just to be on the safe side, drop
0: 		** it.  We'd like do something cheaper,
0: 		** but there is no truncate on congloms.
0: 		*/
0: 		if (conglomCreated)
0: 		{
0: 			tc.dropConglomerate(CID);
0: 			conglomCreated = false;
0: 		}
0: 	}
0: 
0: 	public long getTemporaryConglomId()
0: 	{
0: 		return CID;
0: 	}
0: 
0: 	public long getPositionIndexConglomId()
0: 	{
0: 		return positionIndexConglomId;
0: 	}
0: 
0: 
0: 
0: 	private Properties makeIndexProperties(DataValueDescriptor[]
0: 											   indexRowArray, long conglomId ) throws StandardException {
0: 		int nCols = indexRowArray.length;
0: 		Properties props = new Properties();
0: 		props.put("allowDuplicates", "false");
0: 		// all columns form the key, (currently) required
0: 		props.put("nKeyFields", String.valueOf(nCols));
0: 		props.put("nUniqueColumns", String.valueOf(nCols-1));
0: 		props.put("rowLocationColumn", String.valueOf(nCols-1));
0: 		props.put("baseConglomerateId", String.valueOf(conglomId));
0: 		return props;
0: 	}
0: 
0: 	public void setRowHolderTypeToUniqueStream()
0: 	{
0: 		isUniqueStream = true;
0: 	}
0: 
0: 	/**
0: 	 * Clean up
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void close() throws StandardException
0: 	{
0: 		if (scan != null)
0: 		{
0: 			scan.close();
0: 			scan = null;
0: 		}
0: 
0: 		if (cc != null)
0: 		{
0: 			cc.close();
0: 			cc = null;
0: 		}
0: 
0: 		if (uniqueIndex_cc != null)
0: 		{
0: 			uniqueIndex_cc.close();
0: 			uniqueIndex_cc = null;
0: 		}
0: 
0: 		if (positionIndex_cc != null)
0: 		{
0: 			positionIndex_cc.close();
0: 			positionIndex_cc = null;
0: 		}
0: 
0: 		if (uniqueIndexCreated)
0: 		{
0: 			tc.dropConglomerate(uniqueIndexConglomId);
0: 			uniqueIndexCreated = false;
0: 		}
0: 
0: 		if (positionIndexCreated)
0: 		{
0: 			tc.dropConglomerate(positionIndexConglomId);
0: 			uniqueIndexCreated = false;
0: 		}
0: 
0: 		if (conglomCreated)
0: 		{
0: 			tc.dropConglomerate(CID);
0: 			conglomCreated = false;
0: 		}
0: 
0: 		state = STATE_UNINIT;
0: 		lastArraySlot = -1;
0: 	}
0: }
0: 
============================================================================