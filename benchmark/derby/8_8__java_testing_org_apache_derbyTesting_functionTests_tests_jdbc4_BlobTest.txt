1:a4846de: /*
1:a4846de:  
1:a4846de:    Derby - Class BlobTest
1:125c328:  
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:a4846de:  
1:a4846de:       http://www.apache.org/licenses/LICENSE-2.0
1:a4846de:  
1:a4846de:    Unless required by applicable law or agreed to in writing, software
1:a4846de:    distributed under the License is distributed on an "AS IS" BASIS,
1:a4846de:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a4846de:    See the License for the specific language governing permissions and
1:a4846de:    limitations under the License.
1:a4846de:  
1:a4846de:  */
1:a4846de: 
1:a4846de: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:a4846de: 
1:1ae02c9: import java.io.ByteArrayInputStream;
1:1ae02c9: import java.io.IOException;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.io.OutputStream;
1:1ae02c9: import java.lang.reflect.InvocationTargetException;
1:1ae02c9: import java.lang.reflect.Method;
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import java.util.HashMap;
1:1ae02c9: import java.util.Vector;
1:1ae02c9: import junit.framework.Test;
1:f697326: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:f697326: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:a4846de: 
1:125c328: /* This class is used to store the details of the methods that
1:125c328:  * throw a SQLFeatureNotSupportedException in the implementation
1:125c328:  * of java.sql.Blob.
1:125c328:  *
1:125c328:  * It store the following information about the methods
1:125c328:  *
1:125c328:  * a) Name
1:125c328:  * b) Method Parameters
1:125c328:  * c) Whether the method is exempted in the Embedded Sever
1:125c328:  * d) Whether the method is exempted in the NetworkClient
1:125c328:  *
1:125c328:  */
1:125c328: class ExemptBlobMD {
1:125c328:     // The Name of the method
1:125c328:     private String methodName_;
1:125c328:     
1:125c328:     // The parameters of the method
1:125c328:     private Class [] params_;
1:125c328:     
1:125c328:     //Whether it is exempted in the 
1:125c328:     //Client or the Embedded framework
1:125c328:     private boolean isClientFramework_;
1:125c328:     private boolean isEmbeddedFramework_;
1:125c328:     
1:125c328:     /**
1:125c328:      * The Constructor for the ExemptBlobMD class that
1:125c328:      * initialized the object with the details of the 
1:125c328:      * methods that have been exempted
1:125c328:      *
1:125c328:      * @param methodName          A String that contains the name of the method
1:125c328:      *                            that has been exempted.
1:125c328:      * @param params              A array of Class that contains the parameters 
1:125c328:      *                            of the methods.
1:125c328:      * @param isClientFramework   true if the method is exempted in the 
1:125c328:      *                            Client framework.
1:125c328:      * @param isEmbeddedFramework true if the method is exempted in the 
1:125c328:      *                            Embedded framework.
1:125c328:      *
1:125c328:      */
1:125c328:     public ExemptBlobMD(String methodName,Class [] params,
1:125c328:                             boolean isClientFramework,
1:125c328:                             boolean isEmbeddedFramework) {
1:125c328:         methodName_ = methodName;
1:125c328:         params_ = params;
1:125c328:         isClientFramework_ = isClientFramework;
1:125c328:         isEmbeddedFramework_ = isEmbeddedFramework;
1:125c328:     }
1:125c328:     
1:125c328:     /**
1:125c328:      *
1:125c328:      * Returns the name of the method.
1:125c328:      *
1:125c328:      * @return A String containing the name of the method.
1:125c328:      *
1:125c328:      */
1:125c328:     public String getMethodName() { return methodName_; }
1:125c328:     
1:125c328:     /**
1:125c328:      * Returns a array of Class containing the type of the parameters
1:125c328:      * of this method. 
1:125c328:      *
1:125c328:      * @return A array of Class containing the type of the parameters 
1:125c328:      *         of the method.
1:125c328:      */
1:125c328:     public Class [] getParams() { return params_; }
1:125c328:     
1:125c328:     /**
1:125c328:      * Returns if the method is exempted from the Client Framework.
1:125c328:      *
1:125c328:      * @return true if the method is exempted from the Client Framework.
1:125c328:      */
1:125c328:     public boolean getIfClientFramework() { return isClientFramework_; }
1:125c328:     
1:125c328:      /**
1:125c328:      * Returns if the method is exempted from the Embedded Framework.
1:125c328:      *
1:125c328:      * @return true if the method is exempted from the Embedded Framework.
1:125c328:      */
1:125c328:     public boolean getIfEmbeddedFramework() { return isEmbeddedFramework_; }
1:125c328: }
1:125c328: 
1:a4846de: /*
1:a4846de:  * Tests of the JDBC 4.0 specific <code>Blob</code> methods.
1:a4846de:  */
1:a4846de: public class BlobTest
1:a4846de:     extends BaseJDBCTestCase {
1:a4846de: 
1:a4846de:     /** Default Blob object used by the tests. */
1:a4846de:     private Blob blob = null;
1:a4846de:     
1:125c328:     // Initialize with the details of the method that are exempted from 
1:125c328:     //throwing a SQLException when they are called after calling free()
1:125c328:     //on a LOB.
1:125c328:     
1:9b52936:     private static final ExemptBlobMD [] emd = new ExemptBlobMD [] {
1:125c328:         new ExemptBlobMD( "getBinaryStream", new Class[] { long.class,long.class }
1:125c328:                                                                    ,true,true ),
1:125c328:         new ExemptBlobMD( "setBinaryStream", new Class[] { long.class },false,true ),
1:125c328:         new ExemptBlobMD( "setBytes", new Class[] { long.class, byte[].class }
1:125c328:                                                                    ,false,true ),
1:125c328:         new ExemptBlobMD( "setBytes", new Class[] { long.class, byte[].class
1:125c328:                                            , int.class, int.class },false,true ),
1:125c328:         new ExemptBlobMD( "truncate", new Class[] { long.class },false,true),
1:125c328:         new ExemptBlobMD( "free",null,true,true)
1:125c328:     };
1:125c328:     
1:125c328:     // An HashMap that is indexed by the Method which facilitated easy
1:125c328:     //search for whether the given method has been exempted from the
1:125c328:     //LOB interface.
1:125c328:     
1:125c328:     private HashMap<Method,ExemptBlobMD> excludedMethodSet = 
1:125c328:                             new HashMap<Method,ExemptBlobMD>();
1:125c328:        
1:125c328:     /**
1:a4846de:      * Create the test with the given name.
1:a4846de:      *
1:a4846de:      * @param name name of the test.
1:a4846de:      */
1:a4846de:     public BlobTest(String name) {
1:a4846de:         super(name);
1:a4846de:     }
1:a4846de:     
1:a4846de:     public void setUp() 
2:a4846de:         throws SQLException {
1:125c328: 
1:05d610e:         // Life span of Blob objects are limited by the transaction.  Need
1:05d610e:         // autocommit off so Blob objects survive closing of result set.
1:05d610e:         getConnection().setAutoCommit(false);
1:a4846de:     }
1:a4846de: 
1:9b52936:     protected void tearDown() throws Exception {
1:f697326:         if (blob != null) {
1:9b52936:             blob.free();
1:a4846de:             blob = null;
1:a4846de:         }
1:9b52936:         excludedMethodSet = null;
1:9b52936:         super.tearDown();
1:a4846de:     }
1:a4846de:     
1:a4846de:     /**
1:125c328:      * Builds the HashSet which will be used to test whether the given methods
1:125c328:      * can be exempted or not
1:125c328:      */
1:125c328:     void buildHashSet() {
1:0f26c83:         Class<Blob> iface = Blob.class;
1:125c328:         for(int i=0;i<emd.length;i++) {
1:125c328:             try {
1:125c328:                 Method m = iface.getMethod(emd[i].getMethodName()
1:125c328:                                                 ,emd[i].getParams());
1:125c328:                 excludedMethodSet.put(m,emd[i]);
1:125c328:             }
1:125c328:             catch(NoSuchMethodException nsme) {
1:125c328:                 fail("The method could not be found in the interface");
1:125c328:             }
1:a4846de:         }
1:a4846de:     }
1:a4846de:     
1:125c328:     /**
1:125c328:      * Tests the implementation for the free() method in the
1:125c328:      * Blob interface.
1:125c328:      * 
1:125c328:      * @throws SQLException if an error occurs during releasing
1:125c328:      *         the Blob resources
1:125c328:      *
1:125c328:      */
1:125c328:     public void testFreeandMethodsAfterCallingFree()
1:125c328:         throws SQLException {
1:a4846de:         
1:f697326:         blob = BlobClobTestSetup.getSampleBlob(getConnection());
1:a4846de:         
1:125c328:         //call the buildHashSetMethod to initialize the
1:125c328:         //HashSet with the method signatures that are exempted 
1:125c328:         //from throwing a SQLException after free has been called
1:125c328:         //on the Clob object.
1:125c328:         buildHashSet();
1:125c328: 
1:125c328:         blob.free();
1:125c328:         //testing the idempotence of the free() method
1:125c328:         //the method can be called multiple times on
1:125c328:         //the same instance. subsequent calls after 
1:125c328:         //the first are treated as no-ops
1:125c328:         blob.free();
1:125c328: 
1:125c328:         //blob becomes invalid after the first call 
1:125c328:         //to the free method so testing calling
1:125c328:         //a method on this invalid object should throw
1:125c328:         //an SQLException
1:125c328:         buildMethodList(blob);
1:125c328:     }
1:125c328:     
1:125c328:     /*
1:125c328:      * 
1:125c328:      * Enumerate the methods of the Blob interface and 
1:125c328:      * get the list of methods present in the interface
1:125c328:      * @param LOB an instance of the Blob interface implementation
1:125c328:      */
1:125c328:     void buildMethodList(Object LOB) {
1:125c328:         //If the given method throws the correct exception
1:125c328:         //set this to true and add it to the 
1:125c328:         boolean valid = true;
1:125c328:         
1:125c328:         //create a list of the methods that fail the test
1:125c328:         Vector<Method> methodList = new Vector<Method>();
1:125c328:         
1:125c328:         //The class whose methods are to be verified
1:125c328:         Class clazz = Blob.class;
1:125c328:         
1:125c328:         //The list of the methods in the class that need to be invoked
1:125c328:         //and verified
1:125c328:         Method [] methods = clazz.getMethods();
1:125c328:         
1:125c328:         //Check each of the methods to ensure that
1:125c328:         //they throw the required exception
1:125c328:         for(int i=0;i<methods.length;i++) {
1:125c328:             if(!checkIfExempted(methods[i])) {
1:125c328:                 valid = checkIfMethodThrowsSQLException(LOB,methods[i]);
1:125c328:                 
1:125c328:                 //add the method to the list if the method does
1:125c328:                 //not throw the required exception
1:125c328:                 if(valid == false) methodList.add(methods[i]);
1:125c328:                 
1:125c328:                 //reset valid
1:125c328:                 valid = true;
1:125c328:             }
1:125c328:         }
1:125c328:         
1:125c328:         if(!methodList.isEmpty()) {
1:125c328:             int c=0;
1:125c328:             String failureMessage = "The Following methods don't throw " +
1:125c328:                 "required exception - ";
1:125c328:             for (Method m : methodList) {
1:125c328:                 c = c + 1;
1:125c328:                 if(c == methodList.size() && c != 1) 
1:125c328:                     failureMessage += " & ";
1:125c328:                 else if(c != 1)
1:125c328:                     failureMessage += " , ";
1:125c328:                 failureMessage += m.getName();
1:125c328:             }
1:125c328:             fail(failureMessage);
1:125c328:         }
1:125c328:     }
1:125c328:     
1:125c328:     /**
1:125c328:      *Checks if the method throws a SQLFeatureNotSupportedException
1:125c328:      *@param m The method object that needs to be verified to see if it 
1:125c328:      *         is exempted
1:125c328:      *@return true if the given method does not throw the required SQLException
1:125c328:      *
1:125c328:      */
1:125c328:     boolean checkIfExempted(Method m) {
1:125c328:         ExemptBlobMD md = excludedMethodSet.get(m);
1:125c328:         
1:125c328:         if(md != null && usingDerbyNetClient()) { 
1:125c328:             if(md.getIfClientFramework()) 
1:125c328:                 return true;
1:125c328:             else
1:125c328:                 return false;
1:125c328:         } 
1:125c328:         if(md != null && usingEmbedded()) {
1:125c328:             if(md.getIfEmbeddedFramework())
1:125c328:                 return true;
1:125c328:             else
1:125c328:                 return false;
1:125c328:         }
1:125c328:         return false;
1:125c328:     }
1:125c328:     
1:125c328:     /**
1:125c328:      * Checks if the invocation of the method throws a SQLExceptio
1:125c328:      * as expected.
1:125c328:      * @param LOB    the Object that implements the Blob interface
1:125c328:      * @param method the method that needs to be tested to ensure
1:125c328:      *               that it throws the correct exception
1:125c328:      * @return true  If the method throws the SQLException required
1:125c328:      *               after the free method has been called on the
1:125c328:      *               LOB object
1:125c328:      *
1:125c328:      */
1:125c328:     boolean checkIfMethodThrowsSQLException(Object LOB,Method method) {
1:125c328:         try {
1:125c328:             method.invoke(LOB,getNullValues(method.getParameterTypes()));
1:125c328:         } catch(Throwable e) {
1:125c328:             if(e instanceof InvocationTargetException) {
1:125c328:                 Throwable cause = e.getCause();
1:125c328:                 if (cause instanceof SQLException ) {
1:125c328:                     SQLException sqle = (SQLException)cause;
1:125c328:                     if(sqle.getSQLState().equals("XJ215"))
1:125c328:                         return true;
1:125c328:                     else
1:125c328:                         return false;
1:125c328:                 } else {
1:125c328:                     return false;
1:125c328:                 }
1:125c328:                 
1:125c328:             }
1:125c328:         }
1:125c328:         return false;
1:125c328:     }
1:125c328:     
1:125c328:     /*
1:125c328:      * Return a array of objects containing the default values for
1:125c328:      * the objects passed in as parameters
1:125c328:      * 
1:125c328:      * @param parameterTypes an array containing the types of the parameter 
1:125c328:      *                       to the method
1:125c328:      * @return an array of Objects containing the null values for the 
1:125c328:      *         parameter inputs
1:125c328:      */
1:125c328:     
1:125c328:     Object[] getNullValues(Class<?> [] params) {
1:125c328:         Object[] args = new Object[params.length];
1:125c328:         for (int i = 0; i < params.length; i++) {
1:125c328:             args[i] = getNullValueForType(params[i]);
1:125c328:         }
1:125c328:         return args;
1:125c328:     }
1:125c328:     
1:125c328:     /*
1:125c328:      * Returns the null value for the specific type
1:125c328:      * 
1:125c328:      * @param type the type of the parameter for which the null
1:125c328:      *             value is required
1:125c328:      * @return the null value for the specific type
1:125c328:      * 
1:125c328:      */
1:125c328:      Object getNullValueForType(Class type)
1:125c328: 	{
1:125c328:         if (!type.isPrimitive()) {
1:125c328:             return null;
1:125c328:         }
1:125c328:         if (type == Boolean.TYPE) {
1:125c328:             return Boolean.FALSE;
1:125c328:         }
1:125c328:         if (type == Character.TYPE) {
1:39b3237:             return (char) 0;
1:125c328:         }
1:125c328:         if (type == Byte.TYPE) {
1:39b3237:             return (byte) 0;
1:125c328:         }
1:125c328:         if (type == Short.TYPE) {
1:39b3237:             return (short) 0;
1:125c328:         }
1:125c328:         if (type == Integer.TYPE) {
1:39b3237:             return 0;
1:125c328:         }
1:125c328:         if (type == Long.TYPE) {
1:39b3237:             return 0L;
1:125c328:         }
1:125c328:         if (type == Float.TYPE) {
1:39b3237:             return 0f;
1:125c328:         }
1:125c328:         if (type == Double.TYPE) {
1:39b3237:             return 0d;
1:125c328:         }
1:125c328:         fail("Don't know how to handle type " + type);
1:125c328:         return null;            // unreachable statement
1:125c328:     }
1:125c328: 
1:a4846de:     /**
1:c9382f0:      * Tests the implementation of the method
1:78afc5b:      * getBinaryStream(long pos, long length).
1:c9382f0:      *
1:c9382f0:      * @throws Exception
1:c9382f0:      */
1:78afc5b:     public void testGetBinaryStreamLong()
1:c9382f0:     throws Exception {
1:c9382f0:         byte[] BYTES1 = {
1:c9382f0:             0x65, 0x66, 0x67, 0x68, 0x69,
1:c9382f0:             0x69, 0x68, 0x67, 0x66, 0x65
1:c9382f0:         };
1:125c328: 
1:c9382f0:         InputStream is = new java.io.ByteArrayInputStream(BYTES1);
1:a4846de: 
1:c9382f0:         PreparedStatement ps = prepareStatement(
1:c9382f0:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:c9382f0:         int id = BlobClobTestSetup.getID();
1:c9382f0:         ps.setInt(1,id);
1:c9382f0:         ps.setBinaryStream(2,is);
1:c9382f0:         ps.execute();
1:c9382f0:         ps.close();
1:a4846de: 
1:c9382f0:         Statement st = createStatement();
1:a4846de: 
1:c9382f0:         ResultSet rs = st.executeQuery("select BLOBDATA from " +
1:c9382f0:             "BLOBCLOB where ID="+id);
1:c9382f0:         rs.next();
1:c9382f0:         Blob blob = rs.getBlob(1);
1:9b52936: 
1:c9382f0:         InputStream is_1 = blob.getBinaryStream(2L,5L);
1:c9382f0:         InputStream is_2 = new java.io.ByteArrayInputStream(BYTES1,1,5);
1:05d610e: 
1:05d610e:         assertEquals(is_2,is_1);
1:05d610e: 
1:c9382f0:         rs.close();
1:c9382f0:         st.close();
1:a4846de:     }
1:c9382f0:     
1:c9382f0:     /**
1:aeb4325:      * Obtains a binary stream and tries to drain it to read the last byte in
1:aeb4325:      * the Blob.
1:aeb4325:      * <p>
1:aeb4325:      * See DERBY-4060.
1:aeb4325:      *
1:aeb4325:      * @throws IOException if reading from a stream fails
1:aeb4325:      * @throws SQLException if something goes wrong
1:aeb4325:      */
1:aeb4325:     public void testGetBinaryStreamLongLastByte()
1:aeb4325:             throws IOException, SQLException {
1:aeb4325:         int length = 5000;
1:aeb4325:         // Insert a Blob
1:aeb4325:         PreparedStatement ps = prepareStatement(
1:aeb4325:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:aeb4325:         int id = BlobClobTestSetup.getID();
1:aeb4325:         ps.setInt(1, id);
1:aeb4325:         ps.setBinaryStream(2, new LoopingAlphabetStream(length), length);
1:aeb4325:         ps.execute();
1:aeb4325:         ps.close();
1:c9382f0: 
1:aeb4325:         // Get last byte from the source stream.
1:aeb4325:         InputStream cmpIs = new LoopingAlphabetStream(length);
1:aeb4325:         cmpIs.skip(length -1);
1:aeb4325:         int srcLastByte = cmpIs.read();
1:aeb4325:         assertTrue(cmpIs.read() == -1);
1:c9382f0: 
1:aeb4325:         // Read everything first.
1:aeb4325:         int bytesToRead = 5000;
1:aeb4325:         ps = prepareStatement("select BLOBDATA from BLOBCLOB where ID=?");
1:aeb4325:         ps.setInt(1, id);
1:aeb4325:         ResultSet rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         InputStream is = rs.getBlob(1).getBinaryStream(
1:aeb4325:                                         length - bytesToRead +1, bytesToRead);
1:c9382f0: 
1:aeb4325:         // Drain the stream, and make sure we are able to read the last byte.
1:aeb4325:         int lastByteRead = getLastByteInStream(is, bytesToRead);
1:aeb4325:         assertEquals(srcLastByte, lastByteRead);
1:aeb4325:         is.close();
1:aeb4325:         rs.close();
1:c9382f0: 
1:aeb4325:         // Read a portion of the stream.
1:aeb4325:         bytesToRead = 2000;
1:aeb4325:         rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         is = rs.getBlob(1).getBinaryStream(
1:aeb4325:                                         length - bytesToRead +1, bytesToRead);
1:aeb4325:         assertEquals(srcLastByte, lastByteRead);
1:aeb4325:         is.close();
1:aeb4325:         rs.close();
1:c9382f0: 
1:aeb4325:         // Read a very small portion of the stream.
1:aeb4325:         bytesToRead = 1;
1:aeb4325:         rs = ps.executeQuery();
1:aeb4325:         rs.next();
1:aeb4325:         is = rs.getBlob(1).getBinaryStream(
1:aeb4325:                                         length - bytesToRead +1, bytesToRead);
1:aeb4325:         assertEquals(srcLastByte, lastByteRead);
1:aeb4325:         is.close();
1:aeb4325:         rs.close();
1:a4846de:     }
1:c9382f0: 
1:c9382f0:     /**
1:c9382f0:      * Tests the exceptions thrown by the getBinaryStream
1:c9382f0:      * (long pos, long length) for the following conditions
1:dbed020:      * a) pos &lt;= 0
1:dbed020:      * b) pos &gt; (length of LOB)
1:dbed020:      * c) length &lt; 0
1:dbed020:      * d) pos + length &gt; (length of LOB).
1:c9382f0:      *
1:c9382f0:      * @throws SQLException.
1:c9382f0:      */
1:78afc5b:     public void testGetBinaryStreamLongExceptionConditions()
1:a4846de:     throws SQLException {
1:c9382f0:         byte[] BYTES1 = {
1:c9382f0:             0x65, 0x66, 0x67, 0x68, 0x69,
1:c9382f0:             0x69, 0x68, 0x67, 0x66, 0x65
1:c9382f0:         };
1:c9382f0: 
1:c9382f0:         InputStream is = new java.io.ByteArrayInputStream(BYTES1);
1:c9382f0: 
1:c9382f0:         PreparedStatement ps = prepareStatement(
1:c9382f0:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:c9382f0:         int id = BlobClobTestSetup.getID();
1:c9382f0:         ps.setInt(1,id);
1:c9382f0:         ps.setBinaryStream(2,is);
1:c9382f0:         ps.execute();
1:c9382f0:         ps.close();
1:c9382f0: 
1:c9382f0:         Statement st = createStatement();
1:c9382f0: 
1:c9382f0:         ResultSet rs = st.executeQuery("select BLOBDATA from " +
1:c9382f0:             "BLOBCLOB where ID="+id);
1:c9382f0:         rs.next();
1:c9382f0:         Blob blob = rs.getBlob(1);
1:c9382f0:         // check the case where pos <= 0
1:a4846de:         try {
1:c9382f0:             // set pos as negative
1:c9382f0:             blob.getBinaryStream(-2L,5L);
1:c9382f0:             //Should not come here. The exception has to be thrown.
1:c9382f0:             fail("FAIL: Expected SQLException for pos being negative " +
1:c9382f0:                     "not thrown");
1:9b52936:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when pos <= 0 is XJ070
1:c9382f0:             assertSQLState("XJ070", sqle);
1:c9382f0:         }
1:c9382f0: 
1:c9382f0:         // check for the case pos > length of Blob
1:a4846de:         try {
1:c9382f0:             // set the pos to any value greater than the Blob length
1:c9382f0:             blob.getBinaryStream(blob.length()+1, 5L);
1:c9382f0:             //Should not come here. The exception has to be thrown.
1:c9382f0:             fail("FAIL: Expected SQLException for position being greater than " +
1:c9382f0:                     "length of LOB not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when pos > length of Blob
1:c9382f0:             // is XJ076
1:9c7c512:             assertSQLState("XJ087", sqle);
1:c9382f0:         }
1:c9382f0: 
1:c9382f0:         //check for the case when length < 0
2:c9382f0:         try {
1:c9382f0:             // set length as negative
1:c9382f0:             blob.getBinaryStream(2L, -5L);
1:c9382f0:             // Should not come here. The exception has to be thrown.
1:c9382f0:             fail("Fail: expected exception for the length being negative " +
1:c9382f0:                     "not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when length < 0 of Blob
1:c9382f0:             // is XJ071
1:c9382f0:             assertSQLState("XJ071", sqle);
1:c9382f0:         }
1:c9382f0: 
1:c9382f0:         //check for the case when pos + length > length of Blob
1:c9382f0:         try {
1:c9382f0:             // set pos + length > length of Blob
1:c9382f0:             blob.getBinaryStream((blob.length() - 4), 10L);
1:c9382f0:             // Should not come here. The exception has to be thrown.
1:c9382f0:             fail("Fail: expected exception for the sum of position and length" +
1:c9382f0:                     " being greater than the LOB size not thrown");
1:c9382f0:         }
1:c9382f0:         catch(SQLException sqle) {
1:c9382f0:             // The SQLState for the exception thrown when length < 0 of Blob
1:c9382f0:             // is XJ087
1:c9382f0:             assertSQLState("XJ087", sqle);
1:c9382f0:         }
1:c9382f0:     }
1:c9382f0: 
1:c9382f0:     /**
1:28365b0:      * Tests that draining a "sub-stream" from the Blob works.
1:28365b0:      * This is a repro for DERBY-4061, where we ended up with an infinite loop.
1:c9382f0:      */
1:28365b0:     public void testGetBinaryStreamLongDrain()
1:28365b0:             throws IOException, SQLException {
1:28365b0:         initializeLongBlob(); // Ignoring id for now, use instance variable.
1:28365b0:         InputStream in = blob.getBinaryStream(2000, 5000);
1:28365b0:         byte[] buf = new byte[256];
1:28365b0:         while (in.read(buf, 0, buf.length) != -1) {
1:28365b0:             // This should end when we have read all the bytes in the stream.
1:28365b0:             // If the code hangs here, see DERBY-4061.
1:c9382f0:         }
1:28365b0:         in.close();
1:a4846de:         blob.free();
1:c9382f0:     }
1:c9382f0:     
1:aeb4325:     /**
1:a8908bd:      * Tests that the InputStream got from
1:a8908bd:      * a empty Blob reflects new data in the
1:a8908bd:      * underlying Blob.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetBinaryStreamCreateBlob() throws Exception {
1:a8908bd:          //The bytes that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Blob.
1:a8908bd:          byte[] bytes1 = {
1:a8908bd:             0x65, 0x66, 0x67, 0x68, 0x69,
1:a8908bd:             0x69, 0x68, 0x67, 0x66, 0x65
1:a8908bd:          };
1:a8908bd:          
1:a8908bd:          //The InputStream corresponding to the
1:a8908bd:          //Byte array
1:a8908bd:          ByteArrayInputStream is_bytes1 = new ByteArrayInputStream(bytes1);
1:a8908bd:          
1:a8908bd:          //create the empty Blob.
1:a8908bd:          Blob blob = getConnection().createBlob();
1:a8908bd:          
1:a8908bd:          //Get the InputStream from this
1:a8908bd:          //Blob
1:a8908bd:          InputStream is = blob.getBinaryStream();
1:a8908bd:          
1:a8908bd:          //set the bytes into the blob.
1:a8908bd:          blob.setBytes(1, bytes1);
1:a8908bd:          
1:a8908bd:          //Now compare the ByteArrayInputStream
1:a8908bd:          //and the stream from the Blob to
1:a8908bd:          //ensure that they are equal
1:a8908bd:          assertEquals(is_bytes1, is);
1:a8908bd:      }
1:a8908bd:      
1:a8908bd:     /**
1:a8908bd:      * Tests that the data updated in a Blob
1:a8908bd:      * is always reflected in the InputStream
1:a8908bd:      * got. Here we do updates in the Blob
1:a8908bd:      * both using Blob.setBytes and
1:a8908bd:      * using the OutputStream obtained from
1:a8908bd:      * the Blob.
1:a8908bd:      *
1:a8908bd:      * @throws Exception
1:a8908bd:      */
1:a8908bd:      public void testGetBinaryStreamBlobUpdates() throws Exception {
1:a8908bd:          //The bytes that will be used
1:a8908bd:          //to do the inserts into the
1:a8908bd:          //Blob using Blob.setBytes.
1:a8908bd:          byte[] bytes1 = {
1:a8908bd:             0x65, 0x66, 0x67, 0x68, 0x69,
1:a8908bd:             0x69, 0x68, 0x67, 0x66, 0x65
1:a8908bd:          };
1:a8908bd:          
1:a8908bd:          //The Byte array that will be used to do the
1:a8908bd:          //updates into the Blob using the OutputStream
1:a8908bd:          //obtained from the Blob
1:a8908bd:          byte[] bytes2 = {
1:a8908bd:             0x65, 0x66, 0x67, 0x68, 0x69,
1:a8908bd:             0x65, 0x66, 0x67, 0x68, 0x69
1:a8908bd:          };
1:a8908bd:          
1:a8908bd:          //create the empty Blob.
1:a8908bd:          Blob blob = getConnection().createBlob();
1:a8908bd:          
1:a8908bd:          //Get the InputStream from this
1:a8908bd:          //Blob
1:a8908bd:          InputStream is_BeforeWrite = blob.getBinaryStream();
1:a8908bd:          
1:a8908bd:          //Get an OutputStream from this Blob
1:a8908bd:          //into which the data can be written
1:a8908bd:          OutputStream os = blob.setBinaryStream(1);
1:a8908bd:          os.write(bytes1);
1:a8908bd:          
1:a8908bd:          //Doing a setBytes now on the Blob
1:a8908bd:          //should reflect the same extension
1:a8908bd:          //in the InputStream also.
1:a8908bd:          blob.setBytes(bytes1.length+1, bytes2);
1:a8908bd:          
1:a8908bd:          //Get the InputStream from this Blob
1:a8908bd:          //after the update has happened.
1:a8908bd:          InputStream is_AfterWrite = blob.getBinaryStream();
1:a8908bd:          
1:a8908bd:          //Compare the two streams to check that they
1:a8908bd:          //match
1:a8908bd:          assertEquals(is_BeforeWrite, is_AfterWrite);
1:a8908bd:      }
1:a8908bd:      
1:a8908bd:     /**
1:0c5c5aa:      * Tests the return count on insertion when the Blob is represented as a
1:0c5c5aa:      * byte array in memory.
1:28365b0:      */
1:0c5c5aa:     public void testSetBytesReturnValueSmall()
1:a4846de:             throws SQLException {
1:0c5c5aa:         Blob myBlob = getConnection().createBlob();
1:0c5c5aa:         byte[] byteBatch = new byte[] {
1:0c5c5aa:                     0x65, 0x66, 0x67, 0x68, 0x69,
1:0c5c5aa:                     0x65, 0x66, 0x67, 0x68, 0x69
1:0c5c5aa:                 };
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:0c5c5aa:         // Try again, overwrites the bytes.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:0c5c5aa:         // Last time, start at a different index.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(4, byteBatch));
1:aeb4325:     }
1:a8908bd: 
1:28365b0:     /**
1:0c5c5aa:      * Tests the return count on insertion when the Blob is represented as a
1:0c5c5aa:      * temporary file on disk.
1:0c5c5aa:      */
1:0c5c5aa:     public void testSetBytesReturnValueLarge()
1:0c5c5aa:             throws IOException, SQLException {
1:0c5c5aa:         Blob myBlob = getConnection().createBlob();
1:0c5c5aa:         // Insert one MB, should cause Blob to spill to disk.
1:0c5c5aa:         OutputStream blobWriter = myBlob.setBinaryStream(1);
1:0c5c5aa:         transferAlphabetData(blobWriter, 1*1024*1024);
1:0c5c5aa:         byte[] byteBatch = new byte[] {
1:0c5c5aa:                     0x65, 0x66, 0x67, 0x68, 0x69,
1:0c5c5aa:                     0x65, 0x66, 0x67, 0x68, 0x69
1:0c5c5aa:                 };
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:0c5c5aa:         // Try again, overwrites the bytes.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:0c5c5aa:         // Start at a different, low index.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(4, byteBatch));
1:0c5c5aa:         // Start at a different, higher index.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 byteBatch.length, myBlob.setBytes(512*1024, byteBatch));
1:28365b0:     }
1:c9382f0: 
1:0c5c5aa:     /**
1:0c5c5aa:      * Tests the return count on insertion when the Blob is fetched from the
1:0c5c5aa:      * database and then modified.
1:0c5c5aa:      * <p>
1:0c5c5aa:      * The main point for this test is to provoke the transition from a
1:0c5c5aa:      * read-only internal representation to a writable representation.
1:0c5c5aa:      * For a Blob of "considerable" size, this involved going from a store
1:0c5c5aa:      * stream representation to a {@code LOBStreamControl} representation using
1:0c5c5aa:      * a temporary file.
1:0c5c5aa:      */
1:0c5c5aa:     public void testSetBytesReturnValueLargeStateChange()
1:0c5c5aa:             throws IOException, SQLException {
1:0c5c5aa:         // Get a Blob from the database, don't create an empty one.
1:0c5c5aa:         initializeLongBlob(); // Ignoring id for now, use instance variable.
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 1, blob.setBytes(30000, new byte[] {0x69}));
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 1, blob.setBytes(1, new byte[] {0x69}));
1:0c5c5aa:         assertEquals("Wrong insertion count",
1:0c5c5aa:                 2, blob.setBytes(1235, new byte[] {0x69, 0x69}));
1:28365b0:     }
1:c9382f0: 
1:0c5c5aa:     /**
1:f697326:      * Test that a lock held on the corresponding row is released when free() is
1:f697326:      * called on the Blob object.
1:f697326:      * @throws java.sql.SQLException 
1:0c5c5aa:      */
1:f697326:     public void testLockingAfterFree() throws SQLException
1:f697326:     {
1:f697326:         int id = initializeLongBlob();  // Opens blob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:c9382f0:         
1:f697326:         // Test that update goes through after the blob is closed
1:28365b0:         blob.free();
1:f697326:         executeParallelUpdate(id, false);
1:aeb4325:         
1:f697326:         commit();
1:0c5c5aa:     }
1:aeb4325:     
1:aeb4325:     
1:0c5c5aa:     /**
1:f697326:      * Test that a lock held on the corresponding row is NOT released when
1:f697326:      * free() is called on the Blob object if the isolation level is
1:f697326:      * Repeatable Read
1:f697326:      * @throws java.sql.SQLException
2:f697326:      */
1:f697326:     public void testLockingAfterFreeWithRR() throws SQLException
1:f697326:     {
1:f697326:         getConnection().
1:f697326:                 setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:f697326:         int id = initializeLongBlob(); // Opens blob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:aeb4325:         
1:f697326:         // Test that update still times out after the blob is closed
1:f697326:         blob.free();
1:f697326:         executeParallelUpdate(id, true);
1:aeb4325:         
1:f697326:         // Test that the update goes through after the transaction has committed
1:f697326:         commit();
1:f697326:         executeParallelUpdate(id, false);
1:0c5c5aa:     }
1:aeb4325: 
1:0c5c5aa:     
1:0c5c5aa:      /**
1:f697326:      * Test that a lock held on the corresponding row is released when
1:f697326:      * free() is called on the Blob object if the isolation level is
1:f697326:      * Read Uncommitted
1:f697326:      * @throws java.sql.SQLException
1:f697326:      */
1:f697326:     public void testLockingAfterFreeWithDirtyReads() throws SQLException
1:f697326:     {
1:f697326:         getConnection().
1:f697326:                 setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:f697326:         int id = initializeLongBlob(); // Opens blob object
1:f697326:         executeParallelUpdate(id, true); // Test that timeout occurs
1:0c5c5aa:         
1:f697326:        // Test that update goes through after the blob is closed
3:f697326:         blob.free();
1:f697326:         executeParallelUpdate(id, false);
1:0c5c5aa:         
1:f697326:         commit();
1:0c5c5aa:     }
1:f697326: 
1:f697326: 
2:f697326:     /**
1:45a4a1d:      * Tests free() after implicit free
1:45a4a1d:      *
1:45a4a1d:      * @throws SQLException if an error occurs during free
1:45a4a1d:      *        
1:45a4a1d:      */
1:45a4a1d:     public void testFreeAfterImplicitFree()  throws SQLException
1:45a4a1d:     {
1:45a4a1d:         Connection conn = getConnection();
1:45a4a1d:         blob = BlobClobTestSetup.getSampleBlob(conn);
1:45a4a1d:         conn.commit();
1:45a4a1d:         // DERBY-5605
1:45a4a1d:         // free should not throw an exception even though it was 
1:45a4a1d:         // implicitly freed with the commit.
1:45a4a1d:         blob.free();
1:45a4a1d:         
1:45a4a1d:     }
1:45a4a1d:     
1:45a4a1d:     /**
1:f697326:      * Insert a row with a large blob into the test table.  Read the row from 
1:f697326:      * the database and assign the blob value to <code>blob</code>.
1:f697326:      * @return The id of the row that was inserted
1:f697326:      * @throws java.sql.SQLException 
1:f697326:      */
1:f697326:     private int initializeLongBlob() throws SQLException
1:f697326:     {
1:f697326:         // Blob needs to be larger than one page for locking to occur
1:f697326:         final int lobLength = 40000;
1:f697326: 
1:f697326:         // Insert a long Blob
1:f697326:         PreparedStatement ps =
1:f697326:                 prepareStatement("insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:f697326:         int id =BlobClobTestSetup.getID();
1:f697326:         ps.setInt(1, id);
1:f697326:         ps.setBinaryStream(2,
1:f697326:                            new LoopingAlphabetStream(lobLength), lobLength);
1:f697326:         ps.execute();
1:f697326:         ps.close();
1:f697326:         commit();
13:f697326: 
1:f697326:         // Fetch the Blob object from the database
1:f697326:         Statement st = createStatement();
1:f697326:         ResultSet rs =
1:f697326:                 st.executeQuery("select BLOBDATA from BLOBCLOB where ID=" + id);
1:f697326:         rs.next();
1:f697326:         blob = rs.getBlob(1);
1:f697326:         rs.close();
1:f697326:         st.close();
1:f697326: 
1:f697326:         return id;
1:f697326:     }
1:f697326:      
1:f697326: 
1:f697326:     /**
1:f697326:      * Try to update the row with the given error.  Flag a failure if a 
1:f697326:      * timeout occurs when not expected, and vice versa.
1:f697326:      * @param id The id of the row to be updated
1:f697326:      * @param timeoutExpected true if it is expected that the update times out
1:f697326:      * @throws java.sql.SQLException 
1:f697326:      */
1:f697326:     private void executeParallelUpdate(int id, boolean timeoutExpected) 
1:f697326:             throws SQLException
1:f697326:     {
1:f697326:         Connection conn2 = openDefaultConnection();
1:f697326:         Statement stmt2 = conn2.createStatement();
1:f697326: 
1:c9382f0:         try {
1:f697326:             stmt2.executeUpdate("update BLOBCLOB set CLOBDATA = 'New' where id=" 
1:f697326:                     + id);
1:f697326:             stmt2.close();
1:f697326:             conn2.commit();
1:f697326:             conn2.close();
1:f697326:             if (timeoutExpected) {
1:f697326:                 fail("FAIL - should have gotten lock timeout");
5:f697326:             }
1:f697326:          } catch (SQLException se) {
1:f697326:             stmt2.close();
1:f697326:             conn2.rollback();
1:f697326:             conn2.close();
1:f697326:             if (timeoutExpected) {
1:f697326:                 assertSQLState(LOCK_TIMEOUT, se);
1:f697326:             } else {               
1:f697326:                 throw se;
1:f697326:             }
1:f697326:         }
1:f697326:     }
1:f697326: 
1:f697326:     /**
1:0c5c5aa:      * Transfers the specified number of bytes generated from the modern latin
1:0c5c5aa:      * alphabet (lowercase) to the destination stream.
1:0c5c5aa:      *
1:0c5c5aa:      * @param writer the destination
1:0c5c5aa:      * @param length number of bytes to write
1:0c5c5aa:      * @throws IOException if writing to the destination stream fails
1:0c5c5aa:      */
1:0c5c5aa:     public static void transferAlphabetData(OutputStream writer, long length)
1:0c5c5aa:             throws IOException {
1:0c5c5aa:         byte[] buffer = new byte[8*1024];
1:6b14720:         int bytesRead = 0;
1:0c5c5aa:         LoopingAlphabetStream contents = new LoopingAlphabetStream(length);
1:6b14720:         while ((bytesRead = contents.read(buffer)) > 0) {
1:6b14720:             writer.write(buffer, 0, bytesRead);
1:0c5c5aa:         }
1:0c5c5aa:     }
1:f697326:     
1:f697326:     /**
1:aeb4325:      * Drains the stream and returns the last byte read from the stream.
1:aeb4325:      *
1:aeb4325:      * @param is stream to drain
1:aeb4325:      * @param expectedCount expected number of bytes (remaining) in the stream
1:aeb4325:      * @return The last byte read.
1:aeb4325:      * @throws AssertionError if there are too many/few bytes in the stream
1:aeb4325:      * @throws IOException if reading from the stream fails
1:aeb4325:      */
1:aeb4325:     public static int getLastByteInStream(InputStream is, int expectedCount)
1:aeb4325:             throws IOException {
1:aeb4325:         int read = 0;
1:aeb4325:         byte[] buf = new byte[256];
1:aeb4325:         assertTrue(buf.length > 0); // Do not allow an infinite loop here.
1:aeb4325:         while (true) {
1:aeb4325:             int readThisTime = is.read(buf, 0, buf.length);
1:aeb4325:             // -1 is expected, but catch all cases with a negative return value.
1:aeb4325:             if (readThisTime < 0) {
1:aeb4325:                 assertTrue("Invalid return value from stream",
1:aeb4325:                         readThisTime == -1);
1:aeb4325:                 fail("Reached EOF prematurely, expected " + expectedCount +
1:aeb4325:                         ", got " + read);
1:aeb4325:             } else if (readThisTime == 0) {
1:aeb4325:                 // Another special case that should not happen.
1:aeb4325:                 fail("Stream breaks contract, read zero bytes " + is);
1:aeb4325:             }
1:aeb4325:             read += readThisTime;
1:aeb4325:             if (read == expectedCount) {
1:aeb4325:                 return buf[readThisTime -1];
1:aeb4325:             } else if (read > expectedCount) {
1:aeb4325:                 fail("Too many bytes in stream, expected " + expectedCount +
1:aeb4325:                         "have " + read + "(EOF not reached/confirmed)");
1:aeb4325:             }
1:aeb4325:         }
1:aeb4325:     }
1:aeb4325: 
1:aeb4325:     /**
1:a4846de:      * Create test suite for this test.
1:a4846de:      */
1:f697326:     public static Test suite()
1:f697326:     {
1:f697326:         return new BlobClobTestSetup(
1:f697326:                 // Reduce lock timeouts so lock test case does not take too long
1:f697326:                 DatabasePropertyTestSetup.setLockTimeouts(
1:f697326:                         TestConfiguration.defaultSuite(BlobTest.class, false),
1:f697326:                         2, 
1:f697326:                         4));
1:a4846de:     }
1:a4846de: 
1:f697326:    private static final String LOCK_TIMEOUT = "40XL1";
1:a4846de: } // End class BlobTest
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * a) pos &lt;= 0
1:      * b) pos &gt; (length of LOB)
1:      * c) length &lt; 0
1:      * d) pos + length &gt; (length of LOB).
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             return (char) 0;
1:             return (byte) 0;
1:             return (short) 0;
1:             return 0;
1:             return 0L;
1:             return 0f;
1:             return 0d;
commit:a8908bd
/////////////////////////////////////////////////////////////////////////
1:      * Tests that the InputStream got from
1:      * a empty Blob reflects new data in the
1:      * underlying Blob.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetBinaryStreamCreateBlob() throws Exception {
1:          //The bytes that will be used
1:          //to do the inserts into the
1:          //Blob.
1:          byte[] bytes1 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x69, 0x68, 0x67, 0x66, 0x65
1:          };
1:          
1:          //The InputStream corresponding to the
1:          //Byte array
1:          ByteArrayInputStream is_bytes1 = new ByteArrayInputStream(bytes1);
1:          
1:          //create the empty Blob.
1:          Blob blob = getConnection().createBlob();
1:          
1:          //Get the InputStream from this
1:          //Blob
1:          InputStream is = blob.getBinaryStream();
1:          
1:          //set the bytes into the blob.
1:          blob.setBytes(1, bytes1);
1:          
1:          //Now compare the ByteArrayInputStream
1:          //and the stream from the Blob to
1:          //ensure that they are equal
1:          assertEquals(is_bytes1, is);
1:      }
1:      
1:     /**
1:      * Tests that the data updated in a Blob
1:      * is always reflected in the InputStream
1:      * got. Here we do updates in the Blob
1:      * both using Blob.setBytes and
1:      * using the OutputStream obtained from
1:      * the Blob.
1:      *
1:      * @throws Exception
1:      */
1:      public void testGetBinaryStreamBlobUpdates() throws Exception {
1:          //The bytes that will be used
1:          //to do the inserts into the
1:          //Blob using Blob.setBytes.
1:          byte[] bytes1 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x69, 0x68, 0x67, 0x66, 0x65
1:          };
1:          
1:          //The Byte array that will be used to do the
1:          //updates into the Blob using the OutputStream
1:          //obtained from the Blob
1:          byte[] bytes2 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x65, 0x66, 0x67, 0x68, 0x69
1:          };
1:          
1:          //create the empty Blob.
1:          Blob blob = getConnection().createBlob();
1:          
1:          //Get the InputStream from this
1:          //Blob
1:          InputStream is_BeforeWrite = blob.getBinaryStream();
1:          
1:          //Get an OutputStream from this Blob
1:          //into which the data can be written
1:          OutputStream os = blob.setBinaryStream(1);
1:          os.write(bytes1);
1:          
1:          //Doing a setBytes now on the Blob
1:          //should reflect the same extension
1:          //in the InputStream also.
1:          blob.setBytes(bytes1.length+1, bytes2);
1:          
1:          //Get the InputStream from this Blob
1:          //after the update has happened.
1:          InputStream is_AfterWrite = blob.getBinaryStream();
1:          
1:          //Compare the two streams to check that they
1:          //match
1:          assertEquals(is_BeforeWrite, is_AfterWrite);
1:      }
1:     
1: 
1:     /**
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:125c328
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import java.lang.reflect.*;
0: import java.util.*;
1: 
1: /* This class is used to store the details of the methods that
1:  * throw a SQLFeatureNotSupportedException in the implementation
1:  * of java.sql.Blob.
1:  *
1:  * It store the following information about the methods
1:  *
1:  * a) Name
1:  * b) Method Parameters
1:  * c) Whether the method is exempted in the Embedded Sever
1:  * d) Whether the method is exempted in the NetworkClient
1:  *
1:  */
1: class ExemptBlobMD {
1:     // The Name of the method
1:     private String methodName_;
1:     
1:     // The parameters of the method
1:     private Class [] params_;
1:     
1:     //Whether it is exempted in the 
1:     //Client or the Embedded framework
1:     private boolean isClientFramework_;
1:     private boolean isEmbeddedFramework_;
1:     
1:     /**
1:      * The Constructor for the ExemptBlobMD class that
1:      * initialized the object with the details of the 
1:      * methods that have been exempted
1:      *
1:      * @param methodName          A String that contains the name of the method
1:      *                            that has been exempted.
1:      * @param params              A array of Class that contains the parameters 
1:      *                            of the methods.
1:      * @param isClientFramework   true if the method is exempted in the 
1:      *                            Client framework.
1:      * @param isEmbeddedFramework true if the method is exempted in the 
1:      *                            Embedded framework.
1:      *
1:      */
1:     public ExemptBlobMD(String methodName,Class [] params,
1:                             boolean isClientFramework,
1:                             boolean isEmbeddedFramework) {
1:         methodName_ = methodName;
1:         params_ = params;
1:         isClientFramework_ = isClientFramework;
1:         isEmbeddedFramework_ = isEmbeddedFramework;
1:     }
1:     
1:     /**
1:      *
1:      * Returns the name of the method.
1:      *
1:      * @return A String containing the name of the method.
1:      *
1:      */
1:     public String getMethodName() { return methodName_; }
1:     
1:     /**
1:      * Returns a array of Class containing the type of the parameters
1:      * of this method. 
1:      *
1:      * @return A array of Class containing the type of the parameters 
1:      *         of the method.
1:      */
1:     public Class [] getParams() { return params_; }
1:     
1:     /**
1:      * Returns if the method is exempted from the Client Framework.
1:      *
1:      * @return true if the method is exempted from the Client Framework.
1:      */
1:     public boolean getIfClientFramework() { return isClientFramework_; }
1:     
1:      /**
1:      * Returns if the method is exempted from the Embedded Framework.
1:      *
1:      * @return true if the method is exempted from the Embedded Framework.
1:      */
1:     public boolean getIfEmbeddedFramework() { return isEmbeddedFramework_; }
1: }
/////////////////////////////////////////////////////////////////////////
1:     // Initialize with the details of the method that are exempted from 
1:     //throwing a SQLException when they are called after calling free()
1:     //on a LOB.
1:     
0:     private ExemptBlobMD [] emd = new ExemptBlobMD [] {
1:         new ExemptBlobMD( "getBinaryStream", new Class[] { long.class,long.class }
1:                                                                    ,true,true ),
1:         new ExemptBlobMD( "setBinaryStream", new Class[] { long.class },false,true ),
1:         new ExemptBlobMD( "setBytes", new Class[] { long.class, byte[].class }
1:                                                                    ,false,true ),
1:         new ExemptBlobMD( "setBytes", new Class[] { long.class, byte[].class
1:                                            , int.class, int.class },false,true ),
1:         new ExemptBlobMD( "truncate", new Class[] { long.class },false,true),
1:         new ExemptBlobMD( "free",null,true,true)
1:     };
1:     
1:     // An HashMap that is indexed by the Method which facilitated easy
1:     //search for whether the given method has been exempted from the
1:     //LOB interface.
1:     
1:     private HashMap<Method,ExemptBlobMD> excludedMethodSet = 
1:                             new HashMap<Method,ExemptBlobMD>();
1:        
/////////////////////////////////////////////////////////////////////////
1:         
1:         //call the buildHashSetMethod to initialize the 
1:         //HashSet with the method signatures that are exempted 
1:         //from throwing a SQLException after free has been called
1:         //on the Clob object.
1:         buildHashSet();
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Builds the HashSet which will be used to test whether the given methods
1:      * can be exempted or not
1:      */
1:     void buildHashSet() {
0:         Class iface = Blob.class;
1:         for(int i=0;i<emd.length;i++) {
1:             try {
1:                 Method m = iface.getMethod(emd[i].getMethodName()
1:                                                 ,emd[i].getParams());
1:                 excludedMethodSet.put(m,emd[i]);
1:             }
1:             catch(NoSuchMethodException nsme) {
1:                 fail("The method could not be found in the interface");
1:             }
1:     /**
1:      * Tests the implementation for the free() method in the
1:      * Blob interface.
1:      * 
1:      * @throws SQLException if an error occurs during releasing
1:      *         the Blob resources
1:      *
1:      */
1:     public void testFreeandMethodsAfterCallingFree()
1:         throws SQLException {
1:         blob.free();
1:         //testing the idempotence of the free() method
1:         //the method can be called multiple times on
1:         //the same instance. subsequent calls after 
1:         //the first are treated as no-ops
1:         blob.free();
1: 
1:         //blob becomes invalid after the first call 
1:         //to the free method so testing calling
1:         //a method on this invalid object should throw
1:         //an SQLException
1:         buildMethodList(blob);
1:     }
1:     
1:     /*
1:      * 
1:      * Enumerate the methods of the Blob interface and 
1:      * get the list of methods present in the interface
1:      * @param LOB an instance of the Blob interface implementation
1:      */
1:     void buildMethodList(Object LOB) {
1:         //If the given method throws the correct exception
1:         //set this to true and add it to the 
1:         boolean valid = true;
1:         
1:         //create a list of the methods that fail the test
1:         Vector<Method> methodList = new Vector<Method>();
1:         
1:         //The class whose methods are to be verified
1:         Class clazz = Blob.class;
1:         
1:         //The list of the methods in the class that need to be invoked
1:         //and verified
1:         Method [] methods = clazz.getMethods();
1:         
1:         //Check each of the methods to ensure that
1:         //they throw the required exception
1:         for(int i=0;i<methods.length;i++) {
1:             if(!checkIfExempted(methods[i])) {
1:                 valid = checkIfMethodThrowsSQLException(LOB,methods[i]);
1:                 
1:                 //add the method to the list if the method does
1:                 //not throw the required exception
1:                 if(valid == false) methodList.add(methods[i]);
1:                 
1:                 //reset valid
1:                 valid = true;
1:             }
1:         }
1:         
1:         if(!methodList.isEmpty()) {
1:             int c=0;
1:             String failureMessage = "The Following methods don't throw " +
1:                 "required exception - ";
1:             for (Method m : methodList) {
1:                 c = c + 1;
1:                 if(c == methodList.size() && c != 1) 
1:                     failureMessage += " & ";
1:                 else if(c != 1)
1:                     failureMessage += " , ";
1:                 failureMessage += m.getName();
1:             }
1:             fail(failureMessage);
1:         }
1:     }
1:     
1:     /**
1:      *Checks if the method throws a SQLFeatureNotSupportedException
1:      *@param m The method object that needs to be verified to see if it 
1:      *         is exempted
1:      *@return true if the given method does not throw the required SQLException
1:      *
1:      */
1:     boolean checkIfExempted(Method m) {
1:         ExemptBlobMD md = excludedMethodSet.get(m);
1:         
1:         if(md != null && usingDerbyNetClient()) { 
1:             if(md.getIfClientFramework()) 
1:                 return true;
1:             else
1:                 return false;
1:         } 
1:         if(md != null && usingEmbedded()) {
1:             if(md.getIfEmbeddedFramework())
1:                 return true;
1:             else
1:                 return false;
1:         }
1:         return false;
1:     }
1:     
1:     /**
1:      * Checks if the invocation of the method throws a SQLExceptio
1:      * as expected.
1:      * @param LOB    the Object that implements the Blob interface
1:      * @param method the method that needs to be tested to ensure
1:      *               that it throws the correct exception
1:      * @return true  If the method throws the SQLException required
1:      *               after the free method has been called on the
1:      *               LOB object
1:      *
1:      */
1:     boolean checkIfMethodThrowsSQLException(Object LOB,Method method) {
1:         try {
1:             method.invoke(LOB,getNullValues(method.getParameterTypes()));
1:         } catch(Throwable e) {
1:             if(e instanceof InvocationTargetException) {
1:                 Throwable cause = e.getCause();
1:                 if (cause instanceof SQLException ) {
1:                     SQLException sqle = (SQLException)cause;
1:                     if(sqle.getSQLState().equals("XJ215"))
1:                         return true;
1:                     else
1:                         return false;
1:                 } else {
1:                     return false;
1:                 }
1:                 
1:             }
1:         }
1:         return false;
1:     }
1:     
1:     /*
1:      * Return a array of objects containing the default values for
1:      * the objects passed in as parameters
1:      * 
1:      * @param parameterTypes an array containing the types of the parameter 
1:      *                       to the method
1:      * @return an array of Objects containing the null values for the 
1:      *         parameter inputs
1:      */
1:     
1:     Object[] getNullValues(Class<?> [] params) {
1:         Object[] args = new Object[params.length];
1:         for (int i = 0; i < params.length; i++) {
1:             args[i] = getNullValueForType(params[i]);
1:         }
1:         return args;
1:     }
1:     
1:     /*
1:      * Returns the null value for the specific type
1:      * 
1:      * @param type the type of the parameter for which the null
1:      *             value is required
1:      * @return the null value for the specific type
1:      * 
1:      */
1:      Object getNullValueForType(Class type)
1: 	{
1:         if (!type.isPrimitive()) {
1:             return null;
1:         }
1:         if (type == Boolean.TYPE) {
1:             return Boolean.FALSE;
1:         }
1:         if (type == Character.TYPE) {
0:             return new Character((char) 0);
1:         }
1:         if (type == Byte.TYPE) {
0:             return new Byte((byte) 0);
1:         }
1:         if (type == Short.TYPE) {
0:             return new Short((short) 0);
1:         }
1:         if (type == Integer.TYPE) {
0:             return new Integer(0);
1:         }
1:         if (type == Long.TYPE) {
0:             return new Long(0L);
1:         }
1:         if (type == Float.TYPE) {
0:             return new Float(0f);
1:         }
1:         if (type == Double.TYPE) {
0:             return new Double(0d);
1:         }
1:         fail("Don't know how to handle type " + type);
1:         return null;            // unreachable statement
1:     }
1:     
1:     
commit:a4846de
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class BlobTest
1:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
0: import java.sql.*;
1: 
1: /*
1:  * Tests of the JDBC 4.0 specific <code>Blob</code> methods.
1:  */
1: public class BlobTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** Default Blob object used by the tests. */
1:     private Blob blob = null;
0:     /** Default connection used by the tests. */
0:     private Connection con = null;
1:     
1:     /**
1:      * Create the test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public BlobTest(String name) {
1:         super(name);
1:     }
1:     
1:     public void setUp() 
1:         throws SQLException {
0:         con = getConnection();
0:         blob = BlobClobTestSetup.getSampleBlob(con);
1:     }
1: 
0:     public void tearDown()
1:         throws SQLException {
1:         blob = null;
0:         if (con != null && !con.isClosed()) {
0:             con.rollback();
0:             con.close();
1:         }
0:         con = null;
1:     }
1: 
0:     public void testFreeNotImplemented()
1:         throws SQLException {
1:         try {
1:             blob.free();
0:             fail("Blob.free() should not be implemented");
0:         } catch (SQLFeatureNotSupportedException sfnse) {
0:             // Do nothing, we are fine
1:         }
1:     }
1:     
0:     public void testGetBinaryStringLongNotImplemented()
1:         throws SQLException {
1:         try {
0:             blob.getBinaryStream(5l, 10l);
0:             fail("Blob.getBinaryStream(long,long) should not be implemented");
0:         } catch (SQLFeatureNotSupportedException sfnse) {
0:             // Do nothing, we are fine
1:         }
1:     }
1: 
1:     /**
1:      * Create test suite for this test.
1:      */
0:     public static Test suite() {
0:         return new BlobClobTestSetup(new TestSuite(BlobTest.class,
0:                                                    "BlobTest suite"));
1:     }
1: 
1: } // End class BlobTest
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:45a4a1d
/////////////////////////////////////////////////////////////////////////
1:      * Tests free() after implicit free
1:      *
1:      * @throws SQLException if an error occurs during free
1:      *        
1:      */
1:     public void testFreeAfterImplicitFree()  throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         blob = BlobClobTestSetup.getSampleBlob(conn);
1:         conn.commit();
1:         // DERBY-5605
1:         // free should not throw an exception even though it was 
1:         // implicitly freed with the commit.
1:         blob.free();
1:         
1:     }
1:     
1:     /**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.sql.Blob;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.HashMap;
1: import java.util.Vector;
1: import junit.framework.Test;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0f26c83
/////////////////////////////////////////////////////////////////////////
1:         Class<Blob> iface = Blob.class;
commit:9b52936
/////////////////////////////////////////////////////////////////////////
1:     private static final ExemptBlobMD [] emd = new ExemptBlobMD [] {
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void tearDown() throws Exception {
1:         blob.free();
0:         blob = null;
1:         excludedMethodSet = null;
1:         super.tearDown();
1:     }
commit:05d610e
/////////////////////////////////////////////////////////////////////////
1:         // Life span of Blob objects are limited by the transaction.  Need
1:         // autocommit off so Blob objects survive closing of result set.
1:         getConnection().setAutoCommit(false);
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(is_2,is_1);
1: 
commit:9c7c512
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XJ087", sqle);
commit:c9382f0
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tests the implementation of the method
0:      * getBinaryStream(long pos, long length)
0:      * in the NetworkClient.
1:      *
1:      * @throws Exception
1:      */
0:     public void clientTestGetBinaryStreamLong()
1:     throws Exception {
1:         byte[] BYTES1 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x69, 0x68, 0x67, 0x66, 0x65
1:         };
1: 
1:         InputStream is = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1,id);
1:         ps.setBinaryStream(2,is);
1:         ps.execute();
1:         ps.close();
1: 
1:         Statement st = createStatement();
1: 
1:         ResultSet rs = st.executeQuery("select BLOBDATA from " +
1:             "BLOBCLOB where ID="+id);
1:         rs.next();
1:         Blob blob = rs.getBlob(1);
1: 
1:         InputStream is_1 = blob.getBinaryStream(2L,5L);
1:         InputStream is_2 = new java.io.ByteArrayInputStream(BYTES1,1,5);
1: 
1:         rs.close();
1:         st.close();
1: 
0:         assertEquals(is_2,is_1);
1:     }
1:     /**
1:      * Tests the exceptions thrown by the getBinaryStream
1:      * (long pos, long length) for the following conditions
0:      * a) pos <= 0
0:      * b) pos > (length of LOB)
0:      * c) length < 0
0:      * d) pos + length > (length of LOB).
1:      *
1:      * @throws SQLException.
1:      */
0:     public void clientTestGetBinaryStreamLongExceptionConditions()
0:     throws SQLException {
1:         byte[] BYTES1 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x69, 0x68, 0x67, 0x66, 0x65
1:         };
1: 
1:         InputStream is = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1,id);
1:         ps.setBinaryStream(2,is);
1:         ps.execute();
1:         ps.close();
1: 
1:         Statement st = createStatement();
1: 
1:         ResultSet rs = st.executeQuery("select BLOBDATA from " +
1:             "BLOBCLOB where ID="+id);
1:         rs.next();
1:         Blob blob = rs.getBlob(1);
1:         // check the case where pos <= 0
1:         try {
1:             // set pos as negative
1:             blob.getBinaryStream(-2L,5L);
1:             //Should not come here. The exception has to be thrown.
1:             fail("FAIL: Expected SQLException for pos being negative " +
1:                     "not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when pos <= 0 is XJ070
1:             assertSQLState("XJ070", sqle);
1:         }
1: 
1:         // check for the case pos > length of Blob
1:         try {
1:             // set the pos to any value greater than the Blob length
1:             blob.getBinaryStream(blob.length()+1, 5L);
1:             //Should not come here. The exception has to be thrown.
1:             fail("FAIL: Expected SQLException for position being greater than " +
1:                     "length of LOB not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when pos > length of Blob
1:             // is XJ076
0:             assertSQLState("XJ076", sqle);
1:         }
1: 
1:         //check for the case when length < 0
1:         try {
1:             // set length as negative
1:             blob.getBinaryStream(2L, -5L);
1:             // Should not come here. The exception has to be thrown.
1:             fail("Fail: expected exception for the length being negative " +
1:                     "not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when length < 0 of Blob
1:             // is XJ071
1:             assertSQLState("XJ071", sqle);
1:         }
1: 
1:         //check for the case when pos + length > length of Blob
1:         try {
1:             // set pos + length > length of Blob
1:             blob.getBinaryStream((blob.length() - 4), 10L);
1:             // Should not come here. The exception has to be thrown.
1:             fail("Fail: expected exception for the sum of position and length" +
1:                     " being greater than the LOB size not thrown");
1:         }
1:         catch(SQLException sqle) {
1:             // The SQLState for the exception thrown when length < 0 of Blob
1:             // is XJ087
1:             assertSQLState("XJ087", sqle);
1:         }
1:     }
1: 
1:     /**
0:      * Tests the getBinaryStream(long pos, long length) on the Embedded side.
0:      * @throws SQLException
1:      */
0:     public void embeddedTestGetBinaryStringLongNotImplemented()
0:     throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:         TestSuite btSuite = new TestSuite("BlobTest suite");
1: 
0:         TestSuite embedded = new TestSuite("BlobTest:embedded");
0:         embedded.addTestSuite(BlobTest.class);
0:         embedded.addTest(new BlobTest(
0:                     "embeddedTestGetBinaryStringLongNotImplemented"));
0:         btSuite.addTest(new BlobClobTestSetup(embedded));
1: 
0:         TestSuite client = new TestSuite("BlobTest:client");
0:         client.addTestSuite(BlobTest.class);
0:         client.addTest(new BlobTest("clientTestGetBinaryStreamLong"));
0:         client.addTest(new BlobTest("clientTestGetBinaryStreamLong" +
0:                 "ExceptionConditions"));
0:         btSuite.addTest(TestConfiguration.clientServerDecorator(
0:             new BlobClobTestSetup(client)));
1: 
0:         return btSuite;
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("BlobTest suite");
0:         suite.addTest(new BlobClobTestSetup(
0:             new TestSuite(BlobTest.class, "BlobTest:embedded")));
0:         suite.addTest(TestConfiguration.clientServerDecorator(
0:             new BlobClobTestSetup(new TestSuite(BlobTest.class,
0:                                                 "BlobTest:client"))));
0:         return suite;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aeb4325
/////////////////////////////////////////////////////////////////////////
1:      * Obtains a binary stream and tries to drain it to read the last byte in
1:      * the Blob.
1:      * <p>
1:      * See DERBY-4060.
1:      *
1:      * @throws IOException if reading from a stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testGetBinaryStreamLongLastByte()
1:             throws IOException, SQLException {
1:         int length = 5000;
1:         // Insert a Blob
1:         PreparedStatement ps = prepareStatement(
1:             "insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:         int id = BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(length), length);
1:         ps.execute();
1:         ps.close();
1: 
1:         // Get last byte from the source stream.
1:         InputStream cmpIs = new LoopingAlphabetStream(length);
1:         cmpIs.skip(length -1);
1:         int srcLastByte = cmpIs.read();
1:         assertTrue(cmpIs.read() == -1);
1: 
1:         // Read everything first.
1:         int bytesToRead = 5000;
1:         ps = prepareStatement("select BLOBDATA from BLOBCLOB where ID=?");
1:         ps.setInt(1, id);
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         InputStream is = rs.getBlob(1).getBinaryStream(
1:                                         length - bytesToRead +1, bytesToRead);
1: 
1:         // Drain the stream, and make sure we are able to read the last byte.
1:         int lastByteRead = getLastByteInStream(is, bytesToRead);
1:         assertEquals(srcLastByte, lastByteRead);
1:         is.close();
1:         rs.close();
1: 
1:         // Read a portion of the stream.
1:         bytesToRead = 2000;
1:         rs = ps.executeQuery();
1:         rs.next();
1:         is = rs.getBlob(1).getBinaryStream(
1:                                         length - bytesToRead +1, bytesToRead);
1:         assertEquals(srcLastByte, lastByteRead);
1:         is.close();
1:         rs.close();
1: 
1:         // Read a very small portion of the stream.
1:         bytesToRead = 1;
1:         rs = ps.executeQuery();
1:         rs.next();
1:         is = rs.getBlob(1).getBinaryStream(
1:                                         length - bytesToRead +1, bytesToRead);
1:         assertEquals(srcLastByte, lastByteRead);
1:         is.close();
1:         rs.close();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Drains the stream and returns the last byte read from the stream.
1:      *
1:      * @param is stream to drain
1:      * @param expectedCount expected number of bytes (remaining) in the stream
1:      * @return The last byte read.
1:      * @throws AssertionError if there are too many/few bytes in the stream
1:      * @throws IOException if reading from the stream fails
1:      */
1:     public static int getLastByteInStream(InputStream is, int expectedCount)
1:             throws IOException {
1:         int read = 0;
1:         byte[] buf = new byte[256];
1:         assertTrue(buf.length > 0); // Do not allow an infinite loop here.
1:         while (true) {
1:             int readThisTime = is.read(buf, 0, buf.length);
1:             // -1 is expected, but catch all cases with a negative return value.
1:             if (readThisTime < 0) {
1:                 assertTrue("Invalid return value from stream",
1:                         readThisTime == -1);
1:                 fail("Reached EOF prematurely, expected " + expectedCount +
1:                         ", got " + read);
1:             } else if (readThisTime == 0) {
1:                 // Another special case that should not happen.
1:                 fail("Stream breaks contract, read zero bytes " + is);
1:             }
1:             read += readThisTime;
1:             if (read == expectedCount) {
1:                 return buf[readThisTime -1];
1:             } else if (read > expectedCount) {
1:                 fail("Too many bytes in stream, expected " + expectedCount +
1:                         "have " + read + "(EOF not reached/confirmed)");
1:             }
1:         }
1:     }
1: 
1:     /**
commit:28365b0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that draining a "sub-stream" from the Blob works.
1:      * This is a repro for DERBY-4061, where we ended up with an infinite loop.
1:      */
1:     public void testGetBinaryStreamLongDrain()
1:             throws IOException, SQLException {
1:         initializeLongBlob(); // Ignoring id for now, use instance variable.
1:         InputStream in = blob.getBinaryStream(2000, 5000);
1:         byte[] buf = new byte[256];
1:         while (in.read(buf, 0, buf.length) != -1) {
1:             // This should end when we have read all the bytes in the stream.
1:             // If the code hangs here, see DERBY-4061.
1:         }
1:         in.close();
1:         blob.free();
1:     }
commit:6b14720
/////////////////////////////////////////////////////////////////////////
1:         int bytesRead = 0;
1:         while ((bytesRead = contents.read(buffer)) > 0) {
1:             writer.write(buffer, 0, bytesRead);
commit:0c5c5aa
/////////////////////////////////////////////////////////////////////////
1:      * Tests the return count on insertion when the Blob is represented as a
1:      * byte array in memory.
1:      */
1:     public void testSetBytesReturnValueSmall()
0:             throws SQLException {
1:         Blob myBlob = getConnection().createBlob();
1:         byte[] byteBatch = new byte[] {
1:                     0x65, 0x66, 0x67, 0x68, 0x69,
1:                     0x65, 0x66, 0x67, 0x68, 0x69
1:                 };
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:         // Try again, overwrites the bytes.
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:         // Last time, start at a different index.
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(4, byteBatch));
1:     }
1: 
1:     /**
1:      * Tests the return count on insertion when the Blob is represented as a
1:      * temporary file on disk.
1:      */
1:     public void testSetBytesReturnValueLarge()
1:             throws IOException, SQLException {
1:         Blob myBlob = getConnection().createBlob();
1:         // Insert one MB, should cause Blob to spill to disk.
1:         OutputStream blobWriter = myBlob.setBinaryStream(1);
1:         transferAlphabetData(blobWriter, 1*1024*1024);
1:         byte[] byteBatch = new byte[] {
1:                     0x65, 0x66, 0x67, 0x68, 0x69,
1:                     0x65, 0x66, 0x67, 0x68, 0x69
1:                 };
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:         // Try again, overwrites the bytes.
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(1, byteBatch));
1:         // Start at a different, low index.
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(4, byteBatch));
1:         // Start at a different, higher index.
1:         assertEquals("Wrong insertion count",
1:                 byteBatch.length, myBlob.setBytes(512*1024, byteBatch));
1:     }
1: 
1:     /**
1:      * Tests the return count on insertion when the Blob is fetched from the
1:      * database and then modified.
1:      * <p>
1:      * The main point for this test is to provoke the transition from a
1:      * read-only internal representation to a writable representation.
1:      * For a Blob of "considerable" size, this involved going from a store
1:      * stream representation to a {@code LOBStreamControl} representation using
1:      * a temporary file.
1:      */
1:     public void testSetBytesReturnValueLargeStateChange()
1:             throws IOException, SQLException {
1:         // Get a Blob from the database, don't create an empty one.
1:         initializeLongBlob(); // Ignoring id for now, use instance variable.
1:         assertEquals("Wrong insertion count",
1:                 1, blob.setBytes(30000, new byte[] {0x69}));
1:         assertEquals("Wrong insertion count",
1:                 1, blob.setBytes(1, new byte[] {0x69}));
1:         assertEquals("Wrong insertion count",
1:                 2, blob.setBytes(1235, new byte[] {0x69, 0x69}));
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Transfers the specified number of bytes generated from the modern latin
1:      * alphabet (lowercase) to the destination stream.
1:      *
1:      * @param writer the destination
1:      * @param length number of bytes to write
1:      * @throws IOException if writing to the destination stream fails
1:      */
1:     public static void transferAlphabetData(OutputStream writer, long length)
1:             throws IOException {
1:         byte[] buffer = new byte[8*1024];
1:         LoopingAlphabetStream contents = new LoopingAlphabetStream(length);
0:         while (contents.read(buffer) > 0) {
0:             writer.write(buffer);
1:         }
1:     }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f697326
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         if (blob != null) {
1:             blob.free();
0:             blob = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
1:         blob = BlobClobTestSetup.getSampleBlob(getConnection());
1:         
0:         //call the buildHashSetMethod to initialize the
0:         //HashSet with the method signatures that are exempted 
0:         //from throwing a SQLException after free has been called
0:         //on the Clob object.
0:         buildHashSet();
1: 
/////////////////////////////////////////////////////////////////////////
1:      
1:     /**
1:      * Test that a lock held on the corresponding row is released when free() is
1:      * called on the Blob object.
1:      * @throws java.sql.SQLException 
1:      */
1:     public void testLockingAfterFree() throws SQLException
1:     {
1:         int id = initializeLongBlob();  // Opens blob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
1:         
1:         // Test that update goes through after the blob is closed
1:         blob.free();
1:         executeParallelUpdate(id, false);
1:         
1:         commit();
1:     }
1:     
1:     /**
1:      * Test that a lock held on the corresponding row is NOT released when
1:      * free() is called on the Blob object if the isolation level is
1:      * Repeatable Read
1:      * @throws java.sql.SQLException
1:      */
1:     public void testLockingAfterFreeWithRR() throws SQLException
1:     {
1:         getConnection().
1:                 setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:         int id = initializeLongBlob(); // Opens blob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
1:         
1:         // Test that update still times out after the blob is closed
1:         blob.free();
1:         executeParallelUpdate(id, true);
1:         
1:         // Test that the update goes through after the transaction has committed
1:         commit();
1:         executeParallelUpdate(id, false);
1:     }
1:     
1:      /**
1:      * Test that a lock held on the corresponding row is released when
1:      * free() is called on the Blob object if the isolation level is
1:      * Read Uncommitted
1:      * @throws java.sql.SQLException
1:      */
1:     public void testLockingAfterFreeWithDirtyReads() throws SQLException
1:     {
1:         getConnection().
1:                 setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         int id = initializeLongBlob(); // Opens blob object
1:         executeParallelUpdate(id, true); // Test that timeout occurs
1:         
1:        // Test that update goes through after the blob is closed
1:         blob.free();
1:         executeParallelUpdate(id, false);
1:         
1:         commit();
1:     }
1: 
1: 
1:     /**
1:      * Insert a row with a large blob into the test table.  Read the row from 
1:      * the database and assign the blob value to <code>blob</code>.
1:      * @return The id of the row that was inserted
1:      * @throws java.sql.SQLException 
1:      */
1:     private int initializeLongBlob() throws SQLException
1:     {
1:         // Blob needs to be larger than one page for locking to occur
1:         final int lobLength = 40000;
1: 
1:         // Insert a long Blob
1:         PreparedStatement ps =
1:                 prepareStatement("insert into BLOBCLOB(ID, BLOBDATA) values(?,?)");
1:         int id =BlobClobTestSetup.getID();
1:         ps.setInt(1, id);
1:         ps.setBinaryStream(2,
1:                            new LoopingAlphabetStream(lobLength), lobLength);
1:         ps.execute();
1:         ps.close();
1:         commit();
1: 
1:         // Fetch the Blob object from the database
1:         Statement st = createStatement();
1:         ResultSet rs =
1:                 st.executeQuery("select BLOBDATA from BLOBCLOB where ID=" + id);
1:         rs.next();
1:         blob = rs.getBlob(1);
1:         rs.close();
1:         st.close();
1: 
1:         return id;
1:     }
1:      
1: 
1:     /**
1:      * Try to update the row with the given error.  Flag a failure if a 
1:      * timeout occurs when not expected, and vice versa.
1:      * @param id The id of the row to be updated
1:      * @param timeoutExpected true if it is expected that the update times out
1:      * @throws java.sql.SQLException 
1:      */
1:     private void executeParallelUpdate(int id, boolean timeoutExpected) 
1:             throws SQLException
1:     {
1:         Connection conn2 = openDefaultConnection();
1:         Statement stmt2 = conn2.createStatement();
1: 
0:         try {
1:             stmt2.executeUpdate("update BLOBCLOB set CLOBDATA = 'New' where id=" 
1:                     + id);
1:             stmt2.close();
1:             conn2.commit();
1:             conn2.close();
1:             if (timeoutExpected) {
1:                 fail("FAIL - should have gotten lock timeout");
1:             }
1:          } catch (SQLException se) {
1:             stmt2.close();
1:             conn2.rollback();
1:             conn2.close();
1:             if (timeoutExpected) {
1:                 assertSQLState(LOCK_TIMEOUT, se);
1:             } else {               
1:                 throw se;
1:             }
1:         }
1:     }
1: 
1:     
1:     public static Test suite()
1:     {
1:         return new BlobClobTestSetup(
1:                 // Reduce lock timeouts so lock test case does not take too long
1:                 DatabasePropertyTestSetup.setLockTimeouts(
1:                         TestConfiguration.defaultSuite(BlobTest.class, false),
1:                         2, 
1:                         4));
1:    private static final String LOCK_TIMEOUT = "40XL1";
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:78afc5b
/////////////////////////////////////////////////////////////////////////
1:      * getBinaryStream(long pos, long length).
1:     public void testGetBinaryStreamLong()
/////////////////////////////////////////////////////////////////////////
1:     public void testGetBinaryStreamLongExceptionConditions()
/////////////////////////////////////////////////////////////////////////
0:         return  new BlobClobTestSetup(
0:                 TestConfiguration.defaultSuite(
0:                 BlobTest.class,
0:                 false));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
0:         blob = BlobClobTestSetup.getSampleBlob(getConnection());
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:         blob = BlobClobTestSetup.getSampleBlob(getXConnection());
/////////////////////////////////////////////////////////////////////////
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================