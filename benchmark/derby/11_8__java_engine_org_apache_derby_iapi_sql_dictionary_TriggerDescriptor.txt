2:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.TriggerDescriptor
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
13:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:bc2c59e: import org.apache.derby.iapi.services.io.ArrayUtil;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
2:eac0369: import org.apache.derby.iapi.sql.depend.Dependent;
2:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
2:eac0369: import org.apache.derby.iapi.error.StandardException;
1:bc2c59e: import org.apache.derby.iapi.types.DataTypeUtilities;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import java.sql.Timestamp;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.StatementType;
1:eac0369: import org.apache.derby.catalog.DependableFinder;
1:eac0369: import org.apache.derby.catalog.Dependable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:9213b42: import org.apache.derby.iapi.store.access.TransactionController;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:08313de: 
1:179e593: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:179e593: import org.apache.derby.iapi.sql.compile.Parser;
1:70a4f2d: import org.apache.derby.iapi.sql.compile.Visitable;
1:08313de: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A trigger.
1:eac0369:  * <p>
1:eac0369:  * We are dependent on TableDescriptors, SPSDescriptors (for our
1:eac0369:  * WHEN clause and our action).  Note that we don't strictly
1:eac0369:  * need to be dependent on out SPSes because we could just disallow
1:eac0369:  * anyone from dropping an sps of type 'T', but to keep dependencies
1:eac0369:  * uniform, we'll do be dependent.
1:eac0369:  * <p>
1:eac0369:  * We are a provider for DML (PreparedStatements or SPSes)
2:eac0369:  *
1:eac0369:  * The public methods for this class are:
1:eac0369:  *
1:eac0369:  * <ol>
1:eac0369:  * <li>getUUID
1:eac0369:  * <li>getName
1:eac0369:  * <li>getSchemaDescriptor
1:eac0369:  * <li>	public boolean listensForEvent(int event);
1:eac0369:  * <li>	public int getTriggerEventMask();
1:eac0369:  * <li>	public Timestamp getCreationTimestamp();
1:eac0369:  * <li>	public boolean isBeforeTrigger();
1:eac0369:  * <li> public boolean isRowTrigger();
1:eac0369:  * <li> public UUID getActionId();
1:eac0369:  * <li> public SPSDescriptor getActionSPS();
1:eac0369:  * <li>	public UUID getWhenClauseId();
1:eac0369:  * <li>	public SPSDescriptor getWhenClauseSPS()
1:d9878ca:  * <li> public String getWhenClauseText();
1:eac0369:  * <li>	public TableDescriptor getTableDescriptor()
1:eac0369:  * <li> public ReferencedColumns getReferencedColumnsDescriptor()
1:eac0369:  * <li> public int[] getReferencedCols();
1:a6f9586:  * <li> public int[] getReferencedColsInTriggerAction();
1:09bee7d:  * <li> public boolean enforced();
1:eac0369:  * <li> public void setEnabled();
1:eac0369:  * <li> public void setDisabled();
1:eac0369:  * <li> public boolean needsToFire(int stmtType, int[] modifiedCols)
1:eac0369:  * <li> public String getTriggerDefinition();
1:eac0369:  * <li> public boolean getReferencingOld();
1:eac0369:  * <li> public boolean getReferencingNew();
1:eac0369:  * <li> public String getOldReferencingName();
1:eac0369:  * <li> public String getNewReferencingName();
1:eac0369:  * </ol>
1:eac0369:  */
1:f2fad75: public class TriggerDescriptor extends UniqueSQLObjectDescriptor
1:f2fad75: 	implements Provider, Dependent, Formatable 
4:eac0369: {
1:eac0369: 	// field that we want users to be able to know about
1:eac0369: 	public static final int SYSTRIGGERS_STATE_FIELD = 8;
1:eac0369: 
1:eac0369: 	public static final int TRIGGER_EVENT_UPDATE = 1;
1:eac0369: 	public static final int TRIGGER_EVENT_DELETE = 2;
1:eac0369: 	public static final int TRIGGER_EVENT_INSERT = 4;
1:eac0369: 
1:eac0369: 	
1:eac0369: 	private	UUID				id;
1:eac0369: 	private String				name;
1:eac0369: 	private String				oldReferencingName;
1:eac0369: 	private String				newReferencingName;
1:eac0369: 	private String				triggerDefinition;
1:eac0369: 	private SchemaDescriptor	sd;
1:eac0369: 	private int					eventMask;
1:eac0369: 	private boolean				isBefore;
1:eac0369: 	private boolean 			isRow;
1:eac0369: 	private boolean				referencingOld;
1:eac0369: 	private boolean				referencingNew;
1:eac0369: 	private	TableDescriptor		td;
1:eac0369: 	private	UUID				actionSPSId;
1:eac0369: 	private SPSDescriptor		actionSPS;
1:eac0369: 	private	UUID				whenSPSId;
1:eac0369: 	private SPSDescriptor		whenSPS;
1:eac0369: 	private	boolean				isEnabled;
1:eac0369: 	private	int[]				referencedCols;
1:a6f9586: 	private	int[]				referencedColsInTriggerAction;
1:eac0369: 	private	Timestamp			creationTimestamp;
1:eac0369: 	private UUID				triggerSchemaId;
1:eac0369: 	private UUID				triggerTableId;
1:d9878ca:     private String              whenClauseText;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Niladic constructor, for formatable
1:eac0369: 	 */
1:eac0369: 	public TriggerDescriptor() {}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor.  Used when creating a trigger from SYS.SYSTRIGGERS
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary 	the data dictionary
1:eac0369: 	 * @param sd	the schema descriptor for this trigger
1:eac0369: 	 * @param id	the trigger id
1:eac0369: 	 * @param name	the trigger name
1:eac0369: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
1:eac0369: 	 * @param isBefore	is this a before (as opposed to after) trigger 
1:eac0369: 	 * @param isRow		is this a row trigger or statement trigger
1:09bee7d:      * @param isEnabled  is this trigger enabled or disabled
1:eac0369: 	 * @param td		the table upon which this trigger is defined
1:eac0369: 	 * @param whenSPSId	the sps id for the when clause (may be null)
1:eac0369: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1:eac0369: 	 * @param creationTimestamp	when was this trigger created?
1:eac0369: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1:a6f9586: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1:a6f9586: 	 *						action reference through old/new transition variables
1:a6f9586: 	 *						(may be null)
1:eac0369: 	 * @param triggerDefinition The original user text of the trigger action
1:eac0369: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1:eac0369: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1:eac0369: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1:eac0369: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1:d9878ca:      * @param whenClauseText the SQL text of the WHEN clause, or {@code null}
1:d9878ca:      *                       if there is no WHEN clause
1:eac0369: 	 */
1:3221b8c:     TriggerDescriptor
1:eac0369: 	(
1:eac0369: 		DataDictionary		dataDictionary,
1:eac0369: 		SchemaDescriptor	sd,
1:eac0369: 		UUID				id,
1:eac0369: 		String				name,
1:eac0369: 		int					eventMask,
1:eac0369: 		boolean				isBefore,
1:eac0369: 		boolean				isRow,
1:eac0369: 		boolean				isEnabled,
1:eac0369: 		TableDescriptor		td,
1:eac0369: 		UUID				whenSPSId,
1:eac0369: 		UUID				actionSPSId,
1:eac0369: 		Timestamp			creationTimestamp,
1:eac0369: 		int[]				referencedCols,
1:a6f9586: 		int[]				referencedColsInTriggerAction,
1:eac0369: 		String				triggerDefinition,
1:eac0369: 		boolean				referencingOld,
1:eac0369: 		boolean				referencingNew,
1:eac0369: 		String				oldReferencingName,
1:d9878ca:         String              newReferencingName,
1:d9878ca:         String              whenClauseText
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		super(dataDictionary);
1:eac0369: 		this.id = id;
1:eac0369: 		this.sd = sd;
1:eac0369: 		this.name = name;
1:eac0369: 		this.eventMask = eventMask;
1:eac0369: 		this.isBefore = isBefore;
1:eac0369: 		this.isRow = isRow;
1:eac0369: 		this.td = td;
1:eac0369: 		this.actionSPSId = actionSPSId; 
1:eac0369: 		this.whenSPSId = whenSPSId;
1:eac0369: 		this.isEnabled = isEnabled;
1:eac0369: 		this.referencedCols = referencedCols;
1:bc2c59e: 		setReferencedColsInTriggerAction( referencedColsInTriggerAction );
1:bc2c59e: 		this.creationTimestamp = DataTypeUtilities.clone( creationTimestamp );
1:eac0369: 		this.triggerDefinition = triggerDefinition;
1:eac0369: 		this.referencingOld = referencingOld;
1:eac0369: 		this.referencingNew = referencingNew;
1:eac0369: 		this.oldReferencingName = oldReferencingName;
1:eac0369: 		this.newReferencingName = newReferencingName;
1:d9878ca:         this.whenClauseText = whenClauseText;
1:eac0369: 		triggerSchemaId = sd.getUUID();
1:eac0369: 		triggerTableId = td.getUUID();
1:d9878ca: 	}	
1:d9878ca: 		
1:179e593: 		
1:d9878ca: 	/**
1:eac0369: 	 * Get the trigger UUID
1:eac0369: 	 *
1:eac0369: 	 * @return the id
1:d9878ca: 	 */
1:eac0369: 	public UUID getUUID()
1:eac0369: 	{
1:eac0369: 		return id;
5:eac0369: 	}
1:9213b42: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger name
1:eac0369: 	 *
1:eac0369: 	 * @return	the name
1:eac0369: 	 */
1:eac0369: 	public String getName()
1:eac0369: 	{
1:eac0369: 		return name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public UUID getTableId() {
1:eac0369: 		return triggerTableId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the triggers schema descriptor
1:eac0369: 	 *
1:eac0369: 	 * @return the schema descriptor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	 public SchemaDescriptor getSchemaDescriptor()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (sd == null)
1:eac0369: 		{
1:eac0369: 			sd = getDataDictionary().getSchemaDescriptor(triggerSchemaId, null);
1:eac0369: 		}
1:eac0369: 		return sd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicate whether this trigger listens for this
1:eac0369: 	 * type of event.
1:eac0369: 	 *
1:eac0369: 	 * @param event TRIGGER_EVENT_XXXX
1:eac0369: 	 *
1:eac0369: 	 * @return true if it listens to the specified event.
1:eac0369: 	 */ 
1:eac0369: 	public boolean listensForEvent(int event)
1:eac0369: 	{
1:eac0369: 		return (event & eventMask) == event;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger event mask.  Currently, a trigger
1:eac0369: 	 * may only listen for a single event, though it may
1:eac0369: 	 * OR multiple events in the future.
1:eac0369: 	 *
1:eac0369: 	 * @return the trigger event mask
1:eac0369: 	 */
1:eac0369: 	public int getTriggerEventMask()
1:eac0369: 	{
1:eac0369: 		return eventMask;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the time that this trigger was created.
1:eac0369: 	 *
1:eac0369: 	 * @return the time the trigger was created
1:eac0369: 	 */
1:eac0369: 	public Timestamp getCreationTimestamp()
1:eac0369: 	{
1:bc2c59e: 		return DataTypeUtilities.clone( creationTimestamp );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a before trigger
1:eac0369: 	 *
1:eac0369: 	 * @return true if it is a before trigger
1:eac0369: 	 */
1:eac0369: 	public boolean isBeforeTrigger()
1:eac0369: 	{
1:eac0369: 		return isBefore;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a row trigger
1:eac0369: 	 *
1:eac0369: 	 * @return true if it is a before trigger
1:eac0369: 	 */
1:eac0369: 	public boolean isRowTrigger()
1:eac0369: 	{
1:eac0369: 		return isRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger action sps UUID
1:eac0369: 	 *
1:eac0369: 	 * @return the uuid of the sps action
1:eac0369: 	 */
1:eac0369: 	public UUID getActionId()
1:eac0369: 	{
1:eac0369: 		return actionSPSId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:179e593: 	 * Get the trigger action sps from SYSSTATEMENTS. If we find that
1:179e593: 	 * the sps is invalid and the trigger is defined at row level and it
1:179e593: 	 * has OLD/NEW transient variables through REFERENCES clause, then
1:179e593: 	 * the sps from SYSSTATEMENTS may not be valid anymore. In such a 
1:179e593: 	 * case, we regenerate the trigger action sql and use that for the
1:179e593: 	 * sps and update SYSSTATEMENTS using this new sps. This update of
1:179e593: 	 * SYSSTATEMENTS was introduced with DERBY-4874
1:eac0369: 	 *
1:179e593: 	 * @param lcc	The LanguageConnectionContext to use.
1:eac0369: 	 * @return the trigger action sps
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public SPSDescriptor getActionSPS(LanguageConnectionContext lcc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:50734d8:         return getSPS(lcc, false /* isWhenClause */);
1:50734d8:     }
1:50734d8: 
1:50734d8:     /**
1:50734d8:      * Get the SPS for the triggered SQL statement or the WHEN clause.
1:50734d8:      *
1:50734d8:      * @param lcc the LanguageConnectionContext to use
1:50734d8:      * @param isWhenClause {@code true} if the SPS for the WHEN clause is
1:50734d8:      *   requested, {@code false} if it is the triggered SQL statement
1:50734d8:      * @return the requested SPS
1:50734d8:      * @throws StandardException if an error occurs
1:50734d8:      */
1:50734d8:     private SPSDescriptor getSPS(LanguageConnectionContext lcc,
1:50734d8:                                  boolean isWhenClause)
1:50734d8:             throws StandardException
1:50734d8:     {
1:50734d8:         DataDictionary dd = getDataDictionary();
1:50734d8:         SPSDescriptor sps = isWhenClause ? whenSPS : actionSPS;
1:50734d8:         UUID spsId = isWhenClause ? whenSPSId : actionSPSId;
1:50734d8:         String originalSQL = isWhenClause ? whenClauseText : triggerDefinition;
1:50734d8: 
1:50734d8:         if (sps == null) {
1:eac0369: 			//bug 4821 - do the sysstatement look up in a nested readonly
1:eac0369: 			//transaction rather than in the user transaction. Because of
1:eac0369: 			//this, the nested compile transaction which is attempting to
1:eac0369: 			//compile the trigger will not run into any locking issues with
1:eac0369: 			//the user transaction for sysstatements.
1:eac0369: 			lcc.beginNestedTransaction(true);
1:50734d8:             sps = dd.getSPSDescriptor(spsId);
1:eac0369: 			lcc.commitNestedTransaction();
1:eac0369: 		}
1:50734d8: 
1:179e593: 		//We need to regenerate the trigger action sql if 
1:179e593: 		//1)the trigger is found to be invalid, 
1:179e593: 		//2)the trigger is defined at row level (that is the only kind of 
1:179e593: 		//  trigger which allows reference to individual columns from 
1:179e593: 		//  old/new row)
1:179e593: 		//3)the trigger action plan has columns that reference 
1:d9d1bc8: 		//  old/new row columns(if we are working with pre-10.9 db,
1:d9d1bc8: 		//  meaning we are in soft-upgrade mode, then we won't have
1:d9d1bc8: 		//  information about the actual trigger action columns since
1:d9d1bc8: 		//  we didn't keep that info in those releases. For such dbs,
1:d9d1bc8: 		//  we will just check if they are using REFERENCING OLD and/or
1:d9d1bc8: 		//  NEW clause.)
1:179e593: 		//This code was added as part of DERBY-4874 where the Alter table 
1:179e593: 		//had changed the length of a varchar column from varchar(30) to 
1:179e593: 		//varchar(64) but the trigger action plan continued to use varchar(30).
1:179e593: 		//To fix varchar(30) in trigger action sql to varchar(64), we need
1:179e593: 		//to regenerate the trigger action sql. This new trigger action sql
1:179e593: 		//will then get updated into SYSSTATEMENTS table.
1:d9d1bc8: 		boolean in10_9_orHigherVersion = dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null);
1:d9d1bc8: 		boolean usesReferencingClause = (in10_9_orHigherVersion) ? 
1:d9d1bc8: 				referencedColsInTriggerAction != null :
1:d9d1bc8: 					(referencingOld || referencingNew);
1:d9d1bc8: 
1:50734d8:         if ((!sps.isValid() ||
1:50734d8:                 (sps.getPreparedStatement() == null)) &&
1:d9d1bc8: 					isRow &&
1:d9d1bc8: 					usesReferencingClause)
1:179e593: 		{
1:ddc6707:             CompilerContext newCC = lcc.pushCompilerContext(
1:50734d8:                     dd.getSchemaDescriptor(sps.getCompSchemaId(), null));
1:179e593: 			Parser	pa = newCC.getParser();
1:50734d8:             Visitable stmtnode =
1:50734d8:                     isWhenClause ? pa.parseSearchCondition(originalSQL)
1:50734d8:                                  : pa.parseStatement(originalSQL);
1:179e593: 			lcc.popCompilerContext(newCC);
1:54844c3:             int[] cols;
1:54844c3:             cols = dd.examineTriggerNodeAndCols(stmtnode,
1:54844c3: 					oldReferencingName,
1:54844c3: 					newReferencingName,
1:54844c3: 					originalSQL,
1:54844c3: 					referencedCols,
1:54844c3: 					referencedColsInTriggerAction,
1:54844c3:                     0,
1:617d55a: 					getTableDescriptor(),
1:54844c3: 					-1,
1:54844c3:                     false,
1:54844c3:                     null);
1:50734d8: 
1:50734d8:             String newText = dd.getTriggerActionString(stmtnode,
1:179e593: 					oldReferencingName,
1:179e593: 					newReferencingName,
1:50734d8:                     originalSQL,
1:179e593: 					referencedCols,
1:179e593: 					referencedColsInTriggerAction,
1:179e593: 					0,
1:617d55a: 					getTableDescriptor(),
1:179e593: 					-1,
1:0cefeda:                     false,
1:54844c3:                     null,
1:54844c3:                     cols);
1:50734d8: 
1:50734d8:             if (isWhenClause) {
1:50734d8:                 // The WHEN clause is not a full SQL statement, just a search
1:50734d8:                 // condition, so we need to turn it into a statement in order
1:50734d8:                 // to create an SPS.
1:50734d8:                 newText = "VALUES " + newText;
1:50734d8:             }
1:50734d8: 
1:50734d8:             sps.setText(newText);
1:50734d8: 
1:179e593: 			//By this point, we are finished transforming the trigger action if
1:179e593: 			//it has any references to old/new transition variables.
1:179e593: 		}
1:50734d8: 
1:50734d8:         return sps;
1:eac0369: 	}
1:179e593: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger when clause sps UUID
1:eac0369: 	 *
1:eac0369: 	 * @return the uuid of the sps action
1:eac0369: 	 */
1:eac0369: 	public UUID getWhenClauseId()
1:eac0369: 	{
1:eac0369: 		return whenSPSId;
1:eac0369: 	}
1:179e593: 
1:d9878ca:     /**
1:d9878ca:      * Get the SQL text of the WHEN clause.
1:d9878ca:      * @return SQL text for the WHEN clause, or {@code null} if there is
1:d9878ca:      *   no WHEN clause
1:d9878ca:      */
1:d9878ca:     public String getWhenClauseText() {
1:d9878ca:         return whenClauseText;
1:d9878ca:     }
1:d9878ca: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger when clause sps 
1:eac0369: 	 *
1:50734d8:      * @param lcc the LanguageConnectionContext to use
1:eac0369: 	 * @return the sps of the when clause
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:50734d8:     public SPSDescriptor getWhenClauseSPS(LanguageConnectionContext lcc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:50734d8:         if (whenSPSId == null) {
1:50734d8:             // This trigger doesn't have a WHEN clause.
1:50734d8:             return null;
1:50734d8:         }
1:50734d8: 
1:50734d8:         return getSPS(lcc, true /* isWhenClause */);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the trigger table descriptor
1:eac0369: 	 *
1:eac0369: 	 * @return the table descripor upon which this trigger
1:eac0369:  	 * is declared
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getTableDescriptor()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (td == null)
1:eac0369: 		{
1:eac0369: 			td = getDataDictionary().getTableDescriptor(triggerTableId);
1:eac0369: 		}
1:eac0369: 		return td;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the referenced table descriptor for this trigger.
1:eac0369: 	 *
1:eac0369: 	 * @return the referenced table descriptor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	// caller converts referencedCols to referencedColsDescriptor...
1:eac0369: //  	public ReferencedColumns getReferencedColumnsDescriptor()
1:eac0369: //  		throws StandardException
1:eac0369: //  	{
1:eac0369: //  		return (referencedCols == null) ? 
1:eac0369: //  				(ReferencedColumns)null :
1:eac0369: //  				new ReferencedColumnsDescriptorImpl(referencedCols);
1:eac0369: //  	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the referenced column array for this trigger, used in "alter table
1:eac0369: 	 * drop column", we get the handle and change it
1:eac0369: 	 *
1:eac0369: 	 * @return the referenced column array
1:eac0369: 	 */
1:eac0369: 	public int[] getReferencedCols()
1:eac0369: 	{
1:bc2c59e: 		return ArrayUtil.copy( referencedCols );
1:eac0369: 	}
1:eac0369: 
1:e2245e6:     /** Update the array of referenced columns */
1:e2245e6:     public  void    setReferencedCols( int[] newCols )
1:e2245e6:     {
1:e2245e6:         referencedCols = ArrayUtil.copy( newCols );
1:e2245e6:     }
1:e2245e6: 
1:eac0369: 	/**
1:a6f9586: 	 * Get the referenced column array for the trigger action columns.
1:a6f9586: 	 *
1:a6f9586: 	 * @return the referenced column array
1:a6f9586: 	 */
1:a6f9586: 	public int[] getReferencedColsInTriggerAction()
1:a6f9586: 	{
1:bc2c59e:         return ArrayUtil.copy( referencedColsInTriggerAction );
1:a6f9586: 	}
1:a6f9586: 
1:bc2c59e:     /** Set the referenced column array for trigger actions */
1:bc2c59e:     public  void    setReferencedColsInTriggerAction( int[] referencedColsInTriggerAction )
1:bc2c59e:     {
1:bc2c59e: 		this.referencedColsInTriggerAction = ArrayUtil.copy( referencedColsInTriggerAction );
1:bc2c59e:     }
1:bc2c59e: 
1:a6f9586: 	/**
1:09bee7d:      * Is this trigger enforced
1:eac0369: 	 *
1:09bee7d:      * @return true if it is enforced
1:eac0369: 	 */
1:eac0369: 	public boolean isEnabled()
1:eac0369: 	{
1:eac0369: 		return isEnabled;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Mark this trigger as enforced
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setEnabled()
1:eac0369: 	{
1:eac0369: 		isEnabled = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this trigger as disabled
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setDisabled()
1:eac0369: 	{
1:eac0369: 		isEnabled = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this trigger need to fire on this type of
1:eac0369: 	 * DML?
1:eac0369: 	 *
1:6b50965: 	 * @param stmtType	the type of DML 
1:eac0369: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
1:eac0369: 	 * @param modifiedCols	the columns modified, or null for all
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public boolean needsToFire(int stmtType, int[] modifiedCols)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!((stmtType == StatementType.INSERT) ||
1:eac0369: 								 (stmtType == StatementType.BULK_INSERT_REPLACE) ||
1:eac0369: 								 (stmtType == StatementType.UPDATE) ||
1:eac0369: 								 (stmtType == StatementType.DELETE)))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("invalid statement type "+stmtType);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If we are disabled, we never fire
1:eac0369: 		*/
1:eac0369: 		if (!isEnabled)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (stmtType == StatementType.INSERT)
1:eac0369: 		{
1:eac0369:  			return (eventMask & TRIGGER_EVENT_INSERT) == eventMask;
1:eac0369: 		}
1:eac0369: 		if (stmtType == StatementType.DELETE) 
1:eac0369: 		{
1:eac0369: 			return (eventMask & TRIGGER_EVENT_DELETE) == eventMask;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// this is a temporary restriction, but it may not be lifted
1:eac0369: 		// anytime soon.
1:eac0369: 		if (stmtType == StatementType.BULK_INSERT_REPLACE)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NO_BULK_INSERT_REPLACE_WITH_TRIGGER, 
1:eac0369: 												 getTableDescriptor().getQualifiedName(), name);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if update, only relevant if columns intersect
1:eac0369: 		return ((eventMask & TRIGGER_EVENT_UPDATE) == eventMask) &&
1:eac0369: 				ConstraintDescriptor.doColumnsIntersect(modifiedCols, referencedCols);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the original trigger definition.
1:eac0369: 	 *
1:eac0369: 	 * @return The trigger definition.
1:eac0369: 	 */
1:eac0369: 	public String getTriggerDefinition()
1:eac0369: 	{
1:eac0369: 		return triggerDefinition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get whether or not OLD was replaced
1:eac0369: 	 * in the REFERENCING clause.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not OLD was replaced
1:eac0369: 	 * in the REFERENCING clause.
1:eac0369: 	 */
1:eac0369: 	public boolean getReferencingOld()
1:eac0369: 	{
1:eac0369: 		return referencingOld;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get whether or not NEW was replaced
1:eac0369: 	 * in the REFERENCING clause.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not NEW was replaced
1:eac0369: 	 * in the REFERENCING clause.
1:eac0369: 	 */
1:eac0369: 	public boolean getReferencingNew()
1:eac0369: 	{
1:eac0369: 		return referencingNew;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the old Referencing name, if any,
1:eac0369: 	 * from the REFERENCING clause.
1:eac0369: 	 *
1:eac0369: 	 * @return The old Referencing name, if any,
1:eac0369: 	 * from the REFERENCING clause.
1:eac0369: 	 */
1:eac0369: 	public String getOldReferencingName()
1:eac0369: 	{
1:eac0369: 		return oldReferencingName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the new Referencing name, if any,
1:eac0369: 	 * from the REFERENCING clause.
1:eac0369: 	 *
1:eac0369: 	 * @return The new Referencing name, if any,
1:eac0369: 	 * from the REFERENCING clause.
1:eac0369: 	 */
1:eac0369: 	public String getNewReferencingName()
1:eac0369: 	{
1:eac0369: 		return newReferencingName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "TRIGGER: "+name;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// PROVIDER INTERFACE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 	 * @return the stored form of this provider
1:eac0369: 	 *
1:eac0369: 	 * @see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public DependableFinder getDependableFinder() 
1:eac0369: 	{
1:eac0369: 	    return getDependableFinder(StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Provider.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this provider.
1:eac0369: 	 */
1:eac0369: 	public String getObjectName()
1:eac0369: 	{
1:eac0369: 		return name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's UUID
1:eac0369: 	 *
1:eac0369: 	 * @return 	The provider's UUID
1:eac0369: 	 */
1:eac0369: 	public UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return id;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's type.
1:eac0369: 	 *
1:eac0369: 	 * @return char		The provider's type.
1:eac0369: 	 */
1:eac0369: 	public String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.TRIGGER;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// DEPENDENT INTERFACE
1:eac0369: 	//
1:eac0369: 	// Triggers are dependent on the underlying table,
1:eac0369:  	// and their spses (for the trigger action and the WHEN
1:eac0369: 	// clause).
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Check that all of the dependent's dependencies are valid.
1:eac0369: 	 *
1:eac0369: 	 * @return true if the dependent is currently valid
1:eac0369: 	 */
1:eac0369: 	public synchronized boolean isValid()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prepare to mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).
1:eac0369: 	 *
1:eac0369: 	 * @param action	The action causing the invalidation
1:eac0369: 	 * @param p			the provider
1:eac0369: 	 * @param lcc		the language connection context
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public void prepareToInvalidate
1:eac0369: 	(
1:eac0369: 		Provider 					p, 
1:eac0369: 		int							action, 
1:eac0369: 		LanguageConnectionContext	lcc
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:eac0369: 		switch (action)
1:eac0369: 		{
1:eac0369: 			/*
1:cc67949:             ** We are dependent on the underlying table, our SPSs, any tables
1:cc67949:             ** or other SQL objects that are referenced from the trigger, and
1:71408ab: 			** privileges on various objects.  (we should be dropped before our 
1:71408ab: 			** table is dropped. Also, we should be dropped before revoke 
1:71408ab: 			** RESTRICT privilege is issued otherwise revoke RESTRICT will  
1:71408ab: 			** throw an exception).
1:71408ab: 			** Currently, in Derby, an execute routine privilege can be revoked
1:71408ab: 			** only if there are no dependents on that privilege. When revoke 
1:71408ab: 			** execute RESTRICT is exectued, all the dependents will receive
1:71408ab: 			** REVOKE_PRIVILEGE_RESTRICT and they should throw exception. 
1:71408ab: 			** We handle this for TriggerDescriptor by throwning an exception 
1:71408ab: 			** below. For all the other types of revoke privileges, for 
1:71408ab: 			** instance, SELECT, UPDATE, DELETE, INSERT, REFERENCES, 
1:71408ab: 			** TRIGGER, we don't do anything here and later in makeInvalid, we 
1:71408ab: 			** make the TriggerDescriptor drop itself. 
1:eac0369: 			*/
1:eac0369: 		    case DependencyManager.DROP_TABLE:
1:81ad58c: 		    case DependencyManager.DROP_SYNONYM:
1:eac0369: 		    case DependencyManager.DROP_SPS:
1:cc67949:             case DependencyManager.DROP_VIEW:
1:eac0369: 		    case DependencyManager.RENAME:
1:71408ab: 		    case DependencyManager.REVOKE_PRIVILEGE_RESTRICT:
1:cc67949:             case DependencyManager.DROP_METHOD_ALIAS:
1:eac0369: 				DependencyManager dm = getDataDictionary().getDependencyManager();
1:eac0369: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
1:eac0369: 									dm.getActionString(action), 
1:eac0369: 									p.getObjectName(), "TRIGGER", name);
1:9213b42: 
1:08313de: 				/*
1:eac0369: 			** The trigger descriptor depends on the trigger table.
1:eac0369: 			** This means that we get called whenever anything happens
1:eac0369: 			** to the trigger table. There are so many cases where this
1:eac0369: 			** can happen that it doesn't make sense to have an assertion
1:eac0369: 			** here to check whether the action was expected (it makes
1:eac0369: 			** the code hard to maintain, and creates a big switch statement).
1:eac0369: 			*/
1:eac0369: 			default:
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).  Always an error
1:eac0369: 	 * for a trigger -- should never have gotten here.
1:eac0369: 	 *
2:eac0369: 	 * @param 	lcc the language connection context
1:eac0369: 	 * @param	action	The action causing the invalidation
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if called in sanity mode
1:eac0369: 	 */
1:eac0369: 	public void makeInvalid(int action, LanguageConnectionContext lcc) throws StandardException
1:eac0369: 	{
1:eac0369: 		// No sanity check for valid action. Trigger descriptors depend on
1:eac0369: 		// the trigger table, so there is a very large number of actions
1:eac0369: 		// that we would have to check against. This is hard to maintain,
1:eac0369: 		// so don't bother.
1:3d7a3d4: 
1:3d7a3d4: 		switch (action)
1:08313de: 		{
1:3d7a3d4: 			// invalidate this trigger descriptor
1:3d7a3d4: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1:3d7a3d4: 				DependencyManager dm = getDataDictionary().getDependencyManager();
1:3d7a3d4: 				dm.invalidateFor(this, DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1:3d7a3d4: 				break;
1:3d7a3d4: 
1:3d7a3d4: 			// When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1:3d7a3d4: 			// types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1:3d7a3d4: 			// make the TriggerDescriptor drop itself. 
1:eb38311: 			// Ditto for revoking a role conferring a privilege.
1:3d7a3d4: 			case DependencyManager.REVOKE_PRIVILEGE:
1:eb38311: 			case DependencyManager.REVOKE_ROLE:
1:9213b42:                 drop(lcc);
1:3d7a3d4: 
1:eb38311: 				lcc.getLastActivation().addWarning(
1:eb38311: 					StandardException.newWarning(
1:eb38311: 						SQLState.LANG_TRIGGER_DROPPED,
1:eb38311: 						this.getObjectName() ));
1:3d7a3d4: 				break;
1:3d7a3d4: 
1:3d7a3d4: 			default:
1:3d7a3d4: 				break;
1:08313de: 		}
1:eb38311: 		
1:eac0369: 	}
1:08313de:     
1:9213b42:     public void drop(LanguageConnectionContext   lcc) throws StandardException
1:9213b42:     {
1:d9d1bc8:         DataDictionary dd = getDataDictionary();
1:9213b42:         DependencyManager dm = getDataDictionary().getDependencyManager();
1:9213b42:         TransactionController tc = lcc.getTransactionExecute();
1:9213b42:         dm.invalidateFor(this, DependencyManager.DROP_TRIGGER, lcc);
1:9213b42: 
1:9213b42:         // Drop the trigger
1:9213b42:         dd.dropTriggerDescriptor(this, tc);
1:9213b42: 
1:9213b42:         // Clear the dependencies for the trigger 
1:9213b42:         dm.clearDependencies(lcc, this);
1:9213b42: 
1:9213b42:         // Drop the spses
1:9213b42:         SPSDescriptor spsd = dd.getSPSDescriptor(this.getActionId());
1:9213b42: 
1:9213b42:         // there shouldn't be any dependencies, but in case
1:9213b42:         // there are, lets clear them
1:9213b42:         dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);
1:9213b42:         dm.clearDependencies(lcc, spsd);
1:9213b42:         dd.dropSPSDescriptor(spsd, tc);
1:9213b42:         
1:9213b42:         if (getWhenClauseId() != null)
1:9213b42:         {   
1:9213b42:             spsd = dd.getSPSDescriptor(getWhenClauseId());
1:9213b42:             dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);
1:9213b42:             dm.clearDependencies(lcc, spsd);
1:9213b42:             dd.dropSPSDescriptor(spsd, tc);
1:9213b42:         }
1:9213b42:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// FORMATABLE
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in)
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		id = (UUID)in.readObject();
1:eac0369: 		name = (String)in.readObject();
1:eac0369: 		triggerSchemaId = (UUID)in.readObject();
1:eac0369: 		triggerTableId = (UUID)in.readObject();
1:eac0369: 		eventMask = in.readInt();
1:eac0369: 		isBefore = in.readBoolean();
1:eac0369: 		isRow = in.readBoolean();
1:eac0369: 		isEnabled = in.readBoolean();
1:eac0369: 		whenSPSId = (UUID)in.readObject();
1:eac0369: 		actionSPSId = (UUID)in.readObject();
1:eac0369: 		int length = in.readInt();
1:eac0369: 		if (length != 0)
1:eac0369: 		{
1:eac0369: 			referencedCols = new int[length];
1:eac0369: 			for (int i = 0; i < length; i++)
1:eac0369: 			{
1:eac0369: 				referencedCols[i] = in.readInt();
1:eac0369: 			}
1:eac0369: 		}
1:a6f9586: 		length = in.readInt();
1:a6f9586: 		if (length != 0)
1:a6f9586: 		{
1:a6f9586: 			referencedColsInTriggerAction = new int[length];
1:a6f9586: 			for (int i = 0; i < length; i++)
1:a6f9586: 			{
1:a6f9586: 				referencedColsInTriggerAction[i] = in.readInt();
1:a6f9586: 			}
1:a6f9586: 		}
1:eac0369: 		triggerDefinition = (String)in.readObject();
1:eac0369: 		referencingOld = in.readBoolean();
1:eac0369: 		referencingNew = in.readBoolean();
1:eac0369: 		oldReferencingName = (String)in.readObject();
1:eac0369: 		newReferencingName = (String)in.readObject();
1:211adc3:         whenClauseText = (String) in.readObject();
1:eac0369: 	}
1:eac0369: 
1:e645861: 	protected DataDictionary getDataDictionary()
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369:  		  note: we need to do this since when this trigger is read back from
1:eac0369: 		  disk (when it is associated with a sps), the dataDictionary has not 
1:eac0369:  		  been initialized and therefore can give a NullPointerException
1:eac0369:  		*/
1:eac0369: 		DataDictionary dd = super.getDataDictionary();
1:eac0369:  		if (dd == null)
1:eac0369:  		{
1:eac0369:   			LanguageConnectionContext lcc = (LanguageConnectionContext)
1:a0dbbd7: 				getContext(LanguageConnectionContext.CONTEXT_ID);
1:eac0369:   			dd = lcc.getDataDictionary();
1:eac0369: 			setDataDictionary(dd);
1:eac0369:   		}
1:eac0369: 		return dd;
1:eac0369:  	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal( ObjectOutput out )
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(triggerSchemaId != null,
1:eac0369: 				"triggerSchemaId expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(triggerTableId != null,
1:eac0369: 				"triggerTableId expected to be non-null");
1:eac0369: 		}
1:eac0369: 		out.writeObject(id);
1:eac0369: 		out.writeObject(name);
1:eac0369: 		out.writeObject(triggerSchemaId);
1:eac0369: 		out.writeObject(triggerTableId);
1:eac0369: 		out.writeInt(eventMask);
1:eac0369: 		out.writeBoolean(isBefore);
1:eac0369: 		out.writeBoolean(isRow);
1:eac0369: 		out.writeBoolean(isEnabled);
1:eac0369: 		out.writeObject(whenSPSId);
1:eac0369: 		out.writeObject(actionSPSId);
1:eac0369: 		if (referencedCols == null)
1:eac0369: 		{
1:eac0369: 			out.writeInt(0);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			out.writeInt(referencedCols.length);
1:eac0369: 			for (int i = 0; i < referencedCols.length; i++)
1:eac0369: 			{
1:eac0369: 				out.writeInt(referencedCols[i]);
1:eac0369: 			}
1:eac0369: 		}	
1:a6f9586: 		if (referencedColsInTriggerAction == null)
1:a6f9586: 		{
1:a6f9586: 			out.writeInt(0);
1:a6f9586: 		}
1:a6f9586: 		else
1:a6f9586: 		{
1:a6f9586: 			out.writeInt(referencedColsInTriggerAction.length);
1:a6f9586: 			for (int i = 0; i < referencedColsInTriggerAction.length; i++)
1:a6f9586: 			{
1:a6f9586: 				out.writeInt(referencedColsInTriggerAction[i]);
1:a6f9586: 			}
1:a6f9586: 		}	
1:eac0369: 		out.writeObject(triggerDefinition);
1:eac0369: 		out.writeBoolean(referencingOld);
1:eac0369: 		out.writeBoolean(referencingNew);
1:eac0369: 		out.writeObject(oldReferencingName);
1:eac0369: 		out.writeObject(newReferencingName);
1:211adc3:         out.writeObject(whenClauseText);
1:d9878ca: 	}
1:d9878ca:  
1:d9878ca: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:d9878ca: 	 */
1:d9878ca:     public int getTypeFormatId() {
1:211adc3:         return StoredFormatIds.TRIGGER_DESCRIPTOR_V01_ID;
1:d9878ca:     }
1:eac0369: 
1:eac0369: 	/** @see TupleDescriptor#getDescriptorType */
1:eac0369: 	public String getDescriptorType()
1:eac0369: 	{
1:eac0369: 		return "Trigger";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see TupleDescriptor#getDescriptorName */
1:eac0369: 	public String getDescriptorName() { return name; }
1:a0dbbd7: 	
1:eac0369:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContext( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContext( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:617d55a
/////////////////////////////////////////////////////////////////////////
1: 					getTableDescriptor(),
/////////////////////////////////////////////////////////////////////////
1: 					getTableDescriptor(),
commit:54844c3
/////////////////////////////////////////////////////////////////////////
1:             int[] cols;
1:             cols = dd.examineTriggerNodeAndCols(stmtnode,
1: 					oldReferencingName,
1: 					newReferencingName,
1: 					originalSQL,
1: 					referencedCols,
1: 					referencedColsInTriggerAction,
1:                     0,
0: 					td,
1: 					-1,
1:                     false,
1:                     null);
/////////////////////////////////////////////////////////////////////////
1:                     null,
1:                     cols);
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 				getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1: public class TriggerDescriptor extends UniqueSQLObjectDescriptor
1: 	implements Provider, Dependent, Formatable 
commit:e2245e6
/////////////////////////////////////////////////////////////////////////
1:     /** Update the array of referenced columns */
1:     public  void    setReferencedCols( int[] newCols )
1:     {
1:         referencedCols = ArrayUtil.copy( newCols );
1:     }
1: 
commit:bc2c59e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
1: import org.apache.derby.iapi.types.DataTypeUtilities;
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedColsInTriggerAction( referencedColsInTriggerAction );
1: 		this.creationTimestamp = DataTypeUtilities.clone( creationTimestamp );
/////////////////////////////////////////////////////////////////////////
1: 		return DataTypeUtilities.clone( creationTimestamp );
/////////////////////////////////////////////////////////////////////////
1: 		return ArrayUtil.copy( referencedCols );
/////////////////////////////////////////////////////////////////////////
1:         return ArrayUtil.copy( referencedColsInTriggerAction );
1:     /** Set the referenced column array for trigger actions */
1:     public  void    setReferencedColsInTriggerAction( int[] referencedColsInTriggerAction )
1:     {
1: 		this.referencedColsInTriggerAction = ArrayUtil.copy( referencedColsInTriggerAction );
1:     }
1: 
commit:3d7a3d4
/////////////////////////////////////////////////////////////////////////
1: 
1: 		switch (action)
1: 			// invalidate this trigger descriptor
1: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1: 				DependencyManager dm = getDataDictionary().getDependencyManager();
1: 				dm.invalidateFor(this, DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1: 				break;
1: 
1: 			// When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1: 			// types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1: 			// make the TriggerDescriptor drop itself. 
1: 			case DependencyManager.REVOKE_PRIVILEGE:
0: 				DropTriggerConstantAction.dropTriggerDescriptor(
0: 					lcc, getDataDictionary().getDependencyManager(),
0: 					getDataDictionary(), lcc.getTransactionExecute(), this,
0: 					null);
1: 				break;
1: 
1: 			default:
1: 				break;
1: 		
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0cefeda
/////////////////////////////////////////////////////////////////////////
1:                     false,
0:                     null);
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1:             ** We are dependent on the underlying table, our SPSs, any tables
1:             ** or other SQL objects that are referenced from the trigger, and
/////////////////////////////////////////////////////////////////////////
1:             case DependencyManager.DROP_VIEW:
1:             case DependencyManager.DROP_METHOD_ALIAS:
commit:211adc3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         whenClauseText = (String) in.readObject();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         out.writeObject(whenClauseText);
/////////////////////////////////////////////////////////////////////////
1:         return StoredFormatIds.TRIGGER_DESCRIPTOR_V01_ID;
commit:50734d8
/////////////////////////////////////////////////////////////////////////
1:         return getSPS(lcc, false /* isWhenClause */);
1:     }
1: 
1:     /**
1:      * Get the SPS for the triggered SQL statement or the WHEN clause.
1:      *
1:      * @param lcc the LanguageConnectionContext to use
1:      * @param isWhenClause {@code true} if the SPS for the WHEN clause is
1:      *   requested, {@code false} if it is the triggered SQL statement
1:      * @return the requested SPS
1:      * @throws StandardException if an error occurs
1:      */
1:     private SPSDescriptor getSPS(LanguageConnectionContext lcc,
1:                                  boolean isWhenClause)
1:             throws StandardException
1:     {
1:         DataDictionary dd = getDataDictionary();
1:         SPSDescriptor sps = isWhenClause ? whenSPS : actionSPS;
1:         UUID spsId = isWhenClause ? whenSPSId : actionSPSId;
1:         String originalSQL = isWhenClause ? whenClauseText : triggerDefinition;
1: 
1:         if (sps == null) {
1:             sps = dd.getSPSDescriptor(spsId);
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ((!sps.isValid() ||
1:                 (sps.getPreparedStatement() == null)) &&
1:                     dd.getSchemaDescriptor(sps.getCompSchemaId(), null));
1:             Visitable stmtnode =
1:                     isWhenClause ? pa.parseSearchCondition(originalSQL)
1:                                  : pa.parseStatement(originalSQL);
1: 
1:             String newText = dd.getTriggerActionString(stmtnode,
1:                     originalSQL,
0:                     false);
1: 
1:             if (isWhenClause) {
1:                 // The WHEN clause is not a full SQL statement, just a search
1:                 // condition, so we need to turn it into a statement in order
1:                 // to create an SPS.
1:                 newText = "VALUES " + newText;
1:             }
1: 
1:             sps.setText(newText);
1: 
1: 
1:         return sps;
/////////////////////////////////////////////////////////////////////////
1:      * @param lcc the LanguageConnectionContext to use
1:     public SPSDescriptor getWhenClauseSPS(LanguageConnectionContext lcc)
1:         if (whenSPSId == null) {
1:             // This trigger doesn't have a WHEN clause.
1:             return null;
1:         }
1: 
1:         return getSPS(lcc, true /* isWhenClause */);
commit:ddc6707
/////////////////////////////////////////////////////////////////////////
1:             CompilerContext newCC = lcc.pushCompilerContext(
0:                     dd.getSchemaDescriptor(actionSPS.getCompSchemaId(), null));
0:             actionSPS.setText(dd.getTriggerActionString(stmtnode,
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:  * <li> public String getWhenClauseText();
/////////////////////////////////////////////////////////////////////////
1:     private String              whenClauseText;
/////////////////////////////////////////////////////////////////////////
1:      * @param whenClauseText the SQL text of the WHEN clause, or {@code null}
1:      *                       if there is no WHEN clause
/////////////////////////////////////////////////////////////////////////
1:         String              newReferencingName,
1:         String              whenClauseText
/////////////////////////////////////////////////////////////////////////
1:         this.whenClauseText = whenClauseText;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the SQL text of the WHEN clause.
1:      * @return SQL text for the WHEN clause, or {@code null} if there is
1:      *   no WHEN clause
1:      */
1:     public String getWhenClauseText() {
1:         return whenClauseText;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         readExternal_v10_10(in);
0:         whenClauseText = (String) in.readObject();
1:     }
1: 
1:     /**
0:      * {@code readExternal()} method to be used if the data dictionary
0:      * version is 10.10 or lower.
1:      */
0:     void readExternal_v10_10(ObjectInput in)
0:             throws IOException, ClassNotFoundException {
/////////////////////////////////////////////////////////////////////////
0:         writeExternal_v10_10(out);
0:         out.writeObject(whenClauseText);
1:     }
1: 
1:     /**
0:      * {@code writeExternal()} method to be used if the data dictionary
0:      * version is 10.10 or lower.
1:      */
0:     void writeExternal_v10_10(ObjectOutput out) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public int getTypeFormatId() {
0:         return StoredFormatIds.TRIGGER_DESCRIPTOR_V02_ID;
1:     }
commit:1725dd1
/////////////////////////////////////////////////////////////////////////
0:         if (whenSPSId != null && whenSPS == null)
commit:3221b8c
/////////////////////////////////////////////////////////////////////////
1:     TriggerDescriptor
commit:70a4f2d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitable;
/////////////////////////////////////////////////////////////////////////
0: 			Visitable stmtnode = pa.parseStatement(triggerDefinition);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1:  * <li> public boolean enforced();
/////////////////////////////////////////////////////////////////////////
1:      * @param isEnabled  is this trigger enabled or disabled
/////////////////////////////////////////////////////////////////////////
1:      * Is this trigger enforced
1:      * @return true if it is enforced
/////////////////////////////////////////////////////////////////////////
1:      * Mark this trigger as enforced
commit:eb38311
/////////////////////////////////////////////////////////////////////////
1: 			// Ditto for revoking a role conferring a privilege.
1: 			case DependencyManager.REVOKE_ROLE:
1: 
1: 				lcc.getLastActivation().addWarning(
1: 					StandardException.newWarning(
1: 						SQLState.LANG_TRIGGER_DROPPED,
1: 						this.getObjectName() ));
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: 		//  old/new row columns(if we are working with pre-10.9 db,
1: 		//  meaning we are in soft-upgrade mode, then we won't have
1: 		//  information about the actual trigger action columns since
1: 		//  we didn't keep that info in those releases. For such dbs,
1: 		//  we will just check if they are using REFERENCING OLD and/or
1: 		//  NEW clause.)
1: 		DataDictionary dd = getDataDictionary();
1: 		boolean in10_9_orHigherVersion = dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null);
1: 		boolean usesReferencingClause = (in10_9_orHigherVersion) ? 
1: 				referencedColsInTriggerAction != null :
1: 					(referencingOld || referencingNew);
1: 
1: 					isRow &&
1: 					usesReferencingClause)
commit:c1193bf
/////////////////////////////////////////////////////////////////////////
0: 				 isRow && (referencingOld || referencingNew))
commit:179e593
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Parser;
0: import org.apache.derby.impl.sql.compile.StatementNode;
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the trigger action sps from SYSSTATEMENTS. If we find that
1: 	 * the sps is invalid and the trigger is defined at row level and it
1: 	 * has OLD/NEW transient variables through REFERENCES clause, then
1: 	 * the sps from SYSSTATEMENTS may not be valid anymore. In such a 
1: 	 * case, we regenerate the trigger action sql and use that for the
1: 	 * sps and update SYSSTATEMENTS using this new sps. This update of
1: 	 * SYSSTATEMENTS was introduced with DERBY-4874
1: 	 * @param lcc	The LanguageConnectionContext to use.
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		//We need to regenerate the trigger action sql if 
1: 		//1)the trigger is found to be invalid, 
1: 		//2)the trigger is defined at row level (that is the only kind of 
1: 		//  trigger which allows reference to individual columns from 
1: 		//  old/new row)
1: 		//3)the trigger action plan has columns that reference 
0: 		//  old/new row columns
1: 		//This code was added as part of DERBY-4874 where the Alter table 
1: 		//had changed the length of a varchar column from varchar(30) to 
1: 		//varchar(64) but the trigger action plan continued to use varchar(30).
1: 		//To fix varchar(30) in trigger action sql to varchar(64), we need
1: 		//to regenerate the trigger action sql. This new trigger action sql
1: 		//will then get updated into SYSSTATEMENTS table.
0: 		if((!actionSPS.isValid() ||
0: 				 (actionSPS.getPreparedStatement() == null)) && 
0: 				 isRow &&
0: 				 referencedColsInTriggerAction != null) 
1: 		{
0: 			SchemaDescriptor compSchema;
0: 			compSchema = getDataDictionary().getSchemaDescriptor(triggerSchemaId, null);
0: 			CompilerContext newCC = lcc.pushCompilerContext(compSchema);
1: 			Parser	pa = newCC.getParser();
0: 			StatementNode stmtnode = (StatementNode)pa.parseStatement(triggerDefinition);
1: 			lcc.popCompilerContext(newCC);
1: 					
0: 			actionSPS.setText(getDataDictionary().getTriggerActionString(stmtnode, 
1: 					oldReferencingName,
1: 					newReferencingName,
0: 					triggerDefinition,
1: 					referencedCols,
1: 					referencedColsInTriggerAction,
1: 					0,
0: 					td,
1: 					-1,
0: 					false
0: 					));
1: 			//By this point, we are finished transforming the trigger action if
1: 			//it has any references to old/new transition variables.
1: 		}
1: 		
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1:  * <li> public int[] getReferencedColsInTriggerAction();
/////////////////////////////////////////////////////////////////////////
1: 	private	int[]				referencedColsInTriggerAction;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1: 	 *						action reference through old/new transition variables
1: 	 *						(may be null)
/////////////////////////////////////////////////////////////////////////
1: 		int[]				referencedColsInTriggerAction,
/////////////////////////////////////////////////////////////////////////
0: 		this.referencedColsInTriggerAction = referencedColsInTriggerAction;
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the referenced column array for the trigger action columns.
1: 	 *
1: 	 * @return the referenced column array
1: 	 */
1: 	public int[] getReferencedColsInTriggerAction()
1: 	{
0: 		return referencedColsInTriggerAction;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		length = in.readInt();
1: 		if (length != 0)
1: 		{
1: 			referencedColsInTriggerAction = new int[length];
1: 			for (int i = 0; i < length; i++)
1: 			{
1: 				referencedColsInTriggerAction[i] = in.readInt();
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		if (referencedColsInTriggerAction == null)
1: 		{
1: 			out.writeInt(0);
1: 		}
1: 		else
1: 		{
1: 			out.writeInt(referencedColsInTriggerAction.length);
1: 			for (int i = 0; i < referencedColsInTriggerAction.length; i++)
1: 			{
1: 				out.writeInt(referencedColsInTriggerAction[i]);
1: 			}
1: 		}	
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e645861
/////////////////////////////////////////////////////////////////////////
1: 	protected DataDictionary getDataDictionary()
commit:9213b42
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1:                 drop(lcc);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void drop(LanguageConnectionContext   lcc) throws StandardException
1:     {
0:         DataDictionary dd = getDataDictionary();
1:         DependencyManager dm = getDataDictionary().getDependencyManager();
1:         TransactionController tc = lcc.getTransactionExecute();
1: 
1:         dm.invalidateFor(this, DependencyManager.DROP_TRIGGER, lcc);
1: 
1:         // Drop the trigger
1:         dd.dropTriggerDescriptor(this, tc);
1: 
1:         // Clear the dependencies for the trigger 
1:         dm.clearDependencies(lcc, this);
1: 
1:         // Drop the spses
1:         SPSDescriptor spsd = dd.getSPSDescriptor(this.getActionId());
1: 
1:         // there shouldn't be any dependencies, but in case
1:         // there are, lets clear them
1:         dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);
1:         dm.clearDependencies(lcc, spsd);
1:         dd.dropSPSDescriptor(spsd, tc);
1:         
1:         if (getWhenClauseId() != null)
1:         {   
1:             spsd = dd.getSPSDescriptor(getWhenClauseId());
1:             dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);
1:             dm.clearDependencies(lcc, spsd);
1:             dd.dropSPSDescriptor(spsd, tc);
1:         }
1:     }
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
commit:71408ab
/////////////////////////////////////////////////////////////////////////
0: 			** We are only dependent on the underlying table, and our spses and 
1: 			** privileges on various objects.  (we should be dropped before our 
1: 			** table is dropped. Also, we should be dropped before revoke 
1: 			** RESTRICT privilege is issued otherwise revoke RESTRICT will  
1: 			** throw an exception).
1: 			** Currently, in Derby, an execute routine privilege can be revoked
1: 			** only if there are no dependents on that privilege. When revoke 
1: 			** execute RESTRICT is exectued, all the dependents will receive
1: 			** REVOKE_PRIVILEGE_RESTRICT and they should throw exception. 
1: 			** We handle this for TriggerDescriptor by throwning an exception 
1: 			** below. For all the other types of revoke privileges, for 
1: 			** instance, SELECT, UPDATE, DELETE, INSERT, REFERENCES, 
1: 			** TRIGGER, we don't do anything here and later in makeInvalid, we 
1: 			** make the TriggerDescriptor drop itself. 
1: 		    case DependencyManager.REVOKE_PRIVILEGE_RESTRICT:
/////////////////////////////////////////////////////////////////////////
0: 		// When REVOKE_PRIVILEGE gets sent (this happens for privilege 
0: 		// types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
0: 		// make the TriggerDescriptor drop itself. 
commit:f8fa8cf
/////////////////////////////////////////////////////////////////////////
0: 		    //Derby supports only RESTRICT form of revoke execute and that
0: 		    //means that if there are any dependent objects on execute
0: 		    //permission on routine, revoke execute on that routine should
0: 		    //fail
0: 			//For all the other types of revoke privileges, for instance,
0: 			//SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER, we don't 
0: 			//do anything here and later in makeInvalid, we make the 
0: 			//TriggerDescriptor drop itself. 
0: 		    case DependencyManager.REVOKE_EXECUTE_PRIVILEGE:
/////////////////////////////////////////////////////////////////////////
0:     	//Notice that REVOKE_EXECUTE_PRIVILEGE is not included here.
0:     	//This is because Derby supports only RESTRICT form of revoke 
0: 	    //execute and that means that if there are any dependent 
0: 	    //objects on execute permission on routine, revoke execute on 
0: 	    //that routine should fail. This behvaior for revoke execute
0: 	    //gets implemented in prepareToInvalidate method
commit:08313de
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.derby.impl.sql.execute.DropTriggerConstantAction;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				/*
/////////////////////////////////////////////////////////////////////////
1: 
0: 		if (action ==  DependencyManager.REVOKE_PRIVILEGE)
1: 		{
0: 		    DropTriggerConstantAction.dropTriggerDescriptor(
0: 				lcc,getDataDictionary().getDependencyManager(), 
0: 				getDataDictionary(), lcc.getTransactionExecute(), this,
0: 				null);
0: 		    return;
1: 		}
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.TriggerDescriptor
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.catalog.ReferencedColumns;
1: import org.apache.derby.catalog.UUID;
1: import java.sql.Timestamp;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.StatementType;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: /**
1:  * A trigger.
1:  * <p>
1:  * We are dependent on TableDescriptors, SPSDescriptors (for our
1:  * WHEN clause and our action).  Note that we don't strictly
1:  * need to be dependent on out SPSes because we could just disallow
1:  * anyone from dropping an sps of type 'T', but to keep dependencies
1:  * uniform, we'll do be dependent.
1:  * <p>
1:  * We are a provider for DML (PreparedStatements or SPSes)
1:  *
1:  * The public methods for this class are:
1:  *
1:  * <ol>
1:  * <li>getUUID
1:  * <li>getName
1:  * <li>getSchemaDescriptor
1:  * <li>	public boolean listensForEvent(int event);
1:  * <li>	public int getTriggerEventMask();
1:  * <li>	public Timestamp getCreationTimestamp();
1:  * <li>	public boolean isBeforeTrigger();
1:  * <li> public boolean isRowTrigger();
1:  * <li> public UUID getActionId();
1:  * <li> public SPSDescriptor getActionSPS();
1:  * <li>	public UUID getWhenClauseId();
1:  * <li>	public SPSDescriptor getWhenClauseSPS()
1:  * <li>	public TableDescriptor getTableDescriptor()
1:  * <li> public ReferencedColumns getReferencedColumnsDescriptor()
1:  * <li> public int[] getReferencedCols();
0:  * <li> public boolean isEnabled();
1:  * <li> public void setEnabled();
1:  * <li> public void setDisabled();
1:  * <li> public boolean needsToFire(int stmtType, int[] modifiedCols)
1:  * <li> public String getTriggerDefinition();
1:  * <li> public boolean getReferencingOld();
1:  * <li> public boolean getReferencingNew();
1:  * <li> public String getOldReferencingName();
1:  * <li> public String getNewReferencingName();
1:  * </ol>
0:  * @author Jamie
1:  */
0: public class TriggerDescriptor extends TupleDescriptor
0: 	implements UniqueSQLObjectDescriptor, Provider, Dependent, Formatable 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	// field that we want users to be able to know about
1: 	public static final int SYSTRIGGERS_STATE_FIELD = 8;
1: 
1: 	public static final int TRIGGER_EVENT_UPDATE = 1;
1: 	public static final int TRIGGER_EVENT_DELETE = 2;
1: 	public static final int TRIGGER_EVENT_INSERT = 4;
1: 
1: 	
1: 	private	UUID				id;
1: 	private String				name;
1: 	private String				oldReferencingName;
1: 	private String				newReferencingName;
1: 	private String				triggerDefinition;
1: 	private SchemaDescriptor	sd;
1: 	private int					eventMask;
1: 	private boolean				isBefore;
1: 	private boolean 			isRow;
1: 	private boolean				referencingOld;
1: 	private boolean				referencingNew;
1: 	private	TableDescriptor		td;
1: 	private	UUID				actionSPSId;
1: 	private SPSDescriptor		actionSPS;
1: 	private	UUID				whenSPSId;
1: 	private SPSDescriptor		whenSPS;
1: 	private	boolean				isEnabled;
1: 	private	int[]				referencedCols;
1: 	private	Timestamp			creationTimestamp;
1: 	private UUID				triggerSchemaId;
1: 	private UUID				triggerTableId;
1: 
1: 
1: 	/**
1: 	 * Niladic constructor, for formatable
1: 	 */
1: 	public TriggerDescriptor() {}
1: 
1: 	/**
1: 	 * Constructor.  Used when creating a trigger from SYS.SYSTRIGGERS
1: 	 *
1: 	 * @param dataDictionary 	the data dictionary
1: 	 * @param sd	the schema descriptor for this trigger
1: 	 * @param id	the trigger id
1: 	 * @param name	the trigger name
1: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
1: 	 * @param isBefore	is this a before (as opposed to after) trigger 
1: 	 * @param isRow		is this a row trigger or statement trigger
0: 	 * @param isEnabled	is this trigger enabled or disabled
1: 	 * @param td		the table upon which this trigger is defined
1: 	 * @param whenSPSId	the sps id for the when clause (may be null)
1: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1: 	 * @param creationTimestamp	when was this trigger created?
1: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1: 	 * @param triggerDefinition The original user text of the trigger action
1: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1: 	 */
0: 	public TriggerDescriptor
1: 	(
1: 		DataDictionary		dataDictionary,
1: 		SchemaDescriptor	sd,
1: 		UUID				id,
1: 		String				name,
1: 		int					eventMask,
1: 		boolean				isBefore,
1: 		boolean				isRow,
1: 		boolean				isEnabled,
1: 		TableDescriptor		td,
1: 		UUID				whenSPSId,
1: 		UUID				actionSPSId,
1: 		Timestamp			creationTimestamp,
1: 		int[]				referencedCols,
1: 		String				triggerDefinition,
1: 		boolean				referencingOld,
1: 		boolean				referencingNew,
1: 		String				oldReferencingName,
0: 		String				newReferencingName
1: 	)
1: 	{
1: 		super(dataDictionary);
1: 		this.id = id;
1: 		this.sd = sd;
1: 		this.name = name;
1: 		this.eventMask = eventMask;
1: 		this.isBefore = isBefore;
1: 		this.isRow = isRow;
1: 		this.td = td;
1: 		this.actionSPSId = actionSPSId; 
1: 		this.whenSPSId = whenSPSId;
1: 		this.isEnabled = isEnabled;
1: 		this.referencedCols = referencedCols;
0: 		this.creationTimestamp = creationTimestamp;
1: 		this.triggerDefinition = triggerDefinition;
1: 		this.referencingOld = referencingOld;
1: 		this.referencingNew = referencingNew;
1: 		this.oldReferencingName = oldReferencingName;
1: 		this.newReferencingName = newReferencingName;
1: 		triggerSchemaId = sd.getUUID();
1: 		triggerTableId = td.getUUID();
1: 	}	
1: 		
1: 		
1: 	/**
1: 	 * Get the trigger UUID
1: 	 *
1: 	 * @return the id
1: 	 */
1: 	public UUID getUUID()
1: 	{
1: 		return id;
1: 	}
1: 
1: 	/**
1: 	 * Get the trigger name
1: 	 *
1: 	 * @return	the name
1: 	 */
1: 	public String getName()
1: 	{
1: 		return name;
1: 	}
1: 
1: 	public UUID getTableId() {
1: 		return triggerTableId;
1: 	}
1: 
1: 	/**
1: 	 * Get the triggers schema descriptor
1: 	 *
1: 	 * @return the schema descriptor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	 public SchemaDescriptor getSchemaDescriptor()
1: 		 throws StandardException
1: 	{
1: 		if (sd == null)
1: 		{
1: 			sd = getDataDictionary().getSchemaDescriptor(triggerSchemaId, null);
1: 		}
1: 		return sd;
1: 	}
1: 
1: 	/**
1: 	 * Indicate whether this trigger listens for this
1: 	 * type of event.
1: 	 *
1: 	 * @param event TRIGGER_EVENT_XXXX
1: 	 *
1: 	 * @return true if it listens to the specified event.
1: 	 */ 
1: 	public boolean listensForEvent(int event)
1: 	{
1: 		return (event & eventMask) == event;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the trigger event mask.  Currently, a trigger
1: 	 * may only listen for a single event, though it may
1: 	 * OR multiple events in the future.
1: 	 *
1: 	 * @return the trigger event mask
1: 	 */
1: 	public int getTriggerEventMask()
1: 	{
1: 		return eventMask;
1: 	}
1: 
1: 	/**
1: 	 * Get the time that this trigger was created.
1: 	 *
1: 	 * @return the time the trigger was created
1: 	 */
1: 	public Timestamp getCreationTimestamp()
1: 	{
0: 		return creationTimestamp;
1: 	}
1: 
1: 	/**
1: 	 * Is this a before trigger
1: 	 *
1: 	 * @return true if it is a before trigger
1: 	 */
1: 	public boolean isBeforeTrigger()
1: 	{
1: 		return isBefore;
1: 	}
1: 
1: 	/**
1: 	 * Is this a row trigger
1: 	 *
1: 	 * @return true if it is a before trigger
1: 	 */
1: 	public boolean isRowTrigger()
1: 	{
1: 		return isRow;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the trigger action sps UUID
1: 	 *
1: 	 * @return the uuid of the sps action
1: 	 */
1: 	public UUID getActionId()
1: 	{
1: 		return actionSPSId;
1: 	}
1: 
1: 	/**
0: 	 * Get the trigger action sps
1: 	 *
1: 	 * @return the trigger action sps
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public SPSDescriptor getActionSPS(LanguageConnectionContext lcc)
1: 		throws StandardException
1: 	{
0: 		if (actionSPS == null)
1: 		{
1: 			//bug 4821 - do the sysstatement look up in a nested readonly
1: 			//transaction rather than in the user transaction. Because of
1: 			//this, the nested compile transaction which is attempting to
1: 			//compile the trigger will not run into any locking issues with
1: 			//the user transaction for sysstatements.
1: 			lcc.beginNestedTransaction(true);
0: 			actionSPS = getDataDictionary().getSPSDescriptor(actionSPSId);
1: 			lcc.commitNestedTransaction();
1: 		}
0: 		return actionSPS;
1: 	}
1: 
1: 	/**
1: 	 * Get the trigger when clause sps UUID
1: 	 *
1: 	 * @return the uuid of the sps action
1: 	 */
1: 	public UUID getWhenClauseId()
1: 	{
1: 		return whenSPSId;
1: 	}
1: 
1: 	/**
1: 	 * Get the trigger when clause sps 
1: 	 *
1: 	 * @return the sps of the when clause
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public SPSDescriptor getWhenClauseSPS()
1: 		throws StandardException
1: 	{
0: 		if (whenSPS == null)
1: 		{
0: 			whenSPS = getDataDictionary().getSPSDescriptor(whenSPSId);
1: 		}
0: 		return whenSPS;
1: 	}
1: 
1: 	/**
1: 	 * Get the trigger table descriptor
1: 	 *
1: 	 * @return the table descripor upon which this trigger
1:  	 * is declared
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public TableDescriptor getTableDescriptor()
1: 		throws StandardException
1: 	{
1: 		if (td == null)
1: 		{
1: 			td = getDataDictionary().getTableDescriptor(triggerTableId);
1: 		}
1: 		return td;
1: 	}
1: 
1: 	/**
1: 	 * Get the referenced table descriptor for this trigger.
1: 	 *
1: 	 * @return the referenced table descriptor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	// caller converts referencedCols to referencedColsDescriptor...
1: //  	public ReferencedColumns getReferencedColumnsDescriptor()
1: //  		throws StandardException
1: //  	{
1: //  		return (referencedCols == null) ? 
1: //  				(ReferencedColumns)null :
1: //  				new ReferencedColumnsDescriptorImpl(referencedCols);
1: //  	}
1: 
1: 	/**
1: 	 * Get the referenced column array for this trigger, used in "alter table
1: 	 * drop column", we get the handle and change it
1: 	 *
1: 	 * @return the referenced column array
1: 	 */
1: 	public int[] getReferencedCols()
1: 	{
0: 		return referencedCols;
1: 	}
1: 
1: 	/**
0: 	 * Is this trigger enabled
1: 	 *
0: 	 * @return true if it is enabled
1: 	 */
1: 	public boolean isEnabled()
1: 	{
1: 		return isEnabled;
1: 	}
1: 
1: 	/**
0: 	 * Mark this trigger as enabled
1: 	 *
1: 	 */
1: 	public void setEnabled()
1: 	{
1: 		isEnabled = true;
1: 	}
1: 
1: 	/**
1: 	 * Mark this trigger as disabled
1: 	 *
1: 	 */
1: 	public void setDisabled()
1: 	{
1: 		isEnabled = false;
1: 	}
1: 
1: 	/**
1: 	 * Does this trigger need to fire on this type of
1: 	 * DML?
1: 	 *
0: 	 * @param dmlType	the type of DML 
1: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
1: 	 * @param modifiedCols	the columns modified, or null for all
1: 	 *
1: 	 * @return true/false
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public boolean needsToFire(int stmtType, int[] modifiedCols)
1: 		throws StandardException
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!((stmtType == StatementType.INSERT) ||
1: 								 (stmtType == StatementType.BULK_INSERT_REPLACE) ||
1: 								 (stmtType == StatementType.UPDATE) ||
1: 								 (stmtType == StatementType.DELETE)))
1: 			{
1: 				SanityManager.THROWASSERT("invalid statement type "+stmtType);
1: 			}
1: 		}
1: 
1: 		/*
1: 		** If we are disabled, we never fire
1: 		*/
1: 		if (!isEnabled)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		if (stmtType == StatementType.INSERT)
1: 		{
1:  			return (eventMask & TRIGGER_EVENT_INSERT) == eventMask;
1: 		}
1: 		if (stmtType == StatementType.DELETE) 
1: 		{
1: 			return (eventMask & TRIGGER_EVENT_DELETE) == eventMask;
1: 		}
1: 
1: 		// this is a temporary restriction, but it may not be lifted
1: 		// anytime soon.
1: 		if (stmtType == StatementType.BULK_INSERT_REPLACE)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NO_BULK_INSERT_REPLACE_WITH_TRIGGER, 
1: 												 getTableDescriptor().getQualifiedName(), name);
1: 		}
1: 
1: 		// if update, only relevant if columns intersect
1: 		return ((eventMask & TRIGGER_EVENT_UPDATE) == eventMask) &&
1: 				ConstraintDescriptor.doColumnsIntersect(modifiedCols, referencedCols);
1: 	}
1: 
1: 	/**
1: 	 * Get the original trigger definition.
1: 	 *
1: 	 * @return The trigger definition.
1: 	 */
1: 	public String getTriggerDefinition()
1: 	{
1: 		return triggerDefinition;
1: 	}
1: 
1: 	/**
1: 	 * Get whether or not OLD was replaced
1: 	 * in the REFERENCING clause.
1: 	 *
1: 	 * @return Whether or not OLD was replaced
1: 	 * in the REFERENCING clause.
1: 	 */
1: 	public boolean getReferencingOld()
1: 	{
1: 		return referencingOld;
1: 	}
1: 
1: 	/**
1: 	 * Get whether or not NEW was replaced
1: 	 * in the REFERENCING clause.
1: 	 *
1: 	 * @return Whether or not NEW was replaced
1: 	 * in the REFERENCING clause.
1: 	 */
1: 	public boolean getReferencingNew()
1: 	{
1: 		return referencingNew;
1: 	}
1: 
1: 	/**
1: 	 * Get the old Referencing name, if any,
1: 	 * from the REFERENCING clause.
1: 	 *
1: 	 * @return The old Referencing name, if any,
1: 	 * from the REFERENCING clause.
1: 	 */
1: 	public String getOldReferencingName()
1: 	{
1: 		return oldReferencingName;
1: 	}
1: 
1: 	/**
1: 	 * Get the new Referencing name, if any,
1: 	 * from the REFERENCING clause.
1: 	 *
1: 	 * @return The new Referencing name, if any,
1: 	 * from the REFERENCING clause.
1: 	 */
1: 	public String getNewReferencingName()
1: 	{
1: 		return newReferencingName;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "TRIGGER: "+name;
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////
1: 	//
1: 	// PROVIDER INTERFACE
1: 	//
1: 	////////////////////////////////////////////////////////////////////
1: 
1: 	/**		
1: 	 * @return the stored form of this provider
1: 	 *
1: 	 * @see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder() 
1: 	{
1: 	    return getDependableFinder(StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID);
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Provider.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this provider.
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return name;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's UUID
1: 	 *
1: 	 * @return 	The provider's UUID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return id;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's type.
1: 	 *
1: 	 * @return char		The provider's type.
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.TRIGGER;
1: 	}
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// DEPENDENT INTERFACE
1: 	//
1: 	// Triggers are dependent on the underlying table,
1:  	// and their spses (for the trigger action and the WHEN
1: 	// clause).
1: 	//
1: 	//////////////////////////////////////////////////////
1: 	/**
1: 	 * Check that all of the dependent's dependencies are valid.
1: 	 *
1: 	 * @return true if the dependent is currently valid
1: 	 */
1: 	public synchronized boolean isValid()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Prepare to mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).
1: 	 *
1: 	 * @param action	The action causing the invalidation
1: 	 * @param p			the provider
1: 	 * @param lcc		the language connection context
1: 	 *
1: 	 * @exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void prepareToInvalidate
1: 	(
1: 		Provider 					p, 
1: 		int							action, 
1: 		LanguageConnectionContext	lcc
1: 	) throws StandardException
1: 	{
1: 		
1: 
1: 		switch (action)
1: 		{
1: 			/*
0: 			** We are only dependent on the underlying
0: 			** table, and our spses.  (we should be
0: 			** dropped before our table is dropped).
1: 			*/
1: 		    case DependencyManager.DROP_TABLE:
1: 		    case DependencyManager.DROP_SPS:
1: 		    case DependencyManager.RENAME:
1: 				DependencyManager dm = getDataDictionary().getDependencyManager();
1: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
1: 									dm.getActionString(action), 
1: 									p.getObjectName(), "TRIGGER", name);
1: 
1: 			/*
1: 			** The trigger descriptor depends on the trigger table.
1: 			** This means that we get called whenever anything happens
1: 			** to the trigger table. There are so many cases where this
1: 			** can happen that it doesn't make sense to have an assertion
1: 			** here to check whether the action was expected (it makes
1: 			** the code hard to maintain, and creates a big switch statement).
1: 			*/
1: 			default:
1: 				break;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).  Always an error
1: 	 * for a trigger -- should never have gotten here.
1: 	 *
1: 	 * @param 	lcc the language connection context
1: 	 * @param	action	The action causing the invalidation
1: 	 *
1: 	 * @exception StandardException thrown if called in sanity mode
1: 	 */
1: 	public void makeInvalid(int action, LanguageConnectionContext lcc) throws StandardException
1: 	{
1: 		// No sanity check for valid action. Trigger descriptors depend on
1: 		// the trigger table, so there is a very large number of actions
1: 		// that we would have to check against. This is hard to maintain,
1: 		// so don't bother.
1: 	}
1: 
1: 	/**
0:      * Attempt to revalidate the dependent. Meaningless
0: 	 * for a trigger.
1: 	 *
1: 	 * @param 	lcc the language connection context
1: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
1: 	{
1: 	}
1: 
1: 
1: 	//////////////////////////////////////////////////////////////
1: 	//
1: 	// FORMATABLE
1: 	//
1: 	//////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal(ObjectInput in)
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		id = (UUID)in.readObject();
1: 		name = (String)in.readObject();
1: 		triggerSchemaId = (UUID)in.readObject();
1: 		triggerTableId = (UUID)in.readObject();
1: 		eventMask = in.readInt();
1: 		isBefore = in.readBoolean();
1: 		isRow = in.readBoolean();
1: 		isEnabled = in.readBoolean();
1: 		whenSPSId = (UUID)in.readObject();
1: 		actionSPSId = (UUID)in.readObject();
1: 		int length = in.readInt();
1: 		if (length != 0)
1: 		{
1: 			referencedCols = new int[length];
1: 			for (int i = 0; i < length; i++)
1: 			{
1: 				referencedCols[i] = in.readInt();
1: 			}
1: 		}
1: 		triggerDefinition = (String)in.readObject();
1: 		referencingOld = in.readBoolean();
1: 		referencingNew = in.readBoolean();
1: 		oldReferencingName = (String)in.readObject();
1: 		newReferencingName = (String)in.readObject();
1: 		
1: 	}
1: 
0: 	protected DataDictionary getDataDictionary() throws StandardException
1: 	{
1: 		/*
1:  		  note: we need to do this since when this trigger is read back from
1: 		  disk (when it is associated with a sps), the dataDictionary has not 
1:  		  been initialized and therefore can give a NullPointerException
1:  		*/
1: 		DataDictionary dd = super.getDataDictionary();
1:  		if (dd == null)
1:  		{
1:   			LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1:   			dd = lcc.getDataDictionary();
1: 			setDataDictionary(dd);
1:   		}
1: 		return dd;
1:  	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException		thrown on error
1: 	 */
1: 	public void writeExternal( ObjectOutput out )
1: 		 throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(triggerSchemaId != null,
1: 				"triggerSchemaId expected to be non-null");
1: 			SanityManager.ASSERT(triggerTableId != null,
1: 				"triggerTableId expected to be non-null");
1: 		}
1: 		out.writeObject(id);
1: 		out.writeObject(name);
1: 		out.writeObject(triggerSchemaId);
1: 		out.writeObject(triggerTableId);
1: 		out.writeInt(eventMask);
1: 		out.writeBoolean(isBefore);
1: 		out.writeBoolean(isRow);
1: 		out.writeBoolean(isEnabled);
1: 		out.writeObject(whenSPSId);
1: 		out.writeObject(actionSPSId);
1: 		if (referencedCols == null)
1: 		{
1: 			out.writeInt(0);
1: 		}
1: 		else
1: 		{
1: 			out.writeInt(referencedCols.length);
1: 			for (int i = 0; i < referencedCols.length; i++)
1: 			{
1: 				out.writeInt(referencedCols[i]);
1: 			}
1: 		}	
1: 		out.writeObject(triggerDefinition);
1: 		out.writeBoolean(referencingOld);
1: 		out.writeBoolean(referencingNew);
1: 		out.writeObject(oldReferencingName);
1: 		out.writeObject(newReferencingName);
1: 	}
1:  
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.TRIGGER_DESCRIPTOR_V01_ID; }
1: 
1: 	/** @see TupleDescriptor#getDescriptorType */
1: 	public String getDescriptorType()
1: 	{
1: 		return "Trigger";
1: 	}
1: 
1: 	/** @see TupleDescriptor#getDescriptorName */
1: 	public String getDescriptorName() { return name; }
1: 	
1: }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stmtType	the type of DML 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:81ad58c
/////////////////////////////////////////////////////////////////////////
1: 		    case DependencyManager.DROP_SYNONYM:
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.catalog.ReferencedColumns;
0: import org.apache.derby.catalog.UUID;
0: import java.sql.Timestamp;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0:  * A trigger.
0:  * <p>
0:  * We are dependent on TableDescriptors, SPSDescriptors (for our
0:  * WHEN clause and our action).  Note that we don't strictly
0:  * need to be dependent on out SPSes because we could just disallow
0:  * anyone from dropping an sps of type 'T', but to keep dependencies
0:  * uniform, we'll do be dependent.
0:  * <p>
0:  * We are a provider for DML (PreparedStatements or SPSes)
0:  *
0:  * The public methods for this class are:
0:  *
0:  * <ol>
0:  * <li>getUUID
0:  * <li>getName
0:  * <li>getSchemaDescriptor
0:  * <li>	public boolean listensForEvent(int event);
0:  * <li>	public int getTriggerEventMask();
0:  * <li>	public Timestamp getCreationTimestamp();
0:  * <li>	public boolean isBeforeTrigger();
0:  * <li> public boolean isRowTrigger();
0:  * <li> public UUID getActionId();
0:  * <li> public SPSDescriptor getActionSPS();
0:  * <li>	public UUID getWhenClauseId();
0:  * <li>	public SPSDescriptor getWhenClauseSPS()
0:  * <li>	public TableDescriptor getTableDescriptor()
0:  * <li> public ReferencedColumns getReferencedColumnsDescriptor()
0:  * <li> public int[] getReferencedCols();
0:  * <li> public boolean isEnabled();
0:  * <li> public void setEnabled();
0:  * <li> public void setDisabled();
0:  * <li> public boolean needsToFire(int stmtType, int[] modifiedCols)
0:  * <li> public String getTriggerDefinition();
0:  * <li> public boolean getReferencingOld();
0:  * <li> public boolean getReferencingNew();
0:  * <li> public String getOldReferencingName();
0:  * <li> public String getNewReferencingName();
0:  * </ol>
0:  * @author Jamie
0:  */
0: public class TriggerDescriptor extends TupleDescriptor
0: 	implements UniqueSQLObjectDescriptor, Provider, Dependent, Formatable 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	// field that we want users to be able to know about
0: 	public static final int SYSTRIGGERS_STATE_FIELD = 8;
0: 
0: 	public static final int TRIGGER_EVENT_UPDATE = 1;
0: 	public static final int TRIGGER_EVENT_DELETE = 2;
0: 	public static final int TRIGGER_EVENT_INSERT = 4;
0: 
0: 	
0: 	private	UUID				id;
0: 	private String				name;
0: 	private String				oldReferencingName;
0: 	private String				newReferencingName;
0: 	private String				triggerDefinition;
0: 	private SchemaDescriptor	sd;
0: 	private int					eventMask;
0: 	private boolean				isBefore;
0: 	private boolean 			isRow;
0: 	private boolean				referencingOld;
0: 	private boolean				referencingNew;
0: 	private	TableDescriptor		td;
0: 	private	UUID				actionSPSId;
0: 	private SPSDescriptor		actionSPS;
0: 	private	UUID				whenSPSId;
0: 	private SPSDescriptor		whenSPS;
0: 	private	boolean				isEnabled;
0: 	private	int[]				referencedCols;
0: 	private	Timestamp			creationTimestamp;
0: 	private UUID				triggerSchemaId;
0: 	private UUID				triggerTableId;
0: 
0: 
0: 	/**
0: 	 * Niladic constructor, for formatable
0: 	 */
0: 	public TriggerDescriptor() {}
0: 
0: 	/**
0: 	 * Constructor.  Used when creating a trigger from SYS.SYSTRIGGERS
0: 	 *
0: 	 * @param dataDictionary 	the data dictionary
0: 	 * @param sd	the schema descriptor for this trigger
0: 	 * @param id	the trigger id
0: 	 * @param name	the trigger name
0: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
0: 	 * @param isBefore	is this a before (as opposed to after) trigger 
0: 	 * @param isRow		is this a row trigger or statement trigger
0: 	 * @param isEnabled	is this trigger enabled or disabled
0: 	 * @param td		the table upon which this trigger is defined
0: 	 * @param whenSPSId	the sps id for the when clause (may be null)
0: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
0: 	 * @param creationTimestamp	when was this trigger created?
0: 	 * @param referencedCols	what columns does this trigger reference (may be null)
0: 	 * @param triggerDefinition The original user text of the trigger action
0: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
0: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
0: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
0: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
0: 	 */
0: 	public TriggerDescriptor
0: 	(
0: 		DataDictionary		dataDictionary,
0: 		SchemaDescriptor	sd,
0: 		UUID				id,
0: 		String				name,
0: 		int					eventMask,
0: 		boolean				isBefore,
0: 		boolean				isRow,
0: 		boolean				isEnabled,
0: 		TableDescriptor		td,
0: 		UUID				whenSPSId,
0: 		UUID				actionSPSId,
0: 		Timestamp			creationTimestamp,
0: 		int[]				referencedCols,
0: 		String				triggerDefinition,
0: 		boolean				referencingOld,
0: 		boolean				referencingNew,
0: 		String				oldReferencingName,
0: 		String				newReferencingName
0: 	)
0: 	{
0: 		super(dataDictionary);
0: 		this.id = id;
0: 		this.sd = sd;
0: 		this.name = name;
0: 		this.eventMask = eventMask;
0: 		this.isBefore = isBefore;
0: 		this.isRow = isRow;
0: 		this.td = td;
0: 		this.actionSPSId = actionSPSId; 
0: 		this.whenSPSId = whenSPSId;
0: 		this.isEnabled = isEnabled;
0: 		this.referencedCols = referencedCols;
0: 		this.creationTimestamp = creationTimestamp;
0: 		this.triggerDefinition = triggerDefinition;
0: 		this.referencingOld = referencingOld;
0: 		this.referencingNew = referencingNew;
0: 		this.oldReferencingName = oldReferencingName;
0: 		this.newReferencingName = newReferencingName;
0: 		triggerSchemaId = sd.getUUID();
0: 		triggerTableId = td.getUUID();
0: 	}	
0: 		
0: 		
0: 	/**
0: 	 * Get the trigger UUID
0: 	 *
0: 	 * @return the id
0: 	 */
0: 	public UUID getUUID()
0: 	{
0: 		return id;
0: 	}
0: 
0: 	/**
0: 	 * Get the trigger name
0: 	 *
0: 	 * @return	the name
0: 	 */
0: 	public String getName()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	public UUID getTableId() {
0: 		return triggerTableId;
0: 	}
0: 
0: 	/**
0: 	 * Get the triggers schema descriptor
0: 	 *
0: 	 * @return the schema descriptor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	 public SchemaDescriptor getSchemaDescriptor()
0: 		 throws StandardException
0: 	{
0: 		if (sd == null)
0: 		{
0: 			sd = getDataDictionary().getSchemaDescriptor(triggerSchemaId, null);
0: 		}
0: 		return sd;
0: 	}
0: 
0: 	/**
0: 	 * Indicate whether this trigger listens for this
0: 	 * type of event.
0: 	 *
0: 	 * @param event TRIGGER_EVENT_XXXX
0: 	 *
0: 	 * @return true if it listens to the specified event.
0: 	 */ 
0: 	public boolean listensForEvent(int event)
0: 	{
0: 		return (event & eventMask) == event;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the trigger event mask.  Currently, a trigger
0: 	 * may only listen for a single event, though it may
0: 	 * OR multiple events in the future.
0: 	 *
0: 	 * @return the trigger event mask
0: 	 */
0: 	public int getTriggerEventMask()
0: 	{
0: 		return eventMask;
0: 	}
0: 
0: 	/**
0: 	 * Get the time that this trigger was created.
0: 	 *
0: 	 * @return the time the trigger was created
0: 	 */
0: 	public Timestamp getCreationTimestamp()
0: 	{
0: 		return creationTimestamp;
0: 	}
0: 
0: 	/**
0: 	 * Is this a before trigger
0: 	 *
0: 	 * @return true if it is a before trigger
0: 	 */
0: 	public boolean isBeforeTrigger()
0: 	{
0: 		return isBefore;
0: 	}
0: 
0: 	/**
0: 	 * Is this a row trigger
0: 	 *
0: 	 * @return true if it is a before trigger
0: 	 */
0: 	public boolean isRowTrigger()
0: 	{
0: 		return isRow;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the trigger action sps UUID
0: 	 *
0: 	 * @return the uuid of the sps action
0: 	 */
0: 	public UUID getActionId()
0: 	{
0: 		return actionSPSId;
0: 	}
0: 
0: 	/**
0: 	 * Get the trigger action sps
0: 	 *
0: 	 * @return the trigger action sps
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public SPSDescriptor getActionSPS(LanguageConnectionContext lcc)
0: 		throws StandardException
0: 	{
0: 		if (actionSPS == null)
0: 		{
0: 			//bug 4821 - do the sysstatement look up in a nested readonly
0: 			//transaction rather than in the user transaction. Because of
0: 			//this, the nested compile transaction which is attempting to
0: 			//compile the trigger will not run into any locking issues with
0: 			//the user transaction for sysstatements.
0: 			lcc.beginNestedTransaction(true);
0: 			actionSPS = getDataDictionary().getSPSDescriptor(actionSPSId);
0: 			lcc.commitNestedTransaction();
0: 		}
0: 		return actionSPS;
0: 	}
0: 
0: 	/**
0: 	 * Get the trigger when clause sps UUID
0: 	 *
0: 	 * @return the uuid of the sps action
0: 	 */
0: 	public UUID getWhenClauseId()
0: 	{
0: 		return whenSPSId;
0: 	}
0: 
0: 	/**
0: 	 * Get the trigger when clause sps 
0: 	 *
0: 	 * @return the sps of the when clause
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public SPSDescriptor getWhenClauseSPS()
0: 		throws StandardException
0: 	{
0: 		if (whenSPS == null)
0: 		{
0: 			whenSPS = getDataDictionary().getSPSDescriptor(whenSPSId);
0: 		}
0: 		return whenSPS;
0: 	}
0: 
0: 	/**
0: 	 * Get the trigger table descriptor
0: 	 *
0: 	 * @return the table descripor upon which this trigger
0:  	 * is declared
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public TableDescriptor getTableDescriptor()
0: 		throws StandardException
0: 	{
0: 		if (td == null)
0: 		{
0: 			td = getDataDictionary().getTableDescriptor(triggerTableId);
0: 		}
0: 		return td;
0: 	}
0: 
0: 	/**
0: 	 * Get the referenced table descriptor for this trigger.
0: 	 *
0: 	 * @return the referenced table descriptor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	// caller converts referencedCols to referencedColsDescriptor...
0: //  	public ReferencedColumns getReferencedColumnsDescriptor()
0: //  		throws StandardException
0: //  	{
0: //  		return (referencedCols == null) ? 
0: //  				(ReferencedColumns)null :
0: //  				new ReferencedColumnsDescriptorImpl(referencedCols);
0: //  	}
0: 
0: 	/**
0: 	 * Get the referenced column array for this trigger, used in "alter table
0: 	 * drop column", we get the handle and change it
0: 	 *
0: 	 * @return the referenced column array
0: 	 */
0: 	public int[] getReferencedCols()
0: 	{
0: 		return referencedCols;
0: 	}
0: 
0: 	/**
0: 	 * Is this trigger enabled
0: 	 *
0: 	 * @return true if it is enabled
0: 	 */
0: 	public boolean isEnabled()
0: 	{
0: 		return isEnabled;
0: 	}
0: 
0: 	/**
0: 	 * Mark this trigger as enabled
0: 	 *
0: 	 */
0: 	public void setEnabled()
0: 	{
0: 		isEnabled = true;
0: 	}
0: 
0: 	/**
0: 	 * Mark this trigger as disabled
0: 	 *
0: 	 */
0: 	public void setDisabled()
0: 	{
0: 		isEnabled = false;
0: 	}
0: 
0: 	/**
0: 	 * Does this trigger need to fire on this type of
0: 	 * DML?
0: 	 *
0: 	 * @param dmlType	the type of DML 
0: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
0: 	 * @param modifiedCols	the columns modified, or null for all
0: 	 *
0: 	 * @return true/false
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public boolean needsToFire(int stmtType, int[] modifiedCols)
0: 		throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!((stmtType == StatementType.INSERT) ||
0: 								 (stmtType == StatementType.BULK_INSERT_REPLACE) ||
0: 								 (stmtType == StatementType.UPDATE) ||
0: 								 (stmtType == StatementType.DELETE)))
0: 			{
0: 				SanityManager.THROWASSERT("invalid statement type "+stmtType);
0: 			}
0: 		}
0: 
0: 		/*
0: 		** If we are disabled, we never fire
0: 		*/
0: 		if (!isEnabled)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		if (stmtType == StatementType.INSERT)
0: 		{
0:  			return (eventMask & TRIGGER_EVENT_INSERT) == eventMask;
0: 		}
0: 		if (stmtType == StatementType.DELETE) 
0: 		{
0: 			return (eventMask & TRIGGER_EVENT_DELETE) == eventMask;
0: 		}
0: 
0: 		// this is a temporary restriction, but it may not be lifted
0: 		// anytime soon.
0: 		if (stmtType == StatementType.BULK_INSERT_REPLACE)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NO_BULK_INSERT_REPLACE_WITH_TRIGGER, 
0: 												 getTableDescriptor().getQualifiedName(), name);
0: 		}
0: 
0: 		// if update, only relevant if columns intersect
0: 		return ((eventMask & TRIGGER_EVENT_UPDATE) == eventMask) &&
0: 				ConstraintDescriptor.doColumnsIntersect(modifiedCols, referencedCols);
0: 	}
0: 
0: 	/**
0: 	 * Get the original trigger definition.
0: 	 *
0: 	 * @return The trigger definition.
0: 	 */
0: 	public String getTriggerDefinition()
0: 	{
0: 		return triggerDefinition;
0: 	}
0: 
0: 	/**
0: 	 * Get whether or not OLD was replaced
0: 	 * in the REFERENCING clause.
0: 	 *
0: 	 * @return Whether or not OLD was replaced
0: 	 * in the REFERENCING clause.
0: 	 */
0: 	public boolean getReferencingOld()
0: 	{
0: 		return referencingOld;
0: 	}
0: 
0: 	/**
0: 	 * Get whether or not NEW was replaced
0: 	 * in the REFERENCING clause.
0: 	 *
0: 	 * @return Whether or not NEW was replaced
0: 	 * in the REFERENCING clause.
0: 	 */
0: 	public boolean getReferencingNew()
0: 	{
0: 		return referencingNew;
0: 	}
0: 
0: 	/**
0: 	 * Get the old Referencing name, if any,
0: 	 * from the REFERENCING clause.
0: 	 *
0: 	 * @return The old Referencing name, if any,
0: 	 * from the REFERENCING clause.
0: 	 */
0: 	public String getOldReferencingName()
0: 	{
0: 		return oldReferencingName;
0: 	}
0: 
0: 	/**
0: 	 * Get the new Referencing name, if any,
0: 	 * from the REFERENCING clause.
0: 	 *
0: 	 * @return The new Referencing name, if any,
0: 	 * from the REFERENCING clause.
0: 	 */
0: 	public String getNewReferencingName()
0: 	{
0: 		return newReferencingName;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "TRIGGER: "+name;
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////
0: 	//
0: 	// PROVIDER INTERFACE
0: 	//
0: 	////////////////////////////////////////////////////////////////////
0: 
0: 	/**		
0: 	 * @return the stored form of this provider
0: 	 *
0: 	 * @see Dependable#getDependableFinder
0: 	 */
0: 	public DependableFinder getDependableFinder() 
0: 	{
0: 	    return getDependableFinder(StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID);
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Provider.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this provider.
0: 	 */
0: 	public String getObjectName()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's UUID
0: 	 *
0: 	 * @return 	The provider's UUID
0: 	 */
0: 	public UUID getObjectID()
0: 	{
0: 		return id;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's type.
0: 	 *
0: 	 * @return char		The provider's type.
0: 	 */
0: 	public String getClassType()
0: 	{
0: 		return Dependable.TRIGGER;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////
0: 	//
0: 	// DEPENDENT INTERFACE
0: 	//
0: 	// Triggers are dependent on the underlying table,
0:  	// and their spses (for the trigger action and the WHEN
0: 	// clause).
0: 	//
0: 	//////////////////////////////////////////////////////
0: 	/**
0: 	 * Check that all of the dependent's dependencies are valid.
0: 	 *
0: 	 * @return true if the dependent is currently valid
0: 	 */
0: 	public synchronized boolean isValid()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Prepare to mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).
0: 	 *
0: 	 * @param action	The action causing the invalidation
0: 	 * @param p			the provider
0: 	 * @param lcc		the language connection context
0: 	 *
0: 	 * @exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public void prepareToInvalidate
0: 	(
0: 		Provider 					p, 
0: 		int							action, 
0: 		LanguageConnectionContext	lcc
0: 	) throws StandardException
0: 	{
0: 		
0: 
0: 		switch (action)
0: 		{
0: 			/*
0: 			** We are only dependent on the underlying
0: 			** table, and our spses.  (we should be
0: 			** dropped before our table is dropped).
0: 			*/
0: 		    case DependencyManager.DROP_TABLE:
0: 		    case DependencyManager.DROP_SPS:
0: 		    case DependencyManager.RENAME:
0: 				DependencyManager dm = getDataDictionary().getDependencyManager();
0: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
0: 									dm.getActionString(action), 
0: 									p.getObjectName(), "TRIGGER", name);
0: 
0: 			/*
0: 			** The trigger descriptor depends on the trigger table.
0: 			** This means that we get called whenever anything happens
0: 			** to the trigger table. There are so many cases where this
0: 			** can happen that it doesn't make sense to have an assertion
0: 			** here to check whether the action was expected (it makes
0: 			** the code hard to maintain, and creates a big switch statement).
0: 			*/
0: 			default:
0: 				break;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).  Always an error
0: 	 * for a trigger -- should never have gotten here.
0: 	 *
0: 	 * @param 	lcc the language connection context
0: 	 * @param	action	The action causing the invalidation
0: 	 *
0: 	 * @exception StandardException thrown if called in sanity mode
0: 	 */
0: 	public void makeInvalid(int action, LanguageConnectionContext lcc) throws StandardException
0: 	{
0: 		// No sanity check for valid action. Trigger descriptors depend on
0: 		// the trigger table, so there is a very large number of actions
0: 		// that we would have to check against. This is hard to maintain,
0: 		// so don't bother.
0: 	}
0: 
0: 	/**
0:      * Attempt to revalidate the dependent. Meaningless
0: 	 * for a trigger.
0: 	 *
0: 	 * @param 	lcc the language connection context
0: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
0: 	{
0: 	}
0: 
0: 
0: 	//////////////////////////////////////////////////////////////
0: 	//
0: 	// FORMATABLE
0: 	//
0: 	//////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal(ObjectInput in)
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		id = (UUID)in.readObject();
0: 		name = (String)in.readObject();
0: 		triggerSchemaId = (UUID)in.readObject();
0: 		triggerTableId = (UUID)in.readObject();
0: 		eventMask = in.readInt();
0: 		isBefore = in.readBoolean();
0: 		isRow = in.readBoolean();
0: 		isEnabled = in.readBoolean();
0: 		whenSPSId = (UUID)in.readObject();
0: 		actionSPSId = (UUID)in.readObject();
0: 		int length = in.readInt();
0: 		if (length != 0)
0: 		{
0: 			referencedCols = new int[length];
0: 			for (int i = 0; i < length; i++)
0: 			{
0: 				referencedCols[i] = in.readInt();
0: 			}
0: 		}
0: 		triggerDefinition = (String)in.readObject();
0: 		referencingOld = in.readBoolean();
0: 		referencingNew = in.readBoolean();
0: 		oldReferencingName = (String)in.readObject();
0: 		newReferencingName = (String)in.readObject();
0: 		
0: 	}
0: 
0: 	protected DataDictionary getDataDictionary() throws StandardException
0: 	{
0: 		/*
0:  		  note: we need to do this since when this trigger is read back from
0: 		  disk (when it is associated with a sps), the dataDictionary has not 
0:  		  been initialized and therefore can give a NullPointerException
0:  		*/
0: 		DataDictionary dd = super.getDataDictionary();
0:  		if (dd == null)
0:  		{
0:   			LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0:   			dd = lcc.getDataDictionary();
0: 			setDataDictionary(dd);
0:   		}
0: 		return dd;
0:  	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException		thrown on error
0: 	 */
0: 	public void writeExternal( ObjectOutput out )
0: 		 throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(triggerSchemaId != null,
0: 				"triggerSchemaId expected to be non-null");
0: 			SanityManager.ASSERT(triggerTableId != null,
0: 				"triggerTableId expected to be non-null");
0: 		}
0: 		out.writeObject(id);
0: 		out.writeObject(name);
0: 		out.writeObject(triggerSchemaId);
0: 		out.writeObject(triggerTableId);
0: 		out.writeInt(eventMask);
0: 		out.writeBoolean(isBefore);
0: 		out.writeBoolean(isRow);
0: 		out.writeBoolean(isEnabled);
0: 		out.writeObject(whenSPSId);
0: 		out.writeObject(actionSPSId);
0: 		if (referencedCols == null)
0: 		{
0: 			out.writeInt(0);
0: 		}
0: 		else
0: 		{
0: 			out.writeInt(referencedCols.length);
0: 			for (int i = 0; i < referencedCols.length; i++)
0: 			{
0: 				out.writeInt(referencedCols[i]);
0: 			}
0: 		}	
0: 		out.writeObject(triggerDefinition);
0: 		out.writeBoolean(referencingOld);
0: 		out.writeBoolean(referencingNew);
0: 		out.writeObject(oldReferencingName);
0: 		out.writeObject(newReferencingName);
0: 	}
0:  
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.TRIGGER_DESCRIPTOR_V01_ID; }
0: 
0: 	/** @see TupleDescriptor#getDescriptorType */
0: 	public String getDescriptorType()
0: 	{
0: 		return "Trigger";
0: 	}
0: 
0: 	/** @see TupleDescriptor#getDescriptorName */
0: 	public String getDescriptorName() { return name; }
0: 	
0: }
0: 
============================================================================