1:fd46794: /*
1:7ecc1f2: 
1:fd46794:    Derby - Class org.apache.derby.iapi.services.info.ProductVersionHolder
1:fd46794: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:fd46794: 
1:fd46794:       http://www.apache.org/licenses/LICENSE-2.0
1:fd46794: 
1:fd46794:    Unless required by applicable law or agreed to in writing, software
1:fd46794:    distributed under the License is distributed on an "AS IS" BASIS,
1:fd46794:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fd46794:    See the License for the specific language governing permissions and
1:fd46794:    limitations under the License.
1:fd46794: 
1:fd46794: */
1:7ecc1f2: 
1:eac0369: package org.apache.derby.iapi.services.info;
2:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:3fd26f3:   Class to hold a Derby Product version.
1:eac0369: 
1:eac0369:   This class includes the following product version features.
1:eac0369: 
1:eac0369:   <OL>
1:eac0369:   <LI>Save the product version information this holds as a String. We call
1:eac0369:       the string a 'product version string'.
1:eac0369:   <LI>Construct a ProductVersionHolder from a valid 'product version string'.
1:eac0369:   <LI>Determine if two product versions are feature compatible. This means
1:eac0369:       products of these versions may interoperate with ***NO*** compatibility
1:eac0369: 	  problems.
1:eac0369:   <LI>Determine if two product versions are the same. This is a stronger
1:eac0369:       test than the test for feature compatibility.
1:eac0369:   </OL>
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:   Cloudscape 5.1 and older versions used the majorVersion, minorVersion, maintVersion versions
1:eac0369:   directly. That is a three part version number, majorVersion.minorVersion.maintVersion, e.g. 5.1.21.
1:eac0369: 
1:eac0369:   For Cloudscape 5.2 onwards a four part name is required.
1:eac0369: 	majorVersion.minorVersion.fixPack.bugVersion e.g. 5.2.1.2
1:eac0369: 
1:eac0369: 	This follows the IBM standard and allows us to state that a fix pack will be 5.2.3 without worrying
1:eac0369: 	about how many maintence fixes there are between fix packs.
1:eac0369: 
1:eac0369: 	We implement this using the existing format of ProductVersionHolder to reduce disruption to the
1:eac0369: 	code, however we make the maintVersion encode the {fixPack.bugVersion}. Since the maintVersion
1:eac0369: 	is represented by a int (2G values) we have plenty of room for encoding. If we assign a given
1:eac0369: 	majorVersion.minorVersion.fixPack a 10 year life, then we about the maximum number of individual releases
1:eac0369: 	it can have is 10 years * 365 days/year = 3650. Thus with the pre 5.2 scheme we would not expect a 
1:dbed020: 	5.1.x to have an x &gt; 3650 (approximately). Usually the rate of point releases has been much less than
1:eac0369: 	one per day, 5.1.31 is released about 225 days after GA which makes around a point release every 7 days.
1:eac0369: 	But in the encoding we need to be conservative. With fix packs the maximum is about 2 per year and fix
1:eac0369: 	packs are only made to the current release, thus with a yearly minor release cycle we would imagine
1:eac0369: 	only 2 fixpacks per major.minor. However like other IBM products or release cycle may be extended thus
1:eac0369: 	we can expect up to a handful of fix packs.
1:eac0369: 
1:eac0369: 	Thus we might imagine releases like
1:eac0369: 
1:eac0369: 	5.2.0.12
1:eac0369: 	5.2.0.234
1:eac0369: 	5.2.1.34
1:eac0369: 	5.2.4.2445
1:eac0369: 
1:eac0369:   but highly unlikey to have
1:eac0369: 
1:eac0369: 	5.2.2.59321
1:eac0369: 	5.2.23.1
1:eac0369: 	
1:eac0369: 
1:eac0369:     The encoding number must continue to increase so that the
1:eac0369: 	
1:dbed020: 		encodedMaintB &gt; encodedMaintA
1:eac0369: 
1:dbed020: 		if (fixPackB &gt; fixPackA) || ((fixPackB == fixPackA) &amp;&amp; (bugB &gt; bugA))
1:eac0369: 
1:eac0369: 
1:eac0369: 	Selected encoding
1:eac0369: 
1:eac0369: 	encodedMaint = (fixPack * 1,000,000) + (bugVersion);
1:eac0369: 
1:eac0369: 	Handles many many fixpacks and upto one million bug fixes per fix pack and remains somewhat human readable.
1:eac0369: 
1:eac0369: 	Special fix packs
1:eac0369: 
1:eac0369: 	fixpack == 0 = alpha (version off main codeline)
1:eac0369: 	fixpack == 1 = first release of major.minor (may be marked with beta)
1:eac0369: 	fixpack == 2 = first fix pack (displayed as 1)
1:eac0369:      
1:eac0369: 
1:eac0369: 	The drdaMaintVersion is sent in the Network Server PRDID. It never displays
1:eac0369:     but may be used by the client for version specific behaviour. It should be 
1:eac0369: 	reset to 0 with each minor release.	
1:eac0369: 
1:eac0369:   The product version string has the form:
1:eac0369:   <PRE>
1:eac0369:   productVendorName - ProductName - majorVersion.minorVersion.maintVersion [beta] - (buildNumber)
1:eac0369: 
1:eac0369:   </PRE>
1:eac0369: 
3:eac0369:   */
1:073b862: public final class ProductVersionHolder implements java.security.PrivilegedAction<Properties>
1:eac0369: {
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//Used as an invalid value for numbers. This works because all
1:eac0369: 	//the numbers in a product version must be non-negative.
1:eac0369: 	private static final int BAD_NUMBER = -1;
1:eac0369: 	private static final String ALPHA = "alpha";
1:eac0369: 	private static final String BETA = "beta";
1:eac0369: 
1:41205b9: 	public final static int	MAINT_ENCODING = org.apache.derbyPreBuild.ReleaseProperties.MAINT_ENCODING;
1:eac0369: 	
1:eac0369: 	private String productVendorName;
1:eac0369: 	private String productName;
1:eac0369: 	private String productTechnologyName;
1:eac0369: 	private int majorVersion = BAD_NUMBER;
1:eac0369: 	private int minorVersion = BAD_NUMBER;
1:eac0369: 	private int maintVersion = BAD_NUMBER;
1:eac0369: 	private int drdaMaintVersion = BAD_NUMBER;
1:0a7339d: 	private String buildNumber = "????";
1:eac0369: 	private Boolean isBeta;
1:eac0369: 
1:eac0369: 	private ProductVersionHolder() {
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Create a ProductVersionHolder
1:eac0369: 
1:eac0369: 	  <P>Please see the documentation for the varient of getProductVesionHolder
1:eac0369: 	  that takes the same parameters as this for a description of the parameters.
1:eac0369: 	  */
1:eac0369: 	private ProductVersionHolder(String productVendorName,
1:eac0369: 								 String productName,
1:eac0369: 								 String productTechnologyName,
1:eac0369: 								 int majorVersion,
1:eac0369: 								 int minorVersion,
1:eac0369: 								 int maintVersion,
1:eac0369: 								 int drdaMaintVersion,
1:0a7339d: 								 String buildNumber,
1:eac0369: 								 Boolean isBeta)
1:eac0369: 	{
1:eac0369: 		if (productVendorName != null)
1:eac0369: 			this.productVendorName = productVendorName.trim();
1:eac0369: 		if (productName != null)
1:eac0369: 			this.productName = productName.trim();
1:eac0369: 		if (productTechnologyName != null)
1:eac0369: 			this.productTechnologyName = productTechnologyName.trim();
1:eac0369: 		this.majorVersion = majorVersion;
1:eac0369: 		this.minorVersion = minorVersion;
1:eac0369: 		this.maintVersion = maintVersion;
1:eac0369: 		this.drdaMaintVersion = drdaMaintVersion;
1:eac0369: 		this.buildNumber = buildNumber;
1:eac0369: 		this.isBeta = isBeta;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Create a valid ProductVersionHolder. If any of the
1:eac0369: 	  parameters provided is invalid, this returns null.
1:eac0369: 	  @param productName The name of the product. productName.length()
1:eac0369: 	  must be greater than 0. The syntax for a product name is
1:eac0369: 	  'productGenus[:productSpecies]'. 
1:eac0369: 	  @param majorVersion The most significant portion of a 3 
1:eac0369: 	  part product version.  Must be non-negative.
1:eac0369: 	  @param minorVersion The second portion of a 3 part 
1:eac0369: 	  product version. Must be non-negative.
1:eac0369: 	  @param maintVersion The least significant portion of a 3 part
1:eac0369: 	  product version. Must be non-negative.
1:eac0369: 	  @param drdaMaintVersion The protocol modification number for minor release.
1:0a7339d: 	  @param buildNumber The buildNumber for a product. 
1:eac0369: 	  @param isBeta true iff the product is beta.
1:eac0369: 	  @return A valid ProductVersionHolder of null if any of the parameters
1:eac0369: 	  provided are not valid.
1:eac0369: 	  */
1:eac0369: 	public static ProductVersionHolder
1:eac0369: 	getProductVersionHolder(
1:eac0369: 						   String productVendorName,
1:eac0369: 						   String productName,
1:eac0369: 						   String productTechnologyName,
1:eac0369: 						   int majorVersion,
1:eac0369: 						   int minorVersion,
1:eac0369: 						   int maintVersion,
1:eac0369: 						   int drdaMaintVersion,
1:0a7339d: 						   String buildNumber,
1:eac0369: 						   Boolean isBeta)
1:eac0369: 	{
1:eac0369: 		ProductVersionHolder pvh =
1:eac0369: 			new ProductVersionHolder(productVendorName,
1:eac0369: 									 productName,
1:eac0369: 									 productTechnologyName,
1:eac0369: 									 majorVersion,
1:eac0369: 									 minorVersion,
1:eac0369: 									 maintVersion,
1:eac0369: 									 drdaMaintVersion,
1:eac0369: 									 buildNumber,
1:eac0369: 									 isBeta);
1:eac0369: 		return pvh;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Get a ProductVersionHolder for a product of a given genus,
1:eac0369: 	  that is available in the caller's environment. 
1:eac0369: 	  Even though this uses a priv bock, it may stil fail when
1:eac0369: 	  the jar the version is being fetched from, is different to the
1:eac0369: 	  one that loaded this class, AND the jars are in different security contexts.
1:eac0369: 
1:eac0369: 	  @param productGenus The genus for the product.
1:eac0369: 	  @return The ProductVersionHolder or null if
1:eac0369: 	  a product with the given genus is not available in the
1:eac0369: 	  caller's environment.
1:eac0369: 	  */
1:eac0369: 	public static ProductVersionHolder
1:eac0369: 	getProductVersionHolderFromMyEnv(String productGenus)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		ProductVersionHolder tempPVH = new ProductVersionHolder();
1:eac0369: 
1:eac0369: 		tempPVH.productGenus = productGenus;
1:eac0369: 		Properties p = (Properties) java.security.AccessController.doPrivileged(tempPVH);
1:eac0369: 
1:eac0369: 		if (p == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		return getProductVersionHolder(p);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Load the version info from the already opened properties files.
1:eac0369: 		We need to do this because if the jar files (e.g. db2jtools and db2j)
1:eac0369: 		are in different security contexts (entries in the policy files) then
1:eac0369: 		we cannot load the version information for one of them correctly.
1:eac0369: 		This is because the this class will either have been loaded from
1:eac0369: 		only one of the jars and hence can only access the resource in its own jar.
1:eac0369: 		By making code specific to the jar open the resource we are guaranteed it will work.
1:eac0369: 	*/
1:eac0369: 	public static ProductVersionHolder
1:eac0369: 	getProductVersionHolderFromMyEnv(InputStream propertiesStream)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (propertiesStream == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		Properties p = new Properties();
1:eac0369: 		try {
1:eac0369: 			p.load(propertiesStream);
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe) {
1:eac0369: 
1:eac0369: 			System.out.println("IOE " + ioe.getMessage());
1:eac0369: 			//
1:eac0369: 			//This case is a bit ugly. If we get an IOException, we return
1:eac0369: 			//null. Though this correctly reflects that the product is not
1:eac0369: 			//available for use, it may be confusing to users that we swallow
1:eac0369: 			//the IO error here.
1:eac0369: 			return null;
1:eac0369: 		} finally {
1:eac0369: 			try {
1:eac0369: 				propertiesStream.close();
1:eac0369: 			} catch (IOException ioe2) {
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return getProductVersionHolder(p);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get a ProductVersionHolder based on the information in
1:eac0369: 	  the Properties object provided.
1:eac0369: 
1:eac0369: 	  @param p The properties object that holds the productVersion
1:eac0369: 	  information.
1:eac0369: 	  @return The ProductVersionHolder or null if
1:eac0369: 	  a product with the given genus is not available in the
1:eac0369: 	  caller's environment.
1:eac0369: 	  */
1:eac0369: 	public static ProductVersionHolder
1:eac0369: 	getProductVersionHolder(Properties p)
1:eac0369: 	{
1:eac0369: 		String pvn = p.getProperty(PropertyNames.PRODUCT_VENDOR_NAME);
1:eac0369: 		String pn = p.getProperty(PropertyNames.PRODUCT_EXTERNAL_NAME);
1:eac0369: 		String ptn = p.getProperty(PropertyNames.PRODUCT_TECHNOLOGY_NAME);
1:eac0369: 		int v1 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAJOR_VERSION));
1:eac0369: 		int v2 = parseInt(p.getProperty(PropertyNames.PRODUCT_MINOR_VERSION));
1:eac0369: 		int v3 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAINT_VERSION));
1:eac0369: 		int v4 = parseInt(p.getProperty(PropertyNames.PRODUCT_DRDA_MAINT_VERSION));
1:0a7339d: 		String bn = p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER);
1:eac0369: 		Boolean isBeta =
1:eac0369: 			Boolean.valueOf(p.getProperty(PropertyNames.PRODUCT_BETA_VERSION));
1:eac0369: 		return 	getProductVersionHolder(pvn,pn,ptn,v1,v2,v3,v4,bn,isBeta);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return the product vendor name.
1:eac0369: 	  */
1:eac0369: 	public String getProductVendorName()
1:eac0369: 	{
1:eac0369: 		return productVendorName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return the external product name.
1:eac0369: 	  */
1:eac0369: 	public String getProductName()
1:eac0369: 	{
1:eac0369: 		return productName;
1:eac0369: 	}
1:eac0369: 	public String getProductTechnologyName()
1:eac0369: 	{
1:eac0369: 		return productTechnologyName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return the major version number.
1:eac0369: 	  */
1:eac0369: 	public int getMajorVersion() {return majorVersion;}
1:eac0369: 	/**
1:eac0369: 	  Return the minor version number.
1:eac0369: 	  */
1:eac0369: 	public int getMinorVersion() {return minorVersion;}
1:eac0369: 	/**
1:eac0369: 	  Return the <B>encoded</B> maintainence version number.
1:eac0369: 	  */
1:eac0369: 	public int getMaintVersion() {return maintVersion;}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		Return the drda protocol maintenance version for this minor release.
1:eac0369: 		Starts at 0 for each minor release and only incremented 
1:eac0369: 		when client behaviour changes based on the server version.
1:eac0369: 	**/
1:eac0369: 	public int getDrdaMaintVersion() {return drdaMaintVersion; }
1:eac0369: 
1:eac0369: 	/**
1:0326967:        Return the fix pack version from the maintenance encoding.
1:eac0369: 	*/
1:eac0369: 	public int getFixPackVersion() { return maintVersion / MAINT_ENCODING; }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return true if this is a beta product.
1:eac0369: 	  */
1:eac0369: 	public boolean isBeta() {return isBeta.booleanValue();}
1:eac0369: 	/**
1:eac0369: 	  Return true if this is a alpha product.
1:eac0369: 	  */
1:eac0369: 	public boolean isAlpha() {
1:eac0369: 		return	   (majorVersion >= 5)
1:eac0369: 				&& (minorVersion > 2)
1:eac0369: 				&& ((maintVersion / MAINT_ENCODING) == 0);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	  Return the build number for this product.
1:eac0369: 	  */
1:0a7339d: 	public String getBuildNumber() {return buildNumber;}
1:eac0369: 
1:0a7339d:     /**
1:0a7339d:      * Return the build number as an integer if possible,
1:0a7339d:      * mapping from the SVN number.
1:dbed020:      * nnnnn -&gt; returns nnnnn
1:dbed020:      * nnnnnM -&gt; returns -nnnnn indicates a modified code base
1:dbed020:      * nnnnn:mmmmm -&gt; returns -nnnnn
1:dbed020:      * anything else -&gt; returns -1
1:0a7339d:     */
1:0a7339d:     public int getBuildNumberAsInt(){
1:0a7339d:     	if (buildNumber == null)
1:0a7339d:     	    return -1;
1:0a7339d:     	boolean dubiousCode = false;
1:0a7339d:     	int offset = buildNumber.indexOf('M');
1:0a7339d:     	if (offset == -1)
1:0a7339d:     	    offset = buildNumber.indexOf(':');
1:0a7339d:     	else
1:0a7339d:     	    dubiousCode = true;
1:0a7339d:     	if (offset == -1)
1:0a7339d:     		offset = buildNumber.length();
1:0a7339d:         else
1:0a7339d:             dubiousCode = true;
1:0a7339d:     	
1:0a7339d:     	try {
1:0a7339d:     		int bnai = Integer.parseInt(buildNumber.substring(0, offset));
1:0a7339d:     		if (dubiousCode)
1:0a7339d:     		    bnai = -bnai;
1:0a7339d:     		return bnai;
1:0a7339d:     	} catch (NumberFormatException nfe) 
1:0a7339d:      	{
1:0a7339d:      		return -1;
1:0a7339d:     	}
1:0a7339d:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Parse a string containing a non-negative integer. Return
1:eac0369: 	  a negative integer is the String is invalid.
1:eac0369: 
1:eac0369: 	  @param s A string with a non-negative integer (a sequence
1:eac0369: 	  of decimal digits.)
1:eac0369: 	  @return the integer or a negative number if s is invalid.
1:eac0369: 	  */
1:eac0369: 	private static int parseInt(String s)
1:eac0369: 	{
1:eac0369: 		//System.out.println("Parsing integer: "+s);		
1:eac0369: 		int result = BAD_NUMBER;
1:eac0369: 		try
1:eac0369: 			{
1:eac0369: 				if (s!=null)
1:eac0369: 					result = Integer.parseInt(s);
1:eac0369: 			}
1:eac0369: 		catch (NumberFormatException nfe)
1:eac0369: 			{}
1:eac0369: 
1:eac0369: 		if (result < 0) result = BAD_NUMBER;
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return  a string representation of this ProductVersion. The
1:eac0369: 	  difference between this and createProductVersionString, is
1:eac0369: 	  that this method retruns a String when this ProductVersionHolder
1:eac0369: 	  holds invalid version information.
1:eac0369: 	 */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		sb.append(getProductVendorName());
1:eac0369: 		sb.append(" - ");
1:eac0369: 		sb.append(getProductName());
1:eac0369: 		sb.append(" - ");
1:eac0369: 		sb.append(getVersionBuildString(true));
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the feature version string, ie. major.minor. (e.g. 5.2)
1:eac0369: 	*/
1:eac0369: 	public String getSimpleVersionString() {
1:eac0369: 
1:eac0369: 		return ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Convert a major and minor number with beta status into a string.
1:eac0369: 	*/
1:eac0369: 	public static String simpleVersionString(int major, int minor, boolean isBeta) {
1:eac0369: 
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 
1:eac0369: 		sb.append(major);
1:eac0369: 		sb.append('.');
1:eac0369: 		sb.append(minor);
1:eac0369: 		if (isBeta) {
1:eac0369: 			sb.append(' ');
1:eac0369: 			sb.append(BETA);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:0a7339d: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, String build) {
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		sb.append(major);
1:eac0369: 		sb.append('.');
1:eac0369: 		sb.append(minor);
1:eac0369: 		sb.append('.');
1:eac0369: 
1:eac0369: 		String preRelease = null;
1:eac0369: 		if (major == 5 && minor <= 2 && maint < MAINT_ENCODING)
1:eac0369: 		{
1:eac0369: 			sb.append(maint);
1:eac0369: 			if (isBeta)
1:eac0369: 				preRelease = BETA;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			int fixPack = maint / MAINT_ENCODING;
1:eac0369: 			int bugVersion = maint % MAINT_ENCODING;
1:eac0369: 			sb.append(fixPack);
1:eac0369: 			sb.append('.');
1:eac0369: 			sb.append(bugVersion);
1:eac0369: 
1:eac0369: 			if (fixPack == 0)
1:eac0369: 			{
1:eac0369: 				preRelease = ALPHA;
1:eac0369: 			}
1:eac0369: 			else if (isBeta) {
1:eac0369: 				preRelease = BETA;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (preRelease != null)
1:eac0369:         {
1:eac0369: 			sb.append(' ');
1:eac0369:             sb.append(preRelease);
1:eac0369:         }
1:0a7339d: 		if (build != null) {
1:eac0369: 			sb.append(" - (");
1:eac0369: 
1:eac0369: 			sb.append(build);
1:eac0369: 			sb.append(')');
1:eac0369: 		}
1:eac0369:         return sb.toString();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Returns a short-hand value for the product version string.
1:eac0369: 		Used by Sysinfo.
1:eac0369: 		Includes the optional <beta> designation
1:eac0369: 	*/
1:eac0369:     public String getVersionBuildString(boolean withBuild)
1:eac0369:     {
1:eac0369: 		return ProductVersionHolder.fullVersionString(majorVersion, minorVersion, maintVersion, isBeta(),
1:0a7339d: 			withBuild ? buildNumber : null);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Security related methods 
1:eac0369: 	*/
1:eac0369: 	private String productGenus;
1:073b862: 	public final Properties run() {
1:eac0369: 
1:eac0369: 		// SECURITY PERMISSION - IP4
1:eac0369: 		return loadProperties(this.productGenus);
1:eac0369: 	}
1:eac0369: 	// SECURITY PERMISSION - IP4
1:eac0369: 	private Properties loadProperties(String productGenus) {
1:eac0369: 		String resourceName = "/org/apache/derby/info/" + productGenus+".properties";
1:eac0369: 			
1:eac0369: 		InputStream is = getClass().getResourceAsStream(resourceName);
1:eac0369: 		if (is==null) {
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		Properties p = new Properties();
1:eac0369: 		try {
1:eac0369: 			p.load(is);
1:eac0369: 			return p;
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe) {
1:eac0369: 			//
1:eac0369: 			//This case is a bit ugly. If we get an IOException, we return
1:eac0369: 			//null. Though this correctly reflects that the product is not
1:eac0369: 			//available for use, it may be confusing to users that we swallow
1:eac0369: 			//the IO error here.
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	5.1.x to have an x &gt; 3650 (approximately). Usually the rate of point releases has been much less than
/////////////////////////////////////////////////////////////////////////
1: 		encodedMaintB &gt; encodedMaintA
1: 		if (fixPackB &gt; fixPackA) || ((fixPackB == fixPackA) &amp;&amp; (bugB &gt; bugA))
/////////////////////////////////////////////////////////////////////////
1:      * nnnnn -&gt; returns nnnnn
1:      * nnnnnM -&gt; returns -nnnnn indicates a modified code base
1:      * nnnnn:mmmmm -&gt; returns -nnnnn
1:      * anything else -&gt; returns -1
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: public final class ProductVersionHolder implements java.security.PrivilegedAction<Properties>
/////////////////////////////////////////////////////////////////////////
1: 	public final Properties run() {
commit:41205b9
/////////////////////////////////////////////////////////////////////////
1: 	public final static int	MAINT_ENCODING = org.apache.derbyPreBuild.ReleaseProperties.MAINT_ENCODING;
commit:6409b40
/////////////////////////////////////////////////////////////////////////
0: 	public final static int	MAINT_ENCODING = 1000000;
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:        Return the fix pack version from the maintenance encoding.
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1:   Class to hold a Derby Product version.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0: 	public final Object run() {
commit:fd46794
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derby.iapi.services.info.ProductVersionHolder
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1: 
0:  * Copyright 1998, 2004.WESTHAM
1: 
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:0a7339d
/////////////////////////////////////////////////////////////////////////
1: 	private String buildNumber = "????";
/////////////////////////////////////////////////////////////////////////
1: 								 String buildNumber,
/////////////////////////////////////////////////////////////////////////
1: 	  @param buildNumber The buildNumber for a product. 
/////////////////////////////////////////////////////////////////////////
1: 						   String buildNumber,
/////////////////////////////////////////////////////////////////////////
1: 		String bn = p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER);
/////////////////////////////////////////////////////////////////////////
1: 	public String getBuildNumber() {return buildNumber;}
1:     /**
1:      * Return the build number as an integer if possible,
1:      * mapping from the SVN number.
0:      * nnnnn -> returns nnnnn
0:      * nnnnnM -> returns -nnnnn indicates a modified code base
0:      * nnnnn:mmmmm -> returns -nnnnn
0:      * anything else -> returns -1
1:     */
1:     public int getBuildNumberAsInt(){
1:     	if (buildNumber == null)
1:     	    return -1;
1:     	boolean dubiousCode = false;
1:     	int offset = buildNumber.indexOf('M');
1:     	if (offset == -1)
1:     	    offset = buildNumber.indexOf(':');
1:     	else
1:     	    dubiousCode = true;
1:     	if (offset == -1)
1:     		offset = buildNumber.length();
1:         else
1:             dubiousCode = true;
1:     	
1:     	try {
1:     		int bnai = Integer.parseInt(buildNumber.substring(0, offset));
1:     		if (dubiousCode)
1:     		    bnai = -bnai;
1:     		return bnai;
1:     	} catch (NumberFormatException nfe) 
1:      	{
1:      		return -1;
1:     	}
1:     }
/////////////////////////////////////////////////////////////////////////
1: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, String build) {
/////////////////////////////////////////////////////////////////////////
1: 		if (build != null) {
/////////////////////////////////////////////////////////////////////////
1: 			withBuild ? buildNumber : null);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /* IBM Confidential
0:  *
0:  * Product ID: 5697-F53
0:  *
0:  * (C) Copyright IBM Corp. 1998, 2004.
0:  *
0:  * The source code for this program is not published or otherwise divested
0:  * of its trade secrets, irrespective of what has been deposited with the
0:  * U.S. Copyright Office.
1:  */
1: 
1: package org.apache.derby.iapi.services.info;
1: 
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.util.Properties;
1: 
1: 
1: /**
0:   Class to hold a cloudscape Product version.
1: 
1:   This class includes the following product version features.
1: 
1:   <OL>
1:   <LI>Save the product version information this holds as a String. We call
1:       the string a 'product version string'.
1:   <LI>Construct a ProductVersionHolder from a valid 'product version string'.
1:   <LI>Determine if two product versions are feature compatible. This means
1:       products of these versions may interoperate with ***NO*** compatibility
1: 	  problems.
1:   <LI>Determine if two product versions are the same. This is a stronger
1:       test than the test for feature compatibility.
1:   </OL>
1: 
1: 
1: 
1:   Cloudscape 5.1 and older versions used the majorVersion, minorVersion, maintVersion versions
1:   directly. That is a three part version number, majorVersion.minorVersion.maintVersion, e.g. 5.1.21.
1: 
1:   For Cloudscape 5.2 onwards a four part name is required.
1: 	majorVersion.minorVersion.fixPack.bugVersion e.g. 5.2.1.2
1: 
1: 	This follows the IBM standard and allows us to state that a fix pack will be 5.2.3 without worrying
1: 	about how many maintence fixes there are between fix packs.
1: 
1: 	We implement this using the existing format of ProductVersionHolder to reduce disruption to the
1: 	code, however we make the maintVersion encode the {fixPack.bugVersion}. Since the maintVersion
1: 	is represented by a int (2G values) we have plenty of room for encoding. If we assign a given
1: 	majorVersion.minorVersion.fixPack a 10 year life, then we about the maximum number of individual releases
1: 	it can have is 10 years * 365 days/year = 3650. Thus with the pre 5.2 scheme we would not expect a 
0: 	5.1.x to have an x > 3650 (approximately). Usually the rate of point releases has been much less than
1: 	one per day, 5.1.31 is released about 225 days after GA which makes around a point release every 7 days.
1: 	But in the encoding we need to be conservative. With fix packs the maximum is about 2 per year and fix
1: 	packs are only made to the current release, thus with a yearly minor release cycle we would imagine
1: 	only 2 fixpacks per major.minor. However like other IBM products or release cycle may be extended thus
1: 	we can expect up to a handful of fix packs.
1: 
1: 	Thus we might imagine releases like
1: 
1: 	5.2.0.12
1: 	5.2.0.234
1: 	5.2.1.34
1: 	5.2.4.2445
1: 
1:   but highly unlikey to have
1: 
1: 	5.2.2.59321
1: 	5.2.23.1
1: 	
1: 
1:     The encoding number must continue to increase so that the
1: 	
0: 		encodedMaintB > encodedMaintA
1: 
0: 		if (fixPackB > fixPackA) || ((fixPackB == fixPackA) && (bugB > bugA))
1: 
1: 
1: 	Selected encoding
1: 
1: 	encodedMaint = (fixPack * 1,000,000) + (bugVersion);
1: 
1: 	Handles many many fixpacks and upto one million bug fixes per fix pack and remains somewhat human readable.
1: 
1: 	Special fix packs
1: 
1: 	fixpack == 0 = alpha (version off main codeline)
1: 	fixpack == 1 = first release of major.minor (may be marked with beta)
1: 	fixpack == 2 = first fix pack (displayed as 1)
1:      
1: 
1: 	The drdaMaintVersion is sent in the Network Server PRDID. It never displays
1:     but may be used by the client for version specific behaviour. It should be 
1: 	reset to 0 with each minor release.	
1: 
1:   The product version string has the form:
1:   <PRE>
1:   productVendorName - ProductName - majorVersion.minorVersion.maintVersion [beta] - (buildNumber)
1: 
1:   </PRE>
1: 
1:   */
0: public final class ProductVersionHolder implements java.security.PrivilegedAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	//
1: 	//Used as an invalid value for numbers. This works because all
1: 	//the numbers in a product version must be non-negative.
1: 	private static final int BAD_NUMBER = -1;
1: 	private static final String ALPHA = "alpha";
1: 	private static final String BETA = "beta";
1: 
0: 	private final static int	MAINT_ENCODING = 1000000;
1: 	
1: 	private String productVendorName;
1: 	private String productName;
1: 	private String productTechnologyName;
1: 	private int majorVersion = BAD_NUMBER;
1: 	private int minorVersion = BAD_NUMBER;
1: 	private int maintVersion = BAD_NUMBER;
1: 	private int drdaMaintVersion = BAD_NUMBER;
0: 	private int buildNumber = BAD_NUMBER;
1: 	private Boolean isBeta;
1: 
1: 	private ProductVersionHolder() {
1: 	}
1: 	
1: 	/**
1: 	  Create a ProductVersionHolder
1: 
1: 	  <P>Please see the documentation for the varient of getProductVesionHolder
1: 	  that takes the same parameters as this for a description of the parameters.
1: 	  */
1: 	private ProductVersionHolder(String productVendorName,
1: 								 String productName,
1: 								 String productTechnologyName,
1: 								 int majorVersion,
1: 								 int minorVersion,
1: 								 int maintVersion,
1: 								 int drdaMaintVersion,
0: 								 int buildNumber,
1: 								 Boolean isBeta)
1: 	{
1: 		if (productVendorName != null)
1: 			this.productVendorName = productVendorName.trim();
1: 		if (productName != null)
1: 			this.productName = productName.trim();
1: 		if (productTechnologyName != null)
1: 			this.productTechnologyName = productTechnologyName.trim();
1: 		this.majorVersion = majorVersion;
1: 		this.minorVersion = minorVersion;
1: 		this.maintVersion = maintVersion;
1: 		this.drdaMaintVersion = drdaMaintVersion;
1: 		this.buildNumber = buildNumber;
1: 		this.isBeta = isBeta;
1: 	}
1: 
1: 	/**
1: 	  Create a valid ProductVersionHolder. If any of the
1: 	  parameters provided is invalid, this returns null.
1: 	  @param productName The name of the product. productName.length()
1: 	  must be greater than 0. The syntax for a product name is
1: 	  'productGenus[:productSpecies]'. 
1: 	  @param majorVersion The most significant portion of a 3 
1: 	  part product version.  Must be non-negative.
1: 	  @param minorVersion The second portion of a 3 part 
1: 	  product version. Must be non-negative.
1: 	  @param maintVersion The least significant portion of a 3 part
1: 	  product version. Must be non-negative.
1: 	  @param drdaMaintVersion The protocol modification number for minor release.
0: 	  @param buildNumber The buildNumber for a product. Must be positive.
1: 	  @param isBeta true iff the product is beta.
1: 	  @return A valid ProductVersionHolder of null if any of the parameters
1: 	  provided are not valid.
1: 	  */
1: 	public static ProductVersionHolder
1: 	getProductVersionHolder(
1: 						   String productVendorName,
1: 						   String productName,
1: 						   String productTechnologyName,
1: 						   int majorVersion,
1: 						   int minorVersion,
1: 						   int maintVersion,
1: 						   int drdaMaintVersion,
0: 						   int buildNumber,
1: 						   Boolean isBeta)
1: 	{
1: 		ProductVersionHolder pvh =
1: 			new ProductVersionHolder(productVendorName,
1: 									 productName,
1: 									 productTechnologyName,
1: 									 majorVersion,
1: 									 minorVersion,
1: 									 maintVersion,
1: 									 drdaMaintVersion,
1: 									 buildNumber,
1: 									 isBeta);
1: 		return pvh;
1: 	}
1: 	
1: 	/**
1: 	  Get a ProductVersionHolder for a product of a given genus,
1: 	  that is available in the caller's environment. 
1: 	  Even though this uses a priv bock, it may stil fail when
1: 	  the jar the version is being fetched from, is different to the
1: 	  one that loaded this class, AND the jars are in different security contexts.
1: 
1: 	  @param productGenus The genus for the product.
1: 	  @return The ProductVersionHolder or null if
1: 	  a product with the given genus is not available in the
1: 	  caller's environment.
1: 	  */
1: 	public static ProductVersionHolder
1: 	getProductVersionHolderFromMyEnv(String productGenus)
1: 	{
1: 
1: 		ProductVersionHolder tempPVH = new ProductVersionHolder();
1: 
1: 		tempPVH.productGenus = productGenus;
1: 		Properties p = (Properties) java.security.AccessController.doPrivileged(tempPVH);
1: 
1: 		if (p == null)
1: 			return null;
1: 
1: 		return getProductVersionHolder(p);
1: 	}
1: 
1: 
1: 	/**
1: 		Load the version info from the already opened properties files.
1: 		We need to do this because if the jar files (e.g. db2jtools and db2j)
1: 		are in different security contexts (entries in the policy files) then
1: 		we cannot load the version information for one of them correctly.
1: 		This is because the this class will either have been loaded from
1: 		only one of the jars and hence can only access the resource in its own jar.
1: 		By making code specific to the jar open the resource we are guaranteed it will work.
1: 	*/
1: 	public static ProductVersionHolder
1: 	getProductVersionHolderFromMyEnv(InputStream propertiesStream)
1: 	{
1: 
1: 		if (propertiesStream == null)
1: 			return null;
1: 
1: 		Properties p = new Properties();
1: 		try {
1: 			p.load(propertiesStream);
1: 		}
1: 		catch (IOException ioe) {
1: 
1: 			System.out.println("IOE " + ioe.getMessage());
1: 			//
1: 			//This case is a bit ugly. If we get an IOException, we return
1: 			//null. Though this correctly reflects that the product is not
1: 			//available for use, it may be confusing to users that we swallow
1: 			//the IO error here.
1: 			return null;
1: 		} finally {
1: 			try {
1: 				propertiesStream.close();
1: 			} catch (IOException ioe2) {
1: 			}
1: 		}
1: 
1: 		return getProductVersionHolder(p);
1: 	}
1: 
1: 	/**
1: 	  Get a ProductVersionHolder based on the information in
1: 	  the Properties object provided.
1: 
1: 	  @param p The properties object that holds the productVersion
1: 	  information.
1: 	  @return The ProductVersionHolder or null if
1: 	  a product with the given genus is not available in the
1: 	  caller's environment.
1: 	  */
1: 	public static ProductVersionHolder
1: 	getProductVersionHolder(Properties p)
1: 	{
1: 		String pvn = p.getProperty(PropertyNames.PRODUCT_VENDOR_NAME);
1: 		String pn = p.getProperty(PropertyNames.PRODUCT_EXTERNAL_NAME);
1: 		String ptn = p.getProperty(PropertyNames.PRODUCT_TECHNOLOGY_NAME);
1: 		int v1 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAJOR_VERSION));
1: 		int v2 = parseInt(p.getProperty(PropertyNames.PRODUCT_MINOR_VERSION));
1: 		int v3 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAINT_VERSION));
1: 		int v4 = parseInt(p.getProperty(PropertyNames.PRODUCT_DRDA_MAINT_VERSION));
0: 		int bn = parseInt(p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER));
1: 		Boolean isBeta =
1: 			Boolean.valueOf(p.getProperty(PropertyNames.PRODUCT_BETA_VERSION));
1: 		return 	getProductVersionHolder(pvn,pn,ptn,v1,v2,v3,v4,bn,isBeta);
1: 	}
1: 
1: 
1: 	/**
1: 	  Return the product vendor name.
1: 	  */
1: 	public String getProductVendorName()
1: 	{
1: 		return productVendorName;
1: 	}
1: 
1: 
1: 	/**
1: 	  Return the external product name.
1: 	  */
1: 	public String getProductName()
1: 	{
1: 		return productName;
1: 	}
1: 	public String getProductTechnologyName()
1: 	{
1: 		return productTechnologyName;
1: 	}
1: 
1: 	/**
1: 	  Return the major version number.
1: 	  */
1: 	public int getMajorVersion() {return majorVersion;}
1: 	/**
1: 	  Return the minor version number.
1: 	  */
1: 	public int getMinorVersion() {return minorVersion;}
1: 	/**
1: 	  Return the <B>encoded</B> maintainence version number.
1: 	  */
1: 	public int getMaintVersion() {return maintVersion;}
1: 
1: 	/** 
1: 		Return the drda protocol maintenance version for this minor release.
1: 		Starts at 0 for each minor release and only incremented 
1: 		when client behaviour changes based on the server version.
1: 	**/
1: 	public int getDrdaMaintVersion() {return drdaMaintVersion; }
1: 
1: 	/**
0: 		Return the fix pack version from the maintence encoding.
1: 	*/
1: 	public int getFixPackVersion() { return maintVersion / MAINT_ENCODING; }
1: 
1: 
1: 	/**
1: 	  Return true if this is a beta product.
1: 	  */
1: 	public boolean isBeta() {return isBeta.booleanValue();}
1: 	/**
1: 	  Return true if this is a alpha product.
1: 	  */
1: 	public boolean isAlpha() {
1: 		return	   (majorVersion >= 5)
1: 				&& (minorVersion > 2)
1: 				&& ((maintVersion / MAINT_ENCODING) == 0);
1: 	}
1: 	/**
1: 	  Return the build number for this product.
1: 	  */
0: 	public int getBuildNumber() {return buildNumber;}
1: 
1: 
1: 	/**
1: 	  Parse a string containing a non-negative integer. Return
1: 	  a negative integer is the String is invalid.
1: 
1: 	  @param s A string with a non-negative integer (a sequence
1: 	  of decimal digits.)
1: 	  @return the integer or a negative number if s is invalid.
1: 	  */
1: 	private static int parseInt(String s)
1: 	{
1: 		//System.out.println("Parsing integer: "+s);		
1: 		int result = BAD_NUMBER;
1: 		try
1: 			{
1: 				if (s!=null)
1: 					result = Integer.parseInt(s);
1: 			}
1: 		catch (NumberFormatException nfe)
1: 			{}
1: 
1: 		if (result < 0) result = BAD_NUMBER;
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	  Return  a string representation of this ProductVersion. The
1: 	  difference between this and createProductVersionString, is
1: 	  that this method retruns a String when this ProductVersionHolder
1: 	  holds invalid version information.
1: 	 */
1: 	public String toString()
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		sb.append(getProductVendorName());
1: 		sb.append(" - ");
1: 		sb.append(getProductName());
1: 		sb.append(" - ");
1: 		sb.append(getVersionBuildString(true));
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
1: 		Return the feature version string, ie. major.minor. (e.g. 5.2)
1: 	*/
1: 	public String getSimpleVersionString() {
1: 
1: 		return ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());
1: 	}
1: 
1: 	/**
1: 		Convert a major and minor number with beta status into a string.
1: 	*/
1: 	public static String simpleVersionString(int major, int minor, boolean isBeta) {
1: 
1: 		StringBuffer sb = new StringBuffer();
1: 
1: 		sb.append(major);
1: 		sb.append('.');
1: 		sb.append(minor);
1: 		if (isBeta) {
1: 			sb.append(' ');
1: 			sb.append(BETA);
1: 		}
1: 
1: 		return sb.toString();
1: 	}
0: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, int build) {
1: 		StringBuffer sb = new StringBuffer();
1: 		sb.append(major);
1: 		sb.append('.');
1: 		sb.append(minor);
1: 		sb.append('.');
1: 
1: 		String preRelease = null;
1: 		if (major == 5 && minor <= 2 && maint < MAINT_ENCODING)
1: 		{
1: 			sb.append(maint);
1: 			if (isBeta)
1: 				preRelease = BETA;
1: 		}
1: 		else
1: 		{
1: 			int fixPack = maint / MAINT_ENCODING;
1: 			int bugVersion = maint % MAINT_ENCODING;
1: 			sb.append(fixPack);
1: 			sb.append('.');
1: 			sb.append(bugVersion);
1: 
1: 			if (fixPack == 0)
1: 			{
1: 				preRelease = ALPHA;
1: 			}
1: 			else if (isBeta) {
1: 				preRelease = BETA;
1: 			}
1: 		}
1: 
1:         if (preRelease != null)
1:         {
1: 			sb.append(' ');
1:             sb.append(preRelease);
1:         }
0: 		if (build != 0) {
1: 			sb.append(" - (");
1: 
1: 			sb.append(build);
1: 			sb.append(')');
1: 		}
1:         return sb.toString();
1: 	}
1: 	/**
1: 		Returns a short-hand value for the product version string.
1: 		Used by Sysinfo.
1: 		Includes the optional <beta> designation
1: 	*/
1:     public String getVersionBuildString(boolean withBuild)
1:     {
1: 		return ProductVersionHolder.fullVersionString(majorVersion, minorVersion, maintVersion, isBeta(),
0: 			withBuild ? buildNumber : 0);
1:     }
1: 
1: 	/*
1: 	** Security related methods 
1: 	*/
1: 	private String productGenus;
0: 	public Object run() {
1: 
1: 		// SECURITY PERMISSION - IP4
1: 		return loadProperties(this.productGenus);
1: 	}
1: 	// SECURITY PERMISSION - IP4
1: 	private Properties loadProperties(String productGenus) {
1: 		String resourceName = "/org/apache/derby/info/" + productGenus+".properties";
1: 			
1: 		InputStream is = getClass().getResourceAsStream(resourceName);
1: 		if (is==null) {
1: 			return null;
1: 		}
1: 
1: 		Properties p = new Properties();
1: 		try {
1: 			p.load(is);
1: 			return p;
1: 		}
1: 		catch (IOException ioe) {
1: 			//
1: 			//This case is a bit ugly. If we get an IOException, we return
1: 			//null. Though this correctly reflects that the product is not
1: 			//available for use, it may be confusing to users that we swallow
1: 			//the IO error here.
1: 			return null;
1: 		}
1: 	}
1: }
commit:d2a30a0
/////////////////////////////////////////////////////////////////////////
0: 	private int buildNumber = BAD_NUMBER;
/////////////////////////////////////////////////////////////////////////
0: 								 int buildNumber,
/////////////////////////////////////////////////////////////////////////
0: 	  @param buildNumber The buildNumber for a product. Must be positive.
/////////////////////////////////////////////////////////////////////////
0: 						   int buildNumber,
/////////////////////////////////////////////////////////////////////////
0: 		int bn = parseInt(p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER));
/////////////////////////////////////////////////////////////////////////
0: 	public int getBuildNumber() {return buildNumber;}
/////////////////////////////////////////////////////////////////////////
0: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, int build) {
/////////////////////////////////////////////////////////////////////////
0: 		if (build != 0) {
/////////////////////////////////////////////////////////////////////////
0: 			withBuild ? buildNumber : 0);
commit:42261f8
/////////////////////////////////////////////////////////////////////////
0: 	private String buildNumber = "????";
/////////////////////////////////////////////////////////////////////////
0: 								 String buildNumber,
/////////////////////////////////////////////////////////////////////////
0: 	  @param buildNumber The buildNumber for a product. 
/////////////////////////////////////////////////////////////////////////
0: 						   String buildNumber,
/////////////////////////////////////////////////////////////////////////
0: 		String bn = p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER);
/////////////////////////////////////////////////////////////////////////
0: 	public String getBuildNumber() {return buildNumber;}
0:     /**
0:      * Return the build number as an integer if possible,
0:      * mapping from the SVN number.
0:      * nnnnn -> returns nnnnn
0:      * nnnnnM -> returns -nnnnn indicates a modified code base
0:      * nnnnn:mmmmm -> returns -nnnnn
0:      * anything else -> returns -1
0:     */
0:     public int getBuildNumberAsInt(){
0:     	if (buildNumber == null)
0:     	    return -1;
0:     	boolean dubiousCode = false;
0:     	int offset = buildNumber.indexOf('M');
0:     	if (offset == -1)
0:     	    offset = buildNumber.indexOf(':');
0:     	else
0:     	    dubiousCode = true;
0:     	if (offset == -1)
0:     		offset = buildNumber.length();
0:         else
0:             dubiousCode = true;
0:     	
0:     	try {
0:     		int bnai = Integer.parseInt(buildNumber.substring(0, offset));
0:     		if (dubiousCode)
0:     		    bnai = -bnai;
0:     		return bnai;
0:     	} catch (NumberFormatException nfe) 
0:      	{
0:      		return -1;
0:     	}
0:     }
/////////////////////////////////////////////////////////////////////////
0: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, String build) {
/////////////////////////////////////////////////////////////////////////
0: 		if (build != null) {
/////////////////////////////////////////////////////////////////////////
0: 			withBuild ? buildNumber : null);
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /* IBM Confidential
0:  *
0:  * Product ID: 5697-F53
0:  *
0:  * (C) Copyright IBM Corp. 1998, 2004.
0:  *
0:  * The source code for this program is not published or otherwise divested
0:  * of its trade secrets, irrespective of what has been deposited with the
0:  * U.S. Copyright Office.
0:  */
0: 
0: package org.apache.derby.iapi.services.info;
0: 
0: import java.io.InputStream;
0: import java.io.IOException;
0: import java.util.Properties;
0: 
0: 
0: /**
0:   Class to hold a cloudscape Product version.
0: 
0:   This class includes the following product version features.
0: 
0:   <OL>
0:   <LI>Save the product version information this holds as a String. We call
0:       the string a 'product version string'.
0:   <LI>Construct a ProductVersionHolder from a valid 'product version string'.
0:   <LI>Determine if two product versions are feature compatible. This means
0:       products of these versions may interoperate with ***NO*** compatibility
0: 	  problems.
0:   <LI>Determine if two product versions are the same. This is a stronger
0:       test than the test for feature compatibility.
0:   </OL>
0: 
0: 
0: 
0:   Cloudscape 5.1 and older versions used the majorVersion, minorVersion, maintVersion versions
0:   directly. That is a three part version number, majorVersion.minorVersion.maintVersion, e.g. 5.1.21.
0: 
0:   For Cloudscape 5.2 onwards a four part name is required.
0: 	majorVersion.minorVersion.fixPack.bugVersion e.g. 5.2.1.2
0: 
0: 	This follows the IBM standard and allows us to state that a fix pack will be 5.2.3 without worrying
0: 	about how many maintence fixes there are between fix packs.
0: 
0: 	We implement this using the existing format of ProductVersionHolder to reduce disruption to the
0: 	code, however we make the maintVersion encode the {fixPack.bugVersion}. Since the maintVersion
0: 	is represented by a int (2G values) we have plenty of room for encoding. If we assign a given
0: 	majorVersion.minorVersion.fixPack a 10 year life, then we about the maximum number of individual releases
0: 	it can have is 10 years * 365 days/year = 3650. Thus with the pre 5.2 scheme we would not expect a 
0: 	5.1.x to have an x > 3650 (approximately). Usually the rate of point releases has been much less than
0: 	one per day, 5.1.31 is released about 225 days after GA which makes around a point release every 7 days.
0: 	But in the encoding we need to be conservative. With fix packs the maximum is about 2 per year and fix
0: 	packs are only made to the current release, thus with a yearly minor release cycle we would imagine
0: 	only 2 fixpacks per major.minor. However like other IBM products or release cycle may be extended thus
0: 	we can expect up to a handful of fix packs.
0: 
0: 	Thus we might imagine releases like
0: 
0: 	5.2.0.12
0: 	5.2.0.234
0: 	5.2.1.34
0: 	5.2.4.2445
0: 
0:   but highly unlikey to have
0: 
0: 	5.2.2.59321
0: 	5.2.23.1
0: 	
0: 
0:     The encoding number must continue to increase so that the
0: 	
0: 		encodedMaintB > encodedMaintA
0: 
0: 		if (fixPackB > fixPackA) || ((fixPackB == fixPackA) && (bugB > bugA))
0: 
0: 
0: 	Selected encoding
0: 
0: 	encodedMaint = (fixPack * 1,000,000) + (bugVersion);
0: 
0: 	Handles many many fixpacks and upto one million bug fixes per fix pack and remains somewhat human readable.
0: 
0: 	Special fix packs
0: 
0: 	fixpack == 0 = alpha (version off main codeline)
0: 	fixpack == 1 = first release of major.minor (may be marked with beta)
0: 	fixpack == 2 = first fix pack (displayed as 1)
0:      
0: 
0: 	The drdaMaintVersion is sent in the Network Server PRDID. It never displays
0:     but may be used by the client for version specific behaviour. It should be 
0: 	reset to 0 with each minor release.	
0: 
0:   The product version string has the form:
0:   <PRE>
0:   productVendorName - ProductName - majorVersion.minorVersion.maintVersion [beta] - (buildNumber)
0: 
0:   </PRE>
0: 
0:   */
0: public final class ProductVersionHolder implements java.security.PrivilegedAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	//
0: 	//Used as an invalid value for numbers. This works because all
0: 	//the numbers in a product version must be non-negative.
0: 	private static final int BAD_NUMBER = -1;
0: 	private static final String ALPHA = "alpha";
0: 	private static final String BETA = "beta";
0: 
0: 	private final static int	MAINT_ENCODING = 1000000;
0: 	
0: 	private String productVendorName;
0: 	private String productName;
0: 	private String productTechnologyName;
0: 	private int majorVersion = BAD_NUMBER;
0: 	private int minorVersion = BAD_NUMBER;
0: 	private int maintVersion = BAD_NUMBER;
0: 	private int drdaMaintVersion = BAD_NUMBER;
0: 	private int buildNumber = BAD_NUMBER;
0: 	private Boolean isBeta;
0: 
0: 	private ProductVersionHolder() {
0: 	}
0: 	
0: 	/**
0: 	  Create a ProductVersionHolder
0: 
0: 	  <P>Please see the documentation for the varient of getProductVesionHolder
0: 	  that takes the same parameters as this for a description of the parameters.
0: 	  */
0: 	private ProductVersionHolder(String productVendorName,
0: 								 String productName,
0: 								 String productTechnologyName,
0: 								 int majorVersion,
0: 								 int minorVersion,
0: 								 int maintVersion,
0: 								 int drdaMaintVersion,
0: 								 int buildNumber,
0: 								 Boolean isBeta)
0: 	{
0: 		if (productVendorName != null)
0: 			this.productVendorName = productVendorName.trim();
0: 		if (productName != null)
0: 			this.productName = productName.trim();
0: 		if (productTechnologyName != null)
0: 			this.productTechnologyName = productTechnologyName.trim();
0: 		this.majorVersion = majorVersion;
0: 		this.minorVersion = minorVersion;
0: 		this.maintVersion = maintVersion;
0: 		this.drdaMaintVersion = drdaMaintVersion;
0: 		this.buildNumber = buildNumber;
0: 		this.isBeta = isBeta;
0: 	}
0: 
0: 	/**
0: 	  Create a valid ProductVersionHolder. If any of the
0: 	  parameters provided is invalid, this returns null.
0: 	  @param productName The name of the product. productName.length()
0: 	  must be greater than 0. The syntax for a product name is
0: 	  'productGenus[:productSpecies]'. 
0: 	  @param majorVersion The most significant portion of a 3 
0: 	  part product version.  Must be non-negative.
0: 	  @param minorVersion The second portion of a 3 part 
0: 	  product version. Must be non-negative.
0: 	  @param maintVersion The least significant portion of a 3 part
0: 	  product version. Must be non-negative.
0: 	  @param drdaMaintVersion The protocol modification number for minor release.
0: 	  @param buildNumber The buildNumber for a product. Must be positive.
0: 	  @param isBeta true iff the product is beta.
0: 	  @return A valid ProductVersionHolder of null if any of the parameters
0: 	  provided are not valid.
0: 	  */
0: 	public static ProductVersionHolder
0: 	getProductVersionHolder(
0: 						   String productVendorName,
0: 						   String productName,
0: 						   String productTechnologyName,
0: 						   int majorVersion,
0: 						   int minorVersion,
0: 						   int maintVersion,
0: 						   int drdaMaintVersion,
0: 						   int buildNumber,
0: 						   Boolean isBeta)
0: 	{
0: 		ProductVersionHolder pvh =
0: 			new ProductVersionHolder(productVendorName,
0: 									 productName,
0: 									 productTechnologyName,
0: 									 majorVersion,
0: 									 minorVersion,
0: 									 maintVersion,
0: 									 drdaMaintVersion,
0: 									 buildNumber,
0: 									 isBeta);
0: 		return pvh;
0: 	}
0: 	
0: 	/**
0: 	  Get a ProductVersionHolder for a product of a given genus,
0: 	  that is available in the caller's environment. 
0: 	  Even though this uses a priv bock, it may stil fail when
0: 	  the jar the version is being fetched from, is different to the
0: 	  one that loaded this class, AND the jars are in different security contexts.
0: 
0: 	  @param productGenus The genus for the product.
0: 	  @return The ProductVersionHolder or null if
0: 	  a product with the given genus is not available in the
0: 	  caller's environment.
0: 	  */
0: 	public static ProductVersionHolder
0: 	getProductVersionHolderFromMyEnv(String productGenus)
0: 	{
0: 
0: 		ProductVersionHolder tempPVH = new ProductVersionHolder();
0: 
0: 		tempPVH.productGenus = productGenus;
0: 		Properties p = (Properties) java.security.AccessController.doPrivileged(tempPVH);
0: 
0: 		if (p == null)
0: 			return null;
0: 
0: 		return getProductVersionHolder(p);
0: 	}
0: 
0: 
0: 	/**
0: 		Load the version info from the already opened properties files.
0: 		We need to do this because if the jar files (e.g. db2jtools and db2j)
0: 		are in different security contexts (entries in the policy files) then
0: 		we cannot load the version information for one of them correctly.
0: 		This is because the this class will either have been loaded from
0: 		only one of the jars and hence can only access the resource in its own jar.
0: 		By making code specific to the jar open the resource we are guaranteed it will work.
0: 	*/
0: 	public static ProductVersionHolder
0: 	getProductVersionHolderFromMyEnv(InputStream propertiesStream)
0: 	{
0: 
0: 		if (propertiesStream == null)
0: 			return null;
0: 
0: 		Properties p = new Properties();
0: 		try {
0: 			p.load(propertiesStream);
0: 		}
0: 		catch (IOException ioe) {
0: 
0: 			System.out.println("IOE " + ioe.getMessage());
0: 			//
0: 			//This case is a bit ugly. If we get an IOException, we return
0: 			//null. Though this correctly reflects that the product is not
0: 			//available for use, it may be confusing to users that we swallow
0: 			//the IO error here.
0: 			return null;
0: 		} finally {
0: 			try {
0: 				propertiesStream.close();
0: 			} catch (IOException ioe2) {
0: 			}
0: 		}
0: 
0: 		return getProductVersionHolder(p);
0: 	}
0: 
0: 	/**
0: 	  Get a ProductVersionHolder based on the information in
0: 	  the Properties object provided.
0: 
0: 	  @param p The properties object that holds the productVersion
0: 	  information.
0: 	  @return The ProductVersionHolder or null if
0: 	  a product with the given genus is not available in the
0: 	  caller's environment.
0: 	  */
0: 	public static ProductVersionHolder
0: 	getProductVersionHolder(Properties p)
0: 	{
0: 		String pvn = p.getProperty(PropertyNames.PRODUCT_VENDOR_NAME);
0: 		String pn = p.getProperty(PropertyNames.PRODUCT_EXTERNAL_NAME);
0: 		String ptn = p.getProperty(PropertyNames.PRODUCT_TECHNOLOGY_NAME);
0: 		int v1 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAJOR_VERSION));
0: 		int v2 = parseInt(p.getProperty(PropertyNames.PRODUCT_MINOR_VERSION));
0: 		int v3 = parseInt(p.getProperty(PropertyNames.PRODUCT_MAINT_VERSION));
0: 		int v4 = parseInt(p.getProperty(PropertyNames.PRODUCT_DRDA_MAINT_VERSION));
0: 		int bn = parseInt(p.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER));
0: 		Boolean isBeta =
0: 			Boolean.valueOf(p.getProperty(PropertyNames.PRODUCT_BETA_VERSION));
0: 		return 	getProductVersionHolder(pvn,pn,ptn,v1,v2,v3,v4,bn,isBeta);
0: 	}
0: 
0: 
0: 	/**
0: 	  Return the product vendor name.
0: 	  */
0: 	public String getProductVendorName()
0: 	{
0: 		return productVendorName;
0: 	}
0: 
0: 
0: 	/**
0: 	  Return the external product name.
0: 	  */
0: 	public String getProductName()
0: 	{
0: 		return productName;
0: 	}
0: 	public String getProductTechnologyName()
0: 	{
0: 		return productTechnologyName;
0: 	}
0: 
0: 	/**
0: 	  Return the major version number.
0: 	  */
0: 	public int getMajorVersion() {return majorVersion;}
0: 	/**
0: 	  Return the minor version number.
0: 	  */
0: 	public int getMinorVersion() {return minorVersion;}
0: 	/**
0: 	  Return the <B>encoded</B> maintainence version number.
0: 	  */
0: 	public int getMaintVersion() {return maintVersion;}
0: 
0: 	/** 
0: 		Return the drda protocol maintenance version for this minor release.
0: 		Starts at 0 for each minor release and only incremented 
0: 		when client behaviour changes based on the server version.
0: 	**/
0: 	public int getDrdaMaintVersion() {return drdaMaintVersion; }
0: 
0: 	/**
0: 		Return the fix pack version from the maintence encoding.
0: 	*/
0: 	public int getFixPackVersion() { return maintVersion / MAINT_ENCODING; }
0: 
0: 
0: 	/**
0: 	  Return true if this is a beta product.
0: 	  */
0: 	public boolean isBeta() {return isBeta.booleanValue();}
0: 	/**
0: 	  Return true if this is a alpha product.
0: 	  */
0: 	public boolean isAlpha() {
0: 		return	   (majorVersion >= 5)
0: 				&& (minorVersion > 2)
0: 				&& ((maintVersion / MAINT_ENCODING) == 0);
0: 	}
0: 	/**
0: 	  Return the build number for this product.
0: 	  */
0: 	public int getBuildNumber() {return buildNumber;}
0: 
0: 
0: 	/**
0: 	  Parse a string containing a non-negative integer. Return
0: 	  a negative integer is the String is invalid.
0: 
0: 	  @param s A string with a non-negative integer (a sequence
0: 	  of decimal digits.)
0: 	  @return the integer or a negative number if s is invalid.
0: 	  */
0: 	private static int parseInt(String s)
0: 	{
0: 		//System.out.println("Parsing integer: "+s);		
0: 		int result = BAD_NUMBER;
0: 		try
0: 			{
0: 				if (s!=null)
0: 					result = Integer.parseInt(s);
0: 			}
0: 		catch (NumberFormatException nfe)
0: 			{}
0: 
0: 		if (result < 0) result = BAD_NUMBER;
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	  Return  a string representation of this ProductVersion. The
0: 	  difference between this and createProductVersionString, is
0: 	  that this method retruns a String when this ProductVersionHolder
0: 	  holds invalid version information.
0: 	 */
0: 	public String toString()
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		sb.append(getProductVendorName());
0: 		sb.append(" - ");
0: 		sb.append(getProductName());
0: 		sb.append(" - ");
0: 		sb.append(getVersionBuildString(true));
0: 		return sb.toString();
0: 	}
0: 
0: 	/**
0: 		Return the feature version string, ie. major.minor. (e.g. 5.2)
0: 	*/
0: 	public String getSimpleVersionString() {
0: 
0: 		return ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());
0: 	}
0: 
0: 	/**
0: 		Convert a major and minor number with beta status into a string.
0: 	*/
0: 	public static String simpleVersionString(int major, int minor, boolean isBeta) {
0: 
0: 		StringBuffer sb = new StringBuffer();
0: 
0: 		sb.append(major);
0: 		sb.append('.');
0: 		sb.append(minor);
0: 		if (isBeta) {
0: 			sb.append(' ');
0: 			sb.append(BETA);
0: 		}
0: 
0: 		return sb.toString();
0: 	}
0: 	public static String fullVersionString(int major, int minor, int maint, boolean isBeta, int build) {
0: 		StringBuffer sb = new StringBuffer();
0: 		sb.append(major);
0: 		sb.append('.');
0: 		sb.append(minor);
0: 		sb.append('.');
0: 
0: 		String preRelease = null;
0: 		if (major == 5 && minor <= 2 && maint < MAINT_ENCODING)
0: 		{
0: 			sb.append(maint);
0: 			if (isBeta)
0: 				preRelease = BETA;
0: 		}
0: 		else
0: 		{
0: 			int fixPack = maint / MAINT_ENCODING;
0: 			int bugVersion = maint % MAINT_ENCODING;
0: 			sb.append(fixPack);
0: 			sb.append('.');
0: 			sb.append(bugVersion);
0: 
0: 			if (fixPack == 0)
0: 			{
0: 				preRelease = ALPHA;
0: 			}
0: 			else if (isBeta) {
0: 				preRelease = BETA;
0: 			}
0: 		}
0: 
0:         if (preRelease != null)
0:         {
0: 			sb.append(' ');
0:             sb.append(preRelease);
0:         }
0: 		if (build != 0) {
0: 			sb.append(" - (");
0: 
0: 			sb.append(build);
0: 			sb.append(')');
0: 		}
0:         return sb.toString();
0: 	}
0: 	/**
0: 		Returns a short-hand value for the product version string.
0: 		Used by Sysinfo.
0: 		Includes the optional <beta> designation
0: 	*/
0:     public String getVersionBuildString(boolean withBuild)
0:     {
0: 		return ProductVersionHolder.fullVersionString(majorVersion, minorVersion, maintVersion, isBeta(),
0: 			withBuild ? buildNumber : 0);
0:     }
0: 
0: 	/*
0: 	** Security related methods 
0: 	*/
0: 	private String productGenus;
0: 	public Object run() {
0: 
0: 		// SECURITY PERMISSION - IP4
0: 		return loadProperties(this.productGenus);
0: 	}
0: 	// SECURITY PERMISSION - IP4
0: 	private Properties loadProperties(String productGenus) {
0: 		String resourceName = "/org/apache/derby/info/" + productGenus+".properties";
0: 			
0: 		InputStream is = getClass().getResourceAsStream(resourceName);
0: 		if (is==null) {
0: 			return null;
0: 		}
0: 
0: 		Properties p = new Properties();
0: 		try {
0: 			p.load(is);
0: 			return p;
0: 		}
0: 		catch (IOException ioe) {
0: 			//
0: 			//This case is a bit ugly. If we get an IOException, we return
0: 			//null. Though this correctly reflects that the product is not
0: 			//available for use, it may be confusing to users that we swallow
0: 			//the IO error here.
0: 			return null;
0: 		}
0: 	}
0: }
============================================================================