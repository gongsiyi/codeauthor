1:0c0db14: /*
1:0c0db14:  
1:121b2ed:    Derby - Class org.apache.derbyMessageBundleTest
1:0c0db14:  
1:0c0db14:    Licensed to the Apache Software Foundation (ASF) under one or more
1:0c0db14:    contributor license agreements.  See the NOTICE file distributed with
1:0c0db14:    this work for additional information regarding copyright ownership.
1:0c0db14:    The ASF licenses this file to You under the Apache License, Version 2.0
1:0c0db14:    (the "License"); you may not use this file except in compliance with
1:0c0db14:    the License.  You may obtain a copy of the License at
1:0c0db14:  
1:0c0db14:       http://www.apache.org/licenses/LICENSE-2.0
1:0c0db14:  
1:0c0db14:    Unless required by applicable law or agreed to in writing, software
1:0c0db14:    distributed under the License is distributed on an "AS IS" BASIS,
1:0c0db14:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0c0db14:    See the License for the specific language governing permissions and
1:0c0db14:    limitations under the License.
1:0c0db14:  
1:0c0db14:  */
1:0c0db14: 
1:121b2ed: package org.apache.derbyBuild;
1:0c0db14: 
1:0c0db14: import org.apache.derby.shared.common.reference.SQLState;
1:0c0db14: import org.apache.derby.shared.common.reference.MessageId;
1:0c0db14: 
1:0c0db14: import java.util.HashSet;
1:0c0db14: import java.lang.reflect.Field;
1:0c0db14: import java.util.ResourceBundle;
1:0c0db14: import java.util.Locale;
1:0c0db14: import java.util.Iterator;
1:0c0db14: 
1:121b2ed: 
1:0c0db14: /**
1:0c0db14:  * This class does everything we can to validate that the messages_en.properties
1:0c0db14:  * file is in synch with SQLState.java and MessageId.java.  We want to make sure
1:0c0db14:  * that message ids defined in SQLState and MessageId have matching messages
1:0c0db14:  * in the messages properties file, and also find out if there are any messages
1:0c0db14:  * that don't have matching ids in the SQLState and MessageId files.   The
1:0c0db14:  * first is a bug, the second is something to be aware of.
1:0c0db14:  */
1:5a18567: public class MessageBundleTest {
1:121b2ed: 
1:121b2ed:     static boolean failbuild = false;
2:121b2ed: 
1:121b2ed:     /**
1:121b2ed:      * <p>
1:121b2ed:      * Let Ant conjure us out of thin air.
1:121b2ed:      * </p>
1:121b2ed:      */
1:121b2ed:     public MessageBundleTest()
1:121b2ed:     {}
1:121b2ed:     
1:5a18567:     public static void main(String [] args) throws Exception
1:121b2ed:     {
1:121b2ed:         MessageBundleTest t = new MessageBundleTest();
1:121b2ed:         try {
1:121b2ed:             t.testMessageBundleOrphanedMessages();
1:121b2ed:             t.testMessageIdOrphanedIds();
1:121b2ed:             t.testSQLStateOrphanedIds();
1:121b2ed:         } catch (Exception e) {
1:121b2ed:             System.out.println("Message check failed: ");
1:121b2ed:             e.printStackTrace();
1:0c0db14:         }
1:121b2ed:         if (failbuild) 
1:5a18567:             throw new Exception("Message check failed. \n" +
1:121b2ed:                 "See error in build output or call ant runmessagecheck.");
1:121b2ed:     }    
1:0c0db14:     
1:0c0db14:     // The list of ids.  We use a HashSet so we can detect duplicates easily
1:38b9499:     static HashSet<String> sqlStateIds  = new HashSet<String>();
1:38b9499:     static HashSet<String> messageIdIds = new HashSet<String>();
1:38b9499:     static HashSet<String> messageBundleIds = new HashSet<String>();
1:0c0db14:     
1:0c0db14:     static {
1:0c0db14:         try {
1:0c0db14:             // Load all the ids for the SQLState class
1:0c0db14:             loadClassIds(SQLState.class, sqlStateIds);
1:0c0db14: 
1:0c0db14:             // Load all the ids for the MessageId class
1:0c0db14:             loadClassIds(MessageId.class, messageIdIds);
1:0c0db14: 
1:0c0db14:             // Load all the ids for the messages_en properties file
1:0c0db14:             loadMessageBundleIds();
1:0c0db14:         } catch ( Exception e ) {
1:0c0db14:             e.printStackTrace();
1:0c0db14:             throw new RuntimeException(e.getMessage());
1:0c0db14:         }
1:0c0db14:     }
1:0c0db14:     
1:38b9499:     static void loadClassIds(Class idclass, HashSet<String> set)
1:38b9499:             throws Exception {
1:0c0db14:         Field[] fields = idclass.getFields();
1:0c0db14:         
1:0c0db14:         int length = fields.length;
1:0c0db14:         for ( int i = 0; i < length ; i++ )
1:0c0db14:         {
1:0c0db14:             String id = (String)fields[i].get(null);
1:0c0db14:             
1:0c0db14:             if ( id.length() == 2 ) {
1:0c0db14:                 // Skip past identifiers that are just categories
1:0c0db14:                 continue;
1:0c0db14:             }
1:0c0db14:             
1:0c0db14:             // Skip past "special" SQL States that are not expected
1:0c0db14:             // to have messages
1:0c0db14:             if ( id.equals("close.C.1") )   continue;            
1:0c0db14:             if ( id.equals("rwupd" ) )      continue;
1:0c0db14:             if ( id.equals("02502" ) )      continue;
1:0c0db14:             if ( id.equals("XSAX0") )       continue;
1:0c0db14:             
1:0c0db14:             if ( ! set.add(id) )
1:0c0db14:             {
1:121b2ed:                 failbuild=true;
1:0c0db14:                 System.err.println("ERROR: The id " + id + 
1:0c0db14:                     " was found twice in " + idclass.getName());
1:0c0db14:             }
1:0c0db14:         }
1:0c0db14:     }
1:0c0db14:             
1:0c0db14:     /** 
1:0c0db14:      * Load all the message ids from messages_en.properties into a HashSet.
1:0c0db14:      * This assumes its available on the classpath
1:0c0db14:      */
1:0c0db14:     static void loadMessageBundleIds() throws Exception {
1:0c0db14:         ResourceBundle bundle;
1:0c0db14:         
1:0c0db14:         // The messages_*.properties files are split into fifty separate
1:0c0db14:         // message bundle files.  We need to load each one in turn
1:0c0db14:         int numBundles = 50;
1:0c0db14:         
1:0c0db14:         for ( int i=0 ; i < numBundles ; i++ ) {
1:0c0db14:             loadMessageBundle(i);
1:0c0db14:         }
1:0c0db14:     }
1:0c0db14:     
1:0c0db14:     static void loadMessageBundle(int index) {
1:0c0db14:         String bundleName = "org.apache.derby.loc.m" + index;
1:0c0db14:         
1:0c0db14:         ResourceBundle bundle = 
1:0c0db14:             ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
1:0c0db14: 
1:0c0db14:         java.util.Enumeration keys = bundle.getKeys();
1:0c0db14: 
1:0c0db14:         while ( keys.hasMoreElements() ) {
1:0c0db14:             String key = (String)keys.nextElement();                
1:0c0db14: 
1:0c0db14:             if ( ! messageBundleIds.add(key) ) {
1:121b2ed:                 failbuild=true;
1:0c0db14:                 System.err.println("ERROR: the key " + key +
1:0c0db14:                     " exists twice in messages_en.properties");
1:0c0db14:             }
1:0c0db14:         }        
1:0c0db14:     }
1:0c0db14: 
1:0c0db14:     /**
1:0c0db14:      * See if there are any message ids in SQLState.java that are
1:0c0db14:      * not in the message bundle
1:0c0db14:      */
1:0c0db14:     public void testSQLStateOrphanedIds() throws Exception {
1:0c0db14:         Iterator it = sqlStateIds.iterator();
1:0c0db14:         
1:0c0db14:         while ( it.hasNext() ) {
1:0c0db14:             String sqlStateId = (String)it.next();
1:0c0db14:             
1:0c0db14:             if ( ! messageBundleIds.contains(sqlStateId) ) {
1:648e348:                 // there are some error messages that do not need to be in 
1:648e348:                 // messages.xml:
1:648e348:                 // XCL32: will never be exposed to users (see DERBY-1414)
1:648e348:                 // XSAX1: shared SQLState explains; not exposed to users. 
1:b850119:                 // 01004: automatically assigned by java.sql.DataTruncation and
1:b850119:                 //        never used to generate a message
1:648e348:                 if (!(sqlStateId.equalsIgnoreCase("XCL32.S") ||
1:b850119:                       sqlStateId.equalsIgnoreCase("XSAX1")   ||
1:b850119:                       sqlStateId.equalsIgnoreCase("01004"))) {
1:0c0db14:                 // Don't fail out on the first one, we want to catch
1:0c0db14:                 // all of them.  Just note there was a failure and continue
1:121b2ed:                     failbuild=true;
1:0c0db14:                     System.err.println("ERROR: Message id " + sqlStateId +
1:0c0db14:                         " in SQLState.java was not found in" +
1:0c0db14:                         " messages_en.properties");         
1:0c0db14:                 }
1:0c0db14:              }
1:0c0db14:         }
1:121b2ed:     }
1:0c0db14: 
1:0c0db14:     /**
1:0c0db14:      * See if there are any message ids in MessageId.java not in
1:0c0db14:      * the message bundle
1:0c0db14:      */
1:0c0db14:     public void testMessageIdOrphanedIds() throws Exception {
1:0c0db14:         Iterator it = messageIdIds.iterator();
1:0c0db14:         
1:0c0db14:         while ( it.hasNext() ) {
1:0c0db14:             String sqlStateId = (String)it.next();
1:0c0db14:             
1:0c0db14:             if ( ! messageBundleIds.contains(sqlStateId) ) {
1:0c0db14:                 // Don't fail out on the first one, we want to catch
1:0c0db14:                 // all of them.  Just note there was a failure and continue
1:121b2ed:                 failbuild=true;
1:0c0db14:                 System.err.println("ERROR: Message id " + sqlStateId +
1:0c0db14:                     " in MessageId.java was not found in" +
1:0c0db14:                     " messages_en.properties");                    
1:0c0db14:              }
1:0c0db14:         }
1:0c0db14:     }
1:0c0db14:      
1:0c0db14:     /**
1:0c0db14:      * See if there are any message ids in the message bundle that
1:0c0db14:      * are <b>not</b> in SQLState.java or MessageId.java
1:0c0db14:      */
1:0c0db14:     public void testMessageBundleOrphanedMessages() throws Exception {
1:0c0db14:         Iterator it = messageBundleIds.iterator();
1:0c0db14:         
1:0c0db14:         while (it.hasNext() ) {
1:0c0db14:             String msgid = (String)it.next();
1:0c0db14:             
1:0c0db14:             if ( sqlStateIds.contains(msgid)) {
1:0c0db14:                 continue;
1:0c0db14:             }
1:0c0db14:             
1:0c0db14:             if ( messageIdIds.contains(msgid)) {
1:0c0db14:                 continue;
1:0c0db14:             }
1:0c0db14:             
1:0c0db14:             // Don't fail out on the first one, we want to catch
1:0c0db14:             // all of them.  Just note there was a failure and continue
1:121b2ed:             failbuild=true;
1:0c0db14:             System.err.println("WARNING: Message id " + msgid + 
1:0c0db14:                 " in messages_en.properties is not " +
1:0c0db14:                 "referenced in either SQLState.java or MessageId.java");
1:0c0db14:         }        
1:0c0db14:     }
1:0c0db14: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b850119
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 // 01004: automatically assigned by java.sql.DataTruncation and
1:                 //        never used to generate a message
1:                       sqlStateId.equalsIgnoreCase("XSAX1")   ||
1:                       sqlStateId.equalsIgnoreCase("01004"))) {
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1:     static HashSet<String> sqlStateIds  = new HashSet<String>();
1:     static HashSet<String> messageIdIds = new HashSet<String>();
1:     static HashSet<String> messageBundleIds = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1:     static void loadClassIds(Class idclass, HashSet<String> set)
1:             throws Exception {
commit:0c0db14
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.i18n.MessageBundleTest
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
0: package org.apache.derbyTesting.functionTests.tests.i18n;
1: 
0: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derby.shared.common.reference.MessageId;
1: 
1: import java.util.HashSet;
1: import java.lang.reflect.Field;
1: import java.util.ResourceBundle;
1: import java.util.Locale;
1: import java.util.Iterator;
1: 
1: /**
1:  * This class does everything we can to validate that the messages_en.properties
1:  * file is in synch with SQLState.java and MessageId.java.  We want to make sure
1:  * that message ids defined in SQLState and MessageId have matching messages
1:  * in the messages properties file, and also find out if there are any messages
1:  * that don't have matching ids in the SQLState and MessageId files.   The
1:  * first is a bug, the second is something to be aware of.
1:  */
0: public class MessageBundleTest extends BaseTestCase {
0:     public MessageBundleTest(String name) {
0:         super(name);
1:     }
1: 
1:     // The list of ids.  We use a HashSet so we can detect duplicates easily
0:     static HashSet sqlStateIds          = new HashSet();
0:     static HashSet messageIdIds         = new HashSet();
0:     static HashSet messageBundleIds     = new HashSet();
1:     
1:     static {
1:         try {
1:             // Load all the ids for the SQLState class
1:             loadClassIds(SQLState.class, sqlStateIds);
1: 
1:             // Load all the ids for the MessageId class
1:             loadClassIds(MessageId.class, messageIdIds);
1: 
1:             // Load all the ids for the messages_en properties file
1:             loadMessageBundleIds();
1:         } catch ( Exception e ) {
1:             e.printStackTrace();
1:             throw new RuntimeException(e.getMessage());
1:         }
1:     }
1:     
0:     static void loadClassIds(Class idclass, HashSet set) throws Exception {
1:         Field[] fields = idclass.getFields();
1:         
1:         int length = fields.length;
1:         for ( int i = 0; i < length ; i++ )
1:         {
1:             String id = (String)fields[i].get(null);
1:             
1:             if ( id.length() == 2 ) {
1:                 // Skip past identifiers that are just categories
1:                 continue;
1:             }
1:             
1:             // Skip past "special" SQL States that are not expected
1:             // to have messages
1:             if ( id.equals("close.C.1") )   continue;            
1:             if ( id.equals("rwupd" ) )      continue;
1:             if ( id.equals("02502" ) )      continue;
1:             if ( id.equals("XSAX0") )       continue;
1:             
1:             if ( ! set.add(id) )
1:             {
1:                 System.err.println("ERROR: The id " + id + 
1:                     " was found twice in " + idclass.getName());
1:             }
1:         }
1:     }
1:             
1:     /** 
1:      * Load all the message ids from messages_en.properties into a HashSet.
1:      * This assumes its available on the classpath
1:      */
1:     static void loadMessageBundleIds() throws Exception {
1:         ResourceBundle bundle;
1:         
1:         // The messages_*.properties files are split into fifty separate
1:         // message bundle files.  We need to load each one in turn
1:         int numBundles = 50;
1:         
1:         for ( int i=0 ; i < numBundles ; i++ ) {
1:             loadMessageBundle(i);
1:         }
1:     }
1:     
1:     static void loadMessageBundle(int index) {
1:         String bundleName = "org.apache.derby.loc.m" + index;
1:         
1:         ResourceBundle bundle = 
1:             ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
1: 
1:         java.util.Enumeration keys = bundle.getKeys();
1: 
1:         while ( keys.hasMoreElements() ) {
1:             String key = (String)keys.nextElement();                
1: 
1:             if ( ! messageBundleIds.add(key) ) {
1:                 System.err.println("ERROR: the key " + key +
1:                     " exists twice in messages_en.properties");
1:             }
1:         }        
1:     }
1: 
1:     /**
1:      * See if there are any message ids in SQLState.java that are
1:      * not in the message bundle
1:      */
1:     public void testSQLStateOrphanedIds() throws Exception {
1:         Iterator it = sqlStateIds.iterator();
1:         
1:         while ( it.hasNext() ) {
1:             String sqlStateId = (String)it.next();
1:             
1:             if ( ! messageBundleIds.contains(sqlStateId) ) {
1:                 // Don't fail out on the first one, we want to catch
1:                 // all of them.  Just note there was a failure and continue
1:                 System.err.println("ERROR: Message id " + sqlStateId +
1:                     " in SQLState.java was not found in" +
1:                     " messages_en.properties");                     
1:              }
1:         }
1:     }
1: 
1:     /**
1:      * See if there are any message ids in MessageId.java not in
1:      * the message bundle
1:      */
1:     public void testMessageIdOrphanedIds() throws Exception {
1:         Iterator it = messageIdIds.iterator();
1:         
1:         while ( it.hasNext() ) {
1:             String sqlStateId = (String)it.next();
1:             
1:             if ( ! messageBundleIds.contains(sqlStateId) ) {
1:                 // Don't fail out on the first one, we want to catch
1:                 // all of them.  Just note there was a failure and continue
1:                 System.err.println("ERROR: Message id " + sqlStateId +
1:                     " in MessageId.java was not found in" +
1:                     " messages_en.properties");                    
1:              }
1:         }
1:     }
1:      
1:     /**
1:      * See if there are any message ids in the message bundle that
1:      * are <b>not</b> in SQLState.java or MessageId.java
1:      */
1:     public void testMessageBundleOrphanedMessages() throws Exception {
1:         Iterator it = messageBundleIds.iterator();
1:         
1:         while (it.hasNext() ) {
1:             String msgid = (String)it.next();
1:             
1:             if ( sqlStateIds.contains(msgid)) {
1:                 continue;
1:             }
1:             
1:             if ( messageIdIds.contains(msgid)) {
1:                 continue;
1:             }
1:             
1:             // Don't fail out on the first one, we want to catch
1:             // all of them.  Just note there was a failure and continue
1:             System.err.println("WARNING: Message id " + msgid + 
1:                 " in messages_en.properties is not " +
1:                 "referenced in either SQLState.java or MessageId.java");
1:         }        
1:     }
1: }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:5a18567
/////////////////////////////////////////////////////////////////////////
0: import java.lang.Exception;
/////////////////////////////////////////////////////////////////////////
1: public class MessageBundleTest {
/////////////////////////////////////////////////////////////////////////
1:     public static void main(String [] args) throws Exception
/////////////////////////////////////////////////////////////////////////
1:             throw new Exception("Message check failed. \n" +
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:121b2ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyMessageBundleTest
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyBuild;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.tools.ant.BuildException;
0: import org.apache.tools.ant.Task;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0: public class MessageBundleTest extends Task {
1:     static boolean failbuild = false;
1: 
1:     /**
1:      * <p>
1:      * Let Ant conjure us out of thin air.
1:      * </p>
1:      */
1:     public MessageBundleTest()
1:     {}
1:     
0:     public void execute() throws BuildException
1:     {
1:         MessageBundleTest t = new MessageBundleTest();
1:         try {
1:             t.testMessageBundleOrphanedMessages();
1:             t.testMessageIdOrphanedIds();
1:             t.testSQLStateOrphanedIds();
1:         } catch (Exception e) {
1:             System.out.println("Message check failed: ");
1:             e.printStackTrace();
1:         }
1:         if (failbuild) 
0:             throw new BuildException("Message check failed. \n" +
1:                 "See error in build output or call ant runmessagecheck.");
1:     }    
1:     
/////////////////////////////////////////////////////////////////////////
1:                 failbuild=true;
/////////////////////////////////////////////////////////////////////////
1:                 failbuild=true;
/////////////////////////////////////////////////////////////////////////
0:                     sqlStateId.equalsIgnoreCase("XSAX1"))) {
1:                     failbuild=true;
0:                         " messages_en.properties");         
0:                 }
/////////////////////////////////////////////////////////////////////////
1:                 failbuild=true;
/////////////////////////////////////////////////////////////////////////
1:             failbuild=true;
commit:648e348
/////////////////////////////////////////////////////////////////////////
1:                 // there are some error messages that do not need to be in 
1:                 // messages.xml:
1:                 // XCL32: will never be exposed to users (see DERBY-1414)
1:                 // XSAX1: shared SQLState explains; not exposed to users. 
0:                 // 
1:                 if (!(sqlStateId.equalsIgnoreCase("XCL32.S") ||
0:                     sqlStateId.equalsIgnoreCase("XSAX1")))
0:                     System.err.println("ERROR: Message id " + sqlStateId +
0:                         " in SQLState.java was not found in" +
0:                         " messages_en.properties");                     
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseTestCase;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
0: /*
0:  
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.i18n.MessageBundleTest
0:  
0:    Licensed to the Apache Software Foundation (ASF) under one or more
0:    contributor license agreements.  See the NOTICE file distributed with
0:    this work for additional information regarding copyright ownership.
0:    The ASF licenses this file to You under the Apache License, Version 2.0
0:    (the "License"); you may not use this file except in compliance with
0:    the License.  You may obtain a copy of the License at
0:  
0:       http://www.apache.org/licenses/LICENSE-2.0
0:  
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0:  
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.i18n;
0: 
0: import org.apache.derbyTesting.functionTests.util.BaseTestCase;
0: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derby.shared.common.reference.MessageId;
0: 
0: import java.util.HashSet;
0: import java.lang.reflect.Field;
0: import java.util.ResourceBundle;
0: import java.util.Locale;
0: import java.util.Iterator;
0: 
0: /**
0:  * This class does everything we can to validate that the messages_en.properties
0:  * file is in synch with SQLState.java and MessageId.java.  We want to make sure
0:  * that message ids defined in SQLState and MessageId have matching messages
0:  * in the messages properties file, and also find out if there are any messages
0:  * that don't have matching ids in the SQLState and MessageId files.   The
0:  * first is a bug, the second is something to be aware of.
0:  */
0: public class MessageBundleTest extends BaseTestCase {
0:     public MessageBundleTest(String name) {
0:         super(name);
0:     }
0: 
0:     // The list of ids.  We use a HashSet so we can detect duplicates easily
0:     static HashSet sqlStateIds          = new HashSet();
0:     static HashSet messageIdIds         = new HashSet();
0:     static HashSet messageBundleIds     = new HashSet();
0:     
0:     static {
0:         try {
0:             // Load all the ids for the SQLState class
0:             loadClassIds(SQLState.class, sqlStateIds);
0: 
0:             // Load all the ids for the MessageId class
0:             loadClassIds(MessageId.class, messageIdIds);
0: 
0:             // Load all the ids for the messages_en properties file
0:             loadMessageBundleIds();
0:         } catch ( Exception e ) {
0:             e.printStackTrace();
0:             throw new RuntimeException(e.getMessage());
0:         }
0:     }
0:     
0:     static void loadClassIds(Class idclass, HashSet set) throws Exception {
0:         Field[] fields = idclass.getFields();
0:         
0:         int length = fields.length;
0:         for ( int i = 0; i < length ; i++ )
0:         {
0:             String id = (String)fields[i].get(null);
0:             
0:             if ( id.length() == 2 ) {
0:                 // Skip past identifiers that are just categories
0:                 continue;
0:             }
0:             
0:             // Skip past "special" SQL States that are not expected
0:             // to have messages
0:             if ( id.equals("close.C.1") )   continue;            
0:             if ( id.equals("rwupd" ) )      continue;
0:             if ( id.equals("02502" ) )      continue;
0:             if ( id.equals("XSAX0") )       continue;
0:             
0:             if ( ! set.add(id) )
0:             {
0:                 System.err.println("ERROR: The id " + id + 
0:                     " was found twice in " + idclass.getName());
0:             }
0:         }
0:     }
0:             
0:     /** 
0:      * Load all the message ids from messages_en.properties into a HashSet.
0:      * This assumes its available on the classpath
0:      */
0:     static void loadMessageBundleIds() throws Exception {
0:         ResourceBundle bundle;
0:         
0:         // The messages_*.properties files are split into fifty separate
0:         // message bundle files.  We need to load each one in turn
0:         int numBundles = 50;
0:         
0:         for ( int i=0 ; i < numBundles ; i++ ) {
0:             loadMessageBundle(i);
0:         }
0:     }
0:     
0:     static void loadMessageBundle(int index) {
0:         String bundleName = "org.apache.derby.loc.m" + index;
0:         
0:         ResourceBundle bundle = 
0:             ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
0: 
0:         java.util.Enumeration keys = bundle.getKeys();
0: 
0:         while ( keys.hasMoreElements() ) {
0:             String key = (String)keys.nextElement();                
0: 
0:             if ( ! messageBundleIds.add(key) ) {
0:                 System.err.println("ERROR: the key " + key +
0:                     " exists twice in messages_en.properties");
0:             }
0:         }        
0:     }
0: 
0:     /**
0:      * See if there are any message ids in SQLState.java that are
0:      * not in the message bundle
0:      */
0:     public void testSQLStateOrphanedIds() throws Exception {
0:         Iterator it = sqlStateIds.iterator();
0:         
0:         while ( it.hasNext() ) {
0:             String sqlStateId = (String)it.next();
0:             
0:             if ( ! messageBundleIds.contains(sqlStateId) ) {
0:                 // Don't fail out on the first one, we want to catch
0:                 // all of them.  Just note there was a failure and continue
0:                 System.err.println("ERROR: Message id " + sqlStateId +
0:                     " in SQLState.java was not found in" +
0:                     " messages_en.properties");                     
0:              }
0:         }
0:     }
0: 
0:     /**
0:      * See if there are any message ids in MessageId.java not in
0:      * the message bundle
0:      */
0:     public void testMessageIdOrphanedIds() throws Exception {
0:         Iterator it = messageIdIds.iterator();
0:         
0:         while ( it.hasNext() ) {
0:             String sqlStateId = (String)it.next();
0:             
0:             if ( ! messageBundleIds.contains(sqlStateId) ) {
0:                 // Don't fail out on the first one, we want to catch
0:                 // all of them.  Just note there was a failure and continue
0:                 System.err.println("ERROR: Message id " + sqlStateId +
0:                     " in MessageId.java was not found in" +
0:                     " messages_en.properties");                    
0:              }
0:         }
0:     }
0:      
0:     /**
0:      * See if there are any message ids in the message bundle that
0:      * are <b>not</b> in SQLState.java or MessageId.java
0:      */
0:     public void testMessageBundleOrphanedMessages() throws Exception {
0:         Iterator it = messageBundleIds.iterator();
0:         
0:         while (it.hasNext() ) {
0:             String msgid = (String)it.next();
0:             
0:             if ( sqlStateIds.contains(msgid)) {
0:                 continue;
0:             }
0:             
0:             if ( messageIdIds.contains(msgid)) {
0:                 continue;
0:             }
0:             
0:             // Don't fail out on the first one, we want to catch
0:             // all of them.  Just note there was a failure and continue
0:             System.err.println("WARNING: Message id " + msgid + 
0:                 " in messages_en.properties is not " +
0:                 "referenced in either SQLState.java or MessageId.java");
0:         }        
0:     }
0: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:bec4777
/////////////////////////////////////////////////////////////////////////
0:             // Skip past "special" SQL States that are not expected
0:             // to have messages
0:             if ( id.equals("close.C.1") )   continue;            
0:             if ( id.equals("rwupd" ) )      continue;
0:             if ( id.equals("02502" ) )      continue;
0:             if ( id.equals("XSAX0") )       continue;
0:             
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     " messages_en.properties");                     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     " messages_en.properties");                    
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         }        
commit:44ad7f6
/////////////////////////////////////////////////////////////////////////
0: /*
0:  
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.i18n.MessageBundleTest
0:  
0:    Copyright (c) 2001, 2006 The Apache Software Foundation or its licensors, where applicable.
0:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0:  
0:       http://www.apache.org/licenses/LICENSE-2.0
0:  
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0:  
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.i18n;
0: 
0: import org.apache.derbyTesting.functionTests.util.BaseTestCase;
0: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derby.shared.common.reference.MessageId;
0: 
0: import java.util.HashSet;
0: import java.lang.reflect.Field;
0: import java.util.ResourceBundle;
0: import java.util.Locale;
0: import java.util.Iterator;
0: 
0: /**
0:  * This class does everything we can to validate that the messages_en.properties
0:  * file is in synch with SQLState.java and MessageId.java.  We want to make sure
0:  * that message ids defined in SQLState and MessageId have matching messages
0:  * in the messages properties file, and also find out if there are any messages
0:  * that don't have matching ids in the SQLState and MessageId files.   The
0:  * first is a bug, the second is something to be aware of.
0:  */
0: public class MessageBundleTest extends BaseTestCase {
0:     public MessageBundleTest(String name) {
0:         super(name);
0:     }
0: 
0:     // The list of ids.  We use a HashSet so we can detect duplicates easily
0:     static HashSet sqlStateIds          = new HashSet();
0:     static HashSet messageIdIds         = new HashSet();
0:     static HashSet messageBundleIds     = new HashSet();
0:     
0:     static {
0:         try {
0:             // Load all the ids for the SQLState class
0:             loadClassIds(SQLState.class, sqlStateIds);
0: 
0:             // Load all the ids for the MessageId class
0:             loadClassIds(MessageId.class, messageIdIds);
0: 
0:             // Load all the ids for the messages_en properties file
0:             loadMessageBundleIds();
0:         } catch ( Exception e ) {
0:             e.printStackTrace();
0:             throw new RuntimeException(e.getMessage());
0:         }
0:     }
0:     
0:     static void loadClassIds(Class idclass, HashSet set) throws Exception {
0:         Field[] fields = idclass.getFields();
0:         
0:         int length = fields.length;
0:         for ( int i = 0; i < length ; i++ )
0:         {
0:             String id = (String)fields[i].get(null);
0:             
0:             if ( id.length() == 2 ) {
0:                 // Skip past identifiers that are just categories
0:                 continue;
0:             }
0:             
0:             if ( id.equals("close.C.1") ) {
0:                 // This one is not expected to have a message string
0:                 continue;
0:             }
0:             if ( ! set.add(id) )
0:             {
0:                 System.err.println("ERROR: The id " + id + 
0:                     " was found twice in " + idclass.getName());
0:             }
0:         }
0:     }
0:             
0:     /** 
0:      * Load all the message ids from messages_en.properties into a HashSet.
0:      * This assumes its available on the classpath
0:      */
0:     static void loadMessageBundleIds() throws Exception {
0:         ResourceBundle bundle;
0:         
0:         // The messages_*.properties files are split into fifty separate
0:         // message bundle files.  We need to load each one in turn
0:         int numBundles = 50;
0:         
0:         for ( int i=0 ; i < numBundles ; i++ ) {
0:             loadMessageBundle(i);
0:         }
0:     }
0:     
0:     static void loadMessageBundle(int index) {
0:         String bundleName = "org.apache.derby.loc.m" + index;
0:         
0:         ResourceBundle bundle = 
0:             ResourceBundle.getBundle(bundleName, Locale.ENGLISH);
0: 
0:         java.util.Enumeration keys = bundle.getKeys();
0: 
0:         while ( keys.hasMoreElements() ) {
0:             String key = (String)keys.nextElement();                
0: 
0:             if ( ! messageBundleIds.add(key) ) {
0:                 System.err.println("ERROR: the key " + key +
0:                     " exists twice in messages_en.properties");
0:             }
0:         }        
0:     }
0: 
0:     /**
0:      * See if there are any message ids in SQLState.java that are
0:      * not in the message bundle
0:      */
0:     public void testSQLStateOrphanedIds() throws Exception {
0:         Iterator it = sqlStateIds.iterator();
0:         boolean success = true;
0:         
0:         while ( it.hasNext() ) {
0:             String sqlStateId = (String)it.next();
0:             
0:             if ( ! messageBundleIds.contains(sqlStateId) ) {
0:                 // Don't fail out on the first one, we want to catch
0:                 // all of them.  Just note there was a failure and continue
0:                 System.err.println("ERROR: Message id " + sqlStateId +
0:                     " in SQLState.java was not found in" +
0:                     " messages_en.properties");     
0:                 
0:                 success = false;
0:              }
0:         }
0: 
0:         if ( ! success ) {
0:             fail("One or more message ids in MessageId.java was not found " +
0:                 "in messages_en.properties");
0:         }
0:     }
0: 
0:     /**
0:      * See if there are any message ids in MessageId.java not in
0:      * the message bundle
0:      */
0:     public void testMessageIdOrphanedIds() throws Exception {
0:         Iterator it = messageIdIds.iterator();
0:         boolean success = true;
0:         
0:         while ( it.hasNext() ) {
0:             String sqlStateId = (String)it.next();
0:             
0:             if ( ! messageBundleIds.contains(sqlStateId) ) {
0:                 // Don't fail out on the first one, we want to catch
0:                 // all of them.  Just note there was a failure and continue
0:                 System.err.println("ERROR: Message id " + sqlStateId +
0:                     " in MessageId.java was not found in" +
0:                     " messages_en.properties");    
0:                 
0:                 success = false;
0:              }
0:         }
0:         
0:         if ( ! success ) {
0:             fail("One or more message ids in MessageId.java was not found " +
0:                 "in messages_en.properties");
0:         }
0:     }
0:      
0:     /**
0:      * See if there are any message ids in the message bundle that
0:      * are <b>not</b> in SQLState.java or MessageId.java
0:      */
0:     public void testMessageBundleOrphanedMessages() throws Exception {
0:         Iterator it = messageBundleIds.iterator();
0:         boolean success = true;
0:         
0:         while (it.hasNext() ) {
0:             String msgid = (String)it.next();
0:             
0:             if ( sqlStateIds.contains(msgid)) {
0:                 continue;
0:             }
0:             
0:             if ( messageIdIds.contains(msgid)) {
0:                 continue;
0:             }
0:             
0:             // Don't fail out on the first one, we want to catch
0:             // all of them.  Just note there was a failure and continue
0:             System.err.println("WARNING: Message id " + msgid + 
0:                 " in messages_en.properties is not " +
0:                 "referenced in either SQLState.java or MessageId.java");
0:             success = false;
0:         }
0:         
0:         if ( ! success ) {
0:             fail("One or more message ids in messages_en.properties was not " +
0:                 "found in SQLState.java or MessageId.java");
0:         }
0:     }
0: }
============================================================================