1:7257ae6: /*
1:7257ae6:  * Class org.apache.derbyTesting.functionTests.tests.lang.StalePlansTest
1:7257ae6:  *
1:7257ae6:  * Licensed to the Apache Software Foundation (ASF) under one
1:7257ae6:  * or more contributor license agreements.  See the NOTICE file
1:7257ae6:  * distributed with this work for additional information
1:7257ae6:  * regarding copyright ownership.  The ASF licenses this file
1:7257ae6:  * to you under the Apache License, Version 2.0 (the
1:7257ae6:  * "License"); you may not use this file except in compliance
1:7257ae6:  * with the License.  You may obtain a copy of the License at
1:7257ae6:  *
1:7257ae6:  *   http://www.apache.org/licenses/LICENSE-2.0
1:7257ae6:  *
1:7257ae6:  * Unless required by applicable law or agreed to in writing,
1:7257ae6:  * software distributed under the License is distributed on an
1:7257ae6:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:7257ae6:  * KIND, either express or implied.  See the License for the
1:7257ae6:  * specific language governing permissions and limitations
1:7257ae6:  * under the License.
1:7257ae6:  */
1:7257ae6: package org.apache.derbyTesting.functionTests.tests.lang;
1:7257ae6: 
1:7257ae6: import java.sql.PreparedStatement;
1:7257ae6: import java.sql.SQLException;
1:7257ae6: import java.sql.Statement;
1:7257ae6: import java.util.Properties;
1:7257ae6: import junit.framework.Test;
1:7257ae6: import org.apache.derbyTesting.functionTests.util.Formatters;
1:7257ae6: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:7257ae6: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:7257ae6: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:7257ae6: import org.apache.derbyTesting.junit.JDBC;
1:dd908e8: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:7257ae6: import org.apache.derbyTesting.junit.SQLUtilities;
1:7257ae6: 
1:7257ae6: /**
1:7257ae6:  * This is the test for stale plan invalidation. The system determines at
1:7257ae6:  * execution whether the tables used by a DML statement have grown or shrunk
1:7257ae6:  * significantly, and if so, causes the statement to be recompiled at the next
1:7257ae6:  * execution.
1:7257ae6:  */
1:7257ae6: public class StalePlansTest extends BaseJDBCTestCase {
1:8bef59d:     /**
1:8bef59d:      * The value of derby.language.stalePlanCheckInterval to use in this
1:8bef59d:      * test. The default value is 100, but we use 10 to reduce the number
1:8bef59d:      * of times the test has to execute statements to get to the desired
1:8bef59d:      * state.
1:8bef59d:      */
1:8bef59d:     private static final int STALE_PLAN_CHECK_INTERVAL = 10;
1:8bef59d: 
1:7257ae6:     public StalePlansTest(String name) {
1:7257ae6:         super(name);
3:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Create the test suite. This test is not run in client/server mode since
1:7257ae6:      * it only tests the query plans generated by the embedded driver.
1:7257ae6:      */
1:7257ae6:     public static Test suite() {
1:7257ae6:         Properties props = new Properties();
1:db8af5c:         // Check for stale plans on every 10th execution (default 100) to
1:db8af5c:         // reduce the number of times we need to execute each statement.
1:8bef59d:         props.setProperty("derby.language.stalePlanCheckInterval",
1:8bef59d:                           String.valueOf(STALE_PLAN_CHECK_INTERVAL));
1:d6aaec9:         // Disable the index statistics daemon so that it doesn't cause
1:d6aaec9:         // recompilation of statements at random times.
1:d6aaec9:         props.setProperty("derby.storage.indexStats.auto", "false");
1:7257ae6:         Test suite = new DatabasePropertyTestSetup(
1:1ae02c9:             new BaseTestSuite(StalePlansTest.class), props, true);
1:db8af5c:         return new CleanDatabaseTestSetup(suite);
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Create tables and indexes needed by the test cases. Enable collection of
1:7257ae6:      * run-time statistics.
1:7257ae6:      */
1:7257ae6:     protected void setUp() throws SQLException {
1:7257ae6:         getConnection().setAutoCommit(false);
1:7257ae6:         Statement stmt = createStatement();
1:7257ae6:         stmt.executeUpdate("create table t (c1 int, c2 int, c3 varchar(255))");
1:7257ae6:         stmt.executeUpdate("create index idx on t (c1)");
1:7257ae6:         stmt.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:7257ae6:         stmt.close();
1:7257ae6:         commit();
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Drop tables used in the test.
1:7257ae6:      */
1:7257ae6:     protected void tearDown() throws Exception {
1:7257ae6:         Statement stmt = createStatement();
1:7257ae6:         stmt.executeUpdate("drop table t");
1:7257ae6:         commit();
1:7257ae6:         super.tearDown();
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:db8af5c:      * Flush the cache so that row count changes are visible. When a dirty
1:db8af5c:      * page is written to disk, the row count estimate for the container will
1:db8af5c:      * be updated with the number of added/deleted rows on that page since
1:db8af5c:      * the last time the page was read from disk or written to disk. We invoke
1:db8af5c:      * a checkpoint in order to force all dirty pages to be flushed and make
1:db8af5c:      * all row count changes visible.
1:7257ae6:      */
1:7257ae6:     private void flushRowCount(Statement stmt) throws SQLException {
1:db8af5c:         stmt.execute("CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Negative test - set stalePlanCheckInterval to a value out of range.
1:7257ae6:      */
1:7257ae6:     public void testStalePlanCheckIntervalOutOfRange() throws SQLException {
1:7257ae6:         Statement stmt = createStatement();
1:7257ae6:         assertStatementError("XCY00", stmt,
1:7257ae6:                              "call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:7257ae6:                              "'derby.language.stalePlanCheckInterval', '2')");
1:7257ae6:         stmt.close();
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Test that the query plan is changed when the size of a small table
1:7257ae6:      * changes.
1:7257ae6:      *
1:7257ae6:      * <p><b>Note:</b> This test is outdated since Derby now tries to use index
1:7257ae6:      * scans whenever possible on small tables (primarily to avoid table locks
1:7257ae6:      * for certain isolation levels, but also because a small table is likely
1:7257ae6:      * to grow).
1:7257ae6:      */
1:7257ae6:     public void testStalePlansOnSmallTable() throws SQLException {
1:7257ae6:         Statement stmt = createStatement();
1:7257ae6: 
1:7257ae6:         PreparedStatement insert =
1:7257ae6:             prepareStatement("insert into t values (?,?,?)");
1:7257ae6:         insert.setInt(1, 1);
1:7257ae6:         insert.setInt(2, 100);
1:7257ae6:         insert.setString(3, Formatters.padString("abc", 255));
1:7257ae6:         insert.executeUpdate();
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Make sure row count from insert is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         PreparedStatement ps =
1:7257ae6:             prepareStatement("select count(c1 + c2) from t where c1 = 1");
1:7257ae6: 
1:7257ae6:         // Expect this to do an index scan
1:7257ae6:         String[][] expected = {{ "1" }};
1:7257ae6:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
2:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:7257ae6: 
1:7257ae6:         // Execute 11 more times, the plan should not change
1:7257ae6:         for (int i = 0; i < 11; i++) {
1:7257ae6:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect index scan
1:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Now increase the size of the table
1:7257ae6:         insert.setInt(2, 100);
1:7257ae6:         for (int i = 2; i <= 10; i++) {
1:7257ae6:             insert.setInt(1, i);
1:7257ae6:             insert.executeUpdate();
1:7257ae6:         }
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Make sure row count from inserts is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         // Execute 11 times, the plan should not change
1:7257ae6:         for (int i = 0; i < 11; i++) {
1:7257ae6:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect this to use index
1:7257ae6:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Now shrink the table back to its original size
1:7257ae6:         stmt.executeUpdate("delete from t where c1 >= 2");
1:7257ae6: 
1:7257ae6:         // Execute 11 times, the plan should not change
1:7257ae6:         for (int i = 0; i < 11; i++) {
1:7257ae6:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect this to do an index scan
1:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:7257ae6: 
1:7257ae6:         stmt.close();
1:7257ae6:         ps.close();
1:7257ae6:         insert.close();
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:7257ae6:      * Test that the query plan changes when a large table is modified.
1:7257ae6:      */
1:7257ae6:     public void testStalePlansOnLargeTable() throws SQLException {
1:7257ae6:         Statement stmt = createStatement();
1:7257ae6: 
1:7257ae6:         PreparedStatement insert =
1:7257ae6:             prepareStatement("insert into t values (?,?,?)");
1:7257ae6:         insert.setInt(1, 1);
1:7257ae6:         insert.setInt(2, 1);
1:7257ae6:         insert.setString(3, Formatters.padString("abc", 255));
1:7257ae6:         insert.executeUpdate();
1:7257ae6: 
1:7257ae6:         PreparedStatement insert2 =
1:7257ae6:             prepareStatement("insert into t select c1+?, c2+?, c3 from t");
1:7257ae6:         for (int i = 1; i <= 512; i *= 2) {
1:7257ae6:             insert2.setInt(1, i);
1:7257ae6:             insert2.setInt(2, i);
1:7257ae6:             insert2.executeUpdate();
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Make sure row count from inserts is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         PreparedStatement ps = prepareStatement(
1:7257ae6:             "select count(c1 + c2) from t where c1 = 1");
1:7257ae6: 
1:7257ae6:         // Expect this to use index
1:7257ae6:         String[][] expected = {{ "1" }};
1:7257ae6:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:7257ae6:         commit();
1:7257ae6: 
1:db8af5c:         // Change the row count a little bit. A recompile will only be
1:db8af5c:         // triggered if the row count changes by 10% or more.
1:db8af5c:         for (int i = 1025; i <= 1250; i++) {
1:7257ae6:             insert.setInt(1, i);
1:7257ae6:             insert.setInt(2, i);
1:7257ae6:             insert.executeUpdate();
1:7257ae6:         }
1:7257ae6:         commit();
1:7257ae6: 
1:7257ae6:         // Change the data so a table scan would make more sense.
1:7257ae6:         // Use a qualifier to convince TableScanResultSet not to
1:7257ae6:         // update the row count in the store (which would make it
1:7257ae6:         // hard for this test to control when recompilation takes
1:7257ae6:         // place).
1:7257ae6:         stmt.executeUpdate("update t set c1 = 1 where c1 > 0");
1:7257ae6: 
1:7257ae6:         // Make sure row count from inserts is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         // Execute 11 more times, the plan should not change
1:7257ae6:         for (int i = 0; i < 11; i++) {
1:db8af5c:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1250");
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect this to use table scan, as the above update has basically
1:7257ae6:         // made all the rows in the table be equal to "1", thus using the index
1:7257ae6:         // does not help if all the rows are going to qualify.
1:dd908e8:         RuntimeStatisticsParser rsp =
1:dd908e8:                 SQLUtilities.getRuntimeStatisticsParser(stmt);
1:dd908e8:         if (!rsp.usedTableScan()) {
1:dd908e8:             // Dump the full plan to help debug DERBY-6336.
1:dd908e8:             fail("Expected table scan. Full plan:\n" + rsp.toString());
1:dd908e8:         }
1:7257ae6: 
1:7257ae6:         // Change the row count significantly
1:7257ae6:         stmt.executeUpdate("insert into t select c1,c2,c3 from t where c1<128");
1:7257ae6: 
1:7257ae6:         // Make sure row count from inserts is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         // Execute 11 times, the plan should change
1:7257ae6:         for (int i = 0; i < 11; i++) {
1:db8af5c:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "2500");
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect this to do table scan
1:7257ae6:         assertTrue(SQLUtilities.
2:7257ae6:                    getRuntimeStatisticsParser(stmt).usedTableScan());
1:7257ae6: 
1:7257ae6:         // Change the distribution back to where an index makes sense
1:7257ae6:         stmt.executeUpdate("update t set c1 = c2");
1:7257ae6: 
1:7257ae6:         // Change the row count significantly
1:7257ae6:         stmt.executeUpdate("insert into t select c1, c2, c3 from t");
1:7257ae6: 
1:7257ae6:         // Make sure row count from inserts is flushed out
1:7257ae6:         flushRowCount(stmt);
1:7257ae6: 
1:7257ae6:         // Execute 11 times, the plan should change
1:7257ae6:         for (int i = 0; i < 11; i++) {
3:7257ae6:             JDBC.assertFullResultSet(ps.executeQuery(),
1:7257ae6:                                      new String[][] { { "4" } });
1:7257ae6:         }
1:7257ae6: 
1:7257ae6:         // Expect this to do index to baserow
1:7257ae6:         assertTrue(SQLUtilities.
1:7257ae6:                    getRuntimeStatisticsParser(stmt).usedIndexRowToBaseRow());
1:7257ae6: 
1:7257ae6:         stmt.close();
1:7257ae6:         insert.close();
1:7257ae6:         insert2.close();
1:7257ae6:         ps.close();
1:7257ae6:     }
1:8bef59d: 
1:8bef59d:     /**
1:8bef59d:      * Regression test case for DERBY-6724, where an INSERT statement would
1:8bef59d:      * fail with a NullPointerException if it had fired a trigger, and it
1:8bef59d:      * was detected during execution that the statement plan was stale and
1:8bef59d:      * had to be recompiled.
1:8bef59d:      */
1:8bef59d:     public void testDerby6724() throws SQLException {
1:8bef59d:         Statement s = createStatement();
1:8bef59d:         s.execute("create table d6724_t(x int)");
1:8bef59d:         s.execute("create trigger d6724_tr after insert on d6724_t values 1");
1:8bef59d:         s.execute("insert into d6724_t values 1");
1:8bef59d: 
1:8bef59d:         // Before DERBY-6724 this statement would fail with an NPE in the
1:8bef59d:         // (STALE_PLAN_CHECK_INTERVAL+1)'th execution.
1:8bef59d:         PreparedStatement ps = prepareStatement(
1:8bef59d:                 "insert into d6724_t select * from d6724_t");
1:8bef59d:         for (int i = 0; i < STALE_PLAN_CHECK_INTERVAL + 1; i++) {
1:8bef59d:             // Execute the statement and verify that the correct number of
1:8bef59d:             // rows are inserted. The number doubles for each execution.
1:8bef59d:             assertUpdateCount(ps, 1 << i);
1:8bef59d:         }
1:8bef59d: 
1:8bef59d:         rollback();
1:8bef59d:     }
1:7257ae6: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8bef59d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The value of derby.language.stalePlanCheckInterval to use in this
1:      * test. The default value is 100, but we use 10 to reduce the number
1:      * of times the test has to execute statements to get to the desired
1:      * state.
1:      */
1:     private static final int STALE_PLAN_CHECK_INTERVAL = 10;
1: 
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("derby.language.stalePlanCheckInterval",
1:                           String.valueOf(STALE_PLAN_CHECK_INTERVAL));
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-6724, where an INSERT statement would
1:      * fail with a NullPointerException if it had fired a trigger, and it
1:      * was detected during execution that the statement plan was stale and
1:      * had to be recompiled.
1:      */
1:     public void testDerby6724() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table d6724_t(x int)");
1:         s.execute("create trigger d6724_tr after insert on d6724_t values 1");
1:         s.execute("insert into d6724_t values 1");
1: 
1:         // Before DERBY-6724 this statement would fail with an NPE in the
1:         // (STALE_PLAN_CHECK_INTERVAL+1)'th execution.
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into d6724_t select * from d6724_t");
1:         for (int i = 0; i < STALE_PLAN_CHECK_INTERVAL + 1; i++) {
1:             // Execute the statement and verify that the correct number of
1:             // rows are inserted. The number doubles for each execution.
1:             assertUpdateCount(ps, 1 << i);
1:         }
1: 
1:         rollback();
1:     }
commit:d6aaec9
/////////////////////////////////////////////////////////////////////////
1:         // Disable the index statistics daemon so that it doesn't cause
1:         // recompilation of statements at random times.
1:         props.setProperty("derby.storage.indexStats.auto", "false");
commit:dd908e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
/////////////////////////////////////////////////////////////////////////
1:         RuntimeStatisticsParser rsp =
1:                 SQLUtilities.getRuntimeStatisticsParser(stmt);
1:         if (!rsp.usedTableScan()) {
1:             // Dump the full plan to help debug DERBY-6336.
1:             fail("Expected table scan. Full plan:\n" + rsp.toString());
1:         }
commit:db8af5c
/////////////////////////////////////////////////////////////////////////
1:         // Check for stale plans on every 10th execution (default 100) to
1:         // reduce the number of times we need to execute each statement.
1:         return new CleanDatabaseTestSetup(suite);
/////////////////////////////////////////////////////////////////////////
1:      * Flush the cache so that row count changes are visible. When a dirty
1:      * page is written to disk, the row count estimate for the container will
1:      * be updated with the number of added/deleted rows on that page since
1:      * the last time the page was read from disk or written to disk. We invoke
1:      * a checkpoint in order to force all dirty pages to be flushed and make
1:      * all row count changes visible.
1:         stmt.execute("CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
/////////////////////////////////////////////////////////////////////////
1:         // Change the row count a little bit. A recompile will only be
1:         // triggered if the row count changes by 10% or more.
1:         for (int i = 1025; i <= 1250; i++) {
/////////////////////////////////////////////////////////////////////////
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1250");
/////////////////////////////////////////////////////////////////////////
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "2500");
commit:7257ae6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.StalePlansTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Properties;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1: 
1: /**
1:  * This is the test for stale plan invalidation. The system determines at
1:  * execution whether the tables used by a DML statement have grown or shrunk
1:  * significantly, and if so, causes the statement to be recompiled at the next
1:  * execution.
1:  */
1: public class StalePlansTest extends BaseJDBCTestCase {
1:     public StalePlansTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Create the test suite. This test is not run in client/server mode since
1:      * it only tests the query plans generated by the embedded driver.
1:      */
1:     public static Test suite() {
1:         Properties props = new Properties();
0:         props.setProperty("derby.language.stalePlanCheckInterval", "10");
0:         props.setProperty("derby.storage.checkpointInterval", "100000");
1:         Test suite = new DatabasePropertyTestSetup(
0:             new TestSuite(StalePlansTest.class), props, true);
0:         return new CleanDatabaseTestSetup(suite) {
0:             protected void decorateSQL(Statement s) throws SQLException {
0:                 // Create and populate a table to be used for flushing the
0:                 // cache. Flushing the cache causes all row count changes to be
0:                 // written, which is necessary for the results of this test to
0:                 // be stable (because otherwise the row count changes would be
0:                 // written asynchronously)
0:                 s.executeUpdate("create table flusher (c1 varchar(3000))");
0:                 PreparedStatement ps = getConnection().prepareStatement(
0:                     "insert into flusher values ?");
0:                 ps.setString(1, Formatters.padString("a", 3000));
0:                 for (int i = 0; i < 64; i++) {
0:                     ps.executeUpdate();
1:                 }
1:             }
0:         };
1:     }
1: 
1:     /**
1:      * Create tables and indexes needed by the test cases. Enable collection of
1:      * run-time statistics.
1:      */
1:     protected void setUp() throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table t (c1 int, c2 int, c3 varchar(255))");
1:         stmt.executeUpdate("create index idx on t (c1)");
1:         stmt.executeUpdate("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.close();
1:         commit();
1:     }
1: 
1:     /**
1:      * Drop tables used in the test.
1:      */
1:     protected void tearDown() throws Exception {
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("drop table t");
1:         commit();
1:         super.tearDown();
1:     }
1: 
1:     /**
0:      * Flush the cache so that row count changes are visible.
1:      */
1:     private void flushRowCount(Statement stmt) throws SQLException {
0:         JDBC.assertFullResultSet(
0:             stmt.executeQuery("select count(c1) from flusher"),
0:             new String[][] { { "64" } });
1:     }
1: 
1:     /**
1:      * Negative test - set stalePlanCheckInterval to a value out of range.
1:      */
1:     public void testStalePlanCheckIntervalOutOfRange() throws SQLException {
1:         Statement stmt = createStatement();
1:         assertStatementError("XCY00", stmt,
1:                              "call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                              "'derby.language.stalePlanCheckInterval', '2')");
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Test that the query plan is changed when the size of a small table
1:      * changes.
1:      *
1:      * <p><b>Note:</b> This test is outdated since Derby now tries to use index
1:      * scans whenever possible on small tables (primarily to avoid table locks
1:      * for certain isolation levels, but also because a small table is likely
1:      * to grow).
1:      */
1:     public void testStalePlansOnSmallTable() throws SQLException {
1:         Statement stmt = createStatement();
1: 
1:         PreparedStatement insert =
1:             prepareStatement("insert into t values (?,?,?)");
1:         insert.setInt(1, 1);
1:         insert.setInt(2, 100);
1:         insert.setString(3, Formatters.padString("abc", 255));
1:         insert.executeUpdate();
1:         commit();
1: 
1:         // Make sure row count from insert is flushed out
1:         flushRowCount(stmt);
1: 
1:         PreparedStatement ps =
1:             prepareStatement("select count(c1 + c2) from t where c1 = 1");
1: 
1:         // Expect this to do an index scan
1:         String[][] expected = {{ "1" }};
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1: 
1:         // Execute 11 more times, the plan should not change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1: 
1:         // Expect index scan
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:         commit();
1: 
1:         // Now increase the size of the table
1:         insert.setInt(2, 100);
1:         for (int i = 2; i <= 10; i++) {
1:             insert.setInt(1, i);
1:             insert.executeUpdate();
1:         }
1:         commit();
1: 
1:         // Make sure row count from inserts is flushed out
1:         flushRowCount(stmt);
1: 
1:         // Execute 11 times, the plan should not change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1: 
1:         // Expect this to use index
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:         commit();
1: 
1:         // Now shrink the table back to its original size
1:         stmt.executeUpdate("delete from t where c1 >= 2");
1: 
1:         // Execute 11 times, the plan should not change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         }
1: 
1:         // Expect this to do an index scan
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1: 
1:         stmt.close();
1:         ps.close();
1:         insert.close();
1:     }
1: 
1:     /**
1:      * Test that the query plan changes when a large table is modified.
1:      */
1:     public void testStalePlansOnLargeTable() throws SQLException {
1:         Statement stmt = createStatement();
1: 
1:         PreparedStatement insert =
1:             prepareStatement("insert into t values (?,?,?)");
1:         insert.setInt(1, 1);
1:         insert.setInt(2, 1);
1:         insert.setString(3, Formatters.padString("abc", 255));
1:         insert.executeUpdate();
1: 
1:         PreparedStatement insert2 =
1:             prepareStatement("insert into t select c1+?, c2+?, c3 from t");
1:         for (int i = 1; i <= 512; i *= 2) {
1:             insert2.setInt(1, i);
1:             insert2.setInt(2, i);
1:             insert2.executeUpdate();
1:         }
1: 
1:         commit();
1: 
1:         // Make sure row count from inserts is flushed out
1:         flushRowCount(stmt);
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "select count(c1 + c2) from t where c1 = 1");
1: 
1:         // Expect this to use index
1:         String[][] expected = {{ "1" }};
1:         JDBC.assertFullResultSet(ps.executeQuery(), expected);
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexScan());
1:         commit();
1: 
0:         // Change the row count a little bit
0:         for (int i = 1025; i <= 1034; i++) {
1:             insert.setInt(1, i);
1:             insert.setInt(2, i);
1:             insert.executeUpdate();
1:         }
1:         commit();
1: 
1:         // Change the data so a table scan would make more sense.
1:         // Use a qualifier to convince TableScanResultSet not to
1:         // update the row count in the store (which would make it
1:         // hard for this test to control when recompilation takes
1:         // place).
1:         stmt.executeUpdate("update t set c1 = 1 where c1 > 0");
1: 
1:         // Make sure row count from inserts is flushed out
1:         flushRowCount(stmt);
1: 
1:         // Execute 11 more times, the plan should not change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(),
0:                                      new String[][] { { "1034" } });
1:         }
1: 
1:         // Expect this to use table scan, as the above update has basically
1:         // made all the rows in the table be equal to "1", thus using the index
1:         // does not help if all the rows are going to qualify.
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedTableScan());
1: 
1:         // Change the row count significantly
1:         stmt.executeUpdate("insert into t select c1,c2,c3 from t where c1<128");
1: 
1:         // Make sure row count from inserts is flushed out
1:         flushRowCount(stmt);
1: 
1:         // Execute 11 times, the plan should change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(),
0:                                      new String[][] { { "2068" } });
1:         }
1: 
1:         // Expect this to do table scan
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedTableScan());
1: 
1:         // Change the distribution back to where an index makes sense
1:         stmt.executeUpdate("update t set c1 = c2");
1: 
1:         // Change the row count significantly
1:         stmt.executeUpdate("insert into t select c1, c2, c3 from t");
1: 
1:         // Make sure row count from inserts is flushed out
1:         flushRowCount(stmt);
1: 
1:         // Execute 11 times, the plan should change
1:         for (int i = 0; i < 11; i++) {
1:             JDBC.assertFullResultSet(ps.executeQuery(),
1:                                      new String[][] { { "4" } });
1:         }
1: 
1:         // Expect this to do index to baserow
1:         assertTrue(SQLUtilities.
1:                    getRuntimeStatisticsParser(stmt).usedIndexRowToBaseRow());
1: 
1:         stmt.close();
1:         insert.close();
1:         insert2.close();
1:         ps.close();
1:     }
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(StalePlansTest.class), props, true);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c7f3642
/////////////////////////////////////////////////////////////////////////
0:                 ps.close();
============================================================================