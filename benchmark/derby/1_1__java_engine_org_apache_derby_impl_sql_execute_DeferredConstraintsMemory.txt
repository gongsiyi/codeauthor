1:af1c18c: /*
48:af1c18c: 
1:af1c18c:    Derby - Class org.apache.derby.impl.sql.execute.DeferredConstraintsMemory
1:af1c18c: 
1:af1c18c:    Licensed to the Apache Software Foundation (ASF) under one or more
1:af1c18c:    contributor license agreements.  See the NOTICE file distributed with
1:af1c18c:    this work for additional information regarding copyright ownership.
1:af1c18c:    The ASF licenses this file to you under the Apache License, Version 2.0
1:af1c18c:    (the "License"); you may not use this file except in compliance with
1:af1c18c:    the License.  You may obtain a copy of the License at
1:af1c18c: 
1:af1c18c:       http://www.apache.org/licenses/LICENSE-2.0
1:af1c18c: 
1:af1c18c:    Unless required by applicable law or agreed to in writing, software
1:af1c18c:    distributed under the License is distributed on an "AS IS" BASIS,
1:af1c18c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:af1c18c:    See the License for the specific language governing permissions and
1:af1c18c:    limitations under the License.
1:af1c18c: 
7:af1c18c:  */
1:af1c18c: 
1:af1c18c: package org.apache.derby.impl.sql.execute;
1:bde481b: import java.sql.ResultSet;
1:af1c18c: import java.util.ArrayList;
1:af1c18c: import java.util.Enumeration;
1:af1c18c: import java.util.HashMap;
1:af1c18c: import java.util.HashSet;
1:af1c18c: import java.util.List;
1:af1c18c: import java.util.Set;
1:af1c18c: import org.apache.derby.catalog.UUID;
1:af1c18c: import org.apache.derby.iapi.error.StandardException;
1:af1c18c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:4cc0287: import org.apache.derby.iapi.sql.Activation;
1:af1c18c: import org.apache.derby.iapi.sql.PreparedStatement;
1:af1c18c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:4cc0287: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1:bde481b: import org.apache.derby.iapi.sql.conn.StatementContext;
1:af1c18c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:af1c18c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:4cc0287: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
1:f6d02c9: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1:f6d02c9: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1:af1c18c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:af1c18c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:af1c18c: import org.apache.derby.iapi.sql.execute.ExecRow;
1:af1c18c: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:af1c18c: import org.apache.derby.iapi.store.access.ScanController;
1:af1c18c: import org.apache.derby.iapi.store.access.TransactionController;
1:af1c18c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:af1c18c: import org.apache.derby.iapi.types.RowLocation;
1:af1c18c: import org.apache.derby.iapi.types.SQLRef;
1:af1c18c: import org.apache.derby.shared.common.reference.SQLState;
1:af1c18c: 
7:af1c18c: /**
1:af1c18c:  * This class provides support for deferrable constraints. When the constraint
1:af1c18c:  * mode is deferred, any violation of the constraint should not be flagged
1:af1c18c:  * until the constraint mode is switched back to immediate, which may happen by
1:af1c18c:  * explicitly setting the constraint mode to immediate, or implicitly at commit
1:af1c18c:  * time. It may also happen implicitly when returning from a stored procedure
1:af1c18c:  * if the constraint mode is immediate in the caller context.
2:af1c18c:  * <p>
1:af1c18c:  * The approach taken in Derby to support deferred constraints is to make a note
1:af1c18c:  * when the violation happens (at insert or update time), and then remember that
1:af1c18c:  * violation until the mode switches back as described above.  We note exactly
1:af1c18c:  * which rows cause violations, so checking can happen as quickly as possible
1:af1c18c:  * when we get there. The core mechanism used to remember the violations as well
1:af1c18c:  * as the deferred checking is embodied in this class.
5:af1c18c:  *
1:af1c18c:  */
1:af1c18c: final public class DeferredConstraintsMemory
1:af1c18c: {
1:af1c18c: 
1:af1c18c:     /**
1:af1c18c:      * Save the contents of an constraint supporting index row in a
1:af1c18c:      * hash table (which may spill to disk) for later checking,
1:af1c18c:      * typically on transaction commit, or upon request.
1:af1c18c:      *
2:af1c18c:      * @param lcc       the language connection context
1:af1c18c:      * @param deferredRowsHashTable
1:af1c18c:      *                  client cached value
1:f6d02c9:      * @param constraintId the id of the unique or primary key constraint
1:af1c18c:      * @param insertRow the duplicate row to be saved in the hash table
1:af1c18c:      *                  for later checking
1:af1c18c:      * @return the hash table (for caching by client to minimize lookups)
1:af1c18c:      * @throws StandardException standard error policy
1:af1c18c:      */
1:af1c18c:     public static BackingStoreHashtable rememberDuplicate(
5:af1c18c:             final LanguageConnectionContext lcc,
1:af1c18c:                   BackingStoreHashtable deferredRowsHashTable,
1:f6d02c9:             UUID constraintId,
1:af1c18c:             final DataValueDescriptor[] insertRow) throws StandardException {
1:af1c18c: 
1:af1c18c:         // Don't copy the RowLocation, we don't need it:
1:af1c18c:         final int keyLength = insertRow.length -1 ;
1:af1c18c: 
1:af1c18c:         if (deferredRowsHashTable == null) {
1:af1c18c:             // Use the backing hashtable for this index's deferred rows
1:af1c18c:             // by checking the transaction's map of such backing hash
1:af1c18c:             // tables (one per index conglomerate).  Use it if it
1:af1c18c:             // exists, else make a new one.
1:af1c18c: 
1:f6d02c9:             final HashMap<UUID, ValidationInfo> hashTables =
3:af1c18c:                 lcc.getDeferredHashTables();
1:f6d02c9:             final ValidationInfo vi = hashTables.get(constraintId);
1:af1c18c: 
1:af1c18c:             if (vi == null) {
1:af1c18c:                 deferredRowsHashTable =
1:af1c18c:                   makeDeferredHashTable(lcc.getTransactionExecute(), keyLength);
1:af1c18c: 
1:af1c18c:                 hashTables.put(
1:f6d02c9:                     constraintId,
1:f6d02c9:                     new UniquePkInfo(deferredRowsHashTable, constraintId));
5:af1c18c:             } else {
1:af1c18c:                 deferredRowsHashTable = vi.infoRows;
1:4cc0287:             }
1:4cc0287:         }
1:4cc0287: 
1:af1c18c:         DataValueDescriptor[] hashRowArray = new DataValueDescriptor[keyLength];
1:af1c18c:         System.arraycopy(insertRow, 0, hashRowArray, 0, keyLength);
1:af1c18c:         deferredRowsHashTable.putRow(true, hashRowArray, null);
1:4cc0287: 
1:af1c18c:         return deferredRowsHashTable;
33:af1c18c:     }
1:af1c18c: 
1:af1c18c:     /**
1:af1c18c:      * Save the row location of an offending row (one or more check constraints
1:af1c18c:      * were violated) in a hash table (which may spill to disk) for later
1:af1c18c:      * checking, typically on transaction commit, or upon request.
1:af1c18c:      *
1:af1c18c:      * The row locations are subject to invalidation, cf.
1:af1c18c:      * {@code CheckInfo#setInvalidatedRowLocations}.
1:af1c18c:      *
1:f6d02c9:      * @param basetableId the id of the target table
1:af1c18c:      * @param schemaName the schema of the target table
1:af1c18c:      * @param tableName the target table name
1:af1c18c:      * @param deferredCheckViolations
1:af1c18c:      *                  client cached value
1:4cc0287:      * @param lcc       the language connection context
1:af1c18c:      * @param violatingCheckConstraints offending constraint(s)
1:af1c18c:      * @param offendingRow the duplicate row to be saved in the hash table
1:af1c18c:      *                  for later checking
1:4cc0287:      * @param result OUT parameter: the allocated CheckInfo
1:af1c18c:      * @return the hash table (for caching by client to minimize lookups)
1:af1c18c:      * @throws StandardException standard error policy
1:af1c18c:      */
1:af1c18c:     public static BackingStoreHashtable rememberCheckViolations(
1:af1c18c:             final LanguageConnectionContext lcc,
1:f6d02c9:             UUID  basetableId,
1:af1c18c:             final String schemaName,
1:af1c18c:             final String tableName,
1:af1c18c:                   BackingStoreHashtable deferredCheckViolations,
1:af1c18c:             final List<UUID> violatingCheckConstraints,
1:4cc0287:             final RowLocation offendingRow,
1:4cc0287:             CheckInfo[] result) throws StandardException {
1:af1c18c: 
1:af1c18c:         if (violatingCheckConstraints.isEmpty()) {
1:af1c18c:             return null;
1:af1c18c:         }
1:af1c18c: 
1:af1c18c:         if (deferredCheckViolations == null) {
1:af1c18c:             // Use the backing hashtable for this base tables deferred rows
1:af1c18c:             // by checking the transaction's map of such backing hash
1:af1c18c:             // tables (one per base table conglomerate).  Use it if it
1:af1c18c:             // exists, else make a new one.
1:af1c18c: 
1:f6d02c9:             final HashMap<UUID, ValidationInfo> hashTables =
1:af1c18c:                     lcc.getDeferredHashTables();
1:f6d02c9:             final CheckInfo vi = (CheckInfo) hashTables.get(basetableId);
1:af1c18c: 
1:af1c18c:             if (vi == null) {
1:af1c18c:                 // size 1 below: the row location in the target table of the
1:af1c18c:                 // offending row
1:af1c18c:                 deferredCheckViolations =
1:af1c18c:                         makeDeferredHashTable(lcc.getTransactionExecute(), 1);
1:4cc0287:                 CheckInfo ci = new CheckInfo(deferredCheckViolations,
1:af1c18c:                                    schemaName,
1:af1c18c:                                    tableName,
1:4cc0287:                                    violatingCheckConstraints);
1:f6d02c9:                 hashTables.put(basetableId, ci);
1:4cc0287:                 result[0] = ci;
1:4cc0287:             } else {
1:af1c18c:                 vi.addCulprits(violatingCheckConstraints);
1:af1c18c:                 deferredCheckViolations = vi.infoRows;
1:4cc0287:                 result[0] = vi;
1:af1c18c:             }
1:af1c18c:         }
1:af1c18c: 
1:af1c18c:         final DataValueDescriptor[] hashRowArray = new DataValueDescriptor[1];
1:af1c18c:         hashRowArray[0] = new SQLRef(offendingRow).cloneValue(true);
1:af1c18c:         deferredCheckViolations.putRow(true, hashRowArray, null);
1:af1c18c: 
1:af1c18c:         return deferredCheckViolations;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c: 
1:4cc0287:     public static Enumeration<Object> getDeferredCheckConstraintLocations(
1:4cc0287:             Activation activation,
1:f6d02c9:             UUID validatingBaseTableUUID) throws StandardException {
1:4cc0287: 
1:4cc0287:         CheckInfo ci = (DeferredConstraintsMemory.CheckInfo)activation.
1:4cc0287:                 getLanguageConnectionContext().
1:f6d02c9:                 getDeferredHashTables().get( validatingBaseTableUUID );
1:4cc0287:         return ci.infoRows.elements();
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     /**
1:4cc0287:      * Make note of a violated foreign key constraint, i.e. the referenced
1:4cc0287:      * key is not present
1:4cc0287:      *
1:4cc0287:      * @param lcc the language connection context
1:4cc0287:      * @param deferredRowsHashTable cached client copy
1:4cc0287:      * @param fkId the UUID of the foreign key constraint
1:4cc0287:      * @param indexRow the row in the supporting index which contains
1:4cc0287:      *        the key which is not present in the referenced index.
1:4cc0287:      * @param schemaName the schema of the table
1:4cc0287:      * @param tableName the table being modified that has a FK.
1:4cc0287:      * @return value to cache
1:4cc0287:      * @throws StandardException
1:4cc0287:      */
1:4cc0287:     public static BackingStoreHashtable rememberFKViolation(
1:4cc0287:             final LanguageConnectionContext lcc,
1:4cc0287:                   BackingStoreHashtable deferredRowsHashTable,
1:4cc0287:             final UUID fkId,
1:4cc0287:             final DataValueDescriptor[] indexRow,
1:4cc0287:             String schemaName,
1:4cc0287:             String tableName) throws StandardException {
1:4cc0287: 
1:4cc0287:         if (deferredRowsHashTable == null) {
1:4cc0287:             // Use the backing hashtable for this index's deferred rows
1:4cc0287:             // by checking the transaction's map of such backing hash
1:4cc0287:             // tables (one per index conglomerate).  Use it if it
1:4cc0287:             // exists, else make a new one.
1:4cc0287: 
1:f6d02c9:             final HashMap<UUID, ValidationInfo> hashTables =
1:4cc0287:                 lcc.getDeferredHashTables();
1:f6d02c9:             final ValidationInfo vi = hashTables.get(fkId);
1:4cc0287: 
1:4cc0287:             if (vi == null) {
1:4cc0287:                 deferredRowsHashTable = makeDeferredHashTable(
1:4cc0287:                     lcc.getTransactionExecute(), indexRow.length);
1:4cc0287: 
1:4cc0287:                 hashTables.put(
1:f6d02c9:                     fkId,
1:f6d02c9:                     new ForeignKeyInfo(deferredRowsHashTable, fkId,
1:4cc0287:                                        schemaName, tableName));
1:4cc0287:             } else {
1:4cc0287:                 deferredRowsHashTable = vi.infoRows;
1:4cc0287:             }
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         DataValueDescriptor[] hashRowArray =
1:4cc0287:             new DataValueDescriptor[indexRow.length];
1:4cc0287:         System.arraycopy(indexRow, 0, hashRowArray, 0, indexRow.length);
1:4cc0287:         deferredRowsHashTable.putRow(true, hashRowArray, null);
1:4cc0287: 
1:4cc0287:         return deferredRowsHashTable;
1:4cc0287:     }
1:4cc0287: 
1:af1c18c:     private static BackingStoreHashtable makeDeferredHashTable(
2:af1c18c:             final TransactionController tc,
2:af1c18c:             final int cols) throws StandardException {
1:af1c18c: 
1:af1c18c:         // key: all columns (these are index rows, or a row containing a
1:af1c18c:         // row location)
2:af1c18c:         final int[] keyCols = new int[cols];
1:af1c18c: 
2:af1c18c:         for (int i = 0; i < cols; i++) {
2:af1c18c:             keyCols[i] = i;
1:4cc0287:         }
1:af1c18c: 
2:af1c18c:         return new BackingStoreHashtable(
2:af1c18c:                 tc,
3:af1c18c:                 null,
2:af1c18c:                 keyCols,
2:af1c18c:                 true, // remove duplicates: no need for more copies:
2:af1c18c:                       // one is enough to know what to look for on commit
2:af1c18c:                 -1,
3:af1c18c:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
2:af1c18c:                 HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
1:af1c18c:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
3:af1c18c:                 false,
2:af1c18c:                 false);
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     public static void compressOrTruncate(
1:4cc0287:             LanguageConnectionContext lcc,
1:4cc0287:             UUID tableId,
1:4cc0287:             String tableName) throws StandardException {
1:4cc0287: 
1:f6d02c9:         final HashMap<UUID, DeferredConstraintsMemory.ValidationInfo> vis =
1:4cc0287:                 lcc.getDeferredHashTables();
1:4cc0287:         final TableDescriptor td =
1:4cc0287:                 lcc.getDataDictionary().getTableDescriptor(tableId);
1:4cc0287:         final DeferredConstraintsMemory.ValidationInfo vi =
1:f6d02c9:                 vis.get( tableId );
1:4cc0287: 
1:4cc0287:         if (td == null) {
1:4cc0287:             throw StandardException.newException(
1:4cc0287:                     SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION, tableName);
1:4cc0287:         }
1:4cc0287: 
2:4cc0287:         if (vi != null &&
1:4cc0287:                 vi instanceof DeferredConstraintsMemory.CheckInfo) {
1:4cc0287:             // We can not use row locations when re-visiting offending
1:4cc0287:             // rows in this table, since we are truncating or compressing.
1:4cc0287:             ((DeferredConstraintsMemory.CheckInfo)vi).
1:4cc0287:                     setInvalidatedRowLocations();
1:4cc0287:         }
1:4cc0287:     }
1:4cc0287: 
1:af1c18c:     /**
1:af1c18c:      * Class hierarchy carrying the information we need to validate
1:af1c18c:      * some deferred constraint. For unique and primary key constraints, we
1:af1c18c:      * only need the index row. For check constraints we need the target table
1:af1c18c:      * name, schema name and some other info also.
1:af1c18c:      */
1:af1c18c:     abstract public static class ValidationInfo {
1:af1c18c:         public final BackingStoreHashtable infoRows;
1:4cc0287: 
1:af1c18c:         public ValidationInfo(final BackingStoreHashtable infoRows) {
1:af1c18c:             this.infoRows = infoRows;
1:af1c18c:         }
1:4cc0287: 
1:4cc0287:         public abstract void possiblyValidateOnReturn(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 SQLSessionContext nested,
1:4cc0287:                 SQLSessionContext caller) throws StandardException;
1:4cc0287: 
1:4cc0287:         public abstract void validateConstraint(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 UUID constraintId,
1:4cc0287:                 boolean rollbackOnError) throws StandardException;
1:af1c18c:     }
1:4cc0287: 
1:af1c18c:     /**
1:af1c18c:      * Info needed for unique and primary key constraints
1:af1c18c:      */
1:4cc0287:     private static class UniquePkInfo extends ValidationInfo {
1:f6d02c9:         private final UUID constraintId;
1:4cc0287: 
1:f6d02c9:         public UniquePkInfo(BackingStoreHashtable infoRows, UUID constraintId) {
1:af1c18c:             super(infoRows);
1:f6d02c9:             this.constraintId = constraintId;
1:af1c18c:         }
1:4cc0287: 
1:f6d02c9:         @Override
1:4cc0287:         public final void possiblyValidateOnReturn(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 SQLSessionContext nested,
1:4cc0287:                 SQLSessionContext caller) throws StandardException {
1:4cc0287: 
1:f6d02c9:                 if (lcc.isEffectivelyDeferred(caller, constraintId)) {
1:4cc0287:                     // the constraint is also deferred in the calling context
1:4cc0287:                     return;
1:4cc0287:                 }
1:4cc0287: 
1:f6d02c9:                 validateUniquePK(lcc, infoRows, true);
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         /**
1:4cc0287:          * Validate one primary key or unique constraint
1:4cc0287:          *
1:4cc0287:          * @param lcc       The language connection context
1:4cc0287:          * @param constraintId Not used by this constraint type
1:4cc0287:          * @param rollbackOnError {@code true} if we should roll back the
1:4cc0287:          *                  transaction if we see a violation of the constraint
1:4cc0287:          * @throws StandardException
1:4cc0287:          */
1:f6d02c9:         @Override
1:4cc0287:         public final void validateConstraint(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 UUID constraintId,
1:4cc0287:                 boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:4cc0287:             validateUniquePK(
1:f6d02c9:                     lcc, this.infoRows, rollbackOnError);
1:4cc0287:         }
1:4cc0287: 
1:f6d02c9:         private void validateUniquePK(
1:4cc0287:                 final LanguageConnectionContext lcc,
1:4cc0287:                 final BackingStoreHashtable ht,
1:4cc0287:                 final boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:4cc0287:             final TransactionController tc = lcc.getTransactionExecute();
1:4cc0287:             final Enumeration<?> e = ht.elements();
1:4cc0287: 
1:f6d02c9:             DataDictionary dd = lcc.getDataDictionary();
1:f6d02c9:             KeyConstraintDescriptor cd = (KeyConstraintDescriptor)
1:f6d02c9:                     dd.getConstraintDescriptor(constraintId);
1:f6d02c9: 
1:f6d02c9:             if (cd == null) {
1:f6d02c9:                 // Constraint dropped, nothing to do.
1:f6d02c9:                 return;
1:f6d02c9:             }
1:f6d02c9: 
1:f6d02c9:             long indexCID = cd.getIndexConglomerateDescriptor(dd)
1:f6d02c9:                               .getConglomerateNumber();
1:f6d02c9: 
1:4cc0287:             while (e.hasMoreElements()) {
1:4cc0287:                 final DataValueDescriptor[] key =
1:4cc0287:                         (DataValueDescriptor[])e.nextElement();
1:4cc0287: 
1:4cc0287:                 // FIXME: This is not very efficient: we could sort the rows in
1:4cc0287:                 // the hash table, and then check all rows using a single scan.
1:4cc0287:                 ScanController indexSC = null;
1:4cc0287:                 boolean sawException = false;
1:4cc0287: 
1:4cc0287:                 try {
1:4cc0287:                     indexSC = tc.openScan(
1:4cc0287:                         indexCID,
1:4cc0287:                         false,
1:4cc0287:                         0, // read only
1:4cc0287:                         TransactionController.MODE_RECORD,
1:4cc0287:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:4cc0287:                         (FormatableBitSet)null, // retrieve all fields
1:4cc0287:                         key,
1:4cc0287:                         ScanController.GE, // startSearchOp
1:4cc0287:                         null,
1:4cc0287:                         key,
1:4cc0287:                         ScanController.GT);
1:4cc0287: 
1:4cc0287:                     if (indexSC.next()) {
1:4cc0287:                         if (indexSC.next()) {
1:4cc0287:                             // two matching rows found, constraint violated
1:4cc0287:                             throw StandardException.newException(
1:4cc0287:                                 rollbackOnError ?
1:4cc0287:                                 SQLState.
1:4cc0287:                                     LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T :
1:4cc0287:                                 SQLState.
1:4cc0287:                                     LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_S,
1:f6d02c9:                                 cd.getConstraintName(),
1:f6d02c9:                                 cd.getTableDescriptor().getName());
1:4cc0287:                         } // else exactly one row contains key: OK
1:4cc0287:                     } else {
1:4cc0287:                         // No rows contain key: OK, must have been deleted later
1:4cc0287:                         // in transaction, or we got here due to pessimistic
1:4cc0287:                         // assumption on a timeout while checking on the insert.
1:4cc0287:                     }
1:4cc0287:                 } catch (StandardException se) {
1:4cc0287:                     sawException = true;
1:4cc0287:                     throw se;
1:4cc0287:                 } finally {
1:4cc0287:                     // Clean up resource usage
1:4cc0287:                     try {
1:4cc0287:                         if (indexSC != null) {
1:4cc0287:                             indexSC.close();
1:4cc0287:                         }
1:4cc0287:                     } catch (StandardException ie) {
1:4cc0287:                         if (!sawException) {
1:4cc0287:                             throw ie;
1:4cc0287:                         } // else: can't let it shadow preceding exception
1:4cc0287:                     }
1:4cc0287:                 }
1:4cc0287:             }
1:af1c18c:         }
1:af1c18c:     }
1:4cc0287: 
1:4cc0287:     /**
1:af1c18c:      * Info needed for check constraints
1:4cc0287:      */
1:af1c18c:     public static class CheckInfo extends ValidationInfo {
1:af1c18c:         final private String schemaName;
1:af1c18c:         final private String tableName;
1:4cc0287: 
1:af1c18c:         private List<UUID> culprits; // constraints that were violated
1:af1c18c:                                      // for this table so far
1:af1c18c:         private boolean invalidatedDueToCompress;
1:4cc0287: 
1:af1c18c:         public CheckInfo(
1:af1c18c:                 final BackingStoreHashtable infoRows,
1:af1c18c:                 final String schemaName,
1:af1c18c:                 final String tableName,
1:af1c18c:                 final List<UUID> culprits) {
1:4cc0287: 
1:af1c18c:             super(infoRows);
1:af1c18c:             this.schemaName = schemaName;
1:af1c18c:             this.tableName = tableName;
1:af1c18c:             this.culprits = new ArrayList<UUID>(culprits);
1:4cc0287:         }
1:4cc0287: 
1:af1c18c:         public void setInvalidatedRowLocations() {
1:af1c18c:             invalidatedDueToCompress = true;
1:4cc0287:         }
1:4cc0287: 
1:af1c18c:         public boolean isInvalidated() {
1:af1c18c:             return invalidatedDueToCompress;
1:af1c18c:         }
1:4cc0287: 
1:af1c18c:         public void addCulprits(List<UUID> newCulprits) {
1:af1c18c:             final Set<UUID> old = new HashSet<UUID>(culprits);
1:af1c18c:             old.addAll(newCulprits);
1:af1c18c:             culprits = new ArrayList<UUID>(old);
1:af1c18c:         }
1:4cc0287: 
1:af1c18c:         public List<UUID> getCulprints() {
1:af1c18c:             return culprits;
1:4cc0287:         }
1:4cc0287: 
1:f6d02c9:         @Override
1:4cc0287:         public void possiblyValidateOnReturn(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 SQLSessionContext nested,
1:4cc0287:                 SQLSessionContext caller) throws StandardException {
1:4cc0287: 
1:4cc0287:             // check if any of the constraints involved is immediate on
1:4cc0287:             // the outside
1:4cc0287:             boolean allEffectivelyDeferred = true;
1:4cc0287: 
1:4cc0287:             for (UUID uid : getCulprints()) {
1:4cc0287:                 if (!lcc.isEffectivelyDeferred(caller, uid) &&
1:4cc0287:                         lcc.isEffectivelyDeferred(nested, uid)) {
1:4cc0287: 
1:4cc0287:                     // at least one check constraint changed back
1:4cc0287:                     // from being deferred to immediate, so check
1:4cc0287:                     // all immediates
1:4cc0287: 
1:4cc0287:                     // FIXME: could be optimized if we knew
1:4cc0287:                     // exactly which constraints failed under the
1:4cc0287:                     // deferred regime: that might save us from
1:4cc0287:                     // checking in a few cases.
1:4cc0287:                     allEffectivelyDeferred = false;
1:4cc0287:                     break;
1:4cc0287:                 }
1:4cc0287:             }
1:4cc0287: 
1:4cc0287:             if (allEffectivelyDeferred) {
1:4cc0287:                 return;
1:4cc0287:             }
1:4cc0287: 
1:f6d02c9:             validateCheck(lcc, null, true);
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         /**
1:4cc0287:          * Validate one or more CHECK constraints on a table.
1:4cc0287:          * <p>
1:4cc0287:          * Implementation note: We remember violations for a row by storing its
1:4cc0287:          * row location in a disk based hash table, similar to what we do for
1:4cc0287:          * the index location for primary key and unique constraints. As far as
1:4cc0287:          * which constraints caused which violations, constraints are only
1:4cc0287:          * presently remembered as having caused "one or more violations",
1:4cc0287:          * i.e. for any violating row, we do not know at checking time exactly
1:4cc0287:          * which constraint caused a problem for that exact row. So, for any
1:4cc0287:          * given constraint which was violated in the transaction we visit all
1:4cc0287:          * rows which had one or more violations and check again. This could be
1:4cc0287:          * improved upon by remembering for each violating row the exact set of
1:4cc0287:          * constraint(s) that saw a violation. Still, this is much faster than
1:4cc0287:          * a full table scan in most use cases.  We use a special internal
1:4cc0287:          * query option to achieve this.  The row locations may not be usable
1:4cc0287:          * if Derby does a compress or otherwise makes them invalid. In that
1:4cc0287:          * case we resort to a full table scan.</p>
1:4cc0287:          * @see ValidateCheckConstraintResultSet
1:4cc0287:          *
1:4cc0287:          * @param lcc          The language connection context
1:4cc0287:          * @param constraintId If not {@code null}, check only for this
1:4cc0287:          *                     constraint.  This is used when switching mode to
1:4cc0287:          *                     immediate.  If {@code null}, we check all check
1:4cc0287:          *                     constraints, i.e.  at commit or if we have {@code
1:4cc0287:          *                     SET CONSTRAINT ALL IMMEDIATE}.
1:4cc0287:          * @param rollbackOnError If {@code true} and a violation occurs, throw
1:4cc0287:          *                     and exception that will cause rollback.
1:4cc0287:          * @throws StandardException
1:4cc0287:          *                     Default error policy
1:4cc0287:          */
1:f6d02c9:         @Override
1:4cc0287:         public final void validateConstraint(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 UUID constraintId,
1:4cc0287:                 boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:f6d02c9:             validateCheck(lcc, constraintId, rollbackOnError);
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         private void validateCheck(
1:4cc0287:                 final LanguageConnectionContext lcc,
1:4cc0287:                 final UUID constraintId,
1:4cc0287:                 final boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:4cc0287:             final TransactionController tc = lcc.getTransactionExecute();
1:4cc0287:             final DataDictionary dd = lcc.getDataDictionary();
1:4cc0287:             final SchemaDescriptor sd = dd.getSchemaDescriptor(
1:4cc0287:                     schemaName, tc, true);
1:4cc0287: 
1:4cc0287:             if (sd == null) {
1:f6d02c9:                 // Schema dropped, nothing to do
1:f6d02c9:                 return;
1:4cc0287:             }
1:4cc0287: 
1:4cc0287:             final TableDescriptor td = dd.getTableDescriptor(tableName, sd, tc);
1:4cc0287: 
1:4cc0287:             if (td == null) {
1:f6d02c9:                 // Nothing to do, table dropped
1:4cc0287:             } else {
1:f6d02c9:                 final String baseTableUUIDString = td.getUUID().toString();
1:4cc0287:                 for (UUID id : culprits) {
1:4cc0287:                     if (constraintId == null || constraintId.equals(id)) {
1:4cc0287:                         final ConstraintDescriptor cd =
1:4cc0287:                                 dd.getConstraintDescriptor(id);
1:f6d02c9: 
1:f6d02c9:                         if (cd == null) {
1:f6d02c9:                             // Constraint dropped, nothing to do.
1:f6d02c9:                             break;
1:f6d02c9:                         }
1:f6d02c9: 
1:4cc0287:                         final StringBuilder checkStmt = new StringBuilder();
1:4cc0287:                         checkStmt.append("SELECT 1 FROM ");
1:4cc0287:                         checkStmt.append(td.getQualifiedName());
1:4cc0287: 
1:4cc0287:                         // If a compress has happened in this transaction, we
1:4cc0287:                         // can't trust the rowLocations, so make a full table
1:4cc0287:                         // scan. If not, we optimize by using a special result
1:4cc0287:                         // set type which utilized the saved away row locations
1:4cc0287:                         // for the offending rows, so we only visit those when
1:4cc0287:                         // checking.  I.e. other rows are known to be good a
1:4cc0287:                         // priori.
1:4cc0287:                         if (!isInvalidated()) {
1:4cc0287:                             checkStmt.append(
1:4cc0287:                                " --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:4cc0287:                                "                    index=null, " +
1:4cc0287:                                "                    validateCheckConstraint=");
1:f6d02c9:                             checkStmt.append( baseTableUUIDString );
1:4cc0287:                             checkStmt.append('\n');
1:4cc0287:                         }
1:4cc0287: 
1:4cc0287:                         checkStmt.append(" WHERE NOT(");
1:4cc0287:                         checkStmt.append(cd.getConstraintText());
1:4cc0287:                         checkStmt.append(')');
1:4cc0287: 
1:4cc0287:                         BasicNoPutResultSetImpl rs = null;
1:bde481b:                         
1:4cc0287:                         final PreparedStatement ps =
1:4cc0287:                             lcc.prepareInternalStatement(
1:4cc0287:                                 lcc.getDefaultSchema(),
1:4cc0287:                                 checkStmt.toString(),
1:4cc0287:                                 true,
1:4cc0287:                                 true);
1:bde481b: 
1:bde481b:                         StatementContext statementContext = null;
1:bde481b:                         
1:4cc0287:                         try {
1:bde481b:                             statementContext =
1:bde481b:                                     lcc.pushStatementContext(true,
1:bde481b:                                             true,
1:bde481b:                                             checkStmt.toString(),
1:bde481b:                                             null,
1:bde481b:                                             false, 0L);
1:4cc0287:                             rs = (BasicNoPutResultSetImpl)ps.execute(
1:4cc0287:                                     ps.getActivation(lcc, false), false, 0L);
1:4cc0287:                             final ExecRow row = rs.getNextRowCore();
1:4cc0287: 
1:4cc0287:                             if (row != null) {
1:4cc0287:                                 //check constraint violated
1:4cc0287:                                 throw StandardException.newException(
1:4cc0287:                                    rollbackOnError ?
1:4cc0287:                                      SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_T :
1:4cc0287:                                      SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_S,
1:4cc0287:                                    cd.getConstraintName(),
1:4cc0287:                                    td.getQualifiedName(),
1:4cc0287:                                    cd.getConstraintText());
1:4cc0287:                             }
1:4cc0287:                         } finally {
1:bde481b:                             if (statementContext != null) {
1:bde481b:                                 lcc.popStatementContext(statementContext, null);
1:bde481b:                             }
1:bde481b:                             
1:4cc0287:                             if (rs != null) {
1:4cc0287:                                 try {
1:4cc0287:                                     rs.close();
1:4cc0287:                                 } catch (StandardException e) {}
1:4cc0287:                             }
1:4cc0287:                         }
1:4cc0287:                     }
1:4cc0287:                 }
1:4cc0287:             }
1:4cc0287:         }
1:4cc0287:     }
1:4cc0287: 
1:4cc0287:     private static class ForeignKeyInfo extends ValidationInfo {
1:4cc0287:         /**
1:4cc0287:          * the UUID of the foreign constraint
1:4cc0287:          */
1:4cc0287:         private final UUID fkId;
1:4cc0287: 
1:4cc0287:         final private String schemaName;
1:4cc0287:         final private String tableName;
1:4cc0287: 
1:4cc0287:         public ForeignKeyInfo(
1:4cc0287:                 final BackingStoreHashtable infoRows,
1:4cc0287:                 UUID fkId,
1:4cc0287:                 String schemaName,
1:4cc0287:                 String tableName) {
1:4cc0287: 
1:4cc0287:             super(infoRows);
1:4cc0287:             this.fkId = fkId;
1:4cc0287:             this.tableName = tableName;
1:4cc0287:             this.schemaName = schemaName;
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         public UUID getFkId() {
1:4cc0287:             return fkId;
1:4cc0287:         }
1:4cc0287: 
1:f6d02c9:         @Override
1:4cc0287:         public void possiblyValidateOnReturn(
3:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 SQLSessionContext nested,
1:4cc0287:                 SQLSessionContext caller) throws StandardException {
1:4cc0287: 
1:4cc0287:             if (lcc.isEffectivelyDeferred(caller, getFkId())) {
1:4cc0287:                 // the constraint is also deferred in the calling context
3:4cc0287:                 return;
1:4cc0287:             }
1:4cc0287: 
1:f6d02c9:             validateForeignKey(lcc, true);
1:4cc0287:         }
1:4cc0287: 
1:f6d02c9:         @Override
1:4cc0287:         public final void validateConstraint(
1:4cc0287:                 LanguageConnectionContext lcc,
1:4cc0287:                 UUID constraintId,
1:4cc0287:                 boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:f6d02c9:             validateForeignKey(lcc, rollbackOnError);
1:4cc0287: 
1:4cc0287:         }
1:4cc0287: 
1:4cc0287:         private void validateForeignKey(
1:4cc0287:             LanguageConnectionContext lcc,
1:4cc0287:             boolean rollbackOnError) throws StandardException {
1:4cc0287: 
1:4cc0287:             // First check if the offending row is still present,
1:4cc0287:             // if so, check that the referenced row exists. To do this we open
1:4cc0287:             // two index scans below.
1:4cc0287: 
1:4cc0287:             TransactionController tc = lcc.getTransactionExecute();
1:f6d02c9: 
1:f6d02c9:             DataDictionary dd = lcc.getDataDictionary();
1:4cc0287: 
1:f6d02c9:             ForeignKeyConstraintDescriptor cd =
1:f6d02c9:                 (ForeignKeyConstraintDescriptor)
1:f6d02c9:                     dd.getConstraintDescriptor(fkId);
1:f6d02c9: 
1:f6d02c9:             // If the foreign key has been dropped, there is nothing to do.
1:f6d02c9:             // See DERBY-6670
1:f6d02c9:             //
1:f6d02c9:             if (cd == null) {
1:f6d02c9:                 return;
1:f6d02c9:             }
1:f6d02c9: 
1:f6d02c9:             ReferencedKeyConstraintDescriptor rcd =
1:f6d02c9:                     cd.getReferencedConstraint();
1:f6d02c9: 
1:f6d02c9:             long[] cids = {
1:f6d02c9:                 cd.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:f6d02c9:                 rcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber()
1:f6d02c9: 
1:f6d02c9:             };
1:f6d02c9: 
1:4cc0287:             final Enumeration<?> e = infoRows.elements();
1:4cc0287: 
1:4cc0287:             while (e.hasMoreElements()) {
1:4cc0287:                 final DataValueDescriptor[] key =
1:4cc0287:                         (DataValueDescriptor[])e.nextElement();
1:4cc0287: 
1:4cc0287:                 // FIXME: This is not very efficient: we could sort the rows in
1:4cc0287:                 // the hash table, and then check all rows using a single scan.
1:4cc0287:                 ScanController indexSC = null;
1:4cc0287:                 boolean violation = false;
1:4cc0287: 
1:4cc0287:                 for (int idx = 0; idx < 2; idx++) {
1:4cc0287:                     boolean sawException = false;
1:4cc0287: 
1:4cc0287:                     try {
1:4cc0287:                         indexSC = tc.openScan(
1:4cc0287:                                 cids[idx],
1:4cc0287:                                 false,
1:4cc0287:                                 0, // read only
1:4cc0287:                                 TransactionController.MODE_RECORD,
1:4cc0287:                                 TransactionController.ISOLATION_READ_COMMITTED,
1:4cc0287:                                 (FormatableBitSet)null, // retrieve all fields
1:4cc0287:                                 key,
1:4cc0287:                                 ScanController.GE, // startSearchOp
1:4cc0287:                                 null,
1:4cc0287:                                 key,
1:4cc0287:                                 ScanController.GT);
1:4cc0287: 
1:4cc0287:                         if (idx == 0) {
1:4cc0287:                             if (indexSC.next()) {
1:4cc0287:                                 // The row with the PK still exists, so we need
1:4cc0287:                                 // to check the referenced table's index
1:4cc0287:                             } else {
1:4cc0287:                                 // No rows contain key: OK, must have been
1:4cc0287:                                 // deleted later in transaction, or we got here
1:4cc0287:                                 // due to pessimistic assumption on a timeout
1:4cc0287:                                 // while checking on the insert.  In any case,
1:4cc0287:                                 // no need to check the referenced key, so
1:4cc0287:                                 // leave.
1:4cc0287:                                 break;
1:4cc0287:                             }
1:4cc0287:                         } else {
1:4cc0287:                             if (indexSC.next()) {
1:4cc0287:                                 // We found the referenced key, all is good
1:4cc0287:                             } else {
1:4cc0287:                                 // We didn't find it and we know it is present
1:4cc0287:                                 // as a PK, so we have a violation.
1:4cc0287:                                 violation = true;
1:4cc0287:                             }
1:4cc0287:                         }
1:4cc0287:                     } catch (StandardException se) {
1:4cc0287:                         sawException = true;
1:4cc0287:                         throw se;
1:4cc0287:                     } finally {
1:4cc0287:                         // Clean up resource usage
1:4cc0287:                         try {
1:4cc0287:                             if (indexSC != null) {
1:4cc0287:                                 indexSC.close();
1:4cc0287:                             }
1:4cc0287:                         } catch (StandardException ie) {
1:4cc0287:                             if (!sawException) {
1:4cc0287:                                 throw ie;
1:4cc0287:                             } // else: can't let it shadow preceding exception
1:4cc0287:                         }
1:4cc0287:                     }
1:4cc0287:                 }
1:4cc0287: 
1:4cc0287:                 if (violation) {
1:4cc0287:                     final SchemaDescriptor sd =
1:4cc0287:                             dd.getSchemaDescriptor(schemaName, tc, true);
1:4cc0287: 
1:4cc0287:                     final TableDescriptor td  =
1:4cc0287:                             dd.getTableDescriptor(tableName, sd, tc);
1:4cc0287: 
1:4cc0287:                     final TableDescriptor rtd = rcd.getTableDescriptor();
1:4cc0287: 
1:4cc0287:                     throw StandardException.newException(
1:4cc0287:                             rollbackOnError ?
1:4cc0287:                                     SQLState.LANG_DEFERRED_FK_CONSTRAINT_T :
1:4cc0287:                                     SQLState.LANG_DEFERRED_FK_CONSTRAINT_S,
1:4cc0287:                             cd.getConstraintName(),
1:4cc0287:                             td.getQualifiedName(),
1:4cc0287:                             rcd.getConstraintName(),
1:4cc0287:                             rtd.getQualifiedName(),
1:4cc0287:                             RowUtil.toString(key));
1:4cc0287:                 }
1:4cc0287:             }
1:4cc0287:         }
1:4cc0287:     }
1:4cc0287: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:bde481b
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.StatementContext;
/////////////////////////////////////////////////////////////////////////
1:                         
1: 
1:                         StatementContext statementContext = null;
1:                         
1:                             statementContext =
1:                                     lcc.pushStatementContext(true,
1:                                             true,
1:                                             checkStmt.toString(),
1:                                             null,
1:                                             false, 0L);
/////////////////////////////////////////////////////////////////////////
1:                             if (statementContext != null) {
1:                                 lcc.popStatementContext(statementContext, null);
1:                             }
1:                             
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param constraintId the id of the unique or primary key constraint
/////////////////////////////////////////////////////////////////////////
1:             UUID constraintId,
/////////////////////////////////////////////////////////////////////////
1:             final HashMap<UUID, ValidationInfo> hashTables =
1:             final ValidationInfo vi = hashTables.get(constraintId);
1:                     constraintId,
1:                     new UniquePkInfo(deferredRowsHashTable, constraintId));
/////////////////////////////////////////////////////////////////////////
1:      * @param basetableId the id of the target table
/////////////////////////////////////////////////////////////////////////
1:             UUID  basetableId,
/////////////////////////////////////////////////////////////////////////
1:             final HashMap<UUID, ValidationInfo> hashTables =
1:             final CheckInfo vi = (CheckInfo) hashTables.get(basetableId);
/////////////////////////////////////////////////////////////////////////
1:                 hashTables.put(basetableId, ci);
/////////////////////////////////////////////////////////////////////////
1:             UUID validatingBaseTableUUID) throws StandardException {
1:                 getDeferredHashTables().get( validatingBaseTableUUID );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             final HashMap<UUID, ValidationInfo> hashTables =
1:             final ValidationInfo vi = hashTables.get(fkId);
1:                     fkId,
1:                     new ForeignKeyInfo(deferredRowsHashTable, fkId,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final HashMap<UUID, DeferredConstraintsMemory.ValidationInfo> vis =
1:                 vis.get( tableId );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         private final UUID constraintId;
1:         public UniquePkInfo(BackingStoreHashtable infoRows, UUID constraintId) {
1:             this.constraintId = constraintId;
1:         @Override
1:                 if (lcc.isEffectivelyDeferred(caller, constraintId)) {
1:                 validateUniquePK(lcc, infoRows, true);
1:         @Override
1:                     lcc, this.infoRows, rollbackOnError);
1:         private void validateUniquePK(
1:             DataDictionary dd = lcc.getDataDictionary();
1:             KeyConstraintDescriptor cd = (KeyConstraintDescriptor)
1:                     dd.getConstraintDescriptor(constraintId);
1: 
1:             if (cd == null) {
1:                 // Constraint dropped, nothing to do.
1:                 return;
1:             }
1: 
1:             long indexCID = cd.getIndexConglomerateDescriptor(dd)
1:                               .getConglomerateNumber();
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 cd.getConstraintName(),
1:                                 cd.getTableDescriptor().getName());
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             validateCheck(lcc, null, true);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:             validateCheck(lcc, constraintId, rollbackOnError);
/////////////////////////////////////////////////////////////////////////
1:                 // Schema dropped, nothing to do
1:                 return;
1:                 // Nothing to do, table dropped
1:                 final String baseTableUUIDString = td.getUUID().toString();
1: 
1:                         if (cd == null) {
1:                             // Constraint dropped, nothing to do.
1:                             break;
1:                         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                             checkStmt.append( baseTableUUIDString );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             validateForeignKey(lcc, true);
1:         @Override
1:             validateForeignKey(lcc, rollbackOnError);
/////////////////////////////////////////////////////////////////////////
1:             DataDictionary dd = lcc.getDataDictionary();
1: 
1:             ForeignKeyConstraintDescriptor cd =
1:                 (ForeignKeyConstraintDescriptor)
1:                     dd.getConstraintDescriptor(fkId);
1: 
1:             // If the foreign key has been dropped, there is nothing to do.
1:             // See DERBY-6670
1:             //
1:             if (cd == null) {
1:                 return;
1:             }
1: 
1:             ReferencedKeyConstraintDescriptor rcd =
1:                     cd.getReferencedConstraint();
1: 
1:             long[] cids = {
1:                 cd.getIndexConglomerateDescriptor(dd).getConglomerateNumber(),
1:                 rcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber()
1: 
1:             };
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
/////////////////////////////////////////////////////////////////////////
1:      * @param result OUT parameter: the allocated CheckInfo
/////////////////////////////////////////////////////////////////////////
1:             final RowLocation offendingRow,
1:             CheckInfo[] result) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:                 CheckInfo ci = new CheckInfo(deferredCheckViolations,
1:                                    violatingCheckConstraints);
0:                 hashTables.put(Long.valueOf(basetableCID), ci);
1:                 result[0] = ci;
1:                 result[0] = vi;
/////////////////////////////////////////////////////////////////////////
1:     public static Enumeration<Object> getDeferredCheckConstraintLocations(
1:             Activation activation,
0:             long validatingBaseTableCID) throws StandardException {
1: 
1:         CheckInfo ci = (DeferredConstraintsMemory.CheckInfo)activation.
1:                 getLanguageConnectionContext().
0:                 getDeferredHashTables().get(
0:                     Long.valueOf(validatingBaseTableCID));
1:         return ci.infoRows.elements();
1:     }
1: 
1:     /**
1:      * Make note of a violated foreign key constraint, i.e. the referenced
1:      * key is not present
1:      *
1:      * @param lcc the language connection context
1:      * @param deferredRowsHashTable cached client copy
0:      * @param siCID the conglomerate ID of the supporting index of the FK
0:      * @param rtCID the conglomerate id of the index of the referenced table
1:      * @param fkId the UUID of the foreign key constraint
1:      * @param indexRow the row in the supporting index which contains
1:      *        the key which is not present in the referenced index.
1:      * @param schemaName the schema of the table
1:      * @param tableName the table being modified that has a FK.
1:      * @return value to cache
1:      * @throws StandardException
1:      */
1:     public static BackingStoreHashtable rememberFKViolation(
1:             final LanguageConnectionContext lcc,
1:                   BackingStoreHashtable deferredRowsHashTable,
0:             final long siCID,
0:             final long rtCID,
1:             final UUID fkId,
1:             final DataValueDescriptor[] indexRow,
1:             String schemaName,
1:             String tableName) throws StandardException {
1: 
1:         if (deferredRowsHashTable == null) {
1:             // Use the backing hashtable for this index's deferred rows
1:             // by checking the transaction's map of such backing hash
1:             // tables (one per index conglomerate).  Use it if it
1:             // exists, else make a new one.
1: 
0:             final HashMap<Long, ValidationInfo> hashTables =
1:                 lcc.getDeferredHashTables();
0:             final ValidationInfo vi = hashTables.get(Long.valueOf(siCID));
1: 
1:             if (vi == null) {
1:                 deferredRowsHashTable = makeDeferredHashTable(
1:                     lcc.getTransactionExecute(), indexRow.length);
1: 
1:                 hashTables.put(
0:                     Long.valueOf(siCID),
0:                     new ForeignKeyInfo(deferredRowsHashTable, fkId, rtCID,
1:                                        schemaName, tableName));
1:             } else {
1:                 deferredRowsHashTable = vi.infoRows;
1:             }
1:         }
1: 
1:         DataValueDescriptor[] hashRowArray =
1:             new DataValueDescriptor[indexRow.length];
1:         System.arraycopy(indexRow, 0, hashRowArray, 0, indexRow.length);
1:         deferredRowsHashTable.putRow(true, hashRowArray, null);
1: 
1:         return deferredRowsHashTable;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         updateKey(lcc, UNDEFINED_CONGLOMERATE, indexCID);
1:     }
1: 
0:     private static void updateKey(
1:         LanguageConnectionContext lcc,
0:         long oldCID,
0:         long newCID) {
/////////////////////////////////////////////////////////////////////////
0:         final ValidationInfo ht = hashTables.remove(Long.valueOf(oldCID));
0:             hashTables.put(newCID, ht);
1:         }
0:      * updating in the memory if the underlying index is rebuilt
/////////////////////////////////////////////////////////////////////////
0:         updateKey(lcc, oldIndexCID, newIndexCID);
/////////////////////////////////////////////////////////////////////////
0:      * Update the conglomerate ids of supporting indexes, when they change,
0:      * under truncate and compress.
1:      * @param lcc       the language connection context
0:      * @param truncate  if {@code true} we are in a TRUNCATE TABLE context
0:      * @param oldCID    the old conglomerate id of a supporting index
0:      * @param newCID    the old conglomerate id of a supporting index
0:     public static void updateIndexCIDs(
1:             LanguageConnectionContext lcc,
0:             boolean truncate,
0:             long oldCID,
0:             long newCID) throws StandardException {
0:         // Handle reference to the old index conglomerate ID for
0:         // deferred constraints
0:         final HashMap<Long, ValidationInfo> vis = lcc.getDeferredHashTables();
0:         if (vis == null) {
1:             return;
0:         if (truncate) {
0:             // Invalidate any deferred constraints information based on this
0:             // index.
0:             final ValidationInfo vi =  vis.get(oldCID);
1:             if (vi != null &&
0:                     (vi instanceof UniquePkInfo ||
0:                      vi instanceof ForeignKeyInfo)) {
0:                 lcc.forgetDeferredConstraintsData(oldCID);
0:             final ValidationInfo vi =  vis.get(oldCID);
0:             if (vi != null && vi instanceof UniquePkInfo){
0:                 updateKey(lcc, oldCID, newCID);
1:             }
1:         }
0:         // Update conglomerate information for deferred foreign keys involved
0:         // with this index re-creation.
0:         for (Map.Entry<Long, ValidationInfo> e : vis.entrySet()) {
0:             final ValidationInfo vi = e.getValue();
0:             if (vi instanceof ForeignKeyInfo) {
0:                 final ForeignKeyInfo fki = (ForeignKeyInfo)vi;
0:                 if (fki.getRtCID() == oldCID) {
0:                     fki.updateRtCID(newCID);
0:                 } else if (e.getKey().longValue() == oldCID) {
0:                     updateKey(lcc, oldCID, newCID);
1: 
1:     public static void compressOrTruncate(
1:             LanguageConnectionContext lcc,
1:             UUID tableId,
1:             String tableName) throws StandardException {
1: 
0:         final HashMap<Long, DeferredConstraintsMemory.ValidationInfo> vis =
1:                 lcc.getDeferredHashTables();
1:         final TableDescriptor td =
1:                 lcc.getDataDictionary().getTableDescriptor(tableId);
1:         final DeferredConstraintsMemory.ValidationInfo vi =
0:                 vis.get(td.getHeapConglomerateId());
1: 
1:         if (td == null) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION, tableName);
1:         }
1: 
1:         if (vi != null &&
1:                 vi instanceof DeferredConstraintsMemory.CheckInfo) {
1:             // We can not use row locations when re-visiting offending
1:             // rows in this table, since we are truncating or compressing.
1:             ((DeferredConstraintsMemory.CheckInfo)vi).
1:                     setInvalidatedRowLocations();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         public abstract void possiblyValidateOnReturn(
0:                 Map.Entry<Long, ValidationInfo> e,
1:                 LanguageConnectionContext lcc,
1:                 SQLSessionContext nested,
1:                 SQLSessionContext caller) throws StandardException;
1: 
1:         public abstract void validateConstraint(
1:                 LanguageConnectionContext lcc,
0:                 long conglomerateId,
1:                 UUID constraintId,
1:                 boolean rollbackOnError) throws StandardException;
1:     private static class UniquePkInfo extends ValidationInfo {
1: 
1: 
1:         public final void possiblyValidateOnReturn(
0:                 Map.Entry<Long, ValidationInfo> e,
1:                 LanguageConnectionContext lcc,
1:                 SQLSessionContext nested,
1:                 SQLSessionContext caller) throws StandardException {
1: 
0:                 final long indexCID = e.getKey().longValue();
1: 
0:                 if (lcc.isEffectivelyDeferred(caller, indexCID)) {
1:                     // the constraint is also deferred in the calling context
1:                     return;
1:                 }
1: 
0:                 validateUniquePK(lcc, indexCID, e.getValue().infoRows, true);
1:         }
1: 
1:         /**
1:          * Validate one primary key or unique constraint
1:          *
1:          * @param lcc       The language connection context
0:          * @param indexCID The conglomerate id of the index backing the
0:          *                 constraint
1:          * @param constraintId Not used by this constraint type
1:          * @param rollbackOnError {@code true} if we should roll back the
1:          *                  transaction if we see a violation of the constraint
1:          * @throws StandardException
1:          */
1:         public final void validateConstraint(
1:                 LanguageConnectionContext lcc,
0:                 long indexCID,
1:                 UUID constraintId,
1:                 boolean rollbackOnError) throws StandardException {
1: 
1:             validateUniquePK(
0:                     lcc, indexCID, this.infoRows, rollbackOnError);
1:         }
1: 
0:         private static void validateUniquePK(
1:                 final LanguageConnectionContext lcc,
0:                 final long indexCID,
1:                 final BackingStoreHashtable ht,
1:                 final boolean rollbackOnError) throws StandardException {
1: 
1:             final TransactionController tc = lcc.getTransactionExecute();
1:             final Enumeration<?> e = ht.elements();
1: 
1:             while (e.hasMoreElements()) {
1:                 final DataValueDescriptor[] key =
1:                         (DataValueDescriptor[])e.nextElement();
1: 
1:                 // FIXME: This is not very efficient: we could sort the rows in
1:                 // the hash table, and then check all rows using a single scan.
1:                 ScanController indexSC = null;
1:                 boolean sawException = false;
1: 
1:                 try {
1:                     indexSC = tc.openScan(
1:                         indexCID,
1:                         false,
1:                         0, // read only
1:                         TransactionController.MODE_RECORD,
1:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:                         (FormatableBitSet)null, // retrieve all fields
1:                         key,
1:                         ScanController.GE, // startSearchOp
1:                         null,
1:                         key,
1:                         ScanController.GT);
1: 
1:                     if (indexSC.next()) {
1:                         if (indexSC.next()) {
1:                             // two matching rows found, constraint violated
1:                             final DataDictionary dd = lcc.getDataDictionary();
0:                             final ConglomerateDescriptor cd =
0:                                 dd.getConglomerateDescriptor(indexCID);
0:                             final TableDescriptor td =
0:                                 dd.getTableDescriptor(cd.getTableID());
0:                             final ConstraintDescriptor conDesc =
0:                                 dd.getConstraintDescriptor(td, cd.getUUID());
1: 
1:                             throw StandardException.newException(
1:                                 rollbackOnError ?
1:                                 SQLState.
1:                                     LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T :
1:                                 SQLState.
1:                                     LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_S,
0:                                 conDesc.getConstraintName(),
0:                                 td.getName());
1:                         } // else exactly one row contains key: OK
1:                     } else {
1:                         // No rows contain key: OK, must have been deleted later
1:                         // in transaction, or we got here due to pessimistic
1:                         // assumption on a timeout while checking on the insert.
1:                     }
1:                 } catch (StandardException se) {
1:                     sawException = true;
1:                     throw se;
1:                 } finally {
1:                     // Clean up resource usage
1:                     try {
1:                         if (indexSC != null) {
1:                             indexSC.close();
1:                         }
1:                     } catch (StandardException ie) {
1:                         if (!sawException) {
1:                             throw ie;
1:                         } // else: can't let it shadow preceding exception
1:                     }
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         public void possiblyValidateOnReturn(
0:                 Map.Entry<Long, ValidationInfo> e,
1:                 LanguageConnectionContext lcc,
1:                 SQLSessionContext nested,
1:                 SQLSessionContext caller) throws StandardException {
1: 
0:             final long baseTableCID = e.getKey().longValue();
1: 
1:             // check if any of the constraints involved is immediate on
1:             // the outside
1:             boolean allEffectivelyDeferred = true;
1: 
1:             for (UUID uid : getCulprints()) {
1:                 if (!lcc.isEffectivelyDeferred(caller, uid) &&
1:                         lcc.isEffectivelyDeferred(nested, uid)) {
1: 
1:                     // at least one check constraint changed back
1:                     // from being deferred to immediate, so check
1:                     // all immediates
1: 
1:                     // FIXME: could be optimized if we knew
1:                     // exactly which constraints failed under the
1:                     // deferred regime: that might save us from
1:                     // checking in a few cases.
1:                     allEffectivelyDeferred = false;
1:                     break;
1:                 }
1:             }
1: 
1:             if (allEffectivelyDeferred) {
1:                 return;
1:             }
1: 
0:             validateCheck(lcc, baseTableCID, null, true);
1:         }
1: 
1:         /**
1:          * Validate one or more CHECK constraints on a table.
1:          * <p>
1:          * Implementation note: We remember violations for a row by storing its
1:          * row location in a disk based hash table, similar to what we do for
1:          * the index location for primary key and unique constraints. As far as
1:          * which constraints caused which violations, constraints are only
1:          * presently remembered as having caused "one or more violations",
1:          * i.e. for any violating row, we do not know at checking time exactly
1:          * which constraint caused a problem for that exact row. So, for any
1:          * given constraint which was violated in the transaction we visit all
1:          * rows which had one or more violations and check again. This could be
1:          * improved upon by remembering for each violating row the exact set of
1:          * constraint(s) that saw a violation. Still, this is much faster than
1:          * a full table scan in most use cases.  We use a special internal
1:          * query option to achieve this.  The row locations may not be usable
1:          * if Derby does a compress or otherwise makes them invalid. In that
1:          * case we resort to a full table scan.</p>
1:          * @see ValidateCheckConstraintResultSet
1:          *
1:          * @param lcc          The language connection context
0:          * @param baseTableCID The conglomerate id of the base table for which
0:          *                     we want to validate check constraints.
1:          * @param constraintId If not {@code null}, check only for this
1:          *                     constraint.  This is used when switching mode to
1:          *                     immediate.  If {@code null}, we check all check
1:          *                     constraints, i.e.  at commit or if we have {@code
1:          *                     SET CONSTRAINT ALL IMMEDIATE}.
1:          * @param rollbackOnError If {@code true} and a violation occurs, throw
1:          *                     and exception that will cause rollback.
1:          * @throws StandardException
1:          *                     Default error policy
1:          */
1:         public final void validateConstraint(
1:                 LanguageConnectionContext lcc,
0:                 long baseTableCID,
1:                 UUID constraintId,
1:                 boolean rollbackOnError) throws StandardException {
1: 
0:             validateCheck(lcc, baseTableCID, constraintId, rollbackOnError);
1:         }
1: 
1:         private void validateCheck(
1:                 final LanguageConnectionContext lcc,
0:                 final long baseTableCID,
1:                 final UUID constraintId,
1:                 final boolean rollbackOnError) throws StandardException {
1: 
1:             final TransactionController tc = lcc.getTransactionExecute();
0:             final DataDictionary dd = lcc.getDataDictionary();
1:             final SchemaDescriptor sd = dd.getSchemaDescriptor(
1:                     schemaName, tc, true);
1: 
1:             if (sd == null) {
0:                 if (SanityManager.DEBUG) {
0:                     // dropping of a schema shouold drop any tables and their
0:                     // constraints, which in turn should drop any deferred
0:                     // constraint memory of them.
0:                     SanityManager.NOTREACHED();
1:                 } else {
1:                     return;
1:                 }
1:             }
1: 
1:             final TableDescriptor td = dd.getTableDescriptor(tableName, sd, tc);
1: 
1:             if (td == null) {
0:                 if (SanityManager.DEBUG) {
0:                     // dropping of a table shouold drop any
0:                     // constraints, which in turn should drop any deferred
0:                     // constraint memory of them. Renaming of a table with
0:                     // constrants is not presently allowed. FIXME: use UUID
0:                     // instead of string here, more stable reference.
0:                     SanityManager.NOTREACHED();
1:                 }
1:             } else {
1:                 for (UUID id : culprits) {
1:                     if (constraintId == null || constraintId.equals(id)) {
1:                         final ConstraintDescriptor cd =
1:                                 dd.getConstraintDescriptor(id);
1:                         final StringBuilder checkStmt = new StringBuilder();
1:                         checkStmt.append("SELECT 1 FROM ");
1:                         checkStmt.append(td.getQualifiedName());
1: 
1:                         // If a compress has happened in this transaction, we
1:                         // can't trust the rowLocations, so make a full table
1:                         // scan. If not, we optimize by using a special result
1:                         // set type which utilized the saved away row locations
1:                         // for the offending rows, so we only visit those when
1:                         // checking.  I.e. other rows are known to be good a
1:                         // priori.
1:                         if (!isInvalidated()) {
1:                             checkStmt.append(
1:                                " --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
1:                                "                    index=null, " +
1:                                "                    validateCheckConstraint=");
0:                             checkStmt.append(Long.toString(baseTableCID));
1:                             checkStmt.append('\n');
1:                         }
1: 
1:                         checkStmt.append(" WHERE NOT(");
1:                         checkStmt.append(cd.getConstraintText());
1:                         checkStmt.append(')');
1: 
1:                         BasicNoPutResultSetImpl rs = null;
1:                         final PreparedStatement ps =
1:                             lcc.prepareInternalStatement(
1:                                 lcc.getDefaultSchema(),
1:                                 checkStmt.toString(),
1:                                 true,
1:                                 true);
1:                         try {
1:                             rs = (BasicNoPutResultSetImpl)ps.execute(
1:                                     ps.getActivation(lcc, false), false, 0L);
1:                             final ExecRow row = rs.getNextRowCore();
1: 
1:                             if (row != null) {
1:                                 //check constraint violated
1: 
1:                                 throw StandardException.newException(
1:                                    rollbackOnError ?
1:                                      SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_T :
1:                                      SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_S,
1:                                    cd.getConstraintName(),
1:                                    td.getQualifiedName(),
1:                                    cd.getConstraintText());
1:                             }
1:                         } finally {
1:                             if (rs != null) {
1:                                 try {
1:                                     rs.close();
1:                                 } catch (StandardException e) {}
1:                             }
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private static class ForeignKeyInfo extends ValidationInfo {
1:         /**
1:          * the UUID of the foreign constraint
1:          */
1:         private final UUID fkId;
1: 
1:         /**
0:          * The conglomerate id of the index of the referenced table
1:          */
0:         private long rtCID;
1: 
1:         final private String schemaName;
1:         final private String tableName;
1: 
1:         public ForeignKeyInfo(
1:                 final BackingStoreHashtable infoRows,
1:                 UUID fkId,
0:                 long rtCID,
1:                 String schemaName,
1:                 String tableName) {
1: 
1:             super(infoRows);
1:             this.fkId = fkId;
0:             this.rtCID = rtCID;
1:             this.tableName = tableName;
1:             this.schemaName = schemaName;
1:         }
1: 
1:         public UUID getFkId() {
1:             return fkId;
1:         }
1: 
0:         public void updateRtCID(long rtCID) {
0:             this.rtCID = rtCID;
1:         }
1: 
0:         public long getRtCID() {
0:             return rtCID;
1:         }
1: 
1:         public void possiblyValidateOnReturn(
0:                 Map.Entry<Long, ValidationInfo> e,
1:                 LanguageConnectionContext lcc,
1:                 SQLSessionContext nested,
1:                 SQLSessionContext caller) throws StandardException {
1: 
1:             if (lcc.isEffectivelyDeferred(caller, getFkId())) {
1:                 // the constraint is also deferred in the calling context
1:                 return;
1:             }
1: 
0:             final long indexCID = e.getKey().longValue();
0:             validateForeignKey(lcc, indexCID, true);
1:         }
1: 
1:         public final void validateConstraint(
1:                 LanguageConnectionContext lcc,
0:                 long conglomerateId,
1:                 UUID constraintId,
1:                 boolean rollbackOnError) throws StandardException {
1: 
0:             validateForeignKey(lcc, conglomerateId, rollbackOnError);
1: 
1:         }
1: 
1:         private void validateForeignKey(
1:             LanguageConnectionContext lcc,
0:             long indexCID,
1:             boolean rollbackOnError) throws StandardException {
1: 
1:             // First check if the offending row is still present,
1:             // if so, check that the referenced row exists. To do this we open
1:             // two index scans below.
1: 
1:             TransactionController tc = lcc.getTransactionExecute();
1: 
1:             final Enumeration<?> e = infoRows.elements();
1: 
1:             while (e.hasMoreElements()) {
1:                 final DataValueDescriptor[] key =
1:                         (DataValueDescriptor[])e.nextElement();
1: 
1:                 // FIXME: This is not very efficient: we could sort the rows in
1:                 // the hash table, and then check all rows using a single scan.
1:                 ScanController indexSC = null;
1:                 boolean violation = false;
1: 
0:                 long[] cids = new long[]{indexCID, getRtCID()};
1: 
1:                 for (int idx = 0; idx < 2; idx++) {
1:                     boolean sawException = false;
1: 
1:                     try {
1:                         indexSC = tc.openScan(
1:                                 cids[idx],
1:                                 false,
1:                                 0, // read only
1:                                 TransactionController.MODE_RECORD,
1:                                 TransactionController.ISOLATION_READ_COMMITTED,
1:                                 (FormatableBitSet)null, // retrieve all fields
1:                                 key,
1:                                 ScanController.GE, // startSearchOp
1:                                 null,
1:                                 key,
1:                                 ScanController.GT);
1: 
1:                         if (idx == 0) {
1:                             if (indexSC.next()) {
1:                                 // The row with the PK still exists, so we need
1:                                 // to check the referenced table's index
1:                             } else {
1:                                 // No rows contain key: OK, must have been
1:                                 // deleted later in transaction, or we got here
1:                                 // due to pessimistic assumption on a timeout
1:                                 // while checking on the insert.  In any case,
1:                                 // no need to check the referenced key, so
1:                                 // leave.
1:                                 break;
1:                             }
1:                         } else {
1:                             if (indexSC.next()) {
1:                                 // We found the referenced key, all is good
1:                             } else {
1:                                 // We didn't find it and we know it is present
1:                                 // as a PK, so we have a violation.
1:                                 violation = true;
1:                             }
1:                         }
1:                     } catch (StandardException se) {
1:                         sawException = true;
1:                         throw se;
1:                     } finally {
1:                         // Clean up resource usage
1:                         try {
1:                             if (indexSC != null) {
1:                                 indexSC.close();
1:                             }
1:                         } catch (StandardException ie) {
1:                             if (!sawException) {
1:                                 throw ie;
1:                             } // else: can't let it shadow preceding exception
1:                         }
1:                     }
1:                 }
1: 
1:                 if (violation) {
0:                     final DataDictionary dd = lcc.getDataDictionary();
1: 
1:                     final SchemaDescriptor sd =
1:                             dd.getSchemaDescriptor(schemaName, tc, true);
1: 
1:                     final TableDescriptor td  =
1:                             dd.getTableDescriptor(tableName, sd, tc);
1: 
0:                     final ForeignKeyConstraintDescriptor cd =
0:                             (ForeignKeyConstraintDescriptor)dd.
0:                                     getConstraintDescriptor(getFkId());
1: 
0:                     final ConstraintDescriptor rcd = dd.getConstraintDescriptor(
0:                             cd.getReferencedConstraintId());
1: 
1:                     final TableDescriptor rtd = rcd.getTableDescriptor();
1: 
1:                     throw StandardException.newException(
1:                             rollbackOnError ?
1:                                     SQLState.LANG_DEFERRED_FK_CONSTRAINT_T :
1:                                     SQLState.LANG_DEFERRED_FK_CONSTRAINT_S,
1:                             cd.getConstraintName(),
1:                             td.getQualifiedName(),
1:                             rcd.getConstraintName(),
1:                             rtd.getQualifiedName(),
1:                             RowUtil.toString(key));
1:                 }
1:             }
1:         }
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.DeferredConstraintsMemory
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.Set;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.SQLRef;
1: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derby.shared.common.sanity.SanityManager;
1: 
1: /**
1:  * This class provides support for deferrable constraints. When the constraint
1:  * mode is deferred, any violation of the constraint should not be flagged
1:  * until the constraint mode is switched back to immediate, which may happen by
1:  * explicitly setting the constraint mode to immediate, or implicitly at commit
1:  * time. It may also happen implicitly when returning from a stored procedure
1:  * if the constraint mode is immediate in the caller context.
1:  * <p>
1:  * The approach taken in Derby to support deferred constraints is to make a note
1:  * when the violation happens (at insert or update time), and then remember that
1:  * violation until the mode switches back as described above.  We note exactly
1:  * which rows cause violations, so checking can happen as quickly as possible
1:  * when we get there. The core mechanism used to remember the violations as well
1:  * as the deferred checking is embodied in this class.
1:  *
1:  */
1: final public class DeferredConstraintsMemory
1: {
1:     /**
0:      * For unique and primary key constraints, sometimes we need to save
0:      * duplicate rows before we know the id of the constraint index, so we
0:      * assign the duplicates row a temporary constraint id
0:      * (UNDEFINED_CONGLOMERATE) and fix it up later.
0:      * @see #associateDuplicatesWithConglomerate
1:      */
0:     public final static long UNDEFINED_CONGLOMERATE = -1;
1: 
1:     /**
1:      * Save the contents of an constraint supporting index row in a
1:      * hash table (which may spill to disk) for later checking,
1:      * typically on transaction commit, or upon request.
1:      *
1:      * @param lcc       the language connection context
1:      * @param deferredRowsHashTable
1:      *                  client cached value
0:      * @param indexCID  the identity of the index conglomerate which supports
0:      *                  the deferred constraint
1:      * @param insertRow the duplicate row to be saved in the hash table
1:      *                  for later checking
1:      * @return the hash table (for caching by client to minimize lookups)
1:      * @throws StandardException standard error policy
1:      */
1:     public static BackingStoreHashtable rememberDuplicate(
1:             final LanguageConnectionContext lcc,
1:                   BackingStoreHashtable deferredRowsHashTable,
0:             final long indexCID,
1:             final DataValueDescriptor[] insertRow) throws StandardException {
1: 
1:         // Don't copy the RowLocation, we don't need it:
1:         final int keyLength = insertRow.length -1 ;
1: 
1:         if (deferredRowsHashTable == null) {
1:             // Use the backing hashtable for this index's deferred rows
1:             // by checking the transaction's map of such backing hash
1:             // tables (one per index conglomerate).  Use it if it
1:             // exists, else make a new one.
1: 
0:             final HashMap<Long, ValidationInfo> hashTables =
1:                 lcc.getDeferredHashTables();
0:             final ValidationInfo vi = hashTables.get(Long.valueOf(indexCID));
1: 
1:             if (vi == null) {
1:                 deferredRowsHashTable =
1:                   makeDeferredHashTable(lcc.getTransactionExecute(), keyLength);
1: 
1:                 hashTables.put(
0:                     Long.valueOf(indexCID),
0:                     new UniquePkInfo(deferredRowsHashTable));
1:             } else {
1:                 deferredRowsHashTable = vi.infoRows;
1:             }
1:         }
1: 
1:         DataValueDescriptor[] hashRowArray = new DataValueDescriptor[keyLength];
1:         System.arraycopy(insertRow, 0, hashRowArray, 0, keyLength);
1:         deferredRowsHashTable.putRow(true, hashRowArray, null);
1: 
1:         return deferredRowsHashTable;
1:     }
1: 
1:     /**
1:      * Save the row location of an offending row (one or more check constraints
1:      * were violated) in a hash table (which may spill to disk) for later
1:      * checking, typically on transaction commit, or upon request.
1:      *
1:      * The row locations are subject to invalidation, cf.
1:      * {@code CheckInfo#setInvalidatedRowLocations}.
1:      *
0:      * @param basetableCID  the identity of the base table conglomerate for
0:      *                  which we have seen a violated deferred check constraint
1:      * @param schemaName the schema of the target table
1:      * @param tableName the target table name
1:      * @param deferredCheckViolations
1:      *                  client cached value
1:      * @param lcc       the language connection context
1:      * @param violatingCheckConstraints offending constraint(s)
1:      * @param offendingRow the duplicate row to be saved in the hash table
1:      *                  for later checking
1:      * @return the hash table (for caching by client to minimize lookups)
1:      * @throws StandardException standard error policy
1:      */
1:     public static BackingStoreHashtable rememberCheckViolations(
1:             final LanguageConnectionContext lcc,
0:             final long basetableCID,
1:             final String schemaName,
1:             final String tableName,
1:                   BackingStoreHashtable deferredCheckViolations,
1:             final List<UUID> violatingCheckConstraints,
0:             final RowLocation offendingRow) throws StandardException {
1: 
1:         if (violatingCheckConstraints.isEmpty()) {
1:             return null;
1:         }
1: 
1:         if (deferredCheckViolations == null) {
1:             // Use the backing hashtable for this base tables deferred rows
1:             // by checking the transaction's map of such backing hash
1:             // tables (one per base table conglomerate).  Use it if it
1:             // exists, else make a new one.
1: 
0:             final HashMap<Long, ValidationInfo> hashTables =
1:                     lcc.getDeferredHashTables();
0:             final CheckInfo vi =
0:                     (CheckInfo)hashTables.get(Long.valueOf(basetableCID));
1: 
1:             if (vi == null) {
1:                 // size 1 below: the row location in the target table of the
1:                 // offending row
1:                 deferredCheckViolations =
1:                         makeDeferredHashTable(lcc.getTransactionExecute(), 1);
1: 
0:                 hashTables.put(Long.valueOf(basetableCID),
0:                                new CheckInfo(deferredCheckViolations,
1:                                    schemaName,
1:                                    tableName,
0:                                    violatingCheckConstraints));
1:             } else {
1:                 vi.addCulprits(violatingCheckConstraints);
1:                 deferredCheckViolations = vi.infoRows;
1:             }
1:         }
1: 
1:         final DataValueDescriptor[] hashRowArray = new DataValueDescriptor[1];
1:         hashRowArray[0] = new SQLRef(offendingRow).cloneValue(true);
1:         deferredCheckViolations.putRow(true, hashRowArray, null);
1: 
1:         return deferredCheckViolations;
1:     }
1: 
1: 
1:     /**
0:      * After having belatedly learned the identity of the conglomerate, we now
0:      * associate the conglomerate id information with the saved duplicates
0:      * memory. Used for unique and primary key constraints.
0:      * See {@link #UNDEFINED_CONGLOMERATE}.
1:      *
0:      * @param lcc language connection context
0:      * @param indexCID the id of the index conglomerate supporting the
0:      *                 deferred constraint
1:      */
0:     public static void associateDuplicatesWithConglomerate(
1:             final LanguageConnectionContext lcc,
0:             final long indexCID) {
1: 
0:         final HashMap<Long, ValidationInfo> hashTables =
1:                     lcc.getDeferredHashTables();
1: 
0:         if (hashTables == null) {
0:             return; // no duplicates recorded in this transaction
1:         }
1: 
0:         final ValidationInfo ht = hashTables.remove(
0:                 Long.valueOf(UNDEFINED_CONGLOMERATE));
1: 
0:         if (ht != null) {
0:             hashTables.put(indexCID, ht);
0:         } // else no duplicates recorded for this index
1:     }
1: 
1:     /**
0:      * The conglomerate id for an index with deferred row checking needs
0:      * updating in the memory if the underlying index is rebuilt, for example
0:      * on bulk insert for import.
1:      *
0:      * @param lcc the language connection context needed to find the
0:      *            deferred rows information if any
0:      * @param oldIndexCID the old id of the supporting index
0:      * @param newIndexCID the new id of the supporting index after recreation
1:      */
0:     public static void updateIndexCID(
1:             final LanguageConnectionContext lcc,
0:             final long oldIndexCID,
0:             final long newIndexCID) {
1: 
0:         final HashMap<Long, ValidationInfo> hashTables =
1:                     lcc.getDeferredHashTables();
1: 
0:         if (hashTables == null) {
0:             return; // no duplicates recorded in this transaction
1:         }
1: 
0:         final ValidationInfo ht = hashTables.remove(
0:                 Long.valueOf(oldIndexCID));
1: 
0:         if (ht != null) {
0:             hashTables.put(Long.valueOf(newIndexCID), ht);
1:         }
1:     }
1: 
1:     private static BackingStoreHashtable makeDeferredHashTable(
1:             final TransactionController tc,
1:             final int cols) throws StandardException {
1: 
1:         // key: all columns (these are index rows, or a row containing a
1:         // row location)
1:         final int[] keyCols = new int[cols];
1: 
1:         for (int i = 0; i < cols; i++) {
1:             keyCols[i] = i;
1:         }
1: 
1:         return new BackingStoreHashtable(
1:                 tc,
1:                 null,
1:                 keyCols,
1:                 true, // remove duplicates: no need for more copies:
1:                       // one is enough to know what to look for on commit
1:                 -1,
1:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:                 HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
1:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:                 false,
1:                 false);
1:     }
1: 
0:     private static BackingStoreHashtable makeDeferredCheck(
1:             final TransactionController tc,
1:             final int cols) throws StandardException {
1: 
0:         // key: all columns (these are index rows)
1:         final int[] keyCols = new int[cols];
1: 
1:         for (int i = 0; i < cols; i++) {
1:             keyCols[i] = i;
1:         }
1: 
1:         return new BackingStoreHashtable(
1:                 tc,
1:                 null,
1:                 keyCols,
1:                 true, // remove duplicates: no need for more copies:
1:                       // one is enough to know what to look for on commit
1:                 -1,
1:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:                 HashScanResultSet.DEFAULT_INITIAL_CAPACITY,
1:                 HashScanResultSet.DEFAULT_MAX_CAPACITY,
1:                 false,
1:                 false);
1:     }
1: 
1:     /**
0:      * Validate one primary key or unique constraint
1:      *
0:      * @param lcc       The language connection context
0:      * @param indexCID  The conglomerate id of the index backing the constraint
0:      * @param ht        Cached saved rows if any
0:      * @param rollbackOnError {@code true} if we should roll back the
0:      *                  transaction if we see a violation of the constraint
0:      * @throws StandardException
1:      */
0:     public static void validateUniquePK(
1:             final LanguageConnectionContext lcc,
0:             final long indexCID,
0:             final BackingStoreHashtable ht,
0:             final boolean rollbackOnError) throws StandardException {
1: 
0:         final TransactionController tc = lcc.getTransactionExecute();
0:         final Enumeration<?> e = ht.elements();
1: 
0:         while (e.hasMoreElements()) {
0:             final DataValueDescriptor[] key =
0:                     (DataValueDescriptor[])e.nextElement();
1: 
0:             // FIXME: This is not very efficient: we could sort the rows in the
0:             // hash table, and then check all rows using a single scan.
0:             ScanController indexSC = null;
0:             boolean sawException = false;
1: 
0:             try {
0:                 indexSC = tc.openScan(
0:                     indexCID,
1:                     false,
0:                     0, // read only
0:                     TransactionController.MODE_RECORD,
0:                     TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
0:                     (FormatableBitSet)null, // retrieve all fields
0:                     key,
0:                     ScanController.GE, // startSearchOp
1:                     null,
0:                     key,
0:                     ScanController.GT);
1: 
0:                 if (indexSC.next()) {
0:                     if (indexSC.next()) {
0:                         // two matching rows found, constraint violated
0:                         final DataDictionary dd = lcc.getDataDictionary();
0:                         final ConglomerateDescriptor cd =
0:                                 dd.getConglomerateDescriptor(indexCID);
0:                         final TableDescriptor td =
0:                                 dd.getTableDescriptor(cd.getTableID());
0:                         final ConstraintDescriptor conDesc =
0:                                 dd.getConstraintDescriptor(td, cd.getUUID());
1: 
0:                         throw StandardException.newException(
0:                           rollbackOnError ?
0:                             SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_T :
0:                             SQLState.LANG_DEFERRED_DUPLICATE_KEY_CONSTRAINT_S,
0:                           conDesc.getConstraintName(),
0:                           td.getName());
0:                     } // else exactly one row contains key: OK
1:                 } else {
0:                     // No rows contain key: OK, must have been deleted later
0:                     // in transaction, or we got here due to pessimistic
0:                     // assumption on a timeout while checking on the insert.
1:                 }
0:             } catch (StandardException se) {
0:                 sawException = true;
0:                 throw se;
0:             } finally {
0:                 // Clean up resource usage
0:                 try {
0:                     if (indexSC != null) {
0:                         indexSC.close();
1:                     }
0:                 } catch (StandardException ie) {
0:                     if (!sawException) {
0:                         throw ie;
0:                     } // else: can't let it shadow preceding exception
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
0:      * Validate one or more CHECK constraints on a table.
1:      * <p>
0:      * Implementation note: We remember violations for a row by storing its row
0:      * location in a disk based hash table, similar to what we do for the index
0:      * location for primary key and unique constraints. As far as which
0:      * constraints caused which violations, constraints are only presently
0:      * remembered as having caused "one or more violations", i.e. for any
0:      * violating row, we do not know at checking time exactly which constraint
0:      * caused a problem for that exact row. So, for any given constraint which
0:      * was violated in the transaction we visit all rows which had one or more
0:      * violations and check again. This could be improved upon by remembering
0:      * for each violating row the exact set of constraint(s) that saw a
0:      * violation. Still, this is much faster than a full table scan in most use
0:      * cases.  We use a special internal query option to achieve this.  The row
0:      * locations may not be usable if Derby does a compress or otherwise makes
0:      * them invalid. In that case we resort to a full table scan.
0:      * @see ValidateCheckConstraintResultSet
1:      *
0:      * @param lcc          The language connection context
0:      * @param baseTableCID The conglomerate id of the base table for which
0:      *                     we want to validate check constraints.
0:      * @param constraintId If not {@code null}, check only for this
0:      *                     constraint.  This is used when switching mode to
0:      *                     immediate.  If {@code null}, we check all check
0:      *                     constraints, i.e.  at commit or if we have {@code
0:      *                     SET CONSTRAINT ALL IMMEDIATE}.
0:      * @param ci           The constraints info for the table we need
0:      *                     to perform the check on.
0:      * @param rollbackOnError If {@code true} and a violation occurs, throw
0:      *                     and exception that will cause rollback.
0:      * @throws StandardException
0:      *                     Default error policy
1:      */
0:     public static void validateCheck(
1:             final LanguageConnectionContext lcc,
0:             final long baseTableCID,
0:             final UUID constraintId,
0:             final CheckInfo ci,
0:             final boolean rollbackOnError) throws StandardException {
1: 
0:         final TransactionController tc = lcc.getTransactionExecute();
0:         final DataDictionary dd = lcc.getDataDictionary();
0:         final SchemaDescriptor sd = dd.getSchemaDescriptor(
0:                 ci.schemaName, tc, true);
1: 
0:         if (sd == null) {
0:             if (SanityManager.DEBUG) {
0:                 // dropping of a schema shouold drop any tables and their
0:                 // constraints, which in turn should drop any deferred
0:                 // constraint memory of them.
0:                 SanityManager.NOTREACHED();
1:             } else {
0:                 return;
1:             }
1:         }
1: 
0:         final TableDescriptor td = dd.getTableDescriptor(ci.tableName, sd, tc);
1: 
0:         if (td == null) {
0:             if (SanityManager.DEBUG) {
0:                 // dropping of a table shouold drop any
0:                 // constraints, which in turn should drop any deferred
0:                 // constraint memory of them. Renaming of a table with
0:                 // constrants is not presently allowed. FIXME: use UUID
0:                 // instead of string here, more stable reference.
0:                 SanityManager.NOTREACHED();
1:             }
1:         } else {
0:             for (UUID id : ci.culprits) {
0:                 if (constraintId == null || constraintId.equals(id)) {
0:                     final ConstraintDescriptor cd =
0:                         dd.getConstraintDescriptor(id);
0:                     final StringBuilder checkStmt = new StringBuilder();
0:                     checkStmt.append("SELECT 1 FROM ");
0:                     checkStmt.append(td.getQualifiedName());
1: 
0:                     // If a compress has happened in this transaction, we can't
0:                     // trust the rowLocations, so make a full table scan. If
0:                     // not, we optimize by using a special result set type
0:                     // which utilized the saved away row locations for the
0:                     // offending rows, so we only visit those when checking.
0:                     // I.e. other rows are known to be good a priori.
0:                     if (!ci.isInvalidated()) {
0:                         checkStmt.append(
0:                             " --DERBY-PROPERTIES joinStrategy=nestedLoop, " +
0:                                 "                    index=null, " +
0:                                 "                    validateCheckConstraint=");
0:                         checkStmt.append(Long.toString(baseTableCID));
0:                         checkStmt.append('\n');
1:                     }
1: 
0:                     checkStmt.append(" WHERE NOT(");
0:                     checkStmt.append(cd.getConstraintText());
0:                     checkStmt.append(')');
1: 
0:                     BasicNoPutResultSetImpl rs = null;
0:                     final PreparedStatement ps = lcc.prepareInternalStatement(
0:                         lcc.getDefaultSchema(),
0:                         checkStmt.toString(),
0:                         true,
0:                         true);
0:                     try {
0:                         rs = (BasicNoPutResultSetImpl)ps.execute(
0:                             ps.getActivation(lcc, false), false, 0L);
0:                         final ExecRow row = rs.getNextRowCore();
1: 
0:                         if (row != null) {
0:                             //check constraint violated
1: 
0:                             throw StandardException.newException(
0:                                 rollbackOnError ?
0:                                     SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_T :
0:                                     SQLState.LANG_DEFERRED_CHECK_CONSTRAINT_S,
0:                                 cd.getConstraintName(),
0:                                 td.getName(),
0:                                 cd.getConstraintText());
1:                         }
0:                     } finally {
0:                         if (rs != null) {
0:                             try {
0:                                 rs.close();
0:                             } catch (StandardException e) {}
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Class hierarchy carrying the information we need to validate
1:      * some deferred constraint. For unique and primary key constraints, we
1:      * only need the index row. For check constraints we need the target table
1:      * name, schema name and some other info also.
1:      */
1:     abstract public static class ValidationInfo {
1:         public final BackingStoreHashtable infoRows;
1: 
1:         public ValidationInfo(final BackingStoreHashtable infoRows) {
1:             this.infoRows = infoRows;
1:         }
1:     }
1: 
1:     /**
1:      * Info needed for unique and primary key constraints
1:      */
0:     public static class UniquePkInfo extends ValidationInfo {
0:         public UniquePkInfo(final BackingStoreHashtable infoRows) {
1:             super(infoRows);
1:         }
1:     }
1: 
1:     /**
1:      * Info needed for check constraints
1:      */
1:     public static class CheckInfo extends ValidationInfo {
1:         final private String schemaName;
1:         final private String tableName;
1: 
1:         private List<UUID> culprits; // constraints that were violated
1:                                      // for this table so far
1:         private boolean invalidatedDueToCompress;
1: 
1:         public CheckInfo(
1:                 final BackingStoreHashtable infoRows,
1:                 final String schemaName,
1:                 final String tableName,
1:                 final List<UUID> culprits) {
1: 
1:             super(infoRows);
1:             this.schemaName = schemaName;
1:             this.tableName = tableName;
1:             this.culprits = new ArrayList<UUID>(culprits);
1:         }
1: 
1:         public void setInvalidatedRowLocations() {
1:             invalidatedDueToCompress = true;
1:         }
1: 
1:         public boolean isInvalidated() {
1:             return invalidatedDueToCompress;
1:         }
1: 
1:         public void addCulprits(List<UUID> newCulprits) {
1:             final Set<UUID> old = new HashSet<UUID>(culprits);
1:             old.addAll(newCulprits);
1:             culprits = new ArrayList<UUID>(old);
1:         }
1: 
1:         public List<UUID> getCulprints() {
1:             return culprits;
1:         }
1:     }
1: }
============================================================================