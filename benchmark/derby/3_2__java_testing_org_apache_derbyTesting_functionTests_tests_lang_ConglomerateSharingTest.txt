1:b2d7261: /*
1:b2d7261:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ConglomerateSharingTest
3:b2d7261: 
1:b2d7261:        Licensed to the Apache Software Foundation (ASF) under one
1:b2d7261:        or more contributor license agreements.  See the NOTICE file
1:b2d7261:        distributed with this work for additional information
1:b2d7261:        regarding copyright ownership.  The ASF licenses this file
1:b2d7261:        to you under the Apache License, Version 2.0 (the
1:b2d7261:        "License"); you may not use this file except in compliance
1:b2d7261:        with the License.  You may obtain a copy of the License at
1:b2d7261: 
1:b2d7261:          http://www.apache.org/licenses/LICENSE-2.0
1:b2d7261: 
1:b2d7261:        Unless required by applicable law or agreed to in writing,
1:b2d7261:        software distributed under the License is distributed on an
1:b2d7261:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:b2d7261:        KIND, either express or implied.  See the License for the
1:b2d7261:        specific language governing permissions and limitations
1:b2d7261:        under the License
1:b2d7261: */
1:b2d7261: 
1:b2d7261: package org.apache.derbyTesting.functionTests.tests.lang;
1:b2d7261: 
1:b2d7261: import java.sql.PreparedStatement;
1:b2d7261: import java.sql.ResultSet;
1:b2d7261: import java.sql.SQLException;
1:b2d7261: import java.sql.Statement;
1:709b46e: import java.util.Arrays;
1:b2d7261: import junit.framework.Test;
1:b2d7261: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:b2d7261: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:b2d7261: import org.apache.derbyTesting.junit.JDBC;
1:b2d7261: import org.apache.derbyTesting.junit.TestConfiguration;
1:b2d7261: 
1:b2d7261: /**
1:b2d7261:  * Test for situations in which Derby attempts to "share" physical
1:b2d7261:  * conglomerates across multiple constraints.
1:b2d7261:  */
1:b2d7261: public final class ConglomerateSharingTest extends BaseJDBCTestCase {
1:b2d7261: 
1:b2d7261:     private final String COUNT_TABLE_CONGLOMS =
1:b2d7261:         "select count (distinct conglomeratenumber) from " +
1:b2d7261:         "sys.sysconglomerates where tableid = " +
1:b2d7261:         " (select tableid from sys.systables where tablename = ?)";
1:b2d7261: 
1:b2d7261:     private final String GET_CONSTRAINT_NAMES =
1:b2d7261:         "select constraintname from sys.sysconstraints " +
1:b2d7261:         "where tableid = (select tableid from sys.systables " +
1:b2d7261:         "where tablename = ?)";
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * Public constructor required for running test as standalone JUnit.
1:b2d7261:      */
1:b2d7261:     public ConglomerateSharingTest(String name)
1:b2d7261:     {
1:b2d7261:         super(name);
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * Create a suite of tests.
1:b2d7261:      */
1:b2d7261:     public static Test suite()
1:b2d7261:     {
1:b2d7261:         return new CleanDatabaseTestSetup(
1:b2d7261:             TestConfiguration.embeddedSuite(ConglomerateSharingTest.class));
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * If we have a unique constraint and a non-unique constraint
1:b2d7261:      * which a) reference the same columns and b) share a single
1:b2d7261:      * (unique) conglomerate, then test that dropping the unique
1:b2d7261:      * constraint will convert the physical conglomerate to be
1:b2d7261:      * non-unique.  This test case is pulled from the repro
1:b2d7261:      * attached to DERBY-3299.
1:b2d7261:      */
1:b2d7261:     public void testConversionToNonUnique() throws SQLException
1:b2d7261:     {
1:b2d7261:         PreparedStatement countCongloms =
1:b2d7261:             prepareStatement(COUNT_TABLE_CONGLOMS);
1:b2d7261: 
1:b2d7261:         Statement st = createStatement();
1:b2d7261: 
1:b2d7261:         st.execute("create table orders (no_w_id int not null, " +
1:b2d7261:             "no_d_id int not null, no_o_id int not null, info varchar(20), " +
1:b2d7261:             "constraint orders_pk primary key (no_w_id, no_d_id, no_o_id))");
1:b2d7261: 
1:b2d7261:         st.execute("insert into orders values (1, 2, 3, 'info # one')");
1:b2d7261:         st.execute("insert into orders values (1, 2, 4, 'info # two')");
1:b2d7261:         st.execute("insert into orders values (1, 2, 5, 'info # 3')");
1:b2d7261: 
1:b2d7261:         st.execute("create table neworders (no_w_id int not null, " +
1:b2d7261:             "no_d_id int not null, no_o_id int not null, lname varchar(50))");
1:b2d7261: 
1:b2d7261:         st.execute("alter table neworders add constraint " +
1:b2d7261:             "neworders_pk primary key (no_w_id, no_d_id, no_o_id)");
1:b2d7261: 
1:b2d7261:         st.execute("alter table neworders add constraint " +
1:b2d7261:               "no_o_fk foreign key (no_w_id, no_d_id, no_o_id) " +
1:b2d7261:             "references orders");
1:b2d7261: 
1:b2d7261:         st.execute("insert into neworders values (1, 2, 3, 'Inigo')");
1:b2d7261:         st.execute("insert into neworders values (1, 2, 4, 'Montoya')");
1:b2d7261:         st.execute("insert into neworders values (1, 2, 5, 'Tortuga')");
1:b2d7261: 
1:b2d7261:         /* Should have 2 conglomerates on NEWORDERS:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. NEWORDERS_PK (shared by: NO_O_FK)
1:b2d7261:          */
1:b2d7261:         countConglomerates("NEWORDERS", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         // This should fail due to foreign key.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into neworders values (1, 3, 5, 'SHOULD FAIL')",
1:b2d7261:             "NO_O_FK");
1:b2d7261: 
1:b2d7261:         // This should fail due to primary key (uniqueness violation).
1:b2d7261:         checkStatementError("23505", st,
1:b2d7261:             "insert into neworders values (1, 2, 4, 'SHOULD FAIL')",
1:b2d7261:             "NEWORDERS_PK");
1:b2d7261: 
1:b2d7261:         /* Now drop the primary key from NEWORDERS.  This should
1:b2d7261:          * drop the implicit uniqueness requirement, as well--i.e.
1:b2d7261:          * the physical conglomerate should become non-unique.
1:b2d7261:          */
1:b2d7261:         st.execute("alter table neworders drop constraint neworders_pk");
1:b2d7261: 
1:b2d7261:         /* Should still have 2 conglomerates because we dropped the
1:b2d7261:          * unique conglomerate from NEWORDER_PK but created another,
1:b2d7261:          * non-unique one for NO_O_FK.
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. NO_O_FK
1:b2d7261:          */
1:b2d7261:         countConglomerates("NEWORDERS", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         // This should still fail due to the foreign key.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into neworders values (1, 3, 5, 'SHOULD FAIL')",
1:b2d7261:             "NO_O_FK");
1:b2d7261: 
1:b2d7261:         /* This should now succeed because we dropped the backing
1:b2d7261:          * unique index and foreign key constraints are not inherently
1:b2d7261:          * unique. DERBY-3299.
1:b2d7261:          */
1:b2d7261:         st.execute("insert into neworders values (1, 2, 4, 'SHOULD SUCCEED')");
1:b2d7261: 
1:b2d7261:         // Sanity check the table contents.
1:b2d7261:         JDBC.assertUnorderedResultSet(
1:b2d7261:             st.executeQuery("select * from neworders"),
1:b2d7261:             new String [][] {
1:b2d7261:                 {"1", "2", "3", "Inigo"},
1:b2d7261:                 {"1", "2", "4", "Montoya"},
1:b2d7261:                 {"1", "2", "5", "Tortuga"},
1:b2d7261:                 {"1", "2", "4", "SHOULD SUCCEED"}
1:b2d7261:             });
1:b2d7261: 
1:b2d7261:         // Check again using the foreign key's backing index.
1:b2d7261:         JDBC.assertUnorderedResultSet(st.executeQuery(
1:b2d7261:             "select * from neworders --DERBY-PROPERTIES constraint=NO_O_FK"),
1:b2d7261:             new String [][] {
1:b2d7261:                 {"1", "2", "3", "Inigo"},
1:b2d7261:                 {"1", "2", "4", "Montoya"},
1:b2d7261:                 {"1", "2", "5", "Tortuga"},
1:b2d7261:                 {"1", "2", "4", "SHOULD SUCCEED"}
1:b2d7261:             });
1:b2d7261: 
1:b2d7261:         st.execute("drop table neworders");
1:b2d7261:         st.execute("drop table orders");
1:b2d7261:         countConglomerates("NEWORDERS", countCongloms, 0);
1:b2d7261: 
1:b2d7261:         countCongloms.close();
1:b2d7261:         st.close();
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * Test various conditions in which a constraint can be dropped,
1:b2d7261:      * and verify that if the constraint's backing conglomerate is
1:b2d7261:      * shared, we do the right thing.
1:b2d7261:      */
1:b2d7261:     public void testConstraintDrops() throws SQLException
1:b2d7261:     {
1:b2d7261:         PreparedStatement countCongloms =
1:b2d7261:             prepareStatement(COUNT_TABLE_CONGLOMS);
1:b2d7261: 
1:b2d7261:         PreparedStatement getConstraintNames =
1:b2d7261:             prepareStatement(GET_CONSTRAINT_NAMES);
1:b2d7261: 
1:b2d7261:         Statement st = createStatement();
1:b2d7261: 
1:b2d7261:         st.execute("create table dropc_t0 (i int not null, j int not null)");
1:b2d7261:         st.execute("alter table dropc_t0 " +
1:b2d7261:             "add constraint dropc_pk0 primary key (i,j)");
1:b2d7261: 
1:b2d7261:         /* Should have 2 conglomerates on DROPC_T0:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_PK0
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T0", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         st.execute("create table dropc_t1 (i int, j int not null)");
1:b2d7261:         st.execute("alter table dropc_t1 " +
1:b2d7261:             "add constraint dropc_pk1 primary key (j)");
1:b2d7261: 
1:b2d7261:         /* Should have 2 conglomerates on DROPC_T1:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_PK1
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T1", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         st.execute("create table dropc_t2 " +
1:b2d7261:             "(a int, b int not null, c int not null)");
1:b2d7261:         st.execute("create index dropc_ix1 on dropc_t2 (a,b)");
1:b2d7261:         st.execute("create unique index dropc_uix2 on dropc_t2 (c)");
1:b2d7261: 
1:b2d7261:         st.execute("alter table dropc_t2 " +
1:b2d7261:             "add constraint dropc_uc1 unique (c)");
1:b2d7261:         st.execute("alter table dropc_t2 add constraint " +
1:b2d7261:             "dropc_fk0 foreign key (a,b) references dropc_t0");
1:b2d7261:         st.execute("alter table dropc_t2 add constraint " +
1:b2d7261:             "dropc_fk1 foreign key (a,b) references dropc_t0");
1:b2d7261:         st.execute("alter table dropc_t2 add constraint " +
1:b2d7261:             "dropc_fk2 foreign key (c) references dropc_t1");
1:b2d7261: 
1:b2d7261:         /* Should have 3 conglomerates on DROPC_T2:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK0, DROPC_FK1)
1:b2d7261:          *  3. DROPC_UIX2 (shared by: DROPC_UC1, DROPC_FK2)
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 3);
1:b2d7261: 
1:b2d7261:         st.execute("insert into dropc_t0 values (1, 2)");
1:b2d7261:         st.execute("insert into dropc_t1 values (3, 4)");
1:b2d7261:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1:b2d7261: 
1:b2d7261:         /* DROP 1: First and obvious way to drop a constraint is
1:b2d7261:          * with an ALTER TABLE DROP CONSTRAINT command.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         /* Drop constraint DROPC_FK0.  Since both DROPC_IX1 and
1:b2d7261:          * DROPC_FK1 require a physical conglomerate identical
1:b2d7261:          * to that of DROPC_FK0 (esp. non-unique on the same
1:b2d7261:          * columns), dropping the latter constraint should have
1:b2d7261:          * no effect on the physical conglomerate.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         st.execute("alter table DROPC_T2 drop constraint DROPC_FK0");
1:b2d7261: 
1:b2d7261:         /* Should still have 3 conglomerates on DROPC_T2:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          *  3. DROPC_UIX2 (shared by: DROPC_UC1, DROPC_FK2)
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 3);
1:b2d7261: 
1:b2d7261:         /* Check that all non-dropped constraint stills exist and
1:b2d7261:          * can be used for queries.
1:b2d7261:          */
1:b2d7261:         verifyConstraints(
1:b2d7261:             st, getConstraintNames, "DROPC_T2", "DROPC_FK0",
1:b2d7261:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"},{"DROPC_UC1"}},
1:b2d7261:             1);
1:b2d7261: 
1:b2d7261:         // Make sure non-dropped constraints are still enforced.
1:b2d7261: 
1:709b46e:         // This statement attempts to insert a duplicate in the C column.
1:709b46e:         // This violates both the unique index DROPC_UIX2 and the unique
1:709b46e:         // constraint DROPC_UC1. Additionally, the backing index of the
1:709b46e:         // foreign key DROPC_FK2 is a unique index. It is not deterministic
1:709b46e:         // which index will be checked first, so accept any of the three.
1:b2d7261:         checkStatementError("23505", st,
1:709b46e:             "insert into dropc_t2 values (1, 2, 4)",
1:709b46e:             "DROPC_UIX2", "DROPC_UC1", "DROPC_FK2");
1:b2d7261: 
1:709b46e:         // This statement violates the foreign key DROPC_FK1. It also
1:709b46e:         // violates the same unique constraints/indexes as the previous
1:709b46e:         // statement (duplicate value in column C). Foreign key violations
1:709b46e:         // are checked before unique index violations, so expect the error
1:709b46e:         // to be reported as a violation of DROPC_FK1.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1:b2d7261: 
1:709b46e:         // This statement violates the foreign key DROPC_FK2.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1:b2d7261: 
1:b2d7261:         /* Drop constraint DROPC_UC1.  Since DROPC_UIX2 requires
1:b2d7261:          * a physical conglomerate identical to that of DROPC_UC1
1:b2d7261:          * (esp. unique on the same columns), dropping the latter
1:b2d7261:          * constraint should have no effect on the physical
1:b2d7261:          * conglomerate.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         st.execute("alter table DROPC_T2 drop constraint DROPC_UC1");
1:b2d7261: 
1:b2d7261:         /* Should still have 3 conglomerates on DROPC_T2:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          *  3. DROPC_UIX2 (shared by: DROPC_FK2)
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 3);
1:b2d7261: 
1:b2d7261:         /* Check that all non-dropped constraints still exist and
1:b2d7261:          * can be used for queries.
1:b2d7261:          */
1:b2d7261:         verifyConstraints(
1:b2d7261:             st, getConstraintNames, "DROPC_T2", "DROPC_UC1",
1:b2d7261:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"}},
1:b2d7261:             1);
1:b2d7261: 
1:b2d7261:         // Make sure non-dropped constraints are still enforced.
1:b2d7261: 
1:709b46e:         // This statement attempts to insert a duplicate into the unique
1:709b46e:         // index DROPC_UIX2 and the unique backing index of the foreign
1:709b46e:         // key constraint DROPC_FK2. It is not deterministic which of the
1:709b46e:         // two indexes will be inserted into first, so accept both in the
1:709b46e:         // error message.
1:b2d7261:         checkStatementError("23505", st,
1:709b46e:             "insert into dropc_t2 values (1, 2, 4)", "DROPC_UIX2", "DROPC_FK2");
1:b2d7261: 
1:709b46e:         // This statement both violates the foreign key DROPC_FK1 and
1:709b46e:         // attempts to insert a duplicate value into the column C. Expect
1:709b46e:         // foreign key constraint violations to be checked before unique
1:709b46e:         // index violations.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1:b2d7261: 
1:709b46e:         // This statement violates the foreign key DROPC_FK2.
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1:b2d7261: 
1:b2d7261:         /* DROP 2: We don't drop the constraint, but we drop a user
1:b2d7261:          * index that shares a physical conglomerate with a constraint.
1:b2d7261:          * In this case we drop DROPC_UIX2.  Since DROPC_FK2 is the only
1:b2d7261:          * constraint that shares with DROPC_UIX2, and since DROPC_FK2
1:b2d7261:          * is NON-unique while DROPC_UIX2 is unique, we should drop
1:b2d7261:          * the unique physical conglomerate and create a non-unique
1:b2d7261:          * one.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         st.execute("drop index dropc_uix2");
1:b2d7261: 
1:b2d7261:         /* Should still have 3 conglomerates on DROPC_T2:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          *  3. DROPC_FK2
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 3);
1:b2d7261: 
1:b2d7261:         /* Check that all non-dropped constraints still exist and
1:b2d7261:          * can be used for queries.
1:b2d7261:          */
1:b2d7261:         verifyConstraints(
1:b2d7261:             st, getConstraintNames, "DROPC_T2", null,
1:b2d7261:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"}},
1:b2d7261:             1);
1:b2d7261: 
1:b2d7261:         // Make sure non-dropped constraints are still enforced.
1:b2d7261: 
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1:b2d7261: 
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1:b2d7261: 
1:b2d7261:         /* This should now succeed because there is no longer any
1:b2d7261:          * requirement for uniqueness.
1:b2d7261:          */
1:b2d7261:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1:b2d7261: 
1:b2d7261:         JDBC.assertUnorderedResultSet(
1:b2d7261:             st.executeQuery("select * from dropc_t2"),
1:b2d7261:             new String [][] {
1:b2d7261:                 {"1", "2", "4"},
1:b2d7261:                 {"1", "2", "4"}
1:b2d7261:             });
1:b2d7261: 
1:b2d7261:         /* Recreate the unique constraint DROPC_UC1 for next test, and
1:b2d7261:          * make DROPC_FK2 share with it again.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         st.execute("delete from dropc_t2");
1:b2d7261:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1:b2d7261:         st.execute("alter table dropc_t2 drop constraint dropc_fk2");
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         st.execute("alter table dropc_t2 " +
1:b2d7261:             "add constraint dropc_uc1 unique (c)");
1:b2d7261:         st.execute("alter table dropc_t2 add constraint " +
1:b2d7261:             "dropc_fk2 foreign key (c) references dropc_t1");
1:b2d7261: 
1:b2d7261:         /* Also create unique index that will be dropped as part of
1:b2d7261:          * the next test, as well--we want to exercise that code
1:b2d7261:          * path, even if there is no conglomerate sharing involved
1:b2d7261:          * for this particular case.
1:b2d7261:          */
1:b2d7261:         st.execute("create unique index dropc_uix3 on dropc_t2 (a, c)");
1:b2d7261: 
1:b2d7261:         /* So we should now have:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          *  3. DROPC_UC1 (shared by: DROPC_FK2)
1:b2d7261:          *  4. DROPC_UIX3
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 4);
1:b2d7261: 
1:b2d7261:         /* DROP 3: Third way to drop a constraint is to drop a
1:b2d7261:          * column on which the constraint depends.  Here we drop
1:b2d7261:          * column C, which will cause both DROPC_UC1 and DROPC_FK2
1:b2d7261:          * to be implicitly dropped, as well. Additionally, DROPC_UIX3
1:b2d7261:          * should be dropped because it is a unique index that relies
1:b2d7261:          * on the dropped column; since it doesn't share its
1:b2d7261:          * conglomerate with anything else, that physical conglom
1:b2d7261:          * should be dropped here, as well.
1:b2d7261:          */
1:b2d7261:         st.execute("alter table dropc_t2 drop column c");
1:b2d7261: 
1:b2d7261:         /* Should now only have 2 conglomerates on DROPC_T2:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 2);
1:b2d7261: 
1:b2d7261:         /* Check that all non-dropped constraint still exist and
1:b2d7261:          * can be used for queries.
1:b2d7261:          */
1:b2d7261:         verifyConstraints(
1:b2d7261:             st, getConstraintNames, "DROPC_T2", "DROPC_FK2",
1:b2d7261:             new String [][] {{"DROPC_FK1"}},
1:b2d7261:             1);
1:b2d7261: 
1:b2d7261:         // Make sure non-dropped constraints are still enforced.
1:b2d7261: 
1:b2d7261:         checkStatementError("23503", st,
1:b2d7261:             "insert into dropc_t2 values (2, 2)", "DROPC_FK1");
1:b2d7261: 
1:b2d7261:         /* DROP 4: If privileges to a table are revoked, a constraint
1:b2d7261:          * (esp. a foreign key constraint) that references that table
1:b2d7261:          * will be dropped.  Test case for this should exist in
1:b2d7261:          * GrantRevokeDDLTest.java.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         /* Make a a non-unique constraint share a conglomerate with
1:b2d7261:          * a unique constraint, in prep for the next test case.
1:b2d7261:          */
1:b2d7261: 
1:b2d7261:         st.execute("delete from dropc_t2");
1:b2d7261:         st.execute("alter table dropc_t2 " +
1:b2d7261:             "add constraint dropc_uc2 unique (b)");
1:b2d7261:         st.execute("alter table dropc_t2 add constraint " +
1:b2d7261:             "dropc_fk3 foreign key (b) references dropc_t1");
1:b2d7261: 
1:b2d7261:         /* So we should now have:
1:b2d7261:          *
1:b2d7261:          *  1. Heap
1:b2d7261:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:b2d7261:          *  3. DROPC_UC2 (shared by: DROPC_FK3)
1:b2d7261:          */
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 3);
1:b2d7261: 
1:b2d7261:         /* DROP 5: Final way to drop a constraint is to drop the
1:b2d7261:          * table on which the constraint exists.  Derby will first
1:b2d7261:          * drop all columns, then drop all constraints, and finally,
1:b2d7261:          * drop all indexes.  Make sure the drop succeeds without
1:b2d7261:          * error and that all physical conglomerates are dropped
1:b2d7261:          * as well.
1:b2d7261:          */
1:b2d7261:         st.execute("drop table dropc_t2");
1:b2d7261: 
1:b2d7261:         // There shouldn't be any conglomerates left...
1:b2d7261:         countConglomerates("DROPC_T2", countCongloms, 0);
1:b2d7261:         assertStatementError("42X05", st, "select * from dropc_t2");
1:b2d7261: 
1:b2d7261:         // Clean up.
1:b2d7261:         st.execute("drop table dropc_t1");
1:b2d7261:         st.execute("drop table dropc_t0");
1:b2d7261:         getConstraintNames.close();
1:b2d7261:         countCongloms.close();
1:b2d7261:         st.close();
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:477fd5e:      * Test conglomerate sharing when a unique constraint having one or
1:477fd5e:      * more nullable columns is in play (possible as of DERBY-3330).
1:477fd5e:      * @throws SQLException
1:477fd5e:      */
1:477fd5e:     public void testUniqueConstraintWithNullsBackingIndex ()
1:477fd5e:         throws SQLException
1:477fd5e:     {
1:477fd5e:         PreparedStatement countCongloms =
1:477fd5e:             prepareStatement(COUNT_TABLE_CONGLOMS);
1:477fd5e:         
1:477fd5e:         Statement stmt = createStatement();
1:477fd5e:         stmt.execute("create table t1 (i int, j int not null, k int)");
1:477fd5e:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:477fd5e:                 "(4, -4, 16), (3, -3, 9)");
1:477fd5e:         //create a non unique index
1:477fd5e:         stmt.executeUpdate("create index nuix on t1(i,j)");
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. nuix
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);
1:477fd5e:         
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)"); 
1:477fd5e:         /* Should have 3 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. unix
1:477fd5e:          *  3. uc
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 3);
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e: 
1:477fd5e:         assertStatementError("23505", stmt, 
1:477fd5e:                 "insert into t1 values (1, -1, 1)");
1:477fd5e:         //clean the table to try unique index
1:477fd5e:         stmt.executeUpdate("delete from t1");
1:477fd5e:         stmt.executeUpdate("drop index nuix");
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uc
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);
1:477fd5e:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:477fd5e:         /* Should have 1 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 1);
1:477fd5e:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:477fd5e:                 "(4, -4, 16), (3, -3, 9)");
1:477fd5e:         stmt.executeUpdate("create unique index uix on t1(i,j)");
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uix
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)");
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uix
1:477fd5e:          * Unique Constraint uc should use uix
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);
1:477fd5e:         //make sure that unique index is effective
1:477fd5e:         assertStatementError("23505", stmt, 
1:477fd5e:                 "insert into t1 values (null, 1, -1)");
1:477fd5e:         //drop unique index
1:477fd5e:         stmt.executeUpdate("drop index uix");
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uc
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);  
1:477fd5e:         //make sure that its a new index and not a unique index
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e:         //drop constraint
1:477fd5e:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:477fd5e:         //clean table
1:477fd5e:         stmt.executeUpdate("delete from t1");
1:477fd5e:         /* Should have 1 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 1);
1:477fd5e: 
1:477fd5e:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:477fd5e:                 "(4, -4, 16), (3, -3, 9)");
1:477fd5e:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:477fd5e:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)"); 
1:477fd5e:         
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uc
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);  
1:477fd5e:         
1:477fd5e:         stmt.executeUpdate("create table t2 (a int not null, b int not null)");
1:477fd5e:         stmt.executeUpdate("alter table t2 add constraint pkt2 primary key(a,b)");
1:477fd5e:         
1:477fd5e:         /* Should have 2 conglomerates on T2:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. pkt2
1:477fd5e:          */
1:477fd5e:         countConglomerates("T2", countCongloms, 2);
1:477fd5e:         stmt.executeUpdate("insert into t2 values (1, -1), (2, -2), " +
1:477fd5e:                 "(4, -4), (3, -3)"); 
1:477fd5e:         
1:477fd5e:         stmt.executeUpdate("alter table t1 add constraint fkt1 " +
1:477fd5e:                 "foreign key (i,j) references t2");
1:477fd5e:         
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uc
1:477fd5e:          * fkt1 should share index with uc
1:477fd5e:          */
1:477fd5e:         countConglomerates("T1", countCongloms, 2);  
1:477fd5e:         
1:477fd5e:         //ensure there is no change in backing index
1:477fd5e:         assertStatementError("23505", stmt, "insert into " +
1:477fd5e:                 "t1(i,j) values (1, -1)");
1:477fd5e:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:477fd5e:         
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. fkt1
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e:        
1:477fd5e:        //ensure that it allows duplicate keys
1:477fd5e:        stmt.executeUpdate("insert into t1(i,j) values (1, -1)");
1:477fd5e:         
1:477fd5e:        //clean tables
1:477fd5e:        stmt.executeUpdate("alter table t1 drop constraint fkt1");
1:477fd5e:        stmt.executeUpdate("alter table t2 drop constraint pkt2");
1:477fd5e:        stmt.executeUpdate("delete from t1");
1:477fd5e:        stmt.executeUpdate("delete from t2");
1:477fd5e:        
1:477fd5e:         /* Should have 1 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 1);
1:477fd5e:         /* Should have 1 conglomerates on T2:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          */
1:477fd5e:        countConglomerates("T2", countCongloms, 1);  
1:477fd5e: 
1:477fd5e:        stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:477fd5e:                "(4, -4, 16), (3, -3, 9)");
1:477fd5e: 
1:477fd5e:        stmt.executeUpdate("alter table t2 add constraint " +
1:477fd5e:                                                 "pkt2 primary key(a,b)");
1:477fd5e:         /* Should have 2 conglomerates on T2:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. pkt2
1:477fd5e:          */
1:477fd5e:        countConglomerates("T2", countCongloms, 2);  
1:477fd5e:        
1:477fd5e:        stmt.executeUpdate("insert into t2 values (1, -1), (2, -2)," +
1:477fd5e:                                                         "(4, -4), (3, -3)");
1:477fd5e: 
1:477fd5e:        stmt.executeUpdate("create unique index uix on t1(i,j)");
1:477fd5e:        
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uix
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e: 
1:477fd5e:        stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)");
1:477fd5e: 
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uix
1:477fd5e:          *  uc should share uix's index
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e: 
1:477fd5e:        //create a foreign key shouldn;t create any new index
1:477fd5e:        stmt.executeUpdate("alter table t1 add constraint fkt1 " +
1:477fd5e:                "foreign key (i,j) references t2");
1:477fd5e:        
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uix
1:477fd5e:          *  uc and fkt1 should share uix's index
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e: 
1:477fd5e:         //Should fail due to UIX
1:477fd5e:         assertStatementError("23505", stmt, "insert into t1(i,j) values (1, -1)");
1:477fd5e: 
1:477fd5e:         //Drop the unique index UIX. The conglomerate for UC and FKT1 should
1:477fd5e:         //be re-created as non-unique with uniqueWithDuplicateNulls set to true.
1:477fd5e:         stmt.executeUpdate("drop index uix");
1:477fd5e:         
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. uc
1:477fd5e:          *  fkt1 should share uc's index
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e: 
1:477fd5e:        //Should work.
1:477fd5e:        stmt.executeUpdate("insert into t1(i,j) values (null, 2)");
1:477fd5e: 
1:477fd5e:        //Should also work since UIX is no longer around.
1:477fd5e:        stmt.executeUpdate("insert into t1(i,j) values (null, 2)");
1:477fd5e: 
1:477fd5e:        //Should fail due to UC
1:477fd5e:        assertStatementError("23505", stmt,"insert into t1 values (1, -1, 1)");
1:477fd5e:         
1:477fd5e:        //drop uc a new non unique should be created
1:477fd5e:        stmt.executeUpdate("alter table t1 drop constraint uc");
1:477fd5e:        
1:477fd5e:         /* Should have 2 conglomerates on T1:
1:477fd5e:          *
1:477fd5e:          *  1. Heap
1:477fd5e:          *  2. fkt1
1:477fd5e:          */
1:477fd5e:        countConglomerates("T1", countCongloms, 2);  
1:477fd5e:        
1:477fd5e:        //should work because there is no uc
1:477fd5e:        stmt.executeUpdate("insert into t1 values (1, -1, 1)");
1:477fd5e:        
1:477fd5e:        //cleanup
1:477fd5e:        stmt.executeUpdate("drop table t1");
1:477fd5e:        stmt.executeUpdate("drop table t2");
1:477fd5e:        stmt.close();
1:477fd5e:        countCongloms.close();
1:477fd5e:     }
1:477fd5e: 
1:477fd5e:     /**
1:b2d7261:      * Count the number of physical conglomerates that exist for
1:b2d7261:      * the received table, and assert that the number found matches
1:b2d7261:      * the expected number.
1:b2d7261:      */
1:b2d7261:     private void countConglomerates(String tableName,
1:b2d7261:         PreparedStatement countCongloms, int expected)
1:b2d7261:         throws SQLException
1:b2d7261:     {
1:b2d7261:         countCongloms.setString(1, tableName);
1:b2d7261:         JDBC.assertSingleValueResultSet(
1:b2d7261:             countCongloms.executeQuery(), String.valueOf(expected));
1:b2d7261:         return;
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * Execute the received statement and assert that:
1:b2d7261:      *
1:b2d7261:      *  1. The statement fails, and
1:b2d7261:      *  1. The SQLSTATE for the failure matches the received SQL
1:b2d7261:      *     state, and
1:b2d7261:      *  2. The failure exception includes the received index/
1:b2d7261:      *     constraint name in its message.  This is intended to
1:b2d7261:      *     be used for uniqueness and foreign key violations,
1:b2d7261:      *     esp. SQLSTATE 23503 and 23505.
1:709b46e:      *
1:709b46e:      * @param sqlState the expected SQLState of the error
1:709b46e:      * @param st the statement to use for execution
1:709b46e:      * @param query the SQL text to execute
1:709b46e:      * @param violatedConstraints the constraints or indexes that are
1:709b46e:      *   violated by this statement; expect the error message to mention
1:709b46e:      *   at least one of them
1:b2d7261:      */
1:b2d7261:     private void checkStatementError(String sqlState,
1:709b46e:         Statement st, String query, String... violatedConstraints)
1:b2d7261:         throws SQLException
1:b2d7261:     {
1:b2d7261:         try {
1:b2d7261: 
1:b2d7261:             st.execute(query);
1:b2d7261:             fail("Expected error '" + sqlState + "' when executing a " +
1:b2d7261:                 "statement, but no error was thrown.");
1:b2d7261: 
1:b2d7261:         } catch (SQLException se) {
1:b2d7261: 
1:b2d7261:             assertSQLState(sqlState, se);
1:709b46e: 
1:709b46e:             boolean foundConstraint = false;
1:709b46e:             for (String c : violatedConstraints) {
1:709b46e:                 if (se.getMessage().contains(c)) {
1:709b46e:                     foundConstraint = true;
1:709b46e:                     break;
1:709b46e:                 }
1:709b46e:             }
1:709b46e: 
1:709b46e:             if (!foundConstraint)
1:b2d7261:             {
1:b2d7261:                 fail("Error " + sqlState + " should have been caused " +
1:709b46e:                     "by one of the following indexes/constraints " +
1:709b46e:                     Arrays.toString(violatedConstraints) +
1:709b46e:                     ", but none of them appeared in the error message.",
1:709b46e:                     se);
1:b2d7261:             }
1:b2d7261: 
1:b2d7261:         }
1:b2d7261:     }
1:b2d7261: 
1:b2d7261:     /**
1:b2d7261:      * Do various checks to ensure that the constraint has truly
1:b2d7261:      * been dropped.  Then do simple SELECT queries using optimizer
1:b2d7261:      * overrides to verify that all expected remaining constraints
1:b2d7261:      * still exist, and that their backing indexes all contain the
1:b2d7261:      * expected number of rows.
1:b2d7261:      */
1:b2d7261:     private void verifyConstraints(Statement st,
1:b2d7261:         PreparedStatement constraintNames, String tName,
1:b2d7261:         String constraintName, String [][] remainingConstraints,
1:b2d7261:         int numRowsExpected) throws SQLException
1:b2d7261:     {
1:b2d7261:         constraintNames.setString(1, tName);
1:b2d7261:         ResultSet constraints = constraintNames.executeQuery();
1:b2d7261:         if (remainingConstraints == null)
1:b2d7261:             JDBC.assertEmpty(constraints);
1:b2d7261:         else
1:b2d7261:             JDBC.assertUnorderedResultSet(constraints, remainingConstraints);
1:b2d7261: 
1:b2d7261:         String select = "select * from " +
1:b2d7261:             tName + " --DERBY-PROPERTIES constraint=";
1:b2d7261: 
1:b2d7261:         /* Make sure the dropped constraint is no longer visible
1:b2d7261:          * from SQL.
1:b2d7261:          */
1:b2d7261:         if (constraintName != null)
1:b2d7261:             assertStatementError("42Y48", st, select + constraintName);
1:b2d7261: 
1:b2d7261:         JDBC.assertDrainResults(st.executeQuery(
1:b2d7261:             "select * from " + tName), numRowsExpected);
1:b2d7261: 
1:b2d7261:         if (remainingConstraints == null)
1:b2d7261:             return;
1:b2d7261: 
1:b2d7261:         /* Run through the remaining constraints and do a simple
1:b2d7261:          * SELECT with each one (via optimizer overrides) as a
1:b2d7261:          * sanity check that we see the correct number of rows.
1:b2d7261:          */
1:b2d7261:         for (int i = 0; i < remainingConstraints.length; i++)
1:b2d7261:         {
1:b2d7261:             JDBC.assertDrainResults(
1:b2d7261:                 st.executeQuery(select + remainingConstraints[i][0]),
1:b2d7261:                 numRowsExpected);
1:b2d7261:         }
1:b2d7261: 
1:b2d7261:         return;
1:b2d7261:     }
1:b2d7261: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:709b46e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:         // This statement attempts to insert a duplicate in the C column.
1:         // This violates both the unique index DROPC_UIX2 and the unique
1:         // constraint DROPC_UC1. Additionally, the backing index of the
1:         // foreign key DROPC_FK2 is a unique index. It is not deterministic
1:         // which index will be checked first, so accept any of the three.
1:             "insert into dropc_t2 values (1, 2, 4)",
1:             "DROPC_UIX2", "DROPC_UC1", "DROPC_FK2");
1:         // This statement violates the foreign key DROPC_FK1. It also
1:         // violates the same unique constraints/indexes as the previous
1:         // statement (duplicate value in column C). Foreign key violations
1:         // are checked before unique index violations, so expect the error
1:         // to be reported as a violation of DROPC_FK1.
1:         // This statement violates the foreign key DROPC_FK2.
/////////////////////////////////////////////////////////////////////////
1:         // This statement attempts to insert a duplicate into the unique
1:         // index DROPC_UIX2 and the unique backing index of the foreign
1:         // key constraint DROPC_FK2. It is not deterministic which of the
1:         // two indexes will be inserted into first, so accept both in the
1:         // error message.
1:             "insert into dropc_t2 values (1, 2, 4)", "DROPC_UIX2", "DROPC_FK2");
1:         // This statement both violates the foreign key DROPC_FK1 and
1:         // attempts to insert a duplicate value into the column C. Expect
1:         // foreign key constraint violations to be checked before unique
1:         // index violations.
1:         // This statement violates the foreign key DROPC_FK2.
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param sqlState the expected SQLState of the error
1:      * @param st the statement to use for execution
1:      * @param query the SQL text to execute
1:      * @param violatedConstraints the constraints or indexes that are
1:      *   violated by this statement; expect the error message to mention
1:      *   at least one of them
1:         Statement st, String query, String... violatedConstraints)
/////////////////////////////////////////////////////////////////////////
1: 
1:             boolean foundConstraint = false;
1:             for (String c : violatedConstraints) {
1:                 if (se.getMessage().contains(c)) {
1:                     foundConstraint = true;
1:                     break;
1:                 }
1:             }
1: 
1:             if (!foundConstraint)
1:                     "by one of the following indexes/constraints " +
1:                     Arrays.toString(violatedConstraints) +
1:                     ", but none of them appeared in the error message.",
1:                     se);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:477fd5e
/////////////////////////////////////////////////////////////////////////
1:      * Test conglomerate sharing when a unique constraint having one or
1:      * more nullable columns is in play (possible as of DERBY-3330).
1:      * @throws SQLException
1:      */
1:     public void testUniqueConstraintWithNullsBackingIndex ()
1:         throws SQLException
1:     {
1:         PreparedStatement countCongloms =
1:             prepareStatement(COUNT_TABLE_CONGLOMS);
1:         
1:         Statement stmt = createStatement();
1:         stmt.execute("create table t1 (i int, j int not null, k int)");
1:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:                 "(4, -4, 16), (3, -3, 9)");
1:         //create a non unique index
1:         stmt.executeUpdate("create index nuix on t1(i,j)");
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. nuix
1:          */
1:         countConglomerates("T1", countCongloms, 2);
1:         
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)"); 
1:         /* Should have 3 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. unix
1:          *  3. uc
1:          */
1:         countConglomerates("T1", countCongloms, 3);
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1: 
1:         assertStatementError("23505", stmt, 
1:                 "insert into t1 values (1, -1, 1)");
1:         //clean the table to try unique index
1:         stmt.executeUpdate("delete from t1");
1:         stmt.executeUpdate("drop index nuix");
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uc
1:          */
1:         countConglomerates("T1", countCongloms, 2);
1:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:         /* Should have 1 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          */
1:         countConglomerates("T1", countCongloms, 1);
1:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:                 "(4, -4, 16), (3, -3, 9)");
1:         stmt.executeUpdate("create unique index uix on t1(i,j)");
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uix
1:          */
1:         countConglomerates("T1", countCongloms, 2);
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)");
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uix
1:          * Unique Constraint uc should use uix
1:          */
1:         countConglomerates("T1", countCongloms, 2);
1:         //make sure that unique index is effective
1:         assertStatementError("23505", stmt, 
1:                 "insert into t1 values (null, 1, -1)");
1:         //drop unique index
1:         stmt.executeUpdate("drop index uix");
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uc
1:          */
1:         countConglomerates("T1", countCongloms, 2);  
1:         //make sure that its a new index and not a unique index
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:         //drop constraint
1:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:         //clean table
1:         stmt.executeUpdate("delete from t1");
1:         /* Should have 1 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          */
1:         countConglomerates("T1", countCongloms, 1);
1: 
1:         stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:                 "(4, -4, 16), (3, -3, 9)");
1:         stmt.executeUpdate("insert into t1 values (null, 1, -1)");
1:         stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)"); 
1:         
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uc
1:          */
1:         countConglomerates("T1", countCongloms, 2);  
1:         
1:         stmt.executeUpdate("create table t2 (a int not null, b int not null)");
1:         stmt.executeUpdate("alter table t2 add constraint pkt2 primary key(a,b)");
1:         
1:         /* Should have 2 conglomerates on T2:
1:          *
1:          *  1. Heap
1:          *  2. pkt2
1:          */
1:         countConglomerates("T2", countCongloms, 2);
1:         stmt.executeUpdate("insert into t2 values (1, -1), (2, -2), " +
1:                 "(4, -4), (3, -3)"); 
1:         
1:         stmt.executeUpdate("alter table t1 add constraint fkt1 " +
1:                 "foreign key (i,j) references t2");
1:         
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uc
1:          * fkt1 should share index with uc
1:          */
1:         countConglomerates("T1", countCongloms, 2);  
1:         
1:         //ensure there is no change in backing index
1:         assertStatementError("23505", stmt, "insert into " +
1:                 "t1(i,j) values (1, -1)");
1:         stmt.executeUpdate("alter table t1 drop constraint uc");
1:         
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. fkt1
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1:        
1:        //ensure that it allows duplicate keys
1:        stmt.executeUpdate("insert into t1(i,j) values (1, -1)");
1:         
1:        //clean tables
1:        stmt.executeUpdate("alter table t1 drop constraint fkt1");
1:        stmt.executeUpdate("alter table t2 drop constraint pkt2");
1:        stmt.executeUpdate("delete from t1");
1:        stmt.executeUpdate("delete from t2");
1:        
1:         /* Should have 1 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          */
1:        countConglomerates("T1", countCongloms, 1);
1:         /* Should have 1 conglomerates on T2:
1:          *
1:          *  1. Heap
1:          */
1:        countConglomerates("T2", countCongloms, 1);  
1: 
1:        stmt.executeUpdate("insert into t1 values (1, -1, 1), (2, -2, 4), " +
1:                "(4, -4, 16), (3, -3, 9)");
1: 
1:        stmt.executeUpdate("alter table t2 add constraint " +
1:                                                 "pkt2 primary key(a,b)");
1:         /* Should have 2 conglomerates on T2:
1:          *
1:          *  1. Heap
1:          *  2. pkt2
1:          */
1:        countConglomerates("T2", countCongloms, 2);  
1:        
1:        stmt.executeUpdate("insert into t2 values (1, -1), (2, -2)," +
1:                                                         "(4, -4), (3, -3)");
1: 
1:        stmt.executeUpdate("create unique index uix on t1(i,j)");
1:        
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uix
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1: 
1:        stmt.executeUpdate("alter table t1 add constraint uc unique(i,j)");
1: 
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uix
1:          *  uc should share uix's index
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1: 
1:        //create a foreign key shouldn;t create any new index
1:        stmt.executeUpdate("alter table t1 add constraint fkt1 " +
1:                "foreign key (i,j) references t2");
1:        
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uix
1:          *  uc and fkt1 should share uix's index
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1: 
1:         //Should fail due to UIX
1:         assertStatementError("23505", stmt, "insert into t1(i,j) values (1, -1)");
1: 
1:         //Drop the unique index UIX. The conglomerate for UC and FKT1 should
1:         //be re-created as non-unique with uniqueWithDuplicateNulls set to true.
1:         stmt.executeUpdate("drop index uix");
1:         
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. uc
1:          *  fkt1 should share uc's index
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1: 
1:        //Should work.
1:        stmt.executeUpdate("insert into t1(i,j) values (null, 2)");
1: 
1:        //Should also work since UIX is no longer around.
1:        stmt.executeUpdate("insert into t1(i,j) values (null, 2)");
1: 
1:        //Should fail due to UC
1:        assertStatementError("23505", stmt,"insert into t1 values (1, -1, 1)");
1:         
1:        //drop uc a new non unique should be created
1:        stmt.executeUpdate("alter table t1 drop constraint uc");
1:        
1:         /* Should have 2 conglomerates on T1:
1:          *
1:          *  1. Heap
1:          *  2. fkt1
1:          */
1:        countConglomerates("T1", countCongloms, 2);  
1:        
1:        //should work because there is no uc
1:        stmt.executeUpdate("insert into t1 values (1, -1, 1)");
1:        
1:        //cleanup
1:        stmt.executeUpdate("drop table t1");
1:        stmt.executeUpdate("drop table t2");
1:        stmt.close();
1:        countCongloms.close();
1:     }
1: 
1:     /**
commit:b2d7261
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ConglomerateSharingTest
1: 
1:        Licensed to the Apache Software Foundation (ASF) under one
1:        or more contributor license agreements.  See the NOTICE file
1:        distributed with this work for additional information
1:        regarding copyright ownership.  The ASF licenses this file
1:        to you under the Apache License, Version 2.0 (the
1:        "License"); you may not use this file except in compliance
1:        with the License.  You may obtain a copy of the License at
1: 
1:          http://www.apache.org/licenses/LICENSE-2.0
1: 
1:        Unless required by applicable law or agreed to in writing,
1:        software distributed under the License is distributed on an
1:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:        KIND, either express or implied.  See the License for the
1:        specific language governing permissions and limitations
1:        under the License
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test for situations in which Derby attempts to "share" physical
1:  * conglomerates across multiple constraints.
1:  */
1: public final class ConglomerateSharingTest extends BaseJDBCTestCase {
1: 
1:     private final String COUNT_TABLE_CONGLOMS =
1:         "select count (distinct conglomeratenumber) from " +
1:         "sys.sysconglomerates where tableid = " +
1:         " (select tableid from sys.systables where tablename = ?)";
1: 
1:     private final String GET_CONSTRAINT_NAMES =
1:         "select constraintname from sys.sysconstraints " +
1:         "where tableid = (select tableid from sys.systables " +
1:         "where tablename = ?)";
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public ConglomerateSharingTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Create a suite of tests.
1:      */
1:     public static Test suite()
1:     {
1:         return new CleanDatabaseTestSetup(
1:             TestConfiguration.embeddedSuite(ConglomerateSharingTest.class));
1:     }
1: 
1:     /**
1:      * If we have a unique constraint and a non-unique constraint
1:      * which a) reference the same columns and b) share a single
1:      * (unique) conglomerate, then test that dropping the unique
1:      * constraint will convert the physical conglomerate to be
1:      * non-unique.  This test case is pulled from the repro
1:      * attached to DERBY-3299.
1:      */
1:     public void testConversionToNonUnique() throws SQLException
1:     {
1:         PreparedStatement countCongloms =
1:             prepareStatement(COUNT_TABLE_CONGLOMS);
1: 
1:         Statement st = createStatement();
1: 
1:         st.execute("create table orders (no_w_id int not null, " +
1:             "no_d_id int not null, no_o_id int not null, info varchar(20), " +
1:             "constraint orders_pk primary key (no_w_id, no_d_id, no_o_id))");
1: 
1:         st.execute("insert into orders values (1, 2, 3, 'info # one')");
1:         st.execute("insert into orders values (1, 2, 4, 'info # two')");
1:         st.execute("insert into orders values (1, 2, 5, 'info # 3')");
1: 
1:         st.execute("create table neworders (no_w_id int not null, " +
1:             "no_d_id int not null, no_o_id int not null, lname varchar(50))");
1: 
1:         st.execute("alter table neworders add constraint " +
1:             "neworders_pk primary key (no_w_id, no_d_id, no_o_id)");
1: 
1:         st.execute("alter table neworders add constraint " +
1:               "no_o_fk foreign key (no_w_id, no_d_id, no_o_id) " +
1:             "references orders");
1: 
1:         st.execute("insert into neworders values (1, 2, 3, 'Inigo')");
1:         st.execute("insert into neworders values (1, 2, 4, 'Montoya')");
1:         st.execute("insert into neworders values (1, 2, 5, 'Tortuga')");
1: 
1:         /* Should have 2 conglomerates on NEWORDERS:
1:          *
1:          *  1. Heap
1:          *  2. NEWORDERS_PK (shared by: NO_O_FK)
1:          */
1:         countConglomerates("NEWORDERS", countCongloms, 2);
1: 
1:         // This should fail due to foreign key.
1:         checkStatementError("23503", st,
1:             "insert into neworders values (1, 3, 5, 'SHOULD FAIL')",
1:             "NO_O_FK");
1: 
1:         // This should fail due to primary key (uniqueness violation).
1:         checkStatementError("23505", st,
1:             "insert into neworders values (1, 2, 4, 'SHOULD FAIL')",
1:             "NEWORDERS_PK");
1: 
1:         /* Now drop the primary key from NEWORDERS.  This should
1:          * drop the implicit uniqueness requirement, as well--i.e.
1:          * the physical conglomerate should become non-unique.
1:          */
1:         st.execute("alter table neworders drop constraint neworders_pk");
1: 
1:         /* Should still have 2 conglomerates because we dropped the
1:          * unique conglomerate from NEWORDER_PK but created another,
1:          * non-unique one for NO_O_FK.
1:          *
1:          *  1. Heap
1:          *  2. NO_O_FK
1:          */
1:         countConglomerates("NEWORDERS", countCongloms, 2);
1: 
1:         // This should still fail due to the foreign key.
1:         checkStatementError("23503", st,
1:             "insert into neworders values (1, 3, 5, 'SHOULD FAIL')",
1:             "NO_O_FK");
1: 
1:         /* This should now succeed because we dropped the backing
1:          * unique index and foreign key constraints are not inherently
1:          * unique. DERBY-3299.
1:          */
1:         st.execute("insert into neworders values (1, 2, 4, 'SHOULD SUCCEED')");
1: 
1:         // Sanity check the table contents.
1:         JDBC.assertUnorderedResultSet(
1:             st.executeQuery("select * from neworders"),
1:             new String [][] {
1:                 {"1", "2", "3", "Inigo"},
1:                 {"1", "2", "4", "Montoya"},
1:                 {"1", "2", "5", "Tortuga"},
1:                 {"1", "2", "4", "SHOULD SUCCEED"}
1:             });
1: 
1:         // Check again using the foreign key's backing index.
1:         JDBC.assertUnorderedResultSet(st.executeQuery(
1:             "select * from neworders --DERBY-PROPERTIES constraint=NO_O_FK"),
1:             new String [][] {
1:                 {"1", "2", "3", "Inigo"},
1:                 {"1", "2", "4", "Montoya"},
1:                 {"1", "2", "5", "Tortuga"},
1:                 {"1", "2", "4", "SHOULD SUCCEED"}
1:             });
1: 
1:         st.execute("drop table neworders");
1:         st.execute("drop table orders");
1:         countConglomerates("NEWORDERS", countCongloms, 0);
1: 
1:         countCongloms.close();
1:         st.close();
1:     }
1: 
1:     /**
1:      * Test various conditions in which a constraint can be dropped,
1:      * and verify that if the constraint's backing conglomerate is
1:      * shared, we do the right thing.
1:      */
1:     public void testConstraintDrops() throws SQLException
1:     {
1:         PreparedStatement countCongloms =
1:             prepareStatement(COUNT_TABLE_CONGLOMS);
1: 
1:         PreparedStatement getConstraintNames =
1:             prepareStatement(GET_CONSTRAINT_NAMES);
1: 
1:         Statement st = createStatement();
1: 
1:         st.execute("create table dropc_t0 (i int not null, j int not null)");
1:         st.execute("alter table dropc_t0 " +
1:             "add constraint dropc_pk0 primary key (i,j)");
1: 
1:         /* Should have 2 conglomerates on DROPC_T0:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_PK0
1:          */
1:         countConglomerates("DROPC_T0", countCongloms, 2);
1: 
1:         st.execute("create table dropc_t1 (i int, j int not null)");
1:         st.execute("alter table dropc_t1 " +
1:             "add constraint dropc_pk1 primary key (j)");
1: 
1:         /* Should have 2 conglomerates on DROPC_T1:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_PK1
1:          */
1:         countConglomerates("DROPC_T1", countCongloms, 2);
1: 
1:         st.execute("create table dropc_t2 " +
1:             "(a int, b int not null, c int not null)");
1:         st.execute("create index dropc_ix1 on dropc_t2 (a,b)");
1:         st.execute("create unique index dropc_uix2 on dropc_t2 (c)");
1: 
1:         st.execute("alter table dropc_t2 " +
1:             "add constraint dropc_uc1 unique (c)");
1:         st.execute("alter table dropc_t2 add constraint " +
1:             "dropc_fk0 foreign key (a,b) references dropc_t0");
1:         st.execute("alter table dropc_t2 add constraint " +
1:             "dropc_fk1 foreign key (a,b) references dropc_t0");
1:         st.execute("alter table dropc_t2 add constraint " +
1:             "dropc_fk2 foreign key (c) references dropc_t1");
1: 
1:         /* Should have 3 conglomerates on DROPC_T2:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK0, DROPC_FK1)
1:          *  3. DROPC_UIX2 (shared by: DROPC_UC1, DROPC_FK2)
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 3);
1: 
1:         st.execute("insert into dropc_t0 values (1, 2)");
1:         st.execute("insert into dropc_t1 values (3, 4)");
1:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1: 
1:         /* DROP 1: First and obvious way to drop a constraint is
1:          * with an ALTER TABLE DROP CONSTRAINT command.
1:          */
1: 
1:         /* Drop constraint DROPC_FK0.  Since both DROPC_IX1 and
1:          * DROPC_FK1 require a physical conglomerate identical
1:          * to that of DROPC_FK0 (esp. non-unique on the same
1:          * columns), dropping the latter constraint should have
1:          * no effect on the physical conglomerate.
1:          */
1: 
1:         st.execute("alter table DROPC_T2 drop constraint DROPC_FK0");
1: 
1:         /* Should still have 3 conglomerates on DROPC_T2:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          *  3. DROPC_UIX2 (shared by: DROPC_UC1, DROPC_FK2)
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 3);
1: 
1:         /* Check that all non-dropped constraint stills exist and
1:          * can be used for queries.
1:          */
1:         verifyConstraints(
1:             st, getConstraintNames, "DROPC_T2", "DROPC_FK0",
1:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"},{"DROPC_UC1"}},
1:             1);
1: 
1:         // Make sure non-dropped constraints are still enforced.
1: 
1:         checkStatementError("23505", st,
0:             "insert into dropc_t2 values (1, 2, 4)", "DROPC_UIX2");
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1: 
1:         /* Drop constraint DROPC_UC1.  Since DROPC_UIX2 requires
1:          * a physical conglomerate identical to that of DROPC_UC1
1:          * (esp. unique on the same columns), dropping the latter
1:          * constraint should have no effect on the physical
1:          * conglomerate.
1:          */
1: 
1:         st.execute("alter table DROPC_T2 drop constraint DROPC_UC1");
1: 
1:         /* Should still have 3 conglomerates on DROPC_T2:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          *  3. DROPC_UIX2 (shared by: DROPC_FK2)
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 3);
1: 
1:         /* Check that all non-dropped constraints still exist and
1:          * can be used for queries.
1:          */
1:         verifyConstraints(
1:             st, getConstraintNames, "DROPC_T2", "DROPC_UC1",
1:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"}},
1:             1);
1: 
1:         // Make sure non-dropped constraints are still enforced.
1: 
1:         checkStatementError("23505", st,
0:             "insert into dropc_t2 values (1, 2, 4)", "DROPC_UIX2");
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1: 
1:         /* DROP 2: We don't drop the constraint, but we drop a user
1:          * index that shares a physical conglomerate with a constraint.
1:          * In this case we drop DROPC_UIX2.  Since DROPC_FK2 is the only
1:          * constraint that shares with DROPC_UIX2, and since DROPC_FK2
1:          * is NON-unique while DROPC_UIX2 is unique, we should drop
1:          * the unique physical conglomerate and create a non-unique
1:          * one.
1:          */
1: 
1:         st.execute("drop index dropc_uix2");
1: 
1:         /* Should still have 3 conglomerates on DROPC_T2:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          *  3. DROPC_FK2
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 3);
1: 
1:         /* Check that all non-dropped constraints still exist and
1:          * can be used for queries.
1:          */
1:         verifyConstraints(
1:             st, getConstraintNames, "DROPC_T2", null,
1:             new String [][] {{"DROPC_FK1"},{"DROPC_FK2"}},
1:             1);
1: 
1:         // Make sure non-dropped constraints are still enforced.
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (2, 2, 4)", "DROPC_FK1");
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (1, 2, 3)", "DROPC_FK2");
1: 
1:         /* This should now succeed because there is no longer any
1:          * requirement for uniqueness.
1:          */
1:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1: 
1:         JDBC.assertUnorderedResultSet(
1:             st.executeQuery("select * from dropc_t2"),
1:             new String [][] {
1:                 {"1", "2", "4"},
1:                 {"1", "2", "4"}
1:             });
1: 
1:         /* Recreate the unique constraint DROPC_UC1 for next test, and
1:          * make DROPC_FK2 share with it again.
1:          */
1: 
1:         st.execute("delete from dropc_t2");
1:         st.execute("insert into dropc_t2 values (1, 2, 4)");
1:         st.execute("alter table dropc_t2 drop constraint dropc_fk2");
1:         countConglomerates("DROPC_T2", countCongloms, 2);
1: 
1:         st.execute("alter table dropc_t2 " +
1:             "add constraint dropc_uc1 unique (c)");
1:         st.execute("alter table dropc_t2 add constraint " +
1:             "dropc_fk2 foreign key (c) references dropc_t1");
1: 
1:         /* Also create unique index that will be dropped as part of
1:          * the next test, as well--we want to exercise that code
1:          * path, even if there is no conglomerate sharing involved
1:          * for this particular case.
1:          */
1:         st.execute("create unique index dropc_uix3 on dropc_t2 (a, c)");
1: 
1:         /* So we should now have:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          *  3. DROPC_UC1 (shared by: DROPC_FK2)
1:          *  4. DROPC_UIX3
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 4);
1: 
1:         /* DROP 3: Third way to drop a constraint is to drop a
1:          * column on which the constraint depends.  Here we drop
1:          * column C, which will cause both DROPC_UC1 and DROPC_FK2
1:          * to be implicitly dropped, as well. Additionally, DROPC_UIX3
1:          * should be dropped because it is a unique index that relies
1:          * on the dropped column; since it doesn't share its
1:          * conglomerate with anything else, that physical conglom
1:          * should be dropped here, as well.
1:          */
1:         st.execute("alter table dropc_t2 drop column c");
1: 
1:         /* Should now only have 2 conglomerates on DROPC_T2:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 2);
1: 
1:         /* Check that all non-dropped constraint still exist and
1:          * can be used for queries.
1:          */
1:         verifyConstraints(
1:             st, getConstraintNames, "DROPC_T2", "DROPC_FK2",
1:             new String [][] {{"DROPC_FK1"}},
1:             1);
1: 
1:         // Make sure non-dropped constraints are still enforced.
1: 
1:         checkStatementError("23503", st,
1:             "insert into dropc_t2 values (2, 2)", "DROPC_FK1");
1: 
1:         /* DROP 4: If privileges to a table are revoked, a constraint
1:          * (esp. a foreign key constraint) that references that table
1:          * will be dropped.  Test case for this should exist in
1:          * GrantRevokeDDLTest.java.
1:          */
1: 
1:         /* Make a a non-unique constraint share a conglomerate with
1:          * a unique constraint, in prep for the next test case.
1:          */
1: 
1:         st.execute("delete from dropc_t2");
1:         st.execute("alter table dropc_t2 " +
1:             "add constraint dropc_uc2 unique (b)");
1:         st.execute("alter table dropc_t2 add constraint " +
1:             "dropc_fk3 foreign key (b) references dropc_t1");
1: 
1:         /* So we should now have:
1:          *
1:          *  1. Heap
1:          *  2. DROPC_IX1 (shared by: DROPC_FK1)
1:          *  3. DROPC_UC2 (shared by: DROPC_FK3)
1:          */
1:         countConglomerates("DROPC_T2", countCongloms, 3);
1: 
1:         /* DROP 5: Final way to drop a constraint is to drop the
1:          * table on which the constraint exists.  Derby will first
1:          * drop all columns, then drop all constraints, and finally,
1:          * drop all indexes.  Make sure the drop succeeds without
1:          * error and that all physical conglomerates are dropped
1:          * as well.
1:          */
1:         st.execute("drop table dropc_t2");
1: 
1:         // There shouldn't be any conglomerates left...
1:         countConglomerates("DROPC_T2", countCongloms, 0);
1:         assertStatementError("42X05", st, "select * from dropc_t2");
1: 
1:         // Clean up.
1:         st.execute("drop table dropc_t1");
1:         st.execute("drop table dropc_t0");
1:         getConstraintNames.close();
1:         countCongloms.close();
1:         st.close();
1:     }
1: 
1:     /**
1:      * Count the number of physical conglomerates that exist for
1:      * the received table, and assert that the number found matches
1:      * the expected number.
1:      */
1:     private void countConglomerates(String tableName,
1:         PreparedStatement countCongloms, int expected)
1:         throws SQLException
1:     {
1:         countCongloms.setString(1, tableName);
1:         JDBC.assertSingleValueResultSet(
1:             countCongloms.executeQuery(), String.valueOf(expected));
1:         return;
1:     }
1: 
1:     /**
1:      * Execute the received statement and assert that:
1:      *
1:      *  1. The statement fails, and
1:      *  1. The SQLSTATE for the failure matches the received SQL
1:      *     state, and
1:      *  2. The failure exception includes the received index/
1:      *     constraint name in its message.  This is intended to
1:      *     be used for uniqueness and foreign key violations,
1:      *     esp. SQLSTATE 23503 and 23505.
1:      */
1:     private void checkStatementError(String sqlState,
0:         Statement st, String query, String ixOrConstraint)
1:         throws SQLException
1:     {
1:         try {
1: 
1:             st.execute(query);
1:             fail("Expected error '" + sqlState + "' when executing a " +
1:                 "statement, but no error was thrown.");
1: 
1:         } catch (SQLException se) {
1: 
1:             assertSQLState(sqlState, se);
0:             if (se.getMessage().indexOf(ixOrConstraint) == -1)
1:             {
1:                 fail("Error " + sqlState + " should have been caused " +
0:                     "by index/constraint '" + ixOrConstraint + "' but " +
0:                     "'" + ixOrConstraint + "' did not appear in the " +
0:                     "following error message: \"" + se.getMessage() + "\"");
1:             }
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Do various checks to ensure that the constraint has truly
1:      * been dropped.  Then do simple SELECT queries using optimizer
1:      * overrides to verify that all expected remaining constraints
1:      * still exist, and that their backing indexes all contain the
1:      * expected number of rows.
1:      */
1:     private void verifyConstraints(Statement st,
1:         PreparedStatement constraintNames, String tName,
1:         String constraintName, String [][] remainingConstraints,
1:         int numRowsExpected) throws SQLException
1:     {
1:         constraintNames.setString(1, tName);
1:         ResultSet constraints = constraintNames.executeQuery();
1:         if (remainingConstraints == null)
1:             JDBC.assertEmpty(constraints);
1:         else
1:             JDBC.assertUnorderedResultSet(constraints, remainingConstraints);
1: 
1:         String select = "select * from " +
1:             tName + " --DERBY-PROPERTIES constraint=";
1: 
1:         /* Make sure the dropped constraint is no longer visible
1:          * from SQL.
1:          */
1:         if (constraintName != null)
1:             assertStatementError("42Y48", st, select + constraintName);
1: 
1:         JDBC.assertDrainResults(st.executeQuery(
1:             "select * from " + tName), numRowsExpected);
1: 
1:         if (remainingConstraints == null)
1:             return;
1: 
1:         /* Run through the remaining constraints and do a simple
1:          * SELECT with each one (via optimizer overrides) as a
1:          * sanity check that we see the correct number of rows.
1:          */
1:         for (int i = 0; i < remainingConstraints.length; i++)
1:         {
1:             JDBC.assertDrainResults(
1:                 st.executeQuery(select + remainingConstraints[i][0]),
1:                 numRowsExpected);
1:         }
1: 
1:         return;
1:     }
1: }
============================================================================