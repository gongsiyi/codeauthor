1:28c4dc4: /*
1:28c4dc4: 
1:28c4dc4:    Class org.apache.derby.optional.dump.DataFileVTI
1:28c4dc4: 
1:28c4dc4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:28c4dc4:    contributor license agreements.  See the NOTICE file distributed with
1:28c4dc4:    this work for additional information regarding copyright ownership.
1:28c4dc4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:28c4dc4:    (the "License"); you may not use this file except in compliance with
1:28c4dc4:    the License.  You may obtain a copy of the License at
1:28c4dc4: 
1:28c4dc4:       http://www.apache.org/licenses/LICENSE-2.0
1:28c4dc4: 
1:28c4dc4:    Unless required by applicable law or agreed to in writing, software
1:28c4dc4:    distributed under the License is distributed on an "AS IS" BASIS,
1:28c4dc4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:28c4dc4:    See the License for the specific language governing permissions and
1:28c4dc4:    limitations under the License.
1:28c4dc4: 
1:28c4dc4:  */
1:28c4dc4: 
1:28c4dc4: package org.apache.derby.optional.dump;
1:28c4dc4: 
1:28c4dc4: import java.io.ByteArrayInputStream;
1:28c4dc4: import java.io.DataInput;
1:28c4dc4: import java.io.DataInputStream;
1:28c4dc4: import java.io.EOFException;
1:28c4dc4: import java.io.FileInputStream;
1:28c4dc4: import java.io.File;
1:28c4dc4: import java.io.InputStream;
1:28c4dc4: import java.io.IOException;
1:28c4dc4: import java.io.PrintWriter;
1:28c4dc4: import java.io.RandomAccessFile;
1:28c4dc4: import java.io.StringWriter;
1:28c4dc4: import java.math.BigDecimal;
1:28c4dc4: import java.security.AccessController;
1:28c4dc4: import java.sql.Blob;
1:28c4dc4: import java.sql.Clob;
1:28c4dc4: import java.sql.Connection;
1:28c4dc4: import java.sql.Date;
1:28c4dc4: import java.sql.DriverManager;
1:28c4dc4: import java.sql.PreparedStatement;
1:28c4dc4: import java.sql.ResultSet;
1:28c4dc4: import java.sql.ResultSetMetaData;
1:28c4dc4: import java.sql.SQLException;
1:28c4dc4: import java.sql.Time;
1:28c4dc4: import java.sql.Timestamp;
1:28c4dc4: import java.sql.SQLWarning;
1:28c4dc4: import java.util.ArrayList;
1:28c4dc4: import java.util.Calendar;
1:28c4dc4: import java.util.Properties;
1:28c4dc4: 
1:28c4dc4: import org.apache.derby.authentication.UserAuthenticator;
1:28c4dc4: import org.apache.derby.catalog.TypeDescriptor;
1:28c4dc4: import org.apache.derby.iapi.reference.Property;
1:28c4dc4: import org.apache.derby.iapi.services.crypto.CipherFactory;
1:28c4dc4: import org.apache.derby.iapi.services.crypto.CipherProvider;
1:28c4dc4: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:28c4dc4: import org.apache.derby.iapi.services.io.CompressedNumber;
1:28c4dc4: import org.apache.derby.iapi.services.io.FormatIdInputStream;
1:28c4dc4: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:28c4dc4: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:28c4dc4: import org.apache.derby.iapi.services.io.StreamStorable;
1:28c4dc4: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1:28c4dc4: import org.apache.derby.iapi.store.raw.Page;
1:28c4dc4: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:28c4dc4: import org.apache.derby.iapi.types.DataValueDescriptor;
1:28c4dc4: import org.apache.derby.iapi.util.StringUtil;
1:28c4dc4: import org.apache.derby.shared.common.reference.Attribute;
1:28c4dc4: import org.apache.derby.iapi.store.raw.RecordHandle;
1:28c4dc4: import org.apache.derby.impl.jdbc.authentication.JNDIAuthenticationService;
1:28c4dc4: import org.apache.derby.impl.services.jce.JCECipherFactoryBuilder;
1:28c4dc4: import org.apache.derby.impl.store.raw.data.MemByteHolder;
1:28c4dc4: import org.apache.derby.impl.store.raw.data.StoredRecordHeader;
1:28c4dc4: import org.apache.derby.impl.store.raw.data.StoredFieldHeader;
1:28c4dc4: import org.apache.derby.shared.common.reference.SQLState;
1:28c4dc4: import org.apache.derby.vti.VTITemplate;
1:28c4dc4: 
1:28c4dc4: 
1:28c4dc4: /**
1:28c4dc4:  * Table function for reading a data file in the seg0 directory of a
1:28c4dc4:  * Derby database. This is based on the 10.11 version of
1:28c4dc4:  * data records.
1:28c4dc4:  */
1:28c4dc4: public  class   DataFileVTI extends VTITemplate
1:28c4dc4: {
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  CONSTANTS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  static  final   String  SYSSCHEMAS_SIGNATURE = "( schemaID char(36), schemaname varchar(128), authorizationid varchar(128) )";
1:28c4dc4:     public  static  final   String  SYSSCHEMAS_CONGLOMERATE_NAME = "cc0.dat";
1:28c4dc4:     public  static  final   String  SYSTABLES_SIGNATURE = "( tableid char(36), tablename varchar(128), tabletype char(1), schemaid char(36), lockgranularity char(1) )";
1:28c4dc4:     public  static  final   String  SYSTABLES_CONGLOMERATE_NAME = "c60.dat";
1:28c4dc4:     public  static  final   String  SYS_SCHEMA_ID = "8000000d-00d0-fd77-3ed8-000a0a0b1900";
1:28c4dc4:     public  static  final   String  SYSUSERS_SIGNATURE = "( username  varchar( 128 ), hashingscheme  varchar( 32672 ), password  varchar( 32672 ), lastmodified timestamp )";
1:28c4dc4:     public  static  final   String  SYSUSERS_CONGLOMERATE_NAME = "c470.dat";
1:28c4dc4:     public  static  final   String  PROPERTIES_SIGNATURE = "( keyname serializable, payload serializable )";
1:28c4dc4:     public  static  final   String  PROPERTIES_CONGLOMERATE_NAME = "c10.dat";
1:28c4dc4:     
1:28c4dc4:     private static  final   String  COMPILATION_DB = "dfv_compilation_db";
1:28c4dc4:     private static  final   String  DUMMY_TABLE_NAME = "dfv_dummy";
1:28c4dc4: 
1:28c4dc4:     private static  final   long READ_ALL_PAGES = -1L;
1:28c4dc4: 
1:28c4dc4:     public  static final int CHECKSUM_SIZE    = 8;
1:28c4dc4:     public  static final int SMALL_SLOT_SIZE  = 2;
1:28c4dc4:     public  static final int LARGE_SLOT_SIZE  = 4;
1:28c4dc4: 
1:28c4dc4:     // record status
1:28c4dc4:     public static final byte RECORD_HAS_FIRST_FIELD = 0x04;
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  STATE
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     //
1:28c4dc4:     // Filled in from the constructor args.
1:28c4dc4:     //
1:28c4dc4:     private DataFile    _dataFile;
1:28c4dc4: 
1:28c4dc4:     //
1:28c4dc4:     // For controlling the iteration through rows.
1:28c4dc4:     //
1:28c4dc4:     private boolean _opened = false;
1:28c4dc4:     private ArrayList<DataValueDescriptor[]>    _rows;
1:28c4dc4:     private int                 _rowIdx;
1:28c4dc4:     private boolean     _lastColumnWasNull;
1:28c4dc4: 
1:28c4dc4:     // transient state
1:28c4dc4:     private Calendar    _defaultCalendar = Calendar.getInstance();
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  CONSTRUCTOR
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Private constructor which performs decryption but not authentication.
1:28c4dc4:      */
1:28c4dc4:     private  DataFileVTI
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String dataFileName,
1:28c4dc4:          String tableSignature,
1:28c4dc4:          String encryptionProperties
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         Connection  conn = getCompilerConnection();
1:28c4dc4:         DataTypeDescriptor[]   rowSignature = getTypeSignature( conn, tableSignature );
1:28c4dc4: 
1:28c4dc4:         _dataFile = new DataFile
1:28c4dc4:             (
1:28c4dc4:              new File( databaseDirectoryName ),
1:28c4dc4:              dataFileName,
1:28c4dc4:              encryptionProperties,
1:28c4dc4:              rowSignature
1:28c4dc4:              );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /** Public constructor */
1:28c4dc4:     public  DataFileVTI
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String dataFileName,
1:28c4dc4:          String tableSignature,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         this( databaseDirectoryName, dataFileName, tableSignature, encryptionProperties );
1:28c4dc4: 
1:28c4dc4:         authenticate( databaseDirectoryName, encryptionProperties, user, password );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Get a connection to a transient database which is only used to
1:28c4dc4:      * compile table signatures.
1:28c4dc4:      */
1:28c4dc4:     private Connection  getCompilerConnection() throws SQLException
1:28c4dc4:     {
1:28c4dc4:         Connection  conn = DriverManager.getConnection( "jdbc:derby:memory:" + COMPILATION_DB + ";create=true" );
1:28c4dc4: 
1:28c4dc4:         // create the serializable type if it doesn't exist
1:28c4dc4:         PreparedStatement   ps = conn.prepareStatement( "select count(*) from sys.sysaliases where alias = 'SERIALIZABLE'" );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4:         rs.next();
1:28c4dc4:         boolean     alreadyExists = (rs.getInt( 1 ) > 0);
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4: 
1:28c4dc4:         if ( !alreadyExists )
1:28c4dc4:         {
1:28c4dc4:             conn.prepareStatement( "create type serializable external name 'java.io.Serializable' language java" ).execute();
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         return conn;
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     private DataTypeDescriptor[] getTypeSignature( Connection conn, String tableSignature )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         String  createTable = "create table " + DUMMY_TABLE_NAME + tableSignature;
1:28c4dc4:         String  dropTable = "drop table " + DUMMY_TABLE_NAME;
1:28c4dc4: 
1:28c4dc4:         try {
1:28c4dc4:             conn.prepareStatement( createTable ).execute();
1:28c4dc4:         }
1:28c4dc4:         catch (SQLException se)
1:28c4dc4:         {
1:28c4dc4:             throw new Exception( "Illegal table signature: " + tableSignature, se );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         String  select = "select c.columndatatype, c.columnnumber\n" +
1:28c4dc4:             "from sys.syscolumns c, sys.systables t\n" +
1:28c4dc4:             "where c.referenceid = t.tableid\n" +
1:28c4dc4:             "and t.tablename = ?\n" +
1:28c4dc4:             "order by c.columnnumber";
1:28c4dc4:         PreparedStatement   ps = conn.prepareStatement( select );
1:28c4dc4:         ps.setString( 1, DUMMY_TABLE_NAME.toUpperCase() );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4: 
1:28c4dc4:         ArrayList<DataTypeDescriptor>   list = new ArrayList<DataTypeDescriptor>();
1:28c4dc4: 
1:28c4dc4:         while ( rs.next() )
1:28c4dc4:         {
1:28c4dc4:             list.add( DataTypeDescriptor.getType( (TypeDescriptor) rs.getObject( 1 ) ) );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4: 
1:28c4dc4:         DataTypeDescriptor[]    result = new DataTypeDescriptor[ list.size() ];
1:28c4dc4:         list.toArray( result );
1:28c4dc4: 
1:28c4dc4:         conn.prepareStatement( dropTable ).execute();
1:28c4dc4: 
1:28c4dc4:         return result;
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     private static  void    skipBytes( DataInputStream dais, int bytesToSkip ) throws IOException
1:28c4dc4:     {
1:28c4dc4:         int     actualBytesSkipped = dais.skipBytes( bytesToSkip );
1:28c4dc4: 
1:28c4dc4:         if ( actualBytesSkipped != bytesToSkip )
1:28c4dc4:         {
1:28c4dc4:             throw new IOException( "Expected to skip " + bytesToSkip + " bytes but only skipped " + actualBytesSkipped + " bytes." );
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     // See FileContainer.decryptPage()
1:28c4dc4:     private static  byte[] decryptPage( CipherProvider decryptionEngine, byte[] cipherText ) throws IOException
1:28c4dc4:     {
1:28c4dc4:         try {
1:28c4dc4:             int     pageSize = cipherText.length;
1:28c4dc4:             byte[]  clearText = new byte[ pageSize ];
1:28c4dc4:         
1:28c4dc4:             int len = decryptionEngine.decrypt( cipherText, 0, pageSize, clearText, 0 );
1:28c4dc4:         
1:28c4dc4:             if ( len != pageSize )
1:28c4dc4:             {
1:28c4dc4:                 throw new IOException( "Expected to decrypt " + pageSize + " bytes but actually decrypted " + len + " bytes." );
1:28c4dc4:             }
1:28c4dc4:         
1:28c4dc4:             // need to put the checksum where it belongs
1:28c4dc4:             System.arraycopy( clearText, 8, cipherText, 0, pageSize-8);
1:28c4dc4:             System.arraycopy( clearText, 0, cipherText, pageSize-8, 8);
1:28c4dc4:         
1:28c4dc4:             return cipherText;
1:28c4dc4:         } catch( Exception e) { throw new IOException( e ); }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  AUTHENTICATION
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     
1:28c4dc4:     /**
1:28c4dc4:      * Authenticate the user's permission to access the raw database.
1:28c4dc4:      * The following hurdles must be passed. Otherwise, an exception is raised.
1:28c4dc4:      *
1:28c4dc4:      * <ul>
1:28c4dc4:      * <li>The user must be the DBO of the raw database.</li>
1:28c4dc4:      * <li>If there are any tuples in the SYSUSERS catalog of the raw database, then the supplied credentials must match
1:28c4dc4:      * what's in SYSUSERS.</li>
1:28c4dc4:      * <li>If the database properties of the raw database specify an authentication scheme,
1:28c4dc4:      * then that scheme must be applied to the supplied credentials.</li>
1:28c4dc4:      * </ul>
1:28c4dc4:      */
1:28c4dc4:     private void    authenticate
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         vetDBO( databaseDirectoryName, encryptionProperties, user );
1:28c4dc4:         if ( vetNative( databaseDirectoryName, encryptionProperties, user, password ) ) { return; }
1:28c4dc4:         vetRawAuthentication( databaseDirectoryName, encryptionProperties, user, password );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Verify that the user is the DBO of the raw database.
1:28c4dc4:      */
1:28c4dc4:     private void    vetDBO
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         boolean isDBO = false;
1:28c4dc4:         boolean foundSYSIBM = false;
1:28c4dc4: 
1:28c4dc4:         if ( user != null )
1:28c4dc4:         {
1:28c4dc4:             String          authorizationID = StringUtil.normalizeSQLIdentifier( user );
1:28c4dc4:             DataFileVTI    sysschemas = new DataFileVTI
1:28c4dc4:                 (
1:28c4dc4:                  databaseDirectoryName,
1:28c4dc4:                  SYSSCHEMAS_CONGLOMERATE_NAME,
1:28c4dc4:                  SYSSCHEMAS_SIGNATURE,
1:28c4dc4:                  encryptionProperties
1:28c4dc4:                  );
1:28c4dc4: 
1:28c4dc4:             while( sysschemas.next() )
1:28c4dc4:             {
1:28c4dc4:                 if ( "SYSIBM".equals( sysschemas.getString( 2 ) ) )
1:28c4dc4:                 {
1:28c4dc4:                     foundSYSIBM = true;
1:28c4dc4:                     if ( sysschemas.getString( 3 ).equals( authorizationID ) ) { isDBO = true; }
1:28c4dc4:                     break;
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4:             sysschemas.close();
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         if ( !foundSYSIBM )
1:28c4dc4:         {
1:28c4dc4:             throw new Exception
1:28c4dc4:                 (
1:28c4dc4:                  "Could not read database at " + databaseDirectoryName +
1:28c4dc4:                  ". Maybe it is encrypted and the wrong encryption key was supplied."
1:28c4dc4:                  );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         if ( !isDBO )
1:28c4dc4:         {
1:28c4dc4:             throw new Exception( user + " is not the owner of the database at " + databaseDirectoryName );
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * If NATIVE authentication is on, then the user's credentials must be stored in SYSUSERS.
1:28c4dc4:      * Returns false if NATIVE authentication is not on. Raises an exception if NATIVE
1:28c4dc4:      * authentication is on and the credentials don't match.
1:28c4dc4:      */
1:28c4dc4:     private boolean    vetNative
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         String          authorizationID = StringUtil.normalizeSQLIdentifier( user );
1:28c4dc4:         DataFileVTI    systables = new DataFileVTI
1:28c4dc4:             (
1:28c4dc4:              databaseDirectoryName,
1:28c4dc4:              SYSTABLES_CONGLOMERATE_NAME,
1:28c4dc4:              SYSTABLES_SIGNATURE,
1:28c4dc4:              encryptionProperties
1:28c4dc4:              );
1:28c4dc4:         boolean sysusersExists = false;
1:28c4dc4: 
1:28c4dc4:         while( systables.next() )
1:28c4dc4:         {
1:28c4dc4:             if ( SYS_SCHEMA_ID.equals( systables.getString( 4 ) ) )
1:28c4dc4:             {
1:28c4dc4:                 if ( "SYSUSERS".equals( systables.getString( 2 ) ) )
1:28c4dc4:                 {
1:28c4dc4:                     sysusersExists = true;
1:28c4dc4:                     break;
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4:         systables.close();
1:28c4dc4: 
1:28c4dc4:         // nothing more to check if the database doesn't even have a SYSUSERS catalog
1:28c4dc4:         if ( !sysusersExists ) { return false; }
1:28c4dc4: 
1:28c4dc4:         //
1:28c4dc4:         // See whether the user's credentials should be and are in SYSUSERS.
1:28c4dc4:         //
1:28c4dc4:         
1:28c4dc4:         DataFileVTI    sysusers = new DataFileVTI
1:28c4dc4:             (
1:28c4dc4:              databaseDirectoryName,
1:28c4dc4:              SYSUSERS_CONGLOMERATE_NAME,
1:28c4dc4:              SYSUSERS_SIGNATURE,
1:28c4dc4:              encryptionProperties
1:28c4dc4:              );
1:28c4dc4:         boolean credentialsShouldBePresent = false;
1:28c4dc4:         boolean credentialsMatch = false;
1:28c4dc4:             
1:28c4dc4:         while( sysusers.next() )
1:28c4dc4:         {
1:28c4dc4:             credentialsShouldBePresent = true;
1:28c4dc4: 
1:28c4dc4:             if ( sysusers.getString( 1 ).equals( authorizationID ) )
1:28c4dc4:             {
1:28c4dc4:                 String  hashingScheme = sysusers.getString( 2 );
1:28c4dc4:                 String  actualPassword = sysusers.getString( 3 );
1:28c4dc4:                 PasswordHasher  hasher = new PasswordHasher( hashingScheme );
1:28c4dc4:                 String  candidatePassword = hasher.hashPasswordIntoString( authorizationID, password );
1:28c4dc4: 
1:28c4dc4:                 credentialsMatch = actualPassword.equals( candidatePassword );
1:28c4dc4: 
1:28c4dc4:                 break;
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4:         sysusers.close();
1:28c4dc4: 
1:28c4dc4:         if ( !credentialsShouldBePresent ) { return false; }
1:28c4dc4:         if ( credentialsMatch ) { return true; }
1:28c4dc4:         else
1:28c4dc4:         {
1:28c4dc4:             throw new Exception( "Bad NATIVE credentials." );
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * If an authentication scheme is specified by database properties in the raw
1:28c4dc4:      * database, then use that scheme to validate the credentials.
1:28c4dc4:      */
1:28c4dc4:     private void    vetRawAuthentication
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         Properties  props = readDatabaseProperties( databaseDirectoryName, encryptionProperties );
1:28c4dc4: 
1:28c4dc4: 		String requireAuthentication = props.getProperty( Property.REQUIRE_AUTHENTICATION_PARAMETER );
1:28c4dc4: 		if ( !Boolean.valueOf( requireAuthentication ).booleanValue() ) { return; }
1:28c4dc4:         
1:28c4dc4: 		String provider = props.getProperty( Property.AUTHENTICATION_PROVIDER_PARAMETER );
1:28c4dc4:         if ( provider == null ) { return; } // no provider specified
1:28c4dc4: 
1:28c4dc4:         // the provider cannot be NATIVE. that case was handled above by vetNative()
1:28c4dc4: 
1:28c4dc4:         boolean authenticated;
1:28c4dc4:         
1:28c4dc4: 		if ( StringUtil.SQLEqualsIgnoreCase( provider, Property.AUTHENTICATION_PROVIDER_LDAP ) )
1:28c4dc4:         { authenticated = vetLDAP( props, databaseDirectoryName, user, password ); }
1:28c4dc4: 		else if ( StringUtil.SQLEqualsIgnoreCase( provider, Property.AUTHENTICATION_PROVIDER_BUILTIN ) )
1:28c4dc4:         { authenticated = vetBuiltin( props, user, password ); }
1:28c4dc4:         else { authenticated = vetCustom( provider, databaseDirectoryName, user, password ); }
1:28c4dc4: 
1:28c4dc4:         if ( !authenticated )
1:28c4dc4:         {
1:28c4dc4:             throw new Exception( "Authentication failed using provider " + provider );
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Match credentials using an LDAP server.
1:28c4dc4:      */
1:28c4dc4:     private boolean vetLDAP
1:28c4dc4:         (
1:28c4dc4:          Properties dbProps,
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         LDAPService   authenticator = new LDAPService( dbProps );
1:28c4dc4: 
1:28c4dc4:         authenticator.boot( false, dbProps );
1:28c4dc4: 
1:28c4dc4:         Properties  userInfo = new Properties();
1:28c4dc4:         userInfo.setProperty( Attribute.USERNAME_ATTR, user );
1:28c4dc4:         userInfo.setProperty( Attribute.PASSWORD_ATTR, password );
1:28c4dc4: 
1:28c4dc4:         return authenticator.authenticate( databaseDirectoryName, userInfo );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     /**
1:28c4dc4:      * Match credentials against the BUILTIN credentials stored in the properties
1:28c4dc4:      * conglomerate of the raw database. All of those properties have been read
1:28c4dc4:      * into the props object already.
1:28c4dc4:      */
1:28c4dc4:     private boolean vetBuiltin
1:28c4dc4:         (
1:28c4dc4:          Properties props,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         String  passwordProperty = Property.USER_PROPERTY_PREFIX.concat( user );
1:28c4dc4:         String  realPassword = props.getProperty( passwordProperty );
1:28c4dc4: 
1:28c4dc4:         if ( realPassword != null )
1:28c4dc4:         {
1:28c4dc4:             PasswordHasher  hasher = new PasswordHasher( realPassword );
1:28c4dc4: 
1:28c4dc4:             password = hasher.hashAndEncode( user, password );
1:28c4dc4:         }
1:28c4dc4:         else
1:28c4dc4:         {
1:28c4dc4:             realPassword = getSystemProperty( passwordProperty );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         return ( (realPassword != null) && realPassword.equals( password ) );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     /**
1:28c4dc4:      * Validate credentials using a custom authenticator.
1:28c4dc4:      */
1:28c4dc4:     private boolean vetCustom
1:28c4dc4:         (
1:28c4dc4:          String customProvider,
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:4469400:         Class<?> clazz = Class.forName( customProvider );
1:4469400:         UserAuthenticator   authenticator = (UserAuthenticator) clazz.getConstructor().newInstance();
1:28c4dc4: 
1:28c4dc4:         return authenticator.authenticateUser( user, password, databaseDirectoryName, new Properties() );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     /**
1:28c4dc4:      * Get system property.
1:28c4dc4:      */
1:28c4dc4:     private static String getSystemProperty( final String name)
1:28c4dc4: 	{
1:28c4dc4:         return AccessController.doPrivileged
1:28c4dc4:             ( new java.security.PrivilegedAction<String>()
1:28c4dc4:                 {
1:28c4dc4:                     public String run() { return System.getProperty( name ); }
1:28c4dc4:                 }
1:28c4dc4:             );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Read the properties conglomerate of the raw database.
1:28c4dc4:      */
1:28c4dc4:     private Properties  readDatabaseProperties
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String encryptionProperties
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         Properties  retval = new Properties();
1:28c4dc4:         
1:28c4dc4:         DataFileVTI    pc = new DataFileVTI
1:28c4dc4:             (
1:28c4dc4:              databaseDirectoryName,
1:28c4dc4:              PROPERTIES_CONGLOMERATE_NAME,
1:28c4dc4:              PROPERTIES_SIGNATURE,
1:28c4dc4:              encryptionProperties
1:28c4dc4:              );
1:28c4dc4: 
1:28c4dc4:         while( pc.next() )
1:28c4dc4:         {
1:28c4dc4:             int col = 1;
1:28c4dc4:             Object  key = pc.getObject( col++ );
1:28c4dc4:             Object  value = pc.getObject( col++ );
1:28c4dc4: 
1:28c4dc4:             retval.put( key, value );
1:28c4dc4:         }
1:28c4dc4:         pc.close();
1:28c4dc4: 
1:28c4dc4:         return retval;
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  TABLE FUNCTION
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Entry point declared in the external name clause of a CREATE FUNCTION statement.
1:28c4dc4:      */
1:28c4dc4:     public  static  DataFileVTI dataFileVTI
1:28c4dc4:         (
1:28c4dc4:          String databaseDirectoryName,
1:28c4dc4:          String dataFileName,
1:28c4dc4:          String tableSignature,
1:28c4dc4:          String encryptionProperties,
1:28c4dc4:          String user,
1:28c4dc4:          String password
1:28c4dc4:          )
1:28c4dc4:         throws Exception
1:28c4dc4:     {
1:28c4dc4:         return new DataFileVTI( databaseDirectoryName, dataFileName, tableSignature, encryptionProperties, user, password );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     private SQLException    wrap( Throwable t )
1:28c4dc4:     {
1:28c4dc4:         return new SQLException( t.getMessage(), t );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     private SQLException    wrap( String errorMessage )
1:28c4dc4:     {
1:28c4dc4:         String  sqlState = SQLState.JAVA_EXCEPTION.substring( 0, 5 );
1:28c4dc4: 
1:28c4dc4:         return new SQLException( errorMessage, sqlState );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  VTITemplate IMPLEMENTATION
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  boolean next()  throws SQLException
1:28c4dc4:     {
1:28c4dc4:         if ( _dataFile == null ) { return false; }
1:28c4dc4:         
1:28c4dc4:         try {
1:28c4dc4:             if ( !_opened )
1:28c4dc4:             {
1:28c4dc4:                 _dataFile.openFile();
1:28c4dc4:                 _opened = true;
1:28c4dc4:                 readNextPage();
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             while ( _rows != null )
1:28c4dc4:             {
1:28c4dc4:                 _rowIdx++;
1:28c4dc4: 
1:28c4dc4:                 if ( _rowIdx < _rows.size() ) { return true; }
1:28c4dc4:                 else { readNextPage(); }
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             close();
1:28c4dc4:             return false;
1:28c4dc4:         }
1:28c4dc4:         catch (Throwable t)
1:28c4dc4:         {
1:28c4dc4:             if ( t instanceof SQLException) { throw (SQLException) t; }
1:28c4dc4:             else    { throw wrap( t ); }
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4:     /**
1:28c4dc4:      * Read the next page of rows.
1:28c4dc4:      */
1:28c4dc4:     private void    readNextPage()  throws Exception
1:28c4dc4:     {
1:28c4dc4:         _rows = _dataFile.readNextPage();
1:28c4dc4:         _rowIdx = -1;
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     /** Get the warnings */
1:28c4dc4:     public SQLWarning  getWarnings()
1:28c4dc4:     {
1:28c4dc4:         SQLWarning  firstWarning = null;
1:28c4dc4:         ArrayList<SQLWarning>   warnings = _dataFile.getWarnings();
1:28c4dc4:         if ( (warnings != null) && (warnings.size() > 0) )
1:28c4dc4:         {
1:28c4dc4:             firstWarning = warnings.get( 0 );
1:28c4dc4:             
1:28c4dc4:             // chain the warnings together
1:28c4dc4:             SQLWarning  previous = null;
1:28c4dc4:             for ( SQLWarning warning : warnings )
1:28c4dc4:             {
1:28c4dc4:                 if ( previous != null ) { previous.setNextWarning( warning ); }
1:28c4dc4:                 previous = warning;
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         return firstWarning;
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     public  void    close() throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try {
1:28c4dc4:             if ( _dataFile != null ) { _dataFile.closeFile(); }
1:28c4dc4:         }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:         finally
1:28c4dc4:         {
1:28c4dc4:             _dataFile = null;
1:28c4dc4:             _rows = null;
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     public  ResultSetMetaData   getMetaData()   { return null; }
1:28c4dc4: 
1:28c4dc4:     /** Get a column value (1-based indexing) and check if it's null */
1:28c4dc4:     private DataValueDescriptor getRawColumn( int idx )
1:28c4dc4:     {
1:28c4dc4:         DataValueDescriptor dvd = _rows.get( _rowIdx )[ idx - 1 ];
1:28c4dc4: 
1:28c4dc4:         _lastColumnWasNull = dvd.isNull();
1:28c4dc4: 
1:28c4dc4:         return dvd;
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     
1:28c4dc4:     public boolean wasNull() { return _lastColumnWasNull; }
1:28c4dc4:     
1:28c4dc4:     public String getString(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getString(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public boolean getBoolean(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getBoolean(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public byte getByte(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getByte(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public short getShort(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getShort(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public int getInt(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getInt(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public long getLong(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getLong(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public float getFloat(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getFloat(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public double getDouble(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getDouble(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public byte[] getBytes(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getBytes(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public Date getDate(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getDate( _defaultCalendar ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public Time getTime(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getTime( _defaultCalendar ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public Timestamp getTimestamp(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getTimestamp( _defaultCalendar ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public Object getObject(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getObject(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4:     public BigDecimal getBigDecimal(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return (BigDecimal) getRawColumn( columnIndex ).getObject(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 	public Date getDate(int columnIndex, Calendar cal) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getDate( cal ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 	public Time getTime(int columnIndex, Calendar cal) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getTime( cal ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 	public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return getRawColumn( columnIndex ).getTimestamp( cal ); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 	public Blob getBlob(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return (Blob) getRawColumn( columnIndex ).getObject(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 	public Clob getClob(int columnIndex) throws SQLException
1:28c4dc4:     {
1:28c4dc4:         try { return (Clob) getRawColumn( columnIndex ).getObject(); }
1:28c4dc4:         catch (Throwable t) { throw wrap( t ); }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  NESTED CLASSES
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  LDAP SERVICE
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  static  final   class   LDAPService extends JNDIAuthenticationService
1:28c4dc4:     {
1:28c4dc4:         private Properties  _dbProperties;
1:28c4dc4: 
1:28c4dc4:         public  LDAPService( Properties dbProperties )
1:28c4dc4:         {
1:28c4dc4:             super();
1:28c4dc4:             _dbProperties = dbProperties;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // override to use properties in raw database
1:28c4dc4:         public String getProperty(String key)
1:28c4dc4:         {
1:28c4dc4:             return _dbProperties.getProperty( key );
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  THIS IS THE WORKHORSE FOR THIS PROGRAM
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////
1:28c4dc4:     
1:28c4dc4:     public  static  final   class   DataFile
1:28c4dc4:     {
1:28c4dc4:         // constructor args
1:28c4dc4:         
1:28c4dc4:         private File        _dbDirectory;
1:28c4dc4:         private File            _file;
1:28c4dc4:         private DataTypeDescriptor[]   _rowSignature;
1:28c4dc4:         private CipherProvider  _decryptionEngine;
1:28c4dc4: 
1:28c4dc4:         // control info
1:28c4dc4: 
1:28c4dc4:         private FileInputStream _fis;
1:28c4dc4:         private DataInputStream _dais;
1:28c4dc4:         private long            _pageCount;
1:28c4dc4:         private byte[]          _pageData;
1:28c4dc4:         private int             _pageSize;
1:28c4dc4:         private SlotReader  _slotReader;
1:28c4dc4:         private OverflowStream  _overflowStream;
1:28c4dc4:         private ArrayList<SQLWarning>  _warnings;
1:28c4dc4:     
1:28c4dc4:         public  DataFile
1:28c4dc4:             ( File dbDirectory, String fileName, String encryptionProperties, DataTypeDescriptor[] rowSignature )
1:28c4dc4:             throws Exception
1:28c4dc4:         {
1:28c4dc4:             _dbDirectory = dbDirectory;
1:28c4dc4:             _file = new File( new File( _dbDirectory, "seg0" ), fileName );
1:28c4dc4:             _rowSignature = rowSignature;
1:28c4dc4:             _decryptionEngine = makeDecryptionEngine( encryptionProperties );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private CipherProvider  makeDecryptionEngine( String encryptionProperties ) throws Exception
1:28c4dc4:         {
1:28c4dc4:             if ( encryptionProperties == null ) { return null; }
1:28c4dc4:             
1:28c4dc4:             File    serviceProperties = new File( _dbDirectory, "service.properties" );
1:28c4dc4:             Properties  properties = unpackEncryptionProperties( encryptionProperties );
1:5a3453d:             try (FileInputStream in = new FileInputStream(serviceProperties)) {
1:5a3453d:                 properties.load(in);
1:5a3453d:             }
1:28c4dc4: 
1:28c4dc4:             CipherFactory    cipherFactory =
1:28c4dc4:                 new JCECipherFactoryBuilder()
1:28c4dc4:                 .createCipherFactory( false, properties, false );
1:28c4dc4: 
1:28c4dc4:             return cipherFactory.createNewCipher( CipherFactory.DECRYPT );
1:28c4dc4:         }
1:28c4dc4:         private Properties  unpackEncryptionProperties( String encryptionProperties )
1:28c4dc4:         {
1:28c4dc4:             Properties  retval = new Properties();
1:28c4dc4:             String[]    items = encryptionProperties.split( ";" );
1:28c4dc4: 
1:28c4dc4:             for ( String item : items )
1:28c4dc4:             {
1:28c4dc4:                 int     equalsSignIdx = item.indexOf( "=" );
1:28c4dc4:                 if ( equalsSignIdx > 0 )
1:28c4dc4:                 {
1:28c4dc4:                     String  key = item.substring( 0, equalsSignIdx );
1:28c4dc4:                     String  value = item.substring( equalsSignIdx + 1, item.length() );
1:28c4dc4: 
1:28c4dc4:                     retval.setProperty( key, value );
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             return retval;
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         //
1:28c4dc4:         // Order of operations is:
1:28c4dc4:         //
1:28c4dc4:         //   openFile()
1:28c4dc4:         //   readNextPage() until returns null
1:28c4dc4:         //   closeFile()
1:28c4dc4:         //
1:28c4dc4: 
1:28c4dc4:         public  void    openFile()  throws Exception
1:28c4dc4:         {
1:28c4dc4:             _pageCount = 0L;
1:28c4dc4: 
1:28c4dc4:             _fis = new FileInputStream( _file );
1:28c4dc4:             WrapperInputStream  wis = new WrapperInputStream( _fis );
1:28c4dc4:             _dais = new DataInputStream( wis );
1:28c4dc4:             
1:28c4dc4:             readFileHeader();
1:28c4dc4:             skipToPageEnd( wis );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Closes the file and returns a list of errors or null if no errors. */
1:28c4dc4:         public  void    closeFile() throws Exception
1:28c4dc4:         {
1:28c4dc4:             _dais.close();
1:28c4dc4:             _fis.close();
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Get the errors which accumulated since the last time this method was called. Returns null if no errors. */
1:28c4dc4:         public  ArrayList<SQLWarning>   getWarnings()
1:28c4dc4:         {
1:28c4dc4:             try { return _warnings; }
1:28c4dc4:             finally { _warnings = null; }
1:28c4dc4:         }
1:28c4dc4:         /** Add a warning */
1:28c4dc4:         private void    addWarning( String message, Throwable t )
1:28c4dc4:         {
1:28c4dc4:             if ( _warnings == null ) { _warnings = new ArrayList<SQLWarning>(); }
1:28c4dc4: 
1:28c4dc4:             _warnings.add( new SQLWarning( message, t ) );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         //////////////////
1:28c4dc4:         //
1:28c4dc4:         // FILE HEADER
1:28c4dc4:         //
1:28c4dc4:         //////////////////
1:28c4dc4: 
1:28c4dc4:         private void    readFileHeader() throws Exception
1:28c4dc4:         {
1:28c4dc4:             readAllocPage( _dais, PageHeader.readPageFormatableID( _dais ) );
1:28c4dc4: 
1:28c4dc4:             _pageCount++;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private void    skipToPageEnd( WrapperInputStream wis )   throws Exception
1:28c4dc4:         {
1:28c4dc4:             int          remainingBytesOnPage = getRemainingBytesOnPage( wis );
1:28c4dc4: 
1:28c4dc4:             DataInputStream dais = new DataInputStream( wis );
1:28c4dc4:             if ( remainingBytesOnPage != 0 ) { skipBytes( dais, remainingBytesOnPage ); }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private int getRemainingBytesOnPage( WrapperInputStream wis )
1:28c4dc4:         {
1:28c4dc4:             long        offsetIntoCurrentPage = currentOffsetIntoPage( wis );
1:28c4dc4: 
1:28c4dc4:             int         remainingBytes = ( offsetIntoCurrentPage == 0L ) ? 0 :  (int) (_pageSize - offsetIntoCurrentPage);
1:28c4dc4: 
1:28c4dc4:             return remainingBytes;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private int currentOffsetIntoPage( WrapperInputStream wis )
1:28c4dc4:         {
1:28c4dc4:             return (int) (wis.getBytesRead() % (long)_pageSize);
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         //////////////////
1:28c4dc4:         //
1:28c4dc4:         // PAGE DISPATCH
1:28c4dc4:         //
1:28c4dc4:         //////////////////
1:28c4dc4: 
1:28c4dc4:         /**
1:28c4dc4:          * Returns rows on the next page. Returns null if at EOF.
1:28c4dc4:          */
1:28c4dc4:         public    ArrayList<DataValueDescriptor[]>  readNextPage()
1:28c4dc4:         {
1:28c4dc4:             _pageData = new byte[ _pageSize ];
1:28c4dc4:             
1:28c4dc4:             try {
1:28c4dc4:                 _dais.readFully( _pageData );
1:28c4dc4:             }
1:28c4dc4:             catch (Throwable t)
1:28c4dc4:             {
1:28c4dc4:                 // errors caught here are fatal file stream errors
1:28c4dc4:                 if ( !( t instanceof EOFException ) )   { addWarning( formatThrowable( t, true ), t ); }
1:28c4dc4:                 
1:28c4dc4:                 return null;
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             try {
1:28c4dc4:                 return readNonHeaderPage();
1:28c4dc4:             }
1:28c4dc4:             catch (Throwable t)
1:28c4dc4:             {
1:28c4dc4:                 // errors caught here are localized corruptions or mistakes in the coding of this class
1:28c4dc4:                 addWarning( formatThrowable( t, false ), t );
1:28c4dc4:                 
1:28c4dc4:                 return makeEmptyRowList();
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // returns null if at EOF
1:28c4dc4:         private ArrayList<DataValueDescriptor[]> readNonHeaderPage() throws Exception
1:28c4dc4:         {
1:28c4dc4:             if ( _decryptionEngine != null )    { _pageData = decryptPage( _decryptionEngine, _pageData ); }
1:28c4dc4: 
1:28c4dc4:             WrapperInputStream  wis = new WrapperInputStream( new ByteArrayInputStream( _pageData ) );
1:28c4dc4:             DataInputStream dais = new DataInputStream( wis );
1:28c4dc4:             int pageFormatableID = PageHeader.readPageFormatableID( dais );
1:28c4dc4: 
1:28c4dc4:             ArrayList<DataValueDescriptor[]>    result;
1:28c4dc4:             
1:28c4dc4:             switch( pageFormatableID )
1:28c4dc4:             {
1:28c4dc4:             case StoredFormatIds.RAW_STORE_ALLOC_PAGE:
1:28c4dc4:                 result = readAllocPage( dais, pageFormatableID );
1:28c4dc4:                 break;
1:28c4dc4:             case StoredFormatIds.RAW_STORE_STORED_PAGE:
1:28c4dc4:                 result = formatRows();
1:28c4dc4:                 break;
1:28c4dc4:             default:
1:28c4dc4:                 throw new IOException( "Unknown page formatable ID: " + pageFormatableID );
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             _pageCount++;
1:28c4dc4: 
1:28c4dc4:             return result;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         //////////////////////
1:28c4dc4:         //
1:28c4dc4:         // ALLOCATION PAGES
1:28c4dc4:         //
1:28c4dc4:         //////////////////////
1:28c4dc4: 
1:28c4dc4:         private ArrayList<DataValueDescriptor[]>    readAllocPage( DataInputStream dais, int formatableID ) throws Exception
1:28c4dc4:         {
1:28c4dc4:             if ( formatableID != StoredFormatIds.RAW_STORE_ALLOC_PAGE )
1:28c4dc4:             {
1:28c4dc4:                 throw new IOException
1:28c4dc4:                     (
1:28c4dc4:                      "File header should start with formatable id " + StoredFormatIds.RAW_STORE_ALLOC_PAGE +
1:28c4dc4:                      " but instead starts with formatable id " + formatableID
1:28c4dc4:                      );
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             PageHeader.readPageHeader( dais );
1:28c4dc4:             
1:28c4dc4:             // documented in AllocPage.readAllocPageHeader()
1:28c4dc4:             long    nextAllocPageNumber = dais.readLong();
1:28c4dc4:             long    nextAllocPageOffset = dais.readLong();
1:28c4dc4:             
1:28c4dc4:             skipBytes( dais, 8 + 8 + 8 + 8 );
1:28c4dc4:             
1:28c4dc4:             byte    containerInfoLength = dais.readByte();
1:28c4dc4:             
1:28c4dc4:             if ( containerInfoLength > (byte) 0 ) { readContainerInfo( dais, containerInfoLength ); }
1:28c4dc4: 
1:28c4dc4:             // return empty set of rows
1:28c4dc4:             return new ArrayList<DataValueDescriptor[]>();
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // see FileContainer.writeHeaderToArray() for the format of the container descriptor
1:28c4dc4:         private void    readContainerInfo( DataInputStream dais, byte containerInfoLength )
1:28c4dc4:             throws Exception
1:28c4dc4:         {
1:28c4dc4:             int     formatableID = dais.readInt();
1:28c4dc4:             if ( formatableID != StoredFormatIds.RAW_STORE_SINGLE_CONTAINER_FILE )
1:28c4dc4:             {
1:28c4dc4:                 throw new IOException
1:28c4dc4:                     (
1:28c4dc4:                      "Container info should start with formatable id " + StoredFormatIds.RAW_STORE_SINGLE_CONTAINER_FILE +
1:28c4dc4:                      " but instead starts with formatable id " + formatableID
1:28c4dc4:                      );
1:28c4dc4: 
1:28c4dc4:             }
1:28c4dc4:             
1:28c4dc4:             int containerStatus = dais.readInt();
1:28c4dc4:             
1:28c4dc4:             _pageSize = dais.readInt();
1:28c4dc4:             _slotReader = new SlotReader( _pageSize );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         //////////////////
1:28c4dc4:         //
1:28c4dc4:         // DATA PAGES
1:28c4dc4:         //
1:28c4dc4:         //////////////////
1:28c4dc4: 
1:28c4dc4:         /**
1:28c4dc4:          * Returns the set of rows on a page. If there are no rows on the page,
1:28c4dc4:          * returns a 0-length list of rows.
1:28c4dc4:          */
1:28c4dc4:         private ArrayList<DataValueDescriptor[]>    formatRows() throws Exception
1:28c4dc4:         {
1:28c4dc4:             PageHeader ph = PageHeader.readPageHeader( _pageData );
1:28c4dc4: 
1:28c4dc4:             ArrayInputStream    ais = new ArrayInputStream( _pageData );
1:28c4dc4:                     
1:28c4dc4:             int     recordCount = ph.getSlotsInUse();
1:28c4dc4: 
1:28c4dc4:             ArrayList<DataValueDescriptor[]>    rows = makeEmptyRowList();
1:28c4dc4: 
1:28c4dc4:             // nothing to do if this is an overflow page
1:28c4dc4:             if ( ph.isOverFlowPage() ) { return rows; }
1:28c4dc4: 
1:28c4dc4:             // largely cribbed from StoredPage.recordToString()
1:28c4dc4:             for ( int slot = 0; slot < recordCount; slot++ )
1:28c4dc4:             {
1:28c4dc4:                 // we need this in order to look at the RECORD_HAS_FIRST_FIELD status,
1:28c4dc4:                 // which is not exposed by StoredRecordHeader
1:28c4dc4:                 byte                        recordStatusByte = _pageData[ _slotReader.getRecordOffset( slot, _pageData ) ];
1:28c4dc4:                 StoredRecordHeader  recordHeader = _slotReader.getRecordHeader( slot, _pageData );
1:28c4dc4:                 int     offset = _slotReader.getRecordOffset( slot, _pageData );
1:28c4dc4: 
1:28c4dc4:                 // skip deleted records
1:28c4dc4:                 if ( recordHeader.isDeleted() ) { continue; }
1:28c4dc4: 
1:28c4dc4:                 int     fieldCount = recordHeader.getNumberFields();
1:28c4dc4:                 
1:28c4dc4:                 // move offset past record header to beginning of first field.
1:28c4dc4:                 offset += recordHeader.size();
1:28c4dc4:                 ais.setPosition( offset );
1:28c4dc4:                         
1:28c4dc4:                 if ( fieldCount > 0 )
1:28c4dc4:                 {                            
1:28c4dc4:                     DataValueDescriptor[]   row = makeEmptyRow();
1:28c4dc4:                     boolean     rowIsValid = true;
1:28c4dc4:                         
1:28c4dc4:                     // field layout is described in StoredFieldHeader.write()
1:28c4dc4:                     for ( int fieldIdx = 0; fieldIdx < fieldCount; fieldIdx++ )
1:28c4dc4:                     {
1:28c4dc4:                         int fieldStatus = StoredFieldHeader.readStatus( ais );
1:28c4dc4:                         int fieldDataLength = StoredFieldHeader.readFieldDataLength( ais, fieldStatus, _slotReader.slotFieldSize() );
1:28c4dc4:                         int fieldDataOffset = ais.getPosition();
1:28c4dc4:                         
1:28c4dc4:                         if ( fieldDataLength >= 0 ) // not null?
1:28c4dc4:                         {
1:28c4dc4:                             if ( StoredFieldHeader.isOverflow( fieldStatus ) )
1:28c4dc4:                             {
1:28c4dc4:                                 long overflowPage;
1:28c4dc4:                                 int overflowId;
1:28c4dc4:                                 
1:28c4dc4:                                 // not likely to be a real pointer, this is most
1:28c4dc4:                                 // likely an old column chain where the first field
1:28c4dc4:                                 // is set to overflow even though the second field
1:28c4dc4:                                 // is the overflow pointer
1:28c4dc4:                                 if ( fieldIdx == 0 && fieldDataLength != 3 ) 
1:28c4dc4:                                 {
1:28c4dc4:                                     // figure out where we should go next
1:28c4dc4:                                     offset = ais.getPosition() + fieldDataLength;
1:28c4dc4:                                     overflowPage = CompressedNumber.readLong( (DataInput) ais );
1:28c4dc4:                                     overflowId = CompressedNumber.readInt( (DataInput) ais );
1:28c4dc4:                                     
1:28c4dc4:                                     printIrregularity( "questionable long column" );
1:28c4dc4:                                     
1:28c4dc4:                                     ais.setPosition( offset );
1:28c4dc4:                                 }
1:28c4dc4:                                 else
1:28c4dc4:                                 {
1:28c4dc4:                                     overflowPage = CompressedNumber.readLong( (DataInput) ais );
1:28c4dc4:                                     overflowId = CompressedNumber.readInt( (DataInput) ais );
1:28c4dc4: 
1:28c4dc4:                                     readOverflowField
1:28c4dc4:                                         ( slot, fieldIdx, fieldDataOffset, fieldDataLength, row[ fieldIdx ], overflowPage, overflowId );
1:28c4dc4:                                 }
1:28c4dc4:                                 
1:28c4dc4:                             }   // end if overflow
1:28c4dc4:                             else    // not overflow
1:28c4dc4:                             {
1:28c4dc4:                                 if ( fieldDataLength > 0 )
1:28c4dc4:                                 {
1:28c4dc4:                                     //
1:28c4dc4:                                     // Ignore records which aren't really rows.
1:28c4dc4:                                     //
1:28c4dc4:                                     if (
1:28c4dc4:                                         recordHasFirstField( recordStatusByte )  &&
1:28c4dc4:                                         ( (fieldCount == 1) || (fieldCount != _rowSignature.length) )
1:28c4dc4:                                        )
1:28c4dc4:                                     {
1:28c4dc4:                                         rowIsValid = false;
1:28c4dc4:                                     }
1:28c4dc4:                                     else    // looks like a real row
1:28c4dc4:                                     {
1:28c4dc4:                                         try {
1:28c4dc4:                                             readField( slot, fieldIdx, fieldDataOffset, fieldDataLength, row[ fieldIdx ] );
1:28c4dc4:                                         } catch (Throwable t)
1:28c4dc4:                                         {
1:28c4dc4:                                             rowIsValid = false;
1:28c4dc4:                                         }
1:28c4dc4:                                     }
1:28c4dc4:                                 }
1:28c4dc4:                                 
1:28c4dc4:                                 // go to next field
1:28c4dc4:                                 offset = ais.getPosition() + fieldDataLength;
1:28c4dc4:                                 ais.setPosition(offset);
1:28c4dc4:                             }   // end if not overflow
1:28c4dc4:                         }   // end if not null
1:28c4dc4:                             
1:28c4dc4:                     }   // end loop through fields
1:28c4dc4:                         
1:28c4dc4:                     if ( rowIsValid )
1:28c4dc4:                     {
1:28c4dc4:                         rows.add( row );
1:28c4dc4:                     }
1:28c4dc4:                 }   // end if there are fields
1:28c4dc4:             }   // end of loop through records
1:28c4dc4: 
1:28c4dc4:             return rows;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private DataValueDescriptor[]   makeEmptyRow()  throws Exception
1:28c4dc4:         {
1:28c4dc4:             int columnCount = _rowSignature.length;
1:28c4dc4:             DataValueDescriptor[]   row = new DataValueDescriptor[ columnCount ];
1:28c4dc4: 
1:28c4dc4:             for ( int i = 0; i < columnCount; i++ )
1:28c4dc4:             {
1:28c4dc4:                 row[ i ] = _rowSignature[ i ].getNull();
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             return row;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Make an empty list of rows */
1:28c4dc4:         private ArrayList<DataValueDescriptor[]> makeEmptyRowList() { return new ArrayList<DataValueDescriptor[]>(); }
1:28c4dc4: 
1:28c4dc4:         private boolean recordHasFirstField( byte recordStatus )
1:28c4dc4:         {
1:28c4dc4:             return ( (recordStatus & RECORD_HAS_FIRST_FIELD) != 0 );
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         private void  readField
1:28c4dc4:             ( int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd )
1:28c4dc4:             throws Exception
1:28c4dc4:         {
1:28c4dc4:             try {
1:28c4dc4:                 byte[]  bytes = new byte[ length ];
1:28c4dc4:                 System.arraycopy( _pageData, offset, bytes, 0, length );
1:28c4dc4:                 ArrayInputStream    ais = new ArrayInputStream( bytes );
1:28c4dc4:             
1:28c4dc4:                 dvd.readExternalFromArray( ais );
1:28c4dc4:             }
1:28c4dc4:             catch (Exception e) { formatFieldWarning( recordNumber, fieldNumber, offset, length, dvd, e ); }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private void  readOverflowField
1:28c4dc4:             (
1:28c4dc4:              int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd,
1:28c4dc4:              long overflowPage, int overflowID
1:28c4dc4:              )
1:28c4dc4:             throws Exception
1:28c4dc4:         {
1:28c4dc4:             try {
1:28c4dc4:                 OverflowStream  os = getOverflowStream().init( overflowPage, overflowID );
1:28c4dc4:                 FormatIdInputStream fiis = new FormatIdInputStream( os );
1:28c4dc4: 
1:28c4dc4:                 if ( dvd instanceof StreamStorable ) 
1:28c4dc4:                 {
1:28c4dc4:                     ( (StreamStorable) dvd).setStream( fiis );
1:28c4dc4:                 } 
1:28c4dc4:                 else 
1:28c4dc4:                 {
1:28c4dc4:                     dvd.readExternal( fiis );
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4:             catch (Exception e) { formatFieldWarning( recordNumber, fieldNumber, offset, length, dvd, e ); }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         private OverflowStream  getOverflowStream()
1:28c4dc4:             throws IOException
1:28c4dc4:         {
1:28c4dc4:             if ( _overflowStream == null )
1:28c4dc4:             {
1:28c4dc4:                 _overflowStream = new OverflowStream
1:28c4dc4:                     (
1:28c4dc4:                      new RandomAccessFile( _file, "r" ),
1:28c4dc4:                      _decryptionEngine,
1:28c4dc4:                      _slotReader
1:28c4dc4:                      );
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             return _overflowStream;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         ////////////////////
1:28c4dc4:         //
1:28c4dc4:         // ERROR HANDLING
1:28c4dc4:         //
1:28c4dc4:         ////////////////////
1:28c4dc4: 
1:28c4dc4:         private void  formatFieldWarning
1:28c4dc4:             ( int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd, Throwable e )
1:28c4dc4:         {
1:28c4dc4:             String  errorMessage =
1:28c4dc4:                 "Error reading field data. Offset = " + offset + ", length = " + length +
1:28c4dc4:                 ", datatype = " + _rowSignature[ fieldNumber ].getSQLstring() +
1:28c4dc4:                 ": " + getFieldCoordinates( recordNumber, fieldNumber ) +
1:28c4dc4:                 ": " + formatThrowable( e, false );
1:28c4dc4: 
1:28c4dc4:             addWarning( errorMessage, e );
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         /** Coordinates of field which confused us */
1:28c4dc4:         private String  getFieldCoordinates( int recordNumber, int fieldNumber )
1:28c4dc4:         {
1:28c4dc4:             return
1:28c4dc4:                 "Field " + fieldNumber +
1:28c4dc4:                 " in record " + recordNumber +
1:28c4dc4:                 getPageCoordinates();
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Coordinates of page which confused us */
1:28c4dc4:         private String  getPageCoordinates()
1:28c4dc4:         {
1:28c4dc4:             return
1:28c4dc4:                 " on page " + _pageCount +
1:28c4dc4:                 " in file " + _file.getName();
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Format an error for printing */
1:28c4dc4:         private String  formatThrowable( Throwable e, boolean includeStackTrace )
1:28c4dc4:         {
1:28c4dc4:             StringBuilder   buffer = new StringBuilder();
1:28c4dc4:             buffer.append( e.getClass().getName() + ": " + e.getMessage() );
1:28c4dc4: 
1:28c4dc4:             if ( includeStackTrace )
1:28c4dc4:             {
1:28c4dc4:                 StringWriter    sw = new StringWriter();
1:28c4dc4:                 PrintWriter     pw = new PrintWriter( sw );
1:28c4dc4:                 e.printStackTrace( pw );
1:28c4dc4:                 pw.flush();
1:28c4dc4:                 buffer.append( sw.toString() );
1:28c4dc4:             }
1:28c4dc4:             
1:28c4dc4:             return buffer.toString();
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         /** Print a string */
1:28c4dc4:         private void    println( String text ) { System.out.println( text ); }
1:28c4dc4: 
1:28c4dc4:         /* Print an irregularity */
1:28c4dc4:         private void    printIrregularity( String text ) {}
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     // PAGE HEADER
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  static  final   class   PageHeader
1:28c4dc4:     {
1:28c4dc4:         private boolean _isOverFlowPage;
1:28c4dc4:         private byte        _pageStatus;
1:28c4dc4:         private long        _pageVersion;
1:28c4dc4:         private int         _slotsInUse;
1:28c4dc4:         private int         _nextRecordID;
1:28c4dc4:         private int         _pageGeneration;
1:28c4dc4:         private int         _previousGeneration;
1:28c4dc4:         private long        _beforeImagePageLocation;
1:28c4dc4:         private int       _deletedRowCount;
1:28c4dc4: 
1:28c4dc4:         private  PageHeader( DataInputStream dais )  throws IOException
1:28c4dc4:         {
1:28c4dc4:             _isOverFlowPage = dais.readBoolean();
1:28c4dc4:             _pageStatus =dais.readByte();
1:28c4dc4:             _pageVersion = dais.readLong();
1:28c4dc4:             _slotsInUse = dais.readUnsignedShort();
1:28c4dc4:             _nextRecordID = dais.readInt();
1:28c4dc4:             _pageGeneration = dais.readInt();
1:28c4dc4:             _previousGeneration = dais.readInt();
1:28c4dc4:             _beforeImagePageLocation = dais.readLong();
1:28c4dc4:             _deletedRowCount = dais.readUnsignedShort();
1:28c4dc4: 
1:28c4dc4:             skipBytes( dais, 2 + 4 + 8 + 8 );
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         public boolean isOverFlowPage() { return _isOverFlowPage; }
1:28c4dc4:         public byte        getPageStatus() { return _pageStatus; }
1:28c4dc4:         public long        getPageVersion() { return _pageVersion; }
1:28c4dc4:         public int         getSlotsInUse() { return _slotsInUse; }
1:28c4dc4:         public int         getNextRecordID() { return _nextRecordID; }
1:28c4dc4:         public int         getPageGeneration() { return _pageGeneration; }
1:28c4dc4:         public int         getPreviousGeneration() { return _previousGeneration; }
1:28c4dc4:         public long        getBeforeImagePageLocation() { return _beforeImagePageLocation; }
1:28c4dc4:         public int       getDeletedRowCount() { return _deletedRowCount; }
1:28c4dc4:         
1:28c4dc4:         // format is documented in StoredPage.readPageHeader()
1:28c4dc4:         public  static PageHeader    readPageHeader( byte[] pageData ) throws IOException
1:28c4dc4:         {
1:28c4dc4:             DataInputStream dais = new DataInputStream( new ByteArrayInputStream( pageData ) );
1:28c4dc4: 
1:28c4dc4:             // skip the formatableid
1:28c4dc4:             int pageFormatableID = readPageFormatableID( dais );
1:28c4dc4:             
1:28c4dc4:             return readPageHeader( dais );
1:28c4dc4:         }
1:28c4dc4:         public  static PageHeader    readPageHeader( DataInputStream dais ) throws IOException
1:28c4dc4:         {
1:28c4dc4:             PageHeader  ph = new PageHeader( dais );
1:28c4dc4:             
1:28c4dc4:             return ph;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         public  static int readPageFormatableID( DataInputStream dais ) throws IOException
1:28c4dc4:         {
1:28c4dc4:             int     formatableID = FormatIdUtil.readFormatIdInteger( dais );
1:28c4dc4:             
1:28c4dc4:             // Even though the formatableID only takes up the leading two bytes of
1:28c4dc4:             // the AllocPage header, 4 bytes are allocated to it. Flush the next 2 bytes.
1:28c4dc4:             skipBytes( dais, 2 );
1:28c4dc4: 
1:28c4dc4:             return formatableID;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  SLOT READER
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  static  class   SlotReader
1:28c4dc4:     {
1:28c4dc4:         private int             _pageSize;
1:28c4dc4:         private int             _slotTableOffsetToFirstEntry;
1:28c4dc4:         private int             _slotTableOffsetToFirstRecordLengthField;
1:28c4dc4:         private int             _slotTableOffsetToFirstReservedSpaceField;
1:28c4dc4:         private int             _slotFieldSize;
1:28c4dc4:         private int             _slotEntrySize;
1:28c4dc4: 
1:28c4dc4:         public  SlotReader( int pageSize )
1:28c4dc4:         {
1:28c4dc4:             _pageSize = pageSize;
1:28c4dc4:             _slotFieldSize = calculateSlotFieldSize( _pageSize );
1:28c4dc4:             _slotEntrySize = 3 * _slotFieldSize;
1:28c4dc4:             _slotTableOffsetToFirstEntry = _pageSize - CHECKSUM_SIZE - _slotEntrySize;
1:28c4dc4:             _slotTableOffsetToFirstRecordLengthField = _slotTableOffsetToFirstEntry + _slotFieldSize;
1:28c4dc4:             _slotTableOffsetToFirstReservedSpaceField = _slotTableOffsetToFirstEntry + (2 * _slotFieldSize);
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         public  int slotFieldSize() { return _slotFieldSize; }
1:28c4dc4:         public  int pageSize() { return _pageSize; }
1:28c4dc4:         
1:28c4dc4:         // copied from StoredPage
1:28c4dc4:         public int getRecordOffset(int slot, byte[] pageData) 
1:28c4dc4:         {
1:28c4dc4:             byte[] data   = pageData;
1:28c4dc4:             int    offset = _slotTableOffsetToFirstEntry - (slot * _slotEntrySize);
1:28c4dc4: 
1:28c4dc4:             // offset on the page of the record is stored in the first 2 or 4 bytes
1:28c4dc4:             // of the slot table entry.  Code has been inlined for performance
1:28c4dc4:             // critical low level routine.
1:28c4dc4:             //
1:28c4dc4:             // return( 
1:28c4dc4:             //  (slotFieldSize == SMALL_SLOT_SIZE) ?
1:28c4dc4:             //       readUnsignedShort() : readInt());
1:28c4dc4: 
1:28c4dc4:             return(
1:28c4dc4:                    (_slotFieldSize == SMALL_SLOT_SIZE)  ?
1:28c4dc4: 
1:28c4dc4:                    ((data[offset++]  & 0xff) <<  8) | 
1:28c4dc4:                    (data[offset]    & 0xff)          :
1:28c4dc4: 
1:28c4dc4:                    (((data[offset++] & 0xff) << 24) |
1:28c4dc4:                     ((data[offset++] & 0xff) << 16) |
1:28c4dc4:                     ((data[offset++] & 0xff) <<  8) |
1:28c4dc4:                     ((data[offset]   & 0xff)      )));
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Get a record header */
1:28c4dc4:         private StoredRecordHeader  getRecordHeader( int slot, byte[] pageData )
1:28c4dc4:         {
1:28c4dc4:             return new StoredRecordHeader( pageData, getRecordOffset( slot, pageData ) );
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         // copied from StoredPage
1:28c4dc4:         private int calculateSlotFieldSize( int pageSize )
1:28c4dc4:         {
1:28c4dc4:             if ( pageSize < 65536 )
1:28c4dc4:             {
1:28c4dc4:                 // slots are 2 bytes (unsigned short data type) for pages <64KB
1:28c4dc4:                 return SMALL_SLOT_SIZE;
1:28c4dc4:             } else
1:28c4dc4:             {
1:28c4dc4:                 // slots are 4 bytes (int data type) for pages >=64KB
1:28c4dc4:                 return LARGE_SLOT_SIZE;
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //  STREAM FOR READING OVERFLOW COLUMNS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     public  static  class   OverflowStream  extends InputStream
1:28c4dc4:     {
1:28c4dc4:         RandomAccessFile        _raf;
1:28c4dc4:         private CipherProvider  _decryptionEngine;
1:28c4dc4:         private SlotReader      _slotReader;
1:28c4dc4:         private byte[]              _currentPageData;
1:28c4dc4:         private long                _overflowPage;
1:28c4dc4:         private int                 _overflowID;
1:28c4dc4:         private ArrayInputStream    _pageStream;
1:28c4dc4:         private MemByteHolder   _bytes;
1:28c4dc4: 
1:28c4dc4:         /** Create once */
1:28c4dc4:         public  OverflowStream
1:28c4dc4:             (
1:28c4dc4:              RandomAccessFile   raf,
1:28c4dc4:              CipherProvider decryptionEngine,
1:28c4dc4:              SlotReader     slotReader
1:28c4dc4:              )
1:28c4dc4:         {
1:28c4dc4:             _raf = raf;
1:28c4dc4:             _decryptionEngine = decryptionEngine;
1:28c4dc4:             _slotReader = slotReader;
1:28c4dc4:             _pageStream = new ArrayInputStream();
1:28c4dc4:             _bytes = new MemByteHolder( _slotReader.pageSize() );
1:28c4dc4:             _currentPageData = new byte[ _slotReader.pageSize() ];
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         /** Reinitialize for every long column */
1:28c4dc4:         public  OverflowStream    init
1:28c4dc4:             (
1:28c4dc4:              long   overflowPage,
1:28c4dc4:              int        overflowID
1:28c4dc4:              )
1:28c4dc4:             throws IOException
1:28c4dc4:         {
1:28c4dc4:             _overflowPage = overflowPage;
1:28c4dc4:             _overflowID = overflowID;
1:28c4dc4:             _bytes.clear();
1:28c4dc4:             
1:28c4dc4:             readExtents();
1:28c4dc4: 
1:28c4dc4:             return this;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         public  int read()  throws IOException
1:28c4dc4:         {
1:28c4dc4:             int retval = _bytes.read();
1:28c4dc4:             if ( retval < 0 )
1:28c4dc4:             {
1:28c4dc4:                 _bytes.clear();
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             return retval;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // see StoredPage.restorePortionLongColumn()
1:28c4dc4:         private void    readExtents()   throws IOException
1:28c4dc4:         {
1:28c4dc4:             while( _overflowPage >= 0 ) { readNextExtent(); }
1:28c4dc4: 
1:28c4dc4:             // switch to reading mode
1:28c4dc4:             _bytes.startReading();
1:28c4dc4:         }
1:28c4dc4:         private void    readNextExtent()    throws IOException
1:28c4dc4:         {
1:28c4dc4:             // read and decrypt the next page in the overflow chain
1:28c4dc4:             _raf.seek( _overflowPage * _slotReader.pageSize() );
1:28c4dc4:             _raf.readFully( _currentPageData );
1:28c4dc4:             if ( _decryptionEngine != null )    { _currentPageData = decryptPage( _decryptionEngine, _currentPageData ); }
1:28c4dc4:             _pageStream.setData( _currentPageData );
1:28c4dc4: 
1:28c4dc4:             PageHeader  ph = PageHeader.readPageHeader( _currentPageData );
1:28c4dc4:             int     recordCount = ph.getSlotsInUse();
1:28c4dc4: 
1:28c4dc4:             int                 slot = findRecordById( _overflowID, Page.FIRST_SLOT_NUMBER, recordCount );
1:28c4dc4:             StoredRecordHeader  recordHeader = _slotReader.getRecordHeader( slot, _currentPageData );
1:28c4dc4:             int                 offset = _slotReader.getRecordOffset( slot, _currentPageData );
1:28c4dc4:             int                 numberFields = recordHeader.getNumberFields();
1:28c4dc4: 
1:28c4dc4:             _pageStream.setPosition( offset + recordHeader.size() );
1:28c4dc4: 
1:28c4dc4:             int                 fieldStatus = StoredFieldHeader.readStatus( _pageStream );
1:28c4dc4:             int                 fieldDataLength = StoredFieldHeader.readFieldDataLength
1:28c4dc4:                 ( _pageStream, fieldStatus, _slotReader.slotFieldSize () );
1:28c4dc4: 
1:28c4dc4:             _bytes.write( _pageStream, fieldDataLength );
1:28c4dc4:             
1:28c4dc4:             // set the next overflow pointer in the stream...
1:28c4dc4:             if ( numberFields == 1 ) 
1:28c4dc4:             {
1:28c4dc4:                 // this is the last bit of the long column
1:28c4dc4:                 _overflowPage = -1;
1:28c4dc4:                 _overflowID = -1;
1:28c4dc4:             } 
1:28c4dc4:             else 
1:28c4dc4:             {
1:28c4dc4:                 int firstFieldStatus = fieldStatus; // for DEBUG check
1:28c4dc4: 
1:28c4dc4:                 // get the field status and data length of the overflow pointer.
1:28c4dc4:                 fieldStatus = StoredFieldHeader.readStatus( _pageStream );
1:28c4dc4:                 fieldDataLength = StoredFieldHeader.readFieldDataLength( _pageStream, fieldStatus, _slotReader.slotFieldSize() );
1:28c4dc4: 
1:28c4dc4:                 if ( !StoredFieldHeader.isOverflow( fieldStatus ) )
1:28c4dc4:                 {
1:28c4dc4:                     throw new IOException( "Corrupt overflow chain on page " + _overflowPage );
1:28c4dc4:                 }
1:28c4dc4: 
1:28c4dc4:                 _overflowPage = CompressedNumber.readLong( (InputStream) _pageStream );
1:28c4dc4:                 _overflowID = CompressedNumber.readInt( (InputStream) _pageStream );
1:28c4dc4:             }
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // cribbed from BasePage
1:28c4dc4:         private int findRecordById( int recordId, int slotHint, int maxSlot )
1:28c4dc4:         {
1:28c4dc4:             if ( slotHint == Page.FIRST_SLOT_NUMBER )
1:28c4dc4:             {
1:28c4dc4:                 slotHint = recordId - RecordHandle.FIRST_RECORD_ID;
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             if (
1:28c4dc4:                 (slotHint > Page.FIRST_SLOT_NUMBER) &&
1:28c4dc4:                 (slotHint < maxSlot) && 
1:28c4dc4:                 ( recordId == _slotReader.getRecordHeader( slotHint, _currentPageData ).getId() )
1:28c4dc4:                )
1:28c4dc4:             {
1:28c4dc4:                 return(slotHint);
1:28c4dc4:             }
1:28c4dc4:             else
1:28c4dc4:             {
1:28c4dc4:                 for ( int slot = Page.FIRST_SLOT_NUMBER; slot < maxSlot; slot++ )
1:28c4dc4:                 {
1:28c4dc4:                     if ( recordId == _slotReader.getRecordHeader( slot, _currentPageData ).getId() )
1:28c4dc4:                     {
1:28c4dc4:                         return slot;
1:28c4dc4:                     }
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4: 
1:28c4dc4:             return -1;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     // Other helper classes.
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     //
1:28c4dc4:     // Used to keep track of where we are in the input stream.
1:28c4dc4:     //
1:28c4dc4:     public  static  final   class   WrapperInputStream   extends InputStream
1:28c4dc4:     {
1:28c4dc4:         private InputStream _wrapped;
1:28c4dc4:         private long            _bytesRead;
1:28c4dc4: 
1:28c4dc4:         public  WrapperInputStream( InputStream is )
1:28c4dc4:         {
1:28c4dc4:             _wrapped = is;
1:28c4dc4:             _bytesRead = 0L;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         public  int read()  throws IOException
1:28c4dc4:         {
1:28c4dc4:             int     retval = _wrapped.read();
1:28c4dc4: 
1:28c4dc4:             if ( retval >= 0 ) { _bytesRead++; }
1:28c4dc4: 
1:28c4dc4:             return retval;
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         public  long    getBytesRead() { return _bytesRead; }
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName( customProvider );
1:         UserAuthenticator   authenticator = (UserAuthenticator) clazz.getConstructor().newInstance();
commit:28c4dc4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Class org.apache.derby.optional.dump.DataFileVTI
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.optional.dump;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.DataInput;
1: import java.io.DataInputStream;
1: import java.io.EOFException;
1: import java.io.FileInputStream;
1: import java.io.File;
1: import java.io.InputStream;
1: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.io.OutputStream;
0: import java.io.PrintStream;
1: import java.io.PrintWriter;
1: import java.io.RandomAccessFile;
1: import java.io.StringWriter;
1: import java.math.BigDecimal;
1: import java.security.AccessController;
0: import java.security.PrivilegedAction;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.Date;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.SQLWarning;
1: import java.util.ArrayList;
1: import java.util.Calendar;
1: import java.util.Properties;
1: 
1: import org.apache.derby.authentication.UserAuthenticator;
1: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.crypto.CipherFactory;
1: import org.apache.derby.iapi.services.crypto.CipherProvider;
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.CompressedNumber;
1: import org.apache.derby.iapi.services.io.FormatIdInputStream;
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.io.StreamStorable;
1: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.util.StringUtil;
1: import org.apache.derby.shared.common.reference.Attribute;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.impl.jdbc.authentication.JNDIAuthenticationService;
1: import org.apache.derby.impl.services.jce.JCECipherFactoryBuilder;
1: import org.apache.derby.impl.store.raw.data.MemByteHolder;
1: import org.apache.derby.impl.store.raw.data.StoredRecordHeader;
1: import org.apache.derby.impl.store.raw.data.StoredFieldHeader;
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derby.vti.VTITemplate;
1: 
1: 
1: /**
1:  * Table function for reading a data file in the seg0 directory of a
1:  * Derby database. This is based on the 10.11 version of
1:  * data records.
1:  */
1: public  class   DataFileVTI extends VTITemplate
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  final   String  SYSSCHEMAS_SIGNATURE = "( schemaID char(36), schemaname varchar(128), authorizationid varchar(128) )";
1:     public  static  final   String  SYSSCHEMAS_CONGLOMERATE_NAME = "cc0.dat";
1:     public  static  final   String  SYSTABLES_SIGNATURE = "( tableid char(36), tablename varchar(128), tabletype char(1), schemaid char(36), lockgranularity char(1) )";
1:     public  static  final   String  SYSTABLES_CONGLOMERATE_NAME = "c60.dat";
1:     public  static  final   String  SYS_SCHEMA_ID = "8000000d-00d0-fd77-3ed8-000a0a0b1900";
1:     public  static  final   String  SYSUSERS_SIGNATURE = "( username  varchar( 128 ), hashingscheme  varchar( 32672 ), password  varchar( 32672 ), lastmodified timestamp )";
1:     public  static  final   String  SYSUSERS_CONGLOMERATE_NAME = "c470.dat";
1:     public  static  final   String  PROPERTIES_SIGNATURE = "( keyname serializable, payload serializable )";
1:     public  static  final   String  PROPERTIES_CONGLOMERATE_NAME = "c10.dat";
1:     
1:     private static  final   String  COMPILATION_DB = "dfv_compilation_db";
1:     private static  final   String  DUMMY_TABLE_NAME = "dfv_dummy";
1: 
1:     private static  final   long READ_ALL_PAGES = -1L;
1: 
1:     public  static final int CHECKSUM_SIZE    = 8;
1:     public  static final int SMALL_SLOT_SIZE  = 2;
1:     public  static final int LARGE_SLOT_SIZE  = 4;
1: 
1:     // record status
1:     public static final byte RECORD_HAS_FIRST_FIELD = 0x04;
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     //
1:     // Filled in from the constructor args.
1:     //
1:     private DataFile    _dataFile;
1: 
1:     //
1:     // For controlling the iteration through rows.
1:     //
1:     private boolean _opened = false;
1:     private ArrayList<DataValueDescriptor[]>    _rows;
1:     private int                 _rowIdx;
1:     private boolean     _lastColumnWasNull;
1: 
1:     // transient state
1:     private Calendar    _defaultCalendar = Calendar.getInstance();
1:     
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Private constructor which performs decryption but not authentication.
1:      */
1:     private  DataFileVTI
1:         (
1:          String databaseDirectoryName,
1:          String dataFileName,
1:          String tableSignature,
1:          String encryptionProperties
1:          )
1:         throws Exception
1:     {
1:         Connection  conn = getCompilerConnection();
1:         DataTypeDescriptor[]   rowSignature = getTypeSignature( conn, tableSignature );
1: 
1:         _dataFile = new DataFile
1:             (
1:              new File( databaseDirectoryName ),
1:              dataFileName,
1:              encryptionProperties,
1:              rowSignature
1:              );
1:     }
1: 
1:     /** Public constructor */
1:     public  DataFileVTI
1:         (
1:          String databaseDirectoryName,
1:          String dataFileName,
1:          String tableSignature,
1:          String encryptionProperties,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         this( databaseDirectoryName, dataFileName, tableSignature, encryptionProperties );
1: 
1:         authenticate( databaseDirectoryName, encryptionProperties, user, password );
1:     }
1: 
1:     /**
1:      * Get a connection to a transient database which is only used to
1:      * compile table signatures.
1:      */
1:     private Connection  getCompilerConnection() throws SQLException
1:     {
1:         Connection  conn = DriverManager.getConnection( "jdbc:derby:memory:" + COMPILATION_DB + ";create=true" );
1: 
1:         // create the serializable type if it doesn't exist
1:         PreparedStatement   ps = conn.prepareStatement( "select count(*) from sys.sysaliases where alias = 'SERIALIZABLE'" );
1:         ResultSet   rs = ps.executeQuery();
1:         rs.next();
1:         boolean     alreadyExists = (rs.getInt( 1 ) > 0);
1:         rs.close();
1:         ps.close();
1: 
1:         if ( !alreadyExists )
1:         {
1:             conn.prepareStatement( "create type serializable external name 'java.io.Serializable' language java" ).execute();
1:         }
1: 
1:         return conn;
1:     }
1: 
1:     private DataTypeDescriptor[] getTypeSignature( Connection conn, String tableSignature )
1:         throws Exception
1:     {
1:         String  createTable = "create table " + DUMMY_TABLE_NAME + tableSignature;
1:         String  dropTable = "drop table " + DUMMY_TABLE_NAME;
1: 
1:         try {
1:             conn.prepareStatement( createTable ).execute();
1:         }
1:         catch (SQLException se)
1:         {
1:             throw new Exception( "Illegal table signature: " + tableSignature, se );
1:         }
1: 
1:         String  select = "select c.columndatatype, c.columnnumber\n" +
1:             "from sys.syscolumns c, sys.systables t\n" +
1:             "where c.referenceid = t.tableid\n" +
1:             "and t.tablename = ?\n" +
1:             "order by c.columnnumber";
1:         PreparedStatement   ps = conn.prepareStatement( select );
1:         ps.setString( 1, DUMMY_TABLE_NAME.toUpperCase() );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         ArrayList<DataTypeDescriptor>   list = new ArrayList<DataTypeDescriptor>();
1: 
1:         while ( rs.next() )
1:         {
1:             list.add( DataTypeDescriptor.getType( (TypeDescriptor) rs.getObject( 1 ) ) );
1:         }
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         DataTypeDescriptor[]    result = new DataTypeDescriptor[ list.size() ];
1:         list.toArray( result );
1: 
1:         conn.prepareStatement( dropTable ).execute();
1: 
1:         return result;
1:     }
1:     
1:     private static  void    skipBytes( DataInputStream dais, int bytesToSkip ) throws IOException
1:     {
1:         int     actualBytesSkipped = dais.skipBytes( bytesToSkip );
1: 
1:         if ( actualBytesSkipped != bytesToSkip )
1:         {
1:             throw new IOException( "Expected to skip " + bytesToSkip + " bytes but only skipped " + actualBytesSkipped + " bytes." );
1:         }
1:     }
1: 
1:     // See FileContainer.decryptPage()
1:     private static  byte[] decryptPage( CipherProvider decryptionEngine, byte[] cipherText ) throws IOException
1:     {
1:         try {
1:             int     pageSize = cipherText.length;
1:             byte[]  clearText = new byte[ pageSize ];
1:         
1:             int len = decryptionEngine.decrypt( cipherText, 0, pageSize, clearText, 0 );
1:         
1:             if ( len != pageSize )
1:             {
1:                 throw new IOException( "Expected to decrypt " + pageSize + " bytes but actually decrypted " + len + " bytes." );
1:             }
1:         
1:             // need to put the checksum where it belongs
1:             System.arraycopy( clearText, 8, cipherText, 0, pageSize-8);
1:             System.arraycopy( clearText, 0, cipherText, pageSize-8, 8);
1:         
1:             return cipherText;
1:         } catch( Exception e) { throw new IOException( e ); }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  AUTHENTICATION
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Authenticate the user's permission to access the raw database.
1:      * The following hurdles must be passed. Otherwise, an exception is raised.
1:      *
1:      * <ul>
1:      * <li>The user must be the DBO of the raw database.</li>
1:      * <li>If there are any tuples in the SYSUSERS catalog of the raw database, then the supplied credentials must match
1:      * what's in SYSUSERS.</li>
1:      * <li>If the database properties of the raw database specify an authentication scheme,
1:      * then that scheme must be applied to the supplied credentials.</li>
1:      * </ul>
1:      */
1:     private void    authenticate
1:         (
1:          String databaseDirectoryName,
1:          String encryptionProperties,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         vetDBO( databaseDirectoryName, encryptionProperties, user );
1:         if ( vetNative( databaseDirectoryName, encryptionProperties, user, password ) ) { return; }
1:         vetRawAuthentication( databaseDirectoryName, encryptionProperties, user, password );
1:     }
1: 
1:     /**
1:      * Verify that the user is the DBO of the raw database.
1:      */
1:     private void    vetDBO
1:         (
1:          String databaseDirectoryName,
1:          String encryptionProperties,
1:          String user
1:          )
1:         throws Exception
1:     {
1:         boolean isDBO = false;
1:         boolean foundSYSIBM = false;
1: 
1:         if ( user != null )
1:         {
1:             String          authorizationID = StringUtil.normalizeSQLIdentifier( user );
1:             DataFileVTI    sysschemas = new DataFileVTI
1:                 (
1:                  databaseDirectoryName,
1:                  SYSSCHEMAS_CONGLOMERATE_NAME,
1:                  SYSSCHEMAS_SIGNATURE,
1:                  encryptionProperties
1:                  );
1: 
1:             while( sysschemas.next() )
1:             {
1:                 if ( "SYSIBM".equals( sysschemas.getString( 2 ) ) )
1:                 {
1:                     foundSYSIBM = true;
1:                     if ( sysschemas.getString( 3 ).equals( authorizationID ) ) { isDBO = true; }
1:                     break;
1:                 }
1:             }
1:             sysschemas.close();
1:         }
1:         
1:         if ( !foundSYSIBM )
1:         {
1:             throw new Exception
1:                 (
1:                  "Could not read database at " + databaseDirectoryName +
1:                  ". Maybe it is encrypted and the wrong encryption key was supplied."
1:                  );
1:         }
1: 
1:         if ( !isDBO )
1:         {
1:             throw new Exception( user + " is not the owner of the database at " + databaseDirectoryName );
1:         }
1:     }
1: 
1:     /**
1:      * If NATIVE authentication is on, then the user's credentials must be stored in SYSUSERS.
1:      * Returns false if NATIVE authentication is not on. Raises an exception if NATIVE
1:      * authentication is on and the credentials don't match.
1:      */
1:     private boolean    vetNative
1:         (
1:          String databaseDirectoryName,
1:          String encryptionProperties,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         String          authorizationID = StringUtil.normalizeSQLIdentifier( user );
1:         DataFileVTI    systables = new DataFileVTI
1:             (
1:              databaseDirectoryName,
1:              SYSTABLES_CONGLOMERATE_NAME,
1:              SYSTABLES_SIGNATURE,
1:              encryptionProperties
1:              );
1:         boolean sysusersExists = false;
1: 
1:         while( systables.next() )
1:         {
1:             if ( SYS_SCHEMA_ID.equals( systables.getString( 4 ) ) )
1:             {
1:                 if ( "SYSUSERS".equals( systables.getString( 2 ) ) )
1:                 {
1:                     sysusersExists = true;
1:                     break;
1:                 }
1:             }
1:         }
1:         systables.close();
1: 
1:         // nothing more to check if the database doesn't even have a SYSUSERS catalog
1:         if ( !sysusersExists ) { return false; }
1: 
1:         //
1:         // See whether the user's credentials should be and are in SYSUSERS.
1:         //
1:         
1:         DataFileVTI    sysusers = new DataFileVTI
1:             (
1:              databaseDirectoryName,
1:              SYSUSERS_CONGLOMERATE_NAME,
1:              SYSUSERS_SIGNATURE,
1:              encryptionProperties
1:              );
1:         boolean credentialsShouldBePresent = false;
1:         boolean credentialsMatch = false;
1:             
1:         while( sysusers.next() )
1:         {
1:             credentialsShouldBePresent = true;
1: 
1:             if ( sysusers.getString( 1 ).equals( authorizationID ) )
1:             {
1:                 String  hashingScheme = sysusers.getString( 2 );
1:                 String  actualPassword = sysusers.getString( 3 );
1:                 PasswordHasher  hasher = new PasswordHasher( hashingScheme );
1:                 String  candidatePassword = hasher.hashPasswordIntoString( authorizationID, password );
1: 
1:                 credentialsMatch = actualPassword.equals( candidatePassword );
1: 
1:                 break;
1:             }
1:         }
1:         sysusers.close();
1: 
1:         if ( !credentialsShouldBePresent ) { return false; }
1:         if ( credentialsMatch ) { return true; }
1:         else
1:         {
1:             throw new Exception( "Bad NATIVE credentials." );
1:         }
1:     }
1: 
1:     /**
1:      * If an authentication scheme is specified by database properties in the raw
1:      * database, then use that scheme to validate the credentials.
1:      */
1:     private void    vetRawAuthentication
1:         (
1:          String databaseDirectoryName,
1:          String encryptionProperties,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         Properties  props = readDatabaseProperties( databaseDirectoryName, encryptionProperties );
1: 
1: 		String requireAuthentication = props.getProperty( Property.REQUIRE_AUTHENTICATION_PARAMETER );
1: 		if ( !Boolean.valueOf( requireAuthentication ).booleanValue() ) { return; }
1:         
1: 		String provider = props.getProperty( Property.AUTHENTICATION_PROVIDER_PARAMETER );
1:         if ( provider == null ) { return; } // no provider specified
1: 
1:         // the provider cannot be NATIVE. that case was handled above by vetNative()
1: 
1:         boolean authenticated;
1:         
1: 		if ( StringUtil.SQLEqualsIgnoreCase( provider, Property.AUTHENTICATION_PROVIDER_LDAP ) )
1:         { authenticated = vetLDAP( props, databaseDirectoryName, user, password ); }
1: 		else if ( StringUtil.SQLEqualsIgnoreCase( provider, Property.AUTHENTICATION_PROVIDER_BUILTIN ) )
1:         { authenticated = vetBuiltin( props, user, password ); }
1:         else { authenticated = vetCustom( provider, databaseDirectoryName, user, password ); }
1: 
1:         if ( !authenticated )
1:         {
1:             throw new Exception( "Authentication failed using provider " + provider );
1:         }
1:     }
1: 
1:     /**
1:      * Match credentials using an LDAP server.
1:      */
1:     private boolean vetLDAP
1:         (
1:          Properties dbProps,
1:          String databaseDirectoryName,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         LDAPService   authenticator = new LDAPService( dbProps );
1: 
1:         authenticator.boot( false, dbProps );
1: 
1:         Properties  userInfo = new Properties();
1:         userInfo.setProperty( Attribute.USERNAME_ATTR, user );
1:         userInfo.setProperty( Attribute.PASSWORD_ATTR, password );
1: 
1:         return authenticator.authenticate( databaseDirectoryName, userInfo );
1:     }
1:     
1:     /**
1:      * Match credentials against the BUILTIN credentials stored in the properties
1:      * conglomerate of the raw database. All of those properties have been read
1:      * into the props object already.
1:      */
1:     private boolean vetBuiltin
1:         (
1:          Properties props,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         String  passwordProperty = Property.USER_PROPERTY_PREFIX.concat( user );
1:         String  realPassword = props.getProperty( passwordProperty );
1: 
1:         if ( realPassword != null )
1:         {
1:             PasswordHasher  hasher = new PasswordHasher( realPassword );
1: 
1:             password = hasher.hashAndEncode( user, password );
1:         }
1:         else
1:         {
1:             realPassword = getSystemProperty( passwordProperty );
1:         }
1: 
1:         return ( (realPassword != null) && realPassword.equals( password ) );
1:     }
1:     
1:     /**
1:      * Validate credentials using a custom authenticator.
1:      */
1:     private boolean vetCustom
1:         (
1:          String customProvider,
1:          String databaseDirectoryName,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
0:         UserAuthenticator   authenticator = (UserAuthenticator) Class.forName( customProvider ).newInstance();
1: 
1:         return authenticator.authenticateUser( user, password, databaseDirectoryName, new Properties() );
1:     }
1:     
1:     /**
1:      * Get system property.
1:      */
1:     private static String getSystemProperty( final String name)
1: 	{
1:         return AccessController.doPrivileged
1:             ( new java.security.PrivilegedAction<String>()
1:                 {
1:                     public String run() { return System.getProperty( name ); }
1:                 }
1:             );
1:     }
1: 
1:     /**
1:      * Read the properties conglomerate of the raw database.
1:      */
1:     private Properties  readDatabaseProperties
1:         (
1:          String databaseDirectoryName,
1:          String encryptionProperties
1:          )
1:         throws Exception
1:     {
1:         Properties  retval = new Properties();
1:         
1:         DataFileVTI    pc = new DataFileVTI
1:             (
1:              databaseDirectoryName,
1:              PROPERTIES_CONGLOMERATE_NAME,
1:              PROPERTIES_SIGNATURE,
1:              encryptionProperties
1:              );
1: 
1:         while( pc.next() )
1:         {
1:             int col = 1;
1:             Object  key = pc.getObject( col++ );
1:             Object  value = pc.getObject( col++ );
1: 
1:             retval.put( key, value );
1:         }
1:         pc.close();
1: 
1:         return retval;
1:     }
1:     
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  TABLE FUNCTION
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Entry point declared in the external name clause of a CREATE FUNCTION statement.
1:      */
1:     public  static  DataFileVTI dataFileVTI
1:         (
1:          String databaseDirectoryName,
1:          String dataFileName,
1:          String tableSignature,
1:          String encryptionProperties,
1:          String user,
1:          String password
1:          )
1:         throws Exception
1:     {
1:         return new DataFileVTI( databaseDirectoryName, dataFileName, tableSignature, encryptionProperties, user, password );
1:     }
1: 
1:     private SQLException    wrap( Throwable t )
1:     {
1:         return new SQLException( t.getMessage(), t );
1:     }
1:     
1:     private SQLException    wrap( String errorMessage )
1:     {
1:         String  sqlState = SQLState.JAVA_EXCEPTION.substring( 0, 5 );
1: 
1:         return new SQLException( errorMessage, sqlState );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  VTITemplate IMPLEMENTATION
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  boolean next()  throws SQLException
1:     {
1:         if ( _dataFile == null ) { return false; }
1:         
1:         try {
1:             if ( !_opened )
1:             {
1:                 _dataFile.openFile();
1:                 _opened = true;
1:                 readNextPage();
1:             }
1: 
1:             while ( _rows != null )
1:             {
1:                 _rowIdx++;
1: 
1:                 if ( _rowIdx < _rows.size() ) { return true; }
1:                 else { readNextPage(); }
1:             }
1: 
1:             close();
1:             return false;
1:         }
1:         catch (Throwable t)
1:         {
1:             if ( t instanceof SQLException) { throw (SQLException) t; }
1:             else    { throw wrap( t ); }
1:         }
1:     }
1:     /**
1:      * Read the next page of rows.
1:      */
1:     private void    readNextPage()  throws Exception
1:     {
1:         _rows = _dataFile.readNextPage();
1:         _rowIdx = -1;
1:     }
1:     
1:     /** Get the warnings */
1:     public SQLWarning  getWarnings()
1:     {
1:         SQLWarning  firstWarning = null;
1:         ArrayList<SQLWarning>   warnings = _dataFile.getWarnings();
1:         if ( (warnings != null) && (warnings.size() > 0) )
1:         {
1:             firstWarning = warnings.get( 0 );
1:             
1:             // chain the warnings together
1:             SQLWarning  previous = null;
1:             for ( SQLWarning warning : warnings )
1:             {
1:                 if ( previous != null ) { previous.setNextWarning( warning ); }
1:                 previous = warning;
1:             }
1:         }
1: 
1:         return firstWarning;
1:     }
1: 
1:     public  void    close() throws SQLException
1:     {
1:         try {
1:             if ( _dataFile != null ) { _dataFile.closeFile(); }
1:         }
1:         catch (Throwable t) { throw wrap( t ); }
1:         finally
1:         {
1:             _dataFile = null;
1:             _rows = null;
1:         }
1:     }
1: 
1:     public  ResultSetMetaData   getMetaData()   { return null; }
1: 
1:     /** Get a column value (1-based indexing) and check if it's null */
1:     private DataValueDescriptor getRawColumn( int idx )
1:     {
1:         DataValueDescriptor dvd = _rows.get( _rowIdx )[ idx - 1 ];
1: 
1:         _lastColumnWasNull = dvd.isNull();
1: 
1:         return dvd;
1:     }
1: 
1:     
1:     public boolean wasNull() { return _lastColumnWasNull; }
1:     
1:     public String getString(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getString(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public boolean getBoolean(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getBoolean(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public byte getByte(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getByte(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public short getShort(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getShort(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public int getInt(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getInt(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public long getLong(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getLong(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public float getFloat(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getFloat(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public double getDouble(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getDouble(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public byte[] getBytes(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getBytes(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public Date getDate(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getDate( _defaultCalendar ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public Time getTime(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getTime( _defaultCalendar ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public Timestamp getTimestamp(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getTimestamp( _defaultCalendar ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public Object getObject(int columnIndex) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getObject(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1:     public BigDecimal getBigDecimal(int columnIndex) throws SQLException
1:     {
1:         try { return (BigDecimal) getRawColumn( columnIndex ).getObject(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 	public Date getDate(int columnIndex, Calendar cal) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getDate( cal ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 	public Time getTime(int columnIndex, Calendar cal) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getTime( cal ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 	public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException
1:     {
1:         try { return getRawColumn( columnIndex ).getTimestamp( cal ); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 	public Blob getBlob(int columnIndex) throws SQLException
1:     {
1:         try { return (Blob) getRawColumn( columnIndex ).getObject(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 	public Clob getClob(int columnIndex) throws SQLException
1:     {
1:         try { return (Clob) getRawColumn( columnIndex ).getObject(); }
1:         catch (Throwable t) { throw wrap( t ); }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  NESTED CLASSES
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1:     
1:     ////////////////////////////////////////////////
1:     //
1:     //  LDAP SERVICE
1:     //
1:     ////////////////////////////////////////////////
1: 
1:     public  static  final   class   LDAPService extends JNDIAuthenticationService
1:     {
1:         private Properties  _dbProperties;
1: 
1:         public  LDAPService( Properties dbProperties )
1:         {
1:             super();
1:             _dbProperties = dbProperties;
1:         }
1: 
1:         // override to use properties in raw database
1:         public String getProperty(String key)
1:         {
1:             return _dbProperties.getProperty( key );
1:         }
1:     }
1:     
1:     ////////////////////////////////////////////////
1:     //
1:     //  THIS IS THE WORKHORSE FOR THIS PROGRAM
1:     //
1:     ////////////////////////////////////////////////
1:     
1:     public  static  final   class   DataFile
1:     {
1:         // constructor args
1:         
1:         private File        _dbDirectory;
1:         private File            _file;
1:         private DataTypeDescriptor[]   _rowSignature;
1:         private CipherProvider  _decryptionEngine;
1: 
1:         // control info
1: 
1:         private FileInputStream _fis;
1:         private DataInputStream _dais;
1:         private long            _pageCount;
1:         private byte[]          _pageData;
1:         private int             _pageSize;
1:         private SlotReader  _slotReader;
1:         private OverflowStream  _overflowStream;
1:         private ArrayList<SQLWarning>  _warnings;
1:     
1:         public  DataFile
1:             ( File dbDirectory, String fileName, String encryptionProperties, DataTypeDescriptor[] rowSignature )
1:             throws Exception
1:         {
1:             _dbDirectory = dbDirectory;
1:             _file = new File( new File( _dbDirectory, "seg0" ), fileName );
1:             _rowSignature = rowSignature;
1:             _decryptionEngine = makeDecryptionEngine( encryptionProperties );
1:         }
1: 
1:         private CipherProvider  makeDecryptionEngine( String encryptionProperties ) throws Exception
1:         {
1:             if ( encryptionProperties == null ) { return null; }
1:             
1:             File    serviceProperties = new File( _dbDirectory, "service.properties" );
1:             Properties  properties = unpackEncryptionProperties( encryptionProperties );
0:             properties.load( new FileInputStream( serviceProperties ) );
1: 
1:             CipherFactory    cipherFactory =
1:                 new JCECipherFactoryBuilder()
1:                 .createCipherFactory( false, properties, false );
1: 
1:             return cipherFactory.createNewCipher( CipherFactory.DECRYPT );
1:         }
1:         private Properties  unpackEncryptionProperties( String encryptionProperties )
1:         {
1:             Properties  retval = new Properties();
1:             String[]    items = encryptionProperties.split( ";" );
1: 
1:             for ( String item : items )
1:             {
1:                 int     equalsSignIdx = item.indexOf( "=" );
1:                 if ( equalsSignIdx > 0 )
1:                 {
1:                     String  key = item.substring( 0, equalsSignIdx );
1:                     String  value = item.substring( equalsSignIdx + 1, item.length() );
1: 
1:                     retval.setProperty( key, value );
1:                 }
1:             }
1: 
1:             return retval;
1:         }
1:         
1:         //
1:         // Order of operations is:
1:         //
1:         //   openFile()
1:         //   readNextPage() until returns null
1:         //   closeFile()
1:         //
1: 
1:         public  void    openFile()  throws Exception
1:         {
1:             _pageCount = 0L;
1: 
1:             _fis = new FileInputStream( _file );
1:             WrapperInputStream  wis = new WrapperInputStream( _fis );
1:             _dais = new DataInputStream( wis );
1:             
1:             readFileHeader();
1:             skipToPageEnd( wis );
1:         }
1: 
1:         /** Closes the file and returns a list of errors or null if no errors. */
1:         public  void    closeFile() throws Exception
1:         {
1:             _dais.close();
1:             _fis.close();
1:         }
1: 
1:         /** Get the errors which accumulated since the last time this method was called. Returns null if no errors. */
1:         public  ArrayList<SQLWarning>   getWarnings()
1:         {
1:             try { return _warnings; }
1:             finally { _warnings = null; }
1:         }
1:         /** Add a warning */
1:         private void    addWarning( String message, Throwable t )
1:         {
1:             if ( _warnings == null ) { _warnings = new ArrayList<SQLWarning>(); }
1: 
1:             _warnings.add( new SQLWarning( message, t ) );
1:         }
1: 
1:         //////////////////
1:         //
1:         // FILE HEADER
1:         //
1:         //////////////////
1: 
1:         private void    readFileHeader() throws Exception
1:         {
1:             readAllocPage( _dais, PageHeader.readPageFormatableID( _dais ) );
1: 
1:             _pageCount++;
1:         }
1: 
1:         private void    skipToPageEnd( WrapperInputStream wis )   throws Exception
1:         {
1:             int          remainingBytesOnPage = getRemainingBytesOnPage( wis );
1: 
1:             DataInputStream dais = new DataInputStream( wis );
1:             if ( remainingBytesOnPage != 0 ) { skipBytes( dais, remainingBytesOnPage ); }
1:         }
1: 
1:         private int getRemainingBytesOnPage( WrapperInputStream wis )
1:         {
1:             long        offsetIntoCurrentPage = currentOffsetIntoPage( wis );
1: 
1:             int         remainingBytes = ( offsetIntoCurrentPage == 0L ) ? 0 :  (int) (_pageSize - offsetIntoCurrentPage);
1: 
1:             return remainingBytes;
1:         }
1: 
1:         private int currentOffsetIntoPage( WrapperInputStream wis )
1:         {
1:             return (int) (wis.getBytesRead() % (long)_pageSize);
1:         }
1: 
1:         //////////////////
1:         //
1:         // PAGE DISPATCH
1:         //
1:         //////////////////
1: 
1:         /**
1:          * Returns rows on the next page. Returns null if at EOF.
1:          */
1:         public    ArrayList<DataValueDescriptor[]>  readNextPage()
1:         {
1:             _pageData = new byte[ _pageSize ];
1:             
1:             try {
1:                 _dais.readFully( _pageData );
1:             }
1:             catch (Throwable t)
1:             {
1:                 // errors caught here are fatal file stream errors
1:                 if ( !( t instanceof EOFException ) )   { addWarning( formatThrowable( t, true ), t ); }
1:                 
1:                 return null;
1:             }
1: 
1:             try {
1:                 return readNonHeaderPage();
1:             }
1:             catch (Throwable t)
1:             {
1:                 // errors caught here are localized corruptions or mistakes in the coding of this class
1:                 addWarning( formatThrowable( t, false ), t );
1:                 
1:                 return makeEmptyRowList();
1:             }
1:         }
1: 
1:         // returns null if at EOF
1:         private ArrayList<DataValueDescriptor[]> readNonHeaderPage() throws Exception
1:         {
1:             if ( _decryptionEngine != null )    { _pageData = decryptPage( _decryptionEngine, _pageData ); }
1: 
1:             WrapperInputStream  wis = new WrapperInputStream( new ByteArrayInputStream( _pageData ) );
1:             DataInputStream dais = new DataInputStream( wis );
1:             int pageFormatableID = PageHeader.readPageFormatableID( dais );
1: 
1:             ArrayList<DataValueDescriptor[]>    result;
1:             
1:             switch( pageFormatableID )
1:             {
1:             case StoredFormatIds.RAW_STORE_ALLOC_PAGE:
1:                 result = readAllocPage( dais, pageFormatableID );
1:                 break;
1:             case StoredFormatIds.RAW_STORE_STORED_PAGE:
1:                 result = formatRows();
1:                 break;
1:             default:
1:                 throw new IOException( "Unknown page formatable ID: " + pageFormatableID );
1:             }
1: 
1:             _pageCount++;
1: 
1:             return result;
1:         }
1: 
1:         //////////////////////
1:         //
1:         // ALLOCATION PAGES
1:         //
1:         //////////////////////
1: 
1:         private ArrayList<DataValueDescriptor[]>    readAllocPage( DataInputStream dais, int formatableID ) throws Exception
1:         {
1:             if ( formatableID != StoredFormatIds.RAW_STORE_ALLOC_PAGE )
1:             {
1:                 throw new IOException
1:                     (
1:                      "File header should start with formatable id " + StoredFormatIds.RAW_STORE_ALLOC_PAGE +
1:                      " but instead starts with formatable id " + formatableID
1:                      );
1:             }
1: 
1:             PageHeader.readPageHeader( dais );
1:             
1:             // documented in AllocPage.readAllocPageHeader()
1:             long    nextAllocPageNumber = dais.readLong();
1:             long    nextAllocPageOffset = dais.readLong();
1:             
1:             skipBytes( dais, 8 + 8 + 8 + 8 );
1:             
1:             byte    containerInfoLength = dais.readByte();
1:             
1:             if ( containerInfoLength > (byte) 0 ) { readContainerInfo( dais, containerInfoLength ); }
1: 
1:             // return empty set of rows
1:             return new ArrayList<DataValueDescriptor[]>();
1:         }
1: 
1:         // see FileContainer.writeHeaderToArray() for the format of the container descriptor
1:         private void    readContainerInfo( DataInputStream dais, byte containerInfoLength )
1:             throws Exception
1:         {
1:             int     formatableID = dais.readInt();
1:             if ( formatableID != StoredFormatIds.RAW_STORE_SINGLE_CONTAINER_FILE )
1:             {
1:                 throw new IOException
1:                     (
1:                      "Container info should start with formatable id " + StoredFormatIds.RAW_STORE_SINGLE_CONTAINER_FILE +
1:                      " but instead starts with formatable id " + formatableID
1:                      );
1: 
1:             }
1:             
1:             int containerStatus = dais.readInt();
1:             
1:             _pageSize = dais.readInt();
1:             _slotReader = new SlotReader( _pageSize );
1:         }
1: 
1:         //////////////////
1:         //
1:         // DATA PAGES
1:         //
1:         //////////////////
1: 
1:         /**
1:          * Returns the set of rows on a page. If there are no rows on the page,
1:          * returns a 0-length list of rows.
1:          */
1:         private ArrayList<DataValueDescriptor[]>    formatRows() throws Exception
1:         {
1:             PageHeader ph = PageHeader.readPageHeader( _pageData );
1: 
1:             ArrayInputStream    ais = new ArrayInputStream( _pageData );
1:                     
1:             int     recordCount = ph.getSlotsInUse();
1: 
1:             ArrayList<DataValueDescriptor[]>    rows = makeEmptyRowList();
1: 
1:             // nothing to do if this is an overflow page
1:             if ( ph.isOverFlowPage() ) { return rows; }
1: 
1:             // largely cribbed from StoredPage.recordToString()
1:             for ( int slot = 0; slot < recordCount; slot++ )
1:             {
1:                 // we need this in order to look at the RECORD_HAS_FIRST_FIELD status,
1:                 // which is not exposed by StoredRecordHeader
1:                 byte                        recordStatusByte = _pageData[ _slotReader.getRecordOffset( slot, _pageData ) ];
1:                 StoredRecordHeader  recordHeader = _slotReader.getRecordHeader( slot, _pageData );
1:                 int     offset = _slotReader.getRecordOffset( slot, _pageData );
1: 
1:                 // skip deleted records
1:                 if ( recordHeader.isDeleted() ) { continue; }
1: 
1:                 int     fieldCount = recordHeader.getNumberFields();
1:                 
1:                 // move offset past record header to beginning of first field.
1:                 offset += recordHeader.size();
1:                 ais.setPosition( offset );
1:                         
1:                 if ( fieldCount > 0 )
1:                 {                            
1:                     DataValueDescriptor[]   row = makeEmptyRow();
1:                     boolean     rowIsValid = true;
1:                         
1:                     // field layout is described in StoredFieldHeader.write()
1:                     for ( int fieldIdx = 0; fieldIdx < fieldCount; fieldIdx++ )
1:                     {
1:                         int fieldStatus = StoredFieldHeader.readStatus( ais );
1:                         int fieldDataLength = StoredFieldHeader.readFieldDataLength( ais, fieldStatus, _slotReader.slotFieldSize() );
1:                         int fieldDataOffset = ais.getPosition();
1:                         
1:                         if ( fieldDataLength >= 0 ) // not null?
1:                         {
1:                             if ( StoredFieldHeader.isOverflow( fieldStatus ) )
1:                             {
1:                                 long overflowPage;
1:                                 int overflowId;
1:                                 
1:                                 // not likely to be a real pointer, this is most
1:                                 // likely an old column chain where the first field
1:                                 // is set to overflow even though the second field
1:                                 // is the overflow pointer
1:                                 if ( fieldIdx == 0 && fieldDataLength != 3 ) 
1:                                 {
1:                                     // figure out where we should go next
1:                                     offset = ais.getPosition() + fieldDataLength;
1:                                     overflowPage = CompressedNumber.readLong( (DataInput) ais );
1:                                     overflowId = CompressedNumber.readInt( (DataInput) ais );
1:                                     
1:                                     printIrregularity( "questionable long column" );
1:                                     
1:                                     ais.setPosition( offset );
1:                                 }
1:                                 else
1:                                 {
1:                                     overflowPage = CompressedNumber.readLong( (DataInput) ais );
1:                                     overflowId = CompressedNumber.readInt( (DataInput) ais );
1: 
1:                                     readOverflowField
1:                                         ( slot, fieldIdx, fieldDataOffset, fieldDataLength, row[ fieldIdx ], overflowPage, overflowId );
1:                                 }
1:                                 
1:                             }   // end if overflow
1:                             else    // not overflow
1:                             {
1:                                 if ( fieldDataLength > 0 )
1:                                 {
1:                                     //
1:                                     // Ignore records which aren't really rows.
1:                                     //
1:                                     if (
1:                                         recordHasFirstField( recordStatusByte )  &&
1:                                         ( (fieldCount == 1) || (fieldCount != _rowSignature.length) )
1:                                        )
1:                                     {
1:                                         rowIsValid = false;
1:                                     }
1:                                     else    // looks like a real row
1:                                     {
1:                                         try {
1:                                             readField( slot, fieldIdx, fieldDataOffset, fieldDataLength, row[ fieldIdx ] );
1:                                         } catch (Throwable t)
1:                                         {
1:                                             rowIsValid = false;
1:                                         }
1:                                     }
1:                                 }
1:                                 
1:                                 // go to next field
1:                                 offset = ais.getPosition() + fieldDataLength;
1:                                 ais.setPosition(offset);
1:                             }   // end if not overflow
1:                         }   // end if not null
1:                             
1:                     }   // end loop through fields
1:                         
1:                     if ( rowIsValid )
1:                     {
1:                         rows.add( row );
1:                     }
1:                 }   // end if there are fields
1:             }   // end of loop through records
1: 
1:             return rows;
1:         }
1: 
1:         private DataValueDescriptor[]   makeEmptyRow()  throws Exception
1:         {
1:             int columnCount = _rowSignature.length;
1:             DataValueDescriptor[]   row = new DataValueDescriptor[ columnCount ];
1: 
1:             for ( int i = 0; i < columnCount; i++ )
1:             {
1:                 row[ i ] = _rowSignature[ i ].getNull();
1:             }
1: 
1:             return row;
1:         }
1: 
1:         /** Make an empty list of rows */
1:         private ArrayList<DataValueDescriptor[]> makeEmptyRowList() { return new ArrayList<DataValueDescriptor[]>(); }
1: 
1:         private boolean recordHasFirstField( byte recordStatus )
1:         {
1:             return ( (recordStatus & RECORD_HAS_FIRST_FIELD) != 0 );
1:         }
1:         
1:         private void  readField
1:             ( int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd )
1:             throws Exception
1:         {
1:             try {
1:                 byte[]  bytes = new byte[ length ];
1:                 System.arraycopy( _pageData, offset, bytes, 0, length );
1:                 ArrayInputStream    ais = new ArrayInputStream( bytes );
1:             
1:                 dvd.readExternalFromArray( ais );
1:             }
1:             catch (Exception e) { formatFieldWarning( recordNumber, fieldNumber, offset, length, dvd, e ); }
1:         }
1: 
1:         private void  readOverflowField
1:             (
1:              int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd,
1:              long overflowPage, int overflowID
1:              )
1:             throws Exception
1:         {
1:             try {
1:                 OverflowStream  os = getOverflowStream().init( overflowPage, overflowID );
1:                 FormatIdInputStream fiis = new FormatIdInputStream( os );
1: 
1:                 if ( dvd instanceof StreamStorable ) 
1:                 {
1:                     ( (StreamStorable) dvd).setStream( fiis );
1:                 } 
1:                 else 
1:                 {
1:                     dvd.readExternal( fiis );
1:                 }
1:             }
1:             catch (Exception e) { formatFieldWarning( recordNumber, fieldNumber, offset, length, dvd, e ); }
1:         }
1: 
1:         private OverflowStream  getOverflowStream()
1:             throws IOException
1:         {
1:             if ( _overflowStream == null )
1:             {
1:                 _overflowStream = new OverflowStream
1:                     (
1:                      new RandomAccessFile( _file, "r" ),
1:                      _decryptionEngine,
1:                      _slotReader
1:                      );
1:             }
1: 
1:             return _overflowStream;
1:         }
1: 
1:         ////////////////////
1:         //
1:         // ERROR HANDLING
1:         //
1:         ////////////////////
1: 
1:         private void  formatFieldWarning
1:             ( int recordNumber, int fieldNumber, int offset, int length, DataValueDescriptor dvd, Throwable e )
1:         {
1:             String  errorMessage =
1:                 "Error reading field data. Offset = " + offset + ", length = " + length +
1:                 ", datatype = " + _rowSignature[ fieldNumber ].getSQLstring() +
1:                 ": " + getFieldCoordinates( recordNumber, fieldNumber ) +
1:                 ": " + formatThrowable( e, false );
1: 
1:             addWarning( errorMessage, e );
1:         }
1:         
1:         /** Coordinates of field which confused us */
1:         private String  getFieldCoordinates( int recordNumber, int fieldNumber )
1:         {
1:             return
1:                 "Field " + fieldNumber +
1:                 " in record " + recordNumber +
1:                 getPageCoordinates();
1:         }
1: 
1:         /** Coordinates of page which confused us */
1:         private String  getPageCoordinates()
1:         {
1:             return
1:                 " on page " + _pageCount +
1:                 " in file " + _file.getName();
1:         }
1: 
1:         /** Format an error for printing */
1:         private String  formatThrowable( Throwable e, boolean includeStackTrace )
1:         {
1:             StringBuilder   buffer = new StringBuilder();
1:             buffer.append( e.getClass().getName() + ": " + e.getMessage() );
1: 
1:             if ( includeStackTrace )
1:             {
1:                 StringWriter    sw = new StringWriter();
1:                 PrintWriter     pw = new PrintWriter( sw );
1:                 e.printStackTrace( pw );
1:                 pw.flush();
1:                 buffer.append( sw.toString() );
1:             }
1:             
1:             return buffer.toString();
1:         }
1:         
1:         /** Print a string */
1:         private void    println( String text ) { System.out.println( text ); }
1: 
1:         /* Print an irregularity */
1:         private void    printIrregularity( String text ) {}
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // PAGE HEADER
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  final   class   PageHeader
1:     {
1:         private boolean _isOverFlowPage;
1:         private byte        _pageStatus;
1:         private long        _pageVersion;
1:         private int         _slotsInUse;
1:         private int         _nextRecordID;
1:         private int         _pageGeneration;
1:         private int         _previousGeneration;
1:         private long        _beforeImagePageLocation;
1:         private int       _deletedRowCount;
1: 
1:         private  PageHeader( DataInputStream dais )  throws IOException
1:         {
1:             _isOverFlowPage = dais.readBoolean();
1:             _pageStatus =dais.readByte();
1:             _pageVersion = dais.readLong();
1:             _slotsInUse = dais.readUnsignedShort();
1:             _nextRecordID = dais.readInt();
1:             _pageGeneration = dais.readInt();
1:             _previousGeneration = dais.readInt();
1:             _beforeImagePageLocation = dais.readLong();
1:             _deletedRowCount = dais.readUnsignedShort();
1: 
1:             skipBytes( dais, 2 + 4 + 8 + 8 );
1:         }
1:         
1:         public boolean isOverFlowPage() { return _isOverFlowPage; }
1:         public byte        getPageStatus() { return _pageStatus; }
1:         public long        getPageVersion() { return _pageVersion; }
1:         public int         getSlotsInUse() { return _slotsInUse; }
1:         public int         getNextRecordID() { return _nextRecordID; }
1:         public int         getPageGeneration() { return _pageGeneration; }
1:         public int         getPreviousGeneration() { return _previousGeneration; }
1:         public long        getBeforeImagePageLocation() { return _beforeImagePageLocation; }
1:         public int       getDeletedRowCount() { return _deletedRowCount; }
1:         
1:         // format is documented in StoredPage.readPageHeader()
1:         public  static PageHeader    readPageHeader( byte[] pageData ) throws IOException
1:         {
1:             DataInputStream dais = new DataInputStream( new ByteArrayInputStream( pageData ) );
1: 
1:             // skip the formatableid
1:             int pageFormatableID = readPageFormatableID( dais );
1:             
1:             return readPageHeader( dais );
1:         }
1:         public  static PageHeader    readPageHeader( DataInputStream dais ) throws IOException
1:         {
1:             PageHeader  ph = new PageHeader( dais );
1:             
1:             return ph;
1:         }
1: 
1:         public  static int readPageFormatableID( DataInputStream dais ) throws IOException
1:         {
1:             int     formatableID = FormatIdUtil.readFormatIdInteger( dais );
1:             
1:             // Even though the formatableID only takes up the leading two bytes of
1:             // the AllocPage header, 4 bytes are allocated to it. Flush the next 2 bytes.
1:             skipBytes( dais, 2 );
1: 
1:             return formatableID;
1:         }
1: 
1:     }
1:     
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  SLOT READER
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  class   SlotReader
1:     {
1:         private int             _pageSize;
1:         private int             _slotTableOffsetToFirstEntry;
1:         private int             _slotTableOffsetToFirstRecordLengthField;
1:         private int             _slotTableOffsetToFirstReservedSpaceField;
1:         private int             _slotFieldSize;
1:         private int             _slotEntrySize;
1: 
1:         public  SlotReader( int pageSize )
1:         {
1:             _pageSize = pageSize;
1:             _slotFieldSize = calculateSlotFieldSize( _pageSize );
1:             _slotEntrySize = 3 * _slotFieldSize;
1:             _slotTableOffsetToFirstEntry = _pageSize - CHECKSUM_SIZE - _slotEntrySize;
1:             _slotTableOffsetToFirstRecordLengthField = _slotTableOffsetToFirstEntry + _slotFieldSize;
1:             _slotTableOffsetToFirstReservedSpaceField = _slotTableOffsetToFirstEntry + (2 * _slotFieldSize);
1:         }
1: 
1:         public  int slotFieldSize() { return _slotFieldSize; }
1:         public  int pageSize() { return _pageSize; }
1:         
1:         // copied from StoredPage
1:         public int getRecordOffset(int slot, byte[] pageData) 
1:         {
1:             byte[] data   = pageData;
1:             int    offset = _slotTableOffsetToFirstEntry - (slot * _slotEntrySize);
1: 
1:             // offset on the page of the record is stored in the first 2 or 4 bytes
1:             // of the slot table entry.  Code has been inlined for performance
1:             // critical low level routine.
1:             //
1:             // return( 
1:             //  (slotFieldSize == SMALL_SLOT_SIZE) ?
1:             //       readUnsignedShort() : readInt());
1: 
1:             return(
1:                    (_slotFieldSize == SMALL_SLOT_SIZE)  ?
1: 
1:                    ((data[offset++]  & 0xff) <<  8) | 
1:                    (data[offset]    & 0xff)          :
1: 
1:                    (((data[offset++] & 0xff) << 24) |
1:                     ((data[offset++] & 0xff) << 16) |
1:                     ((data[offset++] & 0xff) <<  8) |
1:                     ((data[offset]   & 0xff)      )));
1:         }
1: 
1:         /** Get a record header */
1:         private StoredRecordHeader  getRecordHeader( int slot, byte[] pageData )
1:         {
1:             return new StoredRecordHeader( pageData, getRecordOffset( slot, pageData ) );
1:         }
1:         
1:         // copied from StoredPage
1:         private int calculateSlotFieldSize( int pageSize )
1:         {
1:             if ( pageSize < 65536 )
1:             {
1:                 // slots are 2 bytes (unsigned short data type) for pages <64KB
1:                 return SMALL_SLOT_SIZE;
1:             } else
1:             {
1:                 // slots are 4 bytes (int data type) for pages >=64KB
1:                 return LARGE_SLOT_SIZE;
1:             }
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //  STREAM FOR READING OVERFLOW COLUMNS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  class   OverflowStream  extends InputStream
1:     {
1:         RandomAccessFile        _raf;
1:         private CipherProvider  _decryptionEngine;
1:         private SlotReader      _slotReader;
1:         private byte[]              _currentPageData;
1:         private long                _overflowPage;
1:         private int                 _overflowID;
1:         private ArrayInputStream    _pageStream;
1:         private MemByteHolder   _bytes;
1: 
1:         /** Create once */
1:         public  OverflowStream
1:             (
1:              RandomAccessFile   raf,
1:              CipherProvider decryptionEngine,
1:              SlotReader     slotReader
1:              )
1:         {
1:             _raf = raf;
1:             _decryptionEngine = decryptionEngine;
1:             _slotReader = slotReader;
1:             _pageStream = new ArrayInputStream();
1:             _bytes = new MemByteHolder( _slotReader.pageSize() );
1:             _currentPageData = new byte[ _slotReader.pageSize() ];
1:         }
1: 
1:         /** Reinitialize for every long column */
1:         public  OverflowStream    init
1:             (
1:              long   overflowPage,
1:              int        overflowID
1:              )
1:             throws IOException
1:         {
1:             _overflowPage = overflowPage;
1:             _overflowID = overflowID;
1:             _bytes.clear();
1:             
1:             readExtents();
1: 
1:             return this;
1:         }
1: 
1:         public  int read()  throws IOException
1:         {
1:             int retval = _bytes.read();
1:             if ( retval < 0 )
1:             {
1:                 _bytes.clear();
1:             }
1: 
1:             return retval;
1:         }
1: 
1:         // see StoredPage.restorePortionLongColumn()
1:         private void    readExtents()   throws IOException
1:         {
1:             while( _overflowPage >= 0 ) { readNextExtent(); }
1: 
1:             // switch to reading mode
1:             _bytes.startReading();
1:         }
1:         private void    readNextExtent()    throws IOException
1:         {
1:             // read and decrypt the next page in the overflow chain
1:             _raf.seek( _overflowPage * _slotReader.pageSize() );
1:             _raf.readFully( _currentPageData );
1:             if ( _decryptionEngine != null )    { _currentPageData = decryptPage( _decryptionEngine, _currentPageData ); }
1:             _pageStream.setData( _currentPageData );
1: 
1:             PageHeader  ph = PageHeader.readPageHeader( _currentPageData );
1:             int     recordCount = ph.getSlotsInUse();
1: 
1:             int                 slot = findRecordById( _overflowID, Page.FIRST_SLOT_NUMBER, recordCount );
1:             StoredRecordHeader  recordHeader = _slotReader.getRecordHeader( slot, _currentPageData );
1:             int                 offset = _slotReader.getRecordOffset( slot, _currentPageData );
1:             int                 numberFields = recordHeader.getNumberFields();
1: 
1:             _pageStream.setPosition( offset + recordHeader.size() );
1: 
1:             int                 fieldStatus = StoredFieldHeader.readStatus( _pageStream );
1:             int                 fieldDataLength = StoredFieldHeader.readFieldDataLength
1:                 ( _pageStream, fieldStatus, _slotReader.slotFieldSize () );
1: 
1:             _bytes.write( _pageStream, fieldDataLength );
1:             
1:             // set the next overflow pointer in the stream...
1:             if ( numberFields == 1 ) 
1:             {
1:                 // this is the last bit of the long column
1:                 _overflowPage = -1;
1:                 _overflowID = -1;
1:             } 
1:             else 
1:             {
1:                 int firstFieldStatus = fieldStatus; // for DEBUG check
1: 
1:                 // get the field status and data length of the overflow pointer.
1:                 fieldStatus = StoredFieldHeader.readStatus( _pageStream );
1:                 fieldDataLength = StoredFieldHeader.readFieldDataLength( _pageStream, fieldStatus, _slotReader.slotFieldSize() );
1: 
1:                 if ( !StoredFieldHeader.isOverflow( fieldStatus ) )
1:                 {
1:                     throw new IOException( "Corrupt overflow chain on page " + _overflowPage );
1:                 }
1: 
1:                 _overflowPage = CompressedNumber.readLong( (InputStream) _pageStream );
1:                 _overflowID = CompressedNumber.readInt( (InputStream) _pageStream );
1:             }
1:         }
1: 
1:         // cribbed from BasePage
1:         private int findRecordById( int recordId, int slotHint, int maxSlot )
1:         {
1:             if ( slotHint == Page.FIRST_SLOT_NUMBER )
1:             {
1:                 slotHint = recordId - RecordHandle.FIRST_RECORD_ID;
1:             }
1: 
1:             if (
1:                 (slotHint > Page.FIRST_SLOT_NUMBER) &&
1:                 (slotHint < maxSlot) && 
1:                 ( recordId == _slotReader.getRecordHeader( slotHint, _currentPageData ).getId() )
1:                )
1:             {
1:                 return(slotHint);
1:             }
1:             else
1:             {
1:                 for ( int slot = Page.FIRST_SLOT_NUMBER; slot < maxSlot; slot++ )
1:                 {
1:                     if ( recordId == _slotReader.getRecordHeader( slot, _currentPageData ).getId() )
1:                     {
1:                         return slot;
1:                     }
1:                 }
1:             }
1: 
1:             return -1;
1:         }
1: 
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // Other helper classes.
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     //
1:     // Used to keep track of where we are in the input stream.
1:     //
1:     public  static  final   class   WrapperInputStream   extends InputStream
1:     {
1:         private InputStream _wrapped;
1:         private long            _bytesRead;
1: 
1:         public  WrapperInputStream( InputStream is )
1:         {
1:             _wrapped = is;
1:             _bytesRead = 0L;
1:         }
1: 
1:         public  int read()  throws IOException
1:         {
1:             int     retval = _wrapped.read();
1: 
1:             if ( retval >= 0 ) { _bytesRead++; }
1: 
1:             return retval;
1:         }
1: 
1:         public  long    getBytesRead() { return _bytesRead; }
1:     }
1:     
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5a3453d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             try (FileInputStream in = new FileInputStream(serviceProperties)) {
1:                 properties.load(in);
1:             }
============================================================================