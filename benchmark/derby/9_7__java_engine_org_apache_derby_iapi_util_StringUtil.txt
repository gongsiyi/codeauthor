1:eac0369: /*
1:67b3e7f: 
1:bba6ca7:    Derby - Class org.apache.derby.iapi.util.StringUtil
1:7ecc1f2: 
1:11ec54f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11ec54f:    contributor license agreements.  See the NOTICE file distributed with
1:11ec54f:    this work for additional information regarding copyright ownership.
1:11ec54f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:11ec54f:    (the "License"); you may not use this file except in compliance with
1:11ec54f:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
8:eac0369:  */
31:eac0369: 
1:eac0369: package org.apache.derby.iapi.util;
1:09c890c: 
1:eac0369: import java.util.Locale;
1:c9a1206: 
1:67b3e7f: /**
1:eac0369: 	A set of public static methods for dealing with Strings
1:eac0369: */
1:eac0369: public class StringUtil 
8:eac0369: {
1:562a925: 	/**
1:eac0369: 	 * Used to print out a string for error messages, 
1:eac0369: 	 * chops is off at 60 chars for historical reasons.
1:eac0369: 	 */
1:eac0369: 	public final static String formatForPrint(String input)
1:eac0369: 	{
1:eac0369: 		if (input.length() > 60)
1:eac0369: 		{
1:eac0369: 			StringBuffer tmp = new StringBuffer(input.substring(0, 60));
1:eac0369: 			tmp.append("&");
1:eac0369: 			input = tmp.toString();
14:eac0369: 		}
1:eac0369: 		return input;
1:ae848fd: 	}
1:7233e33: 
1:7233e33: 	/**
1:eac0369: 	 * A method that receive an array of Objects and return a 
1:eac0369: 	 * String array representation of that array.
1:ae848fd: 	 */
1:eac0369: 	public static String [] toStringArray(Object [] objArray) {
1:eac0369: 		int idx;
1:eac0369: 		int len=objArray.length;
1:eac0369: 		String [] strArray=new String[len];
1:7233e33: 
1:eac0369: 		for (idx=0 ; idx<len ; idx++) {
1:eac0369: 			strArray[idx]=objArray[idx].toString();
1:c9a1206: 		}
1:ae848fd: 
1:eac0369: 		return strArray;
1:c9a1206: 	}
1:ae848fd: 
1:ae848fd: 	/**
1:eac0369: 		Get 7-bit ASCII character array from input String.
1:eac0369: 		The lower 7 bits of each character in the input string is assumed to be
1:eac0369: 		the ASCII character value.
1:ae848fd: 
1:eac0369:      Hexadecimal - Character
1:ae848fd: 
1:eac0369:      | 00 NUL| 01 SOH| 02 STX| 03 ETX| 04 EOT| 05 ENQ| 06 ACK| 07 BEL|
1:eac0369:      | 08 BS | 09 HT | 0A NL | 0B VT | 0C NP | 0D CR | 0E SO | 0F SI |
1:eac0369:      | 10 DLE| 11 DC1| 12 DC2| 13 DC3| 14 DC4| 15 NAK| 16 SYN| 17 ETB|
1:eac0369:      | 18 CAN| 19 EM | 1A SUB| 1B ESC| 1C FS | 1D GS | 1E RS | 1F US |
1:dbed020:      | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  &amp; | 27  ' |
1:eac0369:      | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
1:eac0369:      | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
1:dbed020:      | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  &lt; | 3D  = | 3E  &gt; | 3F  ? |
1:eac0369:      | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
1:eac0369:      | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
1:eac0369:      | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
1:eac0369:      | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
1:eac0369:      | 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
1:eac0369:      | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
1:eac0369:      | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
1:eac0369:      | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F DEL|
1:c9a1206: 
1:c9a1206: 	 */
1:eac0369: 	public static byte[] getAsciiBytes(String input)
1:b70badf: 	{
1:eac0369: 		char[] c = input.toCharArray();
1:eac0369: 		byte[] b = new byte[c.length];
1:eac0369: 		for (int i = 0; i < c.length; i++)
1:eac0369: 			b[i] = (byte)(c[i] & 0x007F);
1:c9a1206: 
1:eac0369: 		return b;
1:eac0369: 	}
1:c9a1206: 
1:ae848fd:     /**
1:eac0369:      * Trim off trailing blanks but not leading blanks
1:09c890c:      *
1:eac0369:      * @param str
1:09c890c:      *
1:eac0369:      * @return The input with trailing blanks stipped off
1:09c890c:      */
1:eac0369:     public static String trimTrailing( String str)
1:b70badf:     {
1:eac0369:         if( str == null)
1:eac0369:             return null;
1:eac0369:         int len = str.length();
1:eac0369:         for( ; len > 0; len--)
1:09c890c:         {
1:eac0369:             if( ! Character.isWhitespace( str.charAt( len - 1)))
1:eac0369:                 break;
1:09c890c:         }
1:eac0369:         return str.substring( 0, len);
1:eac0369:     } // end of trimTrailing
1:09c890c: 
1:09c890c: 
1:09c890c: 	/**
1:eac0369: 		Truncate a String to the given length with no warnings
1:eac0369: 		or error raised if it is bigger.
1:ae848fd: 	
1:eac0369: 		@param	value String to be truncated
1:eac0369: 		@param	length	Maximum length of string
1:c9a1206: 
1:eac0369: 		@return Returns value if value is null or value.length() is less or equal to than length, otherwise a String representing
1:eac0369: 			value truncated to length.
1:562a925: 	*/
1:eac0369: 	public static String truncate(String value, int length)
1:562a925: 	{
1:eac0369: 		if (value != null && value.length() > length)
1:eac0369: 			value = value.substring(0, length);
1:eac0369: 		return value;
1:09c890c: 	}
1:c9a1206: 	
1:c9a1206: 	/**
1:67b3e7f: 	 * Return a slice (substring) of the passed in value, optionally trimmed.
1:67b3e7f: 	 * WARNING - endOffset is inclusive for historical reasons, unlike
1:67b3e7f: 	 * String.substring() which has an exclusive ending offset.
1:67b3e7f: 	 * @param value Value to slice, must be non-null.
1:67b3e7f: 	 * @param beginOffset Inclusive start character
1:67b3e7f: 	 * @param endOffset Inclusive end character
1:67b3e7f: 	 * @param trim To trim or not to trim
1:67b3e7f: 	 * @return Sliceed value.
1:67b3e7f: 	 */
1:67b3e7f: 	public static String slice(String value,
1:67b3e7f: 			int beginOffset, int endOffset,
1:67b3e7f: 			boolean trim)
1:67b3e7f: 	{
1:67b3e7f: 		String retval = value.substring(beginOffset, endOffset + 1);
1:c9a1206: 		
1:67b3e7f: 		if (trim)
1:67b3e7f: 			retval = retval.trim();
1:c9a1206: 		
1:67b3e7f: 		return retval;
1:09c890c: 	}
1:c9a1206: 
1:c9a1206: 
1:eac0369: 	private static char[] hex_table = {
1:09c890c:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:09c890c:         'a', 'b', 'c', 'd', 'e', 'f'
1:09c890c:     };
1:c9a1206: 
1:c8e864b: 
1:c8e864b: 	/**
1:eac0369: 		Convert a byte array to a String with a hexidecimal format.
1:eac0369: 		The String may be converted back to a byte array using fromHexString.
1:7233e33: 		<BR>
1:eac0369: 		For each byte (b) two characaters are generated, the first character
1:dbed020: 		represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>), the second character
1:dbed020: 		represents the low nibble (<code>b &ampxs; 0x0f</code>).
1:7233e33: 		<BR>
1:eac0369: 		The byte at <code>data[offset]</code> is represented by the first two characters in the returned String.
1:7233e33: 
1:eac0369: 		@param	data	byte array
1:eac0369: 		@param	offset	starting byte (zero based) to convert.
1:eac0369: 		@param	length	number of bytes to convert.
1:7233e33: 
1:eac0369: 		@return the String (with hexidecimal format) form of the byte array
1:7233e33: 	*/
1:eac0369: 	public static String toHexString(byte[] data, int offset, int length)
1:7233e33: 	{
1:eac0369: 		StringBuffer s = new StringBuffer(length*2);
1:7233e33: 		int end = offset+length;
1:7233e33: 
1:7233e33: 		for (int i = offset; i < end; i++)
1:7233e33: 		{
1:eac0369: 			int high_nibble = (data[i] & 0xf0) >>> 4;
1:eac0369: 			int low_nibble = (data[i] & 0x0f);
1:eac0369: 			s.append(hex_table[high_nibble]);
1:eac0369: 			s.append(hex_table[low_nibble]);
1:7233e33: 		}
1:c8e864b: 
1:eac0369: 		return s.toString();
1:7233e33: 	}
1:67b3e7f: 
7:eac0369: 	/**
1:eac0369: 		Convert a hexidecimal string generated by toHexString() back
1:eac0369: 		into a byte array.
1:67b3e7f: 
1:eac0369: 		@param s String to convert
1:eac0369: 		@param offset starting character (zero based) to convert.
1:eac0369: 		@param length number of characters to convert.
1:eac0369: 
1:eac0369: 		@return the converted byte array. Returns null if the length is
1:eac0369: 		not a multiple of 2.
1:eac0369: 	*/
1:eac0369: 	public static byte[] fromHexString(String s, int offset, int length)
1:eac0369: 	{
1:eac0369: 		if ((length%2) != 0)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		byte[] byteArray = new byte[length/2];
1:eac0369: 
1:eac0369: 		int j = 0;
2:eac0369: 		int end = offset+length;
1:eac0369: 		for (int i = offset; i < end; i += 2)
1:eac0369: 		{
1:eac0369: 			int high_nibble = Character.digit(s.charAt(i), 16);
1:eac0369: 			int low_nibble = Character.digit(s.charAt(i+1), 16);
1:eac0369: 
1:eac0369: 			if (high_nibble == -1 || low_nibble == -1)
1:eac0369: 			{
1:eac0369: 				// illegal format
1:eac0369: 				return null;
1:562a925: 			}
1:eac0369: 
1:eac0369: 			byteArray[j++] = (byte)(((high_nibble << 4) & 0xf0) | (low_nibble & 0x0f));
1:562a925: 		}
1:eac0369: 		return byteArray;
1:562a925: 	}
1:eac0369: 	/**
1:eac0369: 		Convert a byte array to a human-readable String for debugging purposes.
1:eac0369: 	*/
1:eac0369: 	public static String hexDump(byte[] data)
1:eac0369: 	{
1:eac0369:             byte byte_value;
1:eac0369: 
1:eac0369: 
1:eac0369:             StringBuffer str = new StringBuffer(data.length * 3);
1:eac0369: 
1:eac0369:             str.append("Hex dump:\n");
1:eac0369: 
1:eac0369:             for (int i = 0; i < data.length; i += 16)
1:eac0369:             {
1:eac0369:                 // dump the header: 00000000: 
1:eac0369:                 String offset = Integer.toHexString(i);
1:eac0369: 
1:eac0369:                 // "0" left pad offset field so it is always 8 char's long.
1:eac0369:                 for (int offlen = offset.length(); offlen < 8; offlen++) 
1:eac0369:                     str.append("0");
1:eac0369:                 str.append(offset);
1:eac0369:                 str.append(":");
1:eac0369: 
1:eac0369:                 // dump hex version of 16 bytes per line.
1:eac0369:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
1:eac0369:                 {
1:eac0369:                     byte_value = data[i + j];
1:eac0369: 
1:eac0369:                     // add spaces between every 2 bytes.
1:eac0369:                     if ((j % 2) == 0)
1:eac0369:                         str.append(" ");
1:eac0369: 
1:eac0369:                     // dump a single byte.
1:eac0369:                     byte high_nibble = (byte) ((byte_value & 0xf0) >>> 4); 
1:eac0369:                     byte low_nibble  = (byte) (byte_value & 0x0f); 
1:eac0369: 
1:eac0369:                     str.append(hex_table[high_nibble]);
1:eac0369:                     str.append(hex_table[low_nibble]);
1:67b3e7f:                 }
1:eac0369: 
1:eac0369:                 // dump ascii version of 16 bytes
1:eac0369:                 str.append("  ");
1:eac0369: 
1:eac0369:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
1:eac0369:                 {
1:eac0369:                     char char_value = (char) data[i + j]; 
1:eac0369: 
1:eac0369:                     // RESOLVE (really want isAscii() or isPrintable())
1:eac0369:                     if (Character.isLetterOrDigit(char_value))
1:eac0369:                         str.append(String.valueOf(char_value));
1:eac0369:                     else
1:eac0369:                         str.append(".");
1:eac0369:                 }
1:eac0369:                     
1:eac0369:                 // new line
1:eac0369:                 str.append("\n");
1:eac0369:             }
1:eac0369:             return(str.toString());
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// The functions below are used for uppercasing SQL in a consistent manner.
1:3fd26f3: 	// Derby will uppercase Turkish to the English locale to avoid i
1:eac0369: 	// uppercasing to an uppercase dotted i. In future versions, all 
1:eac0369: 	// casing will be done in English.   The result will be that we will get
1:eac0369: 	// only the 1:1 mappings  in 
1:eac0369: 	// http://www.unicode.org/Public/3.0-Update1/UnicodeData-3.0.1.txt
1:eac0369: 	// and avoid the 1:n mappings in 
1:eac0369: 	//http://www.unicode.org/Public/3.0-Update1/SpecialCasing-3.txt
1:eac0369: 	// 
1:eac0369: 	// Any SQL casing should use these functions
1:eac0369: 
1:eac0369: 
1:eac0369: 	/** Convert string to uppercase
1:eac0369: 	 * Always use the java.util.ENGLISH locale
1:eac0369: 	 * @param s   string to uppercase
1:eac0369: 	 * @return uppercased string
1:eac0369: 	 */
1:eac0369: 	public static String SQLToUpperCase(String s)
1:eac0369: 	{
1:eac0369: 			return s.toUpperCase(Locale.ENGLISH);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Compares two strings 
1:eac0369: 	 * Strings will be uppercased in english and compared
1:eac0369: 	 * equivalent to s1.equalsIgnoreCase(s2)
1:eac0369: 	 * throws NPE if s1 is null
1:562a925: 	 *
1:eac0369: 	 * @param s1  first string to compare
1:eac0369: 	 * @param s2  second string to compare
1:562a925: 	 *
1:eac0369: 	 * @return   true if the two upppercased ENGLISH values are equal
1:eac0369: 	 *           return false if s2 is null
1:eac0369: 	 */
1:eac0369: 	public static boolean SQLEqualsIgnoreCase(String s1, String s2)
1:eac0369: 	{
1:eac0369: 		if (s2 == null)
1:eac0369: 			return  false;
1:eac0369: 		else
1:03f03b6: 			return SQLToUpperCase(s1).equals(SQLToUpperCase(s2));
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:c8e864b: 	 * Normalize a SQL identifer, up-casing if <regular identifer>,
1:c8e864b: 	 * and handling of <delimited identifer> (SQL 2003, section 5.2).
1:c8e864b: 	 * The normal form is used internally in Derby.
1:c8e864b: 	 *
1:c8e864b: 	 * @param id syntacically correct SQL identifier
1:c8e864b: 	 */
1:c8e864b: 	public static String normalizeSQLIdentifier(String id) {
1:c8e864b: 		if (id.length() == 0) {
1:c8e864b: 			return id;
1:c8e864b: 		}
1:c8e864b: 
1:c8e864b: 		if (id.charAt(0) == '"' &&
1:c8e864b: 				id.length() >= 3   &&
1:c8e864b: 				id.charAt(id.length() - 1) == '"') {
1:c8e864b: 			// assume syntax is OK, thats is, any quotes inside are doubled:
1:c8e864b: 
1:c8e864b: 			return StringUtil.compressQuotes(
1:c8e864b: 				id.substring(1, id.length() - 1), "\"\"");
1:c8e864b: 
1:c8e864b: 		} else {
1:c8e864b: 			return StringUtil.SQLToUpperCase(id);
1:c8e864b: 		}
1:c8e864b: 	}
1:c8e864b: 
1:c8e864b: 
1:c8e864b: 	/**
1:c8e864b: 	 * Compress 2 adjacent (single or double) quotes into a single (s or d)
1:c8e864b: 	 * quote when found in the middle of a String.
1:c8e864b: 	 *
1:c8e864b: 	 * NOTE:  """" or '''' will be compressed into "" or ''.
1:c8e864b: 	 * This function assumes that the leading and trailing quote from a
1:c8e864b: 	 * string or delimited identifier have already been removed.
1:c8e864b: 	 * @param source string to be compressed
1:c8e864b: 	 * @param quotes string containing two single or double quotes.
1:8959636: 	 * @return String where quotes have been compressed
1:c8e864b: 	 */
1:c8e864b: 	public static String compressQuotes(String source, String quotes)
1:c8e864b: 	{
1:c8e864b: 		String	result = source;
1:c8e864b: 		int		index;
1:c8e864b: 
1:c8e864b: 		/* Find the first occurrence of adjacent quotes. */
1:c8e864b: 		index = result.indexOf(quotes);
1:c8e864b: 
1:c8e864b: 		/* Replace each occurrence with a single quote and begin the
1:c8e864b: 		 * search for the next occurrence from where we left off.
1:c8e864b: 		 */
1:c8e864b: 		while (index != -1) {
1:c8e864b: 			result = result.substring(0, index + 1) +
1:c8e864b: 					 result.substring(index + 2);
1:c8e864b: 			index = result.indexOf(quotes, index + 1);
1:c8e864b: 		}
1:c8e864b: 
1:c8e864b: 		return result;
1:c8e864b: 	}
1:c8e864b: 
1:5b90cf1:     /**
1:5b90cf1:      * Quote a string so that it can be used as an identifier or a string
1:5b90cf1:      * literal in SQL statements. Identifiers are surrounded by double quotes
1:5b90cf1:      * and string literals are surrounded by single quotes. If the string
1:5b90cf1:      * contains quote characters, they are escaped.
1:5b90cf1:      *
1:5b90cf1:      * @param source the string to quote
1:5b90cf1:      * @param quote the character to quote the string with (' or &quot;)
1:5b90cf1:      * @return a string quoted with the specified quote character
1:5b90cf1:      * @see #quoteStringLiteral(String)
1:5b90cf1:      * @see IdUtil#normalToDelimited(String)
1:5b90cf1:      */
1:5b90cf1:     static String quoteString(String source, char quote) {
1:5b90cf1:         // Normally, the quoted string is two characters longer than the source
1:5b90cf1:         // string (because of start quote and end quote).
1:5b90cf1:         StringBuffer quoted = new StringBuffer(source.length() + 2);
1:5b90cf1:         quoted.append(quote);
1:5b90cf1:         for (int i = 0; i < source.length(); i++) {
1:5b90cf1:             char c = source.charAt(i);
1:5b90cf1:             // if the character is a quote, escape it with an extra quote
1:5b90cf1:             if (c == quote) quoted.append(quote);
1:5b90cf1:             quoted.append(c);
1:5b90cf1:         }
1:5b90cf1:         quoted.append(quote);
1:5b90cf1:         return quoted.toString();
1:5b90cf1:     }
1:c8e864b: 
1:5b90cf1:     /**
1:5b90cf1:      * Quote a string so that it can be used as a string literal in an
1:5b90cf1:      * SQL statement.
1:5b90cf1:      *
1:5b90cf1:      * @param string the string to quote
1:5b90cf1:      * @return the string surrounded by single quotes and with proper escaping
1:5b90cf1:      * of any single quotes inside the string
1:5b90cf1:      */
1:5b90cf1:     public static String quoteStringLiteral(String string) {
1:5b90cf1:         return quoteString(string, '\'');
1:b70badf:     }
1:b70badf: 
1:b70badf: 	/**
1:ae848fd: 	 * Utility for formatting which bends a multi-line string into shape for
1:ae848fd: 	 * outputting it in a context where there is <i>depth</i> tabs. Trailing
1:ae848fd: 	 * newlines are discarded as well.
1:ae848fd: 	 * <p>
1:ae848fd: 	 * Replace     "^[\t]*" with "depth" number of tabs.<br>
1:ae848fd: 	 * Replace     "\n+$" with "".
1:ae848fd: 	 * Replace all "\n[\t]*" with "\n" + "depth" number of tabs.<br>
1:ae848fd: 	 * </p>
1:ae848fd: 	 * @param formatted string to sanitize
1:ae848fd: 	 * @param depth indentation level the string is to be printed at (0,1,2..)
1:b70badf: 	 */
1:ae848fd: 	public static String ensureIndent(String formatted, int depth) {
1:ae848fd: 		StringBuffer indent = new StringBuffer();
1:b70badf: 
1:ae848fd: 		while (depth-- > 0) {
1:ae848fd: 			indent.append("\t");
1:b70badf: 		}
1:b70badf: 
1:ae848fd: 		if (formatted == null) {
1:ae848fd: 			return indent.toString() + "null";
1:5b90cf1: 		}
1:b70badf: 
1:ae848fd: 		/*
1:ae848fd: 		 * Sadly, we can't use java.util.regexp here since it's not supported
1:ae848fd: 		 * by Foundation 1.1
1:ae848fd: 		 */
1:ae848fd: 
1:ae848fd: 		formatted = doRegExpA(formatted, indent.toString());
1:ae848fd: 
1:ae848fd: 		formatted = doRegExpB(formatted);
1:ae848fd: 
1:ae848fd: 		formatted = doRegExpC(formatted, indent.toString());
1:ae848fd: 
1:ae848fd: 		return formatted;
1:ae848fd: 	}
1:ae848fd: 
1:ae848fd: 	/**
1:ae848fd: 	 * Reg.exp substitute:<br/>
1:ae848fd: 	 * <p/>
1:ae848fd: 	 * Pattern pat_a = Pattern.compile("\\A\\t*");<br/>
1:ae848fd: 	 * Matcher m_a = pat_a.matcher(src);<br/>
1:ae848fd: 	 * src = m_a.replaceFirst(indent.toString());<br/>
1:ae848fd: 	 *
1:ae848fd: 	 * @param src source string in which to substitute indent
1:ae848fd: 	 * @param indent indentation to lead source
1:ae848fd: 	 * @return new version of src after substitution
1:ae848fd: 	 *
1:ae848fd: 	 */
1:ae848fd: 	private static String doRegExpA(String src, String indent) {
1:ae848fd: 		StringBuffer result = new StringBuffer();
1:ae848fd: 		int idx = 0;
1:ae848fd: 
1:ae848fd: 		while (idx < src.length() && src.charAt(idx) == '\t') {
1:ae848fd: 			idx++;
1:ae848fd: 		}
1:ae848fd: 
1:ae848fd: 		result.append(indent);
1:ae848fd: 		result.append(src.substring(idx));
1:ae848fd: 		return result.toString();
1:ae848fd: 	}
1:502ed2e: 
1:502ed2e: 	/**
1:ae848fd: 	 * Reg.exp substitute:<br/>
1:ae848fd: 	 * <p/>
1:ae848fd: 	 * Pattern pat_b = Pattern.compile("\\n+\\Z");<br/>
1:ae848fd: 	 * Matcher m_b = pat_b.matcher(formatted);<br/>
1:ae848fd: 	 * formatted = m_b.replaceFirst("");<br/>
1:ae848fd: 	 *
1:ae848fd: 	 * @param src source string in which to substitute
1:ae848fd: 	 * @return new version of src after substitution
1:ae848fd: 	 *
1:ae848fd: 	 */
1:ae848fd: 	private static String doRegExpB(String src) {
1:ae848fd: 		StringBuffer result = new StringBuffer();
1:ae848fd: 		int idx = src.length() - 1;
1:ae848fd: 
1:ae848fd: 		while (idx >= 0 && src.charAt(idx) == '\n') {
1:ae848fd: 			idx--;
1:ae848fd: 		}
1:ae848fd: 
1:ae848fd: 		result.append(src.substring(0, idx + 1));
1:ae848fd: 		return result.toString();
1:ae848fd: 	}
1:ae848fd: 
1:ae848fd: 
1:ae848fd: 	/**
1:ae848fd: 	 * Reg.exp substitute:<br/>
1:ae848fd: 	 * <p/>
1:ae848fd: 	 * Pattern pat_c = Pattern.compile("\\n\\t*");<br/>
1:ae848fd: 	 * Matcher m_c = pat_c.matcher(formatted);<br/>
1:ae848fd: 	 * formatted = m_c.replaceAll("\n" + indent.toString());<br/>
1:ae848fd: 	 *
1:ae848fd: 	 * @param src source string in which to substitute indent
1:ae848fd: 	 * @param indent indentation to lead source
1:ae848fd: 	 * @return new version of src after substitution
1:ae848fd: 	 *
1:ae848fd: 	 */
1:ae848fd: 	private static String doRegExpC(String src, String indent) {
1:ae848fd: 
1:ae848fd: 		StringBuffer result = new StringBuffer();
1:ae848fd: 		int idx = 0;
1:ae848fd: 
1:ae848fd: 		while (idx < src.length()) {
1:ae848fd: 			char c = src.charAt(idx);
1:ae848fd: 
1:ae848fd: 			if (c == '\n') {
1:ae848fd: 				result.append(c);
1:ae848fd: 				int tabidx = idx + 1;
1:ae848fd: 
1:ae848fd: 				while (tabidx < src.length() && src.charAt(tabidx) == '\t') {
1:ae848fd: 					tabidx++;
1:ae848fd: 				}
1:ae848fd: 
1:ae848fd: 				result.append(indent);
1:ae848fd: 				idx = tabidx;
1:ae848fd: 			} else {
1:ae848fd: 				result.append(c);
1:ae848fd: 				idx++;
1:ae848fd: 			}
1:ae848fd: 		}
1:ae848fd: 		return result.toString();
1:ae848fd: 	}
1:ae848fd: 
1:eac0369:     /**
1:502ed2e:      * Get the short database name from the canonical name.
1:502ed2e:      */
1:502ed2e:     public  static  String  shortDBName
1:502ed2e:         (
1:502ed2e:          String canonicalDBName,
1:502ed2e:          char   separatorChar
1:502ed2e:          )
1:502ed2e:     {
1:502ed2e:         int         lastSep = canonicalDBName.lastIndexOf( separatorChar );
1:502ed2e:         return canonicalDBName.substring( lastSep + 1 );
1:502ed2e:     }
1:502ed2e:     
1:ae848fd: }
1:ae848fd: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  &amp; | 27  ' |
1:      | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  &lt; | 3D  = | 3E  &gt; | 3F  ? |
/////////////////////////////////////////////////////////////////////////
1: 		represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>), the second character
1: 		represents the low nibble (<code>b &ampxs; 0x0f</code>).
commit:502ed2e
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the short database name from the canonical name.
1:      */
1:     public  static  String  shortDBName
1:         (
1:          String canonicalDBName,
1:          char   separatorChar
1:          )
1:     {
1:         int         lastSep = canonicalDBName.lastIndexOf( separatorChar );
1:         return canonicalDBName.substring( lastSep + 1 );
1:     }
1:     
commit:15b837e
/////////////////////////////////////////////////////////////////////////
0:      * Turn an array of ints into a printable string. Returns what's returned
0:      * in Java 5 by java.util.Arrays.toString(int[]).
commit:b70badf
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Turn an array of ints into a printable string.
1:      */
0:     public  static  String  stringify( int[] raw )
1:     {
0:         if ( raw == null ) { return "null"; }
1:         
0:         StringBuffer    buffer = new StringBuffer();
0:         int                 count = raw.length;
1: 
0:         buffer.append( "[ " );
0:         for ( int i = 0; i < count; i++ )
1:         {
0:             if ( i > 0 ) { buffer.append( ", " ); }
0:             buffer.append( raw[ i ] );
1:         }
0:         buffer.append( " ]" );
1: 
0:         return buffer.toString();
1:     }
commit:09c890c
/////////////////////////////////////////////////////////////////////////
1: 
0: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0: 	 * Splits a string around matches of the given delimiter character.
1: 	 *
0: 	 * Where applicable, this method can be used as a substitute for
0: 	 * <code>String.split(String regex)</code>, which is not available
0: 	 * on a JSR169/Java ME platform.
1: 	 *
0: 	 * @param str the string to be split
0: 	 * @param delim the delimiter
0: 	 * @throws NullPointerException if str is null
1: 	 */
0: 	static public String[] split(String str, char delim)
1: 	{
0: 		if (str == null) {
0: 			throw new NullPointerException("str can't be null");
1: 		}
1: 
0: 		// Note the javadoc on StringTokenizer:
0: 		//     StringTokenizer is a legacy class that is retained for
0: 		//     compatibility reasons although its use is discouraged in
0: 		//     new code.
0:         // In other words, if StringTokenizer is ever removed from the JDK,
0:         // we need to have a look at String.split() (or java.util.regex)
0:         // if it is supported on a JSR169/Java ME platform by then.
0: 		StringTokenizer st = new StringTokenizer(str, String.valueOf(delim));
0: 		int n = st.countTokens();
0: 		String[] s = new String[n];
0: 		for (int i = 0; i < n; i++) {
0: 			s[i] = st.nextToken();
1: 		}
0: 		return s;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:         'a', 'b', 'c', 'd', 'e', 'f'
1:     };
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1: 
0:         Convert a string into a byte array in hex format.
1:         <BR>
0:         For each character (b) two bytes are generated, the first byte 
0:         represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:         the second byte represents the low nibble (<code>b & 0x0f</code>).
1:         <BR>
0:         The character at <code>str.charAt(0)</code> is represented by the first two bytes 
0:         in the returned String.
1: 
0:         @param	str string 
0:         @param	offset	starting character (zero based) to convert.
0:         @param	length	number of characters to convert.
1: 
0:         @return the byte[]  (with hexidecimal format) form of the string (str) 
1:     */
0:     public static byte[] toHexByte(String str, int offset, int length)
1:     {
0:         byte[] data = new byte[(length - offset) * 2];
1:         int end = offset+length;
1: 
1:         for (int i = offset; i < end; i++)
1:         {
0:             char ch = str.charAt(i);
0:             int high_nibble = (ch & 0xf0) >>> 4;
0:             int low_nibble = (ch & 0x0f);
0:             data[i] = (byte)high_nibble;
0:             data[i+1] = (byte)low_nibble;
1:         }
0:         return data;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3c23476
/////////////////////////////////////////////////////////////////////////
commit:be94230
/////////////////////////////////////////////////////////////////////////
commit:178ca0c
/////////////////////////////////////////////////////////////////////////
commit:5b90cf1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Quote a string so that it can be used as an identifier or a string
1:      * literal in SQL statements. Identifiers are surrounded by double quotes
1:      * and string literals are surrounded by single quotes. If the string
1:      * contains quote characters, they are escaped.
1:      *
1:      * @param source the string to quote
1:      * @param quote the character to quote the string with (' or &quot;)
1:      * @return a string quoted with the specified quote character
1:      * @see #quoteStringLiteral(String)
1:      * @see IdUtil#normalToDelimited(String)
1:      */
1:     static String quoteString(String source, char quote) {
1:         // Normally, the quoted string is two characters longer than the source
1:         // string (because of start quote and end quote).
1:         StringBuffer quoted = new StringBuffer(source.length() + 2);
1:         quoted.append(quote);
1:         for (int i = 0; i < source.length(); i++) {
1:             char c = source.charAt(i);
1:             // if the character is a quote, escape it with an extra quote
1:             if (c == quote) quoted.append(quote);
1:             quoted.append(c);
1:         }
1:         quoted.append(quote);
1:         return quoted.toString();
1:     }
1:     /**
1:      * Quote a string so that it can be used as a string literal in an
1:      * SQL statement.
1:      *
1:      * @param string the string to quote
1:      * @return the string surrounded by single quotes and with proper escaping
1:      * of any single quotes inside the string
1:      */
1:     public static String quoteStringLiteral(String string) {
1:         return quoteString(string, '\'');
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:78befe8
/////////////////////////////////////////////////////////////////////////
commit:bba6ca7
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.util.StringUtil
commit:562a925
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Splits a string around matches of the given delimiter character.
1:      *
0:      * Where applicable, this method can be used as a substitute for
0:      * <code>String.split(String regex)</code>, which is not available
0:      * on a JSR169/Java ME platform.
1:      *
0:      * @param str the string to be split
0:      * @param delim the delimiter
0:      * @throws NullPointerException if str is null
1:      */
0:     static public String[] split(String str, char delim)
1:     {
0:         if (str == null) {
0:             throw new NullPointerException("str can't be null");
1:         }
0:         // Note the javadoc on StringTokenizer:
0:         //     StringTokenizer is a legacy class that is retained for
0:         //     compatibility reasons although its use is discouraged in
0:         //     new code.
0:         StringTokenizer st = new StringTokenizer(str, String.valueOf(delim));
0:         int n = st.countTokens();
0:         String[] s = new String[n];
0:         for (int i = 0; i < n; i++) {
0:             s[i] = st.nextToken();
1:         }
0:         return s;
1:     }
commit:8959636
/////////////////////////////////////////////////////////////////////////
1: 	 * @return String where quotes have been compressed
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ae848fd
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * Utility for formatting which bends a multi-line string into shape for
1: 	 * outputting it in a context where there is <i>depth</i> tabs. Trailing
1: 	 * newlines are discarded as well.
1: 	 * <p>
1: 	 * Replace     "^[\t]*" with "depth" number of tabs.<br>
1: 	 * Replace     "\n+$" with "".
1: 	 * Replace all "\n[\t]*" with "\n" + "depth" number of tabs.<br>
1: 	 * </p>
1: 	 * @param formatted string to sanitize
1: 	 * @param depth indentation level the string is to be printed at (0,1,2..)
1: 	 */
1: 	public static String ensureIndent(String formatted, int depth) {
0: 		StringBuffer buf = new StringBuffer();
1: 		StringBuffer indent = new StringBuffer();
1: 
1: 		while (depth-- > 0) {
1: 			indent.append("\t");
1: 		}
1: 
1: 		if (formatted == null) {
1: 			return indent.toString() + "null";
1: 		}
1: 
1: 		/*
1: 		 * Sadly, we can't use java.util.regexp here since it's not supported
1: 		 * by Foundation 1.1
1: 		 */
1: 
1: 		formatted = doRegExpA(formatted, indent.toString());
1: 
1: 		formatted = doRegExpB(formatted);
1: 
1: 		formatted = doRegExpC(formatted, indent.toString());
1: 
1: 		return formatted;
1: 	}
1: 
1: 	/**
1: 	 * Reg.exp substitute:<br/>
1: 	 * <p/>
1: 	 * Pattern pat_a = Pattern.compile("\\A\\t*");<br/>
1: 	 * Matcher m_a = pat_a.matcher(src);<br/>
1: 	 * src = m_a.replaceFirst(indent.toString());<br/>
1: 	 *
1: 	 * @param src source string in which to substitute indent
1: 	 * @param indent indentation to lead source
1: 	 * @return new version of src after substitution
1: 	 *
1: 	 */
1: 	private static String doRegExpA(String src, String indent) {
1: 		StringBuffer result = new StringBuffer();
1: 		int idx = 0;
1: 
1: 		while (idx < src.length() && src.charAt(idx) == '\t') {
1: 			idx++;
1: 		}
1: 
1: 		result.append(indent);
1: 		result.append(src.substring(idx));
1: 		return result.toString();
1: 	}
1: 
1: 	/**
1: 	 * Reg.exp substitute:<br/>
1: 	 * <p/>
1: 	 * Pattern pat_b = Pattern.compile("\\n+\\Z");<br/>
1: 	 * Matcher m_b = pat_b.matcher(formatted);<br/>
1: 	 * formatted = m_b.replaceFirst("");<br/>
1: 	 *
1: 	 * @param src source string in which to substitute
1: 	 * @return new version of src after substitution
1: 	 *
1: 	 */
1: 	private static String doRegExpB(String src) {
1: 		StringBuffer result = new StringBuffer();
1: 		int idx = src.length() - 1;
1: 
1: 		while (idx >= 0 && src.charAt(idx) == '\n') {
1: 			idx--;
1: 		}
1: 
1: 		result.append(src.substring(0, idx + 1));
1: 		return result.toString();
1: 	}
1: 
1: 
1: 	/**
1: 	 * Reg.exp substitute:<br/>
1: 	 * <p/>
1: 	 * Pattern pat_c = Pattern.compile("\\n\\t*");<br/>
1: 	 * Matcher m_c = pat_c.matcher(formatted);<br/>
1: 	 * formatted = m_c.replaceAll("\n" + indent.toString());<br/>
1: 	 *
1: 	 * @param src source string in which to substitute indent
1: 	 * @param indent indentation to lead source
1: 	 * @return new version of src after substitution
1: 	 *
1: 	 */
1: 	private static String doRegExpC(String src, String indent) {
1: 
1: 		StringBuffer result = new StringBuffer();
1: 		int idx = 0;
1: 
1: 		while (idx < src.length()) {
1: 			char c = src.charAt(idx);
1: 
1: 			if (c == '\n') {
1: 				result.append(c);
1: 				int tabidx = idx + 1;
1: 
1: 				while (tabidx < src.length() && src.charAt(tabidx) == '\t') {
1: 					tabidx++;
1: 				}
1: 
1: 				result.append(indent);
1: 				idx = tabidx;
1: 			} else {
1: 				result.append(c);
1: 				idx++;
1: 			}
1: 		}
1: 		return result.toString();
1: 	}
1: 
commit:14fde85
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
0: import java.util.regex.Pattern;
0: import java.util.regex.Matcher;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
0: 	 * Utility for formatting which bends a multi-line string into shape for
0: 	 * outputting it in a context where there is <i>depth</i> tabs. Trailing
0: 	 * newlines are discarded as well.
0: 	 * <p>
0: 	 * Replace     "^[\t]*" with "depth" number of tabs.<br>
0: 	 * Replace     "\n+$" with "".
0: 	 * Replace all "\n[\t]*" with "\n" + "depth" number of tabs.<br>
0: 	 * </p>
0: 	 * @param formatted string to sanitize
0: 	 * @param depth the string is to be printed at
1: 	 */
0: 	public static String ensureIndent(String formatted, int depth) {
0: 		StringBuffer buf = new StringBuffer();
0: 		StringBuffer indent = new StringBuffer();
1: 
0: 		while (depth-- > 0) {
0: 			indent.append("\t");
1: 		}
1: 
1: 
0: 		Pattern pat_a = Pattern.compile("\\A\\t*");
0: 		Matcher m_a = pat_a.matcher(formatted);
1: 
0: 		formatted = m_a.replaceFirst(indent.toString());
1: 
0: 		Pattern pat_b = Pattern.compile("\\n+\\Z");
0: 		Matcher m_b = pat_b.matcher(formatted);
0: 		formatted = m_b.replaceFirst("");
1: 
0: 		Pattern pat_c = Pattern.compile("\\n\\t*");
0: 		Matcher m_c = pat_c.matcher(formatted);
0: 		formatted = m_c.replaceAll("\n" + indent.toString());
1: 
1: 
0: 		return formatted;
1: 	}
commit:c8e864b
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Normalize a SQL identifer, up-casing if <regular identifer>,
1: 	 * and handling of <delimited identifer> (SQL 2003, section 5.2).
1: 	 * The normal form is used internally in Derby.
1: 	 *
1: 	 * @param id syntacically correct SQL identifier
1: 	 */
1: 	public static String normalizeSQLIdentifier(String id) {
1: 		if (id.length() == 0) {
1: 			return id;
1: 		}
1: 
1: 		if (id.charAt(0) == '"' &&
1: 				id.length() >= 3   &&
1: 				id.charAt(id.length() - 1) == '"') {
1: 			// assume syntax is OK, thats is, any quotes inside are doubled:
1: 
1: 			return StringUtil.compressQuotes(
1: 				id.substring(1, id.length() - 1), "\"\"");
1: 
1: 		} else {
1: 			return StringUtil.SQLToUpperCase(id);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Compress 2 adjacent (single or double) quotes into a single (s or d)
1: 	 * quote when found in the middle of a String.
1: 	 *
1: 	 * NOTE:  """" or '''' will be compressed into "" or ''.
1: 	 * This function assumes that the leading and trailing quote from a
1: 	 * string or delimited identifier have already been removed.
1: 	 * @param source string to be compressed
1: 	 * @param quotes string containing two single or double quotes.
0: 	 * @returns String where quotes have been compressed
1: 	 */
1: 	public static String compressQuotes(String source, String quotes)
1: 	{
1: 		String	result = source;
1: 		int		index;
1: 
1: 		/* Find the first occurrence of adjacent quotes. */
1: 		index = result.indexOf(quotes);
1: 
1: 		/* Replace each occurrence with a single quote and begin the
1: 		 * search for the next occurrence from where we left off.
1: 		 */
1: 		while (index != -1) {
1: 			result = result.substring(0, index + 1) +
1: 					 result.substring(index + 2);
1: 			index = result.indexOf(quotes, index + 1);
1: 		}
1: 
1: 		return result;
1: 	}
1: 
1: 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:aa438ff
/////////////////////////////////////////////////////////////////////////
commit:03f03b6
/////////////////////////////////////////////////////////////////////////
1: 			return SQLToUpperCase(s1).equals(SQLToUpperCase(s2));
commit:67b3e7f
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Return a slice (substring) of the passed in value, optionally trimmed.
1: 	 * WARNING - endOffset is inclusive for historical reasons, unlike
1: 	 * String.substring() which has an exclusive ending offset.
1: 	 * @param value Value to slice, must be non-null.
1: 	 * @param beginOffset Inclusive start character
1: 	 * @param endOffset Inclusive end character
1: 	 * @param trim To trim or not to trim
1: 	 * @return Sliceed value.
1: 	 */
1: 	public static String slice(String value,
1: 			int beginOffset, int endOffset,
1: 			boolean trim)
1: 	{
1: 		String retval = value.substring(beginOffset, endOffset + 1);
1: 		
1: 		if (trim)
1: 			retval = retval.trim();
1: 		
1: 		return retval;
1: 	}
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class com.ihost.cs.StringUtil
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package com.ihost.cs
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.util;
1: import java.util.Locale;
1: 
1: /**
1: 	A set of public static methods for dealing with Strings
1: */
1: public class StringUtil 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/**
1: 	 * Used to print out a string for error messages, 
1: 	 * chops is off at 60 chars for historical reasons.
1: 	 */
1: 	public final static String formatForPrint(String input)
1: 	{
1: 		if (input.length() > 60)
1: 		{
1: 			StringBuffer tmp = new StringBuffer(input.substring(0, 60));
1: 			tmp.append("&");
1: 			input = tmp.toString();
1: 		}
1: 		return input;
1: 	}
1: 
1: 	/**
1: 	 * A method that receive an array of Objects and return a 
1: 	 * String array representation of that array.
1: 	 */
1: 	public static String [] toStringArray(Object [] objArray) {
1: 		int idx;
1: 		int len=objArray.length;
1: 		String [] strArray=new String[len];
1: 
1: 		for (idx=0 ; idx<len ; idx++) {
1: 			strArray[idx]=objArray[idx].toString();
1: 		}
1: 
1: 		return strArray;
1: 	}
1: 
1: 	/**
1: 		Get 7-bit ASCII character array from input String.
1: 		The lower 7 bits of each character in the input string is assumed to be
1: 		the ASCII character value.
1: 
1:      Hexadecimal - Character
1: 
1:      | 00 NUL| 01 SOH| 02 STX| 03 ETX| 04 EOT| 05 ENQ| 06 ACK| 07 BEL|
1:      | 08 BS | 09 HT | 0A NL | 0B VT | 0C NP | 0D CR | 0E SO | 0F SI |
1:      | 10 DLE| 11 DC1| 12 DC2| 13 DC3| 14 DC4| 15 NAK| 16 SYN| 17 ETB|
1:      | 18 CAN| 19 EM | 1A SUB| 1B ESC| 1C FS | 1D GS | 1E RS | 1F US |
0:      | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
1:      | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
1:      | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
0:      | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
1:      | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
1:      | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
1:      | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
1:      | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
1:      | 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
1:      | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
1:      | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
1:      | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F DEL|
1: 
1: 	 */
1: 	public static byte[] getAsciiBytes(String input)
1: 	{
1: 		char[] c = input.toCharArray();
1: 		byte[] b = new byte[c.length];
1: 		for (int i = 0; i < c.length; i++)
1: 			b[i] = (byte)(c[i] & 0x007F);
1: 
1: 		return b;
1: 	}
1: 
1:     /**
1:      * Trim off trailing blanks but not leading blanks
0:      *
1:      * @param str
0:      *
1:      * @return The input with trailing blanks stipped off
1:      */
1:     public static String trimTrailing( String str)
1:     {
1:         if( str == null)
1:             return null;
1:         int len = str.length();
1:         for( ; len > 0; len--)
1:         {
1:             if( ! Character.isWhitespace( str.charAt( len - 1)))
1:                 break;
1:         }
1:         return str.substring( 0, len);
1:     } // end of trimTrailing
1: 
1: 
1: 	/**
1: 		Truncate a String to the given length with no warnings
1: 		or error raised if it is bigger.
1: 	
1: 		@param	value String to be truncated
1: 		@param	length	Maximum length of string
1: 
1: 		@return Returns value if value is null or value.length() is less or equal to than length, otherwise a String representing
1: 			value truncated to length.
1: 	*/
1: 	public static String truncate(String value, int length)
1: 	{
1: 		if (value != null && value.length() > length)
1: 			value = value.substring(0, length);
1: 		return value;
1: 	}
1: 
1: 
1: 	private static char[] hex_table = {
0:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
0:                 'a', 'b', 'c', 'd', 'e', 'f'
0:             };
1: 
1: 
1: 	/**
1: 		Convert a byte array to a String with a hexidecimal format.
1: 		The String may be converted back to a byte array using fromHexString.
0: 		<BR>
1: 		For each byte (b) two characaters are generated, the first character
0: 		represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>), the second character
0: 		represents the low nibble (<code>b & 0x0f</code>).
0: 		<BR>
1: 		The byte at <code>data[offset]</code> is represented by the first two characters in the returned String.
1: 
1: 		@param	data	byte array
1: 		@param	offset	starting byte (zero based) to convert.
1: 		@param	length	number of bytes to convert.
1: 
1: 		@return the String (with hexidecimal format) form of the byte array
1: 	*/
1: 	public static String toHexString(byte[] data, int offset, int length)
1: 	{
1: 		StringBuffer s = new StringBuffer(length*2);
1: 		int end = offset+length;
1: 
0: 		for (int i = offset; i < end; i++)
1: 		{
1: 			int high_nibble = (data[i] & 0xf0) >>> 4;
1: 			int low_nibble = (data[i] & 0x0f);
1: 			s.append(hex_table[high_nibble]);
1: 			s.append(hex_table[low_nibble]);
1: 		}
1: 
1: 		return s.toString();
1: 	}
1: 		
1: 	/**
1: 		Convert a hexidecimal string generated by toHexString() back
1: 		into a byte array.
1: 
1: 		@param s String to convert
1: 		@param offset starting character (zero based) to convert.
1: 		@param length number of characters to convert.
1: 
1: 		@return the converted byte array. Returns null if the length is
1: 		not a multiple of 2.
1: 	*/
1: 	public static byte[] fromHexString(String s, int offset, int length)
1: 	{
1: 		if ((length%2) != 0)
1: 			return null;
1: 
1: 		byte[] byteArray = new byte[length/2];
1: 
1: 		int j = 0;
1: 		int end = offset+length;
1: 		for (int i = offset; i < end; i += 2)
1: 		{
1: 			int high_nibble = Character.digit(s.charAt(i), 16);
1: 			int low_nibble = Character.digit(s.charAt(i+1), 16);
1: 
1: 			if (high_nibble == -1 || low_nibble == -1)
1: 			{
1: 				// illegal format
1: 				return null;
1: 			}
1: 
1: 			byteArray[j++] = (byte)(((high_nibble << 4) & 0xf0) | (low_nibble & 0x0f));
1: 		}
1: 		return byteArray;
1: 	}
1: 	/**
1: 		Convert a byte array to a human-readable String for debugging purposes.
1: 	*/
1: 	public static String hexDump(byte[] data)
1: 	{
1:             byte byte_value;
1: 
1: 
1:             StringBuffer str = new StringBuffer(data.length * 3);
1: 
1:             str.append("Hex dump:\n");
1: 
1:             for (int i = 0; i < data.length; i += 16)
1:             {
1:                 // dump the header: 00000000: 
1:                 String offset = Integer.toHexString(i);
1: 
1:                 // "0" left pad offset field so it is always 8 char's long.
1:                 for (int offlen = offset.length(); offlen < 8; offlen++) 
1:                     str.append("0");
1:                 str.append(offset);
1:                 str.append(":");
1: 
1:                 // dump hex version of 16 bytes per line.
1:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
1:                 {
1:                     byte_value = data[i + j];
1: 
1:                     // add spaces between every 2 bytes.
1:                     if ((j % 2) == 0)
1:                         str.append(" ");
1: 
1:                     // dump a single byte.
1:                     byte high_nibble = (byte) ((byte_value & 0xf0) >>> 4); 
1:                     byte low_nibble  = (byte) (byte_value & 0x0f); 
1: 
1:                     str.append(hex_table[high_nibble]);
1:                     str.append(hex_table[low_nibble]);
1:                 }
1: 
1:                 // dump ascii version of 16 bytes
1:                 str.append("  ");
1: 
1:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
1:                 {
1:                     char char_value = (char) data[i + j]; 
1: 
1:                     // RESOLVE (really want isAscii() or isPrintable())
1:                     if (Character.isLetterOrDigit(char_value))
1:                         str.append(String.valueOf(char_value));
1:                     else
1:                         str.append(".");
1:                 }
1:                     
1:                 // new line
1:                 str.append("\n");
1:             }
1:             return(str.toString());
1: 
1: 	}
1: 
1: 	// The functions below are used for uppercasing SQL in a consistent manner.
0: 	// Cloudscape will uppercase Turkish to the English locale to avoid i
1: 	// uppercasing to an uppercase dotted i. In future versions, all 
1: 	// casing will be done in English.   The result will be that we will get
1: 	// only the 1:1 mappings  in 
1: 	// http://www.unicode.org/Public/3.0-Update1/UnicodeData-3.0.1.txt
1: 	// and avoid the 1:n mappings in 
1: 	//http://www.unicode.org/Public/3.0-Update1/SpecialCasing-3.txt
1: 	// 
1: 	// Any SQL casing should use these functions
1: 
1: 
1: 	/** Convert string to uppercase
1: 	 * Always use the java.util.ENGLISH locale
1: 	 * @param s   string to uppercase
1: 	 * @return uppercased string
1: 	 */
1: 	public static String SQLToUpperCase(String s)
1: 	{
1: 			return s.toUpperCase(Locale.ENGLISH);
1: 	}
1: 
1: 
0: 	/** Convert string to lowercase
0: 	 *  Return java.util.Locale.ENGLISH lowercasing
0: 	 * @param s string to lowercase
0: 	 * @return lowercased string
1: 	 */
0: 	public static String SQLToLowerCase(String s)
1: 	{
0: 		return s.toLowerCase(Locale.ENGLISH);
1: 
1: 	}
1: 
1: 
1: 	/** Compares two strings 
1: 	 * Strings will be uppercased in english and compared
1: 	 * equivalent to s1.equalsIgnoreCase(s2)
1: 	 * throws NPE if s1 is null
0: 	 *
1: 	 * @param s1  first string to compare
1: 	 * @param s2  second string to compare
0: 	 *
1: 	 * @return   true if the two upppercased ENGLISH values are equal
1: 	 *           return false if s2 is null
1: 	 */
1: 	public static boolean SQLEqualsIgnoreCase(String s1, String s2)
1: 	{
1: 		if (s2 == null)
1: 			return  false;
1: 		else
0: 			return s1.toUpperCase(Locale.ENGLISH).equals(s2.toUpperCase(Locale.ENGLISH));
1: 
1: 	}
1: 
1: }
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	// Derby will uppercase Turkish to the English locale to avoid i
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11ec54f
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package com.ihost.cs
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.util;
0: import java.util.Locale;
0: 
0: /**
0: 	A set of public static methods for dealing with Strings
0: */
0: public class StringUtil 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/**
0: 	 * Used to print out a string for error messages, 
0: 	 * chops is off at 60 chars for historical reasons.
0: 	 */
0: 	public final static String formatForPrint(String input)
0: 	{
0: 		if (input.length() > 60)
0: 		{
0: 			StringBuffer tmp = new StringBuffer(input.substring(0, 60));
0: 			tmp.append("&");
0: 			input = tmp.toString();
0: 		}
0: 		return input;
0: 	}
0: 
0: 	/**
0: 	 * A method that receive an array of Objects and return a 
0: 	 * String array representation of that array.
0: 	 */
0: 	public static String [] toStringArray(Object [] objArray) {
0: 		int idx;
0: 		int len=objArray.length;
0: 		String [] strArray=new String[len];
0: 
0: 		for (idx=0 ; idx<len ; idx++) {
0: 			strArray[idx]=objArray[idx].toString();
0: 		}
0: 
0: 		return strArray;
0: 	}
0: 
0: 	/**
0: 		Get 7-bit ASCII character array from input String.
0: 		The lower 7 bits of each character in the input string is assumed to be
0: 		the ASCII character value.
0: 
0:      Hexadecimal - Character
0: 
0:      | 00 NUL| 01 SOH| 02 STX| 03 ETX| 04 EOT| 05 ENQ| 06 ACK| 07 BEL|
0:      | 08 BS | 09 HT | 0A NL | 0B VT | 0C NP | 0D CR | 0E SO | 0F SI |
0:      | 10 DLE| 11 DC1| 12 DC2| 13 DC3| 14 DC4| 15 NAK| 16 SYN| 17 ETB|
0:      | 18 CAN| 19 EM | 1A SUB| 1B ESC| 1C FS | 1D GS | 1E RS | 1F US |
0:      | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
0:      | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
0:      | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
0:      | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
0:      | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
0:      | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
0:      | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
0:      | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
0:      | 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
0:      | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
0:      | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
0:      | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F DEL|
0: 
0: 	 */
0: 	public static byte[] getAsciiBytes(String input)
0: 	{
0: 		char[] c = input.toCharArray();
0: 		byte[] b = new byte[c.length];
0: 		for (int i = 0; i < c.length; i++)
0: 			b[i] = (byte)(c[i] & 0x007F);
0: 
0: 		return b;
0: 	}
0: 
0:     /**
0:      * Trim off trailing blanks but not leading blanks
0:      *
0:      * @param str
0:      *
0:      * @return The input with trailing blanks stipped off
0:      */
0:     public static String trimTrailing( String str)
0:     {
0:         if( str == null)
0:             return null;
0:         int len = str.length();
0:         for( ; len > 0; len--)
0:         {
0:             if( ! Character.isWhitespace( str.charAt( len - 1)))
0:                 break;
0:         }
0:         return str.substring( 0, len);
0:     } // end of trimTrailing
0: 
0: 
0: 	/**
0: 		Truncate a String to the given length with no warnings
0: 		or error raised if it is bigger.
0: 	
0: 		@param	value String to be truncated
0: 		@param	length	Maximum length of string
0: 
0: 		@return Returns value if value is null or value.length() is less or equal to than length, otherwise a String representing
0: 			value truncated to length.
0: 	*/
0: 	public static String truncate(String value, int length)
0: 	{
0: 		if (value != null && value.length() > length)
0: 			value = value.substring(0, length);
0: 		return value;
0: 	}
0: 
0: 
0: 	private static char[] hex_table = {
0:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
0:                 'a', 'b', 'c', 'd', 'e', 'f'
0:             };
0: 
0: 
0: 	/**
0: 		Convert a byte array to a String with a hexidecimal format.
0: 		The String may be converted back to a byte array using fromHexString.
0: 		<BR>
0: 		For each byte (b) two characaters are generated, the first character
0: 		represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>), the second character
0: 		represents the low nibble (<code>b & 0x0f</code>).
0: 		<BR>
0: 		The byte at <code>data[offset]</code> is represented by the first two characters in the returned String.
0: 
0: 		@param	data	byte array
0: 		@param	offset	starting byte (zero based) to convert.
0: 		@param	length	number of bytes to convert.
0: 
0: 		@return the String (with hexidecimal format) form of the byte array
0: 	*/
0: 	public static String toHexString(byte[] data, int offset, int length)
0: 	{
0: 		StringBuffer s = new StringBuffer(length*2);
0: 		int end = offset+length;
0: 
0: 		for (int i = offset; i < end; i++)
0: 		{
0: 			int high_nibble = (data[i] & 0xf0) >>> 4;
0: 			int low_nibble = (data[i] & 0x0f);
0: 			s.append(hex_table[high_nibble]);
0: 			s.append(hex_table[low_nibble]);
0: 		}
0: 
0: 		return s.toString();
0: 	}
0: 		
0: 	/**
0: 		Convert a hexidecimal string generated by toHexString() back
0: 		into a byte array.
0: 
0: 		@param s String to convert
0: 		@param offset starting character (zero based) to convert.
0: 		@param length number of characters to convert.
0: 
0: 		@return the converted byte array. Returns null if the length is
0: 		not a multiple of 2.
0: 	*/
0: 	public static byte[] fromHexString(String s, int offset, int length)
0: 	{
0: 		if ((length%2) != 0)
0: 			return null;
0: 
0: 		byte[] byteArray = new byte[length/2];
0: 
0: 		int j = 0;
0: 		int end = offset+length;
0: 		for (int i = offset; i < end; i += 2)
0: 		{
0: 			int high_nibble = Character.digit(s.charAt(i), 16);
0: 			int low_nibble = Character.digit(s.charAt(i+1), 16);
0: 
0: 			if (high_nibble == -1 || low_nibble == -1)
0: 			{
0: 				// illegal format
0: 				return null;
0: 			}
0: 
0: 			byteArray[j++] = (byte)(((high_nibble << 4) & 0xf0) | (low_nibble & 0x0f));
0: 		}
0: 		return byteArray;
0: 	}
0: 	/**
0: 		Convert a byte array to a human-readable String for debugging purposes.
0: 	*/
0: 	public static String hexDump(byte[] data)
0: 	{
0:             byte byte_value;
0: 
0: 
0:             StringBuffer str = new StringBuffer(data.length * 3);
0: 
0:             str.append("Hex dump:\n");
0: 
0:             for (int i = 0; i < data.length; i += 16)
0:             {
0:                 // dump the header: 00000000: 
0:                 String offset = Integer.toHexString(i);
0: 
0:                 // "0" left pad offset field so it is always 8 char's long.
0:                 for (int offlen = offset.length(); offlen < 8; offlen++) 
0:                     str.append("0");
0:                 str.append(offset);
0:                 str.append(":");
0: 
0:                 // dump hex version of 16 bytes per line.
0:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
0:                 {
0:                     byte_value = data[i + j];
0: 
0:                     // add spaces between every 2 bytes.
0:                     if ((j % 2) == 0)
0:                         str.append(" ");
0: 
0:                     // dump a single byte.
0:                     byte high_nibble = (byte) ((byte_value & 0xf0) >>> 4); 
0:                     byte low_nibble  = (byte) (byte_value & 0x0f); 
0: 
0:                     str.append(hex_table[high_nibble]);
0:                     str.append(hex_table[low_nibble]);
0:                 }
0: 
0:                 // dump ascii version of 16 bytes
0:                 str.append("  ");
0: 
0:                 for (int j = 0; (j < 16) && ((i + j) < data.length); j++)
0:                 {
0:                     char char_value = (char) data[i + j]; 
0: 
0:                     // RESOLVE (really want isAscii() or isPrintable())
0:                     if (Character.isLetterOrDigit(char_value))
0:                         str.append(String.valueOf(char_value));
0:                     else
0:                         str.append(".");
0:                 }
0:                     
0:                 // new line
0:                 str.append("\n");
0:             }
0:             return(str.toString());
0: 
0: 	}
0: 
0: 	// The functions below are used for uppercasing SQL in a consistent manner.
0: 	// Cloudscape will uppercase Turkish to the English locale to avoid i
0: 	// uppercasing to an uppercase dotted i. In future versions, all 
0: 	// casing will be done in English.   The result will be that we will get
0: 	// only the 1:1 mappings  in 
0: 	// http://www.unicode.org/Public/3.0-Update1/UnicodeData-3.0.1.txt
0: 	// and avoid the 1:n mappings in 
0: 	//http://www.unicode.org/Public/3.0-Update1/SpecialCasing-3.txt
0: 	// 
0: 	// Any SQL casing should use these functions
0: 
0: 
0: 	/** Convert string to uppercase
0: 	 * Always use the java.util.ENGLISH locale
0: 	 * @param s   string to uppercase
0: 	 * @return uppercased string
0: 	 */
0: 	public static String SQLToUpperCase(String s)
0: 	{
0: 			return s.toUpperCase(Locale.ENGLISH);
0: 	}
0: 
0: 
0: 	/** Convert string to lowercase
0: 	 *  Return java.util.Locale.ENGLISH lowercasing
0: 	 * @param s string to lowercase
0: 	 * @return lowercased string
0: 	 */
0: 	public static String SQLToLowerCase(String s)
0: 	{
0: 		return s.toLowerCase(Locale.ENGLISH);
0: 
0: 	}
0: 
0: 
0: 	/** Compares two strings 
0: 	 * Strings will be uppercased in english and compared
0: 	 * equivalent to s1.equalsIgnoreCase(s2)
0: 	 * throws NPE if s1 is null
0: 	 *
0: 	 * @param s1  first string to compare
0: 	 * @param s2  second string to compare
0: 	 *
0: 	 * @return   true if the two upppercased ENGLISH values are equal
0: 	 *           return false if s2 is null
0: 	 */
0: 	public static boolean SQLEqualsIgnoreCase(String s1, String s2)
0: 	{
0: 		if (s2 == null)
0: 			return  false;
0: 		else
0: 			return s1.toUpperCase(Locale.ENGLISH).equals(s2.toUpperCase(Locale.ENGLISH));
0: 
0: 	}
0: 
0: }
0: 
============================================================================