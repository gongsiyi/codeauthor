3:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLBinary
1:33288d6: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
5:eac0369:  */
17:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:75ec275: import org.apache.derby.iapi.sql.conn.StatementContext;
1:75ec275: 
1:75ec275: import org.apache.derby.iapi.reference.ContextId;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:69ffa5b: import org.apache.derby.iapi.reference.MessageId;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:75ec275: import org.apache.derby.iapi.services.context.ContextService;
1:75ec275: 
1:33288d6: import org.apache.derby.iapi.services.io.DerbyIOException;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdInputStream;
1:75ec275: import org.apache.derby.iapi.services.io.InputStreamUtil;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:69ffa5b: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:eac0369: 
1:638f1b4: import java.sql.Blob;
1:75ec275: import java.sql.DataTruncation;
1:eac0369: import java.sql.SQLException;
1:e21adc5: import java.sql.PreparedStatement;
1:eac0369: 
1:40bcd6b: /**
1:806114c:  * SQLBinary is the abstract class for the binary datatypes.
1:806114c:  * <UL>
1:806114c:  * <LI> CHAR FOR BIT DATA
1:806114c:  * <LI> VARCHAR FOR BIT DATA
1:806114c:  * <LI> LONG VARCHAR
1:806114c:  * <LI> BLOB
1:806114c:  * </UL>
1:eac0369: 
1:eac0369:   <P>
1:eac0369:   Format : <encoded length><raw data>
1:eac0369:   <BR>
1:5c20522:   Length is encoded to support Cloudscape 5.x databases where the length was stored as the number of bits.
1:5c20522:   The first bit of the first byte indicates if the format is an old (Cloudscape 5.x) style or a new Derby style.
1:5c20522:   Derby then uses the next two bits to indicate how the length is encoded.
1:eac0369:   <BR>
1:eac0369:   <encoded length> is one of N styles.
1:eac0369:   <UL>
1:5c20522:   <LI> (5.x format zero) 4 byte Java format integer value 0 - either <raw data> is 0 bytes/bits  or an unknown number of bytes.
1:dbed020:   <LI> (5.x format bits) 4 byte Java format integer value &gt;0 (positive) - number of bits in raw data, number of bytes in <raw data>
1:eac0369:   is the minimum number of bytes required to store the number of bits.
1:dbed020:   <LI> (Derby format) 1 byte encoded length (0 &lt;= L &lt;= 31) - number of bytes of raw data - encoded = 0x80 &amp; L
1:dbed020:   <LI> (Derby format) 3 byte encoded length (32 &lt;= L &lt; 64k) - number of bytes of raw data - encoded = 0xA0 <L as Java format unsigned short>
1:dbed020:   <LI> (Derby format) 5 byte encoded length (64k &lt;= L &lt; 2G) - number of bytes of raw data - encoded = 0xC0 <L as Java format integer>
1:dbed020:   <LI> (future) to be determined L &gt;= 2G - encoded 0xE0 <encoding of L to be determined>
1:eac0369:   (0xE0 is an esacape to allow any number of arbitary encodings in the future).
1:eac0369:   </UL>
1:5c20522:   <BR>
1:5c20522:   When the value was written from a byte array the Derby encoded byte
1:5c20522:   length format was always used from Derby 10.0 onwards (ie. all open
1:5c20522:   source versions).
1:5c20522:   <BR>
1:5c20522:   When the value was written from a stream (e.g. PreparedStatement.setBinaryStream)
1:5c20522:   then the Cloudscape '5.x format zero' was used by 10.0 and 10.1.
1:5c20522:   The was due to the class RawToBinaryFormatStream always writing
1:5c20522:   four zero bytes for the length before the data.
1:5c20522:   <BR>
1:5c20522:   The Cloudscape '5.x format bits' format I think was never used by Derby.
1:eac0369:  */
1:806114c: abstract class SQLBinary
1:eac0369: 	extends DataType implements BitDataValue
11:eac0369: {
1:96b9662: 
1:eac0369: 	static final byte PAD = (byte) 0x20;
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBinary.class);
1:eac0369: 
1:33288d6:     private static final int LEN_OF_BUFFER_TO_WRITE_BLOB = 1024;
1:33288d6: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:b7c1f3b:         if (dataValue == null) {
1:b7c1f3b:             if (streamValueLength>=0) {
1:b7c1f3b:                 return BASE_MEMORY_USAGE + streamValueLength;
1:b7c1f3b:             } else {
1:b7c1f3b:                 return getMaxMemoryUsage();
8:eac0369:             }
1:b7c1f3b:         } else {
1:b7c1f3b:             return BASE_MEMORY_USAGE + dataValue.length;
1:eac0369:         }
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 	  
1:eac0369: 	  
1:b4e2eb7: 	/**
1:b7c1f3b: 	 * Return max memory usage for a SQL Binary
1:eac0369: 	 */
1:b7c1f3b: 	abstract int getMaxMemoryUsage();
1:eac0369: 
1:eac0369: 	 /*
1:638f1b4: 	 * value as a blob
1:638f1b4: 	 */
1:638f1b4:     Blob _blobValue;
1:638f1b4:     
1:638f1b4: 	 /*
1:eac0369: 	 * object state
1:eac0369: 	 */
1:eac0369: 	byte[] dataValue;
1:eac0369: 
1:5c20522: 	/**
1:40bcd6b: 	 * Value as a stream, this stream represents the on-disk
1:40bcd6b:      * format of the value. That is it has length information
1:40bcd6b:      * encoded in the first fe bytes.
1:eac0369: 	 */
1:eac0369: 	InputStream stream;
1:eac0369: 
2:eac0369: 	/**
1:40bcd6b: 		Length of the value in bytes when this value
1:40bcd6b:         is set as a stream. Represents the length of the
1:40bcd6b:         value itself and not the length of the stream
1:40bcd6b:         which contains this length encoded as the first
1:40bcd6b:         few bytes. If the value of the stream is unknown
1:40bcd6b:         then this will be set to -1. If this value is
1:40bcd6b:         not set as a stream then this value should be ignored.
1:eac0369: 	*/
1:40bcd6b: 	int streamValueLength;
1:eac0369: 
1:eac0369: 	/**
1:c8c1551: 		Create a binary value set to NULL
1:eac0369: 	*/
1:eac0369: 	SQLBinary()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	SQLBinary(byte[] val)
1:eac0369: 	{
1:eac0369: 		dataValue = val;
1:eac0369: 	}
1:eac0369: 
1:638f1b4: 	SQLBinary(Blob val)
1:638f1b4: 	{
1:638f1b4: 		setValue( val );
1:638f1b4: 	}
1:638f1b4: 
1:638f1b4:    
1:eac0369: 
1:eac0369: 	public final void setValue(byte[] theValue)
1:eac0369: 	{
1:eac0369: 		dataValue = theValue;
1:638f1b4:         _blobValue = null;
1:638f1b4: 		stream = null;
1:638f1b4: 		streamValueLength = -1;
1:638f1b4: 	}
1:638f1b4: 
1:638f1b4: 	public final void setValue(Blob theValue)
1:638f1b4: 	{
1:638f1b4: 		dataValue = null;
1:638f1b4:         _blobValue = theValue;
3:eac0369: 		stream = null;
1:40bcd6b: 		streamValueLength = -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Used by JDBC -- string should not contain
1:eac0369: 	 * SQL92 formatting.
2:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public final String	getString() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (getValue() == null)
1:eac0369: 			return null;
1:eac0369: 		else if (dataValue.length * 2 < 0)  //if converted to hex, length exceeds max int
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(),
1:eac0369: 									"",
1:eac0369: 									String.valueOf(Integer.MAX_VALUE));
1:eac0369: 		}
1:146fd5c: 		else 
1:eac0369: 		{
1:eac0369: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:638f1b4: 	public final InputStream	getStream() throws StandardException
1:eac0369: 	{
1:541361f:         if (!hasStream()) {
1:541361f:             throw StandardException.newException(
1:541361f:                     SQLState.LANG_STREAM_INVALID_ACCESS, getTypeName());
1:541361f:         }
1:eac0369: 		return (stream);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public final byte[]	getBytes() throws StandardException
1:eac0369: 	{
1:eac0369: 		return getValue();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	byte[] getValue() throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:638f1b4: 			if ((dataValue == null) && (_blobValue != null) )
1:638f1b4:             {
1:638f1b4:                 dataValue = _blobValue.getBytes( 1L,  getBlobLength() );
1:638f1b4:                 
1:638f1b4:                 _blobValue = null;
1:638f1b4:  				stream = null;
1:638f1b4: 				streamValueLength = -1;
1:638f1b4:             }
1:638f1b4: 			else if ((dataValue == null) && (stream != null) )
1:638f1b4:             {
1:eac0369: 				if (stream instanceof FormatIdInputStream) {
1:eac0369: 					readExternal((FormatIdInputStream) stream);
1:eac0369: 				}
1:eac0369: 				else {
1:eac0369: 					readExternal(new FormatIdInputStream(stream));
1:eac0369: 				}
1:638f1b4:                 _blobValue = null;
1:96b9662:  				stream = null;
1:40bcd6b: 				streamValueLength = -1;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:146fd5c: 			throwStreamingIOException(ioe);
1:eac0369: 		}
1:638f1b4: 		catch (SQLException se) { throw StandardException.plainWrapException( se ); }
1:638f1b4: 
1:eac0369: 		return dataValue;
1:638f1b4: 	}
1:638f1b4: 	
1:638f1b4: 	/**
1:eac0369: 	 * length in bytes
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:638f1b4: 	 */
1:eac0369: 	public final int	getLength() throws StandardException
1:eac0369: 	{
1:638f1b4:         if ( _blobValue != null ) { return getBlobLength(); }
1:638f1b4: 		else if (stream != null) {
1:40bcd6b: 			if (streamValueLength != -1)
1:146fd5c: 				return streamValueLength;
1:146fd5c: 			else if (stream instanceof Resetable){
1:146fd5c: 				try {
1:146fd5c: 					// If we have the stream length encoded.
1:146fd5c: 					// just read that.
1:146fd5c: 					streamValueLength = readBinaryLength((ObjectInput) stream);
1:a1c1356:                     if (streamValueLength == 0) {
1:a1c1356:                         // Otherwise we will have to read the whole stream.
1:a1c1356:                         streamValueLength =
1:a1c1356:                                 (int) InputStreamUtil.skipUntilEOF(stream);
1:a1c1356:                     }
1:146fd5c: 					return streamValueLength;
1:146fd5c: 				}
1:146fd5c: 				catch (IOException ioe) {
1:146fd5c: 					throwStreamingIOException(ioe);
1:146fd5c: 				}
1:146fd5c: 				finally {
1:146fd5c: 					try {
1:146fd5c: 						((Resetable) stream).resetStream();
1:146fd5c: 					} catch (IOException ioe) {
1:146fd5c: 						throwStreamingIOException(ioe);
1:146fd5c: 					}
1:146fd5c: 				}
1:75ec275: 				
1:146fd5c: 			}
1:146fd5c: 		}
1:146fd5c: 		byte[] bytes = getBytes();
1:146fd5c: 		return (bytes == null) ? 0 : bytes.length;
1:146fd5c: 		
1:146fd5c: 	}
1:146fd5c: 
1:146fd5c: 
1:146fd5c: 	private void throwStreamingIOException(IOException ioe) throws StandardException {
1:146fd5c: 		throw StandardException.
1:146fd5c: 			newException(SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION,
1:146fd5c: 						 ioe, getTypeName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:75ec275: 	/**
1:eac0369: 	 * see if the Bit value is null.
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
1:eac0369: 	 */
1:eac0369: 	public final boolean isNull()
1:eac0369: 	{
1:638f1b4: 		return (dataValue == null) && (stream == null) && (_blobValue == null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		Write the value out from the byte array (not called if null)
1:eac0369: 		using the 8.1 encoding.
1:eac0369: 
1:eac0369: 	 * @exception IOException		io exception
1:eac0369: 	 */
1:eac0369: 	public final void writeExternal(ObjectOutput out) throws IOException
1:638f1b4: 	{
1:638f1b4:         if ( _blobValue != null )
1:638f1b4:         {
1:638f1b4:             writeBlob(  out );
1:638f1b4:             return;
1:638f1b4:         }
1:638f1b4:         int len = dataValue.length;
1:638f1b4: 
1:638f1b4:         writeLength( out, len );
1:638f1b4: 		out.write(dataValue, 0, dataValue.length);
1:638f1b4: 	}
1:638f1b4: 
1:638f1b4: 	/** 
1:638f1b4: 		Serialize a blob using the 8.1 encoding. Not called if null.
1:638f1b4: 
1:638f1b4: 	 * @exception IOException		io exception
1:638f1b4: 	 */
1:638f1b4: 	private void writeBlob(ObjectOutput out) throws IOException
1:638f1b4: 	{
1:638f1b4:         try {
1:638f1b4:             int                 len = getBlobLength();
1:638f1b4:             InputStream         is = _blobValue.getBinaryStream();
1:638f1b4:             
1:638f1b4:             writeLength( out, len );
1:638f1b4:             
1:33288d6:             int bytesRead = 0;
1:33288d6:             int numOfBytes = 0;
1:447f048:             byte[] buffer = new byte[Math.min(len, LEN_OF_BUFFER_TO_WRITE_BLOB)];
1:33288d6:             
1:33288d6:             while(bytesRead < len) {
1:33288d6:                 numOfBytes = is.read(buffer);
1:33288d6:                 
1:33288d6:                 if (numOfBytes == -1) {
1:33288d6:                     throw new DerbyIOException(
1:33288d6:                         MessageService.getTextMessage(
1:33288d6:                                 SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:33288d6:                             SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:638f1b4:                 }
1:33288d6:                 
1:33288d6:                 out.write(buffer, 0, numOfBytes);
1:33288d6:                 bytesRead += numOfBytes; 
1:638f1b4:             }
1:638f1b4:         }
1:638f1b4:         catch (StandardException se) { throw new IOException( se.getMessage() ); }
1:638f1b4:         catch (SQLException se) { throw new IOException( se.getMessage() ); }
1:638f1b4:     }
1:638f1b4:     
1:638f1b4: 	/** 
1:638f1b4: 		Write the length if
1:638f1b4: 		using the 8.1 encoding.
1:638f1b4: 
1:638f1b4: 	 * @exception IOException		io exception
1:638f1b4: 	 */
1:638f1b4:     private void writeLength( ObjectOutput out, int len ) throws IOException
1:638f1b4:     {
1:eac0369: 		if (len <= 31)
1:638f1b4: 		{
1:eac0369: 			out.write((byte) (0x80 | (len & 0xff)));
1:33288d6: 		}
1:eac0369: 		else if (len <= 0xFFFF)
1:eac0369: 		{
1:eac0369: 			out.write((byte) 0xA0);
1:eac0369: 			out.writeShort((short) len);
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			out.write((byte) 0xC0);
1:eac0369: 			out.writeInt(len);
1:eac0369: 
1:638f1b4: 		}
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * delegated to bit 
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException			io exception
1:eac0369: 	 * @exception ClassNotFoundException	class not found
1:eac0369: 	*/
1:eac0369: 	public final void readExternal(ObjectInput in) throws IOException
1:eac0369: 	{
2:eac0369: 		// need to clear stream first, in case this object is reused, and
2:eac0369: 		// stream is set by previous use.  Track 3794.
1:eac0369: 		stream = null;
1:40bcd6b: 		streamValueLength = -1;
1:638f1b4:         _blobValue = null;
1:eac0369: 
1:eac0369: 
2:eac0369: 		int len = SQLBinary.readBinaryLength(in);
1:eac0369: 
2:eac0369: 		if (len != 0)
1:eac0369: 		{
2:eac0369: 			dataValue = new byte[len];
2:eac0369: 			in.readFully(dataValue);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			readFromStream((InputStream) in);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:5c20522:      * Read the encoded length of the value from the on-disk format.
1:5c20522:      * 
1:5c20522:      * @see SQLBinary
1:5c20522:     */
1:eac0369: 	private static int readBinaryLength(ObjectInput in) throws IOException {
1:5c20522: 		
1:eac0369: 		int bl = in.read();
1:5c20522: 		if (bl == -1)
1:eac0369: 			throw new java.io.EOFException();
1:96b9662:         
1:96b9662:         byte li = (byte) bl;
1:eac0369: 
1:5c20522:         int len;
1:96b9662: 		if ((li & ((byte) 0x80)) != 0)
1:eac0369: 		{
1:96b9662: 			if (li == ((byte) 0xC0))
1:96b9662: 			{             
1:eac0369: 				len = in.readInt();
1:96b9662:  			}
1:96b9662: 			else if (li == ((byte) 0xA0))
1:eac0369: 			{
1:eac0369: 				len = in.readUnsignedShort();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:96b9662: 				len = li & 0x1F;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:96b9662:             
1:eac0369: 			// old length in bits
1:eac0369: 			int v2 = in.read();
1:eac0369: 			int v3 = in.read();
1:eac0369: 			int v4 = in.read();
1:5c20522: 			if (v2 == -1 || v3 == -1 || v4 == -1)
1:eac0369: 				throw new java.io.EOFException();
1:eac0369:             int lenInBits = (((bl & 0xff) << 24) | ((v2 & 0xff) << 16) | ((v3 & 0xff) << 8) | (v4 & 0xff));
1:eac0369: 
1:eac0369: 			len = lenInBits / 8;
1:eac0369: 			if ((lenInBits % 8) != 0)
1:eac0369: 				len++;
1:96b9662:  		}
1:eac0369: 		return len;
1:eac0369: 	}
1:eac0369: 
1:40bcd6b:     /**
1:40bcd6b:      * Read the value from an input stream. The length
1:40bcd6b:      * encoded in the input stream has already been read
1:40bcd6b:      * and determined to be unknown.
1:40bcd6b:      */
1:40bcd6b:     private void readFromStream(InputStream in) throws IOException {
1:eac0369: 
1:eac0369: 		dataValue = null;	// allow gc of the old value before the new.
1:eac0369: 		byte[] tmpData = new byte[32 * 1024];
1:eac0369: 
1:eac0369: 		int off = 0;
1:146fd5c: 		for (;;) {
1:eac0369: 
1:eac0369: 			int len = in.read(tmpData, off, tmpData.length - off);
1:eac0369: 			if (len == -1)
1:146fd5c: 				break;
1:eac0369: 			off += len;
1:eac0369: 
1:402d610: 			int available = Math.max(1, in.available());
1:eac0369: 			int extraSpace = available - (tmpData.length - off);
1:eac0369: 			if (extraSpace > 0)
1:eac0369: 			{
1:eac0369: 				// need to grow the array
1:eac0369: 				int size = tmpData.length * 2;
1:eac0369: 				if (extraSpace > tmpData.length)
1:eac0369: 					size += extraSpace;
1:eac0369: 
1:eac0369: 				byte[] grow = new byte[size];
1:eac0369: 				System.arraycopy(tmpData, 0, grow, 0, off);
1:eac0369: 				tmpData = grow;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		dataValue = new byte[off];
1:eac0369: 		System.arraycopy(tmpData, 0, dataValue, 0, off);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	 */
1:eac0369: 	public final void restoreToNull()
1:eac0369: 	{
1:eac0369: 		dataValue = null;
1:638f1b4:         _blobValue = null;
1:eac0369: 		stream = null;
1:40bcd6b: 		streamValueLength = -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public final boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:638f1b4: 		throws StandardException
1:638f1b4: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369:                 int otherTypeFormatId = other.getTypeFormatId();
1:eac0369: 				if (!((StoredFormatIds.SQL_BIT_ID == otherTypeFormatId)
1:eac0369:                       || (StoredFormatIds.SQL_VARBIT_ID == otherTypeFormatId)
1:eac0369:                       || (StoredFormatIds.SQL_LONGVARBIT_ID == otherTypeFormatId)
1:638f1b4: 
1:eac0369:                       || (StoredFormatIds.SQL_CHAR_ID == otherTypeFormatId)
1:eac0369:                       || (StoredFormatIds.SQL_VARCHAR_ID == otherTypeFormatId)
1:eac0369:                       || (StoredFormatIds.SQL_LONGVARCHAR_ID == otherTypeFormatId)
1:eac0369: 
1:eac0369:                       || ((StoredFormatIds.SQL_BLOB_ID == otherTypeFormatId)
1:eac0369:                           && (StoredFormatIds.SQL_BLOB_ID == getTypeFormatId()))
1:eac0369:                         ))
1:eac0369: 				SanityManager.THROWASSERT(
1:807b29c:                         "An object of type " + other.getClass().getName() +
1:807b29c:                         ", with format id " + otherTypeFormatId +
1:807b29c:                         ", was passed to SQLBinary.compare()");
1:eac0369: 			}
1:876391e: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public final int compare(DataValueDescriptor other) throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** By convention, nulls sort High, and null == null
1:eac0369: 		*/
1:eac0369: 		if (this.isNull() || other.isNull())
1:eac0369: 		{
1:eac0369: 			if (!isNull())
1:eac0369: 				return -1;
1:eac0369: 			if (!other.isNull())
1:eac0369: 				return 1;
1:eac0369: 			return 0;							// both null
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBinary.compare(getBytes(), other.getBytes());
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:b4e2eb7:      * Shallow clone a StreamStorable without objectifying.
1:b4e2eb7:      * This is used to avoid unnecessary objectifying of a stream object.
1:b4e2eb7:      *
1:b4e2eb7:      *  Beetle 4896
1:b4e2eb7:      */
1:d7aa761:     public final DataValueDescriptor cloneHolder() {
1:d7aa761:         if (stream == null && _blobValue == null) {
1:854dd10:             return cloneValue(false);
1:d7aa761:         } else {
1:d7aa761:             // Cast to SQLBinary to avoid having to catch StandardException.
1:d7aa761:             SQLBinary self = (SQLBinary)getNewNull();
1:d7aa761:             if (stream != null) {
1:d7aa761:                 // Just reference the same stream in the cloned holder.
1:d7aa761:                 self.setValue(stream, streamValueLength);
1:d7aa761:             } else if (_blobValue != null) {
1:d7aa761:                 // Just reference the same BLOB value in the cloned holder.
1:638f1b4:                 self.setValue(_blobValue);
1:d7aa761:             } else {
1:d7aa761:                 throw new IllegalStateException("unknown BLOB value repr");
1:d7aa761:             }
1:638f1b4:             return self;
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10: 	/** @see DataValueDescriptor#cloneValue */
1:04acfa5: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor cloneDVD = getNewNull();
1:eac0369: 			cloneDVD.setValue(getValue());
1:eac0369: 			return cloneDVD;
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:e7d2a42: 				SanityManager.THROWASSERT("Unexpected exception", se);
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * StreamStorable interface : 
1:eac0369: 	 */
1:eac0369: 	public final InputStream returnStream()
1:eac0369: 	{
1:eac0369: 		return stream;
1:eac0369: 	}
1:eac0369: 
1:40bcd6b:     /**
1:40bcd6b:      * Set me to the value represented by this stream.
1:40bcd6b:      * The format of the stream is the on-disk format
1:40bcd6b:      * described in this class's javadoc. That is the
1:40bcd6b:      * length is encoded in the first few bytes of the
1:40bcd6b:      * stream.
1:40bcd6b:      */
1:eac0369: 	public final void setStream(InputStream newStream)
1:eac0369: 	{
1:eac0369: 		this.dataValue = null;
1:638f1b4:         _blobValue = null;
1:eac0369: 		this.stream = newStream;
1:40bcd6b: 		streamValueLength = -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void loadStream() throws StandardException
1:eac0369: 	{
1:eac0369: 		getValue();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     boolean objectNull(Object o) 
1:eac0369: 	{
1:eac0369: 		if (o == null) 
1:eac0369: 		{
1:eac0369: 			setToNull();
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:40bcd6b:      * Set the value from the stream which is in the on-disk format.
1:40bcd6b:      * @param theStream On disk format of the stream
1:d4953dd:      * @param valueLength length of the logical value in bytes, or
1:d4953dd:      *      <code>DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH</code>
1:d4953dd:      */
1:40bcd6b: 	public final void setValue(InputStream theStream, int valueLength)
1:eac0369: 	{
1:eac0369: 		dataValue = null;
1:638f1b4:         _blobValue = null;
1:eac0369: 		stream = theStream;
1:40bcd6b: 		this.streamValueLength = valueLength;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected final void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:eac0369: 		if (theValue instanceof SQLBinary)
1:eac0369: 		{
1:eac0369: 			SQLBinary theValueBinary = (SQLBinary) theValue;
1:eac0369: 			dataValue = theValueBinary.dataValue;
1:638f1b4:             _blobValue = theValueBinary._blobValue;
1:eac0369: 			stream = theValueBinary.stream;
1:40bcd6b: 			streamValueLength = theValueBinary.streamValueLength;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			setValue(theValue.getBytes());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The = operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:eac0369: 	 * @param left			The value on the left side of the =
1:eac0369: 	 * @param right			The value on the right side of the =
1:eac0369: 	 *						is not.
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue equals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
2:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isEqual;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isEqual = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) == 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isEqual);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters
1:eac0369: 	 * are not equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue notEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isNotEqual;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isNotEqual = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isNotEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) != 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isNotEqual);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is
1:eac0369: 	 *			less than the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue lessThan(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isLessThan;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isLessThan = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isLessThan = SQLBinary.compare(left.getBytes(), right.getBytes()) < 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isLessThan);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is
1:eac0369: 	 *			greater than the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue greaterThan(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isGreaterThan = false;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isGreaterThan = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isGreaterThan = SQLBinary.compare(left.getBytes(), right.getBytes()) > 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isGreaterThan);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is
1:eac0369: 	 *			less than or equal to the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue lessOrEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isLessEquals = false;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isLessEquals = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isLessEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) <= 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isLessEquals);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &gt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the &gt;=
1:dbed020: 	 * @param right			The value on the right side of the &gt;=
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is
1:eac0369: 	 *			greater than or equal to the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean isGreaterEquals = false;
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			isGreaterEquals = false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			isGreaterEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) >= 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 isGreaterEquals);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 * This method implements the char_length function for bit.
1:eac0369: 	 *
2:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLInteger containing the length of the char value
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 *
1:eac0369: 	 * @see ConcatableDataValue#charLength
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final NumberDataValue charLength(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLInteger();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (this.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		result.setValue(getValue().length);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see BitDataValue#concatenate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public final BitDataValue concatenate(
1:eac0369: 				BitDataValue left,
1:eac0369: 				BitDataValue right,
1:eac0369: 				BitDataValue result)
1:eac0369: 		throws StandardException
1:6d90df0: 	{
1:6d90df0:         if (result == null)
1:eac0369:         {
1:6d90df0:             result = (BitDataValue) getNewNull();
1:6d90df0:         }
1:6d90df0: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		byte[] leftData = left.getBytes();
1:eac0369: 		byte[] rightData = right.getBytes();
1:eac0369: 
1:eac0369: 		byte[] concatData = new byte[leftData.length + rightData.length];
1:eac0369: 
1:eac0369: 		System.arraycopy(leftData, 0, concatData, 0, leftData.length);
1:eac0369: 		System.arraycopy(rightData, 0, concatData, leftData.length, rightData.length);
1:eac0369: 
1:eac0369: 
1:eac0369: 		result.setValue(concatData);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369:   
1:eac0369: 	/**
1:eac0369: 	 * The SQL substr() function.
1:eac0369: 	 *
1:eac0369: 	 * @param start		Start of substr
1:eac0369: 	 * @param length	Length of substr
1:eac0369: 	 * @param result	The result of a previous call to this method,
1:eac0369: 	 *					null if not called yet.
1:eac0369: 	 * @param maxLen	Maximum length of the result
1:eac0369: 	 *
1:eac0369: 	 * @return	A ConcatableDataValue containing the result of the substr()
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public final ConcatableDataValue substring(
1:eac0369: 				NumberDataValue start,
1:eac0369: 				NumberDataValue length,
1:eac0369: 				ConcatableDataValue result,
1:eac0369: 				int maxLen)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int startInt;
1:eac0369: 		int lengthInt;
1:eac0369: 		BitDataValue varbitResult;
1:eac0369: 
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLVarbit();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		varbitResult = (BitDataValue) result;
1:eac0369: 
1:eac0369: 		/* The result is null if the receiver (this) is null or if the length is negative.
1:eac0369: 		 * Oracle docs don't say what happens if the start position or the length is a usernull.
1:eac0369: 		 * We will return null, which is the only sensible thing to do.
1:eac0369: 		 * (If the user did not specify a length then length is not a user null.)
1:eac0369: 		 */
1:eac0369: 		if (this.isNull() || start.isNull() || (length != null && length.isNull()))
1:eac0369: 		{
1:eac0369: 			varbitResult.setToNull();
1:eac0369: 			return varbitResult;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		startInt = start.getInt();
1:eac0369: 
1:eac0369: 		// If length is not specified, make it till end of the string
1:eac0369: 		if (length != null)
1:eac0369: 		{
1:eac0369: 			lengthInt = length.getInt();
1:eac0369: 		}
1:eac0369: 		else lengthInt = getLength() - startInt + 1;
1:eac0369: 
1:eac0369: 		/* DB2 Compatibility: Added these checks to match DB2. We currently enforce these
1:eac0369: 		 * limits in both modes. We could do these checks in DB2 mode only, if needed, so
1:eac0369: 		 * leaving earlier code for out of range in for now, though will not be exercised
1:eac0369: 		 */
1:eac0369: 		if ((startInt <= 0 || lengthInt < 0 || startInt > getLength() ||
1:eac0369: 				lengthInt > getLength() - startInt + 1))
1:eac0369: 			throw StandardException.newException(SQLState.LANG_SUBSTR_START_OR_LEN_OUT_OF_RANGE);
1:eac0369: 			
1:eac0369: 		// Return null if length is non-positive
1:eac0369: 		if (lengthInt < 0)
1:eac0369: 		{
1:eac0369: 			varbitResult.setToNull();
1:eac0369: 			return varbitResult;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If startInt < 0 then we count from the right of the string */
1:eac0369: 		if (startInt < 0)
1:eac0369: 		{
1:eac0369: 			startInt += getLength();
1:eac0369: 			if (startInt < 0)
1:eac0369: 			{
1:eac0369: 				lengthInt += startInt;
1:eac0369: 				startInt = 0;
1:eac0369: 			}
1:eac0369: 			if (lengthInt + startInt > 0)
1:eac0369: 			{
1:eac0369: 				lengthInt += startInt;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				lengthInt = 0;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else if (startInt > 0)
1:eac0369: 		{
1:eac0369: 			/* java substr() is 0 based */
1:eac0369: 			startInt--;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Oracle docs don't say what happens if the window is to the
1:eac0369: 		 * left of the string.  Return "" if the window
1:eac0369: 		 * is to the left or right or if the length is 0.
1:eac0369: 		 */
1:eac0369: 		if (lengthInt == 0 ||
1:eac0369: 			lengthInt <= 0 - startInt ||
1:eac0369: 			startInt > getLength())
1:eac0369: 		{
1:eac0369: 			varbitResult.setValue(new byte[0]);
1:eac0369: 			return varbitResult;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (lengthInt >= getLength() - startInt)
1:eac0369: 		{
1:eac0369: 			byte[] substring = new byte[dataValue.length - startInt];
1:eac0369: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
1:eac0369: 			varbitResult.setValue(substring);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			byte[] substring = new byte[lengthInt];
1:eac0369: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
1:eac0369: 			varbitResult.setValue(substring);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return varbitResult;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Host variables are rejected if their length is
1:eac0369: 		bigger than the declared length, regardless of
1:eac0369: 		if the trailing bytes are the pad character.
1:eac0369: 
1:eac0369: 		@exception StandardException Variable is too big.
1:eac0369: 	*/
1:eac0369: 	public final void checkHostVariable(int declaredLength) throws StandardException
1:eac0369: 	{
1:eac0369: 		// stream length checking occurs at the JDBC layer
1:eac0369: 		int variableLength = -1;
1:638f1b4:         if ( _blobValue != null ) { variableLength = -1; }
1:638f1b4: 		else if (stream == null)
1:eac0369: 		{
1:eac0369: 			if (dataValue != null)
1:eac0369: 				variableLength = dataValue.length;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:40bcd6b: 			variableLength = streamValueLength;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (variableLength != -1 && variableLength > declaredLength)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(), 
1:69ffa5b: 							MessageService.getTextMessage(
1:69ffa5b: 								MessageId.BINARY_DATA_HIDDEN),
1:eac0369: 							String.valueOf(declaredLength));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * String display of value
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final String toString()
1:eac0369: 	{
1:eac0369: 		if (dataValue == null)
1:eac0369: 		{
1:638f1b4: 			if ((stream == null) && (_blobValue == null) )
1:eac0369: 			{
1:eac0369: 				return "NULL";
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.THROWASSERT(
1:638f1b4: 						"value is null, stream or blob is not null");
1:eac0369: 				return "";
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public final int hashCode()
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			if (getValue() == null)
1:eac0369: 				{
1:eac0369: 					return 0;
1:eac0369: 				}
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:e7d2a42: 				SanityManager.THROWASSERT("Unexpected exception", se);
1:eac0369: 			return 0;
1:eac0369: 		}
1:e21adc5: 
1:1aa5b64: 		// Hash code should ignore trailing PAD bytes.
1:eac0369: 		byte[] bytes = dataValue;
1:1aa5b64:         int lastNonPadByte = bytes.length - 1;
1:1aa5b64:         while (lastNonPadByte >= 0 && bytes[lastNonPadByte] == PAD) {
1:1aa5b64:             lastNonPadByte--;
1:1aa5b64:         }
1:eac0369: 
1:1aa5b64:         // Build the hash code in a way similar to String.hashCode() and
1:1aa5b64:         // SQLChar.hashCode()
1:1aa5b64:         int hashcode = 0;
1:1aa5b64:         for (int i = 0; i <= lastNonPadByte; i++) {
1:1aa5b64:             hashcode = hashcode * 31 + bytes[i];
1:1aa5b64:         }
1:eac0369: 
1:eac0369: 		return hashcode;
1:eac0369: 	}
1:eac0369: 	private static int compare(byte[] left, byte[] right) {
1:eac0369: 
1:eac0369: 		int minLen = left.length;
1:eac0369: 		byte[] longer = right;
1:eac0369: 		if (right.length < minLen) {
1:eac0369: 			minLen = right.length;
1:eac0369: 			longer = left;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = 0; i < minLen; i++) {
1:eac0369: 
1:eac0369: 			int lb = left[i] & 0xff;
1:eac0369: 			int rb = right[i] & 0xff;
1:eac0369: 
1:eac0369: 			if (lb == rb)
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			return lb - rb;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// complete match on all the bytes for the smallest value.
1:eac0369: 
1:eac0369: 		// if the longer value is all pad characters
1:eac0369: 		// then the values are equal.
1:eac0369: 		for (int i = minLen; i < longer.length; i++) {
1:eac0369: 			byte nb = longer[i];
1:eac0369: 			if (nb == SQLBinary.PAD)
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			// longer value is bigger.
1:eac0369: 			if (left == longer)
1:eac0369: 				return 1;
1:eac0369: 			return -1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return 0;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:e21adc5:       /** Adding this method to ensure that super class' setInto method doesn't get called
1:e21adc5:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:e21adc5:       */
1:e21adc5:      public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1:e21adc5: 
1:e21adc5:                   ps.setBytes(position, getBytes());
1:e21adc5:      }
1:4b66efc: 
1:4b66efc:     /**
1:4b66efc:      * Gets a trace representation for debugging.
1:4b66efc:      *
1:4b66efc:      * @return a trace representation of this SQL DataType.
1:4b66efc:      */
1:4b66efc:     public final String getTraceString() throws StandardException {
1:4b66efc:         // Check if the value is SQL NULL.
1:4b66efc:         if (isNull()) {
1:4b66efc:             return "NULL";
1:4b66efc:         }
1:4b66efc: 
1:4b66efc:         // Check if we have a stream.
1:541361f:         if (hasStream()) {
1:4b66efc:             return (getTypeName() + "(" + getStream().toString() + ")");
1:4b66efc:         }
1:4b66efc: 
1:4b66efc:         return (getTypeName() + ":Length=" + getLength());
1:4b66efc:     }
1:638f1b4: 
1:638f1b4:     private int getBlobLength() throws StandardException
1:638f1b4:     {
1:638f1b4:         try {
1:638f1b4:             long   maxLength = Integer.MAX_VALUE;
1:638f1b4:             long   length = _blobValue.length();
1:638f1b4:             if ( length > Integer.MAX_VALUE )
1:638f1b4:             {
1:638f1b4:                 throw StandardException.newException
1:638f1b4:                     ( SQLState.BLOB_TOO_LARGE_FOR_CLIENT, Long.toString( length ), Long.toString( maxLength ) );
1:638f1b4:             }
1:638f1b4: 
1:638f1b4:             return (int) length;
1:638f1b4:         }
1:638f1b4:         catch (SQLException se) { throw StandardException.plainWrapException( se ); }
1:638f1b4:     }
1:638f1b4: 
1:eac0369:     /**
1:75ec275:      * Truncate this value to the desired width by removing bytes at the
1:75ec275:      * end of the byte sequence.
1:75ec275:      *
1:75ec275:      * @param sourceWidth the original width in bytes (only used for
1:75ec275:      *   diagnostics, ignored if {@code warn} is {@code false})
1:75ec275:      * @param desiredWidth the desired width in bytes
1:75ec275:      * @param warn whether or not to generate a truncation warning
1:75ec275:      */
1:75ec275:     void truncate(int sourceWidth, int desiredWidth, boolean warn)
1:75ec275:             throws StandardException {
1:75ec275:         if (warn) {
1:75ec275:             // SQL:2003, part 2, 6.12 <cast specification>,
1:75ec275:             // general rule 12 says we should warn about truncation.
1:75ec275:             DataTruncation warning = new DataTruncation(
1:75ec275:                     -1,    // column index is unknown
1:75ec275:                     false, // parameter
1:75ec275:                     true,  // read
1:75ec275:                     getLength(), desiredWidth);
1:75ec275: 
1:75ec275:             StatementContext statementContext = (StatementContext)
1:a0dbbd7:                 DataValueFactoryImpl.getContext(ContextId.LANG_STATEMENT);
1:75ec275:             statementContext.getActivation().
1:75ec275:                     getResultSet().addWarning(warning);
1:75ec275:         }
1:75ec275: 
1:75ec275:         // Truncate to the desired width.
1:75ec275:         byte[] shrunkData = new byte[desiredWidth];
1:75ec275:         System.arraycopy(getValue(), 0, shrunkData, 0, desiredWidth);
1:75ec275:         setValue(shrunkData);
1:75ec275:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:   <LI> (5.x format bits) 4 byte Java format integer value &gt;0 (positive) - number of bits in raw data, number of bytes in <raw data>
1:   <LI> (Derby format) 1 byte encoded length (0 &lt;= L &lt;= 31) - number of bytes of raw data - encoded = 0x80 &amp; L
1:   <LI> (Derby format) 3 byte encoded length (32 &lt;= L &lt; 64k) - number of bytes of raw data - encoded = 0xA0 <L as Java format unsigned short>
1:   <LI> (Derby format) 5 byte encoded length (64k &lt;= L &lt; 2G) - number of bytes of raw data - encoded = 0xC0 <L as Java format integer>
1:   <LI> (future) to be determined L &gt;= 2G - encoded 0xE0 <encoding of L to be determined>
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the &gt;=
1: 	 * @param right			The value on the right side of the &gt;=
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:                 DataValueFactoryImpl.getContext(ContextId.LANG_STATEMENT);
commit:a2a0ff2
/////////////////////////////////////////////////////////////////////////
commit:638f1b4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
/////////////////////////////////////////////////////////////////////////
1: 	 * value as a blob
1: 	 */
1:     Blob _blobValue;
1:     
1: 	 /*
/////////////////////////////////////////////////////////////////////////
1: 	SQLBinary(Blob val)
1: 	{
1: 		setValue( val );
1: 	}
1: 
1:    
1:         _blobValue = null;
1: 		stream = null;
1: 		streamValueLength = -1;
1: 	}
1: 
1: 	public final void setValue(Blob theValue)
1: 	{
1: 		dataValue = null;
1:         _blobValue = theValue;
/////////////////////////////////////////////////////////////////////////
1: 	public final InputStream	getStream() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 			if ((dataValue == null) && (_blobValue != null) )
1:             {
1:                 dataValue = _blobValue.getBytes( 1L,  getBlobLength() );
1:                 
1:                 _blobValue = null;
1:  				stream = null;
1: 				streamValueLength = -1;
1:             }
1: 			else if ((dataValue == null) && (stream != null) )
1:             {
1:                 _blobValue = null;
/////////////////////////////////////////////////////////////////////////
1: 		catch (SQLException se) { throw StandardException.plainWrapException( se ); }
1: 
1:      /**
0:       * Return a JDBC Blob. Only implemented to support DERBY-2201.
1:       */
0:     public Object getObject()
1:         throws StandardException
1:     {
0:         // the generated code for the DERBY-2201 codepath expects to get a Blob
0:         // back.
1: 
0:         if ( _blobValue != null ) { return _blobValue; }
0:         else { return super.getObject(); }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         if ( _blobValue != null ) { return getBlobLength(); }
1: 		else if (stream != null) {
/////////////////////////////////////////////////////////////////////////
1: 		return (dataValue == null) && (stream == null) && (_blobValue == null);
/////////////////////////////////////////////////////////////////////////
1:         if ( _blobValue != null )
1:         {
1:             writeBlob(  out );
1:             return;
1:         }
1:         int len = dataValue.length;
1:         writeLength( out, len );
1: 		out.write(dataValue, 0, dataValue.length);
1: 	}
1: 
1: 	/** 
1: 		Serialize a blob using the 8.1 encoding. Not called if null.
1: 
1: 	 * @exception IOException		io exception
1: 	 */
1: 	private void writeBlob(ObjectOutput out) throws IOException
1: 	{
1:         try {
1:             int                 len = getBlobLength();
1:             InputStream         is = _blobValue.getBinaryStream();
1:             
1:             writeLength( out, len );
1: 
0:             for ( int i = 0; i < len; i++ )
1:             {
0:                 out.write( is.read() );
1:             }
1:         }
1:         catch (StandardException se) { throw new IOException( se.getMessage() ); }
1:         catch (SQLException se) { throw new IOException( se.getMessage() ); }
1:     }
1:     
1: 	/** 
1: 		Write the length if
1: 		using the 8.1 encoding.
1: 
1: 	 * @exception IOException		io exception
1: 	 */
1:     private void writeLength( ObjectOutput out, int len ) throws IOException
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1:         _blobValue = null;
/////////////////////////////////////////////////////////////////////////
1:         _blobValue = null;
/////////////////////////////////////////////////////////////////////////
1:         _blobValue = null;
/////////////////////////////////////////////////////////////////////////
0:         if ( _blobValue != null )
1:         {
0:             SQLBinary self = (SQLBinary) getNewNull();
1:             self.setValue(_blobValue);
1:             return self;
1:         }
0: 		if (stream == null) { return getClone(); }
1:         
/////////////////////////////////////////////////////////////////////////
1:         _blobValue = null;
/////////////////////////////////////////////////////////////////////////
0:         _blobValue = null;
/////////////////////////////////////////////////////////////////////////
1:             _blobValue = theValueBinary._blobValue;
/////////////////////////////////////////////////////////////////////////
1:         if ( _blobValue != null ) { variableLength = -1; }
1: 		else if (stream == null)
/////////////////////////////////////////////////////////////////////////
1: 			if ((stream == null) && (_blobValue == null) )
/////////////////////////////////////////////////////////////////////////
1: 						"value is null, stream or blob is not null");
/////////////////////////////////////////////////////////////////////////
1: 
1:     private int getBlobLength() throws StandardException
1:     {
1:         try {
1:             long   maxLength = Integer.MAX_VALUE;
1:             long   length = _blobValue.length();
1:             if ( length > Integer.MAX_VALUE )
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.BLOB_TOO_LARGE_FOR_CLIENT, Long.toString( length ), Long.toString( maxLength ) );
1:             }
1: 
1:             return (int) length;
1:         }
1:         catch (SQLException se) { throw StandardException.plainWrapException( se ); }
1:     }
1:     
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:402d610
/////////////////////////////////////////////////////////////////////////
1: 			int available = Math.max(1, in.available());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:69ffa5b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.i18n.MessageService;
/////////////////////////////////////////////////////////////////////////
1: 							MessageService.getTextMessage(
1: 								MessageId.BINARY_DATA_HIDDEN),
commit:c4229c9
/////////////////////////////////////////////////////////////////////////
0: 							"(Binary data value not displayed)",
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:75ec275
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: import org.apache.derby.iapi.reference.ContextId;
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.services.io.InputStreamUtil;
1: import java.sql.DataTruncation;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Truncate this value to the desired width by removing bytes at the
1:      * end of the byte sequence.
1:      *
1:      * @param sourceWidth the original width in bytes (only used for
1:      *   diagnostics, ignored if {@code warn} is {@code false})
1:      * @param desiredWidth the desired width in bytes
1:      * @param warn whether or not to generate a truncation warning
1:      */
1:     void truncate(int sourceWidth, int desiredWidth, boolean warn)
1:             throws StandardException {
1:         if (warn) {
1:             // SQL:2003, part 2, 6.12 <cast specification>,
1:             // general rule 12 says we should warn about truncation.
1:             DataTruncation warning = new DataTruncation(
1:                     -1,    // column index is unknown
1:                     false, // parameter
1:                     true,  // read
1:                     getLength(), desiredWidth);
1: 
1:             StatementContext statementContext = (StatementContext)
0:                 ContextService.getContext(ContextId.LANG_STATEMENT);
1:             statementContext.getActivation().
1:                     getResultSet().addWarning(warning);
1:         }
1: 
1:         // Truncate to the desired width.
1:         byte[] shrunkData = new byte[desiredWidth];
1:         System.arraycopy(getValue(), 0, shrunkData, 0, desiredWidth);
1:         setValue(shrunkData);
1:     }
commit:6d90df0
/////////////////////////////////////////////////////////////////////////
1:         if (result == null)
1:         {
1:             result = (BitDataValue) getNewNull();
1:         }
1: 
commit:807b29c
/////////////////////////////////////////////////////////////////////////
1:                         "An object of type " + other.getClass().getName() +
1:                         ", with format id " + otherTypeFormatId +
1:                         ", was passed to SQLBinary.compare()");
commit:876391e
/////////////////////////////////////////////////////////////////////////
1: 			if (this.isNull() || other.isNull())
commit:1aa5b64
/////////////////////////////////////////////////////////////////////////
1: 		// Hash code should ignore trailing PAD bytes.
1:         int lastNonPadByte = bytes.length - 1;
1:         while (lastNonPadByte >= 0 && bytes[lastNonPadByte] == PAD) {
1:             lastNonPadByte--;
1:         }
1:         // Build the hash code in a way similar to String.hashCode() and
1:         // SQLChar.hashCode()
1:         int hashcode = 0;
1:         for (int i = 0; i <= lastNonPadByte; i++) {
1:             hashcode = hashcode * 31 + bytes[i];
1:         }
commit:a1c1356
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.InputStreamUtil;
/////////////////////////////////////////////////////////////////////////
1:                     if (streamValueLength == 0) {
1:                         // Otherwise we will have to read the whole stream.
1:                         streamValueLength =
1:                                 (int) InputStreamUtil.skipUntilEOF(stream);
1:                     }
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("Unexpected exception", se);
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("Unexpected exception", se);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:447f048
/////////////////////////////////////////////////////////////////////////
1:             byte[] buffer = new byte[Math.min(len, LEN_OF_BUFFER_TO_WRITE_BLOB)];
commit:33288d6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.DerbyIOException;
/////////////////////////////////////////////////////////////////////////
1:     private static final int LEN_OF_BUFFER_TO_WRITE_BLOB = 1024;
1: 
/////////////////////////////////////////////////////////////////////////
1:             
1:             int bytesRead = 0;
1:             int numOfBytes = 0;
0:             byte[] buffer = new byte[LEN_OF_BUFFER_TO_WRITE_BLOB];
1:             
1:             while(bytesRead < len) {
1:                 numOfBytes = is.read(buffer);
1:                 
1:                 if (numOfBytes == -1) {
1:                     throw new DerbyIOException(
1:                         MessageService.getTextMessage(
1:                                 SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:                             SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:                 }
1:                 
1:                 out.write(buffer, 0, numOfBytes);
1:                 bytesRead += numOfBytes; 
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:         if (!hasStream()) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_STREAM_INVALID_ACCESS, getTypeName());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (hasStream()) {
commit:04acfa5
/////////////////////////////////////////////////////////////////////////
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:             return cloneValue(false);
/////////////////////////////////////////////////////////////////////////
1: 	/** @see DataValueDescriptor#cloneValue */
0: 	public final DataValueDescriptor cloneValue(boolean forceMaterialization)
commit:d7aa761
/////////////////////////////////////////////////////////////////////////
1:     public final DataValueDescriptor cloneHolder() {
1:         if (stream == null && _blobValue == null) {
0:             return getClone();
1:         } else {
1:             // Cast to SQLBinary to avoid having to catch StandardException.
1:             SQLBinary self = (SQLBinary)getNewNull();
1:             if (stream != null) {
1:                 // Just reference the same stream in the cloned holder.
1:                 self.setValue(stream, streamValueLength);
1:             } else if (_blobValue != null) {
1:                 // Just reference the same BLOB value in the cloned holder.
0:                 self.setValue(_blobValue);
1:             } else {
1:                 throw new IllegalStateException("unknown BLOB value repr");
1:             }
commit:b4e2eb7
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Shallow clone a StreamStorable without objectifying.
1:      * This is used to avoid unnecessary objectifying of a stream object.
1:      *
1:      *  Beetle 4896
1:      */
0:     public final DataValueDescriptor cloneObject() {
commit:d4953dd
/////////////////////////////////////////////////////////////////////////
1:      * @param valueLength length of the logical value in bytes, or
1:      *      <code>DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH</code>
1:      */
commit:4b66efc
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Gets a trace representation for debugging.
1:      *
1:      * @return a trace representation of this SQL DataType.
1:      */
1:     public final String getTraceString() throws StandardException {
1:         // Check if the value is SQL NULL.
1:         if (isNull()) {
1:             return "NULL";
1:         }
1: 
1:         // Check if we have a stream.
0:         if (getStream() != null) {
1:             return (getTypeName() + "(" + getStream().toString() + ")");
1:         }
1: 
1:         return (getTypeName() + ":Length=" + getLength());
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:146fd5c
/////////////////////////////////////////////////////////////////////////
1: 			throwStreamingIOException(ioe);
/////////////////////////////////////////////////////////////////////////
1: 			else if (stream instanceof Resetable){
1: 				try {
1: 					// If we have the stream length encoded.
1: 					// just read that.
1: 					streamValueLength = readBinaryLength((ObjectInput) stream);
0: 					if (streamValueLength != 0)
1: 						return streamValueLength;
0: 					// Otherwise we will have to read the whole stream.
1: 					for (;;) {
0: 						long skipsize = stream.skip(Integer.MAX_VALUE);
0: 						streamValueLength += skipsize;
0: 						if (stream.read() == -1)
1: 							break;
1: 						else
0: 							streamValueLength++;
1: 					}
1: 					return streamValueLength;
1: 				}
1: 				catch (IOException ioe) {
1: 					throwStreamingIOException(ioe);
1: 				}
1: 				finally {
1: 					try {
1: 						((Resetable) stream).resetStream();
1: 					} catch (IOException ioe) {
1: 						throwStreamingIOException(ioe);
1: 					}
1: 				}
1: 				
1: 			}
1: 		byte[] bytes = getBytes();
1: 		return (bytes == null) ? 0 : bytes.length;
1: 		
1: 	}
1: 
1: 	private void throwStreamingIOException(IOException ioe) throws StandardException {
1: 		throw StandardException.
1: 			newException(SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION,
1: 						 ioe, getTypeName());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c8c1551
/////////////////////////////////////////////////////////////////////////
1: 		Create a binary value set to NULL
commit:96b9662
/////////////////////////////////////////////////////////////////////////
1:         
1:  				stream = null;
/////////////////////////////////////////////////////////////////////////
1:         
1:         byte li = (byte) bl;
1: 		if ((li & ((byte) 0x80)) != 0)
1: 			if (li == ((byte) 0xC0))
1: 			{             
1:  			}
1: 			else if (li == ((byte) 0xA0))
1: 				len = li & 0x1F;
1:             
/////////////////////////////////////////////////////////////////////////
1:  		}
commit:5c20522
/////////////////////////////////////////////////////////////////////////
1:   Length is encoded to support Cloudscape 5.x databases where the length was stored as the number of bits.
1:   The first bit of the first byte indicates if the format is an old (Cloudscape 5.x) style or a new Derby style.
1:   Derby then uses the next two bits to indicate how the length is encoded.
1:   <LI> (5.x format zero) 4 byte Java format integer value 0 - either <raw data> is 0 bytes/bits  or an unknown number of bytes.
0:   <LI> (5.x format bits) 4 byte Java format integer value >0 (positive) - number of bits in <raw data>, number of bytes in <raw data>
0:   <LI> (Derby format) 1 byte encoded length (0 <= L <= 31) - number of bytes of <raw data> - encoded = 0x80 & L
0:   <LI> (Derby format) 3 byte encoded length (32 <= L < 64k) - number of bytes of <raw data> - encoded = 0xA0 <L as Java format unsigned short>
0:   <LI> (Derby format) 5 byte encoded length (64k <= L < 2G) - number of bytes of <raw data> - encoded = 0xC0 <L as Java format integer>
1:   <BR>
1:   When the value was written from a byte array the Derby encoded byte
1:   length format was always used from Derby 10.0 onwards (ie. all open
1:   source versions).
1:   <BR>
1:   When the value was written from a stream (e.g. PreparedStatement.setBinaryStream)
1:   then the Cloudscape '5.x format zero' was used by 10.0 and 10.1.
1:   The was due to the class RawToBinaryFormatStream always writing
1:   four zero bytes for the length before the data.
1:   <BR>
1:   The Cloudscape '5.x format bits' format I think was never used by Derby.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Read the encoded length of the value from the on-disk format.
1:      * 
1:      * @see SQLBinary
1:     */
1: 		
1: 		if (bl == -1)
1:         int len;
/////////////////////////////////////////////////////////////////////////
1: 			if (v2 == -1 || v3 == -1 || v4 == -1)
commit:40bcd6b
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Value as a stream, this stream represents the on-disk
1:      * format of the value. That is it has length information
1:      * encoded in the first fe bytes.
1: 		Length of the value in bytes when this value
1:         is set as a stream. Represents the length of the
1:         value itself and not the length of the stream
1:         which contains this length encoded as the first
1:         few bytes. If the value of the stream is unknown
1:         then this will be set to -1. If this value is
1:         not set as a stream then this value should be ignored.
1: 	int streamValueLength;
/////////////////////////////////////////////////////////////////////////
1: 		streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1: 				streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1: 			if (streamValueLength != -1)
0: 				return streamValueLength;
/////////////////////////////////////////////////////////////////////////
1: 		streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1: 		streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Read the value from an input stream. The length
1:      * encoded in the input stream has already been read
1:      * and determined to be unknown.
1:      */
1:     private void readFromStream(InputStream in) throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 		streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set me to the value represented by this stream.
1:      * The format of the stream is the on-disk format
1:      * described in this class's javadoc. That is the
1:      * length is encoded in the first few bytes of the
1:      * stream.
1:      */
0: 		streamValueLength = -1;
/////////////////////////////////////////////////////////////////////////
1:      * Set the value from the stream which is in the on-disk format.
1:      * @param theStream On disk format of the stream
0:      * @param valueLength length of the logical value in bytes.
1: 	public final void setValue(InputStream theStream, int valueLength)
1: 		this.streamValueLength = valueLength;
/////////////////////////////////////////////////////////////////////////
1: 			streamValueLength = theValueBinary.streamValueLength;
/////////////////////////////////////////////////////////////////////////
1: 			variableLength = streamValueLength;
commit:806114c
/////////////////////////////////////////////////////////////////////////
1:  * SQLBinary is the abstract class for the binary datatypes.
1:  * <UL>
1:  * <LI> CHAR FOR BIT DATA
1:  * <LI> VARCHAR FOR BIT DATA
1:  * <LI> LONG VARCHAR
1:  * <LI> BLOB
1:  * </UL>
/////////////////////////////////////////////////////////////////////////
1: abstract class SQLBinary
commit:e21adc5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:       /** Adding this method to ensure that super class' setInto method doesn't get called
1:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:       */
1:      public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1: 
1:                   ps.setBytes(position, getBytes());
1:      }
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLBinary
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.NewByteArrayInputStream;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.ConcatableDataValue;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.StreamStorable;
1: import org.apache.derby.iapi.services.io.FormatIdInputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.NumberDataValue;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import org.apache.derby.iapi.types.SQLInteger;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: import java.io.InputStream;
1: 
0: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: /**
0:  * SQLBinary satisfies the DataValueDescriptor
0:  * interfaces (i.e., DataType). It implements a String holder,
0:  * e.g. for storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction.
0:  * <p>
0:  * Because DataType is a subclass of DataType,
0:  * SQLBit can play a role in either a DataType/Value
0:  * or a DataType/KeyRow, interchangeably.
1: 
1:   <P>
1:   Format : <encoded length><raw data>
1:   <BR>
0:   Length is encoded to support 5.x databases where the length was stored as the number of bits.
0:   The first bit of the first byte indicates if the format is an old (5.x) style or a new 8.1 style.
0:   8.1 then uses the next two bits to indicate how the length is encoded.
1:   <BR>
1:   <encoded length> is one of N styles.
1:   <UL>
0:   <LI> (5.x format) 4 byte Java format integer value 0 - either <raw data> is 0 bytes/bits  or an unknown number of bytes.
0:   <LI> (5.x format) 4 byte Java format integer value >0 (positive) - number of bits in <raw data>, number of bytes in <raw data>
1:   is the minimum number of bytes required to store the number of bits.
0:   <LI> (8.1 format) 1 byte encoded length (0 <= L <= 31) - number of bytes of <raw data> - encoded = 0x80 & L
0:   <LI> (8.1 format) 3 byte encoded length (32 <= L < 64k) - number of bytes of <raw data> - encoded = 0xA0 <L as Java format unsigned short>
0:   <LI> (8.1 format) 5 byte encoded length (64k <= L < 2G) - number of bytes of <raw data> - encoded = 0xC0 <L as Java format integer>
0:   <LI> (future) to be determined L >= 2G - encoded 0xE0 <encoding of L to be determined>
1:   (0xE0 is an esacape to allow any number of arbitary encodings in the future).
1:   </UL>
1:  */
0: public abstract class SQLBinary
1: 	extends DataType implements BitDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 	static final byte PAD = (byte) 0x20;
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBinary.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
0:         int sz = BASE_MEMORY_USAGE;
0:         if( null != dataValue)
0:             sz += dataValue.length;
0:         return sz;
1:     } // end of estimateMemoryUsage
1: 
1: 	  
1: 	  
1: 	 /*
1: 	 * object state
1: 	 */
1: 	byte[] dataValue;
1: 
1: 	/*
0: 	 * stream state
1: 	 */
1: 	InputStream stream;
1: 
1: 	/**
0: 		Length of the stream in units relevant to the type,
0: 		in this case bytes.
1: 	*/
0: 	int streamLength;
1: 
1: 	/**
0: 		no-arg constructor, required by Formattable.
1: 	*/
1: 	SQLBinary()
1: 	{
1: 	}
1: 
1: 	SQLBinary(byte[] val)
1: 	{
1: 		dataValue = val;
1: 	}
1: 
1: 
1: 	public final void setValue(byte[] theValue)
1: 	{
1: 		dataValue = theValue;
1: 		stream = null;
0: 		streamLength = -1;
1: 	}
1: 
1: 	/**
1: 	 * Used by JDBC -- string should not contain
1: 	 * SQL92 formatting.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public final String	getString() throws StandardException
1: 	{
1: 		if (getValue() == null)
1: 			return null;
1: 		else if (dataValue.length * 2 < 0)  //if converted to hex, length exceeds max int
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(),
1: 									"",
1: 									String.valueOf(Integer.MAX_VALUE));
1: 		}
1: 		else 
1: 		{
1: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public final InputStream	getStream()
1: 	{
1: 		return (stream);
1: 	}
1: 
1: 	/**
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public final byte[]	getBytes() throws StandardException
1: 	{
1: 		return getValue();
1: 	}
1: 
1: 	byte[] getValue() throws StandardException
1: 	{
1: 		try
1: 		{
0: 			if ((dataValue == null) && (stream != null)) {
1: 
1: 				if (stream instanceof FormatIdInputStream) {
1: 					readExternal((FormatIdInputStream) stream);
0: 				} else if ( stream instanceof NewByteArrayInputStream )
1: 				{
0: 					// this piece of code handles the case that a stream has been
0: 					// opened on the bit value. the stream will have already called
0: 					// readExternal() on the underlying FormatableBitSet. we just need to
0: 					// retrieve the byte array from that stream.
0: 					NewByteArrayInputStream	nbais = (NewByteArrayInputStream) stream;
0: 					dataValue = nbais.getData();
1: 				}
1: 				else {
1: 					readExternal(new FormatIdInputStream(stream));
1: 				}
1: 				stream = null;
0: 				streamLength = -1;
1: 
1: 			}
1: 		}
1: 		catch (IOException ioe)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, getTypeName());
1: 		}
1: 		return dataValue;
1: 	}
1: 	
1: 	/**
1: 	 * length in bytes
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public final int	getLength() throws StandardException
1: 	{
0: 		if (stream != null) {
1: 
0: 			if (streamLength != -1)
0: 				return streamLength;
1: 		}
1: 
0: 		return getBytes().length;
1: 
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 
1: 	/**
1: 	 * see if the Bit value is null.
1: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
1: 	 */
1: 	public final boolean isNull()
1: 	{
0: 		return (dataValue == null) && (stream == null);
1: 	}
1: 
1: 	/** 
1: 		Write the value out from the byte array (not called if null)
1: 		using the 8.1 encoding.
1: 
1: 	 * @exception IOException		io exception
1: 	 */
1: 	public final void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 
0: 		int len = dataValue.length;
1: 		if (len <= 31)
1: 		{
1: 			out.write((byte) (0x80 | (len & 0xff)));
1: 		}
1: 		else if (len <= 0xFFFF)
1: 		{
1: 			out.write((byte) 0xA0);
1: 			out.writeShort((short) len);
1: 		}
1: 		else
1: 		{
1: 			out.write((byte) 0xC0);
1: 			out.writeInt(len);
1: 
1: 		}
0: 		out.write(dataValue, 0, dataValue.length);
1: 	}
1: 
1: 	/** 
1: 	 * delegated to bit 
1: 	 *
1: 	 * @exception IOException			io exception
1: 	 * @exception ClassNotFoundException	class not found
1: 	*/
1: 	public final void readExternal(ObjectInput in) throws IOException
1: 	{
1: 		// need to clear stream first, in case this object is reused, and
1: 		// stream is set by previous use.  Track 3794.
1: 		stream = null;
0: 		streamLength = -1;
1: 
1: 
1: 		int len = SQLBinary.readBinaryLength(in);
1: 
1: 		if (len != 0)
1: 		{
1: 			dataValue = new byte[len];
1: 			in.readFully(dataValue);
1: 		}
1: 		else
1: 		{
1: 			readFromStream((InputStream) in);
1: 		}
1: 	}
0: 	public final void readExternalFromArray(ArrayInputStream in) throws IOException
1: 	{
1: 		// need to clear stream first, in case this object is reused, and
1: 		// stream is set by previous use.  Track 3794.
1: 		stream = null;
0: 		streamLength = -1;
1: 
1: 		int len = SQLBinary.readBinaryLength(in);
1: 
1: 		if (len != 0)
1: 		{
1: 			dataValue = new byte[len];
1: 			in.readFully(dataValue);
1: 		}
1: 		else
1: 		{
0: 			readFromStream(in);
1: 		}
1: 	}
1: 
1: 	private static int readBinaryLength(ObjectInput in) throws IOException {
0: 		int len = 0;
1: 		int bl = in.read();
0: 		if (len < 0)
1: 			throw new java.io.EOFException();
1: 
0: 		if ((bl & 0x80) != 0)
1: 		{
0: 			if (bl == 0xC0)
1: 			{
1: 				len = in.readInt();
1: 			}
0: 			else if (bl == 0xA0)
1: 			{
1: 				len = in.readUnsignedShort();
1: 			}
1: 			else
1: 			{
0: 				len = bl & 0x1F;
1: 			}
1: 		}
1: 		else
1: 		{
1: 			// old length in bits
1: 			int v2 = in.read();
1: 			int v3 = in.read();
1: 			int v4 = in.read();
0: 			if (v2 < 0 || v3 < 0 || v4 < 0)
1: 				throw new java.io.EOFException();
1:             int lenInBits = (((bl & 0xff) << 24) | ((v2 & 0xff) << 16) | ((v3 & 0xff) << 8) | (v4 & 0xff));
1: 
1: 			len = lenInBits / 8;
1: 			if ((lenInBits % 8) != 0)
1: 				len++;
1: 		}
1: 		return len;
1: 	}
1: 
0: 	private void readFromStream(InputStream in) throws IOException {
1: 
1: 		dataValue = null;	// allow gc of the old value before the new.
1: 		byte[] tmpData = new byte[32 * 1024];
1: 
1: 		int off = 0;
0: 		for (;;) {
1: 
1: 			int len = in.read(tmpData, off, tmpData.length - off);
1: 			if (len == -1)
0: 				break;
1: 			off += len;
1: 
0: 			int available = in.available();
1: 			int extraSpace = available - (tmpData.length - off);
1: 			if (extraSpace > 0)
1: 			{
1: 				// need to grow the array
1: 				int size = tmpData.length * 2;
1: 				if (extraSpace > tmpData.length)
1: 					size += extraSpace;
1: 
1: 				byte[] grow = new byte[size];
1: 				System.arraycopy(tmpData, 0, grow, 0, off);
1: 				tmpData = grow;
1: 			}
1: 		}
1: 
1: 		dataValue = new byte[off];
1: 		System.arraycopy(tmpData, 0, dataValue, 0, off);
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	 */
1: 	public final void restoreToNull()
1: 	{
1: 		dataValue = null;
1: 		stream = null;
0: 		streamLength = -1;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public final boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1:                 int otherTypeFormatId = other.getTypeFormatId();
1: 				if (!((StoredFormatIds.SQL_BIT_ID == otherTypeFormatId)
1:                       || (StoredFormatIds.SQL_VARBIT_ID == otherTypeFormatId)
1:                       || (StoredFormatIds.SQL_LONGVARBIT_ID == otherTypeFormatId)
1: 
1:                       || (StoredFormatIds.SQL_CHAR_ID == otherTypeFormatId)
1:                       || (StoredFormatIds.SQL_VARCHAR_ID == otherTypeFormatId)
1:                       || (StoredFormatIds.SQL_LONGVARCHAR_ID == otherTypeFormatId)
1: 
1:                       || ((StoredFormatIds.SQL_BLOB_ID == otherTypeFormatId)
1:                           && (StoredFormatIds.SQL_BLOB_ID == getTypeFormatId()))
1:                         ))
1: 				SanityManager.THROWASSERT(
0: 									"Some fool passed in a "+ other.getClass().getName() + ", "
0:                                     + otherTypeFormatId  + " to SQLBinary.compare()");
1: 			}
0: 			String otherString = other.getString();
0: 			if (this.getString() == null  || otherString == null)
1: 				return unknownRV;
1: 		}
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public final int compare(DataValueDescriptor other) throws StandardException
1: 	{
1: 
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 		/*
1: 		** By convention, nulls sort High, and null == null
1: 		*/
1: 		if (this.isNull() || other.isNull())
1: 		{
1: 			if (!isNull())
1: 				return -1;
1: 			if (!other.isNull())
1: 				return 1;
1: 			return 0;							// both null
1: 		}
1: 
1: 		return SQLBinary.compare(getBytes(), other.getBytes());
1: 	}
1: 
1: 	/*
0: 	 * CloneableObject interface
1: 	 */
1: 
0: 	/** From CloneableObject
0: 	 *	Shallow clone a StreamStorable without objectifying.  This is used to avoid
0: 	 *	unnecessary objectifying of a stream object.  The only difference of this method
0: 	 *  from getClone is this method does not objectify a stream.  beetle 4896
1: 	 */
0: 	public final Object cloneObject()
1: 	{
0: 		if (stream == null)
0: 			return getClone();
0: 		SQLBinary self = (SQLBinary) getNewNull();
0: 		self.setStream(stream);
0: 		return self;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public final DataValueDescriptor getClone()
1: 	{
1: 		try
1: 		{
1: 			DataValueDescriptor cloneDVD = getNewNull();
1: 			cloneDVD.setValue(getValue());
1: 			return cloneDVD;
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
1: 			return null;
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/*
1: 	 * StreamStorable interface : 
1: 	 */
1: 	public final InputStream returnStream()
1: 	{
1: 		return stream;
1: 	}
1: 
1: 	public final void setStream(InputStream newStream)
1: 	{
1: 		this.dataValue = null;
1: 		this.stream = newStream;
0: 		streamLength = -1;
1: 	}
1: 
1: 	public final void loadStream() throws StandardException
1: 	{
1: 		getValue();
1: 	}
1: 
1: 	/*
1: 	 * class interface
1: 	 */
1: 
1:     boolean objectNull(Object o) 
1: 	{
1: 		if (o == null) 
1: 		{
1: 			setToNull();
1: 			return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * @see SQLBit#setValue
1: 	 *
1: 	 */
0: 	public final void setValue(InputStream theStream, int streamLength)
1: 	{
1: 		dataValue = null;
1: 		stream = theStream;
0: 		this.streamLength = streamLength;
1: 	}
1: 
1: 	protected final void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
1: 		if (theValue instanceof SQLBinary)
1: 		{
1: 			SQLBinary theValueBinary = (SQLBinary) theValue;
1: 			dataValue = theValueBinary.dataValue;
1: 			stream = theValueBinary.stream;
0: 			streamLength = theValueBinary.streamLength;
1: 		}
1: 		else
1: 		{
1: 			setValue(theValue.getBytes());
1: 		}
1: 	}
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 	/**
1: 	 * The = operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
1: 	 * @param left			The value on the left side of the =
1: 	 * @param right			The value on the right side of the =
1: 	 *						is not.
1: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue equals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isEqual;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isEqual = false;
1: 		}
1: 		else
1: 		{	
1: 			isEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) == 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isEqual);
1: 	}
1: 
1: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters
1: 	 * are not equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue notEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isNotEqual;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isNotEqual = false;
1: 		}
1: 		else
1: 		{	
1: 			isNotEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) != 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isNotEqual);
1: 	}
1: 
1: 	/**
0: 	 * The < operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <
0: 	 * @param right			The value on the right side of the <
1: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet.  NOTE: This is unused in this
0: 	 *					method, because comparison operators always return
0: 	 *					pre-allocated values.
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is
1: 	 *			less than the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue lessThan(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isLessThan;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isLessThan = false;
1: 		}
1: 		else
1: 		{	
1: 			isLessThan = SQLBinary.compare(left.getBytes(), right.getBytes()) < 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isLessThan);
1: 	}
1: 
1: 	/**
0: 	 * The > operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is
1: 	 *			greater than the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue greaterThan(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isGreaterThan = false;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isGreaterThan = false;
1: 		}
1: 		else
1: 		{	
1: 			isGreaterThan = SQLBinary.compare(left.getBytes(), right.getBytes()) > 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isGreaterThan);
1: 	}
1: 
1: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is
1: 	 *			less than or equal to the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue lessOrEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isLessEquals = false;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isLessEquals = false;
1: 		}
1: 		else
1: 		{	
1: 			isLessEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) <= 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isLessEquals);
1: 	}
1: 
1: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is
1: 	 *			greater than or equal to the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public final BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 								throws StandardException
1: 	{
1: 		boolean isGreaterEquals = false;
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			isGreaterEquals = false;
1: 		}
1: 		else
1: 		{	
1: 			isGreaterEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) >= 0;
1: 		}
1: 
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 isGreaterEquals);
1: 	}
1: 
1: 
1: 	/**
1: 	 *
1: 	 * This method implements the char_length function for bit.
1: 	 *
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLInteger containing the length of the char value
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 *
1: 	 * @see ConcatableDataValue#charLength
1: 	 */
1: 
1: 	public final NumberDataValue charLength(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = new SQLInteger();
1: 		}
1: 
1: 		if (this.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
1: 
1: 		result.setValue(getValue().length);
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * @see BitDataValue#concatenate
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public final BitDataValue concatenate(
1: 				BitDataValue left,
1: 				BitDataValue right,
1: 				BitDataValue result)
1: 		throws StandardException
1: 	{
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
1: 		byte[] leftData = left.getBytes();
1: 		byte[] rightData = right.getBytes();
1: 
1: 		byte[] concatData = new byte[leftData.length + rightData.length];
1: 
1: 		System.arraycopy(leftData, 0, concatData, 0, leftData.length);
1: 		System.arraycopy(rightData, 0, concatData, leftData.length, rightData.length);
1: 
1: 
1: 		result.setValue(concatData);
1: 		return result;
1: 	}
1: 
1:   
1: 	/**
1: 	 * The SQL substr() function.
1: 	 *
1: 	 * @param start		Start of substr
1: 	 * @param length	Length of substr
1: 	 * @param result	The result of a previous call to this method,
1: 	 *					null if not called yet.
1: 	 * @param maxLen	Maximum length of the result
1: 	 *
1: 	 * @return	A ConcatableDataValue containing the result of the substr()
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public final ConcatableDataValue substring(
1: 				NumberDataValue start,
1: 				NumberDataValue length,
1: 				ConcatableDataValue result,
1: 				int maxLen)
1: 		throws StandardException
1: 	{
1: 		int startInt;
1: 		int lengthInt;
1: 		BitDataValue varbitResult;
1: 
1: 		if (result == null)
1: 		{
1: 			result = new SQLVarbit();
1: 		}
1: 
1: 		varbitResult = (BitDataValue) result;
1: 
1: 		/* The result is null if the receiver (this) is null or if the length is negative.
1: 		 * Oracle docs don't say what happens if the start position or the length is a usernull.
1: 		 * We will return null, which is the only sensible thing to do.
1: 		 * (If the user did not specify a length then length is not a user null.)
1: 		 */
1: 		if (this.isNull() || start.isNull() || (length != null && length.isNull()))
1: 		{
1: 			varbitResult.setToNull();
1: 			return varbitResult;
1: 		}
1: 
1: 		startInt = start.getInt();
1: 
1: 		// If length is not specified, make it till end of the string
1: 		if (length != null)
1: 		{
1: 			lengthInt = length.getInt();
1: 		}
1: 		else lengthInt = getLength() - startInt + 1;
1: 
1: 		/* DB2 Compatibility: Added these checks to match DB2. We currently enforce these
1: 		 * limits in both modes. We could do these checks in DB2 mode only, if needed, so
1: 		 * leaving earlier code for out of range in for now, though will not be exercised
1: 		 */
1: 		if ((startInt <= 0 || lengthInt < 0 || startInt > getLength() ||
1: 				lengthInt > getLength() - startInt + 1))
1: 			throw StandardException.newException(SQLState.LANG_SUBSTR_START_OR_LEN_OUT_OF_RANGE);
1: 			
1: 		// Return null if length is non-positive
1: 		if (lengthInt < 0)
1: 		{
1: 			varbitResult.setToNull();
1: 			return varbitResult;
1: 		}
1: 
1: 		/* If startInt < 0 then we count from the right of the string */
1: 		if (startInt < 0)
1: 		{
1: 			startInt += getLength();
1: 			if (startInt < 0)
1: 			{
1: 				lengthInt += startInt;
1: 				startInt = 0;
1: 			}
1: 			if (lengthInt + startInt > 0)
1: 			{
1: 				lengthInt += startInt;
1: 			}
1: 			else
1: 			{
1: 				lengthInt = 0;
1: 			}
1: 		}
1: 		else if (startInt > 0)
1: 		{
1: 			/* java substr() is 0 based */
1: 			startInt--;
1: 		}
1: 
1: 		/* Oracle docs don't say what happens if the window is to the
1: 		 * left of the string.  Return "" if the window
1: 		 * is to the left or right or if the length is 0.
1: 		 */
1: 		if (lengthInt == 0 ||
1: 			lengthInt <= 0 - startInt ||
1: 			startInt > getLength())
1: 		{
1: 			varbitResult.setValue(new byte[0]);
1: 			return varbitResult;
1: 		}
1: 
1: 		if (lengthInt >= getLength() - startInt)
1: 		{
1: 			byte[] substring = new byte[dataValue.length - startInt];
1: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
1: 			varbitResult.setValue(substring);
1: 		}
1: 		else
1: 		{
1: 			byte[] substring = new byte[lengthInt];
1: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
1: 			varbitResult.setValue(substring);
1: 		}
1: 
1: 		return varbitResult;
1: 	}
1: 
1: 	/**
1: 		Host variables are rejected if their length is
1: 		bigger than the declared length, regardless of
1: 		if the trailing bytes are the pad character.
1: 
1: 		@exception StandardException Variable is too big.
1: 	*/
1: 	public final void checkHostVariable(int declaredLength) throws StandardException
1: 	{
1: 		// stream length checking occurs at the JDBC layer
1: 		int variableLength = -1;
0: 		if (stream == null)
1: 		{
1: 			if (dataValue != null)
1: 				variableLength = dataValue.length;
1: 		}
1: 		else
1: 		{
0: 			variableLength = streamLength;
1: 		}
1: 
1: 		if (variableLength != -1 && variableLength > declaredLength)
1: 				throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(), 
0: 							"XX-RESOLVE-XX",
1: 							String.valueOf(declaredLength));
1: 	}
1: 
1: 	/*
1: 	 * String display of value
1: 	 */
1: 
1: 	public final String toString()
1: 	{
1: 		if (dataValue == null)
1: 		{
0: 			if (stream == null)
1: 			{
1: 				return "NULL";
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.THROWASSERT(
0: 						"value is null, stream is not null");
1: 				return "";
1: 			}
1: 		}
1: 		else
1: 		{
1: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public final int hashCode()
1: 	{
1: 		try {
1: 			if (getValue() == null)
1: 				{
1: 					return 0;
1: 				}
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
1: 			return 0;
1: 		}
1: 
0: 		/* Hash code is simply the sum of all of the bytes */
1: 		byte[] bytes = dataValue;
0: 		int hashcode = 0;
1: 
0: 		// Build the hash code
0: 		for (int index = 0 ; index < bytes.length; index++)
1: 		{
0: 			byte bv = bytes[index];
0: 			if (bv != SQLBinary.PAD)
0: 				hashcode += bytes[index];
1: 		}
1: 
1: 		return hashcode;
1: 	}
1: 	private static int compare(byte[] left, byte[] right) {
1: 
1: 		int minLen = left.length;
1: 		byte[] longer = right;
1: 		if (right.length < minLen) {
1: 			minLen = right.length;
1: 			longer = left;
1: 		}
1: 
1: 		for (int i = 0; i < minLen; i++) {
1: 
1: 			int lb = left[i] & 0xff;
1: 			int rb = right[i] & 0xff;
1: 
1: 			if (lb == rb)
1: 				continue;
1: 
1: 			return lb - rb;
1: 		}
1: 
1: 		// complete match on all the bytes for the smallest value.
1: 
1: 		// if the longer value is all pad characters
1: 		// then the values are equal.
1: 		for (int i = minLen; i < longer.length; i++) {
1: 			byte nb = longer[i];
1: 			if (nb == SQLBinary.PAD)
1: 				continue;
1: 
1: 			// longer value is bigger.
1: 			if (left == longer)
1: 				return 1;
1: 			return -1;
1: 		}
1: 
1: 		return 0;
1: 
1: 	}
1: }
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:b7c1f3b
/////////////////////////////////////////////////////////////////////////
1:         if (dataValue == null) {
1:             if (streamValueLength>=0) {
1:                 return BASE_MEMORY_USAGE + streamValueLength;
1:             } else {
1:                 return getMaxMemoryUsage();
0:             }
1:         } else {
1:             return BASE_MEMORY_USAGE + dataValue.length;
0:         }
0: 	  
0: 	  
0: 	/**
1: 	 * Return max memory usage for a SQL Binary
0: 	 */
1: 	abstract int getMaxMemoryUsage();
/////////////////////////////////////////////////////////////////////////
0: 		self.setValue(stream, streamValueLength);
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:91151e5
/////////////////////////////////////////////////////////////////////////
0: 		return (getBytes() == null) ? 0 : getBytes().length;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.NewByteArrayInputStream;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.ConcatableDataValue;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.StreamStorable;
0: import org.apache.derby.iapi.services.io.FormatIdInputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.types.SQLInteger;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.io.InputStream;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: /**
0:  * SQLBinary satisfies the DataValueDescriptor
0:  * interfaces (i.e., DataType). It implements a String holder,
0:  * e.g. for storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction.
0:  * <p>
0:  * Because DataType is a subclass of DataType,
0:  * SQLBit can play a role in either a DataType/Value
0:  * or a DataType/KeyRow, interchangeably.
0: 
0:   <P>
0:   Format : <encoded length><raw data>
0:   <BR>
0:   Length is encoded to support 5.x databases where the length was stored as the number of bits.
0:   The first bit of the first byte indicates if the format is an old (5.x) style or a new 8.1 style.
0:   8.1 then uses the next two bits to indicate how the length is encoded.
0:   <BR>
0:   <encoded length> is one of N styles.
0:   <UL>
0:   <LI> (5.x format) 4 byte Java format integer value 0 - either <raw data> is 0 bytes/bits  or an unknown number of bytes.
0:   <LI> (5.x format) 4 byte Java format integer value >0 (positive) - number of bits in <raw data>, number of bytes in <raw data>
0:   is the minimum number of bytes required to store the number of bits.
0:   <LI> (8.1 format) 1 byte encoded length (0 <= L <= 31) - number of bytes of <raw data> - encoded = 0x80 & L
0:   <LI> (8.1 format) 3 byte encoded length (32 <= L < 64k) - number of bytes of <raw data> - encoded = 0xA0 <L as Java format unsigned short>
0:   <LI> (8.1 format) 5 byte encoded length (64k <= L < 2G) - number of bytes of <raw data> - encoded = 0xC0 <L as Java format integer>
0:   <LI> (future) to be determined L >= 2G - encoded 0xE0 <encoding of L to be determined>
0:   (0xE0 is an esacape to allow any number of arbitary encodings in the future).
0:   </UL>
0:  */
0: public abstract class SQLBinary
0: 	extends DataType implements BitDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 	static final byte PAD = (byte) 0x20;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBinary.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE;
0:         if( null != dataValue)
0:             sz += dataValue.length;
0:         return sz;
0:     } // end of estimateMemoryUsage
0: 
0: 	  
0: 	  
0: 	 /*
0: 	 * object state
0: 	 */
0: 	byte[] dataValue;
0: 
0: 	/*
0: 	 * stream state
0: 	 */
0: 	InputStream stream;
0: 
0: 	/**
0: 		Length of the stream in units relevant to the type,
0: 		in this case bytes.
0: 	*/
0: 	int streamLength;
0: 
0: 	/**
0: 		no-arg constructor, required by Formattable.
0: 	*/
0: 	SQLBinary()
0: 	{
0: 	}
0: 
0: 	SQLBinary(byte[] val)
0: 	{
0: 		dataValue = val;
0: 	}
0: 
0: 
0: 	public final void setValue(byte[] theValue)
0: 	{
0: 		dataValue = theValue;
0: 		stream = null;
0: 		streamLength = -1;
0: 	}
0: 
0: 	/**
0: 	 * Used by JDBC -- string should not contain
0: 	 * SQL92 formatting.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final String	getString() throws StandardException
0: 	{
0: 		if (getValue() == null)
0: 			return null;
0: 		else if (dataValue.length * 2 < 0)  //if converted to hex, length exceeds max int
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(),
0: 									"",
0: 									String.valueOf(Integer.MAX_VALUE));
0: 		}
0: 		else 
0: 		{
0: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final InputStream	getStream()
0: 	{
0: 		return (stream);
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final byte[]	getBytes() throws StandardException
0: 	{
0: 		return getValue();
0: 	}
0: 
0: 	byte[] getValue() throws StandardException
0: 	{
0: 		try
0: 		{
0: 			if ((dataValue == null) && (stream != null)) {
0: 
0: 				if (stream instanceof FormatIdInputStream) {
0: 					readExternal((FormatIdInputStream) stream);
0: 				} else if ( stream instanceof NewByteArrayInputStream )
0: 				{
0: 					// this piece of code handles the case that a stream has been
0: 					// opened on the bit value. the stream will have already called
0: 					// readExternal() on the underlying FormatableBitSet. we just need to
0: 					// retrieve the byte array from that stream.
0: 					NewByteArrayInputStream	nbais = (NewByteArrayInputStream) stream;
0: 					dataValue = nbais.getData();
0: 				}
0: 				else {
0: 					readExternal(new FormatIdInputStream(stream));
0: 				}
0: 				stream = null;
0: 				streamLength = -1;
0: 
0: 			}
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, getTypeName());
0: 		}
0: 		return dataValue;
0: 	}
0: 	
0: 	/**
0: 	 * length in bytes
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final int	getLength() throws StandardException
0: 	{
0: 		if (stream != null) {
0: 
0: 			if (streamLength != -1)
0: 				return streamLength;
0: 		}
0: 
0: 		return getBytes().length;
0: 
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 
0: 	/**
0: 	 * see if the Bit value is null.
0: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
0: 	 */
0: 	public final boolean isNull()
0: 	{
0: 		return (dataValue == null) && (stream == null);
0: 	}
0: 
0: 	/** 
0: 		Write the value out from the byte array (not called if null)
0: 		using the 8.1 encoding.
0: 
0: 	 * @exception IOException		io exception
0: 	 */
0: 	public final void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 
0: 		int len = dataValue.length;
0: 		if (len <= 31)
0: 		{
0: 			out.write((byte) (0x80 | (len & 0xff)));
0: 		}
0: 		else if (len <= 0xFFFF)
0: 		{
0: 			out.write((byte) 0xA0);
0: 			out.writeShort((short) len);
0: 		}
0: 		else
0: 		{
0: 			out.write((byte) 0xC0);
0: 			out.writeInt(len);
0: 
0: 		}
0: 		out.write(dataValue, 0, dataValue.length);
0: 	}
0: 
0: 	/** 
0: 	 * delegated to bit 
0: 	 *
0: 	 * @exception IOException			io exception
0: 	 * @exception ClassNotFoundException	class not found
0: 	*/
0: 	public final void readExternal(ObjectInput in) throws IOException
0: 	{
0: 		// need to clear stream first, in case this object is reused, and
0: 		// stream is set by previous use.  Track 3794.
0: 		stream = null;
0: 		streamLength = -1;
0: 
0: 
0: 		int len = SQLBinary.readBinaryLength(in);
0: 
0: 		if (len != 0)
0: 		{
0: 			dataValue = new byte[len];
0: 			in.readFully(dataValue);
0: 		}
0: 		else
0: 		{
0: 			readFromStream((InputStream) in);
0: 		}
0: 	}
0: 	public final void readExternalFromArray(ArrayInputStream in) throws IOException
0: 	{
0: 		// need to clear stream first, in case this object is reused, and
0: 		// stream is set by previous use.  Track 3794.
0: 		stream = null;
0: 		streamLength = -1;
0: 
0: 		int len = SQLBinary.readBinaryLength(in);
0: 
0: 		if (len != 0)
0: 		{
0: 			dataValue = new byte[len];
0: 			in.readFully(dataValue);
0: 		}
0: 		else
0: 		{
0: 			readFromStream(in);
0: 		}
0: 	}
0: 
0: 	private static int readBinaryLength(ObjectInput in) throws IOException {
0: 		int len = 0;
0: 		int bl = in.read();
0: 		if (len < 0)
0: 			throw new java.io.EOFException();
0: 
0: 		if ((bl & 0x80) != 0)
0: 		{
0: 			if (bl == 0xC0)
0: 			{
0: 				len = in.readInt();
0: 			}
0: 			else if (bl == 0xA0)
0: 			{
0: 				len = in.readUnsignedShort();
0: 			}
0: 			else
0: 			{
0: 				len = bl & 0x1F;
0: 			}
0: 		}
0: 		else
0: 		{
0: 			// old length in bits
0: 			int v2 = in.read();
0: 			int v3 = in.read();
0: 			int v4 = in.read();
0: 			if (v2 < 0 || v3 < 0 || v4 < 0)
0: 				throw new java.io.EOFException();
0:             int lenInBits = (((bl & 0xff) << 24) | ((v2 & 0xff) << 16) | ((v3 & 0xff) << 8) | (v4 & 0xff));
0: 
0: 			len = lenInBits / 8;
0: 			if ((lenInBits % 8) != 0)
0: 				len++;
0: 		}
0: 		return len;
0: 	}
0: 
0: 	private void readFromStream(InputStream in) throws IOException {
0: 
0: 		dataValue = null;	// allow gc of the old value before the new.
0: 		byte[] tmpData = new byte[32 * 1024];
0: 
0: 		int off = 0;
0: 		for (;;) {
0: 
0: 			int len = in.read(tmpData, off, tmpData.length - off);
0: 			if (len == -1)
0: 				break;
0: 			off += len;
0: 
0: 			int available = in.available();
0: 			int extraSpace = available - (tmpData.length - off);
0: 			if (extraSpace > 0)
0: 			{
0: 				// need to grow the array
0: 				int size = tmpData.length * 2;
0: 				if (extraSpace > tmpData.length)
0: 					size += extraSpace;
0: 
0: 				byte[] grow = new byte[size];
0: 				System.arraycopy(tmpData, 0, grow, 0, off);
0: 				tmpData = grow;
0: 			}
0: 		}
0: 
0: 		dataValue = new byte[off];
0: 		System.arraycopy(tmpData, 0, dataValue, 0, off);
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	 */
0: 	public final void restoreToNull()
0: 	{
0: 		dataValue = null;
0: 		stream = null;
0: 		streamLength = -1;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public final boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0:                 int otherTypeFormatId = other.getTypeFormatId();
0: 				if (!((StoredFormatIds.SQL_BIT_ID == otherTypeFormatId)
0:                       || (StoredFormatIds.SQL_VARBIT_ID == otherTypeFormatId)
0:                       || (StoredFormatIds.SQL_LONGVARBIT_ID == otherTypeFormatId)
0: 
0:                       || (StoredFormatIds.SQL_CHAR_ID == otherTypeFormatId)
0:                       || (StoredFormatIds.SQL_VARCHAR_ID == otherTypeFormatId)
0:                       || (StoredFormatIds.SQL_LONGVARCHAR_ID == otherTypeFormatId)
0: 
0:                       || ((StoredFormatIds.SQL_BLOB_ID == otherTypeFormatId)
0:                           && (StoredFormatIds.SQL_BLOB_ID == getTypeFormatId()))
0:                         ))
0: 				SanityManager.THROWASSERT(
0: 									"Some fool passed in a "+ other.getClass().getName() + ", "
0:                                     + otherTypeFormatId  + " to SQLBinary.compare()");
0: 			}
0: 			String otherString = other.getString();
0: 			if (this.getString() == null  || otherString == null)
0: 				return unknownRV;
0: 		}
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public final int compare(DataValueDescriptor other) throws StandardException
0: 	{
0: 
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 		/*
0: 		** By convention, nulls sort High, and null == null
0: 		*/
0: 		if (this.isNull() || other.isNull())
0: 		{
0: 			if (!isNull())
0: 				return -1;
0: 			if (!other.isNull())
0: 				return 1;
0: 			return 0;							// both null
0: 		}
0: 
0: 		return SQLBinary.compare(getBytes(), other.getBytes());
0: 	}
0: 
0: 	/*
0: 	 * CloneableObject interface
0: 	 */
0: 
0: 	/** From CloneableObject
0: 	 *	Shallow clone a StreamStorable without objectifying.  This is used to avoid
0: 	 *	unnecessary objectifying of a stream object.  The only difference of this method
0: 	 *  from getClone is this method does not objectify a stream.  beetle 4896
0: 	 */
0: 	public final Object cloneObject()
0: 	{
0: 		if (stream == null)
0: 			return getClone();
0: 		SQLBinary self = (SQLBinary) getNewNull();
0: 		self.setStream(stream);
0: 		return self;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public final DataValueDescriptor getClone()
0: 	{
0: 		try
0: 		{
0: 			DataValueDescriptor cloneDVD = getNewNull();
0: 			cloneDVD.setValue(getValue());
0: 			return cloneDVD;
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/*
0: 	 * StreamStorable interface : 
0: 	 */
0: 	public final InputStream returnStream()
0: 	{
0: 		return stream;
0: 	}
0: 
0: 	public final void setStream(InputStream newStream)
0: 	{
0: 		this.dataValue = null;
0: 		this.stream = newStream;
0: 		streamLength = -1;
0: 	}
0: 
0: 	public final void loadStream() throws StandardException
0: 	{
0: 		getValue();
0: 	}
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: 
0:     boolean objectNull(Object o) 
0: 	{
0: 		if (o == null) 
0: 		{
0: 			setToNull();
0: 			return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * @see SQLBit#setValue
0: 	 *
0: 	 */
0: 	public final void setValue(InputStream theStream, int streamLength)
0: 	{
0: 		dataValue = null;
0: 		stream = theStream;
0: 		this.streamLength = streamLength;
0: 	}
0: 
0: 	protected final void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		if (theValue instanceof SQLBinary)
0: 		{
0: 			SQLBinary theValueBinary = (SQLBinary) theValue;
0: 			dataValue = theValueBinary.dataValue;
0: 			stream = theValueBinary.stream;
0: 			streamLength = theValueBinary.streamLength;
0: 		}
0: 		else
0: 		{
0: 			setValue(theValue.getBytes());
0: 		}
0: 	}
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 	/**
0: 	 * The = operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the =
0: 	 * @param right			The value on the right side of the =
0: 	 *						is not.
0: 	 * @return	A SQL boolean value telling whether the two parameters are equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue equals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isEqual;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isEqual = false;
0: 		}
0: 		else
0: 		{	
0: 			isEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) == 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isEqual);
0: 	}
0: 
0: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters
0: 	 * are not equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue notEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isNotEqual;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isNotEqual = false;
0: 		}
0: 		else
0: 		{	
0: 			isNotEqual = SQLBinary.compare(left.getBytes(), right.getBytes()) != 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isNotEqual);
0: 	}
0: 
0: 	/**
0: 	 * The < operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <
0: 	 * @param right			The value on the right side of the <
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet.  NOTE: This is unused in this
0: 	 *					method, because comparison operators always return
0: 	 *					pre-allocated values.
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is
0: 	 *			less than the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue lessThan(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isLessThan;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isLessThan = false;
0: 		}
0: 		else
0: 		{	
0: 			isLessThan = SQLBinary.compare(left.getBytes(), right.getBytes()) < 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isLessThan);
0: 	}
0: 
0: 	/**
0: 	 * The > operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is
0: 	 *			greater than the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue greaterThan(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isGreaterThan = false;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isGreaterThan = false;
0: 		}
0: 		else
0: 		{	
0: 			isGreaterThan = SQLBinary.compare(left.getBytes(), right.getBytes()) > 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isGreaterThan);
0: 	}
0: 
0: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is
0: 	 *			less than or equal to the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue lessOrEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isLessEquals = false;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isLessEquals = false;
0: 		}
0: 		else
0: 		{	
0: 			isLessEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) <= 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isLessEquals);
0: 	}
0: 
0: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is
0: 	 *			greater than or equal to the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final BooleanDataValue greaterOrEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 								throws StandardException
0: 	{
0: 		boolean isGreaterEquals = false;
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			isGreaterEquals = false;
0: 		}
0: 		else
0: 		{	
0: 			isGreaterEquals = SQLBinary.compare(left.getBytes(), right.getBytes()) >= 0;
0: 		}
0: 
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 isGreaterEquals);
0: 	}
0: 
0: 
0: 	/**
0: 	 *
0: 	 * This method implements the char_length function for bit.
0: 	 *
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLInteger containing the length of the char value
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 *
0: 	 * @see ConcatableDataValue#charLength
0: 	 */
0: 
0: 	public final NumberDataValue charLength(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (result == null)
0: 		{
0: 			result = new SQLInteger();
0: 		}
0: 
0: 		if (this.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 
0: 		result.setValue(getValue().length);
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * @see BitDataValue#concatenate
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final BitDataValue concatenate(
0: 				BitDataValue left,
0: 				BitDataValue right,
0: 				BitDataValue result)
0: 		throws StandardException
0: 	{
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		byte[] leftData = left.getBytes();
0: 		byte[] rightData = right.getBytes();
0: 
0: 		byte[] concatData = new byte[leftData.length + rightData.length];
0: 
0: 		System.arraycopy(leftData, 0, concatData, 0, leftData.length);
0: 		System.arraycopy(rightData, 0, concatData, leftData.length, rightData.length);
0: 
0: 
0: 		result.setValue(concatData);
0: 		return result;
0: 	}
0: 
0:   
0: 	/**
0: 	 * The SQL substr() function.
0: 	 *
0: 	 * @param start		Start of substr
0: 	 * @param length	Length of substr
0: 	 * @param result	The result of a previous call to this method,
0: 	 *					null if not called yet.
0: 	 * @param maxLen	Maximum length of the result
0: 	 *
0: 	 * @return	A ConcatableDataValue containing the result of the substr()
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public final ConcatableDataValue substring(
0: 				NumberDataValue start,
0: 				NumberDataValue length,
0: 				ConcatableDataValue result,
0: 				int maxLen)
0: 		throws StandardException
0: 	{
0: 		int startInt;
0: 		int lengthInt;
0: 		BitDataValue varbitResult;
0: 
0: 		if (result == null)
0: 		{
0: 			result = new SQLVarbit();
0: 		}
0: 
0: 		varbitResult = (BitDataValue) result;
0: 
0: 		/* The result is null if the receiver (this) is null or if the length is negative.
0: 		 * Oracle docs don't say what happens if the start position or the length is a usernull.
0: 		 * We will return null, which is the only sensible thing to do.
0: 		 * (If the user did not specify a length then length is not a user null.)
0: 		 */
0: 		if (this.isNull() || start.isNull() || (length != null && length.isNull()))
0: 		{
0: 			varbitResult.setToNull();
0: 			return varbitResult;
0: 		}
0: 
0: 		startInt = start.getInt();
0: 
0: 		// If length is not specified, make it till end of the string
0: 		if (length != null)
0: 		{
0: 			lengthInt = length.getInt();
0: 		}
0: 		else lengthInt = getLength() - startInt + 1;
0: 
0: 		/* DB2 Compatibility: Added these checks to match DB2. We currently enforce these
0: 		 * limits in both modes. We could do these checks in DB2 mode only, if needed, so
0: 		 * leaving earlier code for out of range in for now, though will not be exercised
0: 		 */
0: 		if ((startInt <= 0 || lengthInt < 0 || startInt > getLength() ||
0: 				lengthInt > getLength() - startInt + 1))
0: 			throw StandardException.newException(SQLState.LANG_SUBSTR_START_OR_LEN_OUT_OF_RANGE);
0: 			
0: 		// Return null if length is non-positive
0: 		if (lengthInt < 0)
0: 		{
0: 			varbitResult.setToNull();
0: 			return varbitResult;
0: 		}
0: 
0: 		/* If startInt < 0 then we count from the right of the string */
0: 		if (startInt < 0)
0: 		{
0: 			startInt += getLength();
0: 			if (startInt < 0)
0: 			{
0: 				lengthInt += startInt;
0: 				startInt = 0;
0: 			}
0: 			if (lengthInt + startInt > 0)
0: 			{
0: 				lengthInt += startInt;
0: 			}
0: 			else
0: 			{
0: 				lengthInt = 0;
0: 			}
0: 		}
0: 		else if (startInt > 0)
0: 		{
0: 			/* java substr() is 0 based */
0: 			startInt--;
0: 		}
0: 
0: 		/* Oracle docs don't say what happens if the window is to the
0: 		 * left of the string.  Return "" if the window
0: 		 * is to the left or right or if the length is 0.
0: 		 */
0: 		if (lengthInt == 0 ||
0: 			lengthInt <= 0 - startInt ||
0: 			startInt > getLength())
0: 		{
0: 			varbitResult.setValue(new byte[0]);
0: 			return varbitResult;
0: 		}
0: 
0: 		if (lengthInt >= getLength() - startInt)
0: 		{
0: 			byte[] substring = new byte[dataValue.length - startInt];
0: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
0: 			varbitResult.setValue(substring);
0: 		}
0: 		else
0: 		{
0: 			byte[] substring = new byte[lengthInt];
0: 			System.arraycopy(dataValue, startInt, substring, 0, substring.length);
0: 			varbitResult.setValue(substring);
0: 		}
0: 
0: 		return varbitResult;
0: 	}
0: 
0: 	/**
0: 		Host variables are rejected if their length is
0: 		bigger than the declared length, regardless of
0: 		if the trailing bytes are the pad character.
0: 
0: 		@exception StandardException Variable is too big.
0: 	*/
0: 	public final void checkHostVariable(int declaredLength) throws StandardException
0: 	{
0: 		// stream length checking occurs at the JDBC layer
0: 		int variableLength = -1;
0: 		if (stream == null)
0: 		{
0: 			if (dataValue != null)
0: 				variableLength = dataValue.length;
0: 		}
0: 		else
0: 		{
0: 			variableLength = streamLength;
0: 		}
0: 
0: 		if (variableLength != -1 && variableLength > declaredLength)
0: 				throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, getTypeName(), 
0: 							"XX-RESOLVE-XX",
0: 							String.valueOf(declaredLength));
0: 	}
0: 
0: 	/*
0: 	 * String display of value
0: 	 */
0: 
0: 	public final String toString()
0: 	{
0: 		if (dataValue == null)
0: 		{
0: 			if (stream == null)
0: 			{
0: 				return "NULL";
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.THROWASSERT(
0: 						"value is null, stream is not null");
0: 				return "";
0: 			}
0: 		}
0: 		else
0: 		{
0: 			return org.apache.derby.iapi.util.StringUtil.toHexString(dataValue, 0, dataValue.length);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public final int hashCode()
0: 	{
0: 		try {
0: 			if (getValue() == null)
0: 				{
0: 					return 0;
0: 				}
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
0: 			return 0;
0: 		}
0: 
0: 		/* Hash code is simply the sum of all of the bytes */
0: 		byte[] bytes = dataValue;
0: 		int hashcode = 0;
0: 
0: 		// Build the hash code
0: 		for (int index = 0 ; index < bytes.length; index++)
0: 		{
0: 			byte bv = bytes[index];
0: 			if (bv != SQLBinary.PAD)
0: 				hashcode += bytes[index];
0: 		}
0: 
0: 		return hashcode;
0: 	}
0: 	private static int compare(byte[] left, byte[] right) {
0: 
0: 		int minLen = left.length;
0: 		byte[] longer = right;
0: 		if (right.length < minLen) {
0: 			minLen = right.length;
0: 			longer = left;
0: 		}
0: 
0: 		for (int i = 0; i < minLen; i++) {
0: 
0: 			int lb = left[i] & 0xff;
0: 			int rb = right[i] & 0xff;
0: 
0: 			if (lb == rb)
0: 				continue;
0: 
0: 			return lb - rb;
0: 		}
0: 
0: 		// complete match on all the bytes for the smallest value.
0: 
0: 		// if the longer value is all pad characters
0: 		// then the values are equal.
0: 		for (int i = minLen; i < longer.length; i++) {
0: 			byte nb = longer[i];
0: 			if (nb == SQLBinary.PAD)
0: 				continue;
0: 
0: 			// longer value is bigger.
0: 			if (left == longer)
0: 				return 1;
0: 			return -1;
0: 		}
0: 
0: 		return 0;
0: 
0: 	}
0: }
============================================================================