1:a2d0847: /*
1:a2d0847: 
1:a2d0847:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest
1:a2d0847: 
1:a2d0847:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a2d0847:    contributor license agreements.  See the NOTICE file distributed with
1:a2d0847:    this work for additional information regarding copyright ownership.
1:a2d0847:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a2d0847:    (the "License"); you may not use this file except in compliance with
1:a2d0847:    the License.  You may obtain a copy of the License at
1:a2d0847: 
1:a2d0847:      http://www.apache.org/licenses/LICENSE-2.0
1:a2d0847: 
1:a2d0847:    Unless required by applicable law or agreed to in writing, software
1:a2d0847:    distributed under the License is distributed on an "AS IS" BASIS,
1:a2d0847:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a2d0847:    See the License for the specific language governing permissions and
1:a2d0847:    limitations under the License.
1:a2d0847: 
1:a2d0847:  */
1:a2d0847: 
1:a2d0847: package org.apache.derbyTesting.functionTests.tests.lang;
1:a2d0847: 
1:a2d0847: import java.sql.Connection;
1:a2d0847: import java.sql.PreparedStatement;
1:a2d0847: import java.sql.ResultSet;
1:9c18d66: import java.sql.Statement;
1:a2d0847: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a2d0847: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:9c18d66: import org.apache.derbyTesting.junit.JDBC;
1:a2d0847: import org.apache.derbyTesting.junit.TestConfiguration;
1:a2d0847: 
1:a2d0847: /**
1:a2d0847:  * <p>
1:a2d0847:  * Test RestrictedVTIs. See DERBY-4357.
1:a2d0847:  * </p>
1:a2d0847:  */
1:a2d0847: public class RestrictedVTITest  extends GeneratedColumnsHelper
1:a2d0847: {
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // CONSTANTS
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // STATE
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // CONSTRUCTOR
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847: 
1:a2d0847:     /**
1:a2d0847:      * Create a new instance.
1:a2d0847:      */
1:a2d0847: 
1:a2d0847:     public RestrictedVTITest(String name)
1:a2d0847:     {
1:a2d0847:         super(name);
1:a2d0847:     }
1:a2d0847: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // JUnit BEHAVIOR
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847: 
1:f6fa942:     /**
1:a2d0847:      * Construct top level suite in this JUnit test
1:a2d0847:      */
1:a2d0847:     public static Test suite()
1:a2d0847:     {
1:1ae02c9:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:1ae02c9:             RestrictedVTITest.class);
1:a2d0847: 
1:a2d0847:         Test        result = new CleanDatabaseTestSetup( suite );
1:a2d0847: 
1:a2d0847:         return result;
1:a2d0847:     }
1:a2d0847: 
1:a2d0847:     protected void    setUp()
1:a2d0847:         throws Exception
1:a2d0847:     {
1:a2d0847:         super.setUp();
1:a2d0847: 
1:a2d0847:         Connection conn = getConnection();
1:a2d0847: 
1:a2d0847:         if ( !routineExists( conn, "GETLASTPROJECTION" ) )
1:a2d0847:         {
1:a2d0847:             goodStatement
1:a2d0847:                 (
1:a2d0847:                  conn,
1:a2d0847:                  "create function getLastProjection\n" +
1:a2d0847:                  "()\n" +
1:a2d0847:                  "returns varchar( 32672 )\n" +
1:a2d0847:                  "language java parameter style java no sql\n" +
1:a2d0847:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastProjection'\n"
1:a2d0847:                  );
1:a2d0847:         }
1:a2d0847:         if ( !routineExists( conn, "GETLASTRESTRICTION" ) )
1:a2d0847:         {
1:a2d0847:             goodStatement
1:a2d0847:                 (
1:a2d0847:                  conn,
1:a2d0847:                  "create function getLastRestriction\n" +
1:a2d0847:                  "()\n" +
1:a2d0847:                  "returns varchar( 32672 )\n" +
1:a2d0847:                  "language java parameter style java no sql\n" +
1:a2d0847:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastRestriction'\n"
1:a2d0847:                  );
1:a2d0847:         }
1:92d8fc5:         if ( !routineExists( conn, "GETCOUNT" ) )
1:92d8fc5:         {
1:92d8fc5:             goodStatement
1:92d8fc5:                 (
1:92d8fc5:                  conn,
1:92d8fc5:                  "create function getCount\n" +
1:92d8fc5:                  "()\n" +
1:92d8fc5:                  "returns int\n" +
1:92d8fc5:                  "language java parameter style java no sql\n" +
1:92d8fc5:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastQualifiedRowCount'\n"
1:92d8fc5:                  );
1:92d8fc5:         }
1:a2d0847:         if ( !routineExists( conn, "INTEGERLIST" ) )
1:a2d0847:         {
1:a2d0847:             goodStatement
1:a2d0847:                 (
1:a2d0847:                  conn,
1:a2d0847:                  "create function integerList()\n" +
1:a2d0847:                  "returns table( s_r int, s_nr int, ns_r int, ns_nr int )\n" +
1:a2d0847:                  "language java\n" +
1:a2d0847:                  "parameter style derby_jdbc_result_set\n" +
1:a2d0847:                  "no sql\n" +
1:a2d0847:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.integerList'\n"
1:a2d0847:                  );
1:a2d0847:         }
1:a2d0847:         if ( !routineExists( conn, "NULLABLEINTEGERLIST" ) )
1:a2d0847:         {
1:a2d0847:             goodStatement
1:a2d0847:                 (
1:a2d0847:                  conn,
1:a2d0847:                  "create function nullableIntegerList()\n" +
1:a2d0847:                  "returns table( s_r int, s_nr int, ns_r int, ns_nr int )\n" +
1:a2d0847:                  "language java\n" +
1:a2d0847:                  "parameter style derby_jdbc_result_set\n" +
1:a2d0847:                  "no sql\n" +
1:a2d0847:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.nullableIntegerList'\n"
1:a2d0847:                  );
1:a2d0847:         }
1:9c18d66:         if ( !routineExists( conn, "INTEGERLISTSPECIALCOLNAMES" ) )
1:9c18d66:         {
1:9c18d66:             goodStatement
1:a2d0847:                 (
1:9c18d66:                  conn,
1:9c18d66:                  "create function integerListSpecialColNames()\n" +
1:9c18d66:                  "returns table( \"CoL \"\"1\"\"\" int,\n" +
1:9c18d66:                  "\"cOL \"\"2\"\"\" int, col3 int, col4 int )\n" +
1:9c18d66:                  "language java\n" +
1:9c18d66:                  "parameter style derby_jdbc_result_set\n" +
1:9c18d66:                  "no sql\n" +
1:9c18d66:                  "external name '" + getClass().getName() +
1:9c18d66:                  ".integerListSpecialColNames'\n"
1:9c18d66:                  );
1:a2d0847:         }
1:8f23d8f:         if ( !routineExists( conn, "MAKEBLOB5370" ) )
1:8f23d8f:         {
1:8f23d8f:             goodStatement
1:8f23d8f:                 (
1:8f23d8f:                  conn,
1:8f23d8f:                  "create function makeBlob5370( ) returns blob\n" +
1:8f23d8f:                  "language java parameter style java no sql deterministic\n" +
1:8f23d8f:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.BooleanValuesTest.makeSimpleBlob'\n"
1:8f23d8f:                  );
1:8f23d8f:         }
1:8f23d8f:         if ( !routineExists( conn, "LASTQUERY5370" ) )
1:8f23d8f:         {
1:8f23d8f:             goodStatement
1:8f23d8f:                 (
1:8f23d8f:                  conn,
1:8f23d8f:                  "create function lastQuery5370() returns varchar( 32672 )\n" +
1:8f23d8f:                  "language java parameter style java no sql\n" +
1:8f23d8f:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI.getLastQuery'\n"
1:8f23d8f:                  );
1:8f23d8f:         }
1:8f23d8f:         if ( !routineExists( conn, "RESTRICTED5370" ) )
1:8f23d8f:         {
1:8f23d8f:             goodStatement
1:8f23d8f:                 (
1:8f23d8f:                  conn,
1:8f23d8f:                  "create function restricted5370( schemaName varchar( 32672 ), tableName varchar( 32672 ) )\n" +
1:8f23d8f:                  "returns table\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    key_col int,\n" +
1:8f23d8f:                  "    boolean_col  BOOLEAN,\n" +
1:8f23d8f:                  "    bigint_col  BIGINT,\n" +
1:8f23d8f:                  "    blob_col  BLOB(2147483647),\n" +
1:8f23d8f:                  "    char_col  CHAR(10),\n" +
1:8f23d8f:                  "    char_for_bit_data_col  CHAR (10) FOR BIT DATA,\n" +
1:8f23d8f:                  "    clob_col  CLOB,\n" +
1:8f23d8f:                  "    date_col  DATE,\n" +
1:8f23d8f:                  "    decimal_col  DECIMAL(5,2),\n" +
1:8f23d8f:                  "    real_col  REAL,\n" +
1:8f23d8f:                  "    double_col  DOUBLE,\n" +
1:8f23d8f:                  "    int_col  INTEGER,\n" +
1:8f23d8f:                  "    long_varchar_col  LONG VARCHAR,\n" +
1:8f23d8f:                  "    long_varchar_for_bit_data_col  LONG VARCHAR FOR BIT DATA,\n" +
1:8f23d8f:                  "    numeric_col  NUMERIC(5,2), \n" +
1:8f23d8f:                  "    smallint_col  SMALLINT,\n" +
1:8f23d8f:                  "    time_col  TIME,\n" +
1:8f23d8f:                  "    timestamp_col  TIMESTAMP,\n" +
1:8f23d8f:                  "    varchar_col  VARCHAR(10),\n" +
1:8f23d8f:                  "    varchar_for_bit_data_col  VARCHAR (10) FOR BIT DATA\n" +
1:8f23d8f:                  ")\n" +
1:8f23d8f:                  "language java parameter style derby_jdbc_result_set reads sql data\n" +
1:8f23d8f:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI.readTable'\n"
1:8f23d8f:                  );
1:8f23d8f:         }
1:f6fa942:         if ( !tableExists( conn, "T_4357_1" ) )
1:f6fa942:         {
1:f6fa942:             goodStatement
1:f6fa942:                 (
1:f6fa942:                  conn,
1:f6fa942:                  "create table t_4357_1( a int )\n"
1:f6fa942:                  );
1:f6fa942:             goodStatement
1:f6fa942:                 (
1:f6fa942:                  conn,
1:f6fa942:                  "insert into t_4357_1( a ) values cast( null as int), ( 1 ), ( 100 ), ( 1000 ), ( 10000)\n"
1:f6fa942:                  );
1:f6fa942:         }
1:8f23d8f:         if ( !tableExists( conn, "T_5370" ) )
1:8f23d8f:         {
1:8f23d8f:             goodStatement
1:8f23d8f:                 (
1:8f23d8f:                  conn,
1:8f23d8f:                  "create table t_5370\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    key_col int,\n" +
1:8f23d8f:                  "    boolean_col  BOOLEAN,\n" +
1:8f23d8f:                  "    bigint_col  BIGINT,\n" +
1:8f23d8f:                  "    blob_col  BLOB(2147483647),\n" +
1:8f23d8f:                  "    char_col  CHAR(10),\n" +
1:8f23d8f:                  "    char_for_bit_data_col  CHAR (10) FOR BIT DATA,\n" +
1:8f23d8f:                  "    clob_col  CLOB,\n" +
1:8f23d8f:                  "    date_col  DATE,\n" +
1:8f23d8f:                  "    decimal_col  DECIMAL(5,2),\n" +
1:8f23d8f:                  "    real_col  REAL,\n" +
1:8f23d8f:                  "    double_col  DOUBLE,\n" +
1:8f23d8f:                  "    int_col  INTEGER,\n" +
1:8f23d8f:                  "    long_varchar_col  LONG VARCHAR,\n" +
1:8f23d8f:                  "    long_varchar_for_bit_data_col  LONG VARCHAR FOR BIT DATA,\n" +
1:8f23d8f:                  "    numeric_col  NUMERIC(5,2), \n" +
1:8f23d8f:                  "    smallint_col  SMALLINT,\n" +
1:8f23d8f:                  "    time_col  TIME,\n" +
1:8f23d8f:                  "    timestamp_col  TIMESTAMP,\n" +
1:8f23d8f:                  "    varchar_col  VARCHAR(10),\n" +
1:8f23d8f:                  "    varchar_for_bit_data_col  VARCHAR (10) FOR BIT DATA\n" +
1:8f23d8f:                  ")\n"
1:8f23d8f:                  );
1:8f23d8f:             goodStatement
1:8f23d8f:                 (
1:8f23d8f:                  conn,
1:8f23d8f:                  "insert into t_5370\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    key_col,\n" +
1:8f23d8f:                  "    boolean_col,\n" +
1:8f23d8f:                  "    bigint_col,\n" +
1:8f23d8f:                  "    blob_col,\n" +
1:8f23d8f:                  "    char_col,\n" +
1:8f23d8f:                  "    char_for_bit_data_col,\n" +
1:8f23d8f:                  "    clob_col,\n" +
1:8f23d8f:                  "    date_col,\n" +
1:8f23d8f:                  "    decimal_col,\n" +
1:8f23d8f:                  "    real_col,\n" +
1:8f23d8f:                  "    double_col,\n" +
1:8f23d8f:                  "    int_col,\n" +
1:8f23d8f:                  "    long_varchar_col,\n" +
1:8f23d8f:                  "    long_varchar_for_bit_data_col,\n" +
1:8f23d8f:                  "    numeric_col, \n" +
1:8f23d8f:                  "    smallint_col,\n" +
1:8f23d8f:                  "    time_col,\n" +
1:8f23d8f:                  "    timestamp_col,\n" +
1:8f23d8f:                  "    varchar_col,\n" +
1:8f23d8f:                  "    varchar_for_bit_data_col\n" +
1:8f23d8f:                  ")\n" +
1:8f23d8f:                  "values\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    0,\n" +
1:8f23d8f:                  "    false,\n" +
1:8f23d8f:                  "    0,\n" +
1:8f23d8f:                  "    makeBlob5370(),\n" +
1:8f23d8f:                  "    '0',\n" +
1:8f23d8f:                  "    X'DE',\n" +
1:8f23d8f:                  "    '0',\n" +
1:8f23d8f:                  "    date('1994-02-23'),\n" +
1:8f23d8f:                  "    0.00,\n" +
1:8f23d8f:                  "    0.0,\n" +
1:8f23d8f:                  "    0.0,\n" +
1:8f23d8f:                  "    0,\n" +
1:8f23d8f:                  "    '0',\n" +
1:8f23d8f:                  "    X'DE',\n" +
1:8f23d8f:                  "    0.00, \n" +
1:8f23d8f:                  "    0,\n" +
1:8f23d8f:                  "    time('15:09:02'),\n" +
1:8f23d8f:                  "    timestamp('1962-09-23 03:23:34.234'),\n" +
1:8f23d8f:                  "    '0',\n" +
1:8f23d8f:                  "    X'DE'\n" +
1:8f23d8f:                  "),\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    1,\n" +
1:8f23d8f:                  "    true,\n" +
1:8f23d8f:                  "    1,\n" +
1:8f23d8f:                  "    makeBlob5370(),\n" +
1:8f23d8f:                  "    '1',\n" +
1:8f23d8f:                  "    X'DD',\n" +
1:8f23d8f:                  "    '1',\n" +
1:8f23d8f:                  "    date('1994-02-24'),\n" +
1:8f23d8f:                  "    1.00,\n" +
1:8f23d8f:                  "    1.0,\n" +
1:8f23d8f:                  "    1.0,\n" +
1:8f23d8f:                  "    1,\n" +
1:8f23d8f:                  "    '1',\n" +
1:8f23d8f:                  "    X'DE',\n" +
1:8f23d8f:                  "    1.00, \n" +
1:8f23d8f:                  "    1,\n" +
1:8f23d8f:                  "    time('15:09:03'),\n" +
1:8f23d8f:                  "    timestamp('1963-09-23 03:23:34.234'),\n" +
1:8f23d8f:                  "    '1',\n" +
1:8f23d8f:                  "    X'DD'\n" +
1:8f23d8f:                  "),\n" +
1:8f23d8f:                  "(\n" +
1:8f23d8f:                  "    2,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null,\n" +
1:8f23d8f:                  "    null\n" +
1:8f23d8f:                  ")\n"
1:8f23d8f:                  );
1:8f23d8f:         }
1:9c18d66:     }
1:a2d0847: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:91394bf:     //
1:a2d0847:     // TESTS
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:92d8fc5:     /**
1:38a34c2:      * <p>
1:a2d0847:      * Heartbeat test to verify that projections and restrictions are being
1:a2d0847:      * pushed into RestrictedVTIs.
1:a2d0847:      * </p>
1:a2d0847:      */
1:a2d0847:     public void test_01_heartbeat() throws Exception
1:a2d0847:     {
1:a2d0847:         Connection conn = getConnection();
1:a2d0847: 
1:a2d0847:         // test basic pushing of projection and restriction
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100" ,         "200"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, NS_R, null]",
1:a2d0847:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:a2d0847:              );
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000 order by s_r\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,         "200"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, NS_R, null]",
1:f6fa942:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:         // order by with no restriction
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select s_r, s_nr from table( integerList() ) s order by s_r\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "1" ,         "2"  },
1:f6fa942:                  { "100" ,         "200"  },
1:f6fa942:                  { "1000" ,         "2000"  },
1:f6fa942:                  { "10000" ,         "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, null, null]",
1:f6fa942:              null
1:f6fa942:              );
1:a2d0847: 
1:a2d0847:         // similar test except with a ? parameter
1:a2d0847:         PreparedStatement ps = chattyPrepare
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r from table( integerList() ) s where s_r > 1 and ns_r < ?"
1:a2d0847:              );
1:a2d0847:         ps.setInt( 1, 30000 );
1:a2d0847:         ResultSet rs = ps.executeQuery();
1:a2d0847:         assertResults
1:a2d0847:             (
1:a2d0847:              rs,
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100" },
1:a2d0847:                  { "1000" },
1:a2d0847:              },
1:a2d0847:              false
1:a2d0847:              );
1:0d2a54f:         assertResults
1:0d2a54f:             (
1:0d2a54f:              conn,
1:a2d0847:              "values ( getLastProjection() )\n",
1:a2d0847:              new String[][] { { "[S_R, null, NS_R, null]" } },
1:a2d0847:              false
1:a2d0847:              );
1:a2d0847:         assertResults
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "values ( getLastRestriction() )\n",
1:a2d0847:              new String[][] { { "( \"NS_R\" < 30000 ) AND ( \"S_R\" > 1 )" } },
1:a2d0847:              false
1:a2d0847:              );
1:0d2a54f:         
1:a2d0847:         // similar to the first test except NOT the qualification
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( integerList() ) s where not( s_r > 1 and ns_r < 3000 )\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "1" ,         "2"  },
1:a2d0847:                  { "1000" ,         "2000"  },
1:a2d0847:                  { "10000" ,         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, NS_R, null]",
1:a2d0847:              "( \"S_R\" <= 1 ) OR ( \"NS_R\" >= 3000 )"
1:a2d0847:              );
1:a2d0847:     }
1:a2d0847: 
1:38a34c2:     /**
1:f6fa942:      * <p>
1:a2d0847:      * Verify that aliases are correctly mapped to table column names. Also
1:a2d0847:      * verify that SELECT list expressions cause columns to be included in the
1:a2d0847:      * column list. Also verify that predicates which aren't qualifiers are not included in the restriction.
1:a2d0847:      * </p>
1:a2d0847:      */
1:a2d0847:     public void test_02_aliasing() throws Exception
1:a2d0847:     {
1:a2d0847:         Connection conn = getConnection();
1:a2d0847: 
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select 2*w, x from table( integerList() ) as s( w, x, y, z ) where w > 1 and mod( y, 3 ) = 0\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "200" ,         "200"  },
1:a2d0847:                  { "2000" ,         "2000"  },
1:a2d0847:                  { "20000" ,         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, NS_R, null]",
1:a2d0847:              "\"S_R\" > 1"
1:a2d0847:              );
1:a2d0847:     }
1:a2d0847:     
1:a2d0847:     /**
1:a2d0847:      * <p>
1:a2d0847:      * Verify that all relational operators are handled.
1:a2d0847:      * </p>
1:a2d0847:      */
1:a2d0847:     public void test_03_allRelationalOperators() throws Exception
1:a2d0847:     {
1:a2d0847:         Connection conn = getConnection();
1:a2d0847: 
1:a2d0847:         // IS NULL
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r is null\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { null ,         "2"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" IS NULL "
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // IS NOT NULL
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r is not null\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100",         null  },
1:a2d0847:                  { "1000",         "2000"  },
1:a2d0847:                  { "10000",         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" IS NOT NULL "
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // <
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r < 1000\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100",         null  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" < 1000"
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // <=
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r <= 100\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100",         null  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" <= 100"
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // =
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r = 100\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100",         null  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" = 100"
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // >
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r > 100\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "1000",         "2000"  },
1:a2d0847:                  { "10000",         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" > 100"
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // >=
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r >= 100\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100",         null  },
1:a2d0847:                  { "1000",         "2000"  },
1:a2d0847:                  { "10000",         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, null, null]",
1:a2d0847:              "\"S_R\" >= 100"
1:a2d0847:              );
1:a2d0847:     }
1:a2d0847:     
1:a2d0847:     /**
1:a2d0847:      * <p>
1:a2d0847:      * Miscellaneous conditions.
1:a2d0847:      * </p>
1:a2d0847:      */
1:a2d0847:     public void test_04_misc() throws Exception
1:a2d0847:     {
1:a2d0847:         Connection conn = getConnection();
1:a2d0847: 
1:a2d0847:         // Arithmetic expressions are not qualifiers.
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r < s_nr + ns_r\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "10000" ,         "20000"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, S_NR, NS_R, null]",
1:a2d0847:              null
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:         // Casting a literal to an int is computed by the compiler and so is a qualifier
1:a2d0847:         assertPR
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "select s_r from table( nullableIntegerList() ) s where ns_r = cast( '300' as int)\n",
1:a2d0847:              new String[][]
1:a2d0847:              {
1:a2d0847:                  { "100"  },
1:a2d0847:              },
1:a2d0847:              "[S_R, null, NS_R, null]",
1:a2d0847:              "\"NS_R\" = 300"
1:a2d0847:              );
1:a2d0847: 
1:a2d0847:     }
1:a2d0847: 
1:a2d0847:     /**
1:a2d0847:      * <p>
1:f6fa942:      * Test joins to RestrictedVTIs.
1:f6fa942:      * </p>
1:f6fa942:      */
1:f6fa942:     public void test_05_joins() throws Exception
1:f6fa942:     {
1:f6fa942:         Connection conn = getConnection();
1:f6fa942: 
1:f6fa942:         // hashjoin with no restriction
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, y from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,    "100",    "300"  },
1:f6fa942:                  { "1000" ,    "1000",    null  },
1:f6fa942:                  { "10000" ,    "10000",    "30000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, null, NS_R, null]",
1:f6fa942:              null
1:f6fa942:              );
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, y from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w order by y\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,    "100",    "300"  },
1:f6fa942:                  { "10000" ,    "10000",    "30000"  },
1:f6fa942:                  { "1000" ,    "1000",    null  },
1:f6fa942:              },
1:f6fa942:              "[S_R, null, NS_R, null]",
1:f6fa942:              null
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:         // hashjoin with a restriction on the table function
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and y is not null\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,    "100",    null  },
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, NS_R, null]",
1:f6fa942:              "\"NS_R\" IS NOT NULL "
1:f6fa942:              );
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and y is not null order by w\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,    "100",    null  },
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, NS_R, null]",
1:f6fa942:              "\"NS_R\" IS NOT NULL "
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:         // hashjoin with a restriction on the base table which transitive closure
1:f6fa942:         // turns into a restriction on the table function
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a > 100\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "1000" ,    "1000",    "2000" },
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, null, null]",
1:f6fa942:              "\"S_R\" > 100"
1:f6fa942:              );
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a > 100 order by x\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "1000" ,    "1000",    "2000" },
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, null, null]",
1:f6fa942:              "\"S_R\" > 100"
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:         // hashjoin with a restriction that can't be pushed into the table function
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a + x > 100\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "1000" ,    "1000",    "2000" },
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, null, null]",
1:f6fa942:              null
1:f6fa942:              );
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and x + y > 100\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "10000" ,    "10000",    "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, NS_R, null]",
1:f6fa942:              null
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:     }
1:f6fa942: 
1:f6fa942:     /**
1:f6fa942:      * <p>
1:f6fa942:      * Test DISTINCT.
1:f6fa942:      * </p>
1:f6fa942:      */
1:f6fa942:     public void test_06_distinct() throws Exception
1:f6fa942:     {
1:f6fa942:         Connection conn = getConnection();
1:f6fa942: 
1:f6fa942:         // distinct with restriction
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select distinct s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "100" ,         "200"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, NS_R, null]",
1:f6fa942:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:f6fa942:              );
1:f6fa942: 
1:f6fa942:         // distinct without restriction
1:f6fa942:         assertPR
1:f6fa942:             (
1:f6fa942:              conn,
1:f6fa942:              "select distinct s_r, s_nr from table( integerList() ) s\n",
1:f6fa942:              new String[][]
1:f6fa942:              {
1:f6fa942:                  { "1" ,         "2"  },
1:f6fa942:                  { "100" ,         "200"  },
1:f6fa942:                  { "1000" ,         "2000"  },
1:f6fa942:                  { "10000" ,         "20000"  },
1:f6fa942:              },
1:f6fa942:              "[S_R, S_NR, null, null]",
1:f6fa942:              null
1:f6fa942:              );
1:f6fa942:     }
1:f6fa942: 
1:a2d0847:     /**
1:a2d0847:      * <p>
1:38a34c2:      * Test subqueries.
1:38a34c2:      * </p>
1:38a34c2:      */
1:38a34c2:     public void test_07_subqueries() throws Exception
1:38a34c2:     {
1:38a34c2:         Connection conn = getConnection();
1:38a34c2: 
1:38a34c2:         // table function in subquery
1:38a34c2:         assertPR
1:38a34c2:             (
1:38a34c2:              conn,
1:38a34c2:              "select * from t_4357_1 where exists ( select x from table( nullableIntegerList() ) as s( w, x, y, z ) where a = w )\n",
1:38a34c2:              new String[][]
1:38a34c2:              {
1:38a34c2:                  { "100"  },
1:38a34c2:                  { "1000"  },
1:38a34c2:                  { "10000"  },
1:38a34c2:              },
1:38a34c2:              "[S_R, S_NR, null, null]",
1:38a34c2:              null
1:38a34c2:              );
1:38a34c2: 
1:38a34c2:         // table function in inner and outer query blocks
1:38a34c2:         assertPR
1:38a34c2:             (
1:38a34c2:              conn,
1:38a34c2:              "select * from table( nullableIntegerList() ) as t( a, b, c, d ) where exists ( select x from table( nullableIntegerList() ) as s( w, x, y, z ) where a = w )\n",
1:38a34c2:              new String[][]
1:38a34c2:              {
1:38a34c2:                  { "100", null, "300", "400"  },
1:38a34c2:                  { "1000", "2000", null, "4000"  },
1:38a34c2:                  { "10000", "20000", "30000", null  },
1:38a34c2:              },
1:38a34c2:              "[S_R, S_NR, null, null]",
1:38a34c2:              null
1:38a34c2:              );
1:38a34c2: 
1:38a34c2:     }
1:38a34c2: 
1:a2d0847:     /**
1:de4c68f:      * Predicates in HAVING clauses are not (yet) pushed down to the VTI.
1:de4c68f:      * Tracked as DERBY-4650.
1:de4c68f:      */
1:de4c68f:     public void test_08_having() throws Exception
1:de4c68f:     {
1:de4c68f:         assertPR(
1:de4c68f:                 getConnection(),
1:de4c68f:                 "select s_r, count(*) from table(integerList()) t " +
1:de4c68f:                 "group by s_r having s_r > 1",
1:de4c68f:                 new String[][] {{"100", "1"}, {"1000", "1"}, {"10000", "1"}},
1:de4c68f:                 "[S_R, null, null, null]",
1:de4c68f:                 null // DERBY-4650: should be "\"S_R\" > 1" if pushed down
1:de4c68f:                 );
1:de4c68f:     }
1:a2d0847: 
1:9c18d66:     /**
1:92d8fc5:      * Verify that attempts to create a trailing constant qualification do no
1:92d8fc5:      * cause the VTI to return the wrong rows.
1:92d8fc5:      * Tracked as DERBY-4651.
1:92d8fc5:      */
1:92d8fc5:     public void test_09_4651() throws Exception
1:92d8fc5:     {
1:92d8fc5:         Connection conn = getConnection();
1:92d8fc5: 
1:92d8fc5:         assertPR
1:92d8fc5:             (
1:92d8fc5:              conn,
1:92d8fc5:              "select s_r, s_nr from table( integerList() ) s order by s_r\n",
1:92d8fc5:              new String[][]
1:92d8fc5:              {
1:92d8fc5:                  { "1" ,         "2"  },
1:92d8fc5:                  { "100" ,         "200"  },
1:92d8fc5:                  { "1000" ,         "2000"  },
1:92d8fc5:                  { "10000" ,         "20000"  },
1:92d8fc5:              },
1:92d8fc5:              "[S_R, S_NR, null, null]",
1:92d8fc5:              null,
1:92d8fc5:              4
1:92d8fc5:              );
1:92d8fc5: 
1:92d8fc5:         assertPR
1:92d8fc5:             (
1:92d8fc5:              conn,
1:92d8fc5:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 order by s_r\n",
1:92d8fc5:              new String[][]
1:92d8fc5:              {
1:92d8fc5:                  { "1000" ,         "2000"  },
1:92d8fc5:                  { "10000" ,         "20000"  },
1:92d8fc5:              },
1:92d8fc5:              "[S_R, S_NR, null, null]",
1:92d8fc5:              "\"S_R\" > 500",
1:92d8fc5:              2
1:92d8fc5:              );
1:92d8fc5: 
1:92d8fc5:         assertPR
1:92d8fc5:             (
1:92d8fc5:              conn,
1:92d8fc5:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 or 1=1 order by s_r\n",
1:92d8fc5:              new String[][]
1:92d8fc5:              {
1:92d8fc5:                  { "1" ,         "2"  },
1:92d8fc5:                  { "100" ,         "200"  },
1:92d8fc5:                  { "1000" ,         "2000"  },
1:92d8fc5:                  { "10000" ,         "20000"  },
1:92d8fc5:              },
1:92d8fc5:              "[S_R, S_NR, null, null]",
1:92d8fc5:              null,
1:92d8fc5:              4
1:92d8fc5:              );
1:92d8fc5: 
1:92d8fc5:         assertPR
1:92d8fc5:             (
1:92d8fc5:              conn,
1:92d8fc5:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 and 1 != 1 order by s_r\n",
1:92d8fc5:              new String[][]
1:92d8fc5:              {
1:92d8fc5:              },
1:92d8fc5:              "[S_R, S_NR, null, null]",
1:92d8fc5:              null,
1:92d8fc5:              4
1:92d8fc5:              );
1:92d8fc5:     }
1:92d8fc5: 
1:de4c68f:     /**
1:9c18d66:      * Test that {@code Restriction.toSQL()} returns properly quoted column
1:9c18d66:      * names. DERBY-4654.
1:9c18d66:      */
1:9c18d66:     public void test_10_quotes_in_column_names() throws Exception
1:9c18d66:     {
1:9c18d66:         String[][] expectedRows = new String[][] {{"100", "200", "300", "400"}};
1:9c18d66:         String expectedRestriction =
1:9c18d66:                 "( \"cOL \"\"2\"\"\" < 1000 ) AND ( \"CoL \"\"1\"\"\" > 1 )";
1:a2d0847: 
1:9c18d66:         // Check that we can execute a query against a restricted VTI with
1:9c18d66:         // double quotes in the column names.
1:9c18d66:         assertPR(
1:9c18d66:                 getConnection(),
1:9c18d66:                 "select * from table(integerListSpecialColNames()) t " +
1:9c18d66:                 "where \"CoL \"\"1\"\"\" > 1 and \"cOL \"\"2\"\"\" < 1000",
1:9c18d66:                 expectedRows,
1:9c18d66:                 "[CoL \"1\", cOL \"2\", COL3, COL4]",
1:9c18d66:                 expectedRestriction);
1:1ae02c9: 
1:9c18d66:         // Get the restriction that was pushed down.
1:9c18d66:         Statement stmt = createStatement();
1:9c18d66:         ResultSet rs = executeQuery(stmt, "values getLastRestriction()");
1:9c18d66:         assertTrue("empty result", rs.next());
1:9c18d66:         String restriction = rs.getString(1);
1:9c18d66:         assertEquals(expectedRestriction, restriction);
1:9c18d66:         rs.close();
1:9c18d66: 
1:9c18d66:         // Verify that the returned restriction has correct syntax so that
1:9c18d66:         // we can put it directly into the WHERE clause of a select query and
1:9c18d66:         // get the same rows as we did above.
1:9c18d66:         rs = executeQuery(
1:9c18d66:                 stmt,
1:9c18d66:                 "select * from table(integerListSpecialColNames()) t where " +
1:9c18d66:                 restriction);
1:9c18d66:         JDBC.assertUnorderedResultSet(rs, expectedRows);
1:9c18d66:     }
1:9c18d66: 
1:8f23d8f:     /**
1:8f23d8f:      * Verify that Restriction.toSQL() returns usable SQL for all of the
1:0d2a54f:      * comparable types. See DERBY-5369 and DERBY-5370.
1:8f23d8f:      */
1:0d2a54f:     public void test_11_5369_5370() throws Exception
1:8f23d8f:     {
1:8f23d8f:         Connection conn = getConnection();
1:8f23d8f: 
1:a2d0847:         //
1:91394bf:         // The table function used by this test extends VTITemplate, an
1:91394bf:         // implementation of the JDBC 3.0 ResultSet. This table function will
1:91394bf:         // not run on JSR169 because the JDBC 3.0 ResultSet pulls in classes
1:91394bf:         // which don't exist in the JSR169 java.sql package (e.g., java.sql.Ref).
1:91394bf:         //
1:91394bf:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:91394bf: 
1:8f23d8f:         // if this fails, then we need to add a new data type to this test
1:8f23d8f:         vetDatatypeCount( conn, 22 );
1:8f23d8f:         
1:8f23d8f:         // comparable types
1:0d2a54f:         vet5370positive( conn, "BOOLEAN_COL", "false", "false", "true" );
1:0d2a54f:         vet5370positive( conn, "BIGINT_COL", "0", "0", "1" );
1:0d2a54f:         vet5370positive( conn, "CHAR_COL", "'0'", "0         ", "1         " );
1:0d2a54f:         vet5370positive( conn, "CHAR_FOR_BIT_DATA_COL", "X'de'", "de202020202020202020", "dd202020202020202020" );
1:0d2a54f:         vet5370positive( conn, "DATE_COL", "DATE('1994-02-23')", "1994-02-23", "1994-02-24" );
1:0d2a54f:         vet5370positive( conn, "DECIMAL_COL", "0.00", "0.00", "1.00" );
1:0d2a54f:         vet5370positive( conn, "REAL_COL", "0.0", "0.0", "1.0" );
1:0d2a54f:         vet5370positive( conn, "DOUBLE_COL", "0.0", "0.0", "1.0" );
1:0d2a54f:         vet5370positive( conn, "INT_COL", "0", "0", "1" );
1:0d2a54f:         vet5370positive( conn, "NUMERIC_COL", "0.00", "0.00", "1.00" );
1:0d2a54f:         vet5370positive( conn, "SMALLINT_COL", "0", "0", "1" );
1:0d2a54f:         vet5370positive( conn, "TIME_COL", "TIME('15:09:02')", "15:09:02", "15:09:03" );
1:0d2a54f:         vet5370positive( conn, "TIMESTAMP_COL", "TIMESTAMP('1962-09-23 03:23:34.234')", "1962-09-23 03:23:34.234", "1963-09-23 03:23:34.234" );
1:0d2a54f:         vet5370positive( conn, "VARCHAR_COL", "'0'", "0", "1" );
1:0d2a54f:         vet5370positive( conn, "VARCHAR_FOR_BIT_DATA_COL", "X'de'", "de", "dd" );
1:8f23d8f: 
1:8f23d8f:         //
1:8f23d8f:         // The following all fail. If these comparisons start working, then this
1:8f23d8f:         // test should be revisited to make sure that Restriction.toSQL() handles
1:8f23d8f:         // the types which used to not be comparable.
1:8f23d8f:         //
1:8f23d8f:         vet5370negative( "BLOB_COL", "makeBlob5370()" );
1:8f23d8f:         vet5370negative( "CLOB_COL", "'0'" );
1:8f23d8f:         vet5370negative( "LONG_VARCHAR_COL", "'0'" );
1:8f23d8f:         vet5370negative( "LONG_VARCHAR_FOR_BIT_DATA_COL", "X'de'" );
1:8f23d8f:     }
1:8f23d8f:     private void    vet5370positive
1:8f23d8f:         (
1:8f23d8f:          Connection conn,
1:8f23d8f:          String columnName,
1:8f23d8f:          String columnValue,
1:0d2a54f:          String expectedValue,
1:0d2a54f:          String negatedValue
1:8f23d8f:          )
1:8f23d8f:         throws Exception
1:8f23d8f:     {
1:8f23d8f:         assertResults
1:8f23d8f:             (
1:8f23d8f:              conn,
1:0d2a54f:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:8f23d8f:              "where " + columnName + " = " + columnValue,
1:8f23d8f:              new String[][] { new String[] { expectedValue } },
1:8f23d8f:              false
1:8f23d8f:              );
1:8f23d8f: 
1:8f23d8f:         assertResults
1:8f23d8f:             (
1:8f23d8f:              conn,
1:8f23d8f:              "values( lastQuery5370() )",
1:8f23d8f:              new String[][]
1:8f23d8f:              {
1:8f23d8f:                  new String[]
1:8f23d8f:                  {
1:8f23d8f:                      "select " + doubleQuote( columnName ) + "\n" +
1:8f23d8f:                      "from " + doubleQuote( "APP" ) + "." + doubleQuote( "T_5370" ) + "\n" +
1:8f23d8f:                      "where " + doubleQuote( columnName ) + " = " + columnValue
1:8f23d8f:                  }
1:8f23d8f:              },
1:8f23d8f:              false
1:8f23d8f:              );
1:9c18d66:         
1:a2d0847:         assertResults
1:9c18d66:             (
1:a2d0847:              conn,
1:8f23d8f:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:0d2a54f:              "where " + columnName + " != " + columnValue,
1:0d2a54f:              new String[][] { new String[] { negatedValue } },
1:0d2a54f:              false
1:0d2a54f:              );
1:0d2a54f: 
1:0d2a54f:         assertResults
1:0d2a54f:             (
1:0d2a54f:              conn,
1:0d2a54f:              "values( lastQuery5370() )",
1:0d2a54f:              new String[][]
1:0d2a54f:              {
1:0d2a54f:                  new String[]
1:0d2a54f:                  {
1:0d2a54f:                      "select " + doubleQuote( columnName ) + "\n" +
1:0d2a54f:                      "from " + doubleQuote( "APP" ) + "." + doubleQuote( "T_5370" ) + "\n" +
1:0d2a54f:                      "where " + doubleQuote( columnName ) + " != " + columnValue
1:0d2a54f:                  }
1:0d2a54f:              },
1:0d2a54f:              false
1:0d2a54f:              );
1:8f23d8f:     }
1:8f23d8f:     private static  String  doubleQuote( String text )  { return '"' + text + '"'; }
1:8f23d8f:     private void    vet5370negative
1:8f23d8f:         (
1:8f23d8f:          String columnName,
1:8f23d8f:          String columnValue
1:8f23d8f:          )
1:8f23d8f:         throws Exception
1:8f23d8f:     {
1:8f23d8f:         expectCompilationError
1:8f23d8f:             (
1:8f23d8f:              "42818",
1:8f23d8f:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:8f23d8f:              "where " + columnName + " = " + columnValue
1:8f23d8f:              );
1:8f23d8f: 
1:8f23d8f:     }
1:8f23d8f:     private int vetDatatypeCount( Connection conn, int expectedTypeCount ) throws Exception
1:8f23d8f:     {
1:8f23d8f:         //
1:8f23d8f:         // If this fails, it means that we need to add another datatype to
1:8f23d8f:         //
1:8f23d8f:         
1:8f23d8f:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:8f23d8f:         int actualTypeCount = 0;
1:8f23d8f:         while ( rs.next() ) { actualTypeCount++; }
1:8f23d8f:         rs.close();
1:8f23d8f: 
1:8f23d8f:         assertEquals( expectedTypeCount, actualTypeCount );
1:8f23d8f: 
1:8f23d8f:         return actualTypeCount;
1:8f23d8f:     }
1:8f23d8f:     
1:431cbeb:     /**
1:431cbeb:      * Verify that if you wrap a RestrictedVTI in a view, selects
1:431cbeb:      * from the view pass the restriction on to the RestrictedVTI.
1:431cbeb:      * However, the projection is not passed through to the view so it
1:431cbeb:      * is not passed on to the RestrictedVTI, as described on DERBY-6036.
1:431cbeb:      * When that issue is addressed, we should adjust this test case.
1:431cbeb:      */
1:431cbeb:     public void test_12_6036() throws Exception
1:431cbeb:     {
1:431cbeb:         Connection conn = getConnection();
1:431cbeb: 
1:431cbeb:         goodStatement( conn, "create view v6036 as select * from table( integerList() ) s" );
1:431cbeb: 
1:431cbeb:         // directly selecting from the vti pushes down both the projection and the restriction
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "select s_nr from table( integerList() ) s where ns_r = 3000",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "2000" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "values getLastProjection()",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "[null, S_NR, NS_R, null]" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "values getLastRestriction()",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "\"NS_R\" = 3000" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb: 
1:431cbeb:         // directly selecting from the view only pushes down the restriction
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "select s_nr from v6036 where ns_r = 3000",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "2000" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "values getLastProjection()",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "[S_R, S_NR, NS_R, NS_NR]" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb:         assertResults
1:431cbeb:             (
1:431cbeb:              conn,
1:431cbeb:              "values getLastRestriction()",
1:431cbeb:              new String[][]
1:431cbeb:              {
1:431cbeb:                 { "\"NS_R\" = 3000" }
1:431cbeb:              },
1:431cbeb:              false
1:431cbeb:              );
1:431cbeb:     }
1:431cbeb: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // SQL ROUTINES
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847:     public static IntegerArrayVTI integerList()
1:a2d0847:     {
1:a2d0847:         // S => in SELECT list
1:a2d0847:         // NS => NOT in SELECT LIST
1:a2d0847:         // R => in restriction
1:a2d0847:         // NR => NOT in restriction
1:a2d0847:         return new IntegerArrayVTI
1:a2d0847:             (
1:a2d0847:              new String[] { "S_R", "S_NR", "NS_R", "NS_NR" },
1:a2d0847:              new int[][]
1:a2d0847:              {
1:a2d0847:                  new int[] { 1, 2, 3, 4 },
1:a2d0847:                  new int[] { 100, 200, 300, 400 },
1:a2d0847:                  new int[] { 1000, 2000, 3000, 4000 },
1:a2d0847:                  new int[] { 10000, 20000, 30000, 40000 },
1:a2d0847:              }
1:a2d0847:              );
1:a2d0847:     }
1:a2d0847:     
1:a2d0847:     public static IntegerArrayVTI nullableIntegerList()
1:a2d0847:     {
1:a2d0847:         // S => in SELECT list
1:a2d0847:         // NS => NOT in SELECT LIST
1:a2d0847:         // R => in restriction
1:a2d0847:         // NR => NOT in restriction
1:a2d0847:         return new IntegerArrayVTI
1:a2d0847:             (
1:a2d0847:              new String[] { "S_R", "S_NR", "NS_R", "NS_NR" },
1:a2d0847:              new Integer[][]
1:a2d0847:              {
1:a2d0847:                  new Integer[] { null, i(2), i(3), i(4) },
1:a2d0847:                  new Integer[] { i(100), null, i(300), i(400) },
1:a2d0847:                  new Integer[] { i(1000), i(2000), null, i(4000) },
1:a2d0847:                  new Integer[] { i(10000), i(20000), i(30000), null },
1:a2d0847:              }
1:a2d0847:              );
1:a2d0847:     }
1:39b3237:     private static Integer i( int intValue ) { return intValue; }
1:a2d0847: 
1:9c18d66:     public static IntegerArrayVTI integerListSpecialColNames()
1:9c18d66:     {
1:9c18d66:         return new IntegerArrayVTI
1:9c18d66:             (
1:9c18d66:              new String[] { "CoL \"1\"", "cOL \"2\"", "COL3", "COL4" },
1:9c18d66:              new int[][]
1:9c18d66:              {
1:9c18d66:                  new int[] { 1, 2, 3, 4 },
1:9c18d66:                  new int[] { 100, 200, 300, 400 },
1:9c18d66:                  new int[] { 1000, 2000, 3000, 4000 },
1:9c18d66:                  new int[] { 10000, 20000, 30000, 40000 },
1:9c18d66:              }
1:9c18d66:              );
1:9c18d66:     }
1:9c18d66: 
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847:     //
1:a2d0847:     // MINIONS
1:a2d0847:     //
1:a2d0847:     ///////////////////////////////////////////////////////////////////////////////////
1:a2d0847: 
1:a2d0847:     /** Return true if the SQL routine exists */
1:a2d0847:     private boolean routineExists( Connection conn, String functionName ) throws Exception
1:a2d0847:     {
1:a2d0847:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.sysaliases where alias = ?" );
1:a2d0847:         ps.setString( 1, functionName );
1:a2d0847: 
1:a2d0847:         ResultSet rs = ps.executeQuery();
1:a2d0847:         rs.next();
1:a2d0847: 
1:a2d0847:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1:a2d0847: 
1:a2d0847:         rs.close();
1:a2d0847:         ps.close();
1:a2d0847: 
1:a2d0847:         return retval;
1:a2d0847:     }
1:f6fa942: 
1:f6fa942:     /** Return true if the table exists */
1:f6fa942:     private boolean tableExists( Connection conn, String tableName ) throws Exception
1:f6fa942:     {
1:f6fa942:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.systables where tablename = ?" );
1:f6fa942:         ps.setString( 1, tableName );
1:f6fa942: 
1:f6fa942:         ResultSet rs = ps.executeQuery();
1:f6fa942:         rs.next();
1:f6fa942: 
1:f6fa942:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1:f6fa942: 
1:f6fa942:         rs.close();
1:f6fa942:         ps.close();
1:f6fa942: 
1:f6fa942:         return retval;
1:f6fa942:     }
1:a2d0847: 
1:a2d0847:     /**
1:a2d0847:      * <p>
1:92d8fc5:      * Run a query against a RestrictedVTI, verify that the expected
1:92d8fc5:      * projection and restriction are pushed into the VTI, and verify
1:92d8fc5:      * that the VTI returns the expected number of rows.
1:92d8fc5:      * </p>
1:92d8fc5:      */
1:92d8fc5:     private void assertPR
1:92d8fc5:         (
1:92d8fc5:          Connection conn,
1:92d8fc5:          String query,
1:92d8fc5:          String[][] expectedResults,
1:92d8fc5:          String expectedProjection,
1:92d8fc5:          String expectedRestriction,
1:92d8fc5:          int expectedQualifiedRowCount
1:92d8fc5:          ) throws Exception
1:92d8fc5:     {
1:92d8fc5:         assertPR( conn, query, expectedResults, expectedProjection, expectedRestriction );
1:92d8fc5:         
1:92d8fc5:         assertResults
1:92d8fc5:             (
1:92d8fc5:              conn,
1:92d8fc5:              "values ( getCount() )\n",
1:92d8fc5:              new String[][] { { Integer.toString( expectedQualifiedRowCount ) } },
1:92d8fc5:              false
1:92d8fc5:              );
1:92d8fc5:     }
1:92d8fc5: 
1:92d8fc5:     /**
1:92d8fc5:      * <p>
1:a2d0847:      * Run a query against a RestrictedVTI and verify that the expected
1:a2d0847:      * projection and restriction are pushed into the VTI.
1:a2d0847:      * </p>
1:a2d0847:      */
1:a2d0847:     private void assertPR
1:a2d0847:         (
1:a2d0847:          Connection conn,
1:a2d0847:          String query,
1:a2d0847:          String[][] expectedResults,
1:a2d0847:          String expectedProjection,
1:a2d0847:          String expectedRestriction
1:a2d0847:          ) throws Exception
1:a2d0847:     {
1:a2d0847:         assertResults
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              query,
1:a2d0847:              expectedResults,
1:a2d0847:              false
1:a2d0847:              );
1:a2d0847:         assertResults
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "values ( getLastProjection() )\n",
1:a2d0847:              new String[][] { { expectedProjection } },
1:a2d0847:              false
1:a2d0847:              );
1:a2d0847:         assertResults
1:a2d0847:             (
1:a2d0847:              conn,
1:a2d0847:              "values ( getLastRestriction() )\n",
1:a2d0847:              new String[][] { { expectedRestriction } },
1:a2d0847:              false
1:a2d0847:              );
1:a2d0847:     }
1:a2d0847: 
1:a2d0847: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:     private static Integer i( int intValue ) { return intValue; }
commit:431cbeb
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that if you wrap a RestrictedVTI in a view, selects
1:      * from the view pass the restriction on to the RestrictedVTI.
1:      * However, the projection is not passed through to the view so it
1:      * is not passed on to the RestrictedVTI, as described on DERBY-6036.
1:      * When that issue is addressed, we should adjust this test case.
1:      */
1:     public void test_12_6036() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create view v6036 as select * from table( integerList() ) s" );
1: 
1:         // directly selecting from the vti pushes down both the projection and the restriction
1:         assertResults
1:             (
1:              conn,
1:              "select s_nr from table( integerList() ) s where ns_r = 3000",
1:              new String[][]
1:              {
1:                 { "2000" }
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values getLastProjection()",
1:              new String[][]
1:              {
1:                 { "[null, S_NR, NS_R, null]" }
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values getLastRestriction()",
1:              new String[][]
1:              {
1:                 { "\"NS_R\" = 3000" }
1:              },
1:              false
1:              );
1: 
1:         // directly selecting from the view only pushes down the restriction
1:         assertResults
1:             (
1:              conn,
1:              "select s_nr from v6036 where ns_r = 3000",
1:              new String[][]
1:              {
1:                 { "2000" }
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values getLastProjection()",
1:              new String[][]
1:              {
1:                 { "[S_R, S_NR, NS_R, NS_NR]" }
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values getLastRestriction()",
1:              new String[][]
1:              {
1:                 { "\"NS_R\" = 3000" }
1:              },
1:              false
1:              );
1:     }
1: 
commit:0d2a54f
/////////////////////////////////////////////////////////////////////////
1:      * comparable types. See DERBY-5369 and DERBY-5370.
1:     public void test_11_5369_5370() throws Exception
/////////////////////////////////////////////////////////////////////////
1:         vet5370positive( conn, "BOOLEAN_COL", "false", "false", "true" );
1:         vet5370positive( conn, "BIGINT_COL", "0", "0", "1" );
1:         vet5370positive( conn, "CHAR_COL", "'0'", "0         ", "1         " );
1:         vet5370positive( conn, "CHAR_FOR_BIT_DATA_COL", "X'de'", "de202020202020202020", "dd202020202020202020" );
1:         vet5370positive( conn, "DATE_COL", "DATE('1994-02-23')", "1994-02-23", "1994-02-24" );
1:         vet5370positive( conn, "DECIMAL_COL", "0.00", "0.00", "1.00" );
1:         vet5370positive( conn, "REAL_COL", "0.0", "0.0", "1.0" );
1:         vet5370positive( conn, "DOUBLE_COL", "0.0", "0.0", "1.0" );
1:         vet5370positive( conn, "INT_COL", "0", "0", "1" );
1:         vet5370positive( conn, "NUMERIC_COL", "0.00", "0.00", "1.00" );
1:         vet5370positive( conn, "SMALLINT_COL", "0", "0", "1" );
1:         vet5370positive( conn, "TIME_COL", "TIME('15:09:02')", "15:09:02", "15:09:03" );
1:         vet5370positive( conn, "TIMESTAMP_COL", "TIMESTAMP('1962-09-23 03:23:34.234')", "1962-09-23 03:23:34.234", "1963-09-23 03:23:34.234" );
1:         vet5370positive( conn, "VARCHAR_COL", "'0'", "0", "1" );
1:         vet5370positive( conn, "VARCHAR_FOR_BIT_DATA_COL", "X'de'", "de", "dd" );
/////////////////////////////////////////////////////////////////////////
1:          String expectedValue,
1:          String negatedValue
/////////////////////////////////////////////////////////////////////////
1:         
1:         assertResults
1:             (
1:              conn,
1:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:              "where " + columnName + " != " + columnValue,
1:              new String[][] { new String[] { negatedValue } },
1:              false
1:              );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "values( lastQuery5370() )",
1:              new String[][]
1:              {
1:                  new String[]
1:                  {
1:                      "select " + doubleQuote( columnName ) + "\n" +
1:                      "from " + doubleQuote( "APP" ) + "." + doubleQuote( "T_5370" ) + "\n" +
1:                      "where " + doubleQuote( columnName ) + " != " + columnValue
1:                  }
1:              },
1:              false
1:              );
commit:91394bf
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // The table function used by this test extends VTITemplate, an
1:         // implementation of the JDBC 3.0 ResultSet. This table function will
1:         // not run on JSR169 because the JDBC 3.0 ResultSet pulls in classes
1:         // which don't exist in the JSR169 java.sql package (e.g., java.sql.Ref).
1:         //
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
1: 
commit:8f23d8f
/////////////////////////////////////////////////////////////////////////
1:         if ( !routineExists( conn, "MAKEBLOB5370" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function makeBlob5370( ) returns blob\n" +
1:                  "language java parameter style java no sql deterministic\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.BooleanValuesTest.makeSimpleBlob'\n"
1:                  );
1:         }
1:         if ( !routineExists( conn, "LASTQUERY5370" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function lastQuery5370() returns varchar( 32672 )\n" +
1:                  "language java parameter style java no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI.getLastQuery'\n"
1:                  );
1:         }
1:         if ( !routineExists( conn, "RESTRICTED5370" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function restricted5370( schemaName varchar( 32672 ), tableName varchar( 32672 ) )\n" +
1:                  "returns table\n" +
1:                  "(\n" +
1:                  "    key_col int,\n" +
1:                  "    boolean_col  BOOLEAN,\n" +
1:                  "    bigint_col  BIGINT,\n" +
1:                  "    blob_col  BLOB(2147483647),\n" +
1:                  "    char_col  CHAR(10),\n" +
1:                  "    char_for_bit_data_col  CHAR (10) FOR BIT DATA,\n" +
1:                  "    clob_col  CLOB,\n" +
1:                  "    date_col  DATE,\n" +
1:                  "    decimal_col  DECIMAL(5,2),\n" +
1:                  "    real_col  REAL,\n" +
1:                  "    double_col  DOUBLE,\n" +
1:                  "    int_col  INTEGER,\n" +
1:                  "    long_varchar_col  LONG VARCHAR,\n" +
1:                  "    long_varchar_for_bit_data_col  LONG VARCHAR FOR BIT DATA,\n" +
1:                  "    numeric_col  NUMERIC(5,2), \n" +
1:                  "    smallint_col  SMALLINT,\n" +
1:                  "    time_col  TIME,\n" +
1:                  "    timestamp_col  TIMESTAMP,\n" +
1:                  "    varchar_col  VARCHAR(10),\n" +
1:                  "    varchar_for_bit_data_col  VARCHAR (10) FOR BIT DATA\n" +
1:                  ")\n" +
1:                  "language java parameter style derby_jdbc_result_set reads sql data\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI.readTable'\n"
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if ( !tableExists( conn, "T_5370" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create table t_5370\n" +
1:                  "(\n" +
1:                  "    key_col int,\n" +
1:                  "    boolean_col  BOOLEAN,\n" +
1:                  "    bigint_col  BIGINT,\n" +
1:                  "    blob_col  BLOB(2147483647),\n" +
1:                  "    char_col  CHAR(10),\n" +
1:                  "    char_for_bit_data_col  CHAR (10) FOR BIT DATA,\n" +
1:                  "    clob_col  CLOB,\n" +
1:                  "    date_col  DATE,\n" +
1:                  "    decimal_col  DECIMAL(5,2),\n" +
1:                  "    real_col  REAL,\n" +
1:                  "    double_col  DOUBLE,\n" +
1:                  "    int_col  INTEGER,\n" +
1:                  "    long_varchar_col  LONG VARCHAR,\n" +
1:                  "    long_varchar_for_bit_data_col  LONG VARCHAR FOR BIT DATA,\n" +
1:                  "    numeric_col  NUMERIC(5,2), \n" +
1:                  "    smallint_col  SMALLINT,\n" +
1:                  "    time_col  TIME,\n" +
1:                  "    timestamp_col  TIMESTAMP,\n" +
1:                  "    varchar_col  VARCHAR(10),\n" +
1:                  "    varchar_for_bit_data_col  VARCHAR (10) FOR BIT DATA\n" +
1:                  ")\n"
1:                  );
1:             goodStatement
1:                 (
1:                  conn,
1:                  "insert into t_5370\n" +
1:                  "(\n" +
1:                  "    key_col,\n" +
1:                  "    boolean_col,\n" +
1:                  "    bigint_col,\n" +
1:                  "    blob_col,\n" +
1:                  "    char_col,\n" +
1:                  "    char_for_bit_data_col,\n" +
1:                  "    clob_col,\n" +
1:                  "    date_col,\n" +
1:                  "    decimal_col,\n" +
1:                  "    real_col,\n" +
1:                  "    double_col,\n" +
1:                  "    int_col,\n" +
1:                  "    long_varchar_col,\n" +
1:                  "    long_varchar_for_bit_data_col,\n" +
1:                  "    numeric_col, \n" +
1:                  "    smallint_col,\n" +
1:                  "    time_col,\n" +
1:                  "    timestamp_col,\n" +
1:                  "    varchar_col,\n" +
1:                  "    varchar_for_bit_data_col\n" +
1:                  ")\n" +
1:                  "values\n" +
1:                  "(\n" +
1:                  "    0,\n" +
1:                  "    false,\n" +
1:                  "    0,\n" +
1:                  "    makeBlob5370(),\n" +
1:                  "    '0',\n" +
1:                  "    X'DE',\n" +
1:                  "    '0',\n" +
1:                  "    date('1994-02-23'),\n" +
1:                  "    0.00,\n" +
1:                  "    0.0,\n" +
1:                  "    0.0,\n" +
1:                  "    0,\n" +
1:                  "    '0',\n" +
1:                  "    X'DE',\n" +
1:                  "    0.00, \n" +
1:                  "    0,\n" +
1:                  "    time('15:09:02'),\n" +
1:                  "    timestamp('1962-09-23 03:23:34.234'),\n" +
1:                  "    '0',\n" +
1:                  "    X'DE'\n" +
1:                  "),\n" +
1:                  "(\n" +
1:                  "    1,\n" +
1:                  "    true,\n" +
1:                  "    1,\n" +
1:                  "    makeBlob5370(),\n" +
1:                  "    '1',\n" +
1:                  "    X'DD',\n" +
1:                  "    '1',\n" +
1:                  "    date('1994-02-24'),\n" +
1:                  "    1.00,\n" +
1:                  "    1.0,\n" +
1:                  "    1.0,\n" +
1:                  "    1,\n" +
1:                  "    '1',\n" +
1:                  "    X'DE',\n" +
1:                  "    1.00, \n" +
1:                  "    1,\n" +
1:                  "    time('15:09:03'),\n" +
1:                  "    timestamp('1963-09-23 03:23:34.234'),\n" +
1:                  "    '1',\n" +
1:                  "    X'DD'\n" +
1:                  "),\n" +
1:                  "(\n" +
1:                  "    2,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null,\n" +
1:                  "    null\n" +
1:                  ")\n"
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that Restriction.toSQL() returns usable SQL for all of the
0:      * comparable types.
1:      */
0:     public void test_11_5370() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // if this fails, then we need to add a new data type to this test
1:         vetDatatypeCount( conn, 22 );
1:         
1:         // comparable types
0:         vet5370positive( conn, "BOOLEAN_COL", "false", "false" );
0:         vet5370positive( conn, "BIGINT_COL", "0", "0" );
0:         vet5370positive( conn, "CHAR_COL", "'0'", "0         " );
0:         vet5370positive( conn, "CHAR_FOR_BIT_DATA_COL", "X'de'", "de202020202020202020" );
0:         vet5370positive( conn, "DATE_COL", "DATE('1994-02-23')", "1994-02-23" );
0:         vet5370positive( conn, "DECIMAL_COL", "0.00", "0.00" );
0:         vet5370positive( conn, "REAL_COL", "0.0", "0.0" );
0:         vet5370positive( conn, "DOUBLE_COL", "0.0", "0.0" );
0:         vet5370positive( conn, "INT_COL", "0", "0" );
0:         vet5370positive( conn, "NUMERIC_COL", "0.00", "0.00" );
0:         vet5370positive( conn, "SMALLINT_COL", "0", "0" );
0:         vet5370positive( conn, "TIME_COL", "TIME('15:09:02')", "15:09:02" );
0:         vet5370positive( conn, "TIMESTAMP_COL", "TIMESTAMP('1962-09-23 03:23:34.234')", "1962-09-23 03:23:34.234" );
0:         vet5370positive( conn, "VARCHAR_COL", "'0'", "0" );
0:         vet5370positive( conn, "VARCHAR_FOR_BIT_DATA_COL", "X'de'", "de" );
1: 
1:         //
1:         // The following all fail. If these comparisons start working, then this
1:         // test should be revisited to make sure that Restriction.toSQL() handles
1:         // the types which used to not be comparable.
1:         //
1:         vet5370negative( "BLOB_COL", "makeBlob5370()" );
1:         vet5370negative( "CLOB_COL", "'0'" );
1:         vet5370negative( "LONG_VARCHAR_COL", "'0'" );
1:         vet5370negative( "LONG_VARCHAR_FOR_BIT_DATA_COL", "X'de'" );
1:     }
1:     private void    vet5370positive
1:         (
1:          Connection conn,
1:          String columnName,
1:          String columnValue,
0:          String expectedValue
1:          )
1:         throws Exception
1:     {
1:         assertResults
1:             (
1:              conn,
1:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:              "where " + columnName + " = " + columnValue,
1:              new String[][] { new String[] { expectedValue } },
1:              false
1:              );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "values( lastQuery5370() )",
1:              new String[][]
1:              {
1:                  new String[]
1:                  {
1:                      "select " + doubleQuote( columnName ) + "\n" +
1:                      "from " + doubleQuote( "APP" ) + "." + doubleQuote( "T_5370" ) + "\n" +
1:                      "where " + doubleQuote( columnName ) + " = " + columnValue
1:                  }
1:              },
1:              false
1:              );
1:     }
1:     private static  String  doubleQuote( String text )  { return '"' + text + '"'; }
1:     private void    vet5370negative
1:         (
1:          String columnName,
1:          String columnValue
1:          )
1:         throws Exception
1:     {
1:         expectCompilationError
1:             (
1:              "42818",
1:              "select " + columnName + " from table( restricted5370( 'APP', 'T_5370' ) ) s\n" +
1:              "where " + columnName + " = " + columnValue
1:              );
1: 
1:     }
1:     private int vetDatatypeCount( Connection conn, int expectedTypeCount ) throws Exception
1:     {
1:         //
1:         // If this fails, it means that we need to add another datatype to
1:         //
1:         
1:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:         int actualTypeCount = 0;
1:         while ( rs.next() ) { actualTypeCount++; }
1:         rs.close();
1: 
1:         assertEquals( expectedTypeCount, actualTypeCount );
1: 
1:         return actualTypeCount;
1:     }
1:     
commit:92d8fc5
/////////////////////////////////////////////////////////////////////////
1:         if ( !routineExists( conn, "GETCOUNT" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function getCount\n" +
1:                  "()\n" +
1:                  "returns int\n" +
1:                  "language java parameter style java no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastQualifiedRowCount'\n"
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that attempts to create a trailing constant qualification do no
1:      * cause the VTI to return the wrong rows.
1:      * Tracked as DERBY-4651.
1:      */
1:     public void test_09_4651() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s order by s_r\n",
1:              new String[][]
1:              {
1:                  { "1" ,         "2"  },
1:                  { "100" ,         "200"  },
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null,
1:              4
1:              );
1: 
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 order by s_r\n",
1:              new String[][]
1:              {
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" > 500",
1:              2
1:              );
1: 
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 or 1=1 order by s_r\n",
1:              new String[][]
1:              {
1:                  { "1" ,         "2"  },
1:                  { "100" ,         "200"  },
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null,
1:              4
1:              );
1: 
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where s_r > 500 and 1 != 1 order by s_r\n",
1:              new String[][]
1:              {
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null,
1:              4
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Run a query against a RestrictedVTI, verify that the expected
1:      * projection and restriction are pushed into the VTI, and verify
1:      * that the VTI returns the expected number of rows.
1:      * </p>
1:      */
1:     private void assertPR
1:         (
1:          Connection conn,
1:          String query,
1:          String[][] expectedResults,
1:          String expectedProjection,
1:          String expectedRestriction,
1:          int expectedQualifiedRowCount
1:          ) throws Exception
1:     {
1:         assertPR( conn, query, expectedResults, expectedProjection, expectedRestriction );
1:         
1:         assertResults
1:             (
1:              conn,
1:              "values ( getCount() )\n",
1:              new String[][] { { Integer.toString( expectedQualifiedRowCount ) } },
1:              false
1:              );
1:     }
1: 
1:     /**
1:      * <p>
commit:38a34c2
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test subqueries.
1:      * </p>
1:      */
1:     public void test_07_subqueries() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // table function in subquery
1:         assertPR
1:             (
1:              conn,
1:              "select * from t_4357_1 where exists ( select x from table( nullableIntegerList() ) as s( w, x, y, z ) where a = w )\n",
1:              new String[][]
1:              {
1:                  { "100"  },
1:                  { "1000"  },
1:                  { "10000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null
1:              );
1: 
1:         // table function in inner and outer query blocks
1:         assertPR
1:             (
1:              conn,
1:              "select * from table( nullableIntegerList() ) as t( a, b, c, d ) where exists ( select x from table( nullableIntegerList() ) as s( w, x, y, z ) where a = w )\n",
1:              new String[][]
1:              {
1:                  { "100", null, "300", "400"  },
1:                  { "1000", "2000", null, "4000"  },
1:                  { "10000", "20000", "30000", null  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null
1:              );
1: 
1:     }
1:     
commit:f6fa942
/////////////////////////////////////////////////////////////////////////
1:         if ( !tableExists( conn, "T_4357_1" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create table t_4357_1( a int )\n"
1:                  );
1:             goodStatement
1:                 (
1:                  conn,
1:                  "insert into t_4357_1( a ) values cast( null as int), ( 1 ), ( 100 ), ( 1000 ), ( 10000)\n"
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000 order by s_r\n",
1:              new String[][]
1:              {
1:                  { "100" ,         "200"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:              );
1: 
1:         // order by with no restriction
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s order by s_r\n",
1:              new String[][]
1:              {
1:                  { "1" ,         "2"  },
1:                  { "100" ,         "200"  },
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null
1:              );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test joins to RestrictedVTIs.
1:      * </p>
1:      */
1:     public void test_05_joins() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // hashjoin with no restriction
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, y from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w\n",
1:              new String[][]
1:              {
1:                  { "100" ,    "100",    "300"  },
1:                  { "1000" ,    "1000",    null  },
1:                  { "10000" ,    "10000",    "30000"  },
1:              },
1:              "[S_R, null, NS_R, null]",
1:              null
1:              );
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, y from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w order by y\n",
1:              new String[][]
1:              {
1:                  { "100" ,    "100",    "300"  },
1:                  { "10000" ,    "10000",    "30000"  },
1:                  { "1000" ,    "1000",    null  },
1:              },
1:              "[S_R, null, NS_R, null]",
1:              null
1:              );
1: 
1:         // hashjoin with a restriction on the table function
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and y is not null\n",
1:              new String[][]
1:              {
1:                  { "100" ,    "100",    null  },
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "\"NS_R\" IS NOT NULL "
1:              );
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and y is not null order by w\n",
1:              new String[][]
1:              {
1:                  { "100" ,    "100",    null  },
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "\"NS_R\" IS NOT NULL "
1:              );
1: 
1:         // hashjoin with a restriction on the base table which transitive closure
1:         // turns into a restriction on the table function
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a > 100\n",
1:              new String[][]
1:              {
1:                  { "1000" ,    "1000",    "2000" },
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" > 100"
1:              );
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a > 100 order by x\n",
1:              new String[][]
1:              {
1:                  { "1000" ,    "1000",    "2000" },
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" > 100"
1:              );
1: 
1:         // hashjoin with a restriction that can't be pushed into the table function
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and a + x > 100\n",
1:              new String[][]
1:              {
1:                  { "1000" ,    "1000",    "2000" },
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null
1:              );
1:         assertPR
1:             (
1:              conn,
1:              "select a, w, x from t_4357_1, table( nullableIntegerList() ) as s( w, x, y, z ) where a = w and x + y > 100\n",
1:              new String[][]
1:              {
1:                  { "10000" ,    "10000",    "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              null
1:              );
1: 
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test DISTINCT.
1:      * </p>
1:      */
1:     public void test_06_distinct() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // distinct with restriction
1:         assertPR
1:             (
1:              conn,
1:              "select distinct s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000\n",
1:              new String[][]
1:              {
1:                  { "100" ,         "200"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:              );
1: 
1:         // distinct without restriction
1:         assertPR
1:             (
1:              conn,
1:              "select distinct s_r, s_nr from table( integerList() ) s\n",
1:              new String[][]
1:              {
1:                  { "1" ,         "2"  },
1:                  { "100" ,         "200"  },
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              null
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the table exists */
1:     private boolean tableExists( Connection conn, String tableName ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.systables where tablename = ?" );
1:         ps.setString( 1, tableName );
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: 
1: /**
1:  * <p>
1:  * Test RestrictedVTIs. See DERBY-4357.
1:  * </p>
1:  */
1: public class RestrictedVTITest  extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public RestrictedVTITest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(RestrictedVTITest.class);
1:         Test        result = new CleanDatabaseTestSetup( suite );
1: 
1:         return result;
1:     }
1: 
1:     protected void    setUp()
1:         throws Exception
1:     {
1:         super.setUp();
1: 
1:         Connection conn = getConnection();
1: 
1:         if ( !routineExists( conn, "GETLASTPROJECTION" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function getLastProjection\n" +
1:                  "()\n" +
1:                  "returns varchar( 32672 )\n" +
1:                  "language java parameter style java no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastProjection'\n"
1:                  );
1:         }
1:         if ( !routineExists( conn, "GETLASTRESTRICTION" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function getLastRestriction\n" +
1:                  "()\n" +
1:                  "returns varchar( 32672 )\n" +
1:                  "language java parameter style java no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.IntegerArrayVTI.getLastRestriction'\n"
1:                  );
1:         }
1:         if ( !routineExists( conn, "INTEGERLIST" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function integerList()\n" +
1:                  "returns table( s_r int, s_nr int, ns_r int, ns_nr int )\n" +
1:                  "language java\n" +
1:                  "parameter style derby_jdbc_result_set\n" +
1:                  "no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.integerList'\n"
1:                  );
1:         }
1:         if ( !routineExists( conn, "NULLABLEINTEGERLIST" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function nullableIntegerList()\n" +
1:                  "returns table( s_r int, s_nr int, ns_r int, ns_nr int )\n" +
1:                  "language java\n" +
1:                  "parameter style derby_jdbc_result_set\n" +
1:                  "no sql\n" +
1:                  "external name 'org.apache.derbyTesting.functionTests.tests.lang.RestrictedVTITest.nullableIntegerList'\n"
1:                  );
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Heartbeat test to verify that projections and restrictions are being
1:      * pushed into RestrictedVTIs.
1:      * </p>
1:      */
1:     public void test_01_heartbeat() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // test basic pushing of projection and restriction
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where s_r > 1 and ns_r < 3000\n",
1:              new String[][]
1:              {
1:                  { "100" ,         "200"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "( \"NS_R\" < 3000 ) AND ( \"S_R\" > 1 )"
1:              );
1: 
1:         // similar test except with a ? parameter
1:         PreparedStatement ps = chattyPrepare
1:             (
1:              conn,
1:              "select s_r from table( integerList() ) s where s_r > 1 and ns_r < ?"
1:              );
1:         ps.setInt( 1, 30000 );
1:         ResultSet rs = ps.executeQuery();
1:         assertResults
1:             (
1:              rs,
1:              new String[][]
1:              {
1:                  { "100" },
1:                  { "1000" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values ( getLastProjection() )\n",
1:              new String[][] { { "[S_R, null, NS_R, null]" } },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values ( getLastRestriction() )\n",
1:              new String[][] { { "( \"NS_R\" < 30000 ) AND ( \"S_R\" > 1 )" } },
1:              false
1:              );
1:         
1:         // similar to the first test except NOT the qualification
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( integerList() ) s where not( s_r > 1 and ns_r < 3000 )\n",
1:              new String[][]
1:              {
1:                  { "1" ,         "2"  },
1:                  { "1000" ,         "2000"  },
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "( \"S_R\" <= 1 ) OR ( \"NS_R\" >= 3000 )"
1:              );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Verify that aliases are correctly mapped to table column names. Also
1:      * verify that SELECT list expressions cause columns to be included in the
1:      * column list. Also verify that predicates which aren't qualifiers are not included in the restriction.
1:      * </p>
1:      */
1:     public void test_02_aliasing() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         assertPR
1:             (
1:              conn,
1:              "select 2*w, x from table( integerList() ) as s( w, x, y, z ) where w > 1 and mod( y, 3 ) = 0\n",
1:              new String[][]
1:              {
1:                  { "200" ,         "200"  },
1:                  { "2000" ,         "2000"  },
1:                  { "20000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              "\"S_R\" > 1"
1:              );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Verify that all relational operators are handled.
1:      * </p>
1:      */
1:     public void test_03_allRelationalOperators() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // IS NULL
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r is null\n",
1:              new String[][]
1:              {
1:                  { null ,         "2"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" IS NULL "
1:              );
1: 
1:         // IS NOT NULL
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r is not null\n",
1:              new String[][]
1:              {
1:                  { "100",         null  },
1:                  { "1000",         "2000"  },
1:                  { "10000",         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" IS NOT NULL "
1:              );
1: 
1:         // <
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r < 1000\n",
1:              new String[][]
1:              {
1:                  { "100",         null  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" < 1000"
1:              );
1: 
1:         // <=
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r <= 100\n",
1:              new String[][]
1:              {
1:                  { "100",         null  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" <= 100"
1:              );
1: 
1:         // =
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r = 100\n",
1:              new String[][]
1:              {
1:                  { "100",         null  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" = 100"
1:              );
1: 
1:         // >
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r > 100\n",
1:              new String[][]
1:              {
1:                  { "1000",         "2000"  },
1:                  { "10000",         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" > 100"
1:              );
1: 
1:         // >=
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r >= 100\n",
1:              new String[][]
1:              {
1:                  { "100",         null  },
1:                  { "1000",         "2000"  },
1:                  { "10000",         "20000"  },
1:              },
1:              "[S_R, S_NR, null, null]",
1:              "\"S_R\" >= 100"
1:              );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Miscellaneous conditions.
1:      * </p>
1:      */
1:     public void test_04_misc() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // Arithmetic expressions are not qualifiers.
1:         assertPR
1:             (
1:              conn,
1:              "select s_r, s_nr from table( nullableIntegerList() ) s where s_r < s_nr + ns_r\n",
1:              new String[][]
1:              {
1:                  { "10000" ,         "20000"  },
1:              },
1:              "[S_R, S_NR, NS_R, null]",
1:              null
1:              );
1: 
1:         // Casting a literal to an int is computed by the compiler and so is a qualifier
1:         assertPR
1:             (
1:              conn,
1:              "select s_r from table( nullableIntegerList() ) s where ns_r = cast( '300' as int)\n",
1:              new String[][]
1:              {
1:                  { "100"  },
1:              },
1:              "[S_R, null, NS_R, null]",
1:              "\"NS_R\" = 300"
1:              );
1: 
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // SQL ROUTINES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public static IntegerArrayVTI integerList()
1:     {
1:         // S => in SELECT list
1:         // NS => NOT in SELECT LIST
1:         // R => in restriction
1:         // NR => NOT in restriction
1:         return new IntegerArrayVTI
1:             (
1:              new String[] { "S_R", "S_NR", "NS_R", "NS_NR" },
1:              new int[][]
1:              {
1:                  new int[] { 1, 2, 3, 4 },
1:                  new int[] { 100, 200, 300, 400 },
1:                  new int[] { 1000, 2000, 3000, 4000 },
1:                  new int[] { 10000, 20000, 30000, 40000 },
1:              }
1:              );
1:     }
1:     
1:     public static IntegerArrayVTI nullableIntegerList()
1:     {
1:         // S => in SELECT list
1:         // NS => NOT in SELECT LIST
1:         // R => in restriction
1:         // NR => NOT in restriction
1:         return new IntegerArrayVTI
1:             (
1:              new String[] { "S_R", "S_NR", "NS_R", "NS_NR" },
1:              new Integer[][]
1:              {
1:                  new Integer[] { null, i(2), i(3), i(4) },
1:                  new Integer[] { i(100), null, i(300), i(400) },
1:                  new Integer[] { i(1000), i(2000), null, i(4000) },
1:                  new Integer[] { i(10000), i(20000), i(30000), null },
1:              }
1:              );
1:     }
0:     private static Integer i( int intValue ) { return new Integer( intValue ); }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Return true if the SQL routine exists */
1:     private boolean routineExists( Connection conn, String functionName ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "select count (*) from sys.sysaliases where alias = ?" );
1:         ps.setString( 1, functionName );
1: 
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1: 
1:         boolean retval = rs.getInt( 1 ) > 0 ? true : false;
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Run a query against a RestrictedVTI and verify that the expected
1:      * projection and restriction are pushed into the VTI.
1:      * </p>
1:      */
1:     private void assertPR
1:         (
1:          Connection conn,
1:          String query,
1:          String[][] expectedResults,
1:          String expectedProjection,
1:          String expectedRestriction
1:          ) throws Exception
1:     {
1:         assertResults
1:             (
1:              conn,
1:              query,
1:              expectedResults,
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values ( getLastProjection() )\n",
1:              new String[][] { { expectedProjection } },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values ( getLastRestriction() )\n",
1:              new String[][] { { expectedRestriction } },
1:              false
1:              );
1:     }
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:             RestrictedVTITest.class);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9c18d66
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         if ( !routineExists( conn, "INTEGERLISTSPECIALCOLNAMES" ) )
1:         {
1:             goodStatement
1:                 (
1:                  conn,
1:                  "create function integerListSpecialColNames()\n" +
1:                  "returns table( \"CoL \"\"1\"\"\" int,\n" +
1:                  "\"cOL \"\"2\"\"\" int, col3 int, col4 int )\n" +
1:                  "language java\n" +
1:                  "parameter style derby_jdbc_result_set\n" +
1:                  "no sql\n" +
1:                  "external name '" + getClass().getName() +
1:                  ".integerListSpecialColNames'\n"
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that {@code Restriction.toSQL()} returns properly quoted column
1:      * names. DERBY-4654.
1:      */
1:     public void test_10_quotes_in_column_names() throws Exception
1:     {
1:         String[][] expectedRows = new String[][] {{"100", "200", "300", "400"}};
1:         String expectedRestriction =
1:                 "( \"cOL \"\"2\"\"\" < 1000 ) AND ( \"CoL \"\"1\"\"\" > 1 )";
1: 
1:         // Check that we can execute a query against a restricted VTI with
1:         // double quotes in the column names.
1:         assertPR(
1:                 getConnection(),
1:                 "select * from table(integerListSpecialColNames()) t " +
1:                 "where \"CoL \"\"1\"\"\" > 1 and \"cOL \"\"2\"\"\" < 1000",
1:                 expectedRows,
1:                 "[CoL \"1\", cOL \"2\", COL3, COL4]",
1:                 expectedRestriction);
1: 
1:         // Get the restriction that was pushed down.
1:         Statement stmt = createStatement();
1:         ResultSet rs = executeQuery(stmt, "values getLastRestriction()");
1:         assertTrue("empty result", rs.next());
1:         String restriction = rs.getString(1);
1:         assertEquals(expectedRestriction, restriction);
1:         rs.close();
1: 
1:         // Verify that the returned restriction has correct syntax so that
1:         // we can put it directly into the WHERE clause of a select query and
1:         // get the same rows as we did above.
1:         rs = executeQuery(
1:                 stmt,
1:                 "select * from table(integerListSpecialColNames()) t where " +
1:                 restriction);
1:         JDBC.assertUnorderedResultSet(rs, expectedRows);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public static IntegerArrayVTI integerListSpecialColNames()
1:     {
1:         return new IntegerArrayVTI
1:             (
1:              new String[] { "CoL \"1\"", "cOL \"2\"", "COL3", "COL4" },
1:              new int[][]
1:              {
1:                  new int[] { 1, 2, 3, 4 },
1:                  new int[] { 100, 200, 300, 400 },
1:                  new int[] { 1000, 2000, 3000, 4000 },
1:                  new int[] { 10000, 20000, 30000, 40000 },
1:              }
1:              );
1:     }
0: 
commit:de4c68f
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Predicates in HAVING clauses are not (yet) pushed down to the VTI.
1:      * Tracked as DERBY-4650.
1:      */
1:     public void test_08_having() throws Exception
1:     {
1:         assertPR(
1:                 getConnection(),
1:                 "select s_r, count(*) from table(integerList()) t " +
1:                 "group by s_r having s_r > 1",
1:                 new String[][] {{"100", "1"}, {"1000", "1"}, {"10000", "1"}},
1:                 "[S_R, null, null, null]",
1:                 null // DERBY-4650: should be "\"S_R\" > 1" if pushed down
1:                 );
1:     }
0: 
============================================================================