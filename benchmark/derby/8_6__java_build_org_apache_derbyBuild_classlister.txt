1:eac0369: /*
1:cd3749b: 
1:cd3749b:    Derby - Class org.apache.derbyBuild.classlister
1:cd3749b: 
1:de243e0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:de243e0:    contributor license agreements.  See the NOTICE file distributed with
1:de243e0:    this work for additional information regarding copyright ownership.
1:de243e0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:de243e0:    (the "License"); you may not use this file except in compliance with
1:de243e0:    the License.  You may obtain a copy of the License at
1:cd3749b: 
1:cd3749b:       http://www.apache.org/licenses/LICENSE-2.0
1:cd3749b: 
1:cd3749b:    Unless required by applicable law or agreed to in writing, software
1:cd3749b:    distributed under the License is distributed on an "AS IS" BASIS,
1:cd3749b:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cd3749b:    See the License for the specific language governing permissions and
1:cd3749b:    limitations under the License.
5:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derbyBuild;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.classfile.*;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import java.util.*;
1:eac0369: import java.util.zip.*;
2:eac0369: import java.io.*;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 	A tool that generates a list of required classes from a
1:eac0369: 	set of properties files. The value of any property within a property
1:eac0369: 	file that starts with 'derby.module.' is taken as a class name.
1:eac0369: 	That class name and all the clases it requires are listed to
1:eac0369: 	System.out, to facilitate building a zip file. Classes that
1:eac0369: 	start with 'java.' or 'javax.' are not listed and are not
1:eac0369: 	checked for dependent classes.
1:eac0369: 	<P>
1:eac0369: 	If the class name starts with 'com.ibm.db2j.' then a messages.properties
1:eac0369: 	file is searched for corresponding to that class, if one exists then
1:eac0369: 	is is added to the list of files printed.
1:eac0369: 	<P>
1:eac0369: 	The search path for the classes is $CLASSPATH
1:eac0369: 	<P>
1:eac0369: 	If the system property cloudscapeOnly is set to true then only classes
1:eac0369: 	and message.properties files are listed that start with com.ibm.db2j.
1:eac0369: 	<P>
1:eac0369: 	The output for each class or properties file is a relative file
1:eac0369: 	name that uses '/' as the file separator. e.g.
1:eac0369: 
1:eac0369: 	com/ibm/db2j/core/Setup.class
1:eac0369: 
1:eac0369:   <P>
1:eac0369: 	The output order of the classes & files is random.
1:eac0369:     <P>
1:eac0369: 
1:eac0369: 
1:eac0369:     Usage: java [-DignoreWebLogic=true] [-Dverbose=true] [-DcloudscapeOnly=true] [-DruntimeOnly=true] 
1:eac0369: 	[-Ddb2jtools=true]
1:eac0369:     [-DportingOnly=true] [-Doutputfile=<filename>] org.apache.derbyBuild.classlister 
1:eac0369:     property_file [ property_file ... ]
1:eac0369: **/
1:eac0369: 
1:50d75f3: public class classlister {
1:eac0369: 
1:eac0369: 	protected String[] sets;
1:38b9499: 	protected Hashtable<String, String> foundClasses;
1:eac0369: 	//protected ClassUtilitiesFactory cuf;
1:eac0369: 
1:eac0369: 	protected boolean cloudscapeOnly = false;
1:eac0369: 	protected boolean portingOnly = false;
1:eac0369: 	protected boolean ignoreWebLogic = false;
1:eac0369: 	protected boolean verbose = false;
1:eac0369: 	protected boolean skipJava = true;
1:eac0369: 	protected boolean skipJavax = true;
1:eac0369: 	protected boolean skipOrg = true;
1:eac0369: 	protected boolean skipInformix = true;
1:eac0369: 	protected boolean skipDB2 = true;
1:eac0369: 	protected boolean skipDB2e = true;
1:eac0369:         protected boolean skipSun = true;
1:eac0369: 	protected boolean showAll = false;
1:eac0369: 	protected boolean keepRolling = false;
1:eac0369: 	protected boolean showOne = false;
1:38b9499: 	protected Hashtable<String, Hashtable<String, String>> masterClassList =
1:38b9499:             new Hashtable<String, Hashtable<String, String>>();
1:eac0369:     protected String classpath[] = null;
1:eac0369:     protected String outputfile;
1:38b9499:     protected Hashtable<String, Object> classpathHash;
1:eac0369: 	protected int indent = 0;
1:eac0369: 	protected int errorCount = 0;
1:eac0369: 	protected PrintWriter pwOut;
1:eac0369: 	protected PrintStream psOut;
1:eac0369: 
1:eac0369: 	protected boolean db2jtools;
1:eac0369: 	protected boolean db2jdrda;
1:eac0369: 
1:eac0369: 	protected boolean keepDependencyHistory;
1:eac0369: 
1:eac0369: 	protected static final String[] propFiles = {
1:eac0369: 		"messages.properties",
1:eac0369: 		"instructions.properties",
1:eac0369:                 "metadata.properties"
1:eac0369: 	};
1:eac0369: 
1:eac0369: 	public static void main(String args[]) throws IOException {
1:eac0369: 
1:eac0369: 		classlister me = new classlister();
1:eac0369: 
1:eac0369: 		me.sets = args;
1:eac0369: 
1:eac0369: 		me.run();
1:eac0369: 		if (me.errorCount > 0)
1:eac0369: 		{
1:eac0369: 			System.out.println(me.errorCount + " errors encountered.");
1:eac0369: 			System.exit(1);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public classlister() {
1:eac0369: 		cloudscapeOnly = Boolean.getBoolean("cloudscapeOnly");
1:eac0369: 		portingOnly = Boolean.getBoolean("portingOnly");
1:eac0369:         ignoreWebLogic = Boolean.getBoolean("ignoreWebLogic");
1:eac0369:         verbose = Boolean.getBoolean("verbose");
1:eac0369:         skipJava = ! Boolean.getBoolean("doJava");
1:eac0369:         skipJavax = ! Boolean.getBoolean("doJavax");
1:eac0369:         skipOrg = ! Boolean.getBoolean("doOrg");
1:eac0369:         showAll = Boolean.getBoolean("showAll");
1:eac0369:         showOne = Boolean.getBoolean("showOne");
1:eac0369:         keepRolling = Boolean.getBoolean("keepRolling");
1:eac0369:         outputfile = System.getProperty("outputfile");
1:eac0369: 		db2jtools = Boolean.getBoolean("db2jtools");
1:eac0369: 		db2jdrda = Boolean.getBoolean("db2jdrda");
1:eac0369: 
1:eac0369: 		keepDependencyHistory = showOne || showAll;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void run() 
1:eac0369: 	{
1:eac0369: 		//System.out.println("outputfile: " + outputfile);
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 		    File outFile = new File(outputfile);
1:eac0369: 		    pwOut = new PrintWriter( new BufferedWriter
1:eac0369:                 (new FileWriter(outFile.getPath()), 10000), true );
1:eac0369:         }
1:eac0369:         catch (IOException ioe)
1:eac0369:         {
1:eac0369:             System.out.println(ioe);
1:eac0369:             System.exit(1);
1:eac0369:         }
1:eac0369: 	    
1:eac0369: 		loadClasspath();
1:eac0369: 		//cuf = new ModifyClasses();
1:eac0369: 
1:38b9499: 		foundClasses = new Hashtable<String, String>(3000, 0.8f);
1:eac0369: 		
1:eac0369: 		for (int i = 0; i < sets.length; i++) 
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			// If a set name ends in '.class' then take it as a class
1:eac0369: 			// name of the form com.acme.foo.MyClass.class.
1:eac0369: 			try 
1:eac0369: 			{
1:eac0369: 
1:eac0369: 				String s = sets[i];
1:eac0369: 
1:eac0369: 				if (s.endsWith(".class")) {
1:eac0369: 
1:eac0369: 					findDependencies(s.substring(0, s.length() - 6));
1:eac0369: 				} else {
1:eac0369: 
1:eac0369: 					FileInputStream fis = new FileInputStream(s);
1:eac0369: 
1:eac0369: 					Properties pset = new Properties();
1:eac0369: 
1:eac0369: 					pset.load(fis);
1:eac0369: 
1:eac0369: 					findClasses(pset);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			} 
1:eac0369: 			catch (IOException ioe) 
1:eac0369: 			{
1:eac0369: 				System.err.println(ioe.toString());
1:eac0369: 				System.exit(1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369:         if (pwOut == null)
1:eac0369:         {
1:eac0369:             System.out.println("Need to specify an outputfile");
1:eac0369:             System.exit(1);
1:eac0369:         }
1:eac0369: 		for (Enumeration e = foundClasses.keys(); e.hasMoreElements(); ) {
1:eac0369: 			String name = (String) e.nextElement();
1:eac0369: 			String type = (String) foundClasses.get(name);
1:eac0369: 			if (type.equals("class")) {
1:eac0369:                 if (ignoreWebLogic) {
1:eac0369:                     if (name.startsWith("weblogic")) {
1:eac0369:                         continue;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 
1:eac0369: 				if (isCloudscapeCode(name)) {
1:eac0369: 
1:eac0369: 					if (name.startsWith("com.ibm.db2j.porting.")) {
1:eac0369: 						if (cloudscapeOnly)
1:eac0369: 							continue;
1:eac0369: 					} else {
1:eac0369: 						if (portingOnly)
1:eac0369: 							continue;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 				} else {
1:eac0369: 					if (cloudscapeOnly || portingOnly)
1:eac0369: 						continue;
1:eac0369: 				}
1:eac0369: 				pwOut.println(name.replace('.', '/') + ".class");
1:eac0369: 			}
1:eac0369: 			else {
1:eac0369: 				// is a file name
1:eac0369: 				if (name.startsWith("com/ibm/db2j/")) {
1:eac0369: 					if (portingOnly) {
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 				} else {
1:eac0369: 					if (cloudscapeOnly || portingOnly)
1:eac0369: 						continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				pwOut.println(name);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (showAll)
1:eac0369: 		{
1:eac0369: 			showAllItems();
1:eac0369: 		}
1:eac0369: 		if (showOne)
1:eac0369: 		{
1:eac0369: 			showAllItemsOneLevel();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void findClasses(Properties pset) throws IOException {
1:eac0369: 
1:eac0369: 		for (Enumeration e = pset.propertyNames(); e.hasMoreElements(); ) {
1:eac0369: 			String key = (String) e.nextElement();
1:eac0369: 			if (key.startsWith("derby.module.")) {
1:eac0369: 				if (verbose) {
1:eac0369: 					pwOut.println(pset.getProperty(key) + " needs ");
1:eac0369: 				}
1:eac0369: 				findDependencies(pset.getProperty(key));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     protected void loadClasspath()
1:eac0369:     {
1:38b9499:         classpathHash = new Hashtable<String, Object>();
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 String classpathString = System.getProperty("java.class.path");
1:eac0369: 				if (verbose)
1:eac0369: 					pwOut.println("classpath: " + classpathString);
1:eac0369:                 StringTokenizer st = new StringTokenizer(classpathString, File.pathSeparator);
1:eac0369:                 int entries = st.countTokens();
1:eac0369:                 classpath = new String[entries];
1:eac0369:                 for (int i = 0; i < entries; i++)
1:eac0369:                 {
1:eac0369:                     classpath[i] = st.nextToken();
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             catch (SecurityException se)
1:eac0369:             {
1:eac0369:                 pwOut.println("**error** SecurityException getting classpath");
1:eac0369:                 System.exit(1);
1:eac0369:             }
1:eac0369:         for (int i = 0; i < classpath.length; i++)
1:eac0369:         {
1:eac0369:             String pathEntry = classpath[i];
1:eac0369:             if (pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".ZIP") ||
1:eac0369:                 pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".JAR") )
1:eac0369:             {
1:eac0369:                 ZipFile zipfile = null;
1:eac0369:                 try
1:eac0369:                 {
1:eac0369:                     zipfile = new ZipFile(pathEntry.replace('/', File.separatorChar));
1:eac0369:                 }
1:eac0369:                 catch (IOException ioe)
1:eac0369:                 {
1:eac0369:                     // can't do anything about it; zipfile doesn't exists
1:eac0369:                     // it can happen if the person sticks a directory called
1:eac0369:                     // foo.zip in the classpath or foo.zip doesn't exist as
1:eac0369:                     // a file
1:eac0369:                 }
1:eac0369:                 if (zipfile != null)
1:eac0369:                 {
1:eac0369: 
1:eac0369:                     classpathHash.put(pathEntry, zipfile);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369: 					if (verbose)
1:eac0369: 					{
1:eac0369: 	                    pwOut.println("Ignoring <zip> entry: " + pathEntry);
1:eac0369: 					}
1:eac0369: 	
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 File file = new File(pathEntry);
1:eac0369: 
1:eac0369:                 if (file.exists() && file.isDirectory())
1:eac0369:                 {
1:eac0369:                     classpathHash.put(pathEntry, file);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                    	if (verbose)
1:eac0369: 					{ 
1:eac0369:                     	pwOut.println("Ignoring <dir> entry: " + pathEntry);
1:eac0369: 					}
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     protected InputStream locateClass(String className, boolean beVerbose)
1:eac0369:     {
1:eac0369:         if (className.startsWith("/"))
1:eac0369:         {
1:eac0369:             className = className.substring(1);
1:eac0369:         }
1:eac0369:         if (beVerbose)
1:eac0369:         {
1:eac0369:             pwOut.println("Looking for " + className);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (classpath == null)
1:eac0369:         {
1:eac0369:             loadClasspath();
1:eac0369:         }
1:eac0369: 
1:eac0369:         for (int i = 0; i < classpath.length; i++)
1:eac0369:         {
1:eac0369:             String pathEntry = classpath[i];
1:eac0369:             Object hash = classpathHash.get(pathEntry);
1:eac0369:             if (hash != null)
1:eac0369:             {
1:eac0369:                 if (hash instanceof ZipFile)
1:eac0369:                 try
1:eac0369:                 {
1:eac0369:                     ZipFile zipfile = (ZipFile) hash;
1:eac0369: 
1:eac0369:                     ZipEntry entry = zipfile.getEntry(className);
1:eac0369: 
1:eac0369:                     if (entry != null)
1:eac0369:                     {
1:eac0369:                         InputStream is = zipfile.getInputStream(entry);
1:eac0369:                         DataInputStream dis= new DataInputStream(new BufferedInputStream(is));
1:eac0369:                         return dis;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 catch (IOException ioe)
1:eac0369:                 {
1:eac0369:                     if (beVerbose)
1:eac0369:                     {
1:eac0369:                         pwOut.println("IOException loading ZipFile or creating InputStream " +
1:eac0369:                             " from it");
1:eac0369:                         pwOut.println(ioe);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 else if (hash instanceof File)
1:eac0369:                 {
1:eac0369:                     File file = new File((File)hash, className.replace('/', File.separatorChar));
1:eac0369:                     if (beVerbose)
1:eac0369:                     {
1:eac0369:                         pwOut.println("looking to load file: " + file.getName());
1:eac0369:                     }
1:eac0369:                     if (file.exists())
1:eac0369:                     {
1:eac0369:                         if (beVerbose)
1:eac0369:                         {
1:eac0369:                             pwOut.println(" found it!");
1:eac0369:                         }
1:eac0369:                         try
1:eac0369:                         {
1:eac0369:                             FileInputStream fis = new FileInputStream(file);
1:eac0369:                             return new BufferedInputStream(fis, 8192);
1:eac0369:                         }
1:eac0369:                         catch (IOException ioe)
1:eac0369:                         {
1:eac0369:                             if (beVerbose)
1:eac0369:                             {
1:eac0369:                                 pwOut.println("IOException creating FileInputStream");
1:eac0369:                                 pwOut.println(ioe);
1:eac0369:                                 return null;
1:eac0369:                             }
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:c491355:             //
1:eac0369:         }
1:eac0369: 
1:eac0369:         // could not find it
1:eac0369:         if (beVerbose)
1:eac0369:         {
1:eac0369:             pwOut.println("returing null on purpose");
1:eac0369:         }
1:eac0369:         return null;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	protected void findDependencies(String className) throws IOException {
1:eac0369: 		indent++;
1:eac0369: 		try {
1:eac0369: 		if (className.startsWith("java.") && skipJava)
1:eac0369: 		{
1:eac0369: 			pwOut.println("Skipping JAVA " + className);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (className.startsWith("javax.") && skipJavax)
1:eac0369: 		{
1:eac0369: 			//System.out.println("Skipping JAVAX " + className);
1:eac0369: 		    return;
1:eac0369: 		}
1:eac0369:                 if (className.startsWith("sun.") && skipSun)
1:eac0369:                 {
1:eac0369:                         //System.out.println("Skipping Sun " + className);
1:eac0369:                     return;
1:eac0369:                 }
1:eac0369: 		if (className.startsWith("org.") && skipOrg)
1:eac0369: 		{
1:eac0369: 		    // Allow opensource org.apache.derby classes
1:eac0369:                     if (!className.startsWith("org.apache.derby")) 
1:eac0369: 		    {
1:eac0369: 			//System.out.println("Skipping org " + className);
1:eac0369: 			return;
1:eac0369: 		    }
1:eac0369: 		}
1:eac0369: 		if (className.startsWith("com.informix.") && skipInformix)
1:eac0369: 		{
1:eac0369: 			//System.out.println("Skipping Informix " + className);
1:eac0369: 		    return;
1:eac0369: 		}
1:eac0369: 		if (className.startsWith("com.ibm.mobileservices.") && skipDB2e)
1:eac0369: 		{
1:eac0369: 			//System.out.println("Skipping DB2e " + className);
1:eac0369: 		    return;
1:eac0369: 		}
1:eac0369: 		if (className.startsWith("common.") && skipDB2)
1:eac0369: 		{
1:eac0369: 			//System.out.println("Skipping DB2 common " + className);
1:eac0369: 		    return;
1:eac0369: 		}
1:eac0369: 
1:0163295:         if (!SanityManager.DEBUG &&
1:0163295:             className.matches("^org\\.apache\\.derby\\..*\\.sanity\\..*"))
1:0163295:         {
1:0163295:             // Don't include sanity classes in insane builds.
1:0163295:             return;
1:0163295:         }
1:0163295: 
1:eac0369:         if (ignoreWebLogic)
1:eac0369:         {
1:eac0369:             if (className.startsWith("weblogic."))
1:eac0369: 			{
1:eac0369:                 return;
1:eac0369: 			}
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (db2jtools || db2jdrda) {
1:eac0369: 
1:eac0369: 			// for tools skip classes that are part of the db2j product api
1:eac0369: 			// they should be pulled in from cs.jar or any client.jar
1:eac0369: 			if (
1:eac0369: 				   className.startsWith("org.apache.derby.authentication.")
1:eac0369: 				|| className.startsWith("org.apache.derby.catalog.")
1:eac0369: 				|| className.startsWith("org.apache.derby.iapi.db.")
1:eac0369: 				|| className.startsWith("org.apache.derby.diag.")
1:eac0369: 				|| className.startsWith("org.apache.derby.jdbc.")
1:eac0369: 				|| className.startsWith("org.apache.derby.vti.")
1:ea335da: 				|| className.startsWith("org.apache.derby.iapi.sql.dictionary.")
1:e081c85: 				|| className.startsWith("org.apache.derby.iapi.util.")
1:eac0369: 				)
1:eac0369: 			{
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// drda explicitly brings in some database engine classes.
1:27fbf33: 		// they must be picked up from derby.jar and not put in
1:eac0369: 		// the network server jar.
1:eac0369: 		if (db2jdrda) {
1:eac0369: 
1:eac0369: 			if (
1:eac0369: 				   className.startsWith("org.apache.derby.impl.sql")
1:eac0369: 				|| className.startsWith("org.apache.derby.impl.jdbc")
1:eac0369: 				|| className.startsWith("org.apache.derby.impl.services")
1:eac0369: 				|| className.startsWith("org.apache.derby.iapi.")
1:c0052e0: 				|| className.startsWith("org.apache.derby.security.")
1:27fbf33:                 || (className.startsWith("org.apache.derby.mbeans.") &&
1:27fbf33:                     !className.startsWith("org.apache.derby.mbeans.drda."))
1:eac0369: 				)
1:eac0369: 			{
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:     //
1:c491355:     // Exclude classes which are referenced only by the compiler
1:c491355:     // in order to copy constants into the target class. These were not recorded
1:c491355:     // in the constant pool by Java compilers at level 7 or earlier.
1:c491355:     // However, these started turning up under Windows with Java 8
1:c491355:     // after the base compilation level was changed to Java 8 by the work
1:c491355:     // on https://issues.apache.org/jira/browse/DERBY-6857. See that issue
1:c491355:     // for more information.
1:c491355:     //
1:c491355:     if (
1:c491355:         className.startsWith("org.apache.derby.iapi.reference.DRDAConstants") ||
1:c491355:         className.startsWith("org.apache.derby.shared.common.sanity.SanityState") ||
1:c491355:         className.startsWith("org.apache.derbyPreBuild.ReleaseProperties")
1:c491355:         )
1:c491355:     { return; }
1:c491355: 
1:eac0369: 		// already seen class
1:eac0369: 		if (foundClasses.get(className) != null)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (verbose) {
1:eac0369: 			for (int i =0; i < indent; i++)
1:eac0369: 			{
1:eac0369: 				System.out.print(".");
1:eac0369: 			}
1:eac0369: 			System.out.println(className);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			org.apache.derby.iapi.reference.ClassName &
1:eac0369: 			RegisteredFormatIds has a list of all registered classes, If we pull this in then
1:eac0369: 			we will pull in the complete set of classes. So we add this to our list but don't
1:eac0369: 			dependency check it.
1:eac0369: 		*/
1:eac0369: 		boolean dontCheckDependencies = false;
1:eac0369: 		/*
1:eac0369: 		if (className.equals("org.apache.derby.iapi.reference.ClassName") ||
1:eac0369: 			className.equals("org.apache.derby.iapi.services.io.RegisteredFormatIds")) {
1:eac0369: 			dontCheckDependencies = true;
1:eac0369: 		}
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:38b9499: 			Hashtable<String, String> localHashtable = null;
1:eac0369: 			
1:eac0369: 			if (keepDependencyHistory) {
1:38b9499: 				localHashtable = masterClassList.get(className);
1:eac0369: 				if (localHashtable == null)
1:eac0369: 				{
1:38b9499: 					localHashtable = new Hashtable<String, String>();
1:eac0369: 					masterClassList.put(className, localHashtable);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		    foundClasses.put(className, "class");
1:eac0369: 
1:eac0369: 			if (dontCheckDependencies)
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			String fileName = "/" + className.replace('.', '/') + ".class";
1:eac0369: 
1:eac0369: 			InputStream is = locateClass(fileName, false);
1:eac0369: 
1:eac0369: 			if (is == null) {
1:7cfb7e6: 
1:7cfb7e6:                 //
1:7cfb7e6:                 // Until there is a Java 8 whose stubs can be used to build Derby, we will allow
1:7cfb7e6:                 // the build to complete without the JDBC 4.2 support.
1:7cfb7e6:                 //
1:7cfb7e6:                 if ( className.endsWith( "Driver42" ) ) { return; }
1:7cfb7e6:                 
1:eac0369: 				pwOut.println("**error** Got NULL when looking for fileName = " + fileName);
1:eac0369: 				if (!keepRolling)
1:eac0369: 				{
1:eac0369: 					System.exit(1);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					errorCount++;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			//byte[] classData = new byte[is.available()];
1:eac0369: 			//is.read(classData);
1:eac0369: 
1:eac0369: 			ClassInvestigator ch = ClassInvestigator.load(is);
1:eac0369: 			is.close();
1:eac0369: 
1:eac0369: 		    for (Enumeration e = ch/*.getClassInfo()*/.referencedClasses(); e.hasMoreElements(); ) {
1:eac0369: 			    String x = (String) e.nextElement();
1:eac0369: 				// skip microsoft classes
1:eac0369: 				if (x.startsWith("com.ms."))
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:0163295: 				if (!SanityManager.DEBUG) {
1:eac0369: 					if (x.indexOf("SanityManager") != -1) {
1:eac0369: 
1:eac0369: 						boolean printSanityWarning = true;
1:eac0369: 
1:eac0369: 						int ld = className.lastIndexOf(".");
1:eac0369: 						if (ld != -1) {
1:eac0369: 							if (className.lastIndexOf("T_") == ld + 1)
1:eac0369: 								printSanityWarning = false;
1:eac0369: 							else if (className.lastIndexOf("T_") == ld + 1)
1:eac0369: 								printSanityWarning = false;
1:eac0369: 							else if (className.lastIndexOf("D_") == ld + 1)
1:eac0369: 								printSanityWarning = false;
1:eac0369: 							else if (className.lastIndexOf("TEST_") == ld + 1)
1:eac0369: 								printSanityWarning = false;
1:eac0369: 							else if (className.endsWith("SanityManager"))
1:eac0369: 								printSanityWarning = false;
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (printSanityWarning)
1:eac0369: 							System.out.println("SANITY >>> " + fileName);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (keepDependencyHistory && (localHashtable.get(x) == null))
1:eac0369: 				{
1:eac0369: 						
1:eac0369: 					localHashtable.put(x, "class");
1:eac0369: 				}
1:eac0369: 			    findDependencies(x);
1:eac0369:             }
1:eac0369: 		} 
1:eac0369:         catch (NullPointerException npe)
1:eac0369: 		{
1:eac0369: 			pwOut.println("**error** Got NullPointerException in findDependencies when looking up ");
1:eac0369: 			pwOut.println(className);
1:eac0369: 			
1:eac0369: 			npe.printStackTrace();
1:eac0369: 			if (!keepRolling)
1:eac0369: 			{
1:eac0369: 				System.exit(1);
1:eac0369: 			}
1:eac0369: 			errorCount++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// look for properties only with cloudscape code ...
1:eac0369: 		if (!isCloudscapeCode(className))
1:eac0369: 			return;
1:eac0369: 
1:17b031d:                 // The following block of code checks the package of each class
1:17b031d:                 // scanned to see if there is a corresponding properties file
1:17b031d:                 // from propFiles and adds it to the list of found classes.
1:17b031d:                 // derbytools.jar should not contain any of these files, so skip
1:17b031d:                 // for that jar. See also DERBY-1537.
1:17b031d:                 if (!db2jtools)
1:17b031d:                 {
1:eac0369: 		    String packageName = className.substring(0, className.lastIndexOf('.') + 1);
1:eac0369: 
1:eac0369: 		    for (int i = 0; i < propFiles.length; i++) {
1:eac0369: 			String fileName = "/" + packageName.replace('.', '/') + propFiles[i];
1:eac0369: 			if (foundClasses.get(fileName) != null)
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			InputStream is = getClass().getResourceAsStream(fileName);
1:eac0369: 			if (is == null)
1:eac0369: 				continue;
1:eac0369: 			is.close();
1:eac0369: 
1:eac0369: 
1:eac0369: 			foundClasses.put(fileName.substring(1), "file");
1:eac0369: 		    }
2:17b031d:                 }
1:eac0369:         } finally {
1:eac0369: 		indent--;
1:eac0369: 	}
1:eac0369: 	}
1:eac0369: 	protected boolean isCloudscapeCode(String name) {
1:eac0369: 		return name.startsWith("com.ibm.db2j.") ||
1:eac0369: 		       name.startsWith("com.ihost.cs.") ||
1:eac0369: 		       name.startsWith("db2j.") ||
1:eac0369: 		       name.startsWith("org.apache.derby");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void showAllItems()
1:eac0369: 	{
1:eac0369: 		Enumeration e = masterClassList.keys();
1:eac0369: 		pwOut.println("------------Printing all dependents--------------");
1:eac0369: 		while (e.hasMoreElements())
1:eac0369: 		{
1:eac0369: 			String kid = (String) e.nextElement();
1:eac0369: 			pwOut.println(kid );
1:38b9499: 			Hashtable<String, Integer> scoreboard =
1:38b9499:                     new Hashtable<String, Integer>();
1:38b9499: 			Hashtable<String, String> grandkids = masterClassList.get(kid);
1:eac0369: 			unrollHashtable("", grandkids, scoreboard, 1);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void showAllItemsOneLevel()
1:eac0369: 	{
1:eac0369: 		pwOut.println("Showing all dependencies");
1:eac0369: 		pwOut.println("One level only");
1:eac0369: 		pwOut.println("-----------------------------------");
1:eac0369: 		
1:eac0369: 		Enumeration e = masterClassList.keys();
1:eac0369: 		while (e.hasMoreElements())
1:eac0369: 		{
1:eac0369: 			String key = (String) e.nextElement();
1:eac0369: 			pwOut.println(key);
1:eac0369: 			Hashtable h = (Hashtable) masterClassList.get(key);
1:eac0369: 			Enumeration e2 = h.keys();
1:eac0369: 			Hashtable h2 = new Hashtable();
1:eac0369: 			while (e2.hasMoreElements())
1:eac0369: 			{
1:eac0369: 				String key2 = (String) e2.nextElement();
1:eac0369: 				pwOut.println("\t" + key2);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:38b9499: 	protected void unrollHashtable(
1:38b9499:             String parent,
1:38b9499:             Hashtable<String, String> current,
1:38b9499:             Hashtable<String, Integer> scoreboard,
1:38b9499:             int indentLevel)
1:eac0369: 	{
1:eac0369: 		String indentString = "  ";
1:38b9499: 		Enumeration<String> e = current.keys();
1:eac0369: 		String key = null;
1:eac0369:  
1:eac0369: 		while (e.hasMoreElements())
1:eac0369: 		{
1:38b9499: 			key = e.nextElement();
1:eac0369: 			if (key.equals(parent))
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 			pwOut.print(indentLevel + ":");
1:eac0369: 
1:38b9499: 			Integer value = scoreboard.get(key);
1:eac0369: 			if (value != null )
1:eac0369: 			{
1:eac0369: 				for (int i = 0; i < indentLevel; i++)
1:eac0369: 				{
1:eac0369: 					pwOut.print(indentString);
1:eac0369: 				}
1:eac0369: 				pwOut.println(key + "*****REPEATED class back at level " + value + "****");
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 			for (int i = 0; i < indentLevel; i++)
1:eac0369: 			{
1:eac0369: 				pwOut.print(indentString);
1:eac0369: 			}
1:eac0369: 			pwOut.println(key);
1:eac0369: 
1:38b9499: 			Hashtable<String, String> currentsChildren =
1:38b9499:                     masterClassList.get(key);
1:ce40a31: 	scoreboard.put(key, indentLevel);
1:eac0369: 			unrollHashtable(key, currentsChildren, scoreboard, (indentLevel+1));
1:ce40a31: 			scoreboard.put(key, indentLevel);
1:eac0369: 			
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 			
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 	scoreboard.put(key, indentLevel);
1: 			scoreboard.put(key, indentLevel);
commit:c491355
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // Exclude classes which are referenced only by the compiler
1:     // in order to copy constants into the target class. These were not recorded
1:     // in the constant pool by Java compilers at level 7 or earlier.
1:     // However, these started turning up under Windows with Java 8
1:     // after the base compilation level was changed to Java 8 by the work
1:     // on https://issues.apache.org/jira/browse/DERBY-6857. See that issue
1:     // for more information.
1:     //
1:     if (
1:         className.startsWith("org.apache.derby.iapi.reference.DRDAConstants") ||
1:         className.startsWith("org.apache.derby.shared.common.sanity.SanityState") ||
1:         className.startsWith("org.apache.derbyPreBuild.ReleaseProperties")
1:         )
1:     { return; }
1: 
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
1: 
1:                 //
1:                 // Until there is a Java 8 whose stubs can be used to build Derby, we will allow
1:                 // the build to complete without the JDBC 4.2 support.
1:                 //
1:                 if ( className.endsWith( "Driver42" ) ) { return; }
1:                 
commit:e081c85
/////////////////////////////////////////////////////////////////////////
1: 				|| className.startsWith("org.apache.derby.iapi.util.")
commit:ea335da
/////////////////////////////////////////////////////////////////////////
1: 				|| className.startsWith("org.apache.derby.iapi.sql.dictionary.")
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1: 		// they must be picked up from derby.jar and not put in
/////////////////////////////////////////////////////////////////////////
1:                 || (className.startsWith("org.apache.derby.mbeans.") &&
1:                     !className.startsWith("org.apache.derby.mbeans.drda."))
commit:0163295
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         if (!SanityManager.DEBUG &&
1:             className.matches("^org\\.apache\\.derby\\..*\\.sanity\\..*"))
1:         {
1:             // Don't include sanity classes in insane builds.
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 				if (!SanityManager.DEBUG) {
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1: 	protected Hashtable<String, String> foundClasses;
/////////////////////////////////////////////////////////////////////////
1: 	protected Hashtable<String, Hashtable<String, String>> masterClassList =
1:             new Hashtable<String, Hashtable<String, String>>();
1:     protected Hashtable<String, Object> classpathHash;
/////////////////////////////////////////////////////////////////////////
1: 		foundClasses = new Hashtable<String, String>(3000, 0.8f);
/////////////////////////////////////////////////////////////////////////
1:         classpathHash = new Hashtable<String, Object>();
/////////////////////////////////////////////////////////////////////////
1: 			Hashtable<String, String> localHashtable = null;
1: 				localHashtable = masterClassList.get(className);
1: 					localHashtable = new Hashtable<String, String>();
/////////////////////////////////////////////////////////////////////////
1: 			Hashtable<String, Integer> scoreboard =
1:                     new Hashtable<String, Integer>();
1: 			Hashtable<String, String> grandkids = masterClassList.get(kid);
/////////////////////////////////////////////////////////////////////////
1: 	protected void unrollHashtable(
1:             String parent,
1:             Hashtable<String, String> current,
1:             Hashtable<String, Integer> scoreboard,
1:             int indentLevel)
1: 		Enumeration<String> e = current.keys();
1: 			key = e.nextElement();
1: 			Integer value = scoreboard.get(key);
/////////////////////////////////////////////////////////////////////////
1: 			Hashtable<String, String> currentsChildren =
1:                     masterClassList.get(key);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c0052e0
/////////////////////////////////////////////////////////////////////////
1: 				|| className.startsWith("org.apache.derby.security.")
commit:cd3749b
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyBuild.classlister
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:50d75f3
/////////////////////////////////////////////////////////////////////////
1: public class classlister {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyBuild
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyBuild;
1: 
1: import org.apache.derby.iapi.services.classfile.*;
0: import org.apache.derby.iapi.util.ByteArray;
1: import java.util.*;
1: import java.util.zip.*;
1: import java.io.*;
1: 
1: import java.io.*;
1: 
1: /**
1: 
1: 	A tool that generates a list of required classes from a
1: 	set of properties files. The value of any property within a property
1: 	file that starts with 'derby.module.' is taken as a class name.
1: 	That class name and all the clases it requires are listed to
1: 	System.out, to facilitate building a zip file. Classes that
1: 	start with 'java.' or 'javax.' are not listed and are not
1: 	checked for dependent classes.
1: 	<P>
1: 	If the class name starts with 'com.ibm.db2j.' then a messages.properties
1: 	file is searched for corresponding to that class, if one exists then
1: 	is is added to the list of files printed.
1: 	<P>
1: 	The search path for the classes is $CLASSPATH
1: 	<P>
1: 	If the system property cloudscapeOnly is set to true then only classes
1: 	and message.properties files are listed that start with com.ibm.db2j.
1: 	<P>
1: 	The output for each class or properties file is a relative file
1: 	name that uses '/' as the file separator. e.g.
1: 
1: 	com/ibm/db2j/core/Setup.class
1: 
1:   <P>
1: 	The output order of the classes & files is random.
1:     <P>
1: 
1: 
1:     Usage: java [-DignoreWebLogic=true] [-Dverbose=true] [-DcloudscapeOnly=true] [-DruntimeOnly=true] 
1: 	[-Ddb2jtools=true]
1:     [-DportingOnly=true] [-Doutputfile=<filename>] org.apache.derbyBuild.classlister 
1:     property_file [ property_file ... ]
1: **/
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
1: 
1: 
0: public class classlister { private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	protected String[] sets;
0: 	protected Hashtable foundClasses;
1: 	//protected ClassUtilitiesFactory cuf;
1: 
1: 	protected boolean cloudscapeOnly = false;
1: 	protected boolean portingOnly = false;
1: 	protected boolean ignoreWebLogic = false;
1: 	protected boolean verbose = false;
1: 	protected boolean skipJava = true;
1: 	protected boolean skipJavax = true;
1: 	protected boolean skipOrg = true;
1: 	protected boolean skipInformix = true;
1: 	protected boolean skipDB2 = true;
1: 	protected boolean skipDB2e = true;
1:         protected boolean skipSun = true;
1: 	protected boolean showAll = false;
1: 	protected boolean keepRolling = false;
1: 	protected boolean showOne = false;
0: 	protected Hashtable masterClassList = new Hashtable();
1:     protected String classpath[] = null;
1:     protected String outputfile;
0:     protected Hashtable classpathHash;
1: 	protected int indent = 0;
1: 	protected int errorCount = 0;
1: 	protected PrintWriter pwOut;
1: 	protected PrintStream psOut;
1: 
1: 	protected boolean db2jtools;
1: 	protected boolean db2jdrda;
1: 
1: 	protected boolean keepDependencyHistory;
1: 
1: 	protected static final String[] propFiles = {
1: 		"messages.properties",
1: 		"instructions.properties",
1:                 "metadata.properties"
1: 	};
1: 
1: 	public static void main(String args[]) throws IOException {
1: 
1: 		classlister me = new classlister();
1: 
1: 		me.sets = args;
1: 
1: 		me.run();
1: 		if (me.errorCount > 0)
1: 		{
1: 			System.out.println(me.errorCount + " errors encountered.");
1: 			System.exit(1);
1: 		}
1: 	}
1: 
1: 	public classlister() {
1: 		cloudscapeOnly = Boolean.getBoolean("cloudscapeOnly");
1: 		portingOnly = Boolean.getBoolean("portingOnly");
1:         ignoreWebLogic = Boolean.getBoolean("ignoreWebLogic");
1:         verbose = Boolean.getBoolean("verbose");
1:         skipJava = ! Boolean.getBoolean("doJava");
1:         skipJavax = ! Boolean.getBoolean("doJavax");
1:         skipOrg = ! Boolean.getBoolean("doOrg");
1:         showAll = Boolean.getBoolean("showAll");
1:         showOne = Boolean.getBoolean("showOne");
1:         keepRolling = Boolean.getBoolean("keepRolling");
1:         outputfile = System.getProperty("outputfile");
1: 		db2jtools = Boolean.getBoolean("db2jtools");
1: 		db2jdrda = Boolean.getBoolean("db2jdrda");
1: 
1: 		keepDependencyHistory = showOne || showAll;
1: 	}
1: 
1: 	public void run() 
1: 	{
1: 		//System.out.println("outputfile: " + outputfile);
1: 		try
1: 		{
1: 		    File outFile = new File(outputfile);
1: 		    pwOut = new PrintWriter( new BufferedWriter
1:                 (new FileWriter(outFile.getPath()), 10000), true );
1:         }
1:         catch (IOException ioe)
1:         {
1:             System.out.println(ioe);
1:             System.exit(1);
1:         }
1: 	    
1: 		loadClasspath();
1: 		//cuf = new ModifyClasses();
1: 
0: 		foundClasses = new Hashtable(3000, 0.8f);  
1: 		
1: 		for (int i = 0; i < sets.length; i++) 
1: 		{
1: 
1: 			// If a set name ends in '.class' then take it as a class
1: 			// name of the form com.acme.foo.MyClass.class.
1: 			try 
1: 			{
1: 
1: 				String s = sets[i];
1: 
1: 				if (s.endsWith(".class")) {
1: 
1: 					findDependencies(s.substring(0, s.length() - 6));
1: 				} else {
1: 
1: 					FileInputStream fis = new FileInputStream(s);
1: 
1: 					Properties pset = new Properties();
1: 
1: 					pset.load(fis);
1: 
1: 					findClasses(pset);
1: 				}
1: 
1: 			} 
1: 			catch (IOException ioe) 
1: 			{
1: 				System.err.println(ioe.toString());
1: 				System.exit(1);
1: 			}
1: 		}
1:         if (pwOut == null)
1:         {
1:             System.out.println("Need to specify an outputfile");
1:             System.exit(1);
1:         }
1: 		for (Enumeration e = foundClasses.keys(); e.hasMoreElements(); ) {
1: 			String name = (String) e.nextElement();
1: 			String type = (String) foundClasses.get(name);
1: 			if (type.equals("class")) {
1:                 if (ignoreWebLogic) {
1:                     if (name.startsWith("weblogic")) {
1:                         continue;
1:                     }
1:                 }
1: 
1: 
1: 				if (isCloudscapeCode(name)) {
1: 
1: 					if (name.startsWith("com.ibm.db2j.porting.")) {
1: 						if (cloudscapeOnly)
1: 							continue;
1: 					} else {
1: 						if (portingOnly)
1: 							continue;
1: 					}
1: 
1: 				} else {
1: 					if (cloudscapeOnly || portingOnly)
1: 						continue;
1: 				}
1: 				pwOut.println(name.replace('.', '/') + ".class");
1: 			}
1: 			else {
1: 				// is a file name
1: 				if (name.startsWith("com/ibm/db2j/")) {
1: 					if (portingOnly) {
1: 						continue;
1: 					}
1: 				} else {
1: 					if (cloudscapeOnly || portingOnly)
1: 						continue;
1: 				}
1: 
1: 				pwOut.println(name);
1: 			}
1: 		}
1: 		if (showAll)
1: 		{
1: 			showAllItems();
1: 		}
1: 		if (showOne)
1: 		{
1: 			showAllItemsOneLevel();
1: 		}
1: 	}
1: 
1: 
1: 	protected void findClasses(Properties pset) throws IOException {
1: 
1: 		for (Enumeration e = pset.propertyNames(); e.hasMoreElements(); ) {
1: 			String key = (String) e.nextElement();
1: 			if (key.startsWith("derby.module.")) {
1: 				if (verbose) {
1: 					pwOut.println(pset.getProperty(key) + " needs ");
1: 				}
1: 				findDependencies(pset.getProperty(key));
1: 			}
1: 		}
1: 	}
1: 
1:     protected void loadClasspath()
1:     {
0:         classpathHash = new Hashtable();
1:             try
1:             {
1:                 String classpathString = System.getProperty("java.class.path");
1: 				if (verbose)
1: 					pwOut.println("classpath: " + classpathString);
1:                 StringTokenizer st = new StringTokenizer(classpathString, File.pathSeparator);
1:                 int entries = st.countTokens();
1:                 classpath = new String[entries];
1:                 for (int i = 0; i < entries; i++)
1:                 {
1:                     classpath[i] = st.nextToken();
1:                 }
1:             }
1:             catch (SecurityException se)
1:             {
1:                 pwOut.println("**error** SecurityException getting classpath");
1:                 System.exit(1);
1:             }
1:         for (int i = 0; i < classpath.length; i++)
1:         {
1:             String pathEntry = classpath[i];
1:             if (pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".ZIP") ||
1:                 pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".JAR") )
1:             {
1:                 ZipFile zipfile = null;
1:                 try
1:                 {
1:                     zipfile = new ZipFile(pathEntry.replace('/', File.separatorChar));
1:                 }
1:                 catch (IOException ioe)
1:                 {
1:                     // can't do anything about it; zipfile doesn't exists
1:                     // it can happen if the person sticks a directory called
1:                     // foo.zip in the classpath or foo.zip doesn't exist as
1:                     // a file
1:                 }
1:                 if (zipfile != null)
1:                 {
1: 
1:                     classpathHash.put(pathEntry, zipfile);
1:                 }
1:                 else
1:                 {
1: 					if (verbose)
1: 					{
1: 	                    pwOut.println("Ignoring <zip> entry: " + pathEntry);
1: 					}
1: 	
1:                 }
1:             }
1:             else
1:             {
1:                 File file = new File(pathEntry);
1: 
1:                 if (file.exists() && file.isDirectory())
1:                 {
1:                     classpathHash.put(pathEntry, file);
1:                 }
1:                 else
1:                 {
1:                    	if (verbose)
1: 					{ 
1:                     	pwOut.println("Ignoring <dir> entry: " + pathEntry);
1: 					}
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     protected InputStream locateClass(String className, boolean beVerbose)
1:     {
1:         if (className.startsWith("/"))
1:         {
1:             className = className.substring(1);
1:         }
1:         if (beVerbose)
1:         {
1:             pwOut.println("Looking for " + className);
1:         }
1: 
1:         if (classpath == null)
1:         {
1:             loadClasspath();
1:         }
1: 
1:         for (int i = 0; i < classpath.length; i++)
1:         {
1:             String pathEntry = classpath[i];
1:             Object hash = classpathHash.get(pathEntry);
1:             if (hash != null)
1:             {
1:                 if (hash instanceof ZipFile)
1:                 try
1:                 {
1:                     ZipFile zipfile = (ZipFile) hash;
1: 
1:                     ZipEntry entry = zipfile.getEntry(className);
1: 
1:                     if (entry != null)
1:                     {
1:                         InputStream is = zipfile.getInputStream(entry);
1:                         DataInputStream dis= new DataInputStream(new BufferedInputStream(is));
1:                         return dis;
1:                     }
1:                 }
1:                 catch (IOException ioe)
1:                 {
1:                     if (beVerbose)
1:                     {
1:                         pwOut.println("IOException loading ZipFile or creating InputStream " +
1:                             " from it");
1:                         pwOut.println(ioe);
1:                     }
1:                 }
1:                 else if (hash instanceof File)
1:                 {
1:                     File file = new File((File)hash, className.replace('/', File.separatorChar));
1:                     if (beVerbose)
1:                     {
1:                         pwOut.println("looking to load file: " + file.getName());
1:                     }
1:                     if (file.exists())
1:                     {
1:                         if (beVerbose)
1:                         {
1:                             pwOut.println(" found it!");
1:                         }
1:                         try
1:                         {
1:                             FileInputStream fis = new FileInputStream(file);
1:                             return new BufferedInputStream(fis, 8192);
1:                         }
1:                         catch (IOException ioe)
1:                         {
1:                             if (beVerbose)
1:                             {
1:                                 pwOut.println("IOException creating FileInputStream");
1:                                 pwOut.println(ioe);
1:                                 return null;
1:                             }
1:                         }
1:                     }
1:                 }
1:             }
1:             //
1:         }
1: 
1:         // could not find it
1:         if (beVerbose)
1:         {
1:             pwOut.println("returing null on purpose");
1:         }
1:         return null;
1:     }
1: 
1: 	protected void findDependencies(String className) throws IOException {
1: 		indent++;
1: 		try {
1: 		if (className.startsWith("java.") && skipJava)
1: 		{
1: 			pwOut.println("Skipping JAVA " + className);
1: 			return;
1: 		}
1: 		if (className.startsWith("javax.") && skipJavax)
1: 		{
1: 			//System.out.println("Skipping JAVAX " + className);
1: 		    return;
1: 		}
1:                 if (className.startsWith("sun.") && skipSun)
1:                 {
1:                         //System.out.println("Skipping Sun " + className);
1:                     return;
1:                 }
1: 		if (className.startsWith("org.") && skipOrg)
1: 		{
1: 		    // Allow opensource org.apache.derby classes
1:                     if (!className.startsWith("org.apache.derby")) 
1: 		    {
1: 			//System.out.println("Skipping org " + className);
1: 			return;
1: 		    }
1: 		}
1: 		if (className.startsWith("com.informix.") && skipInformix)
1: 		{
1: 			//System.out.println("Skipping Informix " + className);
1: 		    return;
1: 		}
1: 		if (className.startsWith("com.ibm.mobileservices.") && skipDB2e)
1: 		{
1: 			//System.out.println("Skipping DB2e " + className);
1: 		    return;
1: 		}
1: 		if (className.startsWith("common.") && skipDB2)
1: 		{
1: 			//System.out.println("Skipping DB2 common " + className);
1: 		    return;
1: 		}
1: 
1:         if (ignoreWebLogic)
1:         {
1:             if (className.startsWith("weblogic."))
1: 			{
1:                 return;
1: 			}
1:         }
1: 
1: 		if (db2jtools || db2jdrda) {
1: 
1: 			// for tools skip classes that are part of the db2j product api
1: 			// they should be pulled in from cs.jar or any client.jar
1: 			if (
1: 				   className.startsWith("org.apache.derby.authentication.")
1: 				|| className.startsWith("org.apache.derby.catalog.")
1: 				|| className.startsWith("org.apache.derby.iapi.db.")
1: 				|| className.startsWith("org.apache.derby.diag.")
1: 				|| className.startsWith("org.apache.derby.jdbc.")
1: 				|| className.startsWith("org.apache.derby.vti.")
1: 				)
1: 			{
1: 				return;
1: 			}
1: 		}
1: 
1: 		// drda explicitly brings in some database engine classes.
0: 		// they must be picke dup from cs.jar and not put in
1: 		// the network server jar.
1: 		if (db2jdrda) {
1: 
1: 			if (
1: 				   className.startsWith("org.apache.derby.impl.sql")
1: 				|| className.startsWith("org.apache.derby.impl.jdbc")
1: 				|| className.startsWith("org.apache.derby.impl.services")
1: 				|| className.startsWith("org.apache.derby.iapi.")
1: 				)
1: 			{
1: 				return;
1: 			}
1: 		}
1: 
1: 		// already seen class
1: 		if (foundClasses.get(className) != null)
1: 			return;
1: 
1: 		if (verbose) {
1: 			for (int i =0; i < indent; i++)
1: 			{
1: 				System.out.print(".");
1: 			}
1: 			System.out.println(className);
1: 		}
1: 
1: 		/*
1: 			org.apache.derby.iapi.reference.ClassName &
1: 			RegisteredFormatIds has a list of all registered classes, If we pull this in then
1: 			we will pull in the complete set of classes. So we add this to our list but don't
1: 			dependency check it.
1: 		*/
1: 		boolean dontCheckDependencies = false;
1: 		/*
1: 		if (className.equals("org.apache.derby.iapi.reference.ClassName") ||
1: 			className.equals("org.apache.derby.iapi.services.io.RegisteredFormatIds")) {
1: 			dontCheckDependencies = true;
1: 		}
1: 		*/
1: 
1: 
1: 
1:         try
1:         {
0: 			Hashtable localHashtable = null;
1: 			
1: 			if (keepDependencyHistory) {
0: 				localHashtable = (Hashtable) masterClassList.get(className);
1: 				if (localHashtable == null)
1: 				{
0: 					localHashtable = new Hashtable();
1: 					masterClassList.put(className, localHashtable);
1: 				}
1: 			}
1: 
1: 		    foundClasses.put(className, "class");
1: 
1: 			if (dontCheckDependencies)
1: 				return;
1: 
1: 			String fileName = "/" + className.replace('.', '/') + ".class";
1: 
1: 			InputStream is = locateClass(fileName, false);
1: 
1: 			if (is == null) {
1: 				pwOut.println("**error** Got NULL when looking for fileName = " + fileName);
1: 				if (!keepRolling)
1: 				{
1: 					System.exit(1);
1: 				}
1: 				else
1: 				{
1: 					errorCount++;
1: 				}
1: 			}
1: 			//byte[] classData = new byte[is.available()];
1: 			//is.read(classData);
1: 
1: 			ClassInvestigator ch = ClassInvestigator.load(is);
1: 			is.close();
1: 
1: 		    for (Enumeration e = ch/*.getClassInfo()*/.referencedClasses(); e.hasMoreElements(); ) {
1: 			    String x = (String) e.nextElement();
1: 				// skip microsoft classes
1: 				if (x.startsWith("com.ms."))
1: 				{
1: 					continue;
1: 				}
1: 
0: 				if (!org.apache.derby.iapi.services.sanity.SanityManager.DEBUG) {
1: 					if (x.indexOf("SanityManager") != -1) {
1: 
1: 						boolean printSanityWarning = true;
1: 
1: 						int ld = className.lastIndexOf(".");
1: 						if (ld != -1) {
1: 							if (className.lastIndexOf("T_") == ld + 1)
1: 								printSanityWarning = false;
1: 							else if (className.lastIndexOf("T_") == ld + 1)
1: 								printSanityWarning = false;
1: 							else if (className.lastIndexOf("D_") == ld + 1)
1: 								printSanityWarning = false;
1: 							else if (className.lastIndexOf("TEST_") == ld + 1)
1: 								printSanityWarning = false;
1: 							else if (className.endsWith("SanityManager"))
1: 								printSanityWarning = false;
1: 						}
1: 
1: 						if (printSanityWarning)
1: 							System.out.println("SANITY >>> " + fileName);
1: 					}
1: 				}
1: 
1: 				if (keepDependencyHistory && (localHashtable.get(x) == null))
1: 				{
1: 						
1: 					localHashtable.put(x, "class");
1: 				}
1: 			    findDependencies(x);
1:             }
1: 		} 
1:         catch (NullPointerException npe)
1: 		{
1: 			pwOut.println("**error** Got NullPointerException in findDependencies when looking up ");
1: 			pwOut.println(className);
1: 			
1: 			npe.printStackTrace();
1: 			if (!keepRolling)
1: 			{
1: 				System.exit(1);
1: 			}
1: 			errorCount++;
1: 		}
1: 
1: 		// look for properties only with cloudscape code ...
1: 		if (!isCloudscapeCode(className))
1: 			return;
1: 
1: 		String packageName = className.substring(0, className.lastIndexOf('.') + 1);
1: 
1: 		for (int i = 0; i < propFiles.length; i++) {
1: 			String fileName = "/" + packageName.replace('.', '/') + propFiles[i];
1: 			if (foundClasses.get(fileName) != null)
1: 				continue;
1: 
1: 			InputStream is = getClass().getResourceAsStream(fileName);
1: 			if (is == null)
1: 				continue;
1: 			is.close();
1: 
1: 
1: 			foundClasses.put(fileName.substring(1), "file");
1: 		}
1: } finally {
1: 		indent--;
1: 	}
1: 	}
1: 	protected boolean isCloudscapeCode(String name) {
1: 		return name.startsWith("com.ibm.db2j.") ||
1: 		       name.startsWith("com.ihost.cs.") ||
1: 		       name.startsWith("db2j.") ||
1: 		       name.startsWith("org.apache.derby");
1: 	}
1: 
1: 
1: 	protected void showAllItems()
1: 	{
1: 		Enumeration e = masterClassList.keys();
1: 		pwOut.println("------------Printing all dependents--------------");
1: 		while (e.hasMoreElements())
1: 		{
1: 			String kid = (String) e.nextElement();
1: 			pwOut.println(kid );
0: 			Hashtable scoreboard = new Hashtable();
0: 			Hashtable grandkids = (Hashtable) masterClassList.get(kid);
1: 			unrollHashtable("", grandkids, scoreboard, 1);
1: 		}
1: 	}
1: 
1: 
1: 	protected void showAllItemsOneLevel()
1: 	{
1: 		pwOut.println("Showing all dependencies");
1: 		pwOut.println("One level only");
1: 		pwOut.println("-----------------------------------");
1: 		
1: 		Enumeration e = masterClassList.keys();
1: 		while (e.hasMoreElements())
1: 		{
1: 			String key = (String) e.nextElement();
1: 			pwOut.println(key);
1: 			Hashtable h = (Hashtable) masterClassList.get(key);
1: 			Enumeration e2 = h.keys();
1: 			Hashtable h2 = new Hashtable();
1: 			while (e2.hasMoreElements())
1: 			{
1: 				String key2 = (String) e2.nextElement();
1: 				pwOut.println("\t" + key2);
1: 			}
1: 		}
1: 	}
1: 
1: 
0: 	protected void unrollHashtable( String parent, Hashtable current, Hashtable scoreboard, int indentLevel)
1: 	{
1: 		String indentString = "  ";
0: 		Enumeration e = current.keys();
1: 		String key = null;
1:  
1: 		while (e.hasMoreElements())
1: 		{
0: 			key = (String) e.nextElement();
1: 			if (key.equals(parent))
1: 			{
1: 				continue;
1: 			}
1: 			pwOut.print(indentLevel + ":");
1: 
0: 			Integer value = (Integer) scoreboard.get(key);
1: 			if (value != null )
1: 			{
1: 				for (int i = 0; i < indentLevel; i++)
1: 				{
1: 					pwOut.print(indentString);
1: 				}
1: 				pwOut.println(key + "*****REPEATED class back at level " + value + "****");
1: 				return;
1: 			}
1: 			for (int i = 0; i < indentLevel; i++)
1: 			{
1: 				pwOut.print(indentString);
1: 			}
1: 			pwOut.println(key);
1: 
0: 			Hashtable currentsChildren = (Hashtable) masterClassList.get(key);
0: 	scoreboard.put(key, new Integer(indentLevel));
1: 			unrollHashtable(key, currentsChildren, scoreboard, (indentLevel+1));
0: 			scoreboard.put(key, new Integer(indentLevel));
1: 			
1: 		}
1: 	}
1: 			
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:de243e0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:17b031d
/////////////////////////////////////////////////////////////////////////
1:                 // The following block of code checks the package of each class
1:                 // scanned to see if there is a corresponding properties file
1:                 // from propFiles and adds it to the list of found classes.
1:                 // derbytools.jar should not contain any of these files, so skip
1:                 // for that jar. See also DERBY-1537.
1:                 if (!db2jtools)
1:                 {
0: 		    String packageName = className.substring(0, className.lastIndexOf('.') + 1);
0: 		    for (int i = 0; i < propFiles.length; i++) {
/////////////////////////////////////////////////////////////////////////
1: 		    }
1:                 }
0:         } finally {
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyBuild
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derbyBuild;
0: 
0: import org.apache.derby.iapi.services.classfile.*;
0: import org.apache.derby.iapi.util.ByteArray;
0: import java.util.*;
0: import java.util.zip.*;
0: import java.io.*;
0: 
0: import java.io.*;
0: 
0: /**
0: 
0: 	A tool that generates a list of required classes from a
0: 	set of properties files. The value of any property within a property
0: 	file that starts with 'derby.module.' is taken as a class name.
0: 	That class name and all the clases it requires are listed to
0: 	System.out, to facilitate building a zip file. Classes that
0: 	start with 'java.' or 'javax.' are not listed and are not
0: 	checked for dependent classes.
0: 	<P>
0: 	If the class name starts with 'com.ibm.db2j.' then a messages.properties
0: 	file is searched for corresponding to that class, if one exists then
0: 	is is added to the list of files printed.
0: 	<P>
0: 	The search path for the classes is $CLASSPATH
0: 	<P>
0: 	If the system property cloudscapeOnly is set to true then only classes
0: 	and message.properties files are listed that start with com.ibm.db2j.
0: 	<P>
0: 	The output for each class or properties file is a relative file
0: 	name that uses '/' as the file separator. e.g.
0: 
0: 	com/ibm/db2j/core/Setup.class
0: 
0:   <P>
0: 	The output order of the classes & files is random.
0:     <P>
0: 
0: 
0:     Usage: java [-DignoreWebLogic=true] [-Dverbose=true] [-DcloudscapeOnly=true] [-DruntimeOnly=true] 
0: 	[-Ddb2jtools=true]
0:     [-DportingOnly=true] [-Doutputfile=<filename>] org.apache.derbyBuild.classlister 
0:     property_file [ property_file ... ]
0: **/
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 
0: 
0: public class classlister { private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	protected String[] sets;
0: 	protected Hashtable foundClasses;
0: 	//protected ClassUtilitiesFactory cuf;
0: 
0: 	protected boolean cloudscapeOnly = false;
0: 	protected boolean portingOnly = false;
0: 	protected boolean ignoreWebLogic = false;
0: 	protected boolean verbose = false;
0: 	protected boolean skipJava = true;
0: 	protected boolean skipJavax = true;
0: 	protected boolean skipOrg = true;
0: 	protected boolean skipInformix = true;
0: 	protected boolean skipDB2 = true;
0: 	protected boolean skipDB2e = true;
0:         protected boolean skipSun = true;
0: 	protected boolean showAll = false;
0: 	protected boolean keepRolling = false;
0: 	protected boolean showOne = false;
0: 	protected Hashtable masterClassList = new Hashtable();
0:     protected String classpath[] = null;
0:     protected String outputfile;
0:     protected Hashtable classpathHash;
0: 	protected int indent = 0;
0: 	protected int errorCount = 0;
0: 	protected PrintWriter pwOut;
0: 	protected PrintStream psOut;
0: 
0: 	protected boolean db2jtools;
0: 	protected boolean db2jdrda;
0: 
0: 	protected boolean keepDependencyHistory;
0: 
0: 	protected static final String[] propFiles = {
0: 		"messages.properties",
0: 		"instructions.properties",
0:                 "metadata.properties"
0: 	};
0: 
0: 	public static void main(String args[]) throws IOException {
0: 
0: 		classlister me = new classlister();
0: 
0: 		me.sets = args;
0: 
0: 		me.run();
0: 		if (me.errorCount > 0)
0: 		{
0: 			System.out.println(me.errorCount + " errors encountered.");
0: 			System.exit(1);
0: 		}
0: 	}
0: 
0: 	public classlister() {
0: 		cloudscapeOnly = Boolean.getBoolean("cloudscapeOnly");
0: 		portingOnly = Boolean.getBoolean("portingOnly");
0:         ignoreWebLogic = Boolean.getBoolean("ignoreWebLogic");
0:         verbose = Boolean.getBoolean("verbose");
0:         skipJava = ! Boolean.getBoolean("doJava");
0:         skipJavax = ! Boolean.getBoolean("doJavax");
0:         skipOrg = ! Boolean.getBoolean("doOrg");
0:         showAll = Boolean.getBoolean("showAll");
0:         showOne = Boolean.getBoolean("showOne");
0:         keepRolling = Boolean.getBoolean("keepRolling");
0:         outputfile = System.getProperty("outputfile");
0: 		db2jtools = Boolean.getBoolean("db2jtools");
0: 		db2jdrda = Boolean.getBoolean("db2jdrda");
0: 
0: 		keepDependencyHistory = showOne || showAll;
0: 	}
0: 
0: 	public void run() 
0: 	{
0: 		//System.out.println("outputfile: " + outputfile);
0: 		try
0: 		{
0: 		    File outFile = new File(outputfile);
0: 		    pwOut = new PrintWriter( new BufferedWriter
0:                 (new FileWriter(outFile.getPath()), 10000), true );
0:         }
0:         catch (IOException ioe)
0:         {
0:             System.out.println(ioe);
0:             System.exit(1);
0:         }
0: 	    
0: 		loadClasspath();
0: 		//cuf = new ModifyClasses();
0: 
0: 		foundClasses = new Hashtable(3000, 0.8f);  
0: 		
0: 		for (int i = 0; i < sets.length; i++) 
0: 		{
0: 
0: 			// If a set name ends in '.class' then take it as a class
0: 			// name of the form com.acme.foo.MyClass.class.
0: 			try 
0: 			{
0: 
0: 				String s = sets[i];
0: 
0: 				if (s.endsWith(".class")) {
0: 
0: 					findDependencies(s.substring(0, s.length() - 6));
0: 				} else {
0: 
0: 					FileInputStream fis = new FileInputStream(s);
0: 
0: 					Properties pset = new Properties();
0: 
0: 					pset.load(fis);
0: 
0: 					findClasses(pset);
0: 				}
0: 
0: 			} 
0: 			catch (IOException ioe) 
0: 			{
0: 				System.err.println(ioe.toString());
0: 				System.exit(1);
0: 			}
0: 		}
0:         if (pwOut == null)
0:         {
0:             System.out.println("Need to specify an outputfile");
0:             System.exit(1);
0:         }
0: 		for (Enumeration e = foundClasses.keys(); e.hasMoreElements(); ) {
0: 			String name = (String) e.nextElement();
0: 			String type = (String) foundClasses.get(name);
0: 			if (type.equals("class")) {
0:                 if (ignoreWebLogic) {
0:                     if (name.startsWith("weblogic")) {
0:                         continue;
0:                     }
0:                 }
0: 
0: 
0: 				if (isCloudscapeCode(name)) {
0: 
0: 					if (name.startsWith("com.ibm.db2j.porting.")) {
0: 						if (cloudscapeOnly)
0: 							continue;
0: 					} else {
0: 						if (portingOnly)
0: 							continue;
0: 					}
0: 
0: 				} else {
0: 					if (cloudscapeOnly || portingOnly)
0: 						continue;
0: 				}
0: 				pwOut.println(name.replace('.', '/') + ".class");
0: 			}
0: 			else {
0: 				// is a file name
0: 				if (name.startsWith("com/ibm/db2j/")) {
0: 					if (portingOnly) {
0: 						continue;
0: 					}
0: 				} else {
0: 					if (cloudscapeOnly || portingOnly)
0: 						continue;
0: 				}
0: 
0: 				pwOut.println(name);
0: 			}
0: 		}
0: 		if (showAll)
0: 		{
0: 			showAllItems();
0: 		}
0: 		if (showOne)
0: 		{
0: 			showAllItemsOneLevel();
0: 		}
0: 	}
0: 
0: 
0: 	protected void findClasses(Properties pset) throws IOException {
0: 
0: 		for (Enumeration e = pset.propertyNames(); e.hasMoreElements(); ) {
0: 			String key = (String) e.nextElement();
0: 			if (key.startsWith("derby.module.")) {
0: 				if (verbose) {
0: 					pwOut.println(pset.getProperty(key) + " needs ");
0: 				}
0: 				findDependencies(pset.getProperty(key));
0: 			}
0: 		}
0: 	}
0: 
0:     protected void loadClasspath()
0:     {
0:         classpathHash = new Hashtable();
0:             try
0:             {
0:                 String classpathString = System.getProperty("java.class.path");
0: 				if (verbose)
0: 					pwOut.println("classpath: " + classpathString);
0:                 StringTokenizer st = new StringTokenizer(classpathString, File.pathSeparator);
0:                 int entries = st.countTokens();
0:                 classpath = new String[entries];
0:                 for (int i = 0; i < entries; i++)
0:                 {
0:                     classpath[i] = st.nextToken();
0:                 }
0:             }
0:             catch (SecurityException se)
0:             {
0:                 pwOut.println("**error** SecurityException getting classpath");
0:                 System.exit(1);
0:             }
0:         for (int i = 0; i < classpath.length; i++)
0:         {
0:             String pathEntry = classpath[i];
0:             if (pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".ZIP") ||
0:                 pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".JAR") )
0:             {
0:                 ZipFile zipfile = null;
0:                 try
0:                 {
0:                     zipfile = new ZipFile(pathEntry.replace('/', File.separatorChar));
0:                 }
0:                 catch (IOException ioe)
0:                 {
0:                     // can't do anything about it; zipfile doesn't exists
0:                     // it can happen if the person sticks a directory called
0:                     // foo.zip in the classpath or foo.zip doesn't exist as
0:                     // a file
0:                 }
0:                 if (zipfile != null)
0:                 {
0: 
0:                     classpathHash.put(pathEntry, zipfile);
0:                 }
0:                 else
0:                 {
0: 					if (verbose)
0: 					{
0: 	                    pwOut.println("Ignoring <zip> entry: " + pathEntry);
0: 					}
0: 	
0:                 }
0:             }
0:             else
0:             {
0:                 File file = new File(pathEntry);
0: 
0:                 if (file.exists() && file.isDirectory())
0:                 {
0:                     classpathHash.put(pathEntry, file);
0:                 }
0:                 else
0:                 {
0:                    	if (verbose)
0: 					{ 
0:                     	pwOut.println("Ignoring <dir> entry: " + pathEntry);
0: 					}
0:                 }
0:             }
0:         }
0:     }
0: 
0: 
0:     protected InputStream locateClass(String className, boolean beVerbose)
0:     {
0:         if (className.startsWith("/"))
0:         {
0:             className = className.substring(1);
0:         }
0:         if (beVerbose)
0:         {
0:             pwOut.println("Looking for " + className);
0:         }
0: 
0:         if (classpath == null)
0:         {
0:             loadClasspath();
0:         }
0: 
0:         for (int i = 0; i < classpath.length; i++)
0:         {
0:             String pathEntry = classpath[i];
0:             Object hash = classpathHash.get(pathEntry);
0:             if (hash != null)
0:             {
0:                 if (hash instanceof ZipFile)
0:                 try
0:                 {
0:                     ZipFile zipfile = (ZipFile) hash;
0: 
0:                     ZipEntry entry = zipfile.getEntry(className);
0: 
0:                     if (entry != null)
0:                     {
0:                         InputStream is = zipfile.getInputStream(entry);
0:                         DataInputStream dis= new DataInputStream(new BufferedInputStream(is));
0:                         return dis;
0:                     }
0:                 }
0:                 catch (IOException ioe)
0:                 {
0:                     if (beVerbose)
0:                     {
0:                         pwOut.println("IOException loading ZipFile or creating InputStream " +
0:                             " from it");
0:                         pwOut.println(ioe);
0:                     }
0:                 }
0:                 else if (hash instanceof File)
0:                 {
0:                     File file = new File((File)hash, className.replace('/', File.separatorChar));
0:                     if (beVerbose)
0:                     {
0:                         pwOut.println("looking to load file: " + file.getName());
0:                     }
0:                     if (file.exists())
0:                     {
0:                         if (beVerbose)
0:                         {
0:                             pwOut.println(" found it!");
0:                         }
0:                         try
0:                         {
0:                             FileInputStream fis = new FileInputStream(file);
0:                             return new BufferedInputStream(fis, 8192);
0:                         }
0:                         catch (IOException ioe)
0:                         {
0:                             if (beVerbose)
0:                             {
0:                                 pwOut.println("IOException creating FileInputStream");
0:                                 pwOut.println(ioe);
0:                                 return null;
0:                             }
0:                         }
0:                     }
0:                 }
0:             }
0:             //
0:         }
0: 
0:         // could not find it
0:         if (beVerbose)
0:         {
0:             pwOut.println("returing null on purpose");
0:         }
0:         return null;
0:     }
0: 
0: 	protected void findDependencies(String className) throws IOException {
0: 		indent++;
0: 		try {
0: 		if (className.startsWith("java.") && skipJava)
0: 		{
0: 			pwOut.println("Skipping JAVA " + className);
0: 			return;
0: 		}
0: 		if (className.startsWith("javax.") && skipJavax)
0: 		{
0: 			//System.out.println("Skipping JAVAX " + className);
0: 		    return;
0: 		}
0:                 if (className.startsWith("sun.") && skipSun)
0:                 {
0:                         //System.out.println("Skipping Sun " + className);
0:                     return;
0:                 }
0: 		if (className.startsWith("org.") && skipOrg)
0: 		{
0: 		    // Allow opensource org.apache.derby classes
0:                     if (!className.startsWith("org.apache.derby")) 
0: 		    {
0: 			//System.out.println("Skipping org " + className);
0: 			return;
0: 		    }
0: 		}
0: 		if (className.startsWith("com.informix.") && skipInformix)
0: 		{
0: 			//System.out.println("Skipping Informix " + className);
0: 		    return;
0: 		}
0: 		if (className.startsWith("com.ibm.mobileservices.") && skipDB2e)
0: 		{
0: 			//System.out.println("Skipping DB2e " + className);
0: 		    return;
0: 		}
0: 		if (className.startsWith("common.") && skipDB2)
0: 		{
0: 			//System.out.println("Skipping DB2 common " + className);
0: 		    return;
0: 		}
0: 
0:         if (ignoreWebLogic)
0:         {
0:             if (className.startsWith("weblogic."))
0: 			{
0:                 return;
0: 			}
0:         }
0: 
0: 		if (db2jtools || db2jdrda) {
0: 
0: 			// for tools skip classes that are part of the db2j product api
0: 			// they should be pulled in from cs.jar or any client.jar
0: 			if (
0: 				   className.startsWith("org.apache.derby.authentication.")
0: 				|| className.startsWith("org.apache.derby.catalog.")
0: 				|| className.startsWith("org.apache.derby.iapi.db.")
0: 				|| className.startsWith("org.apache.derby.diag.")
0: 				|| className.startsWith("org.apache.derby.jdbc.")
0: 				|| className.startsWith("org.apache.derby.vti.")
0: 				)
0: 			{
0: 				return;
0: 			}
0: 		}
0: 
0: 		// drda explicitly brings in some database engine classes.
0: 		// they must be picke dup from cs.jar and not put in
0: 		// the network server jar.
0: 		if (db2jdrda) {
0: 
0: 			if (
0: 				   className.startsWith("org.apache.derby.impl.sql")
0: 				|| className.startsWith("org.apache.derby.impl.jdbc")
0: 				|| className.startsWith("org.apache.derby.impl.services")
0: 				|| className.startsWith("org.apache.derby.iapi.")
0: 				)
0: 			{
0: 				return;
0: 			}
0: 		}
0: 
0: 		// already seen class
0: 		if (foundClasses.get(className) != null)
0: 			return;
0: 
0: 		if (verbose) {
0: 			for (int i =0; i < indent; i++)
0: 			{
0: 				System.out.print(".");
0: 			}
0: 			System.out.println(className);
0: 		}
0: 
0: 		/*
0: 			org.apache.derby.iapi.reference.ClassName &
0: 			RegisteredFormatIds has a list of all registered classes, If we pull this in then
0: 			we will pull in the complete set of classes. So we add this to our list but don't
0: 			dependency check it.
0: 		*/
0: 		boolean dontCheckDependencies = false;
0: 		/*
0: 		if (className.equals("org.apache.derby.iapi.reference.ClassName") ||
0: 			className.equals("org.apache.derby.iapi.services.io.RegisteredFormatIds")) {
0: 			dontCheckDependencies = true;
0: 		}
0: 		*/
0: 
0: 
0: 
0:         try
0:         {
0: 			Hashtable localHashtable = null;
0: 			
0: 			if (keepDependencyHistory) {
0: 				localHashtable = (Hashtable) masterClassList.get(className);
0: 				if (localHashtable == null)
0: 				{
0: 					localHashtable = new Hashtable();
0: 					masterClassList.put(className, localHashtable);
0: 				}
0: 			}
0: 
0: 		    foundClasses.put(className, "class");
0: 
0: 			if (dontCheckDependencies)
0: 				return;
0: 
0: 			String fileName = "/" + className.replace('.', '/') + ".class";
0: 
0: 			InputStream is = locateClass(fileName, false);
0: 
0: 			if (is == null) {
0: 				pwOut.println("**error** Got NULL when looking for fileName = " + fileName);
0: 				if (!keepRolling)
0: 				{
0: 					System.exit(1);
0: 				}
0: 				else
0: 				{
0: 					errorCount++;
0: 				}
0: 			}
0: 			//byte[] classData = new byte[is.available()];
0: 			//is.read(classData);
0: 
0: 			ClassInvestigator ch = ClassInvestigator.load(is);
0: 			is.close();
0: 
0: 		    for (Enumeration e = ch/*.getClassInfo()*/.referencedClasses(); e.hasMoreElements(); ) {
0: 			    String x = (String) e.nextElement();
0: 				// skip microsoft classes
0: 				if (x.startsWith("com.ms."))
0: 				{
0: 					continue;
0: 				}
0: 
0: 				if (!org.apache.derby.iapi.services.sanity.SanityManager.DEBUG) {
0: 					if (x.indexOf("SanityManager") != -1) {
0: 
0: 						boolean printSanityWarning = true;
0: 
0: 						int ld = className.lastIndexOf(".");
0: 						if (ld != -1) {
0: 							if (className.lastIndexOf("T_") == ld + 1)
0: 								printSanityWarning = false;
0: 							else if (className.lastIndexOf("T_") == ld + 1)
0: 								printSanityWarning = false;
0: 							else if (className.lastIndexOf("D_") == ld + 1)
0: 								printSanityWarning = false;
0: 							else if (className.lastIndexOf("TEST_") == ld + 1)
0: 								printSanityWarning = false;
0: 							else if (className.endsWith("SanityManager"))
0: 								printSanityWarning = false;
0: 						}
0: 
0: 						if (printSanityWarning)
0: 							System.out.println("SANITY >>> " + fileName);
0: 					}
0: 				}
0: 
0: 				if (keepDependencyHistory && (localHashtable.get(x) == null))
0: 				{
0: 						
0: 					localHashtable.put(x, "class");
0: 				}
0: 			    findDependencies(x);
0:             }
0: 		} 
0:         catch (NullPointerException npe)
0: 		{
0: 			pwOut.println("**error** Got NullPointerException in findDependencies when looking up ");
0: 			pwOut.println(className);
0: 			
0: 			npe.printStackTrace();
0: 			if (!keepRolling)
0: 			{
0: 				System.exit(1);
0: 			}
0: 			errorCount++;
0: 		}
0: 
0: 		// look for properties only with cloudscape code ...
0: 		if (!isCloudscapeCode(className))
0: 			return;
0: 
0: 		String packageName = className.substring(0, className.lastIndexOf('.') + 1);
0: 
0: 		for (int i = 0; i < propFiles.length; i++) {
0: 			String fileName = "/" + packageName.replace('.', '/') + propFiles[i];
0: 			if (foundClasses.get(fileName) != null)
0: 				continue;
0: 
0: 			InputStream is = getClass().getResourceAsStream(fileName);
0: 			if (is == null)
0: 				continue;
0: 			is.close();
0: 
0: 
0: 			foundClasses.put(fileName.substring(1), "file");
0: 		}
0: } finally {
0: 		indent--;
0: 	}
0: 	}
0: 	protected boolean isCloudscapeCode(String name) {
0: 		return name.startsWith("com.ibm.db2j.") ||
0: 		       name.startsWith("com.ihost.cs.") ||
0: 		       name.startsWith("db2j.") ||
0: 		       name.startsWith("org.apache.derby");
0: 	}
0: 
0: 
0: 	protected void showAllItems()
0: 	{
0: 		Enumeration e = masterClassList.keys();
0: 		pwOut.println("------------Printing all dependents--------------");
0: 		while (e.hasMoreElements())
0: 		{
0: 			String kid = (String) e.nextElement();
0: 			pwOut.println(kid );
0: 			Hashtable scoreboard = new Hashtable();
0: 			Hashtable grandkids = (Hashtable) masterClassList.get(kid);
0: 			unrollHashtable("", grandkids, scoreboard, 1);
0: 		}
0: 	}
0: 
0: 
0: 	protected void showAllItemsOneLevel()
0: 	{
0: 		pwOut.println("Showing all dependencies");
0: 		pwOut.println("One level only");
0: 		pwOut.println("-----------------------------------");
0: 		
0: 		Enumeration e = masterClassList.keys();
0: 		while (e.hasMoreElements())
0: 		{
0: 			String key = (String) e.nextElement();
0: 			pwOut.println(key);
0: 			Hashtable h = (Hashtable) masterClassList.get(key);
0: 			Enumeration e2 = h.keys();
0: 			Hashtable h2 = new Hashtable();
0: 			while (e2.hasMoreElements())
0: 			{
0: 				String key2 = (String) e2.nextElement();
0: 				pwOut.println("\t" + key2);
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	protected void unrollHashtable( String parent, Hashtable current, Hashtable scoreboard, int indentLevel)
0: 	{
0: 		String indentString = "  ";
0: 		Enumeration e = current.keys();
0: 		String key = null;
0:  
0: 		while (e.hasMoreElements())
0: 		{
0: 			key = (String) e.nextElement();
0: 			if (key.equals(parent))
0: 			{
0: 				continue;
0: 			}
0: 			pwOut.print(indentLevel + ":");
0: 
0: 			Integer value = (Integer) scoreboard.get(key);
0: 			if (value != null )
0: 			{
0: 				for (int i = 0; i < indentLevel; i++)
0: 				{
0: 					pwOut.print(indentString);
0: 				}
0: 				pwOut.println(key + "*****REPEATED class back at level " + value + "****");
0: 				return;
0: 			}
0: 			for (int i = 0; i < indentLevel; i++)
0: 			{
0: 				pwOut.print(indentString);
0: 			}
0: 			pwOut.println(key);
0: 
0: 			Hashtable currentsChildren = (Hashtable) masterClassList.get(key);
0: 	scoreboard.put(key, new Integer(indentLevel));
0: 			unrollHashtable(key, currentsChildren, scoreboard, (indentLevel+1));
0: 			scoreboard.put(key, new Integer(indentLevel));
0: 			
0: 		}
0: 	}
0: 			
0: 
0: }
============================================================================