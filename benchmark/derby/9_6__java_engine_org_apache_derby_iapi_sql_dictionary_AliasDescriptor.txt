1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.AliasDescriptor
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:4112e91: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:4112e91: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:2209325: import org.apache.derby.iapi.sql.depend.Dependent;
1:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
1:4112e91: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:2209325: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import	org.apache.derby.catalog.AliasInfo;
1:22d64f5: import	org.apache.derby.catalog.types.AggregateAliasInfo;
1:4aef9b0: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:98c7520: import	org.apache.derby.catalog.types.UDTAliasInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.AliasInfo;
1:eac0369: import	org.apache.derby.catalog.DependableFinder;
1:eac0369: import	org.apache.derby.catalog.Dependable;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:e96b5a2: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This class represents an Alias Descriptor. 
1:eac0369:  * The public methods for this class are:
1:eac0369:  * 
1:eac0369:  * <ol>
1:eac0369:  * <li>getUUID</li>
1:eac0369:  * <li>getJavaClassName</li>
1:eac0369:  * <li>getAliasType</li>
1:eac0369:  * <li>getNameSpace</li>
1:eac0369:  * <li>getSystemAlias</li>
1:eac0369:  * <li>getAliasId</li>
1:eac0369:  * </ol>
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class AliasDescriptor 
1:f2fad75: 	extends PrivilegedSQLObject
1:f2fad75: 	implements Provider, Dependent
1:eac0369: {
1:4eece41: 	private final UUID		aliasID;
1:4eece41: 	private final String		aliasName;
1:4eece41: 	private final UUID		schemaID;
1:4eece41: 	private final String		javaClassName;
1:4eece41: 	private final char		aliasType;
1:4eece41: 	private final char		nameSpace;
1:4eece41: 	private final boolean		systemAlias;
1:4eece41: 	private final AliasInfo	aliasInfo;
1:4eece41: 	private final String		specificName;
1:98c7520:     private final SchemaDescriptor schemaDescriptor;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a AliasDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1:eac0369: 	 * @param aliasID				The UUID for this alias
1:eac0369: 	 * @param aliasName				The name of the method alias
1:eac0369: 	 * @param schemaID				The UUID for this alias's schema
1:eac0369: 	 * @param javaClassName			The java class name of the alias
1:eac0369: 	 * @param aliasType				The alias type
1:eac0369: 	 * @param nameSpace				The alias name space
1:eac0369: 	 * @param aliasInfo				The AliasInfo for the alias
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public	AliasDescriptor( DataDictionary dataDictionary, UUID aliasID,
1:eac0369: 							  String aliasName, UUID schemaID, String javaClassName,
1:eac0369: 							  char aliasType, char nameSpace, boolean systemAlias,
1:eac0369: 							  AliasInfo aliasInfo, String specificName)
1:98c7520:         throws StandardException
1:eac0369: 	{
1:eac0369: 		super( dataDictionary );
1:eac0369: 
1:eac0369: 		this.aliasID = aliasID;
1:eac0369: 		this.aliasName = aliasName;
1:eac0369: 		this.schemaID = schemaID;
1:98c7520: 		this.schemaDescriptor = dataDictionary.getSchemaDescriptor(schemaID, null);
1:eac0369: 		this.javaClassName = javaClassName;
1:eac0369: 		this.aliasType = aliasType;
1:eac0369: 		this.nameSpace = nameSpace;
1:eac0369: 		this.systemAlias = systemAlias;
1:eac0369: 		this.aliasInfo = aliasInfo;
1:eac0369: 		if (specificName == null)
1:eac0369: 			specificName = dataDictionary.getSystemSQLName();
1:eac0369: 		this.specificName = specificName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// Interface methods
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the UUID  of the method alias.
1:eac0369: 	 *
1:eac0369: 	 * @return	The UUID String of the method alias.
1:eac0369: 	 */
1:eac0369: 	public UUID getUUID()
1:eac0369: 	{
1:eac0369: 		return aliasID;
1:eac0369: 	}
1:eac0369: 
1:98c7520:    /**
1:98c7520: 	 * @see PrivilegedSQLObject#getObjectTypeName
1:98c7520: 	 */
1:98c7520: 	public String getObjectTypeName()
1:98c7520: 	{
1:98c7520:         if ( aliasInfo instanceof UDTAliasInfo )
1:98c7520:         {
1:98c7520:             return PermDescriptor.UDT_TYPE;
1:98c7520:         }
1:22d64f5:         else if ( aliasInfo instanceof AggregateAliasInfo )
1:22d64f5:         {
1:22d64f5:             return PermDescriptor.AGGREGATE_TYPE;
1:22d64f5:         }
1:98c7520:         else
1:98c7520:         {
1:98c7520:             if( SanityManager.DEBUG)
1:98c7520:             {
1:98c7520:                 SanityManager.THROWASSERT( "Unsupported alias type: " + aliasInfo.getClass().getName() );
1:98c7520:             }
1:98c7520: 
1:98c7520:             return null;  // should never get here
1:98c7520:         }
1:98c7520: 	}
1:98c7520: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the UUID  of the schema for this method alias.
1:eac0369: 	 *
1:eac0369: 	 * @return	The UUID String of the schema id.
1:eac0369: 	 */
1:eac0369: 	public UUID getSchemaUUID()
1:eac0369: 	{
1:eac0369: 		return schemaID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:98c7520: 	 * Gets the SchemaDescriptor for this alias.
1:98c7520: 	 *
1:98c7520: 	 * @return SchemaDescriptor	The SchemaDescriptor.
1:98c7520: 	 */
1:98c7520: 	public final SchemaDescriptor getSchemaDescriptor()
1:98c7520: 	{
1:98c7520: 		return schemaDescriptor;
1:98c7520: 	}
1:98c7520: 
1:98c7520: 	/**
1:98c7520: 	 * Gets the name of the alias.
1:98c7520: 	 *
1:98c7520: 	 * @return	A String containing the name of the statement.
1:98c7520: 	 */
1:98c7520: 	public final String	getName()
1:98c7520: 	{
1:98c7520: 		return aliasName;
1:98c7520: 	}
1:98c7520: 
1:98c7520: 	/**
1:2209325: 	 * Gets the name of the schema that the alias lives in.
1:2209325: 	 *
1:2209325: 	 * @return	A String containing the name of the schema that the alias
1:2209325: 	 *		lives in.
1:2209325: 	 */
1:3d1bc57: 	public String getSchemaName()
1:2209325: 	{
1:98c7520: 		return schemaDescriptor.getSchemaName();
1:2209325: 	}
1:2209325: 
1:2209325: 	/**
1:2209325: 	 * Gets the full, qualified name of the alias.
1:2209325: 	 *
1:2209325: 	 * @return	A String containing the name of the table.
1:2209325: 	 */
1:3d1bc57: 	public String getQualifiedName()
1:2209325: 	{
1:e96b5a2:         return IdUtil.mkQualifiedName(getSchemaName(), aliasName);
1:2209325: 	}
1:2209325: 
1:2209325: 	/**
1:eac0369: 	 * Gets the java class name of the alias.
1:eac0369: 	 *
1:eac0369: 	 * @return	The java class name of the alias.
1:eac0369: 	 */
1:eac0369: 	public String getJavaClassName()
1:eac0369: 	{
1:eac0369: 		return javaClassName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the type of the alias.
1:eac0369: 	 *
1:eac0369: 	 * @return The type of the alias.
1:eac0369: 	 */
1:eac0369: 	public char getAliasType()
1:eac0369: 	{
1:eac0369: 		return aliasType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the name space of the alias.
1:eac0369: 	 *
1:eac0369: 	 * @return The name space of the alias.
1:eac0369: 	 */
1:eac0369: 	public char getNameSpace()
1:eac0369: 	{
1:eac0369: 		return nameSpace;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets whether or not the alias is a system alias.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the alias is a system alias.
1:eac0369: 	 */
1:eac0369: 	public boolean getSystemAlias()
1:eac0369: 	{
1:eac0369: 		return systemAlias;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gests the AliasInfo for the alias.
1:eac0369: 	 *
1:eac0369: 	 * @return	The AliasInfo for the alias.
1:eac0369: 	 */
1:eac0369: 	public AliasInfo getAliasInfo()
1:eac0369: 	{
1:eac0369: 		return aliasInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: //  	/**
1:eac0369: //  	 * Sets the ID of the method alias
1:eac0369: //  	 *
1:eac0369: //  	 * @param aliasID	The UUID of the method alias to be set in the descriptor
1:eac0369: //  	 *
1:eac0369: //  	 * @return	Nothing
1:eac0369: //  	 */
1:eac0369: //  	public void setAliasID(UUID aliasID)
1:eac0369: //  	{
1:eac0369: //  		this.aliasID = aliasID;
1:eac0369: //  	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert the AliasDescriptor to a String.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String representation of this AliasDescriptor
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public String	toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "aliasID: " + aliasID + "\n" +
1:eac0369: 				"aliasName: " + aliasName + "\n" +
1:eac0369: 				"schemaID: " + schemaID + "\n" +
1:eac0369: 				"javaClassName: " + javaClassName + "\n" +
1:eac0369: 				"aliasType: " + aliasType + "\n" +
1:eac0369: 				"nameSpace: " + nameSpace + "\n" +
1:eac0369: 				"systemAlias: " + systemAlias + "\n" +
1:eac0369: 				"aliasInfo: " + aliasInfo + "\n";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//	Methods so that we can put AliasDescriptors on hashed lists
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Determine if two AliasDescriptors are the same.
1:eac0369: 	  *
1:eac0369: 	  *	@param	otherObject	other descriptor
1:eac0369: 	  *
1:eac0369: 	  *	@return	true if they are the same, false otherwise
1:eac0369: 	  */
1:eac0369: 
1:eac0369: 	public boolean equals(Object otherObject)
1:eac0369: 	{
1:eac0369: 		if (!(otherObject instanceof AliasDescriptor))
1:eac0369: 		{	return false; }
1:eac0369: 
1:eac0369: 		AliasDescriptor other = (AliasDescriptor) otherObject;
1:eac0369: 
1:eac0369: 		return aliasID.equals( other.getUUID() );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get a hashcode for this AliasDescriptor
1:eac0369: 	  *
1:eac0369: 	  *	@return	hashcode
1:eac0369: 	  */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		return	aliasID.hashCode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Provider interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 		@return the stored form of this provider
1:eac0369: 			representation
1:eac0369: 
1:eac0369: 			@see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public DependableFinder getDependableFinder()
1:eac0369: 	{
1:eac0369: 	    return	getDependableFinder(StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Provider.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this provider.
1:eac0369: 	 */
1:eac0369: 	public String getObjectName()
1:eac0369: 	{
1:eac0369: 		return aliasName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's UUID
1:eac0369: 	 *
1:eac0369: 	 * @return String	The provider's UUID
1:eac0369: 	 */
1:eac0369: 	public UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return aliasID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's type.
1:eac0369: 	 *
1:eac0369: 	 * @return String		The provider's type.
1:eac0369: 	 */
1:eac0369: 	public String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.ALIAS;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see TupleDescriptor#getDescriptorType */
1:eac0369: 	public String getDescriptorType()
1:eac0369: 	{
1:582425f: 		return getAliasType(aliasType);
1:582425f: 	}
1:eac0369: 	
1:582425f: 	public static final String getAliasType(char nameSpace)
1:eac0369: 	{
1:582425f: 		switch (nameSpace)
1:582425f: 		{
1:eac0369: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1:eac0369: 				return "PROCEDURE";
1:eac0369: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1:eac0369: 				return "FUNCTION";
1:582425f: 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1:582425f: 				return "SYNONYM";
1:fa292b9: 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1:fa292b9: 				return "TYPE";
1:22d64f5: 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:22d64f5: 				return "DERBY AGGREGATE";
1:eac0369: 		}
1:eac0369: 		return  null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see TupleDescriptor#getDescriptorName */
1:eac0369: 	public String getDescriptorName()
1:eac0369: 	{
1:eac0369: 		return aliasName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the specific name for this object.
1:eac0369: 	*/
1:eac0369: 	public String getSpecificName()
1:eac0369: 	{
1:eac0369: 		return specificName;
1:eac0369: 	}
1:13d4456:     
1:13d4456:     /**
1:13d4456:      * Functions are persistent unless they are in the SYSFUN schema.
1:13d4456:      *
1:13d4456:      */
1:13d4456:     public boolean isPersistent()
1:13d4456:     {
1:13d4456:         return !getSchemaUUID().toString().equals(SchemaDescriptor.SYSFUN_SCHEMA_UUID);
1:13d4456:     }
1:4112e91:    
1:4112e91:     /**
1:4aef9b0:      * Report whether this descriptor describes a Table Function.
1:4aef9b0:      *
1:4aef9b0:      */
1:4aef9b0:     public boolean isTableFunction()
1:4aef9b0:     {
1:4aef9b0:         if ( getAliasType() != AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ) { return false; }
1:4aef9b0: 
1:4aef9b0:         RoutineAliasInfo    rai = (RoutineAliasInfo) getAliasInfo();
1:4aef9b0: 
1:4aef9b0:         return rai.getReturnType().isRowMultiSet();
1:4aef9b0:     }
1:4aef9b0:    
1:4aef9b0:     /**
1:4112e91:      * Drop the routine or synonym.
1:4112e91:      * For a routine its permission descriptors will be dropped as well.
1:4112e91:      * For a synonym its TableDescriptor will be dropped as well.
1:4112e91:      * @param lcc
1:4112e91:      * @throws StandardException
1:4112e91:      */
1:4112e91:     public void drop(LanguageConnectionContext lcc) throws StandardException {
1:4112e91:         
1:4112e91:         DataDictionary dd = getDataDictionary();
1:4112e91:         TransactionController tc = lcc.getTransactionExecute();
1:4112e91:         DependencyManager dm = dd.getDependencyManager();
1:4112e91:         
1:4112e91:         
1:4112e91:         /* Prepare all dependents to invalidate.  (This is their chance
1:4112e91:          * to say that they can't be invalidated.  For example, an open
1:4112e91:          * cursor referencing a table/view that the user is attempting to
1:4112e91:          * drop.) If no one objects, then invalidate any dependent objects.
1:4112e91:          * We check for invalidation before we drop the descriptor
1:4112e91:          * since the descriptor may be looked up as part of
1:4112e91:          * decoding tuples in SYSDEPENDS.
1:4112e91:          */
1:4112e91:         int invalidationType = 0;
1:4112e91:         switch (getAliasType())
1:4112e91:         {
1:4112e91:         case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1:4112e91:         case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1:4112e91:             invalidationType = DependencyManager.DROP_METHOD_ALIAS;
1:4112e91:             break;
1:4112e91:             
1:4112e91:         case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1:4112e91:             invalidationType = DependencyManager.DROP_SYNONYM;
1:4112e91:             break;
1:e126f58:             
1:e126f58:         case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1:e126f58:             invalidationType = DependencyManager.DROP_UDT;
1:e126f58:             break;
1:22d64f5:             
1:22d64f5:         case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:22d64f5:             invalidationType = DependencyManager.DROP_AGGREGATE;
1:22d64f5:             break;
1:4112e91:         }
1:4112e91:         
1:4112e91:         dm.invalidateFor(this, invalidationType, lcc);
1:4112e91:         
1:4112e91:         if (getAliasType() == AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
1:4112e91:         {
1:4112e91:             SchemaDescriptor sd = dd.getSchemaDescriptor(schemaID, tc);
1:4112e91:             
1:4112e91:             // Drop the entry from SYSTABLES as well.
1:4112e91:             DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1:4112e91:             TableDescriptor td = ddg.newTableDescriptor(aliasName, sd,
1:4112e91:                     TableDescriptor.SYNONYM_TYPE, TableDescriptor.DEFAULT_LOCK_GRANULARITY);
1:4112e91:             dd.dropTableDescriptor(td, sd, tc);
1:4112e91:         }
1:4112e91:         else
1:4112e91:             dd.dropAllRoutinePermDescriptors(getUUID(), tc);
1:4112e91:         
1:4112e91:         /* Drop the alias */
1:4112e91:         dd.dropAliasDescriptor(this, tc);
1:4112e91:     }
1:2209325: 
1:2209325: 	//////////////////////////////////////////////////////
1:2209325: 	//
1:2209325: 	// DEPENDENT INTERFACE
1:2209325: 	//
1:2209325: 	//////////////////////////////////////////////////////
1:2209325: 	/**
1:2209325: 	 * Check that all of the dependent's dependencies are valid.
1:2209325: 	 *
1:2209325: 	 * @return true if the dependent is currently valid
1:2209325: 	 */
1:2209325: 	public synchronized boolean isValid()
1:2209325: 	{
1:2209325: 		return true;
1:2209325: 	}
1:2209325: 
1:2209325: 	/**
1:2209325: 	 * Prepare to mark the dependent as invalid (due to at least one of
1:2209325: 	 * its dependencies being invalid).
1:2209325: 	 *
1:2209325: 	 * @param action	The action causing the invalidation
1:2209325: 	 * @param p		the provider
1:2209325: 	 *
1:2209325: 	 * @exception StandardException thrown if unable to make it invalid
1:2209325: 	 */
1:2209325: 	public void prepareToInvalidate(Provider p, int action,
1:2209325: 					LanguageConnectionContext lcc) 
1:2209325: 		throws StandardException
1:2209325: 	{
1:2209325: 		DependencyManager dm = getDataDictionary().getDependencyManager();
1:2209325: 
1:2209325: 		switch (action)
1:2209325: 		{
1:2209325: 			/*
1:2209325: 			** Currently, the only thing we are dependent
1:2209325: 			** on is an alias descriptor for an ANSI UDT.
1:2209325: 			*/
1:2209325: 		    default:
1:2209325: 
1:2209325: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_ALIAS, 
1:2209325: 									dm.getActionString(action), 
1:2209325: 									p.getObjectName(),
1:2209325: 									getQualifiedName());
1:2209325: 		}
1:2209325: 	}
1:2209325: 
1:2209325: 	/**
1:2209325: 	 * Mark the dependent as invalid (due to at least one of
1:2209325: 	 * its dependencies being invalid).  Always an error
1:2209325: 	 * for an alias -- should never have gotten here.
1:2209325: 	 *
1:2209325: 	 * @param	action	The action causing the invalidation
1:2209325: 	 *
1:2209325: 	 * @exception StandardException thrown if called in sanity mode
1:2209325: 	 */
1:2209325: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1:2209325: 		throws StandardException
1:2209325: 	{
1:2209325: 		/* 
1:2209325: 		** We should never get here, we should have barfed on 
1:2209325: 		** prepareToInvalidate().
1:2209325: 		*/
1:2209325: 		if (SanityManager.DEBUG)
1:2209325: 		{
1:2209325: 			DependencyManager dm;
1:2209325: 	
1:2209325: 			dm = getDataDictionary().getDependencyManager();
1:2209325: 
1:2209325: 			SanityManager.THROWASSERT("makeInvalid("+
1:2209325: 				dm.getActionString(action)+
1:2209325: 				") not expected to get called");
1:2209325: 		}
1:2209325: 	}
1:2209325:     
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1: 	extends PrivilegedSQLObject
1: 	implements Provider, Dependent
commit:22d64f5
/////////////////////////////////////////////////////////////////////////
1: import	org.apache.derby.catalog.types.AggregateAliasInfo;
/////////////////////////////////////////////////////////////////////////
1:         else if ( aliasInfo instanceof AggregateAliasInfo )
1:         {
1:             return PermDescriptor.AGGREGATE_TYPE;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1: 				return "DERBY AGGREGATE";
/////////////////////////////////////////////////////////////////////////
1:             
1:         case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:             invalidationType = DependencyManager.DROP_AGGREGATE;
1:             break;
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1: import	org.apache.derby.catalog.types.UDTAliasInfo;
/////////////////////////////////////////////////////////////////////////
0: 	implements PrivilegedSQLObject, Provider, Dependent
/////////////////////////////////////////////////////////////////////////
1:     private final SchemaDescriptor schemaDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
1: 		this.schemaDescriptor = dataDictionary.getSchemaDescriptor(schemaID, null);
/////////////////////////////////////////////////////////////////////////
1:    /**
1: 	 * @see PrivilegedSQLObject#getObjectTypeName
1: 	 */
1: 	public String getObjectTypeName()
1: 	{
1:         if ( aliasInfo instanceof UDTAliasInfo )
1:         {
1:             return PermDescriptor.UDT_TYPE;
1:         }
1:         else
1:         {
1:             if( SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT( "Unsupported alias type: " + aliasInfo.getClass().getName() );
1:             }
1: 
1:             return null;  // should never get here
1:         }
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Gets the SchemaDescriptor for this alias.
1: 	 *
1: 	 * @return SchemaDescriptor	The SchemaDescriptor.
1: 	 */
1: 	public final SchemaDescriptor getSchemaDescriptor()
1: 	{
1: 		return schemaDescriptor;
1: 	}
1: 
1: 	/**
1: 	 * Gets the name of the alias.
1: 	 *
1: 	 * @return	A String containing the name of the statement.
1: 	 */
1: 	public final String	getName()
1: 	{
1: 		return aliasName;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		return schemaDescriptor.getSchemaName();
commit:2209325
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0: 	implements UniqueTupleDescriptor, Provider, Dependent
/////////////////////////////////////////////////////////////////////////
1: 	 * Gets the name of the schema that the alias lives in.
1: 	 *
1: 	 * @return	A String containing the name of the schema that the alias
1: 	 *		lives in.
1: 	 */
0: 	public String	getSchemaName() throws StandardException
1: 	{
0: 		return getDataDictionary().getSchemaDescriptor( schemaID, null ).getSchemaName();
1: 	}
1: 
1: 	/**
1: 	 * Gets the full, qualified name of the alias.
1: 	 *
1: 	 * @return	A String containing the name of the table.
1: 	 */
0: 	public String	getQualifiedName() throws StandardException
1: 	{
0: 		return quoteProtectName(getSchemaName()) + "." +
0: 			quoteProtectName( aliasName );
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// DEPENDENT INTERFACE
1: 	//
1: 	//////////////////////////////////////////////////////
1: 	/**
1: 	 * Check that all of the dependent's dependencies are valid.
1: 	 *
1: 	 * @return true if the dependent is currently valid
1: 	 */
1: 	public synchronized boolean isValid()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Prepare to mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).
1: 	 *
1: 	 * @param action	The action causing the invalidation
1: 	 * @param p		the provider
1: 	 *
1: 	 * @exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action,
1: 					LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		DependencyManager dm = getDataDictionary().getDependencyManager();
1: 
1: 		switch (action)
1: 		{
1: 			/*
1: 			** Currently, the only thing we are dependent
1: 			** on is an alias descriptor for an ANSI UDT.
1: 			*/
1: 		    default:
1: 
1: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_ALIAS, 
1: 									dm.getActionString(action), 
1: 									p.getObjectName(),
1: 									getQualifiedName());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).  Always an error
1: 	 * for an alias -- should never have gotten here.
1: 	 *
1: 	 * @param	action	The action causing the invalidation
1: 	 *
1: 	 * @exception StandardException thrown if called in sanity mode
1: 	 */
1: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		/* 
1: 		** We should never get here, we should have barfed on 
1: 		** prepareToInvalidate().
1: 		*/
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			DependencyManager dm;
1: 	
1: 			dm = getDataDictionary().getDependencyManager();
1: 
1: 			SanityManager.THROWASSERT("makeInvalid("+
1: 				dm.getActionString(action)+
1: 				") not expected to get called");
1: 		}
1: 	}
1:     
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1:             
1:         case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1:             invalidationType = DependencyManager.DROP_UDT;
1:             break;
commit:fa292b9
/////////////////////////////////////////////////////////////////////////
1: 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1: 				return "TYPE";
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
/////////////////////////////////////////////////////////////////////////
1:      * Report whether this descriptor describes a Table Function.
1:      *
1:      */
1:     public boolean isTableFunction()
1:     {
1:         if ( getAliasType() != AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ) { return false; }
1: 
1:         RoutineAliasInfo    rai = (RoutineAliasInfo) getAliasInfo();
1: 
1:         return rai.getReturnType().isRowMultiSet();
1:     }
1:    
1:     /**
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3d1bc57
/////////////////////////////////////////////////////////////////////////
1: 	public String getSchemaName()
/////////////////////////////////////////////////////////////////////////
1: 	public String getQualifiedName()
commit:e96b5a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1:         return IdUtil.mkQualifiedName(getSchemaName(), aliasName);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4112e91
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1:    
1:     /**
1:      * Drop the routine or synonym.
1:      * For a routine its permission descriptors will be dropped as well.
1:      * For a synonym its TableDescriptor will be dropped as well.
1:      * @param lcc
1:      * @throws StandardException
1:      */
1:     public void drop(LanguageConnectionContext lcc) throws StandardException {
1:         
1:         DataDictionary dd = getDataDictionary();
1:         TransactionController tc = lcc.getTransactionExecute();
1:         DependencyManager dm = dd.getDependencyManager();
1:         
1:         
1:         /* Prepare all dependents to invalidate.  (This is their chance
1:          * to say that they can't be invalidated.  For example, an open
1:          * cursor referencing a table/view that the user is attempting to
1:          * drop.) If no one objects, then invalidate any dependent objects.
1:          * We check for invalidation before we drop the descriptor
1:          * since the descriptor may be looked up as part of
1:          * decoding tuples in SYSDEPENDS.
1:          */
1:         int invalidationType = 0;
1:         switch (getAliasType())
1:         {
1:         case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1:         case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1:             invalidationType = DependencyManager.DROP_METHOD_ALIAS;
1:             break;
1:             
1:         case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1:             invalidationType = DependencyManager.DROP_SYNONYM;
1:             break;
1:         }
1:         
1:         dm.invalidateFor(this, invalidationType, lcc);
1:         
1:         if (getAliasType() == AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
1:         {
1:             SchemaDescriptor sd = dd.getSchemaDescriptor(schemaID, tc);
1:             
1:             // Drop the entry from SYSTABLES as well.
1:             DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1:             TableDescriptor td = ddg.newTableDescriptor(aliasName, sd,
1:                     TableDescriptor.SYNONYM_TYPE, TableDescriptor.DEFAULT_LOCK_GRANULARITY);
1:             dd.dropTableDescriptor(td, sd, tc);
1:         }
1:         else
1:             dd.dropAllRoutinePermDescriptors(getUUID(), tc);
1:         
1:         /* Drop the alias */
1:         dd.dropAliasDescriptor(this, tc);
1:     }
commit:13d4456
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Functions are persistent unless they are in the SYSFUN schema.
1:      *
1:      */
1:     public boolean isPersistent()
1:     {
1:         return !getSchemaUUID().toString().equals(SchemaDescriptor.SYSFUN_SCHEMA_UUID);
1:     }
commit:4eece41
/////////////////////////////////////////////////////////////////////////
1: 	private final UUID		aliasID;
1: 	private final String		aliasName;
1: 	private final UUID		schemaID;
1: 	private final String		javaClassName;
1: 	private final char		aliasType;
1: 	private final char		nameSpace;
1: 	private final boolean		systemAlias;
1: 	private final AliasInfo	aliasInfo;
1: 	private final String		specificName;
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.AliasDescriptor
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import org.apache.derby.iapi.sql.depend.Provider;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import	org.apache.derby.catalog.AliasInfo;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.catalog.AliasInfo;
1: import	org.apache.derby.catalog.DependableFinder;
1: import	org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: /**
1:  * This class represents an Alias Descriptor. 
1:  * The public methods for this class are:
1:  * 
1:  * <ol>
1:  * <li>getUUID</li>
1:  * <li>getJavaClassName</li>
1:  * <li>getAliasType</li>
1:  * <li>getNameSpace</li>
1:  * <li>getSystemAlias</li>
1:  * <li>getAliasId</li>
1:  * </ol>
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
1: public final class AliasDescriptor 
0: 	extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Provider
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private UUID		aliasID;
0: 	private String		aliasName;
0: 	private UUID		schemaID;
0: 	private String		javaClassName;
0: 	private char		aliasType;
0: 	private char		nameSpace;
0: 	private boolean		systemAlias;
0: 	private AliasInfo	aliasInfo;
0: 	private String		specificName;
1: 
1: 	/**
1: 	 * Constructor for a AliasDescriptor
1: 	 *
1: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1: 	 * @param aliasID				The UUID for this alias
1: 	 * @param aliasName				The name of the method alias
1: 	 * @param schemaID				The UUID for this alias's schema
1: 	 * @param javaClassName			The java class name of the alias
1: 	 * @param aliasType				The alias type
1: 	 * @param nameSpace				The alias name space
1: 	 * @param aliasInfo				The AliasInfo for the alias
1: 	 *
1: 	 */
1: 
1: 	public	AliasDescriptor( DataDictionary dataDictionary, UUID aliasID,
1: 							  String aliasName, UUID schemaID, String javaClassName,
1: 							  char aliasType, char nameSpace, boolean systemAlias,
1: 							  AliasInfo aliasInfo, String specificName)
1: 	{
1: 		super( dataDictionary );
1: 
1: 		this.aliasID = aliasID;
1: 		this.aliasName = aliasName;
1: 		this.schemaID = schemaID;
1: 		this.javaClassName = javaClassName;
1: 		this.aliasType = aliasType;
1: 		this.nameSpace = nameSpace;
1: 		this.systemAlias = systemAlias;
1: 		this.aliasInfo = aliasInfo;
1: 		if (specificName == null)
1: 			specificName = dataDictionary.getSystemSQLName();
1: 		this.specificName = specificName;
1: 	}
1: 
1: 	// Interface methods
1: 
1: 	/**
1: 	 * Gets the UUID  of the method alias.
1: 	 *
1: 	 * @return	The UUID String of the method alias.
1: 	 */
1: 	public UUID getUUID()
1: 	{
1: 		return aliasID;
1: 	}
1: 
1: 	/**
1: 	 * Gets the UUID  of the schema for this method alias.
1: 	 *
1: 	 * @return	The UUID String of the schema id.
1: 	 */
1: 	public UUID getSchemaUUID()
1: 	{
1: 		return schemaID;
1: 	}
1: 
1: 	/**
1: 	 * Gets the java class name of the alias.
1: 	 *
1: 	 * @return	The java class name of the alias.
1: 	 */
1: 	public String getJavaClassName()
1: 	{
1: 		return javaClassName;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Gets the type of the alias.
1: 	 *
1: 	 * @return The type of the alias.
1: 	 */
1: 	public char getAliasType()
1: 	{
1: 		return aliasType;
1: 	}
1: 
1: 	/**
1: 	 * Gets the name space of the alias.
1: 	 *
1: 	 * @return The name space of the alias.
1: 	 */
1: 	public char getNameSpace()
1: 	{
1: 		return nameSpace;
1: 	}
1: 
1: 	/**
1: 	 * Gets whether or not the alias is a system alias.
1: 	 *
1: 	 * @return Whether or not the alias is a system alias.
1: 	 */
1: 	public boolean getSystemAlias()
1: 	{
1: 		return systemAlias;
1: 	}
1: 
1: 	/**
1: 	 * Gests the AliasInfo for the alias.
1: 	 *
1: 	 * @return	The AliasInfo for the alias.
1: 	 */
1: 	public AliasInfo getAliasInfo()
1: 	{
1: 		return aliasInfo;
1: 	}
1: 
1: 
1: //  	/**
1: //  	 * Sets the ID of the method alias
1: //  	 *
1: //  	 * @param aliasID	The UUID of the method alias to be set in the descriptor
1: //  	 *
1: //  	 * @return	Nothing
1: //  	 */
1: //  	public void setAliasID(UUID aliasID)
1: //  	{
1: //  		this.aliasID = aliasID;
1: //  	}
1: 
1: 	/**
1: 	 * Convert the AliasDescriptor to a String.
1: 	 *
1: 	 * @return	A String representation of this AliasDescriptor
1: 	 */
1: 
1: 	public String	toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "aliasID: " + aliasID + "\n" +
1: 				"aliasName: " + aliasName + "\n" +
1: 				"schemaID: " + schemaID + "\n" +
1: 				"javaClassName: " + javaClassName + "\n" +
1: 				"aliasType: " + aliasType + "\n" +
1: 				"nameSpace: " + nameSpace + "\n" +
1: 				"systemAlias: " + systemAlias + "\n" +
1: 				"aliasInfo: " + aliasInfo + "\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	//	Methods so that we can put AliasDescriptors on hashed lists
1: 
1: 	/**
1: 	  *	Determine if two AliasDescriptors are the same.
1: 	  *
1: 	  *	@param	otherObject	other descriptor
1: 	  *
1: 	  *	@return	true if they are the same, false otherwise
1: 	  */
1: 
1: 	public boolean equals(Object otherObject)
1: 	{
1: 		if (!(otherObject instanceof AliasDescriptor))
1: 		{	return false; }
1: 
1: 		AliasDescriptor other = (AliasDescriptor) otherObject;
1: 
1: 		return aliasID.equals( other.getUUID() );
1: 	}
1: 
1: 	/**
1: 	  *	Get a hashcode for this AliasDescriptor
1: 	  *
1: 	  *	@return	hashcode
1: 	  */
1: 	public int hashCode()
1: 	{
1: 		return	aliasID.hashCode();
1: 	}
1: 
1: 	//
1: 	// Provider interface
1: 	//
1: 
1: 	/**		
1: 		@return the stored form of this provider
1: 			representation
1: 
1: 			@see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder()
1: 	{
1: 	    return	getDependableFinder(StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID);
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Provider.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this provider.
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return aliasName;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's UUID
1: 	 *
1: 	 * @return String	The provider's UUID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return aliasID;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's type.
1: 	 *
1: 	 * @return String		The provider's type.
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.ALIAS;
1: 	}
1: 	
1: 	/** @see TupleDescriptor#getDescriptorType */
1: 	public String getDescriptorType()
1: 	{
0: 		switch (aliasType)
1: 		{
1: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1: 				return "PROCEDURE";
1: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1: 				return "FUNCTION";
0: 			default:
1: 				return  null;
1: 		}
1: 	}
1: 	
1: 	/** @see TupleDescriptor#getDescriptorName */
1: 	public String getDescriptorName()
1: 	{
1: 		return aliasName;
1: 	}
1: 
1: 
1: 	/**
1: 		Return the specific name for this object.
1: 	*/
1: 	public String getSpecificName()
1: 	{
1: 		return specificName;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:582425f
/////////////////////////////////////////////////////////////////////////
1: 		return getAliasType(aliasType);
1: 	}
0: 	
1: 	public static final String getAliasType(char nameSpace)
1: 	{
1: 		switch (nameSpace)
1: 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1: 				return "SYNONYM";
0: 		return  null;
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.sql.depend.Provider;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import	org.apache.derby.catalog.AliasInfo;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import	org.apache.derby.catalog.DependableFinder;
0: import	org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: /**
0:  * This class represents an Alias Descriptor. 
0:  * The public methods for this class are:
0:  * 
0:  * <ol>
0:  * <li>getUUID</li>
0:  * <li>getJavaClassName</li>
0:  * <li>getAliasType</li>
0:  * <li>getNameSpace</li>
0:  * <li>getSystemAlias</li>
0:  * <li>getAliasId</li>
0:  * </ol>
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public final class AliasDescriptor 
0: 	extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Provider
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private UUID		aliasID;
0: 	private String		aliasName;
0: 	private UUID		schemaID;
0: 	private String		javaClassName;
0: 	private char		aliasType;
0: 	private char		nameSpace;
0: 	private boolean		systemAlias;
0: 	private AliasInfo	aliasInfo;
0: 	private String		specificName;
0: 
0: 	/**
0: 	 * Constructor for a AliasDescriptor
0: 	 *
0: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
0: 	 * @param aliasID				The UUID for this alias
0: 	 * @param aliasName				The name of the method alias
0: 	 * @param schemaID				The UUID for this alias's schema
0: 	 * @param javaClassName			The java class name of the alias
0: 	 * @param aliasType				The alias type
0: 	 * @param nameSpace				The alias name space
0: 	 * @param aliasInfo				The AliasInfo for the alias
0: 	 *
0: 	 */
0: 
0: 	public	AliasDescriptor( DataDictionary dataDictionary, UUID aliasID,
0: 							  String aliasName, UUID schemaID, String javaClassName,
0: 							  char aliasType, char nameSpace, boolean systemAlias,
0: 							  AliasInfo aliasInfo, String specificName)
0: 	{
0: 		super( dataDictionary );
0: 
0: 		this.aliasID = aliasID;
0: 		this.aliasName = aliasName;
0: 		this.schemaID = schemaID;
0: 		this.javaClassName = javaClassName;
0: 		this.aliasType = aliasType;
0: 		this.nameSpace = nameSpace;
0: 		this.systemAlias = systemAlias;
0: 		this.aliasInfo = aliasInfo;
0: 		if (specificName == null)
0: 			specificName = dataDictionary.getSystemSQLName();
0: 		this.specificName = specificName;
0: 	}
0: 
0: 	// Interface methods
0: 
0: 	/**
0: 	 * Gets the UUID  of the method alias.
0: 	 *
0: 	 * @return	The UUID String of the method alias.
0: 	 */
0: 	public UUID getUUID()
0: 	{
0: 		return aliasID;
0: 	}
0: 
0: 	/**
0: 	 * Gets the UUID  of the schema for this method alias.
0: 	 *
0: 	 * @return	The UUID String of the schema id.
0: 	 */
0: 	public UUID getSchemaUUID()
0: 	{
0: 		return schemaID;
0: 	}
0: 
0: 	/**
0: 	 * Gets the java class name of the alias.
0: 	 *
0: 	 * @return	The java class name of the alias.
0: 	 */
0: 	public String getJavaClassName()
0: 	{
0: 		return javaClassName;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Gets the type of the alias.
0: 	 *
0: 	 * @return The type of the alias.
0: 	 */
0: 	public char getAliasType()
0: 	{
0: 		return aliasType;
0: 	}
0: 
0: 	/**
0: 	 * Gets the name space of the alias.
0: 	 *
0: 	 * @return The name space of the alias.
0: 	 */
0: 	public char getNameSpace()
0: 	{
0: 		return nameSpace;
0: 	}
0: 
0: 	/**
0: 	 * Gets whether or not the alias is a system alias.
0: 	 *
0: 	 * @return Whether or not the alias is a system alias.
0: 	 */
0: 	public boolean getSystemAlias()
0: 	{
0: 		return systemAlias;
0: 	}
0: 
0: 	/**
0: 	 * Gests the AliasInfo for the alias.
0: 	 *
0: 	 * @return	The AliasInfo for the alias.
0: 	 */
0: 	public AliasInfo getAliasInfo()
0: 	{
0: 		return aliasInfo;
0: 	}
0: 
0: 
0: //  	/**
0: //  	 * Sets the ID of the method alias
0: //  	 *
0: //  	 * @param aliasID	The UUID of the method alias to be set in the descriptor
0: //  	 *
0: //  	 * @return	Nothing
0: //  	 */
0: //  	public void setAliasID(UUID aliasID)
0: //  	{
0: //  		this.aliasID = aliasID;
0: //  	}
0: 
0: 	/**
0: 	 * Convert the AliasDescriptor to a String.
0: 	 *
0: 	 * @return	A String representation of this AliasDescriptor
0: 	 */
0: 
0: 	public String	toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "aliasID: " + aliasID + "\n" +
0: 				"aliasName: " + aliasName + "\n" +
0: 				"schemaID: " + schemaID + "\n" +
0: 				"javaClassName: " + javaClassName + "\n" +
0: 				"aliasType: " + aliasType + "\n" +
0: 				"nameSpace: " + nameSpace + "\n" +
0: 				"systemAlias: " + systemAlias + "\n" +
0: 				"aliasInfo: " + aliasInfo + "\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	//	Methods so that we can put AliasDescriptors on hashed lists
0: 
0: 	/**
0: 	  *	Determine if two AliasDescriptors are the same.
0: 	  *
0: 	  *	@param	otherObject	other descriptor
0: 	  *
0: 	  *	@return	true if they are the same, false otherwise
0: 	  */
0: 
0: 	public boolean equals(Object otherObject)
0: 	{
0: 		if (!(otherObject instanceof AliasDescriptor))
0: 		{	return false; }
0: 
0: 		AliasDescriptor other = (AliasDescriptor) otherObject;
0: 
0: 		return aliasID.equals( other.getUUID() );
0: 	}
0: 
0: 	/**
0: 	  *	Get a hashcode for this AliasDescriptor
0: 	  *
0: 	  *	@return	hashcode
0: 	  */
0: 	public int hashCode()
0: 	{
0: 		return	aliasID.hashCode();
0: 	}
0: 
0: 	//
0: 	// Provider interface
0: 	//
0: 
0: 	/**		
0: 		@return the stored form of this provider
0: 			representation
0: 
0: 			@see Dependable#getDependableFinder
0: 	 */
0: 	public DependableFinder getDependableFinder()
0: 	{
0: 	    return	getDependableFinder(StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID);
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Provider.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this provider.
0: 	 */
0: 	public String getObjectName()
0: 	{
0: 		return aliasName;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's UUID
0: 	 *
0: 	 * @return String	The provider's UUID
0: 	 */
0: 	public UUID getObjectID()
0: 	{
0: 		return aliasID;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's type.
0: 	 *
0: 	 * @return String		The provider's type.
0: 	 */
0: 	public String getClassType()
0: 	{
0: 		return Dependable.ALIAS;
0: 	}
0: 	
0: 	/** @see TupleDescriptor#getDescriptorType */
0: 	public String getDescriptorType()
0: 	{
0: 		switch (aliasType)
0: 		{
0: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
0: 				return "PROCEDURE";
0: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
0: 				return "FUNCTION";
0: 			default:
0: 				return  null;
0: 		}
0: 	}
0: 	
0: 	/** @see TupleDescriptor#getDescriptorName */
0: 	public String getDescriptorName()
0: 	{
0: 		return aliasName;
0: 	}
0: 
0: 
0: 	/**
0: 		Return the specific name for this object.
0: 	*/
0: 	public String getSpecificName()
0: 	{
0: 		return specificName;
0: 	}
0: }
============================================================================