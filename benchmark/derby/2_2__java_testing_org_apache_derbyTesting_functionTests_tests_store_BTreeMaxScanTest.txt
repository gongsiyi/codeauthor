1:20cc8ad: /*
1:20cc8ad:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.BTreeMaxScanTest
1:20cc8ad:  *
1:20cc8ad:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:20cc8ad:  * contributor license agreements.  See the NOTICE file distributed with
1:20cc8ad:  * this work for additional information regarding copyright ownership.
1:20cc8ad:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:20cc8ad:  * (the "License"); you may not use this file except in compliance with
1:20cc8ad:  * the License.  You may obtain a copy of the License at
1:20cc8ad:  *
1:20cc8ad:  *    http://www.apache.org/licenses/LICENSE-2.0
1:20cc8ad:  *
1:20cc8ad:  * Unless required by applicable law or agreed to in writing,
1:20cc8ad:  * software distributed under the License is distributed on an
1:20cc8ad:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:20cc8ad:  * either express or implied. See the License for the specific
1:20cc8ad:  * language governing permissions and limitations under the License.
1:20cc8ad:  */
1:20cc8ad: 
1:20cc8ad: package org.apache.derbyTesting.functionTests.tests.store;
1:20cc8ad: 
1:20cc8ad: import java.sql.Connection;
1:20cc8ad: import java.sql.PreparedStatement;
1:20cc8ad: import java.sql.ResultSet;
1:20cc8ad: import java.sql.Statement;
1:20cc8ad: import java.util.ArrayList;
1:20cc8ad: import java.util.List;
1:20cc8ad: import junit.framework.Test;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:20cc8ad: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:20cc8ad: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:20cc8ad: import org.apache.derbyTesting.junit.JDBC;
1:20cc8ad: import org.apache.derbyTesting.junit.TestConfiguration;
1:20cc8ad: 
1:20cc8ad: /**
1:20cc8ad:  * Test cases for max queries that scan a B-tree index backwards (DERBY-642).
1:20cc8ad:  */
1:20cc8ad: public class BTreeMaxScanTest extends BaseJDBCTestCase {
1:20cc8ad:     /** List of SanityManager debug flags to reset on teardown. */
1:3f5c48a:     private List<String> traceFlags = new ArrayList<String>();
1:20cc8ad: 
1:20cc8ad:     public BTreeMaxScanTest(String name) {
1:20cc8ad:         super(name);
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * Create a test suite with all the test cases in this class.
1:20cc8ad:      */
1:20cc8ad:     public static Test suite() {
1:20cc8ad:         // This is a test for engine functionality, so skip client/server.
1:20cc8ad:         return new CleanDatabaseTestSetup(
1:20cc8ad:                 TestConfiguration.embeddedSuite(BTreeMaxScanTest.class));
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * Tear down the test environment.
1:20cc8ad:      */
1:20cc8ad:     protected void tearDown() throws Exception {
1:20cc8ad:         super.tearDown();
1:20cc8ad:         if (SanityManager.DEBUG) {
1:3f5c48a:             for (String flag : traceFlags) {
1:20cc8ad:                 SanityManager.DEBUG_PRINT(
1:20cc8ad:                         flag, "Disable tracing for " + getName());
1:20cc8ad:                 SanityManager.DEBUG_CLEAR(flag);
1:20cc8ad:             }
1:20cc8ad:         }
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     // TESTS
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * Test that a max scan which cannot immediately lock the rightmost row
1:20cc8ad:      * in the index, restarts the scan when it wakes up to see if the row it
1:20cc8ad:      * waited for is still the maximum row. Tests
1:20cc8ad:      * BTreeMaxScan#positionAtStartPosition.
1:20cc8ad:      */
1:20cc8ad:     public void testRestartScanAfterWaitOnMaxRow() throws Exception {
1:20cc8ad:         setAutoCommit(false);
1:20cc8ad: 
1:20cc8ad:         // Populate a table with test data
1:20cc8ad:         Statement s = createStatement();
1:20cc8ad:         s.execute("create table t(x int, y int)");
1:20cc8ad: 
1:20cc8ad:         PreparedStatement ins = prepareStatement("insert into t(x) values ?");
1:20cc8ad:         for (int i = 1; i <= 800; i++) {
1:20cc8ad:             ins.setInt(1, i);
1:20cc8ad:             ins.executeUpdate();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         s.execute("create index i on t(x)");
1:20cc8ad: 
1:20cc8ad:         commit();
1:20cc8ad: 
1:20cc8ad:         // Make sure the rightmost row in the index is locked
1:20cc8ad:         s.execute("update t set y = 0 where x = 800");
1:20cc8ad: 
1:20cc8ad:         Connection c2 = openDefaultConnection();
1:20cc8ad:         try {
1:20cc8ad:             c2.setAutoCommit(false);
1:20cc8ad:             Statement s2 = c2.createStatement();
1:20cc8ad: 
1:20cc8ad:             // In a different thread, in a different transaction, start a max
1:20cc8ad:             // scan that will be blocked trying to lock the rightmost row.
1:20cc8ad:             Result r = asyncGetSingleResult(s2,
1:20cc8ad:                     "select max(x) from t --derby-properties index=i");
1:20cc8ad: 
1:20cc8ad:             // Give the other thread two seconds to start executing and hit
1:20cc8ad:             // the lock.
1:20cc8ad:             Thread.sleep(2000L);
1:20cc8ad: 
1:20cc8ad:             // Now insert a row with a higher value, so that the row the other
1:20cc8ad:             // thread is waiting for is no longer the maximum row.
1:20cc8ad:             ins.setInt(1, 801);
1:20cc8ad:             ins.executeUpdate();
1:20cc8ad: 
1:20cc8ad:             // Commit, release locks, and allow the other thread to continue.
1:20cc8ad:             commit();
1:20cc8ad: 
1:20cc8ad:             // Now we expect the other thread to be able to continue. It should
1:20cc8ad:             // restart the scan because it couldn't lock the rightmost row, and
1:20cc8ad:             // it should therefore see the newly inserted value 801.
1:20cc8ad:             assertEquals("801", r.get());
1:20cc8ad: 
1:20cc8ad:         } finally {
1:20cc8ad:             c2.rollback();
1:20cc8ad:             c2.close();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         dropTable("T");
1:20cc8ad:         commit();
1:20cc8ad:     }
1:20cc8ad: 
1:9d9c142:     /**
1:20cc8ad:      * Test that scanners that work in opposite directions don't deadlock. The
1:20cc8ad:      * test case has two threads running B-tree forward scans in parallel with
1:20cc8ad:      * two threads running B-tree (backward) max scans.
1:20cc8ad:      */
1:20cc8ad:     public void testOppositeScanDirections() throws Exception {
1:20cc8ad:         // Trace latch conflicts to see which parts of the repositioning code
1:20cc8ad:         // we exercise. This test case is supposed to test simple latch
1:20cc8ad:         // conflicts between forward scanners and backward scanners, and should
1:20cc8ad:         // result in "Couldn't get latch nowait, will retry" being written to
1:20cc8ad:         // derby.log when latch conflicts occur.
1:20cc8ad:         setTraceFlag("BTreeMaxScan.latchConflict");
1:20cc8ad: 
1:20cc8ad:         setAutoCommit(false);
1:20cc8ad: 
1:20cc8ad:         Statement s = createStatement();
1:20cc8ad:         s.execute("create table t(x int)");
1:20cc8ad: 
1:20cc8ad:         // Insert a couple pages worth of rows, only the first 100 of them
1:20cc8ad:         // being non-null. The null values makes the max scan need to scan
1:20cc8ad:         // backwards across page boundaries to find a qualifying row.
1:20cc8ad:         PreparedStatement ins = prepareStatement("insert into t values ?");
1:20cc8ad:         final String[][] tableContents = new String[800][];
1:20cc8ad:         for (int i = 1; i <= tableContents.length; i++) {
1:20cc8ad:             String value = (i <= 100) ? Integer.toString(i) : null;
1:20cc8ad:             ins.setString(1, value);
1:20cc8ad:             ins.executeUpdate();
1:20cc8ad:             tableContents[i - 1] = new String[] { value };
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         s.execute("create index i on t(x)");
1:20cc8ad: 
1:20cc8ad:         commit();
1:20cc8ad: 
1:20cc8ad:         // Now start four threads. Two scanning the B-tree in the forward
1:20cc8ad:         // direction, and two scanning in the backward direction (max scans).
1:20cc8ad:         // These threads should not interfere with each other.
1:20cc8ad:         String forwardSQL = "select x from t --derby-properties index=i";
1:20cc8ad:         String backwardSQL = "select max(x) from t --derby-properties index=i";
1:20cc8ad: 
1:20cc8ad:         final PreparedStatement[] pss = {
1:20cc8ad:             openDefaultConnection().prepareStatement(forwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(forwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(backwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(backwardSQL),
1:20cc8ad:         };
1:20cc8ad: 
1:20cc8ad:         final Exception[] exceptions = new Exception[pss.length];
1:20cc8ad: 
1:20cc8ad:         final Thread[] threads = new Thread[pss.length];
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < pss.length; i++) {
1:20cc8ad:             final int threadNo = i;
1:20cc8ad:             threads[i] = new Thread() {
1:20cc8ad:                 public void run() {
1:20cc8ad:                     // The forward scan is expected to return all rows in
1:20cc8ad:                     // the table, the backward (max) scan only the highest
1:20cc8ad:                     // non-null row.
1:20cc8ad:                     String[][] expected = (threadNo < 2) ?
1:20cc8ad:                             tableContents : new String[][] {{"100"}};
1:20cc8ad:                     try {
1:20cc8ad:                         for (int j = 0; j < 1000; j++) {
1:20cc8ad:                             ResultSet rs = pss[threadNo].executeQuery();
1:20cc8ad:                             JDBC.assertFullResultSet(rs, expected);
1:20cc8ad:                         }
1:20cc8ad:                     } catch (Exception e) {
1:20cc8ad:                         exceptions[threadNo] = e;
1:20cc8ad:                     }
1:20cc8ad:                 }
1:20cc8ad:             };
1:20cc8ad:             threads[i].start();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < pss.length; i++) {
1:20cc8ad:             threads[i].join();
1:20cc8ad:             pss[i].getConnection().close();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < exceptions.length; i++) {
1:20cc8ad:             if (exceptions[i] != null) {
1:20cc8ad:                 throw exceptions[i];
1:20cc8ad:             }
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         dropTable("T");
1:20cc8ad:         commit();
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:9d9c142:      * <p>
1:20cc8ad:      * Test that latch conflicts between forward scans and backward (max) scans
1:20cc8ad:      * are resolved without deadlocking or other errors when the rightmost
1:20cc8ad:      * leaf page of the B-tree is empty. In that case, the backward scan must
1:20cc8ad:      * restart, since it doesn't have any saved position to return to.
1:20cc8ad:      * </p>
1:20cc8ad:      *
1:20cc8ad:      * <p>
1:20cc8ad:      * The test is performed by running two threads that scan the leaves of
1:20cc8ad:      * the B-tree in the forward direction, while at the same time two threads
1:20cc8ad:      * do a backward max scan on the same B-tree. In parallel with the threads
1:20cc8ad:      * that scan the index, the main thread will repeatedly delete the rows
1:20cc8ad:      * with the highest values in order to create a window where the scans may
1:20cc8ad:      * see an empty page, sleep a little, and then re-insert the deleted rows.
1:20cc8ad:      * </p>
1:20cc8ad:      */
1:20cc8ad:     public void testEmptyRightmostLeaf() throws Exception {
1:20cc8ad:         // Trace latch conflicts to see that we exercise the code path that
1:20cc8ad:         // handles repositioning after waiting for a latch when moving away
1:20cc8ad:         // from an empty leaf at the far-right end of the B-tree. When this
1:20cc8ad:         // code is exercised, we'll see "Restart scan from rightmost leaf"
1:20cc8ad:         // printed to derby.log.
1:20cc8ad:         setTraceFlag("BTreeMaxScan.latchConflict");
1:20cc8ad: 
1:20cc8ad:         setAutoCommit(false);
1:20cc8ad: 
1:20cc8ad:         Statement s = createStatement();
1:20cc8ad:         s.execute("create table t(x int)");
1:20cc8ad: 
1:20cc8ad:         // Insert a couple pages worth of rows.
1:20cc8ad:         PreparedStatement ins = prepareStatement("insert into t values ?");
1:20cc8ad:         for (int i = 1; i <= 800; i++) {
1:20cc8ad:             ins.setInt(1, i);
1:20cc8ad:             ins.executeUpdate();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         s.execute("create index i on t(x)");
1:20cc8ad: 
1:20cc8ad:         commit();
1:20cc8ad: 
1:20cc8ad:         // Now start four threads. Two scanning the B-tree in the forward
1:20cc8ad:         // direction, and two scanning in the backward direction (max scans).
1:20cc8ad:         // These threads should not interfere with each other.
1:20cc8ad:         String forwardSQL = "select x from t --derby-properties index=i";
1:20cc8ad:         String backwardSQL = "select max(x) from t --derby-properties index=i";
1:20cc8ad: 
1:20cc8ad:         final PreparedStatement[] pss = {
1:20cc8ad:             openDefaultConnection().prepareStatement(forwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(forwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(backwardSQL),
1:20cc8ad:             openDefaultConnection().prepareStatement(backwardSQL),
1:20cc8ad:         };
1:20cc8ad: 
1:20cc8ad:         final Exception[] exceptions = new Exception[pss.length];
1:20cc8ad: 
1:20cc8ad:         final Thread[] threads = new Thread[pss.length];
1:20cc8ad: 
1:20cc8ad:         final AtomicInt threadCount = new AtomicInt();
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < pss.length; i++) {
1:20cc8ad:             final int threadNo = i;
1:20cc8ad:             // Set the isolation level to read uncommitted so that the scans
1:20cc8ad:             // don't take any locks. We do this because we want to test latch
1:20cc8ad:             // conflicts, and if the scans take read locks, they'll spend most
1:20cc8ad:             // of the time waiting for the write thread to release its locks.
1:20cc8ad:             pss[i].getConnection().setTransactionIsolation(
1:20cc8ad:                     Connection.TRANSACTION_READ_UNCOMMITTED);
1:20cc8ad:             threads[i] = new Thread() {
1:20cc8ad:                 public void run() {
1:20cc8ad:                     try {
1:20cc8ad:                         for (int j = 0; j < 1000; j++) {
1:20cc8ad:                             ResultSet rs = pss[threadNo].executeQuery();
1:20cc8ad:                             if (threadNo < 2) {
1:20cc8ad:                                 // This is a full forward scan (SELECT *) of
1:20cc8ad:                                 // the B-tree, so expect it to see between 400
1:20cc8ad:                                 // and 800 rows.
1:20cc8ad:                                 int rowCount = JDBC.assertDrainResults(rs);
1:20cc8ad:                                 if (rowCount < 400 || rowCount > 800) {
1:20cc8ad:                                     fail("Unexpected row count: " + rowCount);
1:20cc8ad:                                 }
1:20cc8ad:                             } else {
1:20cc8ad:                                 // This is a max scan, so expect a single
1:20cc8ad:                                 // row that contains a value between 400 and
1:20cc8ad:                                 // 800.
1:20cc8ad:                                 assertTrue(rs.next());
1:20cc8ad:                                 int max = rs.getInt(1);
1:20cc8ad:                                 if (max < 400 || max > 800) {
1:20cc8ad:                                     fail("Unexpected max value: " + max);
1:20cc8ad:                                 }
1:20cc8ad:                                 assertFalse(rs.next());
1:20cc8ad:                                 rs.close();
1:20cc8ad:                             }
1:20cc8ad:                         }
1:20cc8ad:                     } catch (Exception e) {
1:20cc8ad:                         exceptions[threadNo] = e;
1:20cc8ad:                     } finally {
1:20cc8ad:                         threadCount.decrement();
1:20cc8ad:                     }
1:20cc8ad:                 }
1:20cc8ad:             };
1:20cc8ad:             threads[i].start();
1:20cc8ad:             threadCount.increment();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         // As long as the scanner threads are running, periodically delete
1:20cc8ad:         // and re-insert the last 400 rows. This empties the rightmost leaf
1:20cc8ad:         // page(s) and makes it possible for the scanners to encounter the
1:20cc8ad:         // situation where they need to reposition after a latch conflict
1:20cc8ad:         // while being positioned on an empty page with no saved position. The
1:20cc8ad:         // post-commit worker will eventually remove the pointers to the empty
1:20cc8ad:         // leaf, so we need to do this repeatedly and hope that the timing
1:20cc8ad:         // will be right at least once so that we exercise the desired path.
1:20cc8ad:         PreparedStatement deleteRows =
1:20cc8ad:                 prepareStatement("delete from t where x > 400");
1:20cc8ad:         PreparedStatement insertRows =
1:20cc8ad:                 prepareStatement("insert into t select x+400 from t");
1:20cc8ad:         while (threadCount.get() > 0) {
1:20cc8ad:             // Delete rows in range [401, 800].
1:20cc8ad:             assertEquals("deleted rows", 400, deleteRows.executeUpdate());
1:20cc8ad:             commit();
1:20cc8ad: 
1:20cc8ad:             // Sleep a little while so that we don't fill the empty page
1:20cc8ad:             // before the scanners have seen it.
1:20cc8ad:             Thread.sleep(100L);
1:20cc8ad: 
1:20cc8ad:             // Re-insert rows in range [401, 800].
1:20cc8ad:             assertEquals("inserted rows", 400, insertRows.executeUpdate());
1:20cc8ad:             commit();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < pss.length; i++) {
1:20cc8ad:             threads[i].join();
1:20cc8ad:             pss[i].getConnection().close();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         for (int i = 0; i < exceptions.length; i++) {
1:20cc8ad:             if (exceptions[i] != null) {
1:20cc8ad:                 throw exceptions[i];
1:20cc8ad:             }
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         dropTable("T");
1:20cc8ad:         commit();
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * <p>
1:9d9c142:      * Test that B-tree max scans reposition correctly after waiting for a
1:9d9c142:      * lock on the last row and detect any new max value inserted while the
1:9d9c142:      * scan was waiting for the lock.
1:9d9c142:      * </p>
1:9d9c142:      *
1:9d9c142:      * <p>
1:9d9c142:      * <b>Note:</b> Currently, B-tree max scans always take a table lock when
1:9d9c142:      * running with serializable isolation level, so the scans in this test
1:9d9c142:      * case will not actually be blocked waiting for a row lock. The test case
1:9d9c142:      * is added to verify that the scans behave correctly if the lock mode is
1:9d9c142:      * changed in the future.
1:9d9c142:      * </p>
1:9d9c142:      */
1:9d9c142:     public void testSerializable() throws Exception {
1:9d9c142:         setAutoCommit(false);
1:9d9c142: 
1:9d9c142:         getConnection().
1:9d9c142:                 setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:9d9c142: 
1:9d9c142:         Statement s = createStatement();
1:9d9c142:         s.execute("create table t(x int, y int)");
1:9d9c142:         s.execute("insert into t(x) values 0,1,2,3,4,null,null,null");
1:9d9c142:         s.execute("create index i on t(x)");
1:9d9c142: 
1:9d9c142:         PreparedStatement ps = prepareStatement(
1:9d9c142:                 "select max(x) from t --derby-properties index=i");
1:9d9c142: 
1:9d9c142:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "4");
1:9d9c142: 
1:9d9c142:         commit();
1:9d9c142: 
1:9d9c142:         // Set up another transaction that holds an exclusive lock on the
1:9d9c142:         // row with the max value.
1:9d9c142:         final Connection c2 = openDefaultConnection();
1:9d9c142:         final Statement s2 = c2.createStatement();
1:9d9c142:         c2.setAutoCommit(false);
1:9d9c142:         s2.execute("update t set y = x where x = 4");
1:9d9c142: 
1:9d9c142:         final Exception[] exception = new Exception[1];
1:9d9c142: 
1:9d9c142:         Thread t = new Thread() {
1:9d9c142:             public void run() {
1:9d9c142:                 try {
1:9d9c142:                     // Wait a little while so that the main thread gets time
1:9d9c142:                     // to start the scan and get blocked by the lock on the
1:9d9c142:                     // highest row.
1:9d9c142:                     Thread.sleep(1000L);
1:9d9c142:                     // While the main thread is still blocked, insert a new
1:9d9c142:                     // max value.
1:9d9c142:                     s2.execute("insert into t(x) values 5");
1:9d9c142:                     // Commit, release the locks, and let the main thread
1:9d9c142:                     // continue.
1:9d9c142:                     c2.commit();
1:9d9c142:                 } catch (Exception sqle) {
1:9d9c142:                     exception[0] = sqle;
1:9d9c142:                 }
1:9d9c142:             }
1:9d9c142:         };
1:9d9c142: 
1:9d9c142:         t.start();
1:9d9c142: 
1:9d9c142:         // The two max scans should return the same value since they are
1:9d9c142:         // in the same transaction and the isolation level is serializable.
1:9d9c142:         // The first scan will be blocked by the lock held by the other
1:9d9c142:         // transaction. When it wakes up, it should see the newly inserted
1:9d9c142:         // row.
1:9d9c142:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "5");
1:9d9c142:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "5");
1:9d9c142:         commit();
1:9d9c142: 
1:9d9c142:         t.join();
1:9d9c142:         s2.close();
1:9d9c142:         c2.rollback();
1:9d9c142:         c2.close();
1:9d9c142: 
1:9d9c142:         // Did the other thread fail?
1:9d9c142:         if (exception[0] != null) {
1:9d9c142:             throw exception[0];
1:9d9c142:         }
1:9d9c142: 
1:9d9c142:         dropTable("T");
1:9d9c142:         commit();
1:9d9c142:     }
1:9d9c142: 
1:20cc8ad:     // HELPER METHODS
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * This class represents a result from an asynchronous operation.
1:20cc8ad:      */
1:20cc8ad:     private static class Result {
1:20cc8ad:         private boolean complete;
1:20cc8ad:         private Exception ex;
1:20cc8ad:         private String value;
1:20cc8ad: 
1:20cc8ad:         synchronized void error(Exception ex) {
1:20cc8ad:             this.ex = ex;
1:20cc8ad:             this.complete = true;
1:20cc8ad:             notifyAll();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         synchronized void set(String value) {
1:20cc8ad:             this.value = value;
1:20cc8ad:             this.complete = true;
1:20cc8ad:             notifyAll();
1:20cc8ad:         }
1:20cc8ad: 
1:20cc8ad:         synchronized String get() throws Exception {
1:20cc8ad:             while (!complete) {
1:20cc8ad:                 wait();
1:20cc8ad:             }
1:20cc8ad:             if (ex != null) {
1:20cc8ad:                 throw ex;
1:20cc8ad:             } else {
1:20cc8ad:                 return value;
1:20cc8ad:             }
1:20cc8ad:         }
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * Execute a statement asynchronously and return an object that can be
1:20cc8ad:      * used to retrieve the result once the statement is complete. The
1:20cc8ad:      * statement should return a single value.
1:20cc8ad:      *
1:20cc8ad:      * @param s the statement object to use for execution
1:20cc8ad:      * @param sql the SQL to execute
1:20cc8ad:      * @return a {@code Result} object that allows retrieval of the result
1:20cc8ad:      * once it's available
1:20cc8ad:      */
1:20cc8ad:     private static Result asyncGetSingleResult(
1:20cc8ad:             final Statement s, final String sql) {
1:20cc8ad:         final Result result = new Result();
1:20cc8ad: 
1:20cc8ad:         Thread t = new Thread() {
1:20cc8ad:             public void run() {
1:20cc8ad:                 try {
1:20cc8ad:                     ResultSet rs = s.executeQuery(sql);
1:20cc8ad:                     assertEquals("expected single value",
1:20cc8ad:                             1, rs.getMetaData().getColumnCount());
1:20cc8ad:                     assertTrue("empty result", rs.next());
1:20cc8ad:                     String val = rs.getString(1);
1:20cc8ad:                     assertFalse("multiple rows", rs.next());
1:20cc8ad:                     rs.close();
1:20cc8ad:                     result.set(val);
1:20cc8ad:                 } catch (Exception e) {
1:20cc8ad:                     result.error(e);
1:20cc8ad:                 }
1:20cc8ad:             }
1:20cc8ad:         };
1:20cc8ad: 
1:20cc8ad:         t.start();
1:20cc8ad: 
1:20cc8ad:         return result;
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * If running with a debug build and derby.tests.trace is true, enable
1:20cc8ad:      * tracing for messages with the specified flag.
1:20cc8ad:      *
1:20cc8ad:      * @param flag the debug flag to enable
1:20cc8ad:      */
1:20cc8ad:     private void setTraceFlag(String flag) {
1:20cc8ad:         if (SanityManager.DEBUG && TestConfiguration.getCurrent().doTrace()) {
1:20cc8ad:             SanityManager.DEBUG_PRINT(flag, "Enable tracing for " + getName());
1:20cc8ad:             SanityManager.DEBUG_SET(flag);
1:20cc8ad:             traceFlags.add(flag);
1:20cc8ad:         }
1:20cc8ad:     }
1:20cc8ad: 
1:20cc8ad:     /**
1:20cc8ad:      * Poor man's replacement for java.util.concurrent.atomic.AtomicInteger
1:20cc8ad:      * that runs on platforms where java.util.concurrent isn't available.
1:20cc8ad:      */
1:20cc8ad:     private static class AtomicInt {
1:20cc8ad:         private int i;
1:20cc8ad:         synchronized void increment() {
1:20cc8ad:             i++;
1:20cc8ad:         }
1:20cc8ad:         synchronized void decrement() {
1:20cc8ad:             i--;
1:20cc8ad:         }
1:20cc8ad:         synchronized int get() {
1:20cc8ad:             return i;
1:20cc8ad:         }
1:20cc8ad:     }
1:20cc8ad: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private List<String> traceFlags = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:             for (String flag : traceFlags) {
commit:9d9c142
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test that B-tree max scans reposition correctly after waiting for a
1:      * lock on the last row and detect any new max value inserted while the
1:      * scan was waiting for the lock.
1:      * </p>
1:      *
1:      * <p>
1:      * <b>Note:</b> Currently, B-tree max scans always take a table lock when
1:      * running with serializable isolation level, so the scans in this test
1:      * case will not actually be blocked waiting for a row lock. The test case
1:      * is added to verify that the scans behave correctly if the lock mode is
1:      * changed in the future.
1:      * </p>
1:      */
1:     public void testSerializable() throws Exception {
1:         setAutoCommit(false);
1: 
1:         getConnection().
1:                 setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table t(x int, y int)");
1:         s.execute("insert into t(x) values 0,1,2,3,4,null,null,null");
1:         s.execute("create index i on t(x)");
1: 
1:         PreparedStatement ps = prepareStatement(
1:                 "select max(x) from t --derby-properties index=i");
1: 
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "4");
1: 
1:         commit();
1: 
1:         // Set up another transaction that holds an exclusive lock on the
1:         // row with the max value.
1:         final Connection c2 = openDefaultConnection();
1:         final Statement s2 = c2.createStatement();
1:         c2.setAutoCommit(false);
1:         s2.execute("update t set y = x where x = 4");
1: 
1:         final Exception[] exception = new Exception[1];
1: 
1:         Thread t = new Thread() {
1:             public void run() {
1:                 try {
1:                     // Wait a little while so that the main thread gets time
1:                     // to start the scan and get blocked by the lock on the
1:                     // highest row.
1:                     Thread.sleep(1000L);
1:                     // While the main thread is still blocked, insert a new
1:                     // max value.
1:                     s2.execute("insert into t(x) values 5");
1:                     // Commit, release the locks, and let the main thread
1:                     // continue.
1:                     c2.commit();
1:                 } catch (Exception sqle) {
1:                     exception[0] = sqle;
1:                 }
1:             }
1:         };
1: 
1:         t.start();
1: 
1:         // The two max scans should return the same value since they are
1:         // in the same transaction and the isolation level is serializable.
1:         // The first scan will be blocked by the lock held by the other
1:         // transaction. When it wakes up, it should see the newly inserted
1:         // row.
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "5");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "5");
1:         commit();
1: 
1:         t.join();
1:         s2.close();
1:         c2.rollback();
1:         c2.close();
1: 
1:         // Did the other thread fail?
1:         if (exception[0] != null) {
1:             throw exception[0];
1:         }
1: 
1:         dropTable("T");
1:         commit();
1:     }
1: 
commit:20cc8ad
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.BTreeMaxScanTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import java.util.ArrayList;
0: import java.util.Iterator;
1: import java.util.List;
1: import junit.framework.Test;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test cases for max queries that scan a B-tree index backwards (DERBY-642).
1:  */
1: public class BTreeMaxScanTest extends BaseJDBCTestCase {
1:     /** List of SanityManager debug flags to reset on teardown. */
0:     private List traceFlags = new ArrayList();
1: 
1:     public BTreeMaxScanTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Create a test suite with all the test cases in this class.
1:      */
1:     public static Test suite() {
1:         // This is a test for engine functionality, so skip client/server.
1:         return new CleanDatabaseTestSetup(
1:                 TestConfiguration.embeddedSuite(BTreeMaxScanTest.class));
1:     }
1: 
1:     /**
1:      * Tear down the test environment.
1:      */
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:         if (SanityManager.DEBUG) {
0:             // If we've enabled tracing for the test case, disable it now.
0:             Iterator it = traceFlags.iterator();
0:             while (it.hasNext()) {
0:                 String flag = (String) it.next();
1:                 SanityManager.DEBUG_PRINT(
1:                         flag, "Disable tracing for " + getName());
1:                 SanityManager.DEBUG_CLEAR(flag);
1:             }
1:         }
1:     }
1: 
1:     // TESTS
1: 
1:     /**
1:      * Test that a max scan which cannot immediately lock the rightmost row
1:      * in the index, restarts the scan when it wakes up to see if the row it
1:      * waited for is still the maximum row. Tests
1:      * BTreeMaxScan#positionAtStartPosition.
1:      */
1:     public void testRestartScanAfterWaitOnMaxRow() throws Exception {
1:         setAutoCommit(false);
1: 
1:         // Populate a table with test data
1:         Statement s = createStatement();
1:         s.execute("create table t(x int, y int)");
1: 
1:         PreparedStatement ins = prepareStatement("insert into t(x) values ?");
1:         for (int i = 1; i <= 800; i++) {
1:             ins.setInt(1, i);
1:             ins.executeUpdate();
1:         }
1: 
1:         s.execute("create index i on t(x)");
1: 
1:         commit();
1: 
1:         // Make sure the rightmost row in the index is locked
1:         s.execute("update t set y = 0 where x = 800");
1: 
1:         Connection c2 = openDefaultConnection();
1:         try {
1:             c2.setAutoCommit(false);
1:             Statement s2 = c2.createStatement();
1: 
1:             // In a different thread, in a different transaction, start a max
1:             // scan that will be blocked trying to lock the rightmost row.
1:             Result r = asyncGetSingleResult(s2,
1:                     "select max(x) from t --derby-properties index=i");
1: 
1:             // Give the other thread two seconds to start executing and hit
1:             // the lock.
1:             Thread.sleep(2000L);
1: 
1:             // Now insert a row with a higher value, so that the row the other
1:             // thread is waiting for is no longer the maximum row.
1:             ins.setInt(1, 801);
1:             ins.executeUpdate();
1: 
1:             // Commit, release locks, and allow the other thread to continue.
1:             commit();
1: 
1:             // Now we expect the other thread to be able to continue. It should
1:             // restart the scan because it couldn't lock the rightmost row, and
1:             // it should therefore see the newly inserted value 801.
1:             assertEquals("801", r.get());
1: 
1:         } finally {
1:             c2.rollback();
1:             c2.close();
1:         }
1: 
1:         dropTable("T");
1:         commit();
1:     }
1: 
1:     /**
1:      * Test that scanners that work in opposite directions don't deadlock. The
1:      * test case has two threads running B-tree forward scans in parallel with
1:      * two threads running B-tree (backward) max scans.
1:      */
1:     public void testOppositeScanDirections() throws Exception {
1:         // Trace latch conflicts to see which parts of the repositioning code
1:         // we exercise. This test case is supposed to test simple latch
1:         // conflicts between forward scanners and backward scanners, and should
1:         // result in "Couldn't get latch nowait, will retry" being written to
1:         // derby.log when latch conflicts occur.
1:         setTraceFlag("BTreeMaxScan.latchConflict");
1: 
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table t(x int)");
1: 
1:         // Insert a couple pages worth of rows, only the first 100 of them
1:         // being non-null. The null values makes the max scan need to scan
1:         // backwards across page boundaries to find a qualifying row.
1:         PreparedStatement ins = prepareStatement("insert into t values ?");
1:         final String[][] tableContents = new String[800][];
1:         for (int i = 1; i <= tableContents.length; i++) {
1:             String value = (i <= 100) ? Integer.toString(i) : null;
1:             ins.setString(1, value);
1:             ins.executeUpdate();
1:             tableContents[i - 1] = new String[] { value };
1:         }
1: 
1:         s.execute("create index i on t(x)");
1: 
1:         commit();
1: 
1:         // Now start four threads. Two scanning the B-tree in the forward
1:         // direction, and two scanning in the backward direction (max scans).
1:         // These threads should not interfere with each other.
1:         String forwardSQL = "select x from t --derby-properties index=i";
1:         String backwardSQL = "select max(x) from t --derby-properties index=i";
1: 
1:         final PreparedStatement[] pss = {
1:             openDefaultConnection().prepareStatement(forwardSQL),
1:             openDefaultConnection().prepareStatement(forwardSQL),
1:             openDefaultConnection().prepareStatement(backwardSQL),
1:             openDefaultConnection().prepareStatement(backwardSQL),
1:         };
1: 
1:         final Exception[] exceptions = new Exception[pss.length];
1: 
1:         final Thread[] threads = new Thread[pss.length];
1: 
1:         for (int i = 0; i < pss.length; i++) {
1:             final int threadNo = i;
1:             threads[i] = new Thread() {
1:                 public void run() {
1:                     // The forward scan is expected to return all rows in
1:                     // the table, the backward (max) scan only the highest
1:                     // non-null row.
1:                     String[][] expected = (threadNo < 2) ?
1:                             tableContents : new String[][] {{"100"}};
1:                     try {
1:                         for (int j = 0; j < 1000; j++) {
1:                             ResultSet rs = pss[threadNo].executeQuery();
1:                             JDBC.assertFullResultSet(rs, expected);
1:                         }
1:                     } catch (Exception e) {
1:                         exceptions[threadNo] = e;
1:                     }
1:                 }
1:             };
1:             threads[i].start();
1:         }
1: 
1:         for (int i = 0; i < pss.length; i++) {
1:             threads[i].join();
1:             pss[i].getConnection().close();
1:         }
1: 
1:         for (int i = 0; i < exceptions.length; i++) {
1:             if (exceptions[i] != null) {
1:                 throw exceptions[i];
1:             }
1:         }
1: 
1:         dropTable("T");
1:         commit();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test that latch conflicts between forward scans and backward (max) scans
1:      * are resolved without deadlocking or other errors when the rightmost
1:      * leaf page of the B-tree is empty. In that case, the backward scan must
1:      * restart, since it doesn't have any saved position to return to.
1:      * </p>
1:      *
1:      * <p>
1:      * The test is performed by running two threads that scan the leaves of
1:      * the B-tree in the forward direction, while at the same time two threads
1:      * do a backward max scan on the same B-tree. In parallel with the threads
1:      * that scan the index, the main thread will repeatedly delete the rows
1:      * with the highest values in order to create a window where the scans may
1:      * see an empty page, sleep a little, and then re-insert the deleted rows.
1:      * </p>
1:      */
1:     public void testEmptyRightmostLeaf() throws Exception {
1:         // Trace latch conflicts to see that we exercise the code path that
1:         // handles repositioning after waiting for a latch when moving away
1:         // from an empty leaf at the far-right end of the B-tree. When this
1:         // code is exercised, we'll see "Restart scan from rightmost leaf"
1:         // printed to derby.log.
1:         setTraceFlag("BTreeMaxScan.latchConflict");
1: 
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table t(x int)");
1: 
1:         // Insert a couple pages worth of rows.
1:         PreparedStatement ins = prepareStatement("insert into t values ?");
1:         for (int i = 1; i <= 800; i++) {
1:             ins.setInt(1, i);
1:             ins.executeUpdate();
1:         }
1: 
1:         s.execute("create index i on t(x)");
1: 
1:         commit();
1: 
1:         // Now start four threads. Two scanning the B-tree in the forward
1:         // direction, and two scanning in the backward direction (max scans).
1:         // These threads should not interfere with each other.
1:         String forwardSQL = "select x from t --derby-properties index=i";
1:         String backwardSQL = "select max(x) from t --derby-properties index=i";
1: 
1:         final PreparedStatement[] pss = {
1:             openDefaultConnection().prepareStatement(forwardSQL),
1:             openDefaultConnection().prepareStatement(forwardSQL),
1:             openDefaultConnection().prepareStatement(backwardSQL),
1:             openDefaultConnection().prepareStatement(backwardSQL),
1:         };
1: 
1:         final Exception[] exceptions = new Exception[pss.length];
1: 
1:         final Thread[] threads = new Thread[pss.length];
1: 
1:         final AtomicInt threadCount = new AtomicInt();
1: 
1:         for (int i = 0; i < pss.length; i++) {
1:             final int threadNo = i;
1:             // Set the isolation level to read uncommitted so that the scans
1:             // don't take any locks. We do this because we want to test latch
1:             // conflicts, and if the scans take read locks, they'll spend most
1:             // of the time waiting for the write thread to release its locks.
1:             pss[i].getConnection().setTransactionIsolation(
1:                     Connection.TRANSACTION_READ_UNCOMMITTED);
1:             threads[i] = new Thread() {
1:                 public void run() {
1:                     try {
1:                         for (int j = 0; j < 1000; j++) {
1:                             ResultSet rs = pss[threadNo].executeQuery();
1:                             if (threadNo < 2) {
1:                                 // This is a full forward scan (SELECT *) of
1:                                 // the B-tree, so expect it to see between 400
1:                                 // and 800 rows.
1:                                 int rowCount = JDBC.assertDrainResults(rs);
1:                                 if (rowCount < 400 || rowCount > 800) {
1:                                     fail("Unexpected row count: " + rowCount);
1:                                 }
1:                             } else {
1:                                 // This is a max scan, so expect a single
1:                                 // row that contains a value between 400 and
1:                                 // 800.
1:                                 assertTrue(rs.next());
1:                                 int max = rs.getInt(1);
1:                                 if (max < 400 || max > 800) {
1:                                     fail("Unexpected max value: " + max);
1:                                 }
1:                                 assertFalse(rs.next());
1:                                 rs.close();
1:                             }
1:                         }
1:                     } catch (Exception e) {
1:                         exceptions[threadNo] = e;
1:                     } finally {
1:                         threadCount.decrement();
1:                     }
1:                 }
1:             };
1:             threads[i].start();
1:             threadCount.increment();
1:         }
1: 
1:         // As long as the scanner threads are running, periodically delete
1:         // and re-insert the last 400 rows. This empties the rightmost leaf
1:         // page(s) and makes it possible for the scanners to encounter the
1:         // situation where they need to reposition after a latch conflict
1:         // while being positioned on an empty page with no saved position. The
1:         // post-commit worker will eventually remove the pointers to the empty
1:         // leaf, so we need to do this repeatedly and hope that the timing
1:         // will be right at least once so that we exercise the desired path.
1:         PreparedStatement deleteRows =
1:                 prepareStatement("delete from t where x > 400");
1:         PreparedStatement insertRows =
1:                 prepareStatement("insert into t select x+400 from t");
1:         while (threadCount.get() > 0) {
1:             // Delete rows in range [401, 800].
1:             assertEquals("deleted rows", 400, deleteRows.executeUpdate());
1:             commit();
1: 
1:             // Sleep a little while so that we don't fill the empty page
1:             // before the scanners have seen it.
1:             Thread.sleep(100L);
1: 
1:             // Re-insert rows in range [401, 800].
1:             assertEquals("inserted rows", 400, insertRows.executeUpdate());
1:             commit();
1:         }
1: 
1:         for (int i = 0; i < pss.length; i++) {
1:             threads[i].join();
1:             pss[i].getConnection().close();
1:         }
1: 
1:         for (int i = 0; i < exceptions.length; i++) {
1:             if (exceptions[i] != null) {
1:                 throw exceptions[i];
1:             }
1:         }
1: 
1:         dropTable("T");
1:         commit();
1:     }
1: 
1:     // HELPER METHODS
1: 
1:     /**
1:      * This class represents a result from an asynchronous operation.
1:      */
1:     private static class Result {
1:         private boolean complete;
1:         private Exception ex;
1:         private String value;
1: 
1:         synchronized void error(Exception ex) {
1:             this.ex = ex;
1:             this.complete = true;
1:             notifyAll();
1:         }
1: 
1:         synchronized void set(String value) {
1:             this.value = value;
1:             this.complete = true;
1:             notifyAll();
1:         }
1: 
1:         synchronized String get() throws Exception {
1:             while (!complete) {
1:                 wait();
1:             }
1:             if (ex != null) {
1:                 throw ex;
1:             } else {
1:                 return value;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Execute a statement asynchronously and return an object that can be
1:      * used to retrieve the result once the statement is complete. The
1:      * statement should return a single value.
1:      *
1:      * @param s the statement object to use for execution
1:      * @param sql the SQL to execute
1:      * @return a {@code Result} object that allows retrieval of the result
1:      * once it's available
1:      */
1:     private static Result asyncGetSingleResult(
1:             final Statement s, final String sql) {
1:         final Result result = new Result();
1: 
1:         Thread t = new Thread() {
1:             public void run() {
1:                 try {
1:                     ResultSet rs = s.executeQuery(sql);
1:                     assertEquals("expected single value",
1:                             1, rs.getMetaData().getColumnCount());
1:                     assertTrue("empty result", rs.next());
1:                     String val = rs.getString(1);
1:                     assertFalse("multiple rows", rs.next());
1:                     rs.close();
1:                     result.set(val);
1:                 } catch (Exception e) {
1:                     result.error(e);
1:                 }
1:             }
1:         };
1: 
1:         t.start();
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * If running with a debug build and derby.tests.trace is true, enable
1:      * tracing for messages with the specified flag.
1:      *
1:      * @param flag the debug flag to enable
1:      */
1:     private void setTraceFlag(String flag) {
1:         if (SanityManager.DEBUG && TestConfiguration.getCurrent().doTrace()) {
1:             SanityManager.DEBUG_PRINT(flag, "Enable tracing for " + getName());
1:             SanityManager.DEBUG_SET(flag);
1:             traceFlags.add(flag);
1:         }
1:     }
1: 
1:     /**
1:      * Poor man's replacement for java.util.concurrent.atomic.AtomicInteger
1:      * that runs on platforms where java.util.concurrent isn't available.
1:      */
1:     private static class AtomicInt {
1:         private int i;
1:         synchronized void increment() {
1:             i++;
1:         }
1:         synchronized void decrement() {
1:             i--;
1:         }
1:         synchronized int get() {
1:             return i;
1:         }
1:     }
1: }
============================================================================