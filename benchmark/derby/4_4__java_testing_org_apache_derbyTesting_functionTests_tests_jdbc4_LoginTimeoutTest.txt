1:25c1e7b: /*
9:25c1e7b:  
1:25c1e7b:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.LoginTimeoutTest
1:25c1e7b: 
1:25c1e7b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:25c1e7b:    contributor license agreements.  See the NOTICE file distributed with
1:25c1e7b:    this work for additional information regarding copyright ownership.
1:25c1e7b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:25c1e7b:    (the "License"); you may not use this file except in compliance with
1:25c1e7b:    the License.  You may obtain a copy of the License at
1:25c1e7b:  
1:25c1e7b:       http://www.apache.org/licenses/LICENSE-2.0
1:25c1e7b:  
1:25c1e7b:    Unless required by applicable law or agreed to in writing, software
1:25c1e7b:    distributed under the License is distributed on an "AS IS" BASIS,
1:25c1e7b:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:25c1e7b:    See the License for the specific language governing permissions and
1:25c1e7b:    limitations under the License.
1:25c1e7b:  
1:25c1e7b:  */
1:25c1e7b: 
1:25c1e7b: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:25c1e7b: 
1:25c1e7b: import java.sql.CallableStatement;
1:25c1e7b: import java.sql.Connection;
1:25c1e7b: import java.sql.DriverManager;
1:25c1e7b: import java.sql.SQLException;
1:25c1e7b: import java.sql.SQLTimeoutException;
1:25c1e7b: import java.util.Properties;
1:25c1e7b: import javax.sql.CommonDataSource;
1:25c1e7b: import javax.sql.ConnectionPoolDataSource;
1:1ae02c9: import javax.sql.DataSource;
1:25c1e7b: import javax.sql.XADataSource;
1:1ae02c9: import junit.framework.Test;
1:25c1e7b: import org.apache.derby.authentication.UserAuthenticator;
1:25c1e7b: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:ddca784: import org.apache.derbyTesting.junit.Derby;
1:25c1e7b: import org.apache.derbyTesting.junit.J2EEDataSource;
1:25c1e7b: import org.apache.derbyTesting.junit.JDBCClient;
1:25c1e7b: import org.apache.derbyTesting.junit.JDBCClientSetup;
1:25c1e7b: import org.apache.derbyTesting.junit.JDBCDataSource;
1:25c1e7b: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:25c1e7b: import org.apache.derbyTesting.junit.TestConfiguration;
1:25c1e7b: 
1:25c1e7b: 
1:25c1e7b: /**
1:25c1e7b:  * Test login timeouts.
1:25c1e7b:  */
1:25c1e7b: 
1:25c1e7b: public class LoginTimeoutTest extends BaseJDBCTestCase
2:25c1e7b: {
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // CONSTANTS
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     private static  final   String[][]    SYSTEM_PROPERTIES =
1:25c1e7b:     {
1:25c1e7b:         { "derby.connection.requireAuthentication", "true" },
1:25c1e7b:         { "derby.authentication.provider", LoginTimeoutTest.class.getName() + "$SluggishAuthenticator" },
1:25c1e7b:     };
1:25c1e7b: 
1:25c1e7b:     private static  final   boolean SUCCEED = true;
1:25c1e7b:     private static  final   boolean FAIL = false;
1:25c1e7b: 
1:2520683:     private static  final   int LONG_TIMEOUT = 10;
1:2520683: 
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // STATE
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     private static  final   String      RUTH = "RUTH";
1:25c1e7b:     private static  final   String      RUTH_PASSWORD = "RUTHPASSWORD";
1:25c1e7b: 
1:25c1e7b:     private static  final   String      LOGIN_TIMEOUT = "XBDA0";
1:25c1e7b:     private static  final   String      LOGIN_FAILED = "08004";
1:25c1e7b: 
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // NESTED CLASSES
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     /** User authenticator which sleeps for a while */
1:25c1e7b:     public  static  final   class   SluggishAuthenticator   implements  UserAuthenticator
1:25c1e7b:     {
1:2520683:         public  static  boolean debugPrinting = false;
1:2520683:         
1:25c1e7b:         private static  final   long    MILLIS_PER_SECOND = 1000L;
1:25c1e7b:         
1:25c1e7b:         public  static  long    secondsToSleep = 2;
1:25c1e7b:         public  static  boolean returnValue = true;
1:25c1e7b:         
1:25c1e7b:         public  SluggishAuthenticator() {}
1:25c1e7b:     
1:25c1e7b:         public boolean authenticateUser
1:25c1e7b:             (
1:25c1e7b:              String userName,
1:25c1e7b:              String userPassword,
1:25c1e7b:              String databaseName,
1:25c1e7b:              Properties info
1:25c1e7b:              )
1:25c1e7b:             throws SQLException
1:25c1e7b:         {
1:25c1e7b:             // sleepy...
1:25c1e7b:             try {
1:2520683:                 long    sleepTime = secondsToSleep * MILLIS_PER_SECOND;
1:2520683:                 printText( "SluggishAuthenticator going to sleep for " + sleepTime + " milliseconds." );
1:25c1e7b:                 Thread.sleep( secondsToSleep * MILLIS_PER_SECOND );
1:2520683:                 printText( "...SluggishAuthenticator waking up after " + sleepTime + " milliseconds." );
1:25c1e7b:             } catch (Exception e) { throw new SQLException( e.getMessage(), e ); }
1:25c1e7b: 
1:25c1e7b:             // ...and vacuous.
1:25c1e7b:             return returnValue;
3:25c1e7b:         }
1:2520683:         
1:2520683:         private static  void    printText( String text )
1:2520683:         {
1:2520683:             if ( debugPrinting )
1:2520683:             {
1:2520683:                 BaseTestCase.println( text );
1:2520683:             }
1:2520683:         }
1:25c1e7b:     }
1:2520683: 
1:25c1e7b:     /** Behavior shared by DataSource and DriverManager */
1:25c1e7b:     public  static  interface   Connector
1:2520683:     {
1:25c1e7b:         public  Connection  getConnection( String user, String password ) throws SQLException;
1:25c1e7b: 
1:25c1e7b:         public  void    setLoginTimeout( int seconds ) throws SQLException;
1:25c1e7b:     }
1:25c1e7b: 
1:25c1e7b:     public  static  final   class   DriverManagerConnector  implements Connector
1:25c1e7b:     {
1:25c1e7b:         private BaseJDBCTestCase    _test;
1:25c1e7b: 
1:25c1e7b:         public  DriverManagerConnector( BaseJDBCTestCase test ) { _test = test; }
1:25c1e7b: 
1:25c1e7b:         public  Connection  getConnection( String user, String password ) throws SQLException
1:25c1e7b:         {
1:25c1e7b:             return _test.openDefaultConnection( user, password );
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         public  void    setLoginTimeout( int seconds ) { DriverManager.setLoginTimeout( seconds ); }
1:25c1e7b: 
1:25c1e7b:         public  String  toString()  { return "DriverManagerConnector"; }
1:25c1e7b:     }
1:25c1e7b:     
1:25c1e7b:     public  static  final   class   DataSourceConnector  implements Connector
1:25c1e7b:     {
1:25c1e7b:         private CommonDataSource  _dataSource;
1:25c1e7b: 
1:25c1e7b:         public  DataSourceConnector( CommonDataSource dataSource )
1:25c1e7b:         {
1:25c1e7b:             _dataSource = dataSource;
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         public  Connection  getConnection( String user, String password ) throws SQLException
1:25c1e7b:         {
1:25c1e7b:             if ( _dataSource instanceof DataSource )
1:25c1e7b:             {
1:25c1e7b:                 return ((DataSource) _dataSource).getConnection( user, password );
1:25c1e7b:             }
1:25c1e7b:             else if ( _dataSource instanceof ConnectionPoolDataSource )
1:25c1e7b:             {
1:25c1e7b:                 return ((ConnectionPoolDataSource) _dataSource).getPooledConnection( user, password ).getConnection();
1:25c1e7b:             }
1:25c1e7b:             else if ( _dataSource instanceof XADataSource )
1:25c1e7b:             {
1:25c1e7b:                 return ((XADataSource) _dataSource).getXAConnection( user, password ).getConnection();
1:25c1e7b:             }
1:25c1e7b:             else { throw new SQLException( "Unknown data source type: " + _dataSource.getClass().getName() ); }
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         public  void    setLoginTimeout( int seconds ) throws SQLException
1:25c1e7b:         { _dataSource.setLoginTimeout( seconds ); }
1:25c1e7b: 
1:25c1e7b:         public  String  toString()
1:25c1e7b:         {
1:25c1e7b:             return "DataSourceConnector( " + _dataSource.getClass().getName() + " )";
1:25c1e7b:         }
1:25c1e7b:     }
1:25c1e7b: 
1:2520683:     ///////////////////////////////////////////////////////////////////////////////////
1:2520683:     //
1:25c1e7b:     // CONSTRUCTORS
1:2520683:     //
1:2520683:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     /**
1:25c1e7b:      *
1:25c1e7b:      * Create a test with the given name.
1:25c1e7b:      */
1:25c1e7b:     public LoginTimeoutTest(String name) { super(name); }
1:25c1e7b:     
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // JUnit MACHINERY
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     
1:25c1e7b:     /**
1:25c1e7b:      * Return suite with all tests of the class.
1:25c1e7b:      */
1:25c1e7b:     public static Test suite()
1:25c1e7b:     {
1:1ae02c9:         BaseTestSuite  suite = new BaseTestSuite();
1:25c1e7b: 
1:1ae02c9:         Test embedded = new BaseTestSuite(
1:1ae02c9:             LoginTimeoutTest.class, "embedded LoginTimeoutTest" );
1:1ae02c9: 
1:25c1e7b:         embedded = TestConfiguration.singleUseDatabaseDecorator( embedded );
1:25c1e7b:         embedded = new SystemPropertyTestSetup( embedded, systemProperties() );
1:25c1e7b:         suite.addTest( embedded );
1:ddca784: 
1:ddca784:         if (Derby.hasServer() && Derby.hasClient()) {
1:1ae02c9:             Test clientServer = new BaseTestSuite(
1:ddca784:                     LoginTimeoutTest.class, "client/server LoginTimeoutTest");
1:ddca784:             clientServer =
1:ddca784:                     TestConfiguration.singleUseDatabaseDecorator(clientServer);
1:ddca784:             clientServer = new JDBCClientSetup(
1:ddca784:                     clientServer, JDBCClient.DERBYNETCLIENT);
1:ddca784:             clientServer = new NetworkServerTestSetup(clientServer,
1:ddca784:                     systemPropertiesArray(), new String[]{}, true);
1:ddca784:             suite.addTest(clientServer);
1:ddca784:         }
1:25c1e7b: 
1:25c1e7b:         return suite;
1:25c1e7b:     }
1:25c1e7b:     private static  Properties  systemProperties()
1:25c1e7b:     {
1:25c1e7b:         Properties  props = new Properties();
1:25c1e7b: 
1:25c1e7b:         for ( int i = 0; i < SYSTEM_PROPERTIES.length; i++ )
1:25c1e7b:         {
1:25c1e7b:             String[]    raw = SYSTEM_PROPERTIES[ i ];
1:25c1e7b: 
1:25c1e7b:             props.put( raw[ 0 ], raw[ 1 ] );
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         return props;
1:25c1e7b:     }
1:25c1e7b:     private static  String[]    systemPropertiesArray()
1:25c1e7b:     {
1:25c1e7b:         String[]    result = new String[ SYSTEM_PROPERTIES.length ];
1:25c1e7b: 
1:25c1e7b:         for ( int i = 0; i < SYSTEM_PROPERTIES.length; i++ )
1:25c1e7b:         {
1:25c1e7b:             String[]    raw = SYSTEM_PROPERTIES[ i ];
1:25c1e7b: 
1:25c1e7b:             result[ i ] = raw[ 0 ] + "=" + raw[ 1 ];
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         return result;
1:25c1e7b:     }
1:25c1e7b:     
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // TESTS
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     /**
1:25c1e7b:      * Basic test of login timeouts.
1:25c1e7b:      */
1:25c1e7b:     public  void    testBasic() throws Exception
1:25c1e7b:     {
1:2520683:         SluggishAuthenticator.debugPrinting = TestConfiguration.getCurrent().isVerbose();
1:2520683: 
1:2520683:         // make sure the database is created in order to eliminate asymmetries
1:2520683:         // in running the tests
1:f63235d:         Connection  conn = openDefaultConnection( RUTH, RUTH_PASSWORD );
1:f63235d:         conn.close();
1:25c1e7b:         
1:25c1e7b:         vetConnector( new DriverManagerConnector( this ), true );
1:25c1e7b:         vetConnector( new DataSourceConnector( JDBCDataSource.getDataSource() ), true );
1:25c1e7b:         vetConnector( new DataSourceConnector( J2EEDataSource.getConnectionPoolDataSource() ), true );
1:25c1e7b:         vetConnector( new DataSourceConnector( J2EEDataSource.getXADataSource() ), true );
1:25c1e7b: 
1:25c1e7b:         if ( usingEmbedded() ) { vetExceptionPassthrough(); }
1:25c1e7b:         if ( usingDerbyNetClient() ) { vetServerTimeouts(); }
1:25c1e7b:     }
1:25c1e7b:     private void    vetConnector( Connector connector, boolean shouldSucceed ) throws Exception
1:25c1e7b:     {
1:2520683:         try {
1:6e6ee8d:             // sometimes this succeeds when we expect not, see DERBY-6250,
1:6e6ee8d:             // give more time to the slug sleep
1:6e6ee8d:             if (usingEmbedded())
1:6e6ee8d:                 SluggishAuthenticator.secondsToSleep = 4;
1:2520683:             tryTimeout( connector, 1, FAIL && shouldSucceed );
1:6e6ee8d:             // set back.
1:6e6ee8d:             if (usingEmbedded())
1:6e6ee8d:                 SluggishAuthenticator.secondsToSleep = 2;
1:2520683:             tryTimeout( connector, LONG_TIMEOUT, SUCCEED && shouldSucceed );
1:2520683:             tryTimeout( connector, 0, SUCCEED && shouldSucceed );
1:2520683:         }
1:2520683:         finally
1:2520683:         {
1:2520683:             // revert to default state
1:2520683:             connector.setLoginTimeout( 0 );
1:6e6ee8d:             // set sluggishauthenticator sleep back
1:6e6ee8d:             SluggishAuthenticator.secondsToSleep = 2;
1:2520683:         }
1:25c1e7b:     }
1:2520683:     private void    tryTimeout( Connector connector, int timeout, boolean shouldSucceed ) throws Exception
1:25c1e7b:     {
1:25c1e7b:         println( "Setting timeout " + timeout + " on " + connector );
1:25c1e7b:         connector.setLoginTimeout( timeout );
1:25c1e7b: 
1:25c1e7b:         tryTimeout( connector, shouldSucceed );
1:25c1e7b:     }
1:2520683:     private void    tryTimeout( Connector connector, boolean shouldSucceed ) throws Exception
1:25c1e7b:     {
1:25c1e7b:         long    startTime = System.currentTimeMillis();
1:25c1e7b:         
1:25c1e7b:         try {
1:25c1e7b:             Connection  conn = connector.getConnection( RUTH, RUTH_PASSWORD );
1:25c1e7b:             println( "    Got a " + conn.getClass().getName() );
1:f63235d:             conn.close();
1:6e6ee8d:             if ( !shouldSucceed )   
1:6e6ee8d:             {
1:6e6ee8d:                 // sometimes the connect succeeds, see DERBY-6250. 
1:6e6ee8d:                 // adding more details to fail message.
1:6e6ee8d:                 long    duration = System.currentTimeMillis() - startTime;
1:6e6ee8d:                 String message ="Should not have been able to connect! \n " +
1:6e6ee8d:                 "        connector: " + connector +
1:6e6ee8d:                 "        Experiment took " + duration + " milliseconds. \n " +
1:6e6ee8d:                 "        seconds sleep time was: " + SluggishAuthenticator.secondsToSleep;
1:6e6ee8d:                 fail( message ); 
1:6e6ee8d:             }
1:25c1e7b:         }
1:25c1e7b:         catch (SQLException se)
1:25c1e7b:         {
1:f63235d:             if ( shouldSucceed ) { fail( "Should have been able to connect!", se ); }
1:25c1e7b: 
1:25c1e7b:             assertTrue( "Didn't expect to see a " + se.getClass().getName(), (se instanceof SQLTimeoutException) );
1:25c1e7b:             assertSQLState( LOGIN_TIMEOUT, se );
1:25c1e7b:         }
1:25c1e7b: 
1:25c1e7b:         long    duration = System.currentTimeMillis() - startTime;
1:25c1e7b: 
1:25c1e7b:         println( "        Experiment took " + duration + " milliseconds." );
1:25c1e7b:     }
1:25c1e7b:     private void    vetExceptionPassthrough() throws Exception
1:25c1e7b:     {
1:25c1e7b:         try {
1:2520683:             println( "Verifying that exceptions are not swallowed by the embedded login timer." );
1:2520683:             // set a long timeout which we won't exceed
1:2520683:             DriverManager.setLoginTimeout( LONG_TIMEOUT );
1:25c1e7b: 
1:2520683:             // tell the authenticator to always fail
1:2520683:             SluggishAuthenticator.returnValue = false;
1:2520683: 
1:2520683:             try {
1:f63235d:                 Connection conn = openDefaultConnection( RUTH, RUTH_PASSWORD );
1:f63235d:                 conn.close();
1:2520683:                 fail( "Didn't expect to get a connection!" );
1:2520683:             }
1:2520683:             catch (SQLException se) { assertSQLState( LOGIN_FAILED, se ); }
1:2520683:         }
1:2520683:         finally
1:2520683:         {
1:2520683:             // return to default position
1:2520683:             DriverManager.setLoginTimeout( 0 );
1:2520683:             SluggishAuthenticator.returnValue = true;
1:2520683:         }
1:25c1e7b:     }
1:25c1e7b:     private void    vetServerTimeouts() throws Exception
1:25c1e7b:     {
1:25c1e7b:         println( "Verifying behavior when timeouts are also set on the server." );
1:25c1e7b: 
1:25c1e7b:         Connection  controlConnection = openDefaultConnection( RUTH, RUTH_PASSWORD );
1:25c1e7b: 
1:25c1e7b:         // create a procedure for changing the login timeout on the server
1:25c1e7b:         String  createProc = 
1:25c1e7b:             "create procedure setLoginTimeout( timeout int ) language java parameter style java no sql\n" +
1:25c1e7b:             "external name '" + getClass().getName() + ".setLoginTimeout'";
1:25c1e7b:         println( createProc );
1:25c1e7b:         controlConnection.prepareStatement( createProc ).execute();
1:6e6ee8d:         createProc = 
1:6e6ee8d:                 "create procedure setAuthenticatorSleep( seconds int ) language java parameter style java no sql\n" +
1:6e6ee8d:                 "external name '" + getClass().getName() + ".setAuthenticatorSleep'";
1:6e6ee8d:         controlConnection.prepareStatement( createProc ).execute();
1:6e6ee8d:         println( createProc );
1:25c1e7b: 
1:25c1e7b:         Connector   connector = new DriverManagerConnector( this );
1:25c1e7b: 
1:25c1e7b:         vetServerTimeout( controlConnection, connector, 1, FAIL );
1:2520683:         vetServerTimeout( controlConnection, connector, LONG_TIMEOUT, SUCCEED );
1:25c1e7b:         vetServerTimeout( controlConnection, connector, 0, SUCCEED );
1:25c1e7b: 
1:25c1e7b:         // reset server timeout to default
1:25c1e7b:         setServerTimeout( controlConnection, 0 );
1:f63235d:         controlConnection.close();
1:25c1e7b:     }
1:25c1e7b:     private void    vetServerTimeout
1:25c1e7b:         ( Connection controlConnection, Connector connector, int serverTimeout, boolean shouldSucceed )
1:25c1e7b:         throws Exception
1:25c1e7b:     {
1:25c1e7b:         setServerTimeout( controlConnection, serverTimeout );
1:6e6ee8d:         // Sometimes we get an unexpected connection when we expect
1:6e6ee8d:         // the timeout to work, see DERBY-6250.
1:6e6ee8d:         // Setting the sleep Authenticator sleep time longer on the server.
1:6e6ee8d:         // for those cases to make the chance of this occurring smaller.
1:6e6ee8d:         if (!shouldSucceed)
1:6e6ee8d:             setServerAuthenticatorSleep(controlConnection, 4);
1:6e6ee8d:         else 
1:6e6ee8d:             setServerAuthenticatorSleep(controlConnection, 2);
1:25c1e7b:         vetConnector( connector, shouldSucceed );
1:25c1e7b:     }
1:25c1e7b:     private void    setServerTimeout( Connection conn, int seconds ) throws Exception
1:25c1e7b:     {
1:25c1e7b:         CallableStatement   cs = conn.prepareCall( "call setLoginTimeout( ? )" );
1:25c1e7b:         cs.setInt( 1, seconds );
1:25c1e7b:         cs.execute();
1:25c1e7b:         cs.close();
1:25c1e7b:     }
1:25c1e7b:     
1:6e6ee8d:     private void    setServerAuthenticatorSleep( Connection conn, int seconds )
1:6e6ee8d:             throws Exception
1:6e6ee8d:     {
1:6e6ee8d:         CallableStatement   cs = conn.prepareCall( "call setAuthenticatorSleep( ? )" );
1:6e6ee8d:         cs.setInt( 1, seconds );
1:6e6ee8d:         cs.execute();
1:6e6ee8d:         cs.close();
1:6e6ee8d:     }
1:6e6ee8d:     
1:6e6ee8d:     
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:25c1e7b:     // SQL ROUTINES
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b: 
1:25c1e7b:     /** Routine to set the DriverManager login timeout on the server */
1:25c1e7b:     public  static  void    setLoginTimeout( int seconds ) throws Exception
1:25c1e7b:     {
1:25c1e7b:         DriverManager.setLoginTimeout( seconds );
1:2520683:     }
1:25c1e7b:     
1:6e6ee8d:     /** Routine to set the SluggishAuthenticator Sleep 
1:6e6ee8d:      *  time on the server */
1:6e6ee8d:     public  static  void    setAuthenticatorSleep( int seconds ) throws Exception
1:6e6ee8d:     {
1:6e6ee8d:         SluggishAuthenticator.secondsToSleep = seconds ;
1:6e6ee8d:     }
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:25c1e7b:     //
1:2520683:     // MINIONS
1:25c1e7b:     //
1:25c1e7b:     ///////////////////////////////////////////////////////////////////////////////////
1:2520683: 
1:25c1e7b: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite  suite = new BaseTestSuite();
1:         Test embedded = new BaseTestSuite(
1:             LoginTimeoutTest.class, "embedded LoginTimeoutTest" );
1: 
1:             Test clientServer = new BaseTestSuite(
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:6e6ee8d
/////////////////////////////////////////////////////////////////////////
1:             // sometimes this succeeds when we expect not, see DERBY-6250,
1:             // give more time to the slug sleep
1:             if (usingEmbedded())
1:                 SluggishAuthenticator.secondsToSleep = 4;
1:             // set back.
1:             if (usingEmbedded())
1:                 SluggishAuthenticator.secondsToSleep = 2;
/////////////////////////////////////////////////////////////////////////
1:             // set sluggishauthenticator sleep back
1:             SluggishAuthenticator.secondsToSleep = 2;
/////////////////////////////////////////////////////////////////////////
1:             if ( !shouldSucceed )   
1:             {
1:                 // sometimes the connect succeeds, see DERBY-6250. 
1:                 // adding more details to fail message.
1:                 long    duration = System.currentTimeMillis() - startTime;
1:                 String message ="Should not have been able to connect! \n " +
1:                 "        connector: " + connector +
1:                 "        Experiment took " + duration + " milliseconds. \n " +
1:                 "        seconds sleep time was: " + SluggishAuthenticator.secondsToSleep;
1:                 fail( message ); 
1:             }
/////////////////////////////////////////////////////////////////////////
1:         createProc = 
1:                 "create procedure setAuthenticatorSleep( seconds int ) language java parameter style java no sql\n" +
1:                 "external name '" + getClass().getName() + ".setAuthenticatorSleep'";
1:         controlConnection.prepareStatement( createProc ).execute();
1:         println( createProc );
/////////////////////////////////////////////////////////////////////////
1:         // Sometimes we get an unexpected connection when we expect
1:         // the timeout to work, see DERBY-6250.
1:         // Setting the sleep Authenticator sleep time longer on the server.
1:         // for those cases to make the chance of this occurring smaller.
1:         if (!shouldSucceed)
1:             setServerAuthenticatorSleep(controlConnection, 4);
1:         else 
1:             setServerAuthenticatorSleep(controlConnection, 2);
/////////////////////////////////////////////////////////////////////////
1:     private void    setServerAuthenticatorSleep( Connection conn, int seconds )
1:             throws Exception
1:     {
1:         CallableStatement   cs = conn.prepareCall( "call setAuthenticatorSleep( ? )" );
1:         cs.setInt( 1, seconds );
1:         cs.execute();
1:         cs.close();
1:     }
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:     /** Routine to set the SluggishAuthenticator Sleep 
1:      *  time on the server */
1:     public  static  void    setAuthenticatorSleep( int seconds ) throws Exception
1:     {
1:         SluggishAuthenticator.secondsToSleep = seconds ;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ddca784
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.Derby;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (Derby.hasServer() && Derby.hasClient()) {
0:             Test clientServer = new TestSuite(
1:                     LoginTimeoutTest.class, "client/server LoginTimeoutTest");
1:             clientServer =
1:                     TestConfiguration.singleUseDatabaseDecorator(clientServer);
1:             clientServer = new JDBCClientSetup(
1:                     clientServer, JDBCClient.DERBYNETCLIENT);
1:             clientServer = new NetworkServerTestSetup(clientServer,
1:                     systemPropertiesArray(), new String[]{}, true);
1:             suite.addTest(clientServer);
1:         }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f63235d
/////////////////////////////////////////////////////////////////////////
1:         Connection  conn = openDefaultConnection( RUTH, RUTH_PASSWORD );
1:         conn.close();
/////////////////////////////////////////////////////////////////////////
1:             conn.close();
1:             if ( shouldSucceed ) { fail( "Should have been able to connect!", se ); }
/////////////////////////////////////////////////////////////////////////
1:                 Connection conn = openDefaultConnection( RUTH, RUTH_PASSWORD );
1:                 conn.close();
/////////////////////////////////////////////////////////////////////////
1:         controlConnection.close();
/////////////////////////////////////////////////////////////////////////
commit:2520683
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseTestCase;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   int LONG_TIMEOUT = 10;
1: 
/////////////////////////////////////////////////////////////////////////
1:         public  static  boolean debugPrinting = false;
1:         
/////////////////////////////////////////////////////////////////////////
1:                 long    sleepTime = secondsToSleep * MILLIS_PER_SECOND;
1:                 printText( "SluggishAuthenticator going to sleep for " + sleepTime + " milliseconds." );
1:                 printText( "...SluggishAuthenticator waking up after " + sleepTime + " milliseconds." );
1:         
1:         private static  void    printText( String text )
1:         {
1:             if ( debugPrinting )
1:             {
1:                 BaseTestCase.println( text );
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         SluggishAuthenticator.debugPrinting = TestConfiguration.getCurrent().isVerbose();
1: 
1:         // make sure the database is created in order to eliminate asymmetries
1:         // in running the tests
0:         openDefaultConnection( RUTH, RUTH_PASSWORD );
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             tryTimeout( connector, 1, FAIL && shouldSucceed );
1:             tryTimeout( connector, LONG_TIMEOUT, SUCCEED && shouldSucceed );
1:             tryTimeout( connector, 0, SUCCEED && shouldSucceed );
1:         }
1:         finally
1:         {
1:             // revert to default state
1:             connector.setLoginTimeout( 0 );
1:         }
1:     private void    tryTimeout( Connector connector, int timeout, boolean shouldSucceed ) throws Exception
1:     private void    tryTimeout( Connector connector, boolean shouldSucceed ) throws Exception
/////////////////////////////////////////////////////////////////////////
0:             if ( shouldSucceed ) { failWithTrace( se, "Should have been able to connect!" ); }
/////////////////////////////////////////////////////////////////////////
1:             println( "Verifying that exceptions are not swallowed by the embedded login timer." );
1:             // set a long timeout which we won't exceed
1:             DriverManager.setLoginTimeout( LONG_TIMEOUT );
1:             // tell the authenticator to always fail
1:             SluggishAuthenticator.returnValue = false;
1: 
1:             try {
0:                 openDefaultConnection( RUTH, RUTH_PASSWORD );
1:                 fail( "Didn't expect to get a connection!" );
1:             }
1:             catch (SQLException se) { assertSQLState( LOGIN_FAILED, se ); }
1:         }
1:         finally
1:         {
1:             // return to default position
1:             DriverManager.setLoginTimeout( 0 );
1:             SluggishAuthenticator.returnValue = true;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         vetServerTimeout( controlConnection, connector, LONG_TIMEOUT, SUCCEED );
/////////////////////////////////////////////////////////////////////////
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0:     /** Fail and print a stack trace */
0:     private static void    failWithTrace( Throwable t, String message )
1:     {
0:         printStackTrace( t );
0:         fail( message );
1:     }
1: 
commit:25c1e7b
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.LoginTimeoutTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.SQLTimeoutException;
1: import java.util.Properties;
0: import javax.sql.DataSource;
1: import javax.sql.CommonDataSource;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.XADataSource;
1: 
0: import junit.framework.*;
1: 
1: import org.apache.derby.authentication.UserAuthenticator;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBCClient;
1: import org.apache.derbyTesting.junit.JDBCClientSetup;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
1:  * Test login timeouts.
1:  */
1: 
1: public class LoginTimeoutTest extends BaseJDBCTestCase
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String[][]    SYSTEM_PROPERTIES =
1:     {
1:         { "derby.connection.requireAuthentication", "true" },
1:         { "derby.authentication.provider", LoginTimeoutTest.class.getName() + "$SluggishAuthenticator" },
1:     };
1: 
1:     private static  final   boolean SUCCEED = true;
1:     private static  final   boolean FAIL = false;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String      RUTH = "RUTH";
1:     private static  final   String      RUTH_PASSWORD = "RUTHPASSWORD";
1: 
1:     private static  final   String      LOGIN_TIMEOUT = "XBDA0";
1:     private static  final   String      LOGIN_FAILED = "08004";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** User authenticator which sleeps for a while */
1:     public  static  final   class   SluggishAuthenticator   implements  UserAuthenticator
1:     {
1:         private static  final   long    MILLIS_PER_SECOND = 1000L;
1:         
1:         public  static  long    secondsToSleep = 2;
1:         public  static  boolean returnValue = true;
1:         
1:         public  SluggishAuthenticator() {}
1:     
1:         public boolean authenticateUser
1:             (
1:              String userName,
1:              String userPassword,
1:              String databaseName,
1:              Properties info
1:              )
1:             throws SQLException
1:         {
1:             // sleepy...
1:             try {
1:                 Thread.sleep( secondsToSleep * MILLIS_PER_SECOND );
1:             } catch (Exception e) { throw new SQLException( e.getMessage(), e ); }
1: 
1:             // ...and vacuous.
1:             return returnValue;
1:         }
1:     }
1: 
1:     /** Behavior shared by DataSource and DriverManager */
1:     public  static  interface   Connector
1:     {
1:         public  Connection  getConnection( String user, String password ) throws SQLException;
1: 
1:         public  void    setLoginTimeout( int seconds ) throws SQLException;
1:     }
1: 
1:     public  static  final   class   DriverManagerConnector  implements Connector
1:     {
1:         private BaseJDBCTestCase    _test;
1: 
1:         public  DriverManagerConnector( BaseJDBCTestCase test ) { _test = test; }
1: 
1:         public  Connection  getConnection( String user, String password ) throws SQLException
1:         {
1:             return _test.openDefaultConnection( user, password );
1:         }
1: 
1:         public  void    setLoginTimeout( int seconds ) { DriverManager.setLoginTimeout( seconds ); }
1: 
1:         public  String  toString()  { return "DriverManagerConnector"; }
1:     }
1:     
1:     public  static  final   class   DataSourceConnector  implements Connector
1:     {
1:         private CommonDataSource  _dataSource;
1: 
1:         public  DataSourceConnector( CommonDataSource dataSource )
1:         {
1:             _dataSource = dataSource;
1:         }
1: 
1:         public  Connection  getConnection( String user, String password ) throws SQLException
1:         {
1:             if ( _dataSource instanceof DataSource )
1:             {
1:                 return ((DataSource) _dataSource).getConnection( user, password );
1:             }
1:             else if ( _dataSource instanceof ConnectionPoolDataSource )
1:             {
1:                 return ((ConnectionPoolDataSource) _dataSource).getPooledConnection( user, password ).getConnection();
1:             }
1:             else if ( _dataSource instanceof XADataSource )
1:             {
1:                 return ((XADataSource) _dataSource).getXAConnection( user, password ).getConnection();
1:             }
1:             else { throw new SQLException( "Unknown data source type: " + _dataSource.getClass().getName() ); }
1:         }
1: 
1:         public  void    setLoginTimeout( int seconds ) throws SQLException
1:         { _dataSource.setLoginTimeout( seconds ); }
1: 
1:         public  String  toString()
1:         {
1:             return "DataSourceConnector( " + _dataSource.getClass().getName() + " )";
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTORS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      *
1:      * Create a test with the given name.
1:      */
1:     public LoginTimeoutTest(String name) { super(name); }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit MACHINERY
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return suite with all tests of the class.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite   suite = new TestSuite();
1: 
0:         Test    embedded = new TestSuite( LoginTimeoutTest.class, "embedded LoginTimeoutTest" );
1:         embedded = TestConfiguration.singleUseDatabaseDecorator( embedded );
1:         embedded = new SystemPropertyTestSetup( embedded, systemProperties() );
1:         suite.addTest( embedded );
1:         
0:         Test    clientServer = new TestSuite( LoginTimeoutTest.class, "client/server LoginTimeoutTest" );
0:         clientServer = TestConfiguration.singleUseDatabaseDecorator( clientServer );
0:         clientServer = new JDBCClientSetup( clientServer, JDBCClient.DERBYNETCLIENT );
0:         clientServer = new NetworkServerTestSetup( clientServer, systemPropertiesArray(), new String[]{}, true );
0:         suite.addTest( clientServer );
1: 
1:         return suite;
1:     }
1:     private static  Properties  systemProperties()
1:     {
1:         Properties  props = new Properties();
1: 
1:         for ( int i = 0; i < SYSTEM_PROPERTIES.length; i++ )
1:         {
1:             String[]    raw = SYSTEM_PROPERTIES[ i ];
1: 
1:             props.put( raw[ 0 ], raw[ 1 ] );
1:         }
1: 
1:         return props;
1:     }
1:     private static  String[]    systemPropertiesArray()
1:     {
1:         String[]    result = new String[ SYSTEM_PROPERTIES.length ];
1: 
1:         for ( int i = 0; i < SYSTEM_PROPERTIES.length; i++ )
1:         {
1:             String[]    raw = SYSTEM_PROPERTIES[ i ];
1: 
1:             result[ i ] = raw[ 0 ] + "=" + raw[ 1 ];
1:         }
1: 
1:         return result;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Basic test of login timeouts.
1:      */
1:     public  void    testBasic() throws Exception
1:     {
0:         DataSource  ds = JDBCDataSource.getDataSource();
1:         
1:         vetConnector( new DriverManagerConnector( this ), true );
1:         vetConnector( new DataSourceConnector( JDBCDataSource.getDataSource() ), true );
1:         vetConnector( new DataSourceConnector( J2EEDataSource.getConnectionPoolDataSource() ), true );
1:         vetConnector( new DataSourceConnector( J2EEDataSource.getXADataSource() ), true );
1: 
1:         if ( usingEmbedded() ) { vetExceptionPassthrough(); }
1:         if ( usingDerbyNetClient() ) { vetServerTimeouts(); }
1:     }
1:     private void    vetConnector( Connector connector, boolean shouldSucceed ) throws Exception
1:     {
0:         tryTimeout( connector, 1, FAIL && shouldSucceed );
0:         tryTimeout( connector, 10, SUCCEED && shouldSucceed );
0:         tryTimeout( connector, 0, SUCCEED && shouldSucceed );
1: 
0:         // revert to default state
0:         connector.setLoginTimeout( 0 );
1:     }
0:     private static  void    tryTimeout( Connector connector, int timeout, boolean shouldSucceed ) throws Exception
1:     {
1:         println( "Setting timeout " + timeout + " on " + connector );
1:         connector.setLoginTimeout( timeout );
1: 
1:         tryTimeout( connector, shouldSucceed );
1:     }
0:     private static  void    tryTimeout( Connector connector, boolean shouldSucceed ) throws Exception
1:     {
1:         long    startTime = System.currentTimeMillis();
1:         
1:         try {
1:             Connection  conn = connector.getConnection( RUTH, RUTH_PASSWORD );
1:             println( "    Got a " + conn.getClass().getName() );
0:             if ( !shouldSucceed )   { fail( "Should not have been able to connect!" ); }
1:         }
1:         catch (SQLException se)
1:         {
0:             if ( shouldSucceed ) { fail( "Should have been able to connect!" ); }
1: 
1:             assertTrue( "Didn't expect to see a " + se.getClass().getName(), (se instanceof SQLTimeoutException) );
1:             assertSQLState( LOGIN_TIMEOUT, se );
1:         }
1: 
1:         long    duration = System.currentTimeMillis() - startTime;
1: 
1:         println( "        Experiment took " + duration + " milliseconds." );
1:     }
1:     private void    vetExceptionPassthrough() throws Exception
1:     {
0:         println( "Verifying that exceptions are not swallowed by the embedded login timer." );
0:         // set a long timeout which we won't exceed
0:         DriverManager.setLoginTimeout( 10 );
1: 
0:         // tell the authenticator to always fail
0:         SluggishAuthenticator.returnValue = false;
1: 
1:         try {
0:             openDefaultConnection( RUTH, RUTH_PASSWORD );
0:             fail( "Didn't expect to get a connection!" );
1:         }
0:         catch (SQLException se) { assertSQLState( LOGIN_FAILED, se ); }
1: 
0:         // return to default position
0:         DriverManager.setLoginTimeout( 0 );
0:         SluggishAuthenticator.returnValue = true;
1:     }
1:     private void    vetServerTimeouts() throws Exception
1:     {
1:         println( "Verifying behavior when timeouts are also set on the server." );
1: 
1:         Connection  controlConnection = openDefaultConnection( RUTH, RUTH_PASSWORD );
1: 
1:         // create a procedure for changing the login timeout on the server
1:         String  createProc = 
1:             "create procedure setLoginTimeout( timeout int ) language java parameter style java no sql\n" +
1:             "external name '" + getClass().getName() + ".setLoginTimeout'";
1:         println( createProc );
1:         controlConnection.prepareStatement( createProc ).execute();
1: 
1:         Connector   connector = new DriverManagerConnector( this );
1: 
1:         vetServerTimeout( controlConnection, connector, 1, FAIL );
0:         vetServerTimeout( controlConnection, connector, 10, SUCCEED );
1:         vetServerTimeout( controlConnection, connector, 0, SUCCEED );
1: 
1:         // reset server timeout to default
1:         setServerTimeout( controlConnection, 0 );
1:     }
1:     private void    vetServerTimeout
1:         ( Connection controlConnection, Connector connector, int serverTimeout, boolean shouldSucceed )
1:         throws Exception
1:     {
1:         setServerTimeout( controlConnection, serverTimeout );
1:         vetConnector( connector, shouldSucceed );
1:     }
1:     private void    setServerTimeout( Connection conn, int seconds ) throws Exception
1:     {
1:         CallableStatement   cs = conn.prepareCall( "call setLoginTimeout( ? )" );
1:         cs.setInt( 1, seconds );
1:         cs.execute();
1:         cs.close();
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // SQL ROUTINES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Routine to set the DriverManager login timeout on the server */
1:     public  static  void    setLoginTimeout( int seconds ) throws Exception
1:     {
1:         DriverManager.setLoginTimeout( seconds );
1:     }
1:     
1: }
============================================================================