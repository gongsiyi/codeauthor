1:eac0369: /*
7:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.DataValueDescriptor
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
8:eac0369:  */
1:9d34086: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:9548d38: import java.math.BigDecimal;
1:75a4806: import java.sql.Blob;
1:75a4806: import java.sql.Clob;
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.util.Calendar;
1:eac0369: 
1:109cb26: /**
1:eac0369:  * The DataValueDescriptor interface provides methods to get the data from
1:b2a0e89:  * a column returned by a statement.
1:b4e2eb7:  * <p>
1:eac0369:  * This interface matches the getXXX methods on java.sql.ResultSet. This means
1:eac0369:  * everyone satisfies getString and getObject; all of the numeric types, within
1:eac0369:  * the limits of representation, satisfy all of the numeric getXXX methods;
1:eac0369:  * all of the character types satisfy all of the getXXX methods except
1:eac0369:  * getBytes and getBinaryStream; all of the binary types satisfy getBytes and
1:eac0369:  * all of the getXXXStream methods; Date satisfies getDate and getTimestamp;
1:eac0369:  * Time satisfies getTime; and Timestamp satisfies all of the date/time getXXX 
1:eac0369:  * methods.
1:eac0369:  * The "preferred" method (one that will always work, I presume) is the one that
1:eac0369:  * matches the type most closely. See the comments below for
1:eac0369:  * "preferences".  See the JDBC guide for details.
2:eac0369:  * <p>
1:eac0369:  * This interface does not include the getXXXStream methods.
1:eac0369:  * <p>
1:eac0369:  * The preferred methods for JDBC are:
1:eac0369:  * <p>
1:eac0369:  * CHAR and VARCHAR - getString()
1:eac0369:  * <p>
1:eac0369:  * BIT - getBoolean()
1:eac0369:  * <p>
1:eac0369:  * TINYINT - getByte()
1:eac0369:  * <p>
1:eac0369:  * SMALLINT - getShort()
1:eac0369:  * <p>
1:eac0369:  * INTEGER - getInt()
1:eac0369:  * <p>
1:eac0369:  * BIGINT - getLong()
1:eac0369:  * <p>
1:eac0369:  * REAL - getFloat()
1:eac0369:  * <p>
1:eac0369:  * FLOAT and DOUBLE - getDouble()
1:eac0369:  * <p>
1:eac0369:  * DECIMAL and NUMERIC - getBigDecimal()
1:eac0369:  * <p>
1:eac0369:  * BINARY and VARBINARY - getBytes()
1:eac0369:  * <p>
1:eac0369:  * DATE - getDate()
1:eac0369:  * <p>
1:eac0369:  * TIME - getTime()
1:eac0369:  * <p>
1:eac0369:  * TIMESTAMP - getTimestamp()
1:eac0369:  * <p>
1:eac0369:  * No JDBC type corresponds to getObject().  Use this for user-defined types
1:eac0369:  * or to get the JDBC types as java Objects.  All primitive types will be
1:eac0369:  * wrapped in their corresponding Object type, i.e. int will be
1:eac0369:  * wrapped in an Integer.
1:eac0369:  * <p>
1:eac0369:  * getStream() 
1:b4e2eb7:  * 
1:eac0369:  */
1:eac0369: 
1:eac0369: public interface DataValueDescriptor extends Storable, Orderable
1:eac0369: {
1:eac0369: 
1:b4e2eb7:     /**
1:d4953dd:      * Constant indicating that the logical length of a value (i.e. chars for
1:d4953dd:      * string types or bytes for binary types) is unknown.
1:d4953dd:      */
1:d4953dd:     int UNKNOWN_LOGICAL_LENGTH = -1;
1:d4953dd: 
1:d4953dd: 	/**
1:eac0369: 	 * Gets the length of the data value.  The meaning of this is
1:eac0369: 	 * implementation-dependent.  For string types, it is the number of
1:eac0369: 	 * characters in the string.  For numeric types, it is the number of
1:eac0369: 	 * bytes used to store the number.  This is the actual length
1:eac0369: 	 * of this value, not the length of the type it was defined as.
1:eac0369: 	 * For example, a VARCHAR value may be shorter than the declared
1:eac0369: 	 * VARCHAR (maximum) length.
32:eac0369: 	 *
1:eac0369: 	 * @return	The length of the data value
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   On error
1:eac0369: 	 */
1:eac0369: 	int	getLength() throws StandardException;
1:eac0369: 
9:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a String.
1:eac0369: 	 * Throws an exception if the data value is not a string.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a String.
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	String	getString() throws StandardException;
1:2c6f0a2: 
1:f73afdc:     /**
1:f73afdc:      * Gets the value in the data value descriptor as a trace string.
1:f73afdc:      * If the value itself is not suitable for tracing purposes, a more
1:f73afdc:      * suitable representation is returned. For instance, data values
1:f73afdc:      * represented as streams are not materialized. Instead, information about
1:f73afdc:      * the associated stream is given.
1:f73afdc:      */
1:f73afdc:     String getTraceString() throws StandardException;
1:f73afdc: 
1:2c6f0a2: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a boolean.
1:eac0369: 	 * Throws an exception if the data value is not a boolean.
1:eac0369: 	 * For DataValueDescriptor, this is the preferred interface
1:eac0369: 	 * for BIT, but for this no-casting interface, it isn't, because
1:eac0369: 	 * BIT is stored internally as a Bit, not as a Boolean.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a boolean.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean	getBoolean() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a byte.
1:eac0369: 	 * Throws an exception if the data value is not a byte.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a byte.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	byte	getByte() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a short.
1:eac0369: 	 * Throws an exception if the data value is not a short.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a short.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	short	getShort() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as an int.
1:eac0369: 	 * Throws an exception if the data value is not an int.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a int.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	int	getInt() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a long.
1:eac0369: 	 * Throws an exception if the data value is not a long.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a long.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	long	getLong() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a float.
1:eac0369: 	 * Throws an exception if the data value is not a float.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a float.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	float	getFloat() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a double.
1:eac0369: 	 * Throws an exception if the data value is not a double.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a double.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	double	getDouble() throws StandardException;
1:eac0369: 	
1:eac0369: 	/**
1:2c6f0a2: 	 * How should this value be obtained so that it can
1:2c6f0a2: 	 * be converted to a BigDecimal representation.
1:2c6f0a2: 	 * @return Types.CHAR for String conversion through getString
1:2c6f0a2: 	 * Types.DECIMAL for BigDecimal through getObject or Types.BIGINT
1:2c6f0a2: 	 * for long conversion through getLong
1:2c6f0a2: 	 * @exception StandardException Conversion is not possible
1:2c6f0a2: 	 */
1:2c6f0a2: 	int typeToBigDecimal() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a byte array.
1:eac0369: 	 * Throws an exception if the data value is not a byte array.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a byte[].
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException  Thrown on error
1:eac0369: 	 */
1:eac0369: 	byte[]	getBytes() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Date.
1:eac0369: 	 * Throws an exception if the data value is not a Date.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 * @return	The data value as a java.sql.Date.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	Date getDate(java.util.Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Time.
1:eac0369: 	 * Throws an exception if the data value is not a Time.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a java.sql.Time.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	Time	getTime(java.util.Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
1:eac0369: 	 * Throws an exception if the data value is not a Timestamp.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 * @return	The data value as a java.sql.Timestamp.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a Java Object.
1:eac0369: 	 * The type of the Object will be the Java object type corresponding
1:eac0369: 	 * to the data value's SQL type. JDBC defines a mapping between Java
1:eac0369: 	 * object types and SQL types - we will allow that to be extended
1:eac0369: 	 * through user type definitions. Throws an exception if the data
1:eac0369: 	 * value is not an object (yeah, right).
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as an Object.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException   Thrown on error
1:eac0369: 	 */
1:eac0369: 	Object	getObject() throws StandardException;
1:eac0369: 
1:541361f:     /**
1:541361f:      * Gets the value in the data value descriptor as a stream of bytes.
1:541361f:      * <p>
1:541361f:      * Only data types that implement {@code StreamStorable} will have stream
1:541361f:      * states, and the method {@code hasStream} should be called to determine
1:541361f:      * if the value in question is, or will be, represented by a stream.
1:541361f:      *
1:541361f:      * @return The stream state of the data value.
1:541361f:      * @throws StandardException Throws an exception if the data value
1:541361f:      *      cannot be received as a stream.
1:541361f:      *
1:541361f:      * @see #hasStream()
1:541361f:      * @see StringDataValue#getStreamWithDescriptor()
1:541361f:      */
1:541361f:     InputStream getStream() throws StandardException;
1:541361f: 
1:541361f:     /**
1:541361f:      * Tells if this data value is, or will be, represented by a stream.
1:541361f:      * <p>
1:541361f:      * This method should be called to determine if the methods {@code
1:541361f:      * getStream} or {@code DataValueDescriptor.getStreamWithDescriptor} can
1:541361f:      * be invoked.
1:541361f:      *
1:541361f:      * @return {@code true} if the value will be a stream, {@code false}
1:541361f:      *      otherwise.
1:541361f:      *
1:541361f:      * @see #getStream()
1:541361f:      * @see StringDataValue#getStreamWithDescriptor()
1:541361f:      */
1:541361f:     boolean hasStream();
1:eac0369: 
1:eac0369:     /**
1:854dd10:      * Get a shallow copy of this {@code codeDataValueDescriptor} (DVD).
1:eac0369:      * <p>
1:854dd10:      * The primary use of this method is to avoid materializing streams for
1:854dd10:      * data types like BLOB and CLOB.
1:854dd10:      * <p>
1:854dd10:      * In general the orginal DVD should be recycled or discarded when this
1:854dd10:      * method is invoked to ensure that changes to the original DVD don't
1:854dd10:      * affect the clone (or the other way around). Note that it is not safe to
1:854dd10:      * assume that a number of these clones can be used for read-only access to
1:854dd10:      * the same value.
1:854dd10:      * <p>
1:854dd10:      * <em>Implementation note:</em> The reason why the clones can't be
1:854dd10:      * guaranteed to work as "read clones" is that if the value is represented
1:854dd10:      * as a stream, the state of the stream will change on read operations.
1:854dd10:      * Since all the clones share the same stream, this may lead to wrong
1:854dd10:      * results, data corruption or crashes.
1:eac0369:      *
1:b4e2eb7:      * @return A clone of this descriptor, which shares the internal state.
1:b4e2eb7:      */
1:9495437:     public DataValueDescriptor cloneHolder();
1:b4e2eb7: 
1:854dd10:     /**
1:854dd10:      * Clone this DataValueDescriptor. Results in a new object
1:854dd10:      * that has the same value as this but can be modified independently.
1:854dd10:      * <p>
1:854dd10:      * Even though the objects can be modified independently regardless of the
1:854dd10:      * value of {@code forceMaterialization}, both the clone and the
1:854dd10:      * original may be dependent on the store state if
1:854dd10:      * {@code forceMaterialization} is set to {@code false}. An example is if
1:854dd10:      * you need to access the value you just read using {@code cloneValue}
1:854dd10:      * after the current transaction has ended, or after the source result set
1:854dd10:      * has been closed.
1:854dd10:      *
1:854dd10:      * @param forceMaterialization any streams representing the data value will
1:854dd10:      *      be materialized if {@code true}, the data value will be kept as a
1:854dd10:      *      stream if possible if {@code false}
1:854dd10:      * @return A clone of the {@code DataValueDescriptor} with the same initial
1:854dd10:      *      value as this.
1:854dd10:      */
1:854dd10:     public abstract DataValueDescriptor cloneValue(
1:9495437:             boolean forceMaterialization);
1:eac0369: 
1:eac0369:     /**
1:109cb26:      * Recycle this DataValueDescriptor if possible. Create and return a new
1:109cb26:      * object if it cannot be recycled.
1:109cb26:      *
1:109cb26:      * @return this object with the value set to null, or a new
1:109cb26:      * DataValueDescriptor of the same type as this
1:109cb26:      */
1:109cb26:     DataValueDescriptor recycle();
1:109cb26: 
1:eac0369: 	/**
1:eac0369: 	 * Get a new null value of the same type as this data value.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value based on the value for the specified DataValueDescriptor
1:eac0369: 	 * from the specified ResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @param resultSet		The specified ResultSet.
1:eac0369: 	 * @param colNumber		The 1-based column # into the resultSet.
1:eac0369: 	 * @param isNullable	Whether or not the column is nullable
1:eac0369: 	 *						(No need to call wasNull() if not)
1:eac0369: 	 * 
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 * @exception SQLException		Error accessing the result set
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(
1:eac0369:     ResultSet   resultSet, 
1:eac0369:     int         colNumber,
1:eac0369:     boolean     isNullable)
1:eac0369: 		throws StandardException, SQLException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set this value into a PreparedStatement. This method must
1:eac0369: 		handle setting NULL into the PreparedStatement.
1:eac0369: 
1:eac0369: 		@exception SQLException thrown by the PreparedStatement object
1:eac0369: 		@exception StandardException thrown by me accessing my value.
1:eac0369: 	*/
1:eac0369: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
1:eac0369: 		or ResultSet.updateRow. This method will only be called for non-null values.
1:eac0369: 
1:eac0369: 		@exception SQLException thrown by the ResultSet object
1:eac0369: 		@exception StandardException thrown by me accessing my value.
1:eac0369: 	*/
1:eac0369: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given int value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(int theValue) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given double value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(double theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given double value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	A Double containing the value to set this
2:eac0369: 	 *					DataValueDescriptor to.  Null means set the value
2:eac0369: 	 *					to SQL null.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void setValue(float theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given short value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(short theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given long value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(long theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given byte value
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(byte theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
2:eac0369: 	 * Set the value.
1:eac0369: 	 *
2:eac0369: 	 * @param theValue	Contains the boolean value to set this to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(boolean theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:33bfdc0: 	 * Set the value of this DataValueDescriptor to the given Object value
1:33bfdc0: 	 *
1:33bfdc0: 	 * @param theValue	The value to set this DataValueDescriptor to
1:33bfdc0: 	 *
1:33bfdc0: 	 * @exception StandardException		Thrown on error
1:33bfdc0: 	 */
1:33bfdc0: 	public void setValue(Object theValue) throws StandardException;
1:33bfdc0: 
1:33bfdc0: 	/**
2:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The byte value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(byte[] theValue) throws StandardException;
1:eac0369: 
1:d7f7457: 	/**
1:d7f7457: 		Set this value from an application supplied java.math.BigDecimal.
1:d7f7457: 		This is to support the PreparedStatement.setBigDecimal method and
1:d7f7457: 		similar JDBC methods that allow an application to pass in a BigDecimal
1:d7f7457: 		to any SQL type.
1:d7f7457: 
1:d7f7457: 		@param bigDecimal required to be a BigDecimal or null.
1:eac0369: 	 */
1:9548d38: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The String value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(String theValue) throws StandardException;
1:eac0369: 
1:75a4806:  	/**
1:75a4806: 	 * Set the value of this DataValueDescriptor from a Blob.
1:75a4806: 	 *
1:75a4806: 	 * @param theValue	The Blob value to set this DataValueDescriptor to
1:75a4806: 	 *
1:75a4806: 	 */
1:75a4806: 	public void setValue(Blob theValue) throws StandardException;
1:75a4806:     
1:75a4806: 	/**
1:75a4806: 	 * Set the value of this DataValueDescriptor from a Clob.
1:75a4806: 	 *
1:75a4806: 	 * @param theValue	The Clob value to set this DataValueDescriptor to
1:75a4806: 	 *
1:75a4806: 	 */
1:75a4806: 	public void setValue(Clob theValue) throws StandardException;
1:75a4806: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Time theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database time value
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Time theValue, Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database timestamp value
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date theValue) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database date value
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date theValue, Calendar cal) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor from another.
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(DataValueDescriptor theValue) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value to SQL null.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void setToNull();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Normalize the source value to this type described by this class
1:eac0369: 		and the passed in DataTypeDescriptor. The type of the DataTypeDescriptor
1:eac0369: 		must match this class.
1:eac0369: 	*/
1:eac0369: 	public void normalize(DataTypeDescriptor dtd, DataValueDescriptor source)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL "IS NULL" operator.  Returns true if this value
1:eac0369: 	 * is null.
1:eac0369: 	 *	 *
1:eac0369: 	 * @return	True if this value is null.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue isNullOp();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL "IS NOT NULL" operator.  Returns true if this value
1:eac0369: 	 * is not null.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return	True if this value is not null.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue isNotNull();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the SQL name of the datatype
1:eac0369: 	 *
1:eac0369: 	 * @return	The SQL name of the datatype
1:eac0369: 	 */
1:eac0369: 	public String	getTypeName();
1:eac0369: 
1:eac0369: 	/**
1:806114c: 	 * Set this value from an Object. Used from CAST of a Java type to
1:806114c: 	 * another type, including SQL types. If the passed instanceOfResultType
1:806114c: 	 * is false then the object is not an instance of the declared
1:806114c: 	 * type resultTypeClassName. Usually an exception should be thrown.
1:eac0369: 	 *
1:eac0369: 	 * @param value					The new value
1:eac0369: 	 * @param instanceOfResultType	Whether or not the new value 
1:eac0369: 	 *								is an instanceof the result type.
1:806114c: 	 * @param resultTypeClassName   The class name of the resulting (declared) type 
1:eac0369:      *                              (for error messages only).
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setObjectForCast(
1:eac0369:     Object  value, 
1:eac0369:     boolean instanceOfResultType, 
1:eac0369:     String  resultTypeClassName) 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Read the DataValueDescriptor from the stream.
1:eac0369:      * <p>
1:eac0369:      * Initialize the data value by reading it's values from the 
1:eac0369:      * ArrayInputStream.  This interface is provided as a way to achieve
1:eac0369:      * possible performance enhancement when reading an array can be 
1:eac0369:      * optimized over reading from a generic stream from readExternal().
1:eac0369:      *
1:eac0369:      * @param ais    The array stream positioned at the beginning of the 
1:eac0369:      *               byte stream to read from.
1:eac0369:      *
1:eac0369: 	 * @exception  IOException              Usual error is if you try to read 
1:eac0369:      *                                      past limit on the stream.
1:eac0369: 	 * @exception  ClassNotFoundException   If a necessary class can not be 
1:eac0369:      *                                      found while reading the object from
1:eac0369:      *                                      the stream.
1:eac0369:      **/
1:eac0369:     public void readExternalFromArray(
1:eac0369:     ArrayInputStream    ais)
1:eac0369:         throws IOException, ClassNotFoundException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
1:eac0369: 	 * how to do type promotion when using binary operators.  For example, float
1:eac0369: 	 * has a higher precedence than int, so when adding an int to a float, the
1:eac0369: 	 * result type is float.
1:eac0369: 	 *
1:eac0369: 	 * The precedence for some types is arbitrary.  For example, it doesn't
1:eac0369: 	 * matter what the precedence of the boolean type is, since it can't be
1:eac0369: 	 * mixed with other types.  But the precedence for the number types is
1:eac0369: 	 * critical.  The SQL standard requires that exact numeric types be
1:eac0369: 	 * promoted to approximate numeric when one operator uses both.  Also,
1:eac0369: 	 * the precedence is arranged so that one will not lose precision when
1:eac0369: 	 * promoting a type.
1:eac0369: 	 *
1:eac0369: 	 * @return		The precedence of this type.
1:eac0369: 	 */
1:eac0369: 	int					typePrecedence();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL language = operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue equals(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The SQL language &lt;&gt; operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The SQL language &lt; operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The SQL language &gt; operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The SQL language &lt;= operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The SQL language &gt;= operator.  This method is called from the language
1:eac0369: 	 * module.  The storage module uses the compare method in Orderable.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param right		The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1:eac0369: 									DataValueDescriptor right)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL language COALESCE/VALUE function.  This method is called from the language
1:eac0369: 	 * module.  
1:eac0369: 	 *
1:eac0369: 	 * @param list		The list of the arguments. Function will return the first non-nullable argument if any.
1:eac0369: 	 * @param returnValue		The return value is the correct datatype for this function.
1:eac0369: 	 * The return value of this method is the type of the 2nd parameter.
1:eac0369: 	 *
1:eac0369: 	 * @return	A DataValueDescriptor which will be either null or first non-null argument
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor coalesce(DataValueDescriptor[] list, DataValueDescriptor returnValue)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL language IN operator.  This method is called from the language
1:eac0369: 	 * module.  This method allows us to optimize and short circuit the search
1:eac0369: 	 * if the list is ordered.
1:eac0369: 	 *
1:eac0369: 	 * @param left		The value on the left side of the operator
1:eac0369: 	 * @param inList	The values in the IN list
1:eac0369: 	 * @param orderedList	True means that the values in the IN list are ordered,
1:eac0369: 	 *						false means they are not.
1:eac0369: 	 *
1:eac0369: 	 * @return	A BooleanDataValue telling the result of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue in(DataValueDescriptor left,
1:eac0369: 							   DataValueDescriptor[] inList,
1:eac0369: 							   boolean orderedList) 
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compare this Orderable with a given Orderable for the purpose of
1:eac0369: 	 * index positioning.  This method treats nulls as ordered values -
1:cc30c0c: 	 * that is, it treats SQL null as equal to null and greater than all
1:eac0369: 	 * other values.
1:eac0369: 	 *
1:eac0369: 	 * @param other		The Orderable to compare this one to.
1:eac0369: 	 *
1:dbed020: 	 * @return  &lt;0 - this Orderable is less than other.
1:eac0369: 	 * 			 0 - this Orderable equals other.
1:dbed020: 	 *			&gt;0 - this Orderable is greater than other.
1:eac0369:      *
1:eac0369:      *			The code should not explicitly look for -1, or 1.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	int compare(DataValueDescriptor other) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:cc30c0c: 	 * Compare this Orderable with another, with configurable null ordering.
1:cc30c0c: 	 * This method treats nulls as ordered values, but allows the caller
1:cc30c0c:          * to specify whether they should be lower than all non-NULL values,
1:cc30c0c:          * or higher than all non-NULL values.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @param other		The Orderable to compare this one to.
1:cc30c0c:          % @param nullsOrderedLow True if null should be lower than non-NULL
1:cc30c0c: 	 *
1:dbed020: 	 * @return  &lt;0 - this Orderable is less than other.
1:cc30c0c: 	 * 			 0 - this Orderable equals other.
1:dbed020: 	 *			&gt;0 - this Orderable is greater than other.
1:cc30c0c:      *
1:cc30c0c:      *			The code should not explicitly look for -1, or 1.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @exception StandardException		Thrown on error
1:cc30c0c: 	 */
1:cc30c0c: 	int compare(DataValueDescriptor other, boolean nullsOrderedLow)
1:cc30c0c:             throws StandardException;
1:cc30c0c: 
1:cc30c0c: 	/**
1:eac0369: 	 * Compare this Orderable with a given Orderable for the purpose of
1:eac0369: 	 * qualification and sorting.  The caller gets to determine how nulls
1:eac0369: 	 * should be treated - they can either be ordered values or unknown
1:eac0369: 	 * values.
1:eac0369: 	 *
1:eac0369: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
1:eac0369: 	 * @param other	The DataValueDescriptor to compare this one to.
1:eac0369: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1:eac0369: 	 *						that is, treat SQL null as equal to null, and less
1:eac0369: 	 *						than all other values.
1:eac0369: 	 *						False means to treat nulls as unknown values,
1:eac0369: 	 *						that is, the result of any comparison with a null
1:eac0369: 	 *						is the UNKNOWN truth value.
1:eac0369: 	 * @param unknownRV		The return value to use if the result of the
1:eac0369: 	 *						comparison is the UNKNOWN truth value.  In other
1:eac0369: 	 *						words, if orderedNulls is false, and a null is
1:eac0369: 	 *						involved in the comparison, return unknownRV.
1:eac0369: 	 *						This parameter is not used orderedNulls is true.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the comparison is true (duh!)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean compare(
1:eac0369:     int         op, 
1:eac0369:     DataValueDescriptor   other,
1:eac0369:     boolean     orderedNulls, 
1:eac0369:     boolean     unknownRV)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:d4953dd: 	/**
1:cc30c0c: 	 * Compare this Orderable with another, with configurable null ordering.
1:cc30c0c: 	 * The caller gets to determine how nulls
1:cc30c0c: 	 * should be treated - they can either be ordered values or unknown
1:cc30c0c: 	 * values. The caller also gets to decide, if they are ordered,
1:cc30c0c:          * whether they should be lower than non-NULL values, or higher
1:cc30c0c: 	 *
1:cc30c0c: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
1:cc30c0c: 	 * @param other	The DataValueDescriptor to compare this one to.
1:cc30c0c: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1:cc30c0c: 	 *						that is, treat SQL null as equal to null, and either greater or less
1:cc30c0c: 	 *						than all other values.
1:cc30c0c: 	 *						False means to treat nulls as unknown values,
1:cc30c0c: 	 *						that is, the result of any comparison with a null
1:cc30c0c: 	 *						is the UNKNOWN truth value.
1:cc30c0c:          * @param nullsOrderedLow       True means NULL less than non-NULL,
1:cc30c0c:          *                              false means NULL greater than non-NULL.
1:cc30c0c:          *                              Only relevant if orderedNulls is true.
1:cc30c0c: 	 * @param unknownRV		The return value to use if the result of the
1:cc30c0c: 	 *						comparison is the UNKNOWN truth value.  In other
1:cc30c0c: 	 *						words, if orderedNulls is false, and a null is
1:cc30c0c: 	 *						involved in the comparison, return unknownRV.
1:cc30c0c: 	 *						This parameter is not used orderedNulls is true.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @return	true if the comparison is true (duh!)
1:cc30c0c: 	 *
1:cc30c0c: 	 * @exception StandardException		Thrown on error
1:cc30c0c: 	 */
1:cc30c0c: 	boolean compare(
1:cc30c0c:     int         op, 
1:cc30c0c:     DataValueDescriptor   other,
1:cc30c0c:     boolean     orderedNulls, 
1:cc30c0c:     boolean     nullsOrderedLow,
1:cc30c0c:     boolean     unknownRV)
1:cc30c0c: 				throws StandardException;
1:cc30c0c: 
1:cc30c0c:     /**
1:d4953dd:      * Set the value to be the contents of the stream.
1:d4953dd:      * <p>
1:d4953dd:      * The reading of the stream may be delayed until execution time, and the
1:d4953dd:      * format of the stream is required to be the format of this type.
1:d4953dd:      * <p>
1:d4953dd:      * Note that the logical length excludes any header bytes and marker bytes
1:d4953dd:      * (for instance the Derby specific EOF stream marker). Specifying the
1:d4953dd:      * logical length may improve performance in some cases, but specifying
1:d4953dd:      * that the length is unknown (<code>UNKNOWN_LOGICAL_LENGTH</code> should
1:d4953dd:      * always leave the system in a functional state. Specifying an incorrect
1:d4953dd:      * length will cause errors.
1:d4953dd:      *
1:d4953dd:      * @param theStream	stream of correctly formatted data
1:d4953dd:      * @param valueLength logical length of the stream's value in units of this
1:d4953dd:      *      type (e.g. chars for string types), or
1:d4953dd:      *      <code>UNKNOWN_LOGICAL_LENGTH</code> if the logical length is unknown
1:d4953dd:      */
1:40bcd6b: 	public void setValue(InputStream theStream, int valueLength) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check the value to seem if it conforms to the restrictions
1:eac0369: 		imposed by DB2/JCC on host variables for this type.
1:eac0369: 
1:eac0369: 		@exception StandardException Variable is too big.
1:eac0369: 	*/
1:eac0369: 	public void checkHostVariable(int declaredLength) throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the memory usage in bytes of the data value and the overhead of the class.
1:eac0369:      *
1:eac0369:      * @return the estimated memory usage
1:eac0369:      */
1:eac0369:     int estimateMemoryUsage();
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * The SQL language &lt;&gt; operator.  This method is called from the language
/////////////////////////////////////////////////////////////////////////
1: 	 * The SQL language &lt; operator.  This method is called from the language
/////////////////////////////////////////////////////////////////////////
1: 	 * The SQL language &gt; operator.  This method is called from the language
/////////////////////////////////////////////////////////////////////////
1: 	 * The SQL language &lt;= operator.  This method is called from the language
/////////////////////////////////////////////////////////////////////////
1: 	 * The SQL language &gt;= operator.  This method is called from the language
/////////////////////////////////////////////////////////////////////////
1: 	 * @return  &lt;0 - this Orderable is less than other.
1: 	 *			&gt;0 - this Orderable is greater than other.
/////////////////////////////////////////////////////////////////////////
1: 	 * @return  &lt;0 - this Orderable is less than other.
1: 	 *			&gt;0 - this Orderable is greater than other.
/////////////////////////////////////////////////////////////////////////
1: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
/////////////////////////////////////////////////////////////////////////
1: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
commit:9495437
/////////////////////////////////////////////////////////////////////////
1:     public DataValueDescriptor cloneHolder();
/////////////////////////////////////////////////////////////////////////
1:             boolean forceMaterialization);
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:     public DataValueDescriptor cloneHolder() throws StandardException;
/////////////////////////////////////////////////////////////////////////
0:             boolean forceMaterialization) throws StandardException;
commit:75a4806
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.Clob;
/////////////////////////////////////////////////////////////////////////
1:  	/**
1: 	 * Set the value of this DataValueDescriptor from a Blob.
1: 	 *
1: 	 * @param theValue	The Blob value to set this DataValueDescriptor to
1: 	 *
1: 	 */
1: 	public void setValue(Blob theValue) throws StandardException;
1:     
1: 	/**
1: 	 * Set the value of this DataValueDescriptor from a Clob.
1: 	 *
1: 	 * @param theValue	The Clob value to set this DataValueDescriptor to
1: 	 *
1: 	 */
1: 	public void setValue(Clob theValue) throws StandardException;
1: 
commit:33bfdc0
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the value of this DataValueDescriptor to the given Object value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(Object theValue) throws StandardException;
1: 
1: 	/**
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException;
commit:109cb26
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Recycle this DataValueDescriptor if possible. Create and return a new
1:      * object if it cannot be recycled.
1:      *
1:      * @return this object with the value set to null, or a new
1:      * DataValueDescriptor of the same type as this
1:      */
1:     DataValueDescriptor recycle();
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the value in the data value descriptor as a stream of bytes.
1:      * <p>
1:      * Only data types that implement {@code StreamStorable} will have stream
1:      * states, and the method {@code hasStream} should be called to determine
1:      * if the value in question is, or will be, represented by a stream.
1:      *
1:      * @return The stream state of the data value.
1:      * @throws StandardException Throws an exception if the data value
1:      *      cannot be received as a stream.
1:      *
1:      * @see #hasStream()
1:      * @see StringDataValue#getStreamWithDescriptor()
1:      */
1:     InputStream getStream() throws StandardException;
1: 
1:     /**
1:      * Tells if this data value is, or will be, represented by a stream.
1:      * <p>
1:      * This method should be called to determine if the methods {@code
1:      * getStream} or {@code DataValueDescriptor.getStreamWithDescriptor} can
1:      * be invoked.
1:      *
1:      * @return {@code true} if the value will be a stream, {@code false}
1:      *      otherwise.
1:      *
1:      * @see #getStream()
1:      * @see StringDataValue#getStreamWithDescriptor()
1:      */
1:     boolean hasStream();
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:      * Get a shallow copy of this {@code codeDataValueDescriptor} (DVD).
1:      * The primary use of this method is to avoid materializing streams for
1:      * data types like BLOB and CLOB.
1:      * <p>
1:      * In general the orginal DVD should be recycled or discarded when this
1:      * method is invoked to ensure that changes to the original DVD don't
1:      * affect the clone (or the other way around). Note that it is not safe to
1:      * assume that a number of these clones can be used for read-only access to
1:      * the same value.
1:      * <p>
1:      * <em>Implementation note:</em> The reason why the clones can't be
1:      * guaranteed to work as "read clones" is that if the value is represented
1:      * as a stream, the state of the stream will change on read operations.
1:      * Since all the clones share the same stream, this may lead to wrong
1:      * results, data corruption or crashes.
1:     /**
1:      * Clone this DataValueDescriptor. Results in a new object
1:      * that has the same value as this but can be modified independently.
1:      * <p>
1:      * Even though the objects can be modified independently regardless of the
1:      * value of {@code forceMaterialization}, both the clone and the
1:      * original may be dependent on the store state if
1:      * {@code forceMaterialization} is set to {@code false}. An example is if
1:      * you need to access the value you just read using {@code cloneValue}
1:      * after the current transaction has ended, or after the source result set
1:      * has been closed.
1:      *
1:      * @param forceMaterialization any streams representing the data value will
1:      *      be materialized if {@code true}, the data value will be kept as a
1:      *      stream if possible if {@code false}
1:      * @return A clone of the {@code DataValueDescriptor} with the same initial
1:      *      value as this.
1:      */
1:     public abstract DataValueDescriptor cloneValue(
0:             boolean forceMaterialization);
commit:d7aa761
/////////////////////////////////////////////////////////////////////////
0:     public DataValueDescriptor cloneHolder();
commit:b4e2eb7
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Get a shallow copy of this <code>DataValueDescriptor</code>.
1:      * <p>
0:      * This is used by the sorter to clone columns. It should be cloning the
0:      * column holder but not its value. The only difference between this method
0:      * and <code>getClone</code> is this one does not objectify a stream.
1:      *
1:      * @return A clone of this descriptor, which shares the internal state.
1:      */
0:     public DataValueDescriptor cloneObject();
1: 
commit:d4953dd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constant indicating that the logical length of a value (i.e. chars for
1:      * string types or bytes for binary types) is unknown.
1:      */
1:     int UNKNOWN_LOGICAL_LENGTH = -1;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the value to be the contents of the stream.
1:      * <p>
1:      * The reading of the stream may be delayed until execution time, and the
1:      * format of the stream is required to be the format of this type.
1:      * <p>
1:      * Note that the logical length excludes any header bytes and marker bytes
1:      * (for instance the Derby specific EOF stream marker). Specifying the
1:      * logical length may improve performance in some cases, but specifying
1:      * that the length is unknown (<code>UNKNOWN_LOGICAL_LENGTH</code> should
1:      * always leave the system in a functional state. Specifying an incorrect
1:      * length will cause errors.
1:      *
1:      * @param theStream	stream of correctly formatted data
1:      * @param valueLength logical length of the stream's value in units of this
1:      *      type (e.g. chars for string types), or
1:      *      <code>UNKNOWN_LOGICAL_LENGTH</code> if the logical length is unknown
1:      */
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
commit:f73afdc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the value in the data value descriptor as a trace string.
1:      * If the value itself is not suitable for tracing purposes, a more
1:      * suitable representation is returned. For instance, data values
1:      * represented as streams are not materialized. Instead, information about
1:      * the associated stream is given.
1:      */
1:     String getTraceString() throws StandardException;
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1: 	 * that is, it treats SQL null as equal to null and greater than all
/////////////////////////////////////////////////////////////////////////
1: 	 * Compare this Orderable with another, with configurable null ordering.
1: 	 * This method treats nulls as ordered values, but allows the caller
1:          * to specify whether they should be lower than all non-NULL values,
1:          * or higher than all non-NULL values.
1: 	 *
1: 	 * @param other		The Orderable to compare this one to.
1:          % @param nullsOrderedLow True if null should be lower than non-NULL
1: 	 *
0: 	 * @return  <0 - this Orderable is less than other.
1: 	 * 			 0 - this Orderable equals other.
0: 	 *			>0 - this Orderable is greater than other.
1:      *
1:      *			The code should not explicitly look for -1, or 1.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	int compare(DataValueDescriptor other, boolean nullsOrderedLow)
1:             throws StandardException;
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	 * Compare this Orderable with another, with configurable null ordering.
1: 	 * The caller gets to determine how nulls
1: 	 * should be treated - they can either be ordered values or unknown
1: 	 * values. The caller also gets to decide, if they are ordered,
1:          * whether they should be lower than non-NULL values, or higher
1: 	 *
1: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
0: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this < other.
0: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this <= other.
1: 	 * @param other	The DataValueDescriptor to compare this one to.
1: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1: 	 *						that is, treat SQL null as equal to null, and either greater or less
1: 	 *						than all other values.
1: 	 *						False means to treat nulls as unknown values,
1: 	 *						that is, the result of any comparison with a null
1: 	 *						is the UNKNOWN truth value.
1:          * @param nullsOrderedLow       True means NULL less than non-NULL,
1:          *                              false means NULL greater than non-NULL.
1:          *                              Only relevant if orderedNulls is true.
1: 	 * @param unknownRV		The return value to use if the result of the
1: 	 *						comparison is the UNKNOWN truth value.  In other
1: 	 *						words, if orderedNulls is false, and a null is
1: 	 *						involved in the comparison, return unknownRV.
1: 	 *						This parameter is not used orderedNulls is true.
1: 	 *
1: 	 * @return	true if the comparison is true (duh!)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean compare(
1:     int         op, 
1:     DataValueDescriptor   other,
1:     boolean     orderedNulls, 
1:     boolean     nullsOrderedLow,
1:     boolean     unknownRV)
1: 				throws StandardException;
1: 
1: 	/**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b2a0e89
/////////////////////////////////////////////////////////////////////////
1:  * a column returned by a statement.
commit:40bcd6b
/////////////////////////////////////////////////////////////////////////
0: 		@param	valueLength	logical length of the stream's value in units of this type (e.g. chars for string types).
1: 	public void setValue(InputStream theStream, int valueLength) throws StandardException;
commit:806114c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Set this value from an Object. Used from CAST of a Java type to
1: 	 * another type, including SQL types. If the passed instanceOfResultType
1: 	 * is false then the object is not an instance of the declared
1: 	 * type resultTypeClassName. Usually an exception should be thrown.
1: 	 * @param resultTypeClassName   The class name of the resulting (declared) type 
commit:9d34086
/////////////////////////////////////////////////////////////////////////
1: 
0: 	 * Clone this DataValueDescriptor. Results in a new object
0: 	 * that has the same value as this but can be modified independently.
0: 	 * @return A clone of the DataValueDescriptor with the same initial value as this.
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * How should this value be obtained so that it can
1: 	 * be converted to a BigDecimal representation.
1: 	 * @return Types.CHAR for String conversion through getString
1: 	 * Types.DECIMAL for BigDecimal through getObject or Types.BIGINT
1: 	 * for long conversion through getLong
1: 	 * @exception StandardException Conversion is not possible
1: 	 */
1: 	int typeToBigDecimal() throws StandardException;
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 		Set this value from an application supplied java.math.BigDecimal.
1: 		This is to support the PreparedStatement.setBigDecimal method and
1: 		similar JDBC methods that allow an application to pass in a BigDecimal
1: 		to any SQL type.
0: 		Parameter is declared as java.lang.Number to allow compilation
0: 		under J2ME/CDC/Foundation. This method will not be called in
0: 		any environment that does not support java.math.BigDecimal.
1: 
1: 		@param bigDecimal required to be a BigDecimal or null.
0: 	public void setBigDecimal(Number bigDecimal) throws StandardException;
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.DataValueDescriptor
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import java.io.InputStream;
1: import java.io.IOException;
0: import java.math.BigDecimal;
1: import java.sql.Date;
1: import java.sql.ResultSet;
1: import java.sql.PreparedStatement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.SQLException;
1: import java.util.Calendar;
1: 
1: /**
1:  * The DataValueDescriptor interface provides methods to get the data from
0:  * a column returned by a statement.  This interface has the same methods
0:  * as NoCastDataValueDescriptor - the only reason it exists is for purposes
0:  * of internal documentation, to make it clear when the different getXXX
0:  * methods throw exceptions for illegal conversions.
1:  * <p>
1:  * This interface matches the getXXX methods on java.sql.ResultSet. This means
1:  * everyone satisfies getString and getObject; all of the numeric types, within
1:  * the limits of representation, satisfy all of the numeric getXXX methods;
1:  * all of the character types satisfy all of the getXXX methods except
1:  * getBytes and getBinaryStream; all of the binary types satisfy getBytes and
1:  * all of the getXXXStream methods; Date satisfies getDate and getTimestamp;
1:  * Time satisfies getTime; and Timestamp satisfies all of the date/time getXXX 
1:  * methods.
1:  * The "preferred" method (one that will always work, I presume) is the one that
1:  * matches the type most closely. See the comments below for
1:  * "preferences".  See the JDBC guide for details.
1:  * <p>
1:  * This interface does not include the getXXXStream methods.
1:  * <p>
1:  * The preferred methods for JDBC are:
1:  * <p>
1:  * CHAR and VARCHAR - getString()
1:  * <p>
1:  * BIT - getBoolean()
1:  * <p>
1:  * TINYINT - getByte()
1:  * <p>
1:  * SMALLINT - getShort()
1:  * <p>
1:  * INTEGER - getInt()
1:  * <p>
1:  * BIGINT - getLong()
1:  * <p>
1:  * REAL - getFloat()
1:  * <p>
1:  * FLOAT and DOUBLE - getDouble()
1:  * <p>
1:  * DECIMAL and NUMERIC - getBigDecimal()
1:  * <p>
1:  * BINARY and VARBINARY - getBytes()
1:  * <p>
1:  * DATE - getDate()
1:  * <p>
1:  * TIME - getTime()
1:  * <p>
1:  * TIMESTAMP - getTimestamp()
1:  * <p>
1:  * No JDBC type corresponds to getObject().  Use this for user-defined types
1:  * or to get the JDBC types as java Objects.  All primitive types will be
1:  * wrapped in their corresponding Object type, i.e. int will be
1:  * wrapped in an Integer.
1:  * <p>
1:  * getStream() 
1:  * 
0:  * @author Jeff Lichtman
1:  */
1: 
1: public interface DataValueDescriptor extends Storable, Orderable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1: 	/**
1: 	 * Gets the length of the data value.  The meaning of this is
1: 	 * implementation-dependent.  For string types, it is the number of
1: 	 * characters in the string.  For numeric types, it is the number of
1: 	 * bytes used to store the number.  This is the actual length
1: 	 * of this value, not the length of the type it was defined as.
1: 	 * For example, a VARCHAR value may be shorter than the declared
1: 	 * VARCHAR (maximum) length.
1: 	 *
1: 	 * @return	The length of the data value
1: 	 *
1: 	 * @exception StandardException   On error
1: 	 */
1: 	int	getLength() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a String.
1: 	 * Throws an exception if the data value is not a string.
1: 	 *
1: 	 * @return	The data value as a String.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	String	getString() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a boolean.
1: 	 * Throws an exception if the data value is not a boolean.
1: 	 * For DataValueDescriptor, this is the preferred interface
1: 	 * for BIT, but for this no-casting interface, it isn't, because
1: 	 * BIT is stored internally as a Bit, not as a Boolean.
1: 	 *
1: 	 * @return	The data value as a boolean.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	boolean	getBoolean() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a byte.
1: 	 * Throws an exception if the data value is not a byte.
1: 	 *
1: 	 * @return	The data value as a byte.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	byte	getByte() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a short.
1: 	 * Throws an exception if the data value is not a short.
1: 	 *
1: 	 * @return	The data value as a short.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	short	getShort() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as an int.
1: 	 * Throws an exception if the data value is not an int.
1: 	 *
1: 	 * @return	The data value as a int.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	int	getInt() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a long.
1: 	 * Throws an exception if the data value is not a long.
1: 	 *
1: 	 * @return	The data value as a long.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	long	getLong() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a float.
1: 	 * Throws an exception if the data value is not a float.
1: 	 *
1: 	 * @return	The data value as a float.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	float	getFloat() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a double.
1: 	 * Throws an exception if the data value is not a double.
1: 	 *
1: 	 * @return	The data value as a double.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	double	getDouble() throws StandardException;
1: 
1: 	/**
0: 	 * Gets the value in the data value descriptor as a BigDecimal.
0: 	 * Throws an exception if the data value is not a BigDecimal.
1: 	 *
0: 	 * @return	The data value as a java.math.BigDecimal.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
0: 	BigDecimal	getBigDecimal() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a byte array.
1: 	 * Throws an exception if the data value is not a byte array.
1: 	 *
1: 	 * @return	The data value as a byte[].
1: 	 *
1: 	 * @exception StandardException  Thrown on error
1: 	 */
1: 	byte[]	getBytes() throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Date.
1: 	 * Throws an exception if the data value is not a Date.
1:      *	@param cal calendar for object creation
1: 	 * @return	The data value as a java.sql.Date.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	Date getDate(java.util.Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Time.
1: 	 * Throws an exception if the data value is not a Time.
1:      *	@param cal calendar for object creation
1: 	 *
1: 	 * @return	The data value as a java.sql.Time.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	Time	getTime(java.util.Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
1: 	 * Throws an exception if the data value is not a Timestamp.
1:      *	@param cal calendar for object creation
1: 	 * @return	The data value as a java.sql.Timestamp.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a Java Object.
1: 	 * The type of the Object will be the Java object type corresponding
1: 	 * to the data value's SQL type. JDBC defines a mapping between Java
1: 	 * object types and SQL types - we will allow that to be extended
1: 	 * through user type definitions. Throws an exception if the data
1: 	 * value is not an object (yeah, right).
1: 	 *
1: 	 * @return	The data value as an Object.
1: 	 *
1: 	 * @exception StandardException   Thrown on error
1: 	 */
1: 	Object	getObject() throws StandardException;
1: 
1: 	/**
0: 	 * Gets the value in the data value descriptor as a Java InputStream.
0: 	 * Only data types that implements StreamStorable will have stream states.
1: 	 *
0: 	 * @return	The stream state of the data value.
1: 	 *
0: 	 * @exception StandardException   Throws an exception if the data value
0: 	 *								  cannot be received as a stream.
1: 	 */
0: 	InputStream	getStream() throws StandardException;
1: 	/**
0: 	 * <U>Shallow copy</U>. 
1: 	 * <p> 
0: 	 * Clone the DataValueDescriptor and copy its contents.
0: 	 * We clone the data value wrapper (e.g. SQLDecimal)
0: 	 * and reuse its contents (the underlying BigDecimal).
0: 	 * The resultant DataValueDescriptor will point to the same
0: 	 * value as the original DataValueDescriptor (unless the value
0: 	 * is a primitive type, e.g. SQLInteger/integer).
1: 	 *
0: 	 * @return A clone of the DataValueDescriptor reusing its contents.
1: 	 */
0: 	public DataValueDescriptor getClone();
1: 
1: 	/**
1: 	 * Get a new null value of the same type as this data value.
1: 	 *
1: 	 */
1: 	public DataValueDescriptor getNewNull();
1: 
1: 	/**
1: 	 * Set the value based on the value for the specified DataValueDescriptor
1: 	 * from the specified ResultSet.
1: 	 *
1: 	 * @param resultSet		The specified ResultSet.
1: 	 * @param colNumber		The 1-based column # into the resultSet.
1: 	 * @param isNullable	Whether or not the column is nullable
1: 	 *						(No need to call wasNull() if not)
1: 	 * 
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 * @exception SQLException		Error accessing the result set
1: 	 */
1: 	public void setValueFromResultSet(
1:     ResultSet   resultSet, 
1:     int         colNumber,
1:     boolean     isNullable)
1: 		throws StandardException, SQLException;
1: 
1: 
1: 	/**
1: 		Set this value into a PreparedStatement. This method must
1: 		handle setting NULL into the PreparedStatement.
1: 
1: 		@exception SQLException thrown by the PreparedStatement object
1: 		@exception StandardException thrown by me accessing my value.
1: 	*/
1: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException;
1: 
1: 	/**
1: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
1: 		or ResultSet.updateRow. This method will only be called for non-null values.
1: 
1: 		@exception SQLException thrown by the ResultSet object
1: 		@exception StandardException thrown by me accessing my value.
1: 	*/
1: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException;
1: 
1: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given value
1: 	 *
0: 	 * @param theValue	An Object containing the value to set this
1: 	 *					DataValueDescriptor to.  Null means set the value
1: 	 *					to SQL null.
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */ 
0: 	public void setValue(Object theValue) throws StandardException;
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given int value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(int theValue) throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given double value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(double theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given double value
1: 	 *
1: 	 * @param theValue	A Double containing the value to set this
1: 	 *					DataValueDescriptor to.  Null means set the value
1: 	 *					to SQL null.
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public void setValue(float theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given short value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(short theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given long value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(long theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given byte value
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(byte theValue) throws StandardException;
1: 
1: 	
1: 	/**
1: 	 * Set the value.
1: 	 *
1: 	 * @param theValue	Contains the boolean value to set this to
1: 	 *
0: 	 * @return	This value
1: 	 *
1: 	 */
1: 	public void setValue(boolean theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value.
1: 	 *
1: 	 * @param theValue	Contains the boolean value to set this to
1: 	 *
0: 	 * @return	This value
1: 	 *
1: 	 */
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The byte value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(byte[] theValue) throws StandardException;
1: 
1: /**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
0: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
0: 	public void setValue(BigDecimal theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The String value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(String theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Time theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database time value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Time theValue, Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Timestamp theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database timestamp value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Date theValue) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 *
1: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database date value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Date theValue, Calendar cal) throws StandardException;
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor from another.
1: 	 *
1: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(DataValueDescriptor theValue) throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Set the value to SQL null.
1: 	 */
1: 
1: 	void setToNull();
1: 
1: 	/**
1: 		Normalize the source value to this type described by this class
1: 		and the passed in DataTypeDescriptor. The type of the DataTypeDescriptor
1: 		must match this class.
1: 	*/
1: 	public void normalize(DataTypeDescriptor dtd, DataValueDescriptor source)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * The SQL "IS NULL" operator.  Returns true if this value
1: 	 * is null.
1: 	 *	 *
1: 	 * @return	True if this value is null.
1: 	 *
1: 	 */
1: 	public BooleanDataValue isNullOp();
1: 
1: 	/**
1: 	 * The SQL "IS NOT NULL" operator.  Returns true if this value
1: 	 * is not null.
1: 	 *
1: 	 *
1: 	 * @return	True if this value is not null.
1: 	 *
1: 	 */
1: 	public BooleanDataValue isNotNull();
1: 
1: 	/**
1: 	 * Get the SQL name of the datatype
1: 	 *
1: 	 * @return	The SQL name of the datatype
1: 	 */
1: 	public String	getTypeName();
1: 
1: 	/**
0: 	 * Set the Object that this Data Type contains (for an explicit cast).
1: 	 *
1: 	 * @param value					The new value
1: 	 * @param instanceOfResultType	Whether or not the new value 
1: 	 *								is an instanceof the result type.
0: 	 * @param resultTypeClassName   The class name of the resulting type 
1:      *                              (for error messages only).
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setObjectForCast(
1:     Object  value, 
1:     boolean instanceOfResultType, 
1:     String  resultTypeClassName) 
1:         throws StandardException;
1: 
1:     /**
1:      * Read the DataValueDescriptor from the stream.
1:      * <p>
1:      * Initialize the data value by reading it's values from the 
1:      * ArrayInputStream.  This interface is provided as a way to achieve
1:      * possible performance enhancement when reading an array can be 
1:      * optimized over reading from a generic stream from readExternal().
1:      *
1:      * @param ais    The array stream positioned at the beginning of the 
1:      *               byte stream to read from.
1:      *
1: 	 * @exception  IOException              Usual error is if you try to read 
1:      *                                      past limit on the stream.
1: 	 * @exception  ClassNotFoundException   If a necessary class can not be 
1:      *                                      found while reading the object from
1:      *                                      the stream.
1:      **/
1:     public void readExternalFromArray(
1:     ArrayInputStream    ais)
1:         throws IOException, ClassNotFoundException;
1: 
1: 	/**
1: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
1: 	 * how to do type promotion when using binary operators.  For example, float
1: 	 * has a higher precedence than int, so when adding an int to a float, the
1: 	 * result type is float.
1: 	 *
1: 	 * The precedence for some types is arbitrary.  For example, it doesn't
1: 	 * matter what the precedence of the boolean type is, since it can't be
1: 	 * mixed with other types.  But the precedence for the number types is
1: 	 * critical.  The SQL standard requires that exact numeric types be
1: 	 * promoted to approximate numeric when one operator uses both.  Also,
1: 	 * the precedence is arranged so that one will not lose precision when
1: 	 * promoting a type.
1: 	 *
1: 	 * @return		The precedence of this type.
1: 	 */
1: 	int					typePrecedence();
1: 
1: 	/**
1: 	 * The SQL language = operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue equals(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 	/**
0: 	 * The SQL language <> operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 	/**
0: 	 * The SQL language < operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 	/**
0: 	 * The SQL language > operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 	/**
0: 	 * The SQL language <= operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 	/**
0: 	 * The SQL language >= operator.  This method is called from the language
1: 	 * module.  The storage module uses the compare method in Orderable.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param right		The value on the right side of the operator
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1: 									DataValueDescriptor right)
1: 						throws StandardException;
1: 
1: 
1: 	/**
1: 	 * The SQL language COALESCE/VALUE function.  This method is called from the language
1: 	 * module.  
1: 	 *
1: 	 * @param list		The list of the arguments. Function will return the first non-nullable argument if any.
1: 	 * @param returnValue		The return value is the correct datatype for this function.
1: 	 * The return value of this method is the type of the 2nd parameter.
1: 	 *
1: 	 * @return	A DataValueDescriptor which will be either null or first non-null argument
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataValueDescriptor coalesce(DataValueDescriptor[] list, DataValueDescriptor returnValue)
1: 						throws StandardException;
1: 
1: 	/**
1: 	 * The SQL language IN operator.  This method is called from the language
1: 	 * module.  This method allows us to optimize and short circuit the search
1: 	 * if the list is ordered.
1: 	 *
1: 	 * @param left		The value on the left side of the operator
1: 	 * @param inList	The values in the IN list
1: 	 * @param orderedList	True means that the values in the IN list are ordered,
1: 	 *						false means they are not.
1: 	 *
1: 	 * @return	A BooleanDataValue telling the result of the comparison
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue in(DataValueDescriptor left,
1: 							   DataValueDescriptor[] inList,
1: 							   boolean orderedList) 
1: 						throws StandardException;
1: 
1: 	/**
1: 	 * Compare this Orderable with a given Orderable for the purpose of
1: 	 * index positioning.  This method treats nulls as ordered values -
0: 	 * that is, it treats SQL null as equal to null and less than all
1: 	 * other values.
1: 	 *
1: 	 * @param other		The Orderable to compare this one to.
1: 	 *
0: 	 * @return  <0 - this Orderable is less than other.
1: 	 * 			 0 - this Orderable equals other.
0: 	 *			>0 - this Orderable is greater than other.
1:      *
1:      *			The code should not explicitly look for -1, or 1.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	int compare(DataValueDescriptor other) throws StandardException;
1: 
1: 	/**
1: 	 * Compare this Orderable with a given Orderable for the purpose of
1: 	 * qualification and sorting.  The caller gets to determine how nulls
1: 	 * should be treated - they can either be ordered values or unknown
1: 	 * values.
1: 	 *
1: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
0: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this < other.
0: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this <= other.
1: 	 * @param other	The DataValueDescriptor to compare this one to.
1: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1: 	 *						that is, treat SQL null as equal to null, and less
1: 	 *						than all other values.
1: 	 *						False means to treat nulls as unknown values,
1: 	 *						that is, the result of any comparison with a null
1: 	 *						is the UNKNOWN truth value.
1: 	 * @param unknownRV		The return value to use if the result of the
1: 	 *						comparison is the UNKNOWN truth value.  In other
1: 	 *						words, if orderedNulls is false, and a null is
1: 	 *						involved in the comparison, return unknownRV.
1: 	 *						This parameter is not used orderedNulls is true.
1: 	 *
1: 	 * @return	true if the comparison is true (duh!)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean compare(
1:     int         op, 
1:     DataValueDescriptor   other,
1:     boolean     orderedNulls, 
1:     boolean     unknownRV)
1: 				throws StandardException;
1: 
1: 	/**
0: 		Set the value to be the contents of the stream.
0: 		The reading of the stream may be delayed until execution time.
0: 		The format of the stream is required to be the format of this type.
1: 
0: 		@param	theStream	stream of correctly formatted data
0: 		@param	streamLength	logical length of the stream's value in units of this type (e.g. chars for string types).
1: 	*/
0: 	public void setValue(InputStream theStream, int streamLength) throws StandardException;
1: 
1: 	/**
1: 		Check the value to seem if it conforms to the restrictions
1: 		imposed by DB2/JCC on host variables for this type.
1: 
1: 		@exception StandardException Variable is too big.
1: 	*/
1: 	public void checkHostVariable(int declaredLength) throws StandardException;
1: 
1:     /**
1:      * Estimate the memory usage in bytes of the data value and the overhead of the class.
1:      *
1:      * @return the estimated memory usage
1:      */
1:     int estimateMemoryUsage();
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import java.io.InputStream;
0: import java.io.IOException;
0: import java.math.BigDecimal;
0: import java.sql.Date;
0: import java.sql.ResultSet;
0: import java.sql.PreparedStatement;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.SQLException;
0: import java.util.Calendar;
0: 
0: /**
0:  * The DataValueDescriptor interface provides methods to get the data from
0:  * a column returned by a statement.  This interface has the same methods
0:  * as NoCastDataValueDescriptor - the only reason it exists is for purposes
0:  * of internal documentation, to make it clear when the different getXXX
0:  * methods throw exceptions for illegal conversions.
0:  * <p>
0:  * This interface matches the getXXX methods on java.sql.ResultSet. This means
0:  * everyone satisfies getString and getObject; all of the numeric types, within
0:  * the limits of representation, satisfy all of the numeric getXXX methods;
0:  * all of the character types satisfy all of the getXXX methods except
0:  * getBytes and getBinaryStream; all of the binary types satisfy getBytes and
0:  * all of the getXXXStream methods; Date satisfies getDate and getTimestamp;
0:  * Time satisfies getTime; and Timestamp satisfies all of the date/time getXXX 
0:  * methods.
0:  * The "preferred" method (one that will always work, I presume) is the one that
0:  * matches the type most closely. See the comments below for
0:  * "preferences".  See the JDBC guide for details.
0:  * <p>
0:  * This interface does not include the getXXXStream methods.
0:  * <p>
0:  * The preferred methods for JDBC are:
0:  * <p>
0:  * CHAR and VARCHAR - getString()
0:  * <p>
0:  * BIT - getBoolean()
0:  * <p>
0:  * TINYINT - getByte()
0:  * <p>
0:  * SMALLINT - getShort()
0:  * <p>
0:  * INTEGER - getInt()
0:  * <p>
0:  * BIGINT - getLong()
0:  * <p>
0:  * REAL - getFloat()
0:  * <p>
0:  * FLOAT and DOUBLE - getDouble()
0:  * <p>
0:  * DECIMAL and NUMERIC - getBigDecimal()
0:  * <p>
0:  * BINARY and VARBINARY - getBytes()
0:  * <p>
0:  * DATE - getDate()
0:  * <p>
0:  * TIME - getTime()
0:  * <p>
0:  * TIMESTAMP - getTimestamp()
0:  * <p>
0:  * No JDBC type corresponds to getObject().  Use this for user-defined types
0:  * or to get the JDBC types as java Objects.  All primitive types will be
0:  * wrapped in their corresponding Object type, i.e. int will be
0:  * wrapped in an Integer.
0:  * <p>
0:  * getStream() 
0:  * 
0:  * @author Jeff Lichtman
0:  */
0: 
0: public interface DataValueDescriptor extends Storable, Orderable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	/**
0: 	 * Gets the length of the data value.  The meaning of this is
0: 	 * implementation-dependent.  For string types, it is the number of
0: 	 * characters in the string.  For numeric types, it is the number of
0: 	 * bytes used to store the number.  This is the actual length
0: 	 * of this value, not the length of the type it was defined as.
0: 	 * For example, a VARCHAR value may be shorter than the declared
0: 	 * VARCHAR (maximum) length.
0: 	 *
0: 	 * @return	The length of the data value
0: 	 *
0: 	 * @exception StandardException   On error
0: 	 */
0: 	int	getLength() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a String.
0: 	 * Throws an exception if the data value is not a string.
0: 	 *
0: 	 * @return	The data value as a String.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	String	getString() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a boolean.
0: 	 * Throws an exception if the data value is not a boolean.
0: 	 * For DataValueDescriptor, this is the preferred interface
0: 	 * for BIT, but for this no-casting interface, it isn't, because
0: 	 * BIT is stored internally as a Bit, not as a Boolean.
0: 	 *
0: 	 * @return	The data value as a boolean.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	boolean	getBoolean() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a byte.
0: 	 * Throws an exception if the data value is not a byte.
0: 	 *
0: 	 * @return	The data value as a byte.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	byte	getByte() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a short.
0: 	 * Throws an exception if the data value is not a short.
0: 	 *
0: 	 * @return	The data value as a short.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	short	getShort() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as an int.
0: 	 * Throws an exception if the data value is not an int.
0: 	 *
0: 	 * @return	The data value as a int.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	int	getInt() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a long.
0: 	 * Throws an exception if the data value is not a long.
0: 	 *
0: 	 * @return	The data value as a long.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	long	getLong() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a float.
0: 	 * Throws an exception if the data value is not a float.
0: 	 *
0: 	 * @return	The data value as a float.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	float	getFloat() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a double.
0: 	 * Throws an exception if the data value is not a double.
0: 	 *
0: 	 * @return	The data value as a double.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	double	getDouble() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a BigDecimal.
0: 	 * Throws an exception if the data value is not a BigDecimal.
0: 	 *
0: 	 * @return	The data value as a java.math.BigDecimal.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	BigDecimal	getBigDecimal() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a byte array.
0: 	 * Throws an exception if the data value is not a byte array.
0: 	 *
0: 	 * @return	The data value as a byte[].
0: 	 *
0: 	 * @exception StandardException  Thrown on error
0: 	 */
0: 	byte[]	getBytes() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Date.
0: 	 * Throws an exception if the data value is not a Date.
0:      *	@param cal calendar for object creation
0: 	 * @return	The data value as a java.sql.Date.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	Date getDate(java.util.Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Time.
0: 	 * Throws an exception if the data value is not a Time.
0:      *	@param cal calendar for object creation
0: 	 *
0: 	 * @return	The data value as a java.sql.Time.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	Time	getTime(java.util.Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
0: 	 * Throws an exception if the data value is not a Timestamp.
0:      *	@param cal calendar for object creation
0: 	 * @return	The data value as a java.sql.Timestamp.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a Java Object.
0: 	 * The type of the Object will be the Java object type corresponding
0: 	 * to the data value's SQL type. JDBC defines a mapping between Java
0: 	 * object types and SQL types - we will allow that to be extended
0: 	 * through user type definitions. Throws an exception if the data
0: 	 * value is not an object (yeah, right).
0: 	 *
0: 	 * @return	The data value as an Object.
0: 	 *
0: 	 * @exception StandardException   Thrown on error
0: 	 */
0: 	Object	getObject() throws StandardException;
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a Java InputStream.
0: 	 * Only data types that implements StreamStorable will have stream states.
0: 	 *
0: 	 * @return	The stream state of the data value.
0: 	 *
0: 	 * @exception StandardException   Throws an exception if the data value
0: 	 *								  cannot be received as a stream.
0: 	 */
0: 	InputStream	getStream() throws StandardException;
0: 	/**
0: 	 * <U>Shallow copy</U>. 
0: 	 * <p> 
0: 	 * Clone the DataValueDescriptor and copy its contents.
0: 	 * We clone the data value wrapper (e.g. SQLDecimal)
0: 	 * and reuse its contents (the underlying BigDecimal).
0: 	 * The resultant DataValueDescriptor will point to the same
0: 	 * value as the original DataValueDescriptor (unless the value
0: 	 * is a primitive type, e.g. SQLInteger/integer).
0: 	 *
0: 	 * @return A clone of the DataValueDescriptor reusing its contents.
0: 	 */
0: 	public DataValueDescriptor getClone();
0: 
0: 	/**
0: 	 * Get a new null value of the same type as this data value.
0: 	 *
0: 	 */
0: 	public DataValueDescriptor getNewNull();
0: 
0: 	/**
0: 	 * Set the value based on the value for the specified DataValueDescriptor
0: 	 * from the specified ResultSet.
0: 	 *
0: 	 * @param resultSet		The specified ResultSet.
0: 	 * @param colNumber		The 1-based column # into the resultSet.
0: 	 * @param isNullable	Whether or not the column is nullable
0: 	 *						(No need to call wasNull() if not)
0: 	 * 
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 * @exception SQLException		Error accessing the result set
0: 	 */
0: 	public void setValueFromResultSet(
0:     ResultSet   resultSet, 
0:     int         colNumber,
0:     boolean     isNullable)
0: 		throws StandardException, SQLException;
0: 
0: 
0: 	/**
0: 		Set this value into a PreparedStatement. This method must
0: 		handle setting NULL into the PreparedStatement.
0: 
0: 		@exception SQLException thrown by the PreparedStatement object
0: 		@exception StandardException thrown by me accessing my value.
0: 	*/
0: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException;
0: 
0: 	/**
0: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
0: 		or ResultSet.updateRow. This method will only be called for non-null values.
0: 
0: 		@exception SQLException thrown by the ResultSet object
0: 		@exception StandardException thrown by me accessing my value.
0: 	*/
0: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given value
0: 	 *
0: 	 * @param theValue	An Object containing the value to set this
0: 	 *					DataValueDescriptor to.  Null means set the value
0: 	 *					to SQL null.
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */ 
0: 	public void setValue(Object theValue) throws StandardException;
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given int value
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(int theValue) throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given double value
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(double theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given double value
0: 	 *
0: 	 * @param theValue	A Double containing the value to set this
0: 	 *					DataValueDescriptor to.  Null means set the value
0: 	 *					to SQL null.
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void setValue(float theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given short value
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(short theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given long value
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(long theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given byte value
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(byte theValue) throws StandardException;
0: 
0: 	
0: 	/**
0: 	 * Set the value.
0: 	 *
0: 	 * @param theValue	Contains the boolean value to set this to
0: 	 *
0: 	 * @return	This value
0: 	 *
0: 	 */
0: 	public void setValue(boolean theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value.
0: 	 *
0: 	 * @param theValue	Contains the boolean value to set this to
0: 	 *
0: 	 * @return	This value
0: 	 *
0: 	 */
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The byte value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(byte[] theValue) throws StandardException;
0: 
0: /**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(BigDecimal theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The String value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(String theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Time value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Time theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Time value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database time value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Time theValue, Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Timestamp theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database timestamp value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Date value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Date theValue) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 *
0: 	 * @param theValue	The Date value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database date value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Date theValue, Calendar cal) throws StandardException;
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor from another.
0: 	 *
0: 	 * @param theValue	The Date value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(DataValueDescriptor theValue) throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Set the value to SQL null.
0: 	 */
0: 
0: 	void setToNull();
0: 
0: 	/**
0: 		Normalize the source value to this type described by this class
0: 		and the passed in DataTypeDescriptor. The type of the DataTypeDescriptor
0: 		must match this class.
0: 	*/
0: 	public void normalize(DataTypeDescriptor dtd, DataValueDescriptor source)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * The SQL "IS NULL" operator.  Returns true if this value
0: 	 * is null.
0: 	 *	 *
0: 	 * @return	True if this value is null.
0: 	 *
0: 	 */
0: 	public BooleanDataValue isNullOp();
0: 
0: 	/**
0: 	 * The SQL "IS NOT NULL" operator.  Returns true if this value
0: 	 * is not null.
0: 	 *
0: 	 *
0: 	 * @return	True if this value is not null.
0: 	 *
0: 	 */
0: 	public BooleanDataValue isNotNull();
0: 
0: 	/**
0: 	 * Get the SQL name of the datatype
0: 	 *
0: 	 * @return	The SQL name of the datatype
0: 	 */
0: 	public String	getTypeName();
0: 
0: 	/**
0: 	 * Set the Object that this Data Type contains (for an explicit cast).
0: 	 *
0: 	 * @param value					The new value
0: 	 * @param instanceOfResultType	Whether or not the new value 
0: 	 *								is an instanceof the result type.
0: 	 * @param resultTypeClassName   The class name of the resulting type 
0:      *                              (for error messages only).
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setObjectForCast(
0:     Object  value, 
0:     boolean instanceOfResultType, 
0:     String  resultTypeClassName) 
0:         throws StandardException;
0: 
0:     /**
0:      * Read the DataValueDescriptor from the stream.
0:      * <p>
0:      * Initialize the data value by reading it's values from the 
0:      * ArrayInputStream.  This interface is provided as a way to achieve
0:      * possible performance enhancement when reading an array can be 
0:      * optimized over reading from a generic stream from readExternal().
0:      *
0:      * @param ais    The array stream positioned at the beginning of the 
0:      *               byte stream to read from.
0:      *
0: 	 * @exception  IOException              Usual error is if you try to read 
0:      *                                      past limit on the stream.
0: 	 * @exception  ClassNotFoundException   If a necessary class can not be 
0:      *                                      found while reading the object from
0:      *                                      the stream.
0:      **/
0:     public void readExternalFromArray(
0:     ArrayInputStream    ais)
0:         throws IOException, ClassNotFoundException;
0: 
0: 	/**
0: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
0: 	 * how to do type promotion when using binary operators.  For example, float
0: 	 * has a higher precedence than int, so when adding an int to a float, the
0: 	 * result type is float.
0: 	 *
0: 	 * The precedence for some types is arbitrary.  For example, it doesn't
0: 	 * matter what the precedence of the boolean type is, since it can't be
0: 	 * mixed with other types.  But the precedence for the number types is
0: 	 * critical.  The SQL standard requires that exact numeric types be
0: 	 * promoted to approximate numeric when one operator uses both.  Also,
0: 	 * the precedence is arranged so that one will not lose precision when
0: 	 * promoting a type.
0: 	 *
0: 	 * @return		The precedence of this type.
0: 	 */
0: 	int					typePrecedence();
0: 
0: 	/**
0: 	 * The SQL language = operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue equals(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language <> operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue notEquals(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language < operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue lessThan(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language > operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language <= operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language >= operator.  This method is called from the language
0: 	 * module.  The storage module uses the compare method in Orderable.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param right		The value on the right side of the operator
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
0: 									DataValueDescriptor right)
0: 						throws StandardException;
0: 
0: 
0: 	/**
0: 	 * The SQL language COALESCE/VALUE function.  This method is called from the language
0: 	 * module.  
0: 	 *
0: 	 * @param list		The list of the arguments. Function will return the first non-nullable argument if any.
0: 	 * @param returnValue		The return value is the correct datatype for this function.
0: 	 * The return value of this method is the type of the 2nd parameter.
0: 	 *
0: 	 * @return	A DataValueDescriptor which will be either null or first non-null argument
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor coalesce(DataValueDescriptor[] list, DataValueDescriptor returnValue)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * The SQL language IN operator.  This method is called from the language
0: 	 * module.  This method allows us to optimize and short circuit the search
0: 	 * if the list is ordered.
0: 	 *
0: 	 * @param left		The value on the left side of the operator
0: 	 * @param inList	The values in the IN list
0: 	 * @param orderedList	True means that the values in the IN list are ordered,
0: 	 *						false means they are not.
0: 	 *
0: 	 * @return	A BooleanDataValue telling the result of the comparison
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue in(DataValueDescriptor left,
0: 							   DataValueDescriptor[] inList,
0: 							   boolean orderedList) 
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * Compare this Orderable with a given Orderable for the purpose of
0: 	 * index positioning.  This method treats nulls as ordered values -
0: 	 * that is, it treats SQL null as equal to null and less than all
0: 	 * other values.
0: 	 *
0: 	 * @param other		The Orderable to compare this one to.
0: 	 *
0: 	 * @return  <0 - this Orderable is less than other.
0: 	 * 			 0 - this Orderable equals other.
0: 	 *			>0 - this Orderable is greater than other.
0:      *
0:      *			The code should not explicitly look for -1, or 1.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	int compare(DataValueDescriptor other) throws StandardException;
0: 
0: 	/**
0: 	 * Compare this Orderable with a given Orderable for the purpose of
0: 	 * qualification and sorting.  The caller gets to determine how nulls
0: 	 * should be treated - they can either be ordered values or unknown
0: 	 * values.
0: 	 *
0: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
0: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this < other.
0: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this <= other.
0: 	 * @param other	The DataValueDescriptor to compare this one to.
0: 	 * @param orderedNulls	True means to treat nulls as ordered values,
0: 	 *						that is, treat SQL null as equal to null, and less
0: 	 *						than all other values.
0: 	 *						False means to treat nulls as unknown values,
0: 	 *						that is, the result of any comparison with a null
0: 	 *						is the UNKNOWN truth value.
0: 	 * @param unknownRV		The return value to use if the result of the
0: 	 *						comparison is the UNKNOWN truth value.  In other
0: 	 *						words, if orderedNulls is false, and a null is
0: 	 *						involved in the comparison, return unknownRV.
0: 	 *						This parameter is not used orderedNulls is true.
0: 	 *
0: 	 * @return	true if the comparison is true (duh!)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean compare(
0:     int         op, 
0:     DataValueDescriptor   other,
0:     boolean     orderedNulls, 
0:     boolean     unknownRV)
0: 				throws StandardException;
0: 
0: 	/**
0: 		Set the value to be the contents of the stream.
0: 		The reading of the stream may be delayed until execution time.
0: 		The format of the stream is required to be the format of this type.
0: 
0: 		@param	theStream	stream of correctly formatted data
0: 		@param	streamLength	logical length of the stream's value in units of this type (e.g. chars for string types).
0: 	*/
0: 	public void setValue(InputStream theStream, int streamLength) throws StandardException;
0: 
0: 	/**
0: 		Check the value to seem if it conforms to the restrictions
0: 		imposed by DB2/JCC on host variables for this type.
0: 
0: 		@exception StandardException Variable is too big.
0: 	*/
0: 	public void checkHostVariable(int declaredLength) throws StandardException;
0: 
0:     /**
0:      * Estimate the memory usage in bytes of the data value and the overhead of the class.
0:      *
0:      * @return the estimated memory usage
0:      */
0:     int estimateMemoryUsage();
0: }
============================================================================