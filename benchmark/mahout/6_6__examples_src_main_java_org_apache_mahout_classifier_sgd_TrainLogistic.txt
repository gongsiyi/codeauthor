1:7aa6232: /*
1:7aa6232:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7aa6232:  * contributor license agreements.  See the NOTICE file distributed with
1:7aa6232:  * this work for additional information regarding copyright ownership.
1:7aa6232:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7aa6232:  * (the "License"); you may not use this file except in compliance with
1:7aa6232:  * the License.  You may obtain a copy of the License at
1:7aa6232:  *
1:7aa6232:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7aa6232:  *
1:7aa6232:  * Unless required by applicable law or agreed to in writing, software
1:7aa6232:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7aa6232:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7aa6232:  * See the License for the specific language governing permissions and
1:7aa6232:  * limitations under the License.
1:7aa6232:  */
9:7aa6232: 
1:7aa6232: package org.apache.mahout.classifier.sgd;
1:7aa6232: 
1:4ef9d31: import com.google.common.io.Resources;
1:4ef9d31: import org.apache.commons.cli2.CommandLine;
1:4ef9d31: import org.apache.commons.cli2.Group;
1:4ef9d31: import org.apache.commons.cli2.Option;
1:4ef9d31: import org.apache.commons.cli2.builder.ArgumentBuilder;
1:4ef9d31: import org.apache.commons.cli2.builder.DefaultOptionBuilder;
1:4ef9d31: import org.apache.commons.cli2.builder.GroupBuilder;
1:4ef9d31: import org.apache.commons.cli2.commandline.Parser;
1:4ef9d31: import org.apache.commons.cli2.util.HelpFormatter;
1:4ef9d31: import org.apache.commons.io.Charsets;
1:4ef9d31: import org.apache.mahout.math.RandomAccessSparseVector;
1:4ef9d31: import org.apache.mahout.math.Vector;
1:4ef9d31: 
1:87d4b2e: import java.io.BufferedReader;
1:87d4b2e: import java.io.File;
1:87d4b2e: import java.io.FileInputStream;
1:87d4b2e: import java.io.FileOutputStream;
1:87d4b2e: import java.io.IOException;
1:87d4b2e: import java.io.InputStream;
1:87d4b2e: import java.io.InputStreamReader;
1:87d4b2e: import java.io.OutputStream;
1:87d4b2e: import java.io.OutputStreamWriter;
1:87d4b2e: import java.io.PrintWriter;
1:4ef9d31: import java.util.ArrayList;
1:87d4b2e: import java.util.List;
1:87d4b2e: import java.util.Locale;
1:87d4b2e: 
1:7aa6232: /**
1:7aa6232:  * Train a logistic regression for the examples from Chapter 13 of Mahout in Action
1:7aa6232:  */
1:8a99d75: public final class TrainLogistic {
1:8a99d75: 
1:7aa6232:   private static String inputFile;
1:7aa6232:   private static String outputFile;
1:7aa6232:   private static LogisticModelParameters lmp;
1:7aa6232:   private static int passes;
1:8a99d75:   private static boolean scores;
1:d4b7924:   private static OnlineLogisticRegression model;
1:7aa6232: 
1:8a99d75:   private TrainLogistic() {
1:8a99d75:   }
1:d2dd884: 
1:d2dd884:   public static void main(String[] args) throws Exception {
1:229aeff:     mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));
1:a515335:   }
1:a515335: 
1:d2dd884:   static void mainToOutput(String[] args, PrintWriter output) throws Exception {
1:7aa6232:     if (parseArgs(args)) {
1:7aa6232:       double logPEstimate = 0;
1:7aa6232:       int samples = 0;
1:8a99d75: 
1:7aa6232:       CsvRecordFactory csv = lmp.getCsvRecordFactory();
1:7aa6232:       OnlineLogisticRegression lr = lmp.createRegression();
1:7aa6232:       for (int pass = 0; pass < passes; pass++) {
1:4ef9d31:         try (BufferedReader in = open(inputFile)) {
1:d608a88:           // read variable names
1:d608a88:           csv.firstLine(in.readLine());
1:7aa6232: 
1:d608a88:           String line = in.readLine();
1:d608a88:           while (line != null) {
1:d608a88:             // for each new line, get target and predictors
1:d608a88:             Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());
1:d608a88:             int targetValue = csv.processLine(line, input);
1:7aa6232: 
1:d608a88:             // check performance while this is still news
1:d608a88:             double logP = lr.logLikelihood(targetValue, input);
1:d608a88:             if (!Double.isInfinite(logP)) {
1:d608a88:               if (samples < 20) {
1:d608a88:                 logPEstimate = (samples * logPEstimate + logP) / (samples + 1);
1:d608a88:               } else {
1:d608a88:                 logPEstimate = 0.95 * logPEstimate + 0.05 * logP;
1:d2dd884:               }
1:d608a88:               samples++;
1:d608a88:             }
1:d608a88:             double p = lr.classifyScalar(input);
1:d608a88:             if (scores) {
1:bdb1c48:               output.printf(Locale.ENGLISH, "%10d %2d %10.2f %2.4f %10.4f %10.4f%n",
1:d608a88:                 samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);
1:d608a88:             }
1:7aa6232: 
1:d608a88:             // now update model
1:d608a88:             lr.train(targetValue, input);
1:7aa6232: 
1:d608a88:             line = in.readLine();
1:d608a88:           }
1:8a99d75:         }
6:7aa6232:       }
1:7aa6232: 
1:4ef9d31:       try (OutputStream modelOutput = new FileOutputStream(outputFile)) {
1:8a99d75:         lmp.saveTo(modelOutput);
1:8a99d75:       }
1:7aa6232: 
1:229aeff:       output.println(lmp.getNumFeatures());
1:229aeff:       output.println(lmp.getTargetVariable() + " ~ ");
1:7aa6232:       String sep = "";
1:ff31f37:       for (String v : csv.getTraceDictionary().keySet()) {
1:7aa6232:         double weight = predictorWeight(lr, 0, csv, v);
1:7aa6232:         if (weight != 0) {
1:977cc39:           output.printf(Locale.ENGLISH, "%s%.3f*%s", sep, weight, v);
1:7aa6232:           sep = " + ";
1:7aa6232:         }
1:7aa6232:       }
1:bdb1c48:       output.printf("%n");
1:d4b7924:       model = lr;
1:7aa6232:       for (int row = 0; row < lr.getBeta().numRows(); row++) {
1:7aa6232:         for (String key : csv.getTraceDictionary().keySet()) {
1:7aa6232:           double weight = predictorWeight(lr, row, csv, key);
1:7aa6232:           if (weight != 0) {
1:bdb1c48:             output.printf(Locale.ENGLISH, "%20s %.5f%n", key, weight);
1:7aa6232:           }
1:7aa6232:         }
1:7aa6232:         for (int column = 0; column < lr.getBeta().numCols(); column++) {
1:977cc39:           output.printf(Locale.ENGLISH, "%15.9f ", lr.getBeta().get(row, column));
1:7aa6232:         }
1:ebaa95d:         output.println();
1:7aa6232:       }
1:7aa6232:     }
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static double predictorWeight(OnlineLogisticRegression lr, int row, RecordFactory csv, String predictor) {
1:7aa6232:     double weight = 0;
1:7aa6232:     for (Integer column : csv.getTraceDictionary().get(predictor)) {
1:7aa6232:       weight += lr.getBeta().get(row, column);
1:7aa6232:     }
1:7aa6232:     return weight;
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static boolean parseArgs(String[] args) {
1:7aa6232:     DefaultOptionBuilder builder = new DefaultOptionBuilder();
1:7aa6232: 
1:7aa6232:     Option help = builder.withLongName("help").withDescription("print this list").create();
1:7aa6232: 
1:7aa6232:     Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();
1:7aa6232:     Option scores = builder.withLongName("scores").withDescription("output score diagnostics during training").create();
1:7aa6232: 
1:7aa6232:     ArgumentBuilder argumentBuilder = new ArgumentBuilder();
1:7aa6232:     Option inputFile = builder.withLongName("input")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("input").withMaximum(1).create())
1:7aa6232:             .withDescription("where to get training data")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option outputFile = builder.withLongName("output")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("output").withMaximum(1).create())
1:7aa6232:             .withDescription("where to get training data")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option predictors = builder.withLongName("predictors")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("p").create())
1:7aa6232:             .withDescription("a list of predictor variables")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option types = builder.withLongName("types")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("t").create())
1:7aa6232:             .withDescription("a list of predictor variable types (numeric, word, or text)")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option target = builder.withLongName("target")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("target").withMaximum(1).create())
1:7aa6232:             .withDescription("the name of the target variable")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option features = builder.withLongName("features")
1:7aa6232:             .withArgument(
1:7aa6232:                     argumentBuilder.withName("numFeatures")
1:7aa6232:                             .withDefault("1000")
1:7aa6232:                             .withMaximum(1).create())
1:7aa6232:             .withDescription("the number of internal hashed features to use")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option passes = builder.withLongName("passes")
1:7aa6232:             .withArgument(
1:7aa6232:                     argumentBuilder.withName("passes")
1:7aa6232:                             .withDefault("2")
1:7aa6232:                             .withMaximum(1).create())
1:7aa6232:             .withDescription("the number of times to pass over the input data")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option lambda = builder.withLongName("lambda")
1:7aa6232:             .withArgument(argumentBuilder.withName("lambda").withDefault("1e-4").withMaximum(1).create())
1:7aa6232:             .withDescription("the amount of coefficient decay to use")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option rate = builder.withLongName("rate")
1:7aa6232:             .withArgument(argumentBuilder.withName("learningRate").withDefault("1e-3").withMaximum(1).create())
1:7aa6232:             .withDescription("the learning rate")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option noBias = builder.withLongName("noBias")
1:7aa6232:             .withDescription("don't include a bias term")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Option targetCategories = builder.withLongName("categories")
1:7aa6232:             .withRequired(true)
1:7aa6232:             .withArgument(argumentBuilder.withName("number").withMaximum(1).create())
1:7aa6232:             .withDescription("the number of target categories to be considered")
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Group normalArgs = new GroupBuilder()
1:7aa6232:             .withOption(help)
1:7aa6232:             .withOption(quiet)
1:7aa6232:             .withOption(inputFile)
1:7aa6232:             .withOption(outputFile)
1:7aa6232:             .withOption(target)
1:7aa6232:             .withOption(targetCategories)
1:7aa6232:             .withOption(predictors)
1:7aa6232:             .withOption(types)
1:7aa6232:             .withOption(passes)
1:7aa6232:             .withOption(lambda)
1:7aa6232:             .withOption(rate)
1:7aa6232:             .withOption(noBias)
1:7aa6232:             .withOption(features)
1:7aa6232:             .create();
1:7aa6232: 
1:7aa6232:     Parser parser = new Parser();
1:7aa6232:     parser.setHelpOption(help);
1:7aa6232:     parser.setHelpTrigger("--help");
1:7aa6232:     parser.setGroup(normalArgs);
1:7aa6232:     parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));
1:c1a4188:     CommandLine cmdLine = parser.parseAndHelp(args);
1:7aa6232: 
1:7aa6232:     if (cmdLine == null) {
1:7aa6232:       return false;
1:7aa6232:     }
1:7aa6232: 
1:7aa6232:     TrainLogistic.inputFile = getStringArgument(cmdLine, inputFile);
1:7aa6232:     TrainLogistic.outputFile = getStringArgument(cmdLine, outputFile);
1:7aa6232: 
1:4ef9d31:     List<String> typeList = new ArrayList<>();
1:7aa6232:     for (Object x : cmdLine.getValues(types)) {
1:7aa6232:       typeList.add(x.toString());
1:7aa6232:     }
1:7aa6232: 
1:4ef9d31:     List<String> predictorList = new ArrayList<>();
1:7aa6232:     for (Object x : cmdLine.getValues(predictors)) {
1:7aa6232:       predictorList.add(x.toString());
1:7aa6232:     }
1:7aa6232: 
1:7aa6232:     lmp = new LogisticModelParameters();
1:7aa6232:     lmp.setTargetVariable(getStringArgument(cmdLine, target));
1:7aa6232:     lmp.setMaxTargetCategories(getIntegerArgument(cmdLine, targetCategories));
1:7aa6232:     lmp.setNumFeatures(getIntegerArgument(cmdLine, features));
1:7aa6232:     lmp.setUseBias(!getBooleanArgument(cmdLine, noBias));
1:7aa6232:     lmp.setTypeMap(predictorList, typeList);
1:7aa6232: 
1:7aa6232:     lmp.setLambda(getDoubleArgument(cmdLine, lambda));
1:7aa6232:     lmp.setLearningRate(getDoubleArgument(cmdLine, rate));
1:7aa6232: 
1:7aa6232:     TrainLogistic.scores = getBooleanArgument(cmdLine, scores);
1:7aa6232:     TrainLogistic.passes = getIntegerArgument(cmdLine, passes);
1:7aa6232: 
1:7aa6232:     return true;
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static String getStringArgument(CommandLine cmdLine, Option inputFile) {
1:7aa6232:     return (String) cmdLine.getValue(inputFile);
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static boolean getBooleanArgument(CommandLine cmdLine, Option option) {
1:7aa6232:     return cmdLine.hasOption(option);
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static int getIntegerArgument(CommandLine cmdLine, Option features) {
1:7aa6232:     return Integer.parseInt((String) cmdLine.getValue(features));
1:7aa6232:   }
1:7aa6232: 
1:7aa6232:   private static double getDoubleArgument(CommandLine cmdLine, Option op) {
1:7aa6232:     return Double.parseDouble((String) cmdLine.getValue(op));
1:7aa6232:   }
1:7aa6232: 
1:d4b7924:   public static OnlineLogisticRegression getModel() {
1:d4b7924:     return model;
1:d4b7924:   }
1:d4b7924: 
1:d4b7924:   public static LogisticModelParameters getParameters() {
1:d4b7924:     return lmp;
1:d4b7924:   }
1:d4b7924: 
1:61ae2e7:   static BufferedReader open(String inputFile) throws IOException {
1:ad8b61d:     InputStream in;
1:d2dd884:     try {
1:d61a0ee:       in = Resources.getResource(inputFile).openStream();
1:61ae2e7:     } catch (IllegalArgumentException e) {
1:ad8b61d:       in = new FileInputStream(new File(inputFile));
1:7aa6232:     }
1:80366ee:     return new BufferedReader(new InputStreamReader(in, Charsets.UTF_8));
1:7aa6232:   }
1:7aa6232: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:4ef9d31
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.io.Resources;
1: import org.apache.commons.cli2.CommandLine;
1: import org.apache.commons.cli2.Group;
1: import org.apache.commons.cli2.Option;
1: import org.apache.commons.cli2.builder.ArgumentBuilder;
1: import org.apache.commons.cli2.builder.DefaultOptionBuilder;
1: import org.apache.commons.cli2.builder.GroupBuilder;
1: import org.apache.commons.cli2.commandline.Parser;
1: import org.apache.commons.cli2.util.HelpFormatter;
1: import org.apache.commons.io.Charsets;
1: import org.apache.mahout.math.RandomAccessSparseVector;
1: import org.apache.mahout.math.Vector;
1: 
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:         try (BufferedReader in = open(inputFile)) {
/////////////////////////////////////////////////////////////////////////
1:       try (OutputStream modelOutput = new FileOutputStream(outputFile)) {
/////////////////////////////////////////////////////////////////////////
1:     List<String> typeList = new ArrayList<>();
1:     List<String> predictorList = new ArrayList<>();
author:dfilimon
-------------------------------------------------------------------------------
commit:87d4b2e
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.OutputStream;
1: import java.io.OutputStreamWriter;
1: import java.io.PrintWriter;
1: import java.util.List;
1: import java.util.Locale;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Closeables.close(modelOutput, false);
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:31cb292
/////////////////////////////////////////////////////////////////////////
0:           Closeables.close(in, true);
/////////////////////////////////////////////////////////////////////////
0:         Closeables.close(modelOutput, true);
commit:1ead5ae
/////////////////////////////////////////////////////////////////////////
0:             lineCount++;
commit:d2dd884
/////////////////////////////////////////////////////////////////////////
1:   public static void main(String[] args) throws Exception {
1:   static void mainToOutput(String[] args, PrintWriter output) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:           int lineCount = 0;
0:             int targetValue = 0;
1:             try {
0:               targetValue = csv.processLine(line, input);
0:             } catch (Exception e) {
0:               System.out.println("Exception at line " + lineCount);
0:               throw e;
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:bdb1c48
/////////////////////////////////////////////////////////////////////////
1:               output.printf(Locale.ENGLISH, "%10d %2d %10.2f %2.4f %10.4f %10.4f%n",
/////////////////////////////////////////////////////////////////////////
1:       output.printf("%n");
1:             output.printf(Locale.ENGLISH, "%20s %.5f%n", key, weight);
commit:d608a88
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.io.Closeables;
/////////////////////////////////////////////////////////////////////////
0:         try {
1:           // read variable names
1:           csv.firstLine(in.readLine());
1:           String line = in.readLine();
1:           while (line != null) {
1:             // for each new line, get target and predictors
1:             Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());
1:             int targetValue = csv.processLine(line, input);
1:             // check performance while this is still news
1:             double logP = lr.logLikelihood(targetValue, input);
1:             if (!Double.isInfinite(logP)) {
1:               if (samples < 20) {
1:                 logPEstimate = (samples * logPEstimate + logP) / (samples + 1);
1:               } else {
1:                 logPEstimate = 0.95 * logPEstimate + 0.05 * logP;
1:               }
1:               samples++;
1:             double p = lr.classifyScalar(input);
1:             if (scores) {
0:               output.printf(Locale.ENGLISH, "%10d %2d %10.2f %2.4f %10.4f %10.4f\n",
1:                 samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);
1:             }
1:             // now update model
1:             lr.train(targetValue, input);
1:             line = in.readLine();
1:           }
0:         } finally {
0:           Closeables.closeQuietly(in);
0:         Closeables.closeQuietly(modelOutput);
commit:977cc39
/////////////////////////////////////////////////////////////////////////
0: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
0:             output.printf(Locale.ENGLISH, "%10d %2d %10.2f %2.4f %10.4f %10.4f\n",
/////////////////////////////////////////////////////////////////////////
0:       output.printf(Locale.ENGLISH, "%d\n", lmp.getNumFeatures());
0:       output.printf(Locale.ENGLISH, "%s ~ ", lmp.getTargetVariable());
1:           output.printf(Locale.ENGLISH, "%s%.3f*%s", sep, weight, v);
/////////////////////////////////////////////////////////////////////////
0:             output.printf(Locale.ENGLISH, "%20s %.5f\n", key, weight);
1:           output.printf(Locale.ENGLISH, "%15.9f ", lr.getBeta().get(row, column));
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
0: import java.io.OutputStreamWriter;
/////////////////////////////////////////////////////////////////////////
1:     mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:       output.println(lmp.getNumFeatures());
1:       output.println(lmp.getTargetVariable() + " ~ ");
commit:4fbfbc6
/////////////////////////////////////////////////////////////////////////
0:             int targetValue = csv.processLine(line, input);
commit:23722bc
/////////////////////////////////////////////////////////////////////////
0:     mainToOutput(args, new PrintWriter(System.out, true));
commit:a515335
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
0:     mainToOutput(args, new PrintWriter(System.out));
1:   }
1: 
0:   static void mainToOutput(String[] args, PrintWriter output) throws IOException {
commit:ff31f37
/////////////////////////////////////////////////////////////////////////
1:       for (String v : csv.getTraceDictionary().keySet()) {
commit:80366ee
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Charsets;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return new BufferedReader(new InputStreamReader(in, Charsets.UTF_8));
commit:35032b8
/////////////////////////////////////////////////////////////////////////
0: import java.io.OutputStream;
/////////////////////////////////////////////////////////////////////////
0:       OutputStream modelOutput = new FileOutputStream(outputFile);
commit:d61a0ee
/////////////////////////////////////////////////////////////////////////
1:       in = Resources.getResource(inputFile).openStream();
commit:ad8b61d
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.InputStream;
0: import java.io.Writer;
0: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
0:       Writer modelOutput = new OutputStreamWriter(new FileOutputStream(outputFile), Charset.forName("UTF-8"));
/////////////////////////////////////////////////////////////////////////
1:     InputStream in;
0:       in= Resources.getResource(inputFile).openStream();
1:       in = new FileInputStream(new File(inputFile));
0:     return new BufferedReader(new InputStreamReader(in, Charset.forName("UTF-8")));
commit:61ae2e7
/////////////////////////////////////////////////////////////////////////
0:         BufferedReader in = open(inputFile);
/////////////////////////////////////////////////////////////////////////
0:             System.out.printf("%10d %2d %10.2f %2.4f %10.4f %10.4f\n",
0:                 samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);
/////////////////////////////////////////////////////////////////////////
1:   static BufferedReader open(String inputFile) throws IOException {
0:     InputStreamReader s;
0:     try {
0:       URL resource = Resources.getResource(inputFile);
0:       s = new InputStreamReader(resource.openStream());
1:     } catch (IllegalArgumentException e) {
0:       s = new FileReader(inputFile);
0:     return new BufferedReader(s);
commit:8a99d75
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.FileReader;
0: import java.io.FileWriter;
0: import java.io.IOException;
0: import java.io.InputStreamReader;
0: import java.io.OutputStreamWriter;
/////////////////////////////////////////////////////////////////////////
1: public final class TrainLogistic {
1: 
1:   private static boolean scores;
1:   private TrainLogistic() {
1:   }
/////////////////////////////////////////////////////////////////////////
0:       OutputStreamWriter modelOutput = new FileWriter(outputFile);
0:       try {
1:         lmp.saveTo(modelOutput);
0:       } finally {
0:         modelOutput.close();
1:       }
/////////////////////////////////////////////////////////////////////////
0:     private InputOpener() {
1:     }
1: 
commit:c1a4188
/////////////////////////////////////////////////////////////////////////
1:     CommandLine cmdLine = parser.parseAndHelp(args);
author:Ted Dunning
-------------------------------------------------------------------------------
commit:ebaa95d
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
0:   static PrintStream output = System.out;
/////////////////////////////////////////////////////////////////////////
0:             output.printf("%10d %2d %10.2f %2.4f %10.4f %10.4f\n",
0:               samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);
/////////////////////////////////////////////////////////////////////////
0:       output.printf("%d\n", lmp.getNumFeatures());
0:       output.printf("%s ~ ", lmp.getTargetVariable());
0:           output.printf("%s%.3f*%s", sep, weight, v);
0:       output.printf("\n");
0:             output.printf("%20s %.5f\n", key, weight);
0:           output.printf("%15.9f ", lr.getBeta().get(row, column));
1:         output.println();
commit:d4b7924
/////////////////////////////////////////////////////////////////////////
1:   private static OnlineLogisticRegression model;
/////////////////////////////////////////////////////////////////////////
1:       model = lr;
/////////////////////////////////////////////////////////////////////////
1:   public static OnlineLogisticRegression getModel() {
1:     return model;
1:   }
1: 
1:   public static LogisticModelParameters getParameters() {
1:     return lmp;
1:   }
1: 
commit:7aa6232
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.classifier.sgd;
1: 
0: import com.google.common.collect.Lists;
0: import com.google.common.io.Resources;
0: import org.apache.commons.cli2.CommandLine;
0: import org.apache.commons.cli2.Group;
0: import org.apache.commons.cli2.Option;
0: import org.apache.commons.cli2.builder.ArgumentBuilder;
0: import org.apache.commons.cli2.builder.DefaultOptionBuilder;
0: import org.apache.commons.cli2.builder.GroupBuilder;
0: import org.apache.commons.cli2.commandline.Parser;
0: import org.apache.commons.cli2.util.HelpFormatter;
0: import org.apache.mahout.math.RandomAccessSparseVector;
0: import org.apache.mahout.math.Vector;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
0: import java.io.*;
0: import java.net.URL;
0: import java.util.List;
1: 
1: 
1: /**
1:  * Train a logistic regression for the examples from Chapter 13 of Mahout in Action
1:  */
0: public class TrainLogistic {
0:   private static final Logger log = LoggerFactory.getLogger(TrainLogistic.class);
1:   private static String inputFile;
1:   private static String outputFile;
1:   private static LogisticModelParameters lmp;
1: 
1:   private static int passes;
0:   private static boolean scores = false;
1: 
1: 
0:   public static void main(String[] args) throws IOException {
1:     if (parseArgs(args)) {
1:       double logPEstimate = 0;
1:       int samples = 0;
1: 
1:       CsvRecordFactory csv = lmp.getCsvRecordFactory();
1:       OnlineLogisticRegression lr = lmp.createRegression();
1:       for (int pass = 0; pass < passes; pass++) {
0:         BufferedReader in = InputOpener.open(inputFile);
1: 
0:         // read variable names
0:         csv.firstLine(in.readLine());
1: 
0:         String line = in.readLine();
0:         while (line != null) {
0:           // for each new line, get target and predictors
0:           Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());
0:           int targetValue = csv.processLine(line, input);
1: 
0:           // check performance while this is still news
0:           double logP = lr.logLikelihood(targetValue, input);
0:           if (!Double.isInfinite(logP)) {
0:             if (samples < 20) {
0:               logPEstimate = (samples * logPEstimate + logP) / (samples + 1);
0:             } else {
0:               logPEstimate = 0.95 * logPEstimate + 0.05 * logP;
1:             }
0:             samples++;
1:           }
0:           double p = lr.classifyScalar(input);
0:           if (scores) {
0:             System.out.printf("%10d %2d %10.2f %2.4f %10.4f %10.4f\n", samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);
1:           }
1: 
0:           // now update model
0:           lr.train(targetValue, input);
1: 
0:           line = in.readLine();
1:         }
0:         in.close();
1:       }
1: 
0:       FileWriter modelOutput = new FileWriter(outputFile);
0:       lmp.saveTo(modelOutput);
0:       modelOutput.close();
1:       
0:       System.out.printf("%d\n", lmp.getNumFeatures());
0:       System.out.printf("%s ~ ", lmp.getTargetVariable());
1:       String sep = "";
0:       for (String v : csv.getPredictors()) {
1:         double weight = predictorWeight(lr, 0, csv, v);
1:         if (weight != 0) {
0:           System.out.printf("%s%.3f*%s", sep, weight, v);
1:           sep = " + ";
1:         }
1:       }
0:       System.out.printf("\n");
1:       for (int row = 0; row < lr.getBeta().numRows(); row++) {
1:         for (String key : csv.getTraceDictionary().keySet()) {
1:           double weight = predictorWeight(lr, row, csv, key);
1:           if (weight != 0) {
0:             System.out.printf("%20s %.5f\n", key, weight);
1:           }
1:         }
1:         for (int column = 0; column < lr.getBeta().numCols(); column++) {
0:           System.out.printf("%15.9f ", lr.getBeta().get(row, column));
1:         }
0:         System.out.println();
1:       }
1:     }
1:   }
1: 
1:   private static double predictorWeight(OnlineLogisticRegression lr, int row, RecordFactory csv, String predictor) {
1:     double weight = 0;
1:     for (Integer column : csv.getTraceDictionary().get(predictor)) {
1:       weight += lr.getBeta().get(row, column);
1:     }
1:     return weight;
1:   }
1: 
1:   private static boolean parseArgs(String[] args) {
1:     DefaultOptionBuilder builder = new DefaultOptionBuilder();
1: 
1:     Option help = builder.withLongName("help").withDescription("print this list").create();
1: 
1:     Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();
1:     Option scores = builder.withLongName("scores").withDescription("output score diagnostics during training").create();
1: 
1:     ArgumentBuilder argumentBuilder = new ArgumentBuilder();
1:     Option inputFile = builder.withLongName("input")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("input").withMaximum(1).create())
1:             .withDescription("where to get training data")
1:             .create();
1: 
1:     Option outputFile = builder.withLongName("output")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("output").withMaximum(1).create())
1:             .withDescription("where to get training data")
1:             .create();
1: 
1:     Option predictors = builder.withLongName("predictors")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("p").create())
1:             .withDescription("a list of predictor variables")
1:             .create();
1: 
1:     Option types = builder.withLongName("types")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("t").create())
1:             .withDescription("a list of predictor variable types (numeric, word, or text)")
1:             .create();
1: 
1:     Option target = builder.withLongName("target")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("target").withMaximum(1).create())
1:             .withDescription("the name of the target variable")
1:             .create();
1: 
1:     Option features = builder.withLongName("features")
1:             .withArgument(
1:                     argumentBuilder.withName("numFeatures")
1:                             .withDefault("1000")
1:                             .withMaximum(1).create())
1:             .withDescription("the number of internal hashed features to use")
1:             .create();
1: 
1:     Option passes = builder.withLongName("passes")
1:             .withArgument(
1:                     argumentBuilder.withName("passes")
1:                             .withDefault("2")
1:                             .withMaximum(1).create())
1:             .withDescription("the number of times to pass over the input data")
1:             .create();
1: 
1:     Option lambda = builder.withLongName("lambda")
1:             .withArgument(argumentBuilder.withName("lambda").withDefault("1e-4").withMaximum(1).create())
1:             .withDescription("the amount of coefficient decay to use")
1:             .create();
1: 
1:     Option rate = builder.withLongName("rate")
1:             .withArgument(argumentBuilder.withName("learningRate").withDefault("1e-3").withMaximum(1).create())
1:             .withDescription("the learning rate")
1:             .create();
1: 
1:     Option noBias = builder.withLongName("noBias")
1:             .withDescription("don't include a bias term")
1:             .create();
1: 
1:     Option targetCategories = builder.withLongName("categories")
1:             .withRequired(true)
1:             .withArgument(argumentBuilder.withName("number").withMaximum(1).create())
1:             .withDescription("the number of target categories to be considered")
1:             .create();
1: 
1:     Group normalArgs = new GroupBuilder()
1:             .withOption(help)
1:             .withOption(quiet)
1:             .withOption(inputFile)
1:             .withOption(outputFile)
1:             .withOption(target)
1:             .withOption(targetCategories)
1:             .withOption(predictors)
1:             .withOption(types)
1:             .withOption(passes)
1:             .withOption(lambda)
1:             .withOption(rate)
1:             .withOption(noBias)
1:             .withOption(features)
1:             .create();
1: 
1:     Parser parser = new Parser();
1:     parser.setHelpOption(help);
1:     parser.setHelpTrigger("--help");
1:     parser.setGroup(normalArgs);
1:     parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));
0:     CommandLine cmdLine;
0:     cmdLine = parser.parseAndHelp(args);
1: 
1:     if (cmdLine == null) {
1:       return false;
1:     }
1: 
1:     TrainLogistic.inputFile = getStringArgument(cmdLine, inputFile);
1:     TrainLogistic.outputFile = getStringArgument(cmdLine, outputFile);
1: 
0:     List<String> typeList = Lists.newArrayList();
1:     for (Object x : cmdLine.getValues(types)) {
1:       typeList.add(x.toString());
1:     }
1: 
0:     List<String> predictorList = Lists.newArrayList();
1:     for (Object x : cmdLine.getValues(predictors)) {
1:       predictorList.add(x.toString());
1:     }
1: 
1:     lmp = new LogisticModelParameters();
1:     lmp.setTargetVariable(getStringArgument(cmdLine, target));
1:     lmp.setMaxTargetCategories(getIntegerArgument(cmdLine, targetCategories));
1:     lmp.setNumFeatures(getIntegerArgument(cmdLine, features));
1:     lmp.setUseBias(!getBooleanArgument(cmdLine, noBias));
1:     lmp.setTypeMap(predictorList, typeList);
1: 
1:     lmp.setLambda(getDoubleArgument(cmdLine, lambda));
1:     lmp.setLearningRate(getDoubleArgument(cmdLine, rate));
1: 
1:     TrainLogistic.scores = getBooleanArgument(cmdLine, scores);
1:     TrainLogistic.passes = getIntegerArgument(cmdLine, passes);
1: 
1:     return true;
1:   }
1: 
1:   private static String getStringArgument(CommandLine cmdLine, Option inputFile) {
1:     return (String) cmdLine.getValue(inputFile);
1:   }
1: 
1:   private static boolean getBooleanArgument(CommandLine cmdLine, Option option) {
1:     return cmdLine.hasOption(option);
1:   }
1: 
1:   private static int getIntegerArgument(CommandLine cmdLine, Option features) {
1:     return Integer.parseInt((String) cmdLine.getValue(features));
1:   }
1: 
1:   private static double getDoubleArgument(CommandLine cmdLine, Option op) {
1:     return Double.parseDouble((String) cmdLine.getValue(op));
1:   }
1: 
0:   public static class InputOpener {
0:     public static BufferedReader open(String inputFile) throws IOException {
0:       InputStreamReader s;
0:       try {
0:         URL resource = Resources.getResource(inputFile);
0:         s = new InputStreamReader(resource.openStream());
0:       } catch (IllegalArgumentException e) {
0:         s = new FileReader(inputFile);
1:       }
1: 
0:       return new BufferedReader(s);
1:     }
1:   }
1: }
commit:f4c8f73
commit:91456bb
============================================================================