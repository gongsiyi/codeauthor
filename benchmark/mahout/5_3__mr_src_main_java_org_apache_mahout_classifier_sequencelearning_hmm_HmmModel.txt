12:27d33a2: /**
1:27d33a2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:27d33a2:  * contributor license agreements.  See the NOTICE file distributed with
1:27d33a2:  * this work for additional information regarding copyright ownership.
1:27d33a2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:27d33a2:  * (the "License"); you may not use this file except in compliance with
1:27d33a2:  * the License.  You may obtain a copy of the License at
4:27d33a2:  *
1:27d33a2:  *     http://www.apache.org/licenses/LICENSE-2.0
1:27d33a2:  *
1:27d33a2:  * Unless required by applicable law or agreed to in writing, software
1:27d33a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27d33a2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27d33a2:  * See the License for the specific language governing permissions and
1:27d33a2:  * limitations under the License.
12:27d33a2:  */
15:27d33a2: 
1:27d33a2: package org.apache.mahout.classifier.sequencelearning.hmm;
1:27d33a2: 
1:27d33a2: import java.util.Map;
1:27d33a2: import java.util.Random;
1:27d33a2: 
1:0793ce4: import com.google.common.collect.BiMap;
1:0793ce4: import com.google.common.collect.HashBiMap;
1:27d33a2: import org.apache.mahout.common.RandomUtils;
1:27d33a2: import org.apache.mahout.math.DenseMatrix;
1:27d33a2: import org.apache.mahout.math.DenseVector;
1:27d33a2: import org.apache.mahout.math.Matrix;
1:27d33a2: import org.apache.mahout.math.Vector;
1:27d33a2: 
1:27d33a2: /**
1:27d33a2:  * Main class defining a Hidden Markov Model
1:27d33a2:  */
1:35032b8: public class HmmModel implements Cloneable {
1:27d33a2: 
1:0793ce4:   /** Bi-directional Map for storing the observed state names */
1:0793ce4:   private BiMap<String,Integer> outputStateNames;
1:0793ce4: 
1:0793ce4:   /** Bi-Directional Map for storing the hidden state names */
1:0793ce4:   private BiMap<String,Integer> hiddenStateNames;
1:0793ce4: 
1:0793ce4:   /* Number of hidden states */
1:0793ce4:   private int nrOfHiddenStates;
1:0793ce4: 
1:0793ce4:   /** Number of output states */
1:0793ce4:   private int nrOfOutputStates;
1:0793ce4: 
1:0793ce4:   /**
1:0793ce4:    * Transition matrix containing the transition probabilities between hidden
1:0793ce4:    * states. TransitionMatrix(i,j) is the probability that we change from hidden
1:0793ce4:    * state i to hidden state j In general: P(h(t+1)=h_j | h(t) = h_i) =
1:0793ce4:    * transitionMatrix(i,j) Since we have to make sure that each hidden state can
1:0793ce4:    * be "left", the following normalization condition has to hold:
1:0793ce4:    * sum(transitionMatrix(i,j),j=1..hiddenStates) = 1
1:0793ce4:    */
1:0793ce4:   private Matrix transitionMatrix;
1:0793ce4: 
1:0793ce4:   /**
1:0793ce4:    * Output matrix containing the probabilities that we observe a given output
1:0793ce4:    * state given a hidden state. outputMatrix(i,j) is the probability that we
1:0793ce4:    * observe output state j if we are in hidden state i Formally: P(o(t)=o_j |
1:0793ce4:    * h(t)=h_i) = outputMatrix(i,j) Since we always have an observation for each
1:0793ce4:    * hidden state, the following normalization condition has to hold:
1:0793ce4:    * sum(outputMatrix(i,j),j=1..outputStates) = 1
1:0793ce4:    */
1:0793ce4:   private Matrix emissionMatrix;
1:0793ce4: 
1:0793ce4:   /**
1:0793ce4:    * Vector containing the initial hidden state probabilities. That is
1:0793ce4:    * P(h(0)=h_i) = initialProbabilities(i). Since we are dealing with
1:0793ce4:    * probabilities the following normalization condition has to hold:
1:0793ce4:    * sum(initialProbabilities(i),i=1..hiddenStates) = 1
1:0793ce4:    */
1:0793ce4:   private Vector initialProbabilities;
1:0793ce4: 
1:0793ce4: 
1:27d33a2:   /**
1:27d33a2:    * Get a copy of this model
1:27d33a2:    */
1:d53cf4a:   @Override
1:d0dbdfb:   public HmmModel clone() {
1:d53cf4a:     HmmModel model = new HmmModel(transitionMatrix.clone(), emissionMatrix.clone(), initialProbabilities.clone());
1:d53cf4a:     if (hiddenStateNames != null) {
1:0793ce4:       model.hiddenStateNames = HashBiMap.create(hiddenStateNames);
1:d53cf4a:     }
1:d53cf4a:     if (outputStateNames != null) {
1:0793ce4:       model.outputStateNames = HashBiMap.create(outputStateNames);
1:d53cf4a:     }
2:27d33a2:     return model;
10:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Assign the content of another HMM model to this one
1:27d33a2:    *
1:27d33a2:    * @param model The HmmModel that will be assigned to this one
1:27d33a2:    */
1:27d33a2:   public void assign(HmmModel model) {
1:27d33a2:     this.nrOfHiddenStates = model.nrOfHiddenStates;
1:27d33a2:     this.nrOfOutputStates = model.nrOfOutputStates;
1:27d33a2:     this.hiddenStateNames = model.hiddenStateNames;
1:27d33a2:     this.outputStateNames = model.outputStateNames;
1:27d33a2:     // for now clone the matrix/vectors
1:27d33a2:     this.initialProbabilities = model.initialProbabilities.clone();
1:27d33a2:     this.emissionMatrix = model.emissionMatrix.clone();
1:27d33a2:     this.transitionMatrix = model.transitionMatrix.clone();
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Construct a valid random Hidden-Markov parameter set with the given number
1:27d33a2:    * of hidden and output states using a given seed.
1:27d33a2:    *
1:27d33a2:    * @param nrOfHiddenStates Number of hidden states
1:27d33a2:    * @param nrOfOutputStates Number of output states
1:27d33a2:    * @param seed             Seed for the random initialization, if set to 0 the current time
1:27d33a2:    *                         is used
1:27d33a2:    */
1:27d33a2:   public HmmModel(int nrOfHiddenStates, int nrOfOutputStates, long seed) {
1:27d33a2:     this.nrOfHiddenStates = nrOfHiddenStates;
1:27d33a2:     this.nrOfOutputStates = nrOfOutputStates;
1:27d33a2:     this.transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);
1:27d33a2:     this.emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);
1:27d33a2:     this.initialProbabilities = new DenseVector(nrOfHiddenStates);
1:27d33a2:     // initialize a random, valid parameter set
1:27d33a2:     initRandomParameters(seed);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Construct a valid random Hidden-Markov parameter set with the given number
1:27d33a2:    * of hidden and output states.
1:27d33a2:    *
1:27d33a2:    * @param nrOfHiddenStates Number of hidden states
1:27d33a2:    * @param nrOfOutputStates Number of output states
1:27d33a2:    */
1:27d33a2:   public HmmModel(int nrOfHiddenStates, int nrOfOutputStates) {
1:27d33a2:     this(nrOfHiddenStates, nrOfOutputStates, 0);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Generates a Hidden Markov model using the specified parameters
1:27d33a2:    *
1:27d33a2:    * @param transitionMatrix     transition probabilities.
1:27d33a2:    * @param emissionMatrix       emission probabilities.
1:27d33a2:    * @param initialProbabilities initial start probabilities.
1:27d33a2:    * @throws IllegalArgumentException If the given parameter set is invalid
1:27d33a2:    */
1:74f849b:   public HmmModel(Matrix transitionMatrix, Matrix emissionMatrix, Vector initialProbabilities) {
1:27d33a2:     this.nrOfHiddenStates = initialProbabilities.size();
1:27d33a2:     this.nrOfOutputStates = emissionMatrix.numCols();
1:27d33a2:     this.transitionMatrix = transitionMatrix;
1:27d33a2:     this.emissionMatrix = emissionMatrix;
1:27d33a2:     this.initialProbabilities = initialProbabilities;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Initialize a valid random set of HMM parameters
1:27d33a2:    *
1:27d33a2:    * @param seed seed to use for Random initialization. Use 0 to use Java-built-in-version.
1:27d33a2:    */
1:27d33a2:   private void initRandomParameters(long seed) {
1:27d33a2:     Random rand;
1:27d33a2:     // initialize the random number generator
1:d53cf4a:     if (seed == 0) {
1:27d33a2:       rand = RandomUtils.getRandom();
1:d53cf4a:     } else {
1:27d33a2:       rand = RandomUtils.getRandom(seed);
1:d53cf4a:     }
1:27d33a2:     // initialize the initial Probabilities
1:27d33a2:     double sum = 0; // used for normalization
1:27d33a2:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:27d33a2:       double nextRand = rand.nextDouble();
1:27d33a2:       initialProbabilities.set(i, nextRand);
1:27d33a2:       sum += nextRand;
1:27d33a2:     }
1:27d33a2:     // "normalize" the vector to generate probabilities
1:27d33a2:     initialProbabilities = initialProbabilities.divide(sum);
1:27d33a2: 
1:27d33a2:     // initialize the transition matrix
1:27d33a2:     double[] values = new double[nrOfHiddenStates];
1:27d33a2:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:27d33a2:       sum = 0;
1:27d33a2:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         values[j] = rand.nextDouble();
1:27d33a2:         sum += values[j];
1:27d33a2:       }
1:27d33a2:       // normalize the random values to obtain probabilities
1:d53cf4a:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:27d33a2:         values[j] /= sum;
1:d53cf4a:       }
1:27d33a2:       // set this row of the transition matrix
1:27d33a2:       transitionMatrix.set(i, values);
1:27d33a2:     }
1:27d33a2: 
1:27d33a2:     // initialize the output matrix
1:27d33a2:     values = new double[nrOfOutputStates];
1:27d33a2:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:27d33a2:       sum = 0;
1:d53cf4a:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         values[j] = rand.nextDouble();
1:27d33a2:         sum += values[j];
1:d53cf4a:       }
1:27d33a2:       // normalize the random values to obtain probabilities
1:27d33a2:       for (int j = 0; j < nrOfOutputStates; j++) {
1:27d33a2:         values[j] /= sum;
1:27d33a2:       }
1:27d33a2:       // set this row of the output matrix
1:27d33a2:       emissionMatrix.set(i, values);
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter Method for the number of hidden states
1:27d33a2:    *
1:27d33a2:    * @return Number of hidden states
1:27d33a2:    */
1:27d33a2:   public int getNrOfHiddenStates() {
1:27d33a2:     return nrOfHiddenStates;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter Method for the number of output states
1:27d33a2:    *
1:27d33a2:    * @return Number of output states
1:27d33a2:    */
1:27d33a2:   public int getNrOfOutputStates() {
1:27d33a2:     return nrOfOutputStates;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter function to get the hidden state transition matrix
1:27d33a2:    *
1:27d33a2:    * @return returns the model's transition matrix.
1:27d33a2:    */
1:27d33a2:   public Matrix getTransitionMatrix() {
1:27d33a2:     return transitionMatrix;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter function to get the output state probability matrix
1:27d33a2:    *
1:27d33a2:    * @return returns the models emission matrix.
1:27d33a2:    */
1:27d33a2:   public Matrix getEmissionMatrix() {
1:27d33a2:     return emissionMatrix;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter function to return the vector of initial hidden state probabilities
1:27d33a2:    *
1:27d33a2:    * @return returns the model's init probabilities.
1:27d33a2:    */
1:27d33a2:   public Vector getInitialProbabilities() {
1:27d33a2:     return initialProbabilities;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter method for the hidden state Names map
1:27d33a2:    *
1:27d33a2:    * @return hidden state names.
1:27d33a2:    */
1:27d33a2:   public Map<String, Integer> getHiddenStateNames() {
1:0793ce4:     return hiddenStateNames;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Register an array of hidden state Names. We assume that the state name at
1:27d33a2:    * position i has the ID i
1:27d33a2:    *
1:27d33a2:    * @param stateNames names of hidden states.
1:27d33a2:    */
1:27d33a2:   public void registerHiddenStateNames(String[] stateNames) {
1:27d33a2:     if (stateNames != null) {
1:0793ce4:       hiddenStateNames = HashBiMap.create();
1:27d33a2:       for (int i = 0; i < stateNames.length; ++i) {
1:27d33a2:         hiddenStateNames.put(stateNames[i], i);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Register a map of hidden state Names/state IDs
1:27d33a2:    *
1:27d33a2:    * @param stateNames <String,Integer> Map that assigns each state name an integer ID
1:27d33a2:    */
1:27d33a2:   public void registerHiddenStateNames(Map<String, Integer> stateNames) {
1:d53cf4a:     if (stateNames != null) {
1:0793ce4:       hiddenStateNames = HashBiMap.create(stateNames);
1:d53cf4a:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Lookup the name for the given hidden state ID
1:27d33a2:    *
1:27d33a2:    * @param id Integer id of the hidden state
1:27d33a2:    * @return String containing the name for the given ID, null if this ID is not
1:27d33a2:    *         known or no hidden state names were specified
1:27d33a2:    */
1:27d33a2:   public String getHiddenStateName(int id) {
1:d53cf4a:     if (hiddenStateNames == null) {
1:27d33a2:       return null;
1:d53cf4a:     }
1:0793ce4:     return hiddenStateNames.inverse().get(id);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Lookup the ID for the given hidden state name
1:27d33a2:    *
1:27d33a2:    * @param name Name of the hidden state
1:27d33a2:    * @return int containing the ID for the given name, -1 if this name is not
1:27d33a2:    *         known or no hidden state names were specified
1:27d33a2:    */
1:27d33a2:   public int getHiddenStateID(String name) {
1:d53cf4a:     if (hiddenStateNames == null) {
1:27d33a2:       return -1;
1:d53cf4a:     }
1:0793ce4:     Integer tmp = hiddenStateNames.get(name);
1:39fe224:     return tmp == null ? -1 : tmp;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Getter method for the output state Names map
1:27d33a2:    *
1:27d33a2:    * @return names of output states.
1:27d33a2:    */
1:27d33a2:   public Map<String, Integer> getOutputStateNames() {
1:0793ce4:     return outputStateNames;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Register an array of hidden state Names. We assume that the state name at
1:27d33a2:    * position i has the ID i
1:27d33a2:    *
1:27d33a2:    * @param stateNames state names to register.
1:27d33a2:    */
1:27d33a2:   public void registerOutputStateNames(String[] stateNames) {
1:27d33a2:     if (stateNames != null) {
1:0793ce4:       outputStateNames = HashBiMap.create();
1:27d33a2:       for (int i = 0; i < stateNames.length; ++i) {
1:27d33a2:         outputStateNames.put(stateNames[i], i);
1:27d33a2:       }
1:27d33a2:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Register a map of hidden state Names/state IDs
1:27d33a2:    *
1:27d33a2:    * @param stateNames <String,Integer> Map that assigns each state name an integer ID
1:27d33a2:    */
1:27d33a2:   public void registerOutputStateNames(Map<String, Integer> stateNames) {
1:d53cf4a:     if (stateNames != null) {
1:0793ce4:       outputStateNames = HashBiMap.create(stateNames);
1:d53cf4a:     }
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Lookup the name for the given output state id
1:27d33a2:    *
1:27d33a2:    * @param id Integer id of the output state
1:27d33a2:    * @return String containing the name for the given id, null if this id is not
1:27d33a2:    *         known or no output state names were specified
1:27d33a2:    */
1:27d33a2:   public String getOutputStateName(int id) {
1:d53cf4a:     if (outputStateNames == null) {
1:27d33a2:       return null;
1:d53cf4a:     }
1:0793ce4:     return outputStateNames.inverse().get(id);
1:27d33a2:   }
1:27d33a2: 
1:27d33a2:   /**
1:27d33a2:    * Lookup the ID for the given output state name
1:27d33a2:    *
1:27d33a2:    * @param name Name of the output state
1:27d33a2:    * @return int containing the ID for the given name, -1 if this name is not
1:27d33a2:    *         known or no output state names were specified
1:27d33a2:    */
1:27d33a2:   public int getOutputStateID(String name) {
1:d53cf4a:     if (outputStateNames == null) {
1:27d33a2:       return -1;
1:d53cf4a:     }
1:0793ce4:     Integer tmp = outputStateNames.get(name);
1:39fe224:     return tmp == null ? -1 : tmp;
1:27d33a2:   }
1:27d33a2: 
1:27d33a2: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:d0dbdfb
/////////////////////////////////////////////////////////////////////////
1:   public HmmModel clone() {
commit:0793ce4
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.BiMap;
1: import com.google.common.collect.HashBiMap;
/////////////////////////////////////////////////////////////////////////
1:   /** Bi-directional Map for storing the observed state names */
1:   private BiMap<String,Integer> outputStateNames;
1: 
1:   /** Bi-Directional Map for storing the hidden state names */
1:   private BiMap<String,Integer> hiddenStateNames;
1: 
1:   /* Number of hidden states */
1:   private int nrOfHiddenStates;
1: 
1:   /** Number of output states */
1:   private int nrOfOutputStates;
1: 
1:   /**
1:    * Transition matrix containing the transition probabilities between hidden
1:    * states. TransitionMatrix(i,j) is the probability that we change from hidden
1:    * state i to hidden state j In general: P(h(t+1)=h_j | h(t) = h_i) =
1:    * transitionMatrix(i,j) Since we have to make sure that each hidden state can
1:    * be "left", the following normalization condition has to hold:
1:    * sum(transitionMatrix(i,j),j=1..hiddenStates) = 1
1:    */
1:   private Matrix transitionMatrix;
1: 
1:   /**
1:    * Output matrix containing the probabilities that we observe a given output
1:    * state given a hidden state. outputMatrix(i,j) is the probability that we
1:    * observe output state j if we are in hidden state i Formally: P(o(t)=o_j |
1:    * h(t)=h_i) = outputMatrix(i,j) Since we always have an observation for each
1:    * hidden state, the following normalization condition has to hold:
1:    * sum(outputMatrix(i,j),j=1..outputStates) = 1
1:    */
1:   private Matrix emissionMatrix;
1: 
1:   /**
1:    * Vector containing the initial hidden state probabilities. That is
1:    * P(h(0)=h_i) = initialProbabilities(i). Since we are dealing with
1:    * probabilities the following normalization condition has to hold:
1:    * sum(initialProbabilities(i),i=1..hiddenStates) = 1
1:    */
1:   private Vector initialProbabilities;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:       model.hiddenStateNames = HashBiMap.create(hiddenStateNames);
1:       model.outputStateNames = HashBiMap.create(outputStateNames);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     return hiddenStateNames;
/////////////////////////////////////////////////////////////////////////
1:       hiddenStateNames = HashBiMap.create();
/////////////////////////////////////////////////////////////////////////
1:       hiddenStateNames = HashBiMap.create(stateNames);
/////////////////////////////////////////////////////////////////////////
1:     return hiddenStateNames.inverse().get(id);
/////////////////////////////////////////////////////////////////////////
1:     Integer tmp = hiddenStateNames.get(name);
1:     return outputStateNames;
/////////////////////////////////////////////////////////////////////////
1:       outputStateNames = HashBiMap.create();
/////////////////////////////////////////////////////////////////////////
1:       outputStateNames = HashBiMap.create(stateNames);
/////////////////////////////////////////////////////////////////////////
1:     return outputStateNames.inverse().get(id);
/////////////////////////////////////////////////////////////////////////
1:     Integer tmp = outputStateNames.get(name);
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:     return tmp == null ? -1 : tmp;
/////////////////////////////////////////////////////////////////////////
1:     return tmp == null ? -1 : tmp;
commit:35032b8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class HmmModel implements Cloneable {
/////////////////////////////////////////////////////////////////////////
commit:d53cf4a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   @Override
1:     HmmModel model = new HmmModel(transitionMatrix.clone(), emissionMatrix.clone(), initialProbabilities.clone());
1:     if (hiddenStateNames != null) {
1:     }
1:     if (outputStateNames != null) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (seed == 0) {
1:     } else {
1:     }
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:       }
/////////////////////////////////////////////////////////////////////////
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:       }
/////////////////////////////////////////////////////////////////////////
0:     return (Map<String, Integer>) hiddenStateNames;
/////////////////////////////////////////////////////////////////////////
1:     if (stateNames != null) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (hiddenStateNames == null) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (hiddenStateNames == null) {
1:     }
/////////////////////////////////////////////////////////////////////////
0:     return (Map<String, Integer>) outputStateNames;
/////////////////////////////////////////////////////////////////////////
1:     if (stateNames != null) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (outputStateNames == null) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     if (outputStateNames == null) {
1:     }
/////////////////////////////////////////////////////////////////////////
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1:   public HmmModel(Matrix transitionMatrix, Matrix emissionMatrix, Vector initialProbabilities) {
author:Isabel Drost
-------------------------------------------------------------------------------
commit:27d33a2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.classifier.sequencelearning.hmm;
1: 
0: import java.lang.reflect.Type;
1: import java.util.Map;
1: import java.util.Random;
1: 
0: import org.apache.commons.collections.BidiMap;
0: import org.apache.commons.collections.bidimap.TreeBidiMap;
1: import org.apache.mahout.common.RandomUtils;
1: import org.apache.mahout.math.DenseMatrix;
1: import org.apache.mahout.math.DenseVector;
0: import org.apache.mahout.math.JsonMatrixAdapter;
0: import org.apache.mahout.math.JsonVectorAdapter;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: 
0: import com.google.gson.Gson;
0: import com.google.gson.GsonBuilder;
0: import com.google.gson.JsonDeserializationContext;
0: import com.google.gson.JsonDeserializer;
0: import com.google.gson.JsonElement;
0: import com.google.gson.JsonObject;
0: import com.google.gson.JsonPrimitive;
0: import com.google.gson.JsonSerializationContext;
0: import com.google.gson.JsonSerializer;
0: import com.google.gson.reflect.TypeToken;
1: 
1: /**
1:  * Main class defining a Hidden Markov Model
1:  *
0:  * @author mheimel
1:  */
0: public class HmmModel implements JsonDeserializer<HmmModel>,
0:     JsonSerializer<HmmModel>, Cloneable {
1: 
1:   /**
0:    * No-args constructed needed for json de-serialization
1:    */
0:   private HmmModel() {
0:     // do nothing
1:   }
1: 
1:   /**
1:    * Get a copy of this model
1:    */
0:   public HmmModel clone() throws CloneNotSupportedException {
0:     super.clone();
0:     HmmModel model = new HmmModel(transitionMatrix.clone(), emissionMatrix
0:         .clone(), initialProbabilities.clone());
0:     if (hiddenStateNames != null)
0:       model.hiddenStateNames = new TreeBidiMap(hiddenStateNames);
0:     if (outputStateNames != null)
0:       model.outputStateNames = new TreeBidiMap(outputStateNames);
1:     return model;
1:   }
1: 
1:   /**
1:    * Assign the content of another HMM model to this one
1:    *
1:    * @param model The HmmModel that will be assigned to this one
1:    */
1:   public void assign(HmmModel model) {
1:     this.nrOfHiddenStates = model.nrOfHiddenStates;
1:     this.nrOfOutputStates = model.nrOfOutputStates;
1:     this.hiddenStateNames = model.hiddenStateNames;
1:     this.outputStateNames = model.outputStateNames;
1:     // for now clone the matrix/vectors
1:     this.initialProbabilities = model.initialProbabilities.clone();
1:     this.emissionMatrix = model.emissionMatrix.clone();
1:     this.transitionMatrix = model.transitionMatrix.clone();
1:   }
1: 
1:   /**
1:    * Construct a valid random Hidden-Markov parameter set with the given number
1:    * of hidden and output states using a given seed.
1:    *
1:    * @param nrOfHiddenStates Number of hidden states
1:    * @param nrOfOutputStates Number of output states
1:    * @param seed             Seed for the random initialization, if set to 0 the current time
1:    *                         is used
1:    */
1:   public HmmModel(int nrOfHiddenStates, int nrOfOutputStates, long seed) {
1:     this.nrOfHiddenStates = nrOfHiddenStates;
1:     this.nrOfOutputStates = nrOfOutputStates;
1:     this.transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);
1:     this.emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);
1:     this.initialProbabilities = new DenseVector(nrOfHiddenStates);
1:     // initialize a random, valid parameter set
1:     initRandomParameters(seed);
1:   }
1: 
1:   /**
1:    * Construct a valid random Hidden-Markov parameter set with the given number
1:    * of hidden and output states.
1:    *
1:    * @param nrOfHiddenStates Number of hidden states
1:    * @param nrOfOutputStates Number of output states
1:    */
1:   public HmmModel(int nrOfHiddenStates, int nrOfOutputStates) {
1:     this(nrOfHiddenStates, nrOfOutputStates, 0);
1:   }
1: 
1:   /**
1:    * Generates a Hidden Markov model using the specified parameters
1:    *
1:    * @param transitionMatrix     transition probabilities.
1:    * @param emissionMatrix       emission probabilities.
1:    * @param initialProbabilities initial start probabilities.
1:    * @throws IllegalArgumentException If the given parameter set is invalid
1:    */
0:   public HmmModel(Matrix transitionMatrix, Matrix emissionMatrix,
0:                   Vector initialProbabilities) {
1:     this.nrOfHiddenStates = initialProbabilities.size();
1:     this.nrOfOutputStates = emissionMatrix.numCols();
1:     this.transitionMatrix = transitionMatrix;
1:     this.emissionMatrix = emissionMatrix;
1:     this.initialProbabilities = initialProbabilities;
1:   }
1: 
1:   /**
1:    * Initialize a valid random set of HMM parameters
1:    *
1:    * @param seed seed to use for Random initialization. Use 0 to use Java-built-in-version.
1:    */
1:   private void initRandomParameters(long seed) {
1:     Random rand;
1:     // initialize the random number generator
0:     if (seed == 0)
1:       rand = RandomUtils.getRandom();
0:     else
1:       rand = RandomUtils.getRandom(seed);
1:     // initialize the initial Probabilities
1:     double sum = 0; // used for normalization
1:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:       double nextRand = rand.nextDouble();
1:       initialProbabilities.set(i, nextRand);
1:       sum += nextRand;
1:     }
1:     // "normalize" the vector to generate probabilities
1:     initialProbabilities = initialProbabilities.divide(sum);
1: 
1:     // initialize the transition matrix
1:     double[] values = new double[nrOfHiddenStates];
1:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:       sum = 0;
1:       for (int j = 0; j < nrOfHiddenStates; j++) {
1:         values[j] = rand.nextDouble();
1:         sum += values[j];
1:       }
1:       // normalize the random values to obtain probabilities
0:       for (int j = 0; j < nrOfHiddenStates; j++)
1:         values[j] /= sum;
1:       // set this row of the transition matrix
1:       transitionMatrix.set(i, values);
1:     }
1: 
1:     // initialize the output matrix
1:     values = new double[nrOfOutputStates];
1:     for (int i = 0; i < nrOfHiddenStates; i++) {
1:       sum = 0;
1:       for (int j = 0; j < nrOfOutputStates; j++) {
1:         values[j] = rand.nextDouble();
1:         sum += values[j];
1:       }
1:       // normalize the random values to obtain probabilities
0:       for (int j = 0; j < nrOfOutputStates; j++)
1:         values[j] /= sum;
1:       // set this row of the output matrix
1:       emissionMatrix.set(i, values);
1:     }
1:   }
1: 
1:   /**
0:    * Number of hidden states
1:    */
0:   private int nrOfHiddenStates;
1: 
1:   /**
1:    * Getter Method for the number of hidden states
1:    *
1:    * @return Number of hidden states
1:    */
1:   public int getNrOfHiddenStates() {
1:     return nrOfHiddenStates;
1:   }
1: 
1:   /**
0:    * Number of output states
1:    */
0:   private int nrOfOutputStates;
1: 
1:   /**
1:    * Getter Method for the number of output states
1:    *
1:    * @return Number of output states
1:    */
1:   public int getNrOfOutputStates() {
1:     return nrOfOutputStates;
1:   }
1: 
1:   /**
0:    * Transition matrix containing the transition probabilities between hidden
0:    * states. TransitionMatrix(i,j) is the probability that we change from hidden
0:    * state i to hidden state j In general: P(h(t+1)=h_j | h(t) = h_i) =
0:    * transitionMatrix(i,j) Since we have to make sure that each hidden state can
0:    * be "left", the following normalization condition has to hold:
0:    * sum(transitionMatrix(i,j),j=1..hiddenStates) = 1
1:    */
0:   private Matrix transitionMatrix;
1: 
1:   /**
1:    * Getter function to get the hidden state transition matrix
1:    *
1:    * @return returns the model's transition matrix.
1:    */
1:   public Matrix getTransitionMatrix() {
1:     return transitionMatrix;
1:   }
1: 
1:   /**
0:    * Output matrix containing the probabilities that we observe a given output
0:    * state given a hidden state. outputMatrix(i,j) is the probability that we
0:    * observe output state j if we are in hidden state i Formally: P(o(t)=o_j |
0:    * h(t)=h_i) = outputMatrix(i,j) Since we always have an observation for each
0:    * hidden state, the following normalization condition has to hold:
0:    * sum(outputMatrix(i,j),j=1..outputStates) = 1
1:    */
0:   private Matrix emissionMatrix;
1: 
1:   /**
1:    * Getter function to get the output state probability matrix
1:    *
1:    * @return returns the models emission matrix.
1:    */
1:   public Matrix getEmissionMatrix() {
1:     return emissionMatrix;
1:   }
1: 
1:   /**
0:    * Vector containing the initial hidden state probabilities. That is
0:    * P(h(0)=h_i) = initialProbabilities(i). Since we are dealing with
0:    * probabilities the following normalization condition has to hold:
0:    * sum(initialProbabilities(i),i=1..hiddenStates) = 1
1:    */
0:   private Vector initialProbabilities;
1: 
1:   /**
1:    * Getter function to return the vector of initial hidden state probabilities
1:    *
1:    * @return returns the model's init probabilities.
1:    */
1:   public Vector getInitialProbabilities() {
1:     return initialProbabilities;
1:   }
1: 
1:   /**
0:    * Bi-Directional Map for storing the hidden state names
1:    */
0:   private BidiMap hiddenStateNames;
1: 
1:   /**
1:    * Getter method for the hidden state Names map
1:    *
1:    * @return hidden state names.
1:    */
0:   @SuppressWarnings("unchecked")
1:   public Map<String, Integer> getHiddenStateNames() {
0:     return hiddenStateNames;
1:   }
1: 
1:   /**
1:    * Register an array of hidden state Names. We assume that the state name at
1:    * position i has the ID i
1:    *
1:    * @param stateNames names of hidden states.
1:    */
1:   public void registerHiddenStateNames(String[] stateNames) {
1:     if (stateNames != null) {
0:       hiddenStateNames = new TreeBidiMap();
1:       for (int i = 0; i < stateNames.length; ++i) {
1:         hiddenStateNames.put(stateNames[i], i);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Register a map of hidden state Names/state IDs
1:    *
1:    * @param stateNames <String,Integer> Map that assigns each state name an integer ID
1:    */
1:   public void registerHiddenStateNames(Map<String, Integer> stateNames) {
0:     if (stateNames != null)
0:       hiddenStateNames = new TreeBidiMap(stateNames);
1:   }
1: 
1:   /**
1:    * Lookup the name for the given hidden state ID
1:    *
1:    * @param id Integer id of the hidden state
1:    * @return String containing the name for the given ID, null if this ID is not
1:    *         known or no hidden state names were specified
1:    */
1:   public String getHiddenStateName(int id) {
0:     if (hiddenStateNames == null)
1:       return null;
0:     return (String) hiddenStateNames.getKey(id);
1:   }
1: 
1:   /**
1:    * Lookup the ID for the given hidden state name
1:    *
1:    * @param name Name of the hidden state
1:    * @return int containing the ID for the given name, -1 if this name is not
1:    *         known or no hidden state names were specified
1:    */
1:   public int getHiddenStateID(String name) {
0:     if (hiddenStateNames == null)
1:       return -1;
0:     Integer tmp = (Integer) hiddenStateNames.get(name);
0:     return (tmp == null) ? -1 : tmp;
1:   }
1: 
1:   /**
0:    * Bi-directional Map for storing the observed state names
1:    */
0:   private BidiMap outputStateNames;
1: 
1:   /**
1:    * Getter method for the output state Names map
1:    *
1:    * @return names of output states.
1:    */
0:   @SuppressWarnings("unchecked")
1:   public Map<String, Integer> getOutputStateNames() {
0:     return outputStateNames;
1:   }
1: 
1:   /**
1:    * Register an array of hidden state Names. We assume that the state name at
1:    * position i has the ID i
1:    *
1:    * @param stateNames state names to register.
1:    */
1:   public void registerOutputStateNames(String[] stateNames) {
1:     if (stateNames != null) {
0:       outputStateNames = new TreeBidiMap();
1:       for (int i = 0; i < stateNames.length; ++i) {
1:         outputStateNames.put(stateNames[i], i);
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Register a map of hidden state Names/state IDs
1:    *
1:    * @param stateNames <String,Integer> Map that assigns each state name an integer ID
1:    */
1:   public void registerOutputStateNames(Map<String, Integer> stateNames) {
0:     if (stateNames != null)
0:       outputStateNames = new TreeBidiMap(stateNames);
1:   }
1: 
1:   /**
1:    * Lookup the name for the given output state id
1:    *
1:    * @param id Integer id of the output state
1:    * @return String containing the name for the given id, null if this id is not
1:    *         known or no output state names were specified
1:    */
1:   public String getOutputStateName(int id) {
0:     if (outputStateNames == null)
1:       return null;
0:     return (String) outputStateNames.getKey(id);
1:   }
1: 
1:   /**
1:    * Lookup the ID for the given output state name
1:    *
1:    * @param name Name of the output state
1:    * @return int containing the ID for the given name, -1 if this name is not
1:    *         known or no output state names were specified
1:    */
1:   public int getOutputStateID(String name) {
0:     if (outputStateNames == null)
1:       return -1;
0:     Integer tmp = (Integer) outputStateNames.get(name);
0:     return (tmp == null) ? -1 : tmp;
1:   }
1: 
1:   /**
0:    * Encode this HMMmodel as a JSON string
1:    *
0:    * @return String containing the JSON of this model
1:    */
0:   public String toJson() {
0:     GsonBuilder builder = new GsonBuilder();
0:     builder.registerTypeAdapter(HmmModel.class, this);
0:     Gson gson = builder.create();
0:     return gson.toJson(this);
1:   }
1: 
1:   /**
0:    * Decode this HmmModel from a JSON string
1:    *
0:    * @param json String containing JSON representation of this model
0:    * @return Initialized model
1:    */
0:   public static HmmModel fromJson(String json) {
0:     GsonBuilder builder = new GsonBuilder();
0:     builder.registerTypeAdapter(HmmModel.class, new HmmModel());
0:     Gson gson = builder.create();
0:     return gson.fromJson(json, HmmModel.class);
1:   }
1: 
0:   // CODE USED FOR SERIALIZATION
1: 
0:   private static final String MODEL = "HMMModel";
0:   private static final String OUTNAMES = "HMMOutNames";
0:   private static final String HIDDENNAMES = "HmmHiddenNames";
1: 
1:   /**
0:    * {@inheritDoc}
1:    */
0:   @Override
0:   public HmmModel deserialize(JsonElement json, Type type,
0:                               JsonDeserializationContext context) {
0:     // register the builders for matrix / vector
0:     GsonBuilder builder = new GsonBuilder();
0:     builder.registerTypeAdapter(Matrix.class, new JsonMatrixAdapter());
0:     builder.registerTypeAdapter(Vector.class, new JsonVectorAdapter());
0:     Gson gson = builder.create();
0:     // now decode the original model
0:     JsonObject obj = json.getAsJsonObject();
0:     String modelString = obj.get(MODEL).getAsString();
0:     HmmModel model = gson.fromJson(modelString, HmmModel.class);
0:     // now decode the names
0:     JsonElement names = obj.get(HIDDENNAMES);
0:     if (names != null) {
0:       Map<String, Integer> tmpMap = gson.fromJson(names.getAsString(),
0:           new TypeToken<Map<String, Integer>>() {
0:           } .getType());
0:       model.registerHiddenStateNames(tmpMap);
1:     }
0:     names = obj.get(OUTNAMES);
0:     if (names != null) {
0:       Map<String, Integer> tmpMap = gson.fromJson(names.getAsString(),
0:           new TypeToken<Map<String, Integer>>() {
0:           } .getType());
0:       model.registerOutputStateNames(tmpMap);
1:     }
0:     // return the model
1:     return model;
1:   }
1: 
0:   @Override
0:   public JsonElement serialize(HmmModel model, Type arg1,
0:                                JsonSerializationContext arg2) {
0:     // we need to make sure that we serialize the bidimaps separately, since
0:     // GSON is unable to do this naively
0:     BidiMap hiddenNames = model.hiddenStateNames;
0:     model.hiddenStateNames = null;
0:     BidiMap outNames = model.outputStateNames;
0:     model.outputStateNames = null;
0:     // now register the builders for matrix / vector
0:     GsonBuilder builder = new GsonBuilder();
0:     builder.registerTypeAdapter(Matrix.class, new JsonMatrixAdapter());
0:     builder.registerTypeAdapter(Vector.class, new JsonVectorAdapter());
0:     Gson gson = builder.create();
0:     // create a model
0:     JsonObject json = new JsonObject();
0:     // first, we add the model
0:     json.add(MODEL, new JsonPrimitive(gson.toJson(model)));
0:     // now, we add the state names
0:     if (outNames != null) {
0:       json.add(OUTNAMES, new JsonPrimitive(gson.toJson(outNames)));
1:     }
0:     if (hiddenNames != null) {
0:       json.add(HIDDENNAMES, new JsonPrimitive(gson.toJson(hiddenNames)));
1:     }
0:     // return the model to its original state :)
0:     model.hiddenStateNames = hiddenNames;
0:     model.outputStateNames = outNames;
0:     return json;
1:   }
1: }
============================================================================