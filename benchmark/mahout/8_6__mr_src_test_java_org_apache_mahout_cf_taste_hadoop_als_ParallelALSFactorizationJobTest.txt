1:af775ba: /**
1:af775ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:af775ba:  * contributor license agreements.  See the NOTICE file distributed with
1:af775ba:  * this work for additional information regarding copyright ownership.
1:af775ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:af775ba:  * (the "License"); you may not use this file except in compliance with
1:af775ba:  * the License.  You may obtain a copy of the License at
1:af775ba:  *
1:af775ba:  *     http://www.apache.org/licenses/LICENSE-2.0
1:af775ba:  *
1:af775ba:  * Unless required by applicable law or agreed to in writing, software
1:af775ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:af775ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:af775ba:  * See the License for the specific language governing permissions and
1:af775ba:  * limitations under the License.
1:af775ba:  */
29:af775ba: 
1:af775ba: package org.apache.mahout.cf.taste.hadoop.als;
1:af775ba: 
1:af775ba: import org.apache.hadoop.conf.Configuration;
1:af775ba: import org.apache.hadoop.fs.Path;
1:e8cd230: import org.apache.hadoop.util.ToolRunner;
1:bbd2b7e: import org.apache.mahout.cf.taste.hadoop.TasteHadoopUtils;
1:af775ba: import org.apache.mahout.cf.taste.impl.TasteTestCase;
1:af775ba: import org.apache.mahout.cf.taste.impl.common.FullRunningAverage;
1:a13b4b7: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
1:af775ba: import org.apache.mahout.math.DenseVector;
1:af775ba: import org.apache.mahout.math.Matrix;
1:af775ba: import org.apache.mahout.math.MatrixSlice;
1:af775ba: import org.apache.mahout.math.SparseRowMatrix;
1:af775ba: import org.apache.mahout.math.Vector;
1:dc62944: import org.apache.mahout.math.Vector.Element;
1:af775ba: import org.apache.mahout.math.hadoop.MathHelper;
1:bbd2b7e: import org.apache.mahout.math.map.OpenIntLongHashMap;
1:bbd2b7e: import org.apache.mahout.math.map.OpenIntObjectHashMap;
1:3631151: import org.junit.Before;
1:af775ba: import org.junit.Test;
1:af775ba: import org.slf4j.Logger;
1:af775ba: import org.slf4j.LoggerFactory;
1:af775ba: 
1:af775ba: import java.io.File;
1:af775ba: 
1:af775ba: public class ParallelALSFactorizationJobTest extends TasteTestCase {
1:af775ba: 
1:74f849b:   private static final Logger log = LoggerFactory.getLogger(ParallelALSFactorizationJobTest.class);
1:3631151: 
1:4fbfbc6:   private File inputFile;
1:bbd2b7e:   private File intermediateDir;
1:4fbfbc6:   private File outputDir;
1:4fbfbc6:   private File tmpDir;
1:4fbfbc6:   private Configuration conf;
1:3631151: 
1:3631151:   @Before
1:3631151:   @Override
1:3631151:   public void setUp() throws Exception {
1:3631151:     super.setUp();
1:3631151:     inputFile = getTestTempFile("prefs.txt");
1:bbd2b7e:     intermediateDir = getTestTempDir("intermediate");
1:bbd2b7e:     intermediateDir.delete();
1:3631151:     outputDir = getTestTempDir("output");
1:3631151:     outputDir.delete();
1:3631151:     tmpDir = getTestTempDir("tmp");
1:3631151: 
1:921e201:     conf = getConfiguration();
1:97f6db2:     // reset as we run all tests in the same JVM
1:97f6db2:     SharingMapper.reset();
1:3631151:   }
1:af775ba: 
1:63c81f1:   @Test
1:63c81f1:   public void completeJobToyExample() throws Exception {
1:63c81f1:     explicitExample(1);
1:63c81f1:   }
1:63c81f1: 
1:63c81f1:   @Test
1:63c81f1:   public void completeJobToyExampleMultithreaded() throws Exception {
1:63c81f1:     explicitExample(2);
1:63c81f1:   }
1:63c81f1: 
1:af775ba:   /**
1:af775ba:    * small integration test that runs the full job
1:af775ba:    *
1:af775ba:    * <pre>
1:af775ba:    *
1:af775ba:    *  user-item-matrix
1:af775ba:    *
1:af775ba:    *          burger  hotdog  berries  icecream
1:af775ba:    *  dog       5       5        2        -
1:af775ba:    *  rabbit    2       -        3        5
1:af775ba:    *  cow       -       5        -        3
1:af775ba:    *  donkey    3       -        -        5
1:af775ba:    *
1:af775ba:    * </pre>
1:af775ba:    */
1:63c81f1:   private void explicitExample(int numThreads) throws Exception {
1:af775ba: 
1:af775ba:     Double na = Double.NaN;
1:95f836b:     Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] {
1:81d64c0:         new DenseVector(new double[] { 5.0, 5.0, 2.0, na }),
1:81d64c0:         new DenseVector(new double[] { 2.0, na,  3.0, 5.0 }),
1:81d64c0:         new DenseVector(new double[] { na,  5.0, na,  3.0 }),
1:81d64c0:         new DenseVector(new double[] { 3.0, na,  na,  5.0 }) });
1:af775ba: 
1:3631151:     writeLines(inputFile, preferencesAsText(preferences));
1:af775ba: 
1:af775ba:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:a13b4b7:     alsFactorization.setConf(conf);
1:3631151: 
1:af775ba:     int numFeatures = 3;
1:af775ba:     int numIterations = 5;
1:af775ba:     double lambda = 0.065;
1:3631151: 
1:3631151:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:3631151:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
1:63c81f1:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:63c81f1:         "--numThreadsPerSolver", String.valueOf(numThreads) });
1:af775ba: 
1:81d64c0:     Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"),
1:af775ba:         preferences.numRows(), numFeatures);
1:81d64c0:     Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"),
1:845cbcd:         preferences.numCols(), numFeatures);
1:af775ba: 
1:3631151:     StringBuilder info = new StringBuilder();
1:3631151:     info.append("\nA - users x items\n\n");
1:08e65f6:     info.append(MathHelper.nice(preferences));
1:3631151:     info.append("\nU - users x features\n\n");
1:08e65f6:     info.append(MathHelper.nice(u));
1:3631151:     info.append("\nM - items x features\n\n");
1:08e65f6:     info.append(MathHelper.nice(m));
1:81d64c0:     Matrix Ak = u.times(m.transpose());
1:3631151:     info.append("\nAk - users x items\n\n");
1:08e65f6:     info.append(MathHelper.nice(Ak));
1:4fbfbc6:     info.append('\n');
1:81d64c0: 
1:3631151:     log.info(info.toString());
1:81d64c0: 
1:a13b4b7:     RunningAverage avg = new FullRunningAverage();
1:dc62944:     for (MatrixSlice slice : preferences) {
1:dc62944:       for (Element e : slice.nonZeroes()) {
2:af775ba:         if (!Double.isNaN(e.get())) {
1:af775ba:           double pref = e.get();
1:528ffcd:           double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));
1:af775ba:           double err = pref - estimate;
1:af775ba:           avg.addDatum(err * err);
1:4194a28:           log.info("Comparing preference of user [{}] towards item [{}], was [{}] estimate is [{}]",
1:8396a27:                    slice.index(), e.index(), pref, estimate);
2:81d64c0:         }
1:81d64c0:       }
1:81d64c0:     }
1:af775ba:     double rmse = Math.sqrt(avg.getAverage());
1:4194a28:     log.info("RMSE: {}", rmse);
1:81d64c0: 
1:208aa07:     assertTrue(rmse < 0.2);
1:3631151:   }
1:3631151: 
1:3631151:   @Test
1:3631151:   public void completeJobImplicitToyExample() throws Exception {
1:63c81f1:     implicitExample(1);
1:63c81f1:   }
1:3631151: 
1:63c81f1:   @Test
1:63c81f1:   public void completeJobImplicitToyExampleMultithreaded() throws Exception {
1:63c81f1:     implicitExample(2);
1:63c81f1:   }
1:63c81f1: 
1:63c81f1:   public void implicitExample(int numThreads) throws Exception {
1:3631151:     Matrix observations = new SparseRowMatrix(4, 4, new Vector[] {
1:3631151:         new DenseVector(new double[] { 5.0, 5.0, 2.0, 0 }),
1:3631151:         new DenseVector(new double[] { 2.0, 0,   3.0, 5.0 }),
1:3631151:         new DenseVector(new double[] { 0,   5.0, 0,   3.0 }),
1:3631151:         new DenseVector(new double[] { 3.0, 0,   0,   5.0 }) });
1:3631151: 
1:3631151:     Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] {
1:3631151:         new DenseVector(new double[] { 1.0, 1.0, 1.0, 0 }),
1:3631151:         new DenseVector(new double[] { 1.0, 0,   1.0, 1.0 }),
1:3631151:         new DenseVector(new double[] { 0,   1.0, 0,   1.0 }),
1:3631151:         new DenseVector(new double[] { 1.0, 0,   0,   1.0 }) });
1:3631151: 
1:3631151:     writeLines(inputFile, preferencesAsText(observations));
1:3631151: 
1:3631151:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:3631151:     alsFactorization.setConf(conf);
1:3631151: 
1:3631151:     int numFeatures = 3;
1:3631151:     int numIterations = 5;
1:3631151:     double lambda = 0.065;
1:3631151:     double alpha = 20;
1:3631151: 
1:3631151:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:3631151:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
1:3631151:         "--implicitFeedback", String.valueOf(true), "--alpha", String.valueOf(alpha),
1:63c81f1:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:63c81f1:         "--numThreadsPerSolver", String.valueOf(numThreads) });
1:3631151: 
1:3631151:     Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"),
1:3631151:         observations.numRows(), numFeatures);
1:3631151:     Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"),
1:3631151:         observations.numCols(), numFeatures);
1:3631151: 
2:3631151:     StringBuilder info = new StringBuilder();
1:3631151:     info.append("\nObservations - users x items\n");
1:08e65f6:     info.append(MathHelper.nice(observations));
1:3631151:     info.append("\nA - users x items\n\n");
1:08e65f6:     info.append(MathHelper.nice(preferences));
1:3631151:     info.append("\nU - users x features\n\n");
1:08e65f6:     info.append(MathHelper.nice(u));
1:3631151:     info.append("\nM - items x features\n\n");
1:08e65f6:     info.append(MathHelper.nice(m));
1:3631151:     Matrix Ak = u.times(m.transpose());
1:3631151:     info.append("\nAk - users x items\n\n");
1:08e65f6:     info.append(MathHelper.nice(Ak));
1:4fbfbc6:     info.append('\n');
1:3631151: 
1:3631151:     log.info(info.toString());
1:af775ba: 
1:3631151:     RunningAverage avg = new FullRunningAverage();
1:dc62944:     for (MatrixSlice slice : preferences) {
1:dc62944:       for (Element e : slice.nonZeroes()) {
1:3631151:         if (!Double.isNaN(e.get())) {
1:3631151:           double pref = e.get();
1:3631151:           double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));
1:3631151:           double confidence = 1 + alpha * observations.getQuick(slice.index(), e.index());
1:3631151:           double err = confidence * (pref - estimate) * (pref - estimate);
1:3631151:           avg.addDatum(err);
1:44459bd:           log.info("Comparing preference of user [{}] towards item [{}], was [{}] with confidence [{}] " 
1:8396a27:                        + "estimate is [{}]", slice.index(), e.index(), pref, confidence, estimate);
1:3631151:         }
1:3631151:       }
1:3631151:     }
1:3631151:     double rmse = Math.sqrt(avg.getAverage());
1:3631151:     log.info("RMSE: {}", rmse);
1:3631151: 
1:3631151:     assertTrue(rmse < 0.4);
1:3631151:   }
1:3631151: 
1:bbd2b7e:   @Test
1:bbd2b7e:   public void exampleWithIDMapping() throws Exception {
1:bbd2b7e: 
1:335a993:     String[] preferencesWithLongIDs = {
1:bbd2b7e:         "5568227754922264005,-4758971626494767444,5.0",
1:bbd2b7e:         "5568227754922264005,3688396615879561990,5.0",
1:bbd2b7e:         "5568227754922264005,4594226737871995304,2.0",
1:bbd2b7e:         "550945997885173934,-4758971626494767444,2.0",
1:bbd2b7e:         "550945997885173934,4594226737871995304,3.0",
1:bbd2b7e:         "550945997885173934,706816485922781596,5.0",
1:bbd2b7e:         "2448095297482319463,3688396615879561990,5.0",
1:bbd2b7e:         "2448095297482319463,706816485922781596,3.0",
1:bbd2b7e:         "6839920411763636962,-4758971626494767444,3.0",
1:bbd2b7e:         "6839920411763636962,706816485922781596,5.0" };
1:bbd2b7e: 
1:bbd2b7e:     writeLines(inputFile, preferencesWithLongIDs);
1:bbd2b7e: 
1:bbd2b7e:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:bbd2b7e:     alsFactorization.setConf(conf);
1:bbd2b7e: 
1:bbd2b7e:     int numFeatures = 3;
1:bbd2b7e:     int numIterations = 5;
1:bbd2b7e:     double lambda = 0.065;
1:bbd2b7e: 
1:bbd2b7e:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:bbd2b7e:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
1:bbd2b7e:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:bbd2b7e:         "--numThreadsPerSolver", String.valueOf(1), "--usesLongIDs", String.valueOf(true) });
1:bbd2b7e: 
1:bbd2b7e: 
1:bbd2b7e:     OpenIntLongHashMap userIDIndex =
1:bbd2b7e:         TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/userIDIndex/part-r-00000", conf);
1:bbd2b7e:     assertEquals(4, userIDIndex.size());
1:bbd2b7e: 
1:bbd2b7e:     OpenIntLongHashMap itemIDIndex =
1:bbd2b7e:         TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/itemIDIndex/part-r-00000", conf);
1:bbd2b7e:     assertEquals(4, itemIDIndex.size());
1:bbd2b7e: 
1:bbd2b7e:     OpenIntObjectHashMap<Vector> u =
1:bbd2b7e:         MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"));
1:bbd2b7e:     OpenIntObjectHashMap<Vector> m =
1:bbd2b7e:         MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"));
1:bbd2b7e: 
1:bbd2b7e:     assertEquals(4, u.size());
1:bbd2b7e:     assertEquals(4, m.size());
1:bbd2b7e: 
1:bbd2b7e:     RunningAverage avg = new FullRunningAverage();
1:bbd2b7e:     for (String line : preferencesWithLongIDs) {
1:bbd2b7e:       String[] tokens = TasteHadoopUtils.splitPrefTokens(line);
1:bbd2b7e:       long userID = Long.parseLong(tokens[TasteHadoopUtils.USER_ID_POS]);
1:bbd2b7e:       long itemID = Long.parseLong(tokens[TasteHadoopUtils.ITEM_ID_POS]);
1:bbd2b7e:       double rating = Double.parseDouble(tokens[2]);
1:bbd2b7e: 
1:bbd2b7e:       Vector userFeatures = u.get(TasteHadoopUtils.idToIndex(userID));
1:bbd2b7e:       Vector itemFeatures = m.get(TasteHadoopUtils.idToIndex(itemID));
1:bbd2b7e: 
1:bbd2b7e:       double estimate = userFeatures.dot(itemFeatures);
1:bbd2b7e: 
1:bbd2b7e:       double err = rating - estimate;
1:bbd2b7e:       avg.addDatum(err * err);
1:bbd2b7e:     }
1:bbd2b7e: 
1:bbd2b7e:     double rmse = Math.sqrt(avg.getAverage());
1:bbd2b7e:     log.info("RMSE: {}", rmse);
1:bbd2b7e: 
1:bbd2b7e:     assertTrue(rmse < 0.2);
1:bbd2b7e:   }
1:bbd2b7e: 
1:4fbfbc6:   protected static String preferencesAsText(Matrix preferences) {
1:3631151:     StringBuilder prefsAsText = new StringBuilder();
1:3631151:     String separator = "";
1:dc62944:     for (MatrixSlice slice : preferences) {
1:dc62944:       for (Element e : slice.nonZeroes()) {
1:3631151:         if (!Double.isNaN(e.get())) {
1:dc62944:           prefsAsText.append(separator)
1:dc62944:               .append(slice.index()).append(',').append(e.index()).append(',').append(e.get());
1:3631151:           separator = "\n";
1:3631151:         }
1:3631151:       }
1:3631151:     }
1:bbd2b7e:     System.out.println(prefsAsText.toString());
1:3631151:     return prefsAsText.toString();
1:3631151:   }
1:bbd2b7e: 
1:bbd2b7e:   @Test
1:bbd2b7e:   public void recommenderJobWithIDMapping() throws Exception {
1:bbd2b7e: 
1:335a993:     String[] preferencesWithLongIDs = {
1:bbd2b7e:         "5568227754922264005,-4758971626494767444,5.0",
1:bbd2b7e:         "5568227754922264005,3688396615879561990,5.0",
1:bbd2b7e:         "5568227754922264005,4594226737871995304,2.0",
1:bbd2b7e:         "550945997885173934,-4758971626494767444,2.0",
1:bbd2b7e:         "550945997885173934,4594226737871995304,3.0",
1:bbd2b7e:         "550945997885173934,706816485922781596,5.0",
1:bbd2b7e:         "2448095297482319463,3688396615879561990,5.0",
1:bbd2b7e:         "2448095297482319463,706816485922781596,3.0",
1:bbd2b7e:         "6839920411763636962,-4758971626494767444,3.0",
1:bbd2b7e:         "6839920411763636962,706816485922781596,5.0" };
1:bbd2b7e: 
1:bbd2b7e:     writeLines(inputFile, preferencesWithLongIDs);
1:bbd2b7e: 
1:bbd2b7e:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:bbd2b7e:     alsFactorization.setConf(conf);
1:bbd2b7e: 
1:bbd2b7e:     int numFeatures = 3;
1:bbd2b7e:     int numIterations = 5;
1:bbd2b7e:     double lambda = 0.065;
1:08e65f6: 
1:e8cd230:     Configuration conf = getConfiguration();
1:e8cd230: 
1:e8cd230:     int success = ToolRunner.run(alsFactorization, new String[] {
1:e8cd230:         "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"),
1:bbd2b7e:         "--input", inputFile.getAbsolutePath(),
1:bbd2b7e:         "--output", intermediateDir.getAbsolutePath(),
1:bbd2b7e:         "--tempDir", tmpDir.getAbsolutePath(),
1:bbd2b7e:         "--lambda", String.valueOf(lambda),
1:bbd2b7e:         "--numFeatures", String.valueOf(numFeatures),
1:bbd2b7e:         "--numIterations", String.valueOf(numIterations),
1:bbd2b7e:         "--numThreadsPerSolver", String.valueOf(1),
1:bbd2b7e:         "--usesLongIDs", String.valueOf(true) });
1:bbd2b7e: 
1:335a993:     assertEquals(0, success);
1:bbd2b7e: 
1:bbd2b7e:     // reset as we run in the same JVM
1:bbd2b7e:     SharingMapper.reset();
1:bbd2b7e: 
1:bbd2b7e:     RecommenderJob recommender = new RecommenderJob();
1:bbd2b7e: 
1:e8cd230:     success = ToolRunner.run(recommender, new String[] {
1:e8cd230:         "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"),
1:bbd2b7e:         "--input", intermediateDir.getAbsolutePath() + "/userRatings/",
1:bbd2b7e:         "--userFeatures", intermediateDir.getAbsolutePath() + "/U/",
1:bbd2b7e:         "--itemFeatures", intermediateDir.getAbsolutePath() + "/M/",
1:bbd2b7e:         "--numRecommendations", String.valueOf(2),
1:bbd2b7e:         "--maxRating", String.valueOf(5.0),
1:bbd2b7e:         "--numThreads", String.valueOf(2),
1:bbd2b7e:         "--usesLongIDs", String.valueOf(true),
1:bbd2b7e:         "--userIDIndex", intermediateDir.getAbsolutePath() + "/userIDIndex/",
1:bbd2b7e:         "--itemIDIndex", intermediateDir.getAbsolutePath() + "/itemIDIndex/",
1:bbd2b7e:         "--output", outputDir.getAbsolutePath() });
1:bbd2b7e: 
1:bbd2b7e:     assertEquals(0, success);
1:bbd2b7e:   }
1:3631151: 
1:3631151: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:sslavic
-------------------------------------------------------------------------------
commit:e8cd230
/////////////////////////////////////////////////////////////////////////
1: import org.apache.hadoop.util.ToolRunner;
/////////////////////////////////////////////////////////////////////////
1:     Configuration conf = getConfiguration();
1: 
1:     int success = ToolRunner.run(alsFactorization, new String[] {
1:         "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"),
/////////////////////////////////////////////////////////////////////////
1:     success = ToolRunner.run(recommender, new String[] {
1:         "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"),
commit:921e201
/////////////////////////////////////////////////////////////////////////
1:     conf = getConfiguration();
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:335a993
/////////////////////////////////////////////////////////////////////////
1:     String[] preferencesWithLongIDs = {
/////////////////////////////////////////////////////////////////////////
1:     String[] preferencesWithLongIDs = {
/////////////////////////////////////////////////////////////////////////
1:     assertEquals(0, success);
commit:8396a27
/////////////////////////////////////////////////////////////////////////
1:                    slice.index(), e.index(), pref, estimate);
/////////////////////////////////////////////////////////////////////////
1:                        + "estimate is [{}]", slice.index(), e.index(), pref, confidence, estimate);
commit:4fbfbc6
/////////////////////////////////////////////////////////////////////////
1:   private File inputFile;
1:   private File outputDir;
1:   private File tmpDir;
1:   private Configuration conf;
/////////////////////////////////////////////////////////////////////////
1:     info.append('\n');
/////////////////////////////////////////////////////////////////////////
1:     info.append('\n');
/////////////////////////////////////////////////////////////////////////
0:       for (Vector.Element e : slice.vector()) {
/////////////////////////////////////////////////////////////////////////
0:                        "estimate is [{}]", new Object[]{slice.index(), e.index(), pref, confidence, estimate});
/////////////////////////////////////////////////////////////////////////
1:   protected static String preferencesAsText(Matrix preferences) {
commit:4194a28
/////////////////////////////////////////////////////////////////////////
0:     log.info("Input matrix:\n{}", prefsAsText);
/////////////////////////////////////////////////////////////////////////
1:           log.info("Comparing preference of user [{}] towards item [{}], was [{}] estimate is [{}]",
0:                    new Object[] {slice.index(), e.index(), pref, estimate});
1:     log.info("RMSE: {}", rmse);
commit:055f4ab
/////////////////////////////////////////////////////////////////////////
0: import org.easymock.EasyMock;
commit:208aa07
/////////////////////////////////////////////////////////////////////////
1:     assertTrue(rmse < 0.2);
commit:a13b4b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
/////////////////////////////////////////////////////////////////////////
0:     ctx.write(EasyMock.eq(new VarIntWritable(TasteHadoopUtils.idToIndex(123L))), matchInitializedFeatureVector(3.0, 3));
0:     reducer.reduce(new VarLongWritable(123L), Arrays.asList(new FloatWritable(4.0f), new FloatWritable(2.0f)), ctx);
/////////////////////////////////////////////////////////////////////////
0:         new DenseVector(new double[] {5.0, 5.0, 2.0,  na }),
0:         new DenseVector(new double[] {2.0,  na, 3.0, 5.0 }),
0:         new DenseVector(new double[] { na, 5.0,  na, 3.0 }),
0:         new DenseVector(new double[] {3.0,  na,  na, 5.0 }) });
/////////////////////////////////////////////////////////////////////////
0:           prefsAsText.append(separator).append(slice.index()).append(',').append(e.index()).append(',').append(e.get());
/////////////////////////////////////////////////////////////////////////
1:     alsFactorization.setConf(conf);
0:     Matrix u = MathHelper.readEntries(conf, new Path(outputDir.getAbsolutePath(), "U/part-r-00000"),
0:     Matrix m = MathHelper.readEntries(conf, new Path(outputDir.getAbsolutePath(), "M/part-r-00000"),
1:     RunningAverage avg = new FullRunningAverage();
/////////////////////////////////////////////////////////////////////////
0:               "was [" + pref + "] estimate is [" + estimate + ']');
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:bbd2b7e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.cf.taste.hadoop.TasteHadoopUtils;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.map.OpenIntLongHashMap;
1: import org.apache.mahout.math.map.OpenIntObjectHashMap;
/////////////////////////////////////////////////////////////////////////
1:   private File intermediateDir;
/////////////////////////////////////////////////////////////////////////
1:     intermediateDir = getTestTempDir("intermediate");
1:     intermediateDir.delete();
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void exampleWithIDMapping() throws Exception {
1: 
0:     String[] preferencesWithLongIDs = new String[] {
1:         "5568227754922264005,-4758971626494767444,5.0",
1:         "5568227754922264005,3688396615879561990,5.0",
1:         "5568227754922264005,4594226737871995304,2.0",
1:         "550945997885173934,-4758971626494767444,2.0",
1:         "550945997885173934,4594226737871995304,3.0",
1:         "550945997885173934,706816485922781596,5.0",
1:         "2448095297482319463,3688396615879561990,5.0",
1:         "2448095297482319463,706816485922781596,3.0",
1:         "6839920411763636962,-4758971626494767444,3.0",
1:         "6839920411763636962,706816485922781596,5.0" };
1: 
1:     writeLines(inputFile, preferencesWithLongIDs);
1: 
1:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:     alsFactorization.setConf(conf);
1: 
1:     int numFeatures = 3;
1:     int numIterations = 5;
1:     double lambda = 0.065;
1: 
1:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
1:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:         "--numThreadsPerSolver", String.valueOf(1), "--usesLongIDs", String.valueOf(true) });
1: 
1: 
1:     OpenIntLongHashMap userIDIndex =
1:         TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/userIDIndex/part-r-00000", conf);
1:     assertEquals(4, userIDIndex.size());
1: 
1:     OpenIntLongHashMap itemIDIndex =
1:         TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/itemIDIndex/part-r-00000", conf);
1:     assertEquals(4, itemIDIndex.size());
1: 
1:     OpenIntObjectHashMap<Vector> u =
1:         MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"));
1:     OpenIntObjectHashMap<Vector> m =
1:         MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"));
1: 
1:     assertEquals(4, u.size());
1:     assertEquals(4, m.size());
1: 
1:     RunningAverage avg = new FullRunningAverage();
1:     for (String line : preferencesWithLongIDs) {
1:       String[] tokens = TasteHadoopUtils.splitPrefTokens(line);
1:       long userID = Long.parseLong(tokens[TasteHadoopUtils.USER_ID_POS]);
1:       long itemID = Long.parseLong(tokens[TasteHadoopUtils.ITEM_ID_POS]);
1:       double rating = Double.parseDouble(tokens[2]);
1: 
1:       Vector userFeatures = u.get(TasteHadoopUtils.idToIndex(userID));
1:       Vector itemFeatures = m.get(TasteHadoopUtils.idToIndex(itemID));
1: 
1:       double estimate = userFeatures.dot(itemFeatures);
1: 
1:       double err = rating - estimate;
1:       avg.addDatum(err * err);
1:     }
1: 
1:     double rmse = Math.sqrt(avg.getAverage());
1:     log.info("RMSE: {}", rmse);
1: 
1:     assertTrue(rmse < 0.2);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:     System.out.println(prefsAsText.toString());
1:   @Test
1:   public void recommenderJobWithIDMapping() throws Exception {
1: 
0:     String[] preferencesWithLongIDs = new String[] {
1:         "5568227754922264005,-4758971626494767444,5.0",
1:         "5568227754922264005,3688396615879561990,5.0",
1:         "5568227754922264005,4594226737871995304,2.0",
1:         "550945997885173934,-4758971626494767444,2.0",
1:         "550945997885173934,4594226737871995304,3.0",
1:         "550945997885173934,706816485922781596,5.0",
1:         "2448095297482319463,3688396615879561990,5.0",
1:         "2448095297482319463,706816485922781596,3.0",
1:         "6839920411763636962,-4758971626494767444,3.0",
1:         "6839920411763636962,706816485922781596,5.0" };
1: 
1:     writeLines(inputFile, preferencesWithLongIDs);
1: 
1:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:     alsFactorization.setConf(conf);
1: 
1:     int numFeatures = 3;
1:     int numIterations = 5;
1:     double lambda = 0.065;
1: 
0:     int success = alsFactorization.run(new String[] {
1:         "--input", inputFile.getAbsolutePath(),
1:         "--output", intermediateDir.getAbsolutePath(),
1:         "--tempDir", tmpDir.getAbsolutePath(),
1:         "--lambda", String.valueOf(lambda),
1:         "--numFeatures", String.valueOf(numFeatures),
1:         "--numIterations", String.valueOf(numIterations),
1:         "--numThreadsPerSolver", String.valueOf(1),
1:         "--usesLongIDs", String.valueOf(true) });
1: 
0:     assertEquals(success, 0);
1: 
1:     // reset as we run in the same JVM
1:     SharingMapper.reset();
1: 
1:     RecommenderJob recommender = new RecommenderJob();
1: 
0:     success = recommender.run(new String[] {
1:         "--input", intermediateDir.getAbsolutePath() + "/userRatings/",
1:         "--userFeatures", intermediateDir.getAbsolutePath() + "/U/",
1:         "--itemFeatures", intermediateDir.getAbsolutePath() + "/M/",
1:         "--numRecommendations", String.valueOf(2),
1:         "--maxRating", String.valueOf(5.0),
1:         "--numThreads", String.valueOf(2),
1:         "--usesLongIDs", String.valueOf(true),
1:         "--userIDIndex", intermediateDir.getAbsolutePath() + "/userIDIndex/",
1:         "--itemIDIndex", intermediateDir.getAbsolutePath() + "/itemIDIndex/",
1:         "--output", outputDir.getAbsolutePath() });
1: 
1:     assertEquals(0, success);
1:   }
commit:97f6db2
/////////////////////////////////////////////////////////////////////////
1:     // reset as we run all tests in the same JVM
1:     SharingMapper.reset();
commit:63c81f1
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void completeJobToyExample() throws Exception {
1:     explicitExample(1);
1:   }
1: 
1:   @Test
1:   public void completeJobToyExampleMultithreaded() throws Exception {
1:     explicitExample(2);
1:   }
1: 
/////////////////////////////////////////////////////////////////////////
1:   private void explicitExample(int numThreads) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:         "--numThreadsPerSolver", String.valueOf(numThreads) });
/////////////////////////////////////////////////////////////////////////
1:     implicitExample(1);
1:   }
1:   @Test
1:   public void completeJobImplicitToyExampleMultithreaded() throws Exception {
1:     implicitExample(2);
1:   }
1: 
1:   public void implicitExample(int numThreads) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations),
1:         "--numThreadsPerSolver", String.valueOf(numThreads) });
commit:08e65f6
/////////////////////////////////////////////////////////////////////////
1:     info.append(MathHelper.nice(preferences));
1:     info.append(MathHelper.nice(u));
1:     info.append(MathHelper.nice(m));
1:     info.append(MathHelper.nice(Ak));
/////////////////////////////////////////////////////////////////////////
1:     info.append(MathHelper.nice(observations));
1:     info.append(MathHelper.nice(preferences));
1:     info.append(MathHelper.nice(u));
1:     info.append(MathHelper.nice(m));
1:     info.append(MathHelper.nice(Ak));
/////////////////////////////////////////////////////////////////////////
1: 
commit:3631151
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Before;
/////////////////////////////////////////////////////////////////////////
0:   File inputFile;
0:   File outputDir;
0:   File tmpDir;
1: 
0:   Configuration conf;
1: 
1:   @Before
1:   @Override
1:   public void setUp() throws Exception {
1:     super.setUp();
1:     inputFile = getTestTempFile("prefs.txt");
1:     outputDir = getTestTempDir("output");
1:     outputDir.delete();
1:     tmpDir = getTestTempDir("tmp");
1: 
0:     conf = new Configuration();
1:   }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     writeLines(inputFile, preferencesAsText(preferences));
1: 
1: 
1:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
/////////////////////////////////////////////////////////////////////////
1:     StringBuilder info = new StringBuilder();
1:     info.append("\nA - users x items\n\n");
0:     info.append(nice(preferences));
1:     info.append("\nU - users x features\n\n");
0:     info.append(nice(u));
1:     info.append("\nM - items x features\n\n");
0:     info.append(nice(m));
1:     info.append("\nAk - users x items\n\n");
0:     info.append(nice(Ak));
0:     info.append("\n");
1:     log.info(info.toString());
0:     Iterator<MatrixSlice> sliceIterator = preferences.iterateAll();
/////////////////////////////////////////////////////////////////////////
1:   @Test
1:   public void completeJobImplicitToyExample() throws Exception {
1: 
1:     Matrix observations = new SparseRowMatrix(4, 4, new Vector[] {
1:         new DenseVector(new double[] { 5.0, 5.0, 2.0, 0 }),
1:         new DenseVector(new double[] { 2.0, 0,   3.0, 5.0 }),
1:         new DenseVector(new double[] { 0,   5.0, 0,   3.0 }),
1:         new DenseVector(new double[] { 3.0, 0,   0,   5.0 }) });
1: 
1:     Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] {
1:         new DenseVector(new double[] { 1.0, 1.0, 1.0, 0 }),
1:         new DenseVector(new double[] { 1.0, 0,   1.0, 1.0 }),
1:         new DenseVector(new double[] { 0,   1.0, 0,   1.0 }),
1:         new DenseVector(new double[] { 1.0, 0,   0,   1.0 }) });
1: 
1:     writeLines(inputFile, preferencesAsText(observations));
1: 
1:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1:     alsFactorization.setConf(conf);
1: 
1:     int numFeatures = 3;
1:     int numIterations = 5;
1:     double lambda = 0.065;
1:     double alpha = 20;
1: 
1:     alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(),
1:         "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
1:         "--implicitFeedback", String.valueOf(true), "--alpha", String.valueOf(alpha),
0:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations) });
1: 
1:     Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"),
1:         observations.numRows(), numFeatures);
1:     Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"),
1:         observations.numCols(), numFeatures);
1: 
1:     StringBuilder info = new StringBuilder();
1:     info.append("\nObservations - users x items\n");
0:     info.append(nice(observations));
1:     info.append("\nA - users x items\n\n");
0:     info.append(nice(preferences));
1:     info.append("\nU - users x features\n\n");
0:     info.append(nice(u));
1:     info.append("\nM - items x features\n\n");
0:     info.append(nice(m));
1:     Matrix Ak = u.times(m.transpose());
1:     info.append("\nAk - users x items\n\n");
0:     info.append(nice(Ak));
0:     info.append("\n");
1: 
1:     log.info(info.toString());
1: 
1:     RunningAverage avg = new FullRunningAverage();
0:     Iterator<MatrixSlice> sliceIterator = preferences.iterateAll();
0:     while (sliceIterator.hasNext()) {
0:       MatrixSlice slice = sliceIterator.next();
0:       Iterator<Vector.Element> elementIterator = slice.vector().iterator();
0:       while (elementIterator.hasNext()) {
0:         Vector.Element e = elementIterator.next();
1:         if (!Double.isNaN(e.get())) {
1:           double pref = e.get();
1:           double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));
1:           double confidence = 1 + alpha * observations.getQuick(slice.index(), e.index());
1:           double err = confidence * (pref - estimate) * (pref - estimate);
1:           avg.addDatum(err);
0:           log.info("Comparing preference of user [{}] towards item [{}], was [{}] with confidence [{}] " +
0:               "estimate is [{}]", new Object[] { slice.index(), e.index(), pref, confidence, estimate });
1:         }
1:       }
1:     }
1:     double rmse = Math.sqrt(avg.getAverage());
1:     log.info("RMSE: {}", rmse);
1: 
1:     assertTrue(rmse < 0.4);
1:   }
1: 
0:   protected String preferencesAsText(Matrix preferences) {
1:     StringBuilder prefsAsText = new StringBuilder();
1:     String separator = "";
0:     Iterator<MatrixSlice> sliceIterator = preferences.iterateAll();
0:     while (sliceIterator.hasNext()) {
0:       MatrixSlice slice = sliceIterator.next();
0:       Iterator<Vector.Element> elementIterator = slice.vector().iterateNonZero();
0:       while (elementIterator.hasNext()) {
0:         Vector.Element e = elementIterator.next();
1:         if (!Double.isNaN(e.get())) {
0:           prefsAsText.append(separator).append(slice.index()).append(',').append(e.index()).append(',').append(e.get());
1:           separator = "\n";
1:         }
1:       }
1:     }
1:     return prefsAsText.toString();
1:   }
1: 
0:   protected StringBuilder nice(Matrix matrix) {
1:     StringBuilder info = new StringBuilder();
0:     for (int n = 0; n < matrix.numRows(); n++) {
0:       info.append(ALSUtils.nice(matrix.viewRow(n))).append("\n");
1:     }
0:     return info;
1:   }
commit:81d64c0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         new DenseVector(new double[] { 5.0, 5.0, 2.0, na }),
1:         new DenseVector(new double[] { 2.0, na,  3.0, 5.0 }),
1:         new DenseVector(new double[] { na,  5.0, na,  3.0 }),
1:         new DenseVector(new double[] { 3.0, na,  na,  5.0 }) });
/////////////////////////////////////////////////////////////////////////
1:     Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"),
1:     Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"),
0:     System.out.println("A - users x items\n");
0:     for (int n = 0; n < preferences.numRows(); n++) {
0:       System.out.println(ALSUtils.nice(preferences.viewRow(n)));
1:     }
0:     System.out.println("\nU - users x features\n");
0:     for (int n = 0; n < u.numRows(); n++) {
0:       System.out.println(ALSUtils.nice(u.viewRow(n)));
1:     }
0:     System.out.println("\nM - items x features\n");
0:     for (int n = 0; n < m.numRows(); n++) {
0:       System.out.println(ALSUtils.nice(m.viewRow(n)));
1:     }
1:     Matrix Ak = u.times(m.transpose());
0:     System.out.println("\nAk - users x items\n");
0:     for (int n = 0; n < Ak.numRows(); n++) {
0:       System.out.println(ALSUtils.nice(Ak.viewRow(n)));
1:     }
1: 
0:     System.out.println();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                    new Object[] { slice.index(), e.index(), pref, estimate });
commit:845cbcd
/////////////////////////////////////////////////////////////////////////
0:     Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-r-00000"),
0:     Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-r-00000"),
1:         preferences.numCols(), numFeatures);
commit:74f849b
/////////////////////////////////////////////////////////////////////////
1:   private static final Logger log = LoggerFactory.getLogger(ParallelALSFactorizationJobTest.class);
/////////////////////////////////////////////////////////////////////////
0:     log.info("Input matrix:\n" + prefsAsText);
/////////////////////////////////////////////////////////////////////////
0:           log.info("Comparing preference of user [" + slice.index() + "] towards item [" + e.index() + "], " +
0:     log.info("RMSE: " + rmse);
commit:af775ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.hadoop.als;
1: 
1: import org.apache.hadoop.conf.Configuration;
0: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
0: import org.apache.hadoop.io.FloatWritable;
0: import org.apache.hadoop.io.LongWritable;
0: import org.apache.hadoop.io.Text;
0: import org.apache.hadoop.mapreduce.Mapper;
0: import org.apache.hadoop.mapreduce.Reducer;
0: import org.apache.mahout.cf.taste.hadoop.TasteHadoopUtils;
1: import org.apache.mahout.cf.taste.impl.TasteTestCase;
1: import org.apache.mahout.cf.taste.impl.common.FullRunningAverage;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.MatrixSlice;
1: import org.apache.mahout.math.SparseRowMatrix;
0: import org.apache.mahout.math.VarIntWritable;
0: import org.apache.mahout.math.VarLongWritable;
1: import org.apache.mahout.math.Vector;
0: import org.apache.mahout.math.als.AlternateLeastSquaresSolver;
1: import org.apache.mahout.math.hadoop.MathHelper;
0: import org.easymock.IArgumentMatcher;
0: import org.easymock.classextension.EasyMock;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import java.io.File;
0: import java.util.Arrays;
0: import java.util.Iterator;
1: 
1: public class ParallelALSFactorizationJobTest extends TasteTestCase {
1: 
0:   private static final Logger logger = LoggerFactory.getLogger(ParallelALSFactorizationJobTest.class);
1: 
0:   @Test
0:   public void prefsToRatingsMapper() throws Exception {
0:     Mapper<LongWritable,Text,VarIntWritable,FeatureVectorWithRatingWritable>.Context ctx =
0:       EasyMock.createMock(Mapper.Context.class);
0:     ctx.write(new VarIntWritable(TasteHadoopUtils.idToIndex(456L)),
0:         new FeatureVectorWithRatingWritable(TasteHadoopUtils.idToIndex(123L), 2.35f));
0:     EasyMock.replay(ctx);
1: 
0:     new ParallelALSFactorizationJob.PrefsToRatingsMapper().map(null, new Text("123,456,2.35"), ctx);
0:     EasyMock.verify(ctx);
0:   }
1: 
0:   @Test
0:   public void prefsToRatingsMapperTranspose() throws Exception {
0:     Mapper<LongWritable,Text,VarIntWritable,FeatureVectorWithRatingWritable>.Context ctx =
0:       EasyMock.createMock(Mapper.Context.class);
0:     ctx.write(new VarIntWritable(TasteHadoopUtils.idToIndex(123L)),
0:         new FeatureVectorWithRatingWritable(TasteHadoopUtils.idToIndex(456L), 2.35f));
0:     EasyMock.replay(ctx);
1: 
0:     ParallelALSFactorizationJob.PrefsToRatingsMapper mapper = new ParallelALSFactorizationJob.PrefsToRatingsMapper();
0:     setField(mapper, "transpose", true);
0:     mapper.map(null, new Text("123,456,2.35"), ctx);
0:     EasyMock.verify(ctx);
0:   }
1: 
0:   @Test
0:   public void initializeMReducer() throws Exception {
0:     Reducer<VarLongWritable,FloatWritable,VarIntWritable,FeatureVectorWithRatingWritable>.Context ctx =
0:         EasyMock.createMock(Reducer.Context.class);
0:     ctx.write(EasyMock.eq(new VarIntWritable(TasteHadoopUtils.idToIndex(123L))), matchInitializedFeatureVector(3d, 3));
0:     EasyMock.replay(ctx);
1: 
0:     ParallelALSFactorizationJob.InitializeMReducer reducer = new ParallelALSFactorizationJob.InitializeMReducer();
0:     setField(reducer, "numFeatures", 3);
0:     reducer.reduce(new VarLongWritable(123L), Arrays.asList(new FloatWritable(4f), new FloatWritable(2f)), ctx);
0:     EasyMock.verify(ctx);
0:   }
1: 
0:   static FeatureVectorWithRatingWritable matchInitializedFeatureVector(final double average, final int numFeatures) {
0:     EasyMock.reportMatcher(new IArgumentMatcher() {
0:       @Override
0:       public boolean matches(Object argument) {
0:         if (argument instanceof FeatureVectorWithRatingWritable) {
0:           Vector v = ((FeatureVectorWithRatingWritable) argument).getFeatureVector();
0:           if (v.get(0) != average) {
0:             return false;
0:           }
0:           for (int n = 1; n < numFeatures; n++) {
0:             if (v.get(n) < 0 || v.get(n) > 1) {
0:               return false;
0:             }
0:           }
0:           return true;
0:         }
0:         return false;
0:       }
1: 
0:       @Override
0:       public void appendTo(StringBuffer buffer) {}
0:     });
0:     return null;
0:   }
1: 
0:   @Test
0:   public void itemIDRatingMapper() throws Exception {
0:     Mapper<LongWritable,Text,VarLongWritable,FloatWritable>.Context ctx = EasyMock.createMock(Mapper.Context.class);
0:     ctx.write(new VarLongWritable(456L), new FloatWritable(2.35f));
0:     EasyMock.replay(ctx);
0:     new ParallelALSFactorizationJob.ItemIDRatingMapper().map(null, new Text("123,456,2.35"), ctx);
0:     EasyMock.verify(ctx);
0:   }
1: 
0:   @Test
0:   public void joinFeatureVectorAndRatingsReducer() throws Exception {
0:     Vector vector = new DenseVector(new double[] { 4.5, 1.2 });
0:     Reducer<VarIntWritable,FeatureVectorWithRatingWritable,IndexedVarIntWritable,FeatureVectorWithRatingWritable>.Context ctx =
0:         EasyMock.createMock(Reducer.Context.class);
0:     ctx.write(new IndexedVarIntWritable(456, 123), new FeatureVectorWithRatingWritable(123, 2.35f, vector));
0:     EasyMock.replay(ctx);
0:     new ParallelALSFactorizationJob.JoinFeatureVectorAndRatingsReducer().reduce(new VarIntWritable(123),
0:         Arrays.asList(new FeatureVectorWithRatingWritable(456, vector),
0:         new FeatureVectorWithRatingWritable(456, 2.35f)), ctx);
0:     EasyMock.verify(ctx);
0:   }
1: 
1: 
0:   @Test
0:   public void solvingReducer() throws Exception {
1: 
0:     AlternateLeastSquaresSolver solver = new AlternateLeastSquaresSolver();
1: 
0:     int numFeatures = 2;
0:     double lambda = 0.01;
0:     Vector ratings = new DenseVector(new double[] { 2, 1 });
0:     Vector col1 = new DenseVector(new double[] { 1, 2 });
0:     Vector col2 = new DenseVector(new double[] { 3, 4 });
1: 
0:     Vector result = solver.solve(Arrays.asList(col1, col2), ratings, lambda, numFeatures);
0:     Vector.Element[] elems = new Vector.Element[result.size()];
0:     for (int n = 0; n < result.size(); n++) {
0:       elems[n] = result.getElement(n);
0:     }
1: 
0:     Reducer<IndexedVarIntWritable,FeatureVectorWithRatingWritable,VarIntWritable,FeatureVectorWithRatingWritable>.Context ctx =
0:         EasyMock.createMock(Reducer.Context.class);
0:     ctx.write(EasyMock.eq(new VarIntWritable(123)), matchFeatureVector(elems));
0:     EasyMock.replay(ctx);
1: 
0:     ParallelALSFactorizationJob.SolvingReducer reducer = new ParallelALSFactorizationJob.SolvingReducer();
0:     setField(reducer, "numFeatures", numFeatures);
0:     setField(reducer, "lambda", lambda);
0:     setField(reducer, "solver", solver);
1: 
0:     reducer.reduce(new IndexedVarIntWritable(123, 1), Arrays.asList(
0:         new FeatureVectorWithRatingWritable(456, new Float(ratings.get(0)), col1),
0:         new FeatureVectorWithRatingWritable(789, new Float(ratings.get(1)), col2)), ctx);
1: 
0:     EasyMock.verify(ctx);
0:   }
1: 
0:   static FeatureVectorWithRatingWritable matchFeatureVector(final Vector.Element... elements) {
0:     EasyMock.reportMatcher(new IArgumentMatcher() {
0:       @Override
0:       public boolean matches(Object argument) {
0:         if (argument instanceof FeatureVectorWithRatingWritable) {
0:           Vector v = ((FeatureVectorWithRatingWritable) argument).getFeatureVector();
0:           return MathHelper.consistsOf(v, elements);
0:         }
0:         return false;
0:       }
1: 
0:       @Override
0:       public void appendTo(StringBuffer buffer) {}
0:     });
0:     return null;
0:   }
1: 
1: 
1:   /**
1:    * small integration test that runs the full job
1:    *
1:    * <pre>
1:    *
1:    *  user-item-matrix
1:    *
1:    *          burger  hotdog  berries  icecream
1:    *  dog       5       5        2        -
1:    *  rabbit    2       -        3        5
1:    *  cow       -       5        -        3
1:    *  donkey    3       -        -        5
1:    *
1:    * </pre>
1:    */
0:   @Test
0:   public void completeJobToyExample() throws Exception {
1: 
0:     File inputFile = getTestTempFile("prefs.txt");
0:     File outputDir = getTestTempDir("output");
0:     outputDir.delete();
0:     File tmpDir = getTestTempDir("tmp");
1: 
1:     Double na = Double.NaN;
0:     Matrix preferences = new SparseRowMatrix(new int[] { 4, 4 }, new Vector[] {
0:         new DenseVector(new double[] { 5d, 5d, 2d, na }),
0:         new DenseVector(new double[] { 2d, na, 3d, 5d }),
0:         new DenseVector(new double[] { na, 5d, na, 3d }),
0:         new DenseVector(new double[] { 3d, na, na, 5d }) });
1: 
0:     StringBuilder prefsAsText = new StringBuilder();
0:     String separator = "";
0:     Iterator<MatrixSlice> sliceIterator = preferences.iterateAll();
0:     while (sliceIterator.hasNext()) {
0:       MatrixSlice slice = sliceIterator.next();
0:       Iterator<Vector.Element> elementIterator = slice.vector().iterateNonZero();
0:       while (elementIterator.hasNext()) {
0:         Vector.Element e = elementIterator.next();
1:         if (!Double.isNaN(e.get())) {
0:           prefsAsText.append(separator).append(slice.index()).append(",").append(e.index()).append(",").append(e.get());
0:           separator = "\n";
0:         }
0:       }
0:     }
0:     logger.info("Input matrix:\n" + prefsAsText);
0:     writeLines(inputFile, prefsAsText.toString());
1: 
1:     ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();
1: 
0:     Configuration conf = new Configuration();
0:     conf.set("mapred.input.dir", inputFile.getAbsolutePath());
0:     conf.set("mapred.output.dir", outputDir.getAbsolutePath());
0:     conf.setBoolean("mapred.output.compress", false);
1: 
1:     int numFeatures = 3;
1:     int numIterations = 5;
1:     double lambda = 0.065;
1: 
0:     alsFactorization.setConf(conf);
0:     alsFactorization.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda),
0:         "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations) });
1: 
0:     Path inputPath = new Path(inputFile.getAbsolutePath());
0:     FileSystem fs = FileSystem.get(inputPath.toUri(), conf);
1: 
0:     Matrix u = MathHelper.readEntries(fs, conf, new Path(outputDir.getAbsolutePath(), "U/part-r-00000"),
1:         preferences.numRows(), numFeatures);
0:     Matrix m = MathHelper.readEntries(fs, conf, new Path(outputDir.getAbsolutePath(), "M/part-r-00000"),
0:       preferences.numCols(), numFeatures);
1: 
0:     FullRunningAverage avg = new FullRunningAverage();
0:     sliceIterator = preferences.iterateAll();
0:     while (sliceIterator.hasNext()) {
0:       MatrixSlice slice = sliceIterator.next();
0:       Iterator<Vector.Element> elementIterator = slice.vector().iterateNonZero();
0:       while (elementIterator.hasNext()) {
0:         Vector.Element e = elementIterator.next();
1:         if (!Double.isNaN(e.get())) {
1:           double pref = e.get();
0:           double estimate = u.getRow(slice.index()).dot(m.getRow(e.index()));
1:           double err = pref - estimate;
1:           avg.addDatum(err * err);
0:           logger.info("Comparing preference of user [" + slice.index() + "] towards item [" + e.index() + "], " +
0:               "was [" + pref + "] estimate is [" + estimate + "]");
0:         }
0:       }
0:     }
1:     double rmse = Math.sqrt(avg.getAverage());
0:     logger.info("RMSE: " + rmse);
1: 
0:     assertTrue(rmse < 0.2d);
0:   }
1: 
0: }
author:Jacob Alexander Mannix
-------------------------------------------------------------------------------
commit:dc62944
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.Vector.Element;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     for (MatrixSlice slice : preferences) {
1:       for (Element e : slice.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:     for (MatrixSlice slice : preferences) {
1:       for (Element e : slice.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:     for (MatrixSlice slice : preferences) {
1:       for (Element e : slice.nonZeroes()) {
1:           prefsAsText.append(separator)
1:               .append(slice.index()).append(',').append(e.index()).append(',').append(e.get());
author:tcp
-------------------------------------------------------------------------------
commit:44459bd
/////////////////////////////////////////////////////////////////////////
1:           log.info("Comparing preference of user [{}] towards item [{}], was [{}] with confidence [{}] " 
0:                        + "estimate is [{}]", new Object[]{slice.index(), e.index(), pref, confidence, estimate});
author:Ted Dunning
-------------------------------------------------------------------------------
commit:95f836b
/////////////////////////////////////////////////////////////////////////
1:     Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] {
commit:528ffcd
/////////////////////////////////////////////////////////////////////////
1:           double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));
============================================================================