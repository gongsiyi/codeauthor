1:7892be3: /**
1:7892be3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7892be3:  * contributor license agreements.  See the NOTICE file distributed with
1:7892be3:  * this work for additional information regarding copyright ownership.
1:7892be3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7892be3:  * (the "License"); you may not use this file except in compliance with
1:7892be3:  * the License.  You may obtain a copy of the License at
1:7892be3:  *
1:7892be3:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7892be3:  *
1:7892be3:  * Unless required by applicable law or agreed to in writing, software
1:7892be3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7892be3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7892be3:  * See the License for the specific language governing permissions and
1:7892be3:  * limitations under the License.
1:7892be3:  */
10:7892be3: 
1:7892be3: package org.apache.mahout.cf.taste.impl.recommender.svd;
1:7892be3: 
1:85f9ece: import java.util.ArrayList;
1:85f9ece: import java.util.List;
1:85f9ece: import java.util.Random;
1:85f9ece: import java.util.concurrent.ExecutorService;
1:85f9ece: import java.util.concurrent.Executors;
1:85f9ece: import java.util.concurrent.TimeUnit;
1:85f9ece: 
1:7892be3: import org.apache.mahout.cf.taste.common.TasteException;
1:7892be3: import org.apache.mahout.cf.taste.impl.common.FullRunningAverage;
1:7892be3: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1:7892be3: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
1:7892be3: import org.apache.mahout.cf.taste.model.DataModel;
1:7892be3: import org.apache.mahout.cf.taste.model.Preference;
1:7892be3: import org.apache.mahout.cf.taste.model.PreferenceArray;
1:7892be3: import org.apache.mahout.common.RandomUtils;
1:7892be3: import org.apache.mahout.math.DenseVector;
1:74f9303: import org.apache.mahout.math.SequentialAccessSparseVector;
1:7892be3: import org.apache.mahout.math.Vector;
1:3631151: import org.apache.mahout.math.als.AlternatingLeastSquaresSolver;
1:74f9303: import org.apache.mahout.math.als.ImplicitFeedbackAlternatingLeastSquaresSolver;
1:85f9ece: import org.apache.mahout.math.map.OpenIntObjectHashMap;
1:7892be3: import org.slf4j.Logger;
1:7892be3: import org.slf4j.LoggerFactory;
1:74f9303: 
1:7892be3: /**
1:4841efb:  * factorizes the rating matrix using "Alternating-Least-Squares with Weighted-位-Regularization" as described in
1:39fe224:  * <a href="http://www.hpl.hp.com/personal/Robert_Schreiber/papers/2008%20AAIM%20Netflix/netflix_aaim08(submitted).pdf">
1:39fe224:  * "Large-scale Collaborative Filtering for the Netflix Prize"</a>
1:74f9303:  *
1:4841efb:  *  also supports the implicit feedback variant of this approach as described in "Collaborative Filtering for Implicit
1:4841efb:  *  Feedback Datasets" available at http://research.yahoo.com/pub/2433
1:7892be3:  */
1:7892be3: public class ALSWRFactorizer extends AbstractFactorizer {
1:7892be3: 
1:7892be3:   private final DataModel dataModel;
1:7892be3: 
1:7892be3:   /** number of features used to compute this factorization */
1:7892be3:   private final int numFeatures;
1:7892be3:   /** parameter to control the regularization */
1:7892be3:   private final double lambda;
1:7892be3:   /** number of iterations */
1:7892be3:   private final int numIterations;
1:7892be3: 
1:74f9303:   private final boolean usesImplicitFeedback;
1:74f9303:   /** confidence weighting parameter, only necessary when working with implicit feedback */
1:74f9303:   private final double alpha;
1:74f9303: 
1:b293384:   private final int numTrainingThreads;
1:b293384: 
1:74f9303:   private static final double DEFAULT_ALPHA = 40;
1:74f9303: 
1:7892be3:   private static final Logger log = LoggerFactory.getLogger(ALSWRFactorizer.class);
1:7892be3: 
1:74f9303:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations,
1:b293384:       boolean usesImplicitFeedback, double alpha, int numTrainingThreads) throws TasteException {
1:7892be3:     super(dataModel);
1:7892be3:     this.dataModel = dataModel;
1:7892be3:     this.numFeatures = numFeatures;
1:7892be3:     this.lambda = lambda;
1:7892be3:     this.numIterations = numIterations;
1:74f9303:     this.usesImplicitFeedback = usesImplicitFeedback;
1:74f9303:     this.alpha = alpha;
1:b293384:     this.numTrainingThreads = numTrainingThreads;
1:b293384:   }
1:b293384: 
1:b293384:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations,
1:b293384:                          boolean usesImplicitFeedback, double alpha) throws TasteException {
1:b293384:     this(dataModel, numFeatures, lambda, numIterations, usesImplicitFeedback, alpha,
1:b293384:         Runtime.getRuntime().availableProcessors());
1:74f9303:   }
1:74f9303: 
1:74f9303:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations) throws TasteException {
1:74f9303:     this(dataModel, numFeatures, lambda, numIterations, false, DEFAULT_ALPHA);
7:7892be3:   }
1:37d9cca: 
1:37d9cca:   static class Features {
1:37d9cca: 
1:37d9cca:     private final DataModel dataModel;
1:37d9cca:     private final int numFeatures;
1:37d9cca: 
1:b16c260:     private final double[][] M;
1:b16c260:     private final double[][] U;
1:7892be3: 
1:37d9cca:     Features(ALSWRFactorizer factorizer) throws TasteException {
1:3631151:       dataModel = factorizer.dataModel;
1:3631151:       numFeatures = factorizer.numFeatures;
1:37d9cca:       Random random = RandomUtils.getRandom();
1:3631151:       M = new double[dataModel.getNumItems()][numFeatures];
1:3631151:       LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();
1:37d9cca:       while (itemIDsIterator.hasNext()) {
1:37d9cca:         long itemID = itemIDsIterator.nextLong();
1:37d9cca:         int itemIDIndex = factorizer.itemIndex(itemID);
1:37d9cca:         M[itemIDIndex][0] = averateRating(itemID);
1:3631151:         for (int feature = 1; feature < numFeatures; feature++) {
1:37d9cca:           M[itemIDIndex][feature] = random.nextDouble() * 0.1;
1:37d9cca:         }
1:37d9cca:       }
1:3631151:       U = new double[dataModel.getNumUsers()][numFeatures];
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     double[][] getM() {
1:37d9cca:       return M;
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     double[][] getU() {
1:37d9cca:       return U;
1:37d9cca:     }
1:37d9cca: 
1:3631151:     Vector getUserFeatureColumn(int index) {
1:37d9cca:       return new DenseVector(U[index]);
1:37d9cca:     }
1:37d9cca: 
1:3631151:     Vector getItemFeatureColumn(int index) {
1:37d9cca:       return new DenseVector(M[index]);
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     void setFeatureColumnInU(int idIndex, Vector vector) {
1:37d9cca:       setFeatureColumn(U, idIndex, vector);
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     void setFeatureColumnInM(int idIndex, Vector vector) {
1:37d9cca:       setFeatureColumn(M, idIndex, vector);
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     protected void setFeatureColumn(double[][] matrix, int idIndex, Vector vector) {
1:37d9cca:       for (int feature = 0; feature < numFeatures; feature++) {
1:37d9cca:         matrix[idIndex][feature] = vector.get(feature);
1:37d9cca:       }
1:37d9cca:     }
1:37d9cca: 
1:37d9cca:     protected double averateRating(long itemID) throws TasteException {
1:37d9cca:       PreferenceArray prefs = dataModel.getPreferencesForItem(itemID);
1:37d9cca:       RunningAverage avg = new FullRunningAverage();
1:37d9cca:       for (Preference pref : prefs) {
1:37d9cca:         avg.addDatum(pref.getValue());
1:37d9cca:       }
1:37d9cca:       return avg.getAverage();
1:37d9cca:     }
1:37d9cca:   }
1:37d9cca: 
1:7892be3:   @Override
1:7892be3:   public Factorization factorize() throws TasteException {
1:7892be3:     log.info("starting to compute the factorization...");
1:37d9cca:     final Features features = new Features(this);
1:7892be3: 
1:74f9303:     /* feature maps necessary for solving for implicit feedback */
1:74f9303:     OpenIntObjectHashMap<Vector> userY = null;
1:74f9303:     OpenIntObjectHashMap<Vector> itemY = null;
1:74f9303: 
1:74f9303:     if (usesImplicitFeedback) {
1:74f9303:       userY = userFeaturesMapping(dataModel.getUserIDs(), dataModel.getNumUsers(), features.getU());
1:74f9303:       itemY = itemFeaturesMapping(dataModel.getItemIDs(), dataModel.getNumItems(), features.getM());
1:74f9303:     }
1:74f9303: 
1:7892be3:     for (int iteration = 0; iteration < numIterations; iteration++) {
1:7892be3:       log.info("iteration {}", iteration);
1:7892be3: 
1:7892be3:       /* fix M - compute U */
1:37d9cca:       ExecutorService queue = createQueue();
1:7892be3:       LongPrimitiveIterator userIDsIterator = dataModel.getUserIDs();
1:37d9cca:       try {
1:74f9303: 
1:6d16230:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback
1:f6fd0ce:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, itemY, numTrainingThreads)
1:f6fd0ce:             : null;
1:74f9303: 
1:37d9cca:         while (userIDsIterator.hasNext()) {
1:37d9cca:           final long userID = userIDsIterator.nextLong();
1:37d9cca:           final LongPrimitiveIterator itemIDsFromUser = dataModel.getItemIDsFromUser(userID).iterator();
1:37d9cca:           final PreferenceArray userPrefs = dataModel.getPreferencesFromUser(userID);
1:37d9cca:           queue.execute(new Runnable() {
1:37d9cca:             @Override
1:37d9cca:             public void run() {
1:85f9ece:               List<Vector> featureVectors = new ArrayList<>();
1:37d9cca:               while (itemIDsFromUser.hasNext()) {
1:37d9cca:                 long itemID = itemIDsFromUser.nextLong();
1:37d9cca:                 featureVectors.add(features.getItemFeatureColumn(itemIndex(itemID)));
1:37d9cca:               }
1:74f9303: 
1:6d16230:               Vector userFeatures = usesImplicitFeedback
1:6d16230:                   ? implicitFeedbackSolver.solve(sparseUserRatingVector(userPrefs))
1:6d16230:                   : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);
1:74f9303: 
1:37d9cca:               features.setFeatureColumnInU(userIndex(userID), userFeatures);
1:37d9cca:             }
1:37d9cca:           });
1:7892be3:         }
1:37d9cca:       } finally {
1:37d9cca:         queue.shutdown();
1:37d9cca:         try {
1:37d9cca:           queue.awaitTermination(dataModel.getNumUsers(), TimeUnit.SECONDS);
1:37d9cca:         } catch (InterruptedException e) {
1:74f849b:           log.warn("Error when computing user features", e);
1:37d9cca:         }
1:7892be3:       }
1:7892be3: 
1:7892be3:       /* fix U - compute M */
1:37d9cca:       queue = createQueue();
2:7892be3:       LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();
1:37d9cca:       try {
1:74f9303: 
1:6d16230:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback
1:f6fd0ce:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, userY, numTrainingThreads)
1:f6fd0ce:             : null;
1:74f9303: 
1:37d9cca:         while (itemIDsIterator.hasNext()) {
1:37d9cca:           final long itemID = itemIDsIterator.nextLong();
1:37d9cca:           final PreferenceArray itemPrefs = dataModel.getPreferencesForItem(itemID);
1:37d9cca:           queue.execute(new Runnable() {
1:37d9cca:             @Override
1:37d9cca:             public void run() {
1:85f9ece:               List<Vector> featureVectors = new ArrayList<>();
1:37d9cca:               for (Preference pref : itemPrefs) {
1:37d9cca:                 long userID = pref.getUserID();
1:37d9cca:                 featureVectors.add(features.getUserFeatureColumn(userIndex(userID)));
1:37d9cca:               }
1:74f9303: 
1:6d16230:               Vector itemFeatures = usesImplicitFeedback
1:6d16230:                   ? implicitFeedbackSolver.solve(sparseItemRatingVector(itemPrefs))
1:6d16230:                   : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);
1:74f9303: 
1:37d9cca:               features.setFeatureColumnInM(itemIndex(itemID), itemFeatures);
1:37d9cca:             }
1:37d9cca:           });
1:7892be3:         }
1:37d9cca:       } finally {
1:37d9cca:         queue.shutdown();
1:37d9cca:         try {
1:37d9cca:           queue.awaitTermination(dataModel.getNumItems(), TimeUnit.SECONDS);
1:37d9cca:         } catch (InterruptedException e) {
1:74f849b:           log.warn("Error when computing item features", e);
1:37d9cca:         }
1:7892be3:       }
1:7892be3:     }
1:7892be3: 
1:7892be3:     log.info("finished computation of the factorization...");
1:37d9cca:     return createFactorization(features.getU(), features.getM());
1:7892be3:   }
1:7892be3: 
1:74f9303:   protected ExecutorService createQueue() {
1:b293384:     return Executors.newFixedThreadPool(numTrainingThreads);
1:7892be3:   }
1:7892be3: 
1:229aeff:   protected static Vector ratingVector(PreferenceArray prefs) {
1:7892be3:     double[] ratings = new double[prefs.length()];
1:7892be3:     for (int n = 0; n < prefs.length(); n++) {
1:7892be3:       ratings[n] = prefs.get(n).getValue();
1:7892be3:     }
1:74f9303:     return new DenseVector(ratings, true);
1:74f9303:   }
1:74f9303: 
1:74f9303:   //TODO find a way to get rid of the object overhead here
1:74f9303:   protected OpenIntObjectHashMap<Vector> itemFeaturesMapping(LongPrimitiveIterator itemIDs, int numItems,
1:74f9303:       double[][] featureMatrix) {
1:85f9ece:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numItems);
1:74f9303:     while (itemIDs.hasNext()) {
1:74f9303:       long itemID = itemIDs.next();
1:5f070b4:       int itemIndex = itemIndex(itemID);
1:5f070b4:       mapping.put(itemIndex, new DenseVector(featureMatrix[itemIndex(itemID)], true));
1:74f9303:     }
1:74f9303: 
1:74f9303:     return mapping;
1:74f9303:   }
1:74f9303: 
1:74f9303:   protected OpenIntObjectHashMap<Vector> userFeaturesMapping(LongPrimitiveIterator userIDs, int numUsers,
1:74f9303:       double[][] featureMatrix) {
1:85f9ece:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numUsers);
1:74f9303: 
1:74f9303:     while (userIDs.hasNext()) {
1:74f9303:       long userID = userIDs.next();
1:5f070b4:       int userIndex = userIndex(userID);
1:5f070b4:       mapping.put(userIndex, new DenseVector(featureMatrix[userIndex(userID)], true));
1:74f9303:     }
1:74f9303: 
1:74f9303:     return mapping;
1:74f9303:   }
1:74f9303: 
1:74f9303:   protected Vector sparseItemRatingVector(PreferenceArray prefs) {
1:74f9303:     SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());
1:74f9303:     for (Preference preference : prefs) {
1:5f070b4:       ratings.set(userIndex(preference.getUserID()), preference.getValue());
1:74f9303:     }
1:74f9303:     return ratings;
1:74f9303:   }
1:74f9303: 
1:74f9303:   protected Vector sparseUserRatingVector(PreferenceArray prefs) {
1:74f9303:     SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());
1:74f9303:     for (Preference preference : prefs) {
1:5f070b4:       ratings.set(itemIndex(preference.getItemID()), preference.getValue());
1:74f9303:     }
1:74f9303:     return ratings;
1:7892be3:   }
1:7892be3: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Random;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.map.OpenIntObjectHashMap;
/////////////////////////////////////////////////////////////////////////
1:               List<Vector> featureVectors = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:               List<Vector> featureVectors = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numItems);
/////////////////////////////////////////////////////////////////////////
1:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numUsers);
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:5f070b4
/////////////////////////////////////////////////////////////////////////
1:       int itemIndex = itemIndex(itemID);
1:       mapping.put(itemIndex, new DenseVector(featureMatrix[itemIndex(itemID)], true));
/////////////////////////////////////////////////////////////////////////
1:       int userIndex = userIndex(userID);
1:       mapping.put(userIndex, new DenseVector(featureMatrix[userIndex(userID)], true));
/////////////////////////////////////////////////////////////////////////
1:       ratings.set(userIndex(preference.getUserID()), preference.getValue());
/////////////////////////////////////////////////////////////////////////
1:       ratings.set(itemIndex(preference.getItemID()), preference.getValue());
commit:f6fd0ce
/////////////////////////////////////////////////////////////////////////
1:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, itemY, numTrainingThreads)
1:             : null;
/////////////////////////////////////////////////////////////////////////
1:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, userY, numTrainingThreads)
1:             : null;
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback
0:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, itemY) : null;
/////////////////////////////////////////////////////////////////////////
1:               Vector userFeatures = usesImplicitFeedback
1:                   ? implicitFeedbackSolver.solve(sparseUserRatingVector(userPrefs))
1:                   : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);
/////////////////////////////////////////////////////////////////////////
1:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback
0:             ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, userY) : null;
/////////////////////////////////////////////////////////////////////////
1:               Vector itemFeatures = usesImplicitFeedback
1:                   ? implicitFeedbackSolver.solve(sparseItemRatingVector(itemPrefs))
1:                   : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);
commit:4841efb
/////////////////////////////////////////////////////////////////////////
1:  * factorizes the rating matrix using "Alternating-Least-Squares with Weighted-位-Regularization" as described in
1:  *  also supports the implicit feedback variant of this approach as described in "Collaborative Filtering for Implicit
1:  *  Feedback Datasets" available at http://research.yahoo.com/pub/2433
commit:b293384
/////////////////////////////////////////////////////////////////////////
1:   private final int numTrainingThreads;
1: 
1:       boolean usesImplicitFeedback, double alpha, int numTrainingThreads) throws TasteException {
/////////////////////////////////////////////////////////////////////////
1:     this.numTrainingThreads = numTrainingThreads;
1:   }
1: 
1:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations,
1:                          boolean usesImplicitFeedback, double alpha) throws TasteException {
1:     this(dataModel, numFeatures, lambda, numIterations, usesImplicitFeedback, alpha,
1:         Runtime.getRuntime().availableProcessors());
/////////////////////////////////////////////////////////////////////////
1:     return Executors.newFixedThreadPool(numTrainingThreads);
commit:74f9303
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.SequentialAccessSparseVector;
1: import org.apache.mahout.math.als.ImplicitFeedbackAlternatingLeastSquaresSolver;
0: import org.apache.mahout.math.map.OpenIntObjectHashMap;
1: 
/////////////////////////////////////////////////////////////////////////
0:  * factorizes the rating matrix using "Alternating-Least-Squares with Weighted-位-Regularization" as described in the paper
1:  *
0:  *  also supports the implicit feedback variant of this approach as described in "Collaborative Filtering for Implicit Feedback Datasets"
0:  *  available at http://research.yahoo.com/pub/2433
/////////////////////////////////////////////////////////////////////////
1:   private final boolean usesImplicitFeedback;
1:   /** confidence weighting parameter, only necessary when working with implicit feedback */
1:   private final double alpha;
1: 
1:   private static final double DEFAULT_ALPHA = 40;
1: 
1:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations,
0:       boolean usesImplicitFeedback, double alpha) throws TasteException {
1:     this.usesImplicitFeedback = usesImplicitFeedback;
1:     this.alpha = alpha;
1:   }
1: 
1:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations) throws TasteException {
1:     this(dataModel, numFeatures, lambda, numIterations, false, DEFAULT_ALPHA);
/////////////////////////////////////////////////////////////////////////
1:     /* feature maps necessary for solving for implicit feedback */
1:     OpenIntObjectHashMap<Vector> userY = null;
1:     OpenIntObjectHashMap<Vector> itemY = null;
1: 
1:     if (usesImplicitFeedback) {
1:       userY = userFeaturesMapping(dataModel.getUserIDs(), dataModel.getNumUsers(), features.getU());
1:       itemY = itemFeaturesMapping(dataModel.getItemIDs(), dataModel.getNumItems(), features.getM());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback ?
0:             new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, itemY) : null;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:               Vector userFeatures = usesImplicitFeedback ?
0:                   implicitFeedbackSolver.solve(sparseUserRatingVector(userPrefs)) :
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback ?
0:             new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, userY) : null;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:               Vector itemFeatures = usesImplicitFeedback ?
0:                   implicitFeedbackSolver.solve(sparseItemRatingVector(itemPrefs)) :
1: 
/////////////////////////////////////////////////////////////////////////
1:   protected ExecutorService createQueue() {
/////////////////////////////////////////////////////////////////////////
1:     return new DenseVector(ratings, true);
1:   }
1: 
1:   //TODO find a way to get rid of the object overhead here
1:   protected OpenIntObjectHashMap<Vector> itemFeaturesMapping(LongPrimitiveIterator itemIDs, int numItems,
1:       double[][] featureMatrix) {
0:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<Vector>(numItems);
1:     while (itemIDs.hasNext()) {
1:       long itemID = itemIDs.next();
0:       mapping.put((int) itemID, new DenseVector(featureMatrix[itemIndex(itemID)], true));
1:     }
1: 
1:     return mapping;
1:   }
1: 
1:   protected OpenIntObjectHashMap<Vector> userFeaturesMapping(LongPrimitiveIterator userIDs, int numUsers,
1:       double[][] featureMatrix) {
0:     OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<Vector>(numUsers);
1: 
1:     while (userIDs.hasNext()) {
1:       long userID = userIDs.next();
0:       mapping.put((int) userID, new DenseVector(featureMatrix[userIndex(userID)], true));
1:     }
1: 
1:     return mapping;
1:   }
1: 
1:   protected Vector sparseItemRatingVector(PreferenceArray prefs) {
1:     SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());
1:     for (Preference preference : prefs) {
0:       ratings.set((int) preference.getUserID(), preference.getValue());
1:     }
1:     return ratings;
1:   }
1: 
1:   protected Vector sparseUserRatingVector(PreferenceArray prefs) {
1:     SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());
1:     for (Preference preference : prefs) {
0:       ratings.set((int) preference.getItemID(), preference.getValue());
1:     }
1:     return ratings;
commit:3631151
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.als.AlternatingLeastSquaresSolver;
/////////////////////////////////////////////////////////////////////////
1:       dataModel = factorizer.dataModel;
1:       numFeatures = factorizer.numFeatures;
1:       M = new double[dataModel.getNumItems()][numFeatures];
1:       LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();
1:         for (int feature = 1; feature < numFeatures; feature++) {
1:       U = new double[dataModel.getNumUsers()][numFeatures];
/////////////////////////////////////////////////////////////////////////
1:     Vector getUserFeatureColumn(int index) {
1:     Vector getItemFeatureColumn(int index) {
/////////////////////////////////////////////////////////////////////////
0:     final AlternatingLeastSquaresSolver solver = new AlternatingLeastSquaresSolver();
commit:74f849b
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:               List<Vector> featureVectors = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:           log.warn("Error when computing user features", e);
/////////////////////////////////////////////////////////////////////////
0:               List<Vector> featureVectors = Lists.newArrayList();
/////////////////////////////////////////////////////////////////////////
1:           log.warn("Error when computing item features", e);
commit:37d9cca
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:   static class Features {
1: 
1:     private final DataModel dataModel;
1:     private final int numFeatures;
1: 
0:     private double[][] M;
0:     private double[][] U;
1: 
1:     Features(ALSWRFactorizer factorizer) throws TasteException {
0:       this.dataModel = factorizer.dataModel;
0:       this.numFeatures = factorizer.numFeatures;
1:       Random random = RandomUtils.getRandom();
0:       M = new double[this.dataModel.getNumItems()][this.numFeatures];
0:       LongPrimitiveIterator itemIDsIterator = this.dataModel.getItemIDs();
1:       while (itemIDsIterator.hasNext()) {
1:         long itemID = itemIDsIterator.nextLong();
1:         int itemIDIndex = factorizer.itemIndex(itemID);
1:         M[itemIDIndex][0] = averateRating(itemID);
0:         for (int feature = 1; feature < this.numFeatures; feature++) {
1:           M[itemIDIndex][feature] = random.nextDouble() * 0.1;
1:         }
1:       }
0:       U = new double[this.dataModel.getNumUsers()][this.numFeatures];
1:     }
1: 
1:     double[][] getM() {
1:       return M;
1:     }
1: 
1:     double[][] getU() {
1:       return U;
1:     }
1: 
0:     DenseVector getUserFeatureColumn(int index) {
1:       return new DenseVector(U[index]);
1:     }
1: 
0:     DenseVector getItemFeatureColumn(int index) {
1:       return new DenseVector(M[index]);
1:     }
1: 
1:     void setFeatureColumnInU(int idIndex, Vector vector) {
1:       setFeatureColumn(U, idIndex, vector);
1:     }
1: 
1:     void setFeatureColumnInM(int idIndex, Vector vector) {
1:       setFeatureColumn(M, idIndex, vector);
1:     }
1: 
1:     protected void setFeatureColumn(double[][] matrix, int idIndex, Vector vector) {
1:       for (int feature = 0; feature < numFeatures; feature++) {
1:         matrix[idIndex][feature] = vector.get(feature);
1:       }
1:     }
1: 
1:     protected double averateRating(long itemID) throws TasteException {
1:       PreferenceArray prefs = dataModel.getPreferencesForItem(itemID);
1:       RunningAverage avg = new FullRunningAverage();
1:       for (Preference pref : prefs) {
1:         avg.addDatum(pref.getValue());
1:       }
1:       return avg.getAverage();
1:     }
1:   }
1: 
0:     final AlternateLeastSquaresSolver solver = new AlternateLeastSquaresSolver();
1:     final Features features = new Features(this);
1:       ExecutorService queue = createQueue();
1:       try {
1:         while (userIDsIterator.hasNext()) {
1:           final long userID = userIDsIterator.nextLong();
1:           final LongPrimitiveIterator itemIDsFromUser = dataModel.getItemIDsFromUser(userID).iterator();
1:           final PreferenceArray userPrefs = dataModel.getPreferencesFromUser(userID);
1:           queue.execute(new Runnable() {
1:             @Override
1:             public void run() {
0:               List<Vector> featureVectors = new ArrayList<Vector>();
1:               while (itemIDsFromUser.hasNext()) {
1:                 long itemID = itemIDsFromUser.nextLong();
1:                 featureVectors.add(features.getItemFeatureColumn(itemIndex(itemID)));
1:               }
0:               Vector userFeatures = solver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);
1:               features.setFeatureColumnInU(userIndex(userID), userFeatures);
1:             }
1:           });
1:       } finally {
1:         queue.shutdown();
1:         try {
1:           queue.awaitTermination(dataModel.getNumUsers(), TimeUnit.SECONDS);
1:         } catch (InterruptedException e) {
0:           throw new IllegalStateException("Error when computing user features", e);
1:         }
1:       queue = createQueue();
1:       try {
1:         while (itemIDsIterator.hasNext()) {
1:           final long itemID = itemIDsIterator.nextLong();
1:           final PreferenceArray itemPrefs = dataModel.getPreferencesForItem(itemID);
1:           queue.execute(new Runnable() {
1:             @Override
1:             public void run() {
0:               List<Vector> featureVectors = new ArrayList<Vector>();
1:               for (Preference pref : itemPrefs) {
1:                 long userID = pref.getUserID();
1:                 featureVectors.add(features.getUserFeatureColumn(userIndex(userID)));
1:               }
0:               Vector itemFeatures = solver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);
1:               features.setFeatureColumnInM(itemIndex(itemID), itemFeatures);
1:             }
1:           });
1:       } finally {
1:         queue.shutdown();
1:         try {
1:           queue.awaitTermination(dataModel.getNumItems(), TimeUnit.SECONDS);
1:         } catch (InterruptedException e) {
0:           throw new IllegalStateException("Error when computing item features", e);
1:         }
1:     return createFactorization(features.getU(), features.getM());
0:   protected ExecutorService createQueue() {
0:     return Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
/////////////////////////////////////////////////////////////////////////
commit:7892be3
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.impl.recommender.svd;
1: 
1: import org.apache.mahout.cf.taste.common.TasteException;
1: import org.apache.mahout.cf.taste.impl.common.FullRunningAverage;
1: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
1: import org.apache.mahout.cf.taste.model.DataModel;
1: import org.apache.mahout.cf.taste.model.Preference;
1: import org.apache.mahout.cf.taste.model.PreferenceArray;
1: import org.apache.mahout.common.RandomUtils;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Vector;
0: import org.apache.mahout.math.als.AlternateLeastSquaresSolver;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.Random;
1: 
1: /**
0:  * factorizes the rating matrix using "Alternating-Least-Squares with Weighted-位-Regularization" as described in
0:  * the paper "Large-scale Collaborative Filtering for the Netflix Prize" available at
0:  * {@see http://www.hpl.hp.com/personal/Robert_Schreiber/papers/2008%20AAIM%20Netflix/netflix_aaim08(submitted).pdf}
1:  */
1: public class ALSWRFactorizer extends AbstractFactorizer {
1: 
1:   private final DataModel dataModel;
1: 
1:   /** number of features used to compute this factorization */
1:   private final int numFeatures;
1:   /** parameter to control the regularization */
1:   private final double lambda;
1:   /** number of iterations */
1:   private final int numIterations;
1: 
1:   private static final Logger log = LoggerFactory.getLogger(ALSWRFactorizer.class);
1: 
0:   public ALSWRFactorizer(DataModel dataModel, int numFeatures, double lambda, int numIterations) throws TasteException {
1:     super(dataModel);
1:     this.dataModel = dataModel;
1:     this.numFeatures = numFeatures;
1:     this.lambda = lambda;
1:     this.numIterations = numIterations;
1:   }
1: 
1:   @Override
1:   public Factorization factorize() throws TasteException {
1:     log.info("starting to compute the factorization...");
0:     AlternateLeastSquaresSolver solver = new AlternateLeastSquaresSolver();
1: 
0:     double[][] M = initializeM();
0:     double[][] U = null;
1: 
1:     for (int iteration = 0; iteration < numIterations; iteration++) {
1:       log.info("iteration {}", iteration);
1: 
1:       /* fix M - compute U */
0:       U = new double[dataModel.getNumUsers()][numFeatures];
1: 
1:       LongPrimitiveIterator userIDsIterator = dataModel.getUserIDs();
0:       while (userIDsIterator.hasNext()) {
0:         long userID = userIDsIterator.nextLong();
0:         List<Vector> featureVectors = new ArrayList<Vector>();
0:         LongPrimitiveIterator itemIDsFromUser = dataModel.getItemIDsFromUser(userID).iterator();
0:         while (itemIDsFromUser.hasNext()) {
0:           long itemID = itemIDsFromUser.nextLong();
0:           featureVectors.add(new DenseVector(M[itemIndex(itemID)]));
1:         }
0:         PreferenceArray userPrefs = dataModel.getPreferencesFromUser(userID);
0:         Vector userFeatures = solver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);
0:         setFeatureColumn(U, userIndex(userID), userFeatures);
1:       }
1: 
1:       /* fix U - compute M */
0:       M = new double[dataModel.getNumItems()][numFeatures];
1: 
1:       LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();
0:       while (itemIDsIterator.hasNext()) {
0:         long itemID = itemIDsIterator.nextLong();
0:         List<Vector> featureVectors = new ArrayList<Vector>();
0:         for (Preference pref : dataModel.getPreferencesForItem(itemID)) {
0:           long userID = pref.getUserID();
0:           featureVectors.add(new DenseVector(U[userIndex(userID)]));
1:         }
0:         PreferenceArray itemPrefs = dataModel.getPreferencesForItem(itemID);
0:         Vector itemFeatures = solver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);
0:         setFeatureColumn(M, itemIndex(itemID), itemFeatures);
1:       }
1:     }
1: 
1:     log.info("finished computation of the factorization...");
0:     return createFactorization(U, M);
1:   }
1: 
0:   protected double[][] initializeM() throws TasteException {
0:     Random random = RandomUtils.getRandom();
0:     double[][] M = new double[dataModel.getNumItems()][numFeatures];
1: 
1:     LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();
0:     while (itemIDsIterator.hasNext()) {
0:       long itemID = itemIDsIterator.nextLong();
0:       int itemIDIndex = itemIndex(itemID);
0:       M[itemIDIndex][0] = averateRating(itemID);
0:       for (int feature = 1; feature < numFeatures; feature++) {
0:         M[itemIDIndex][feature] = random.nextDouble() * 0.1;
1:       }
1:     }
0:     return M;
1:   }
1: 
0:   protected void setFeatureColumn(double[][] matrix, int idIndex, Vector vector) {
0:     for (int feature = 0; feature < numFeatures; feature++) {
0:       matrix[idIndex][feature] = vector.get(feature);
1:     }
1:   }
1: 
0:   protected Vector ratingVector(PreferenceArray prefs) {
1:     double[] ratings = new double[prefs.length()];
1:     for (int n = 0; n < prefs.length(); n++) {
1:       ratings[n] = prefs.get(n).getValue();
1:     }
0:     return new DenseVector(ratings);
1:   }
1: 
0:   protected double averateRating(long itemID) throws TasteException {
0:     PreferenceArray prefs = dataModel.getPreferencesForItem(itemID);
0:     RunningAverage avg = new FullRunningAverage();
0:     for (Preference pref : prefs) {
0:       avg.addDatum(pref.getValue());
1:     }
0:     return avg.getAverage();
1:   }
1: 
1: }
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:               Vector userFeatures =
0:                   AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);
/////////////////////////////////////////////////////////////////////////
0:               Vector itemFeatures =
0:                   AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);
/////////////////////////////////////////////////////////////////////////
0:   protected static ExecutorService createQueue() {
1:   protected static Vector ratingVector(PreferenceArray prefs) {
commit:39fe224
/////////////////////////////////////////////////////////////////////////
0:  * the paper
1:  * <a href="http://www.hpl.hp.com/personal/Robert_Schreiber/papers/2008%20AAIM%20Netflix/netflix_aaim08(submitted).pdf">
1:  * "Large-scale Collaborative Filtering for the Netflix Prize"</a>
commit:b16c260
/////////////////////////////////////////////////////////////////////////
1:     private final double[][] M;
1:     private final double[][] U;
============================================================================