1:9c7a9e7: /*
1:9c7a9e7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9c7a9e7:  * contributor license agreements.  See the NOTICE file distributed with
1:9c7a9e7:  * this work for additional information regarding copyright ownership.
1:9c7a9e7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9c7a9e7:  * (the "License"); you may not use this file except in compliance with
1:9c7a9e7:  * the License.  You may obtain a copy of the License at
1:9c7a9e7:  *
1:9c7a9e7:  *     http://www.apache.org/licenses/LICENSE-2.0
1:9c7a9e7:  *
1:9c7a9e7:  * Unless required by applicable law or agreed to in writing, software
1:9c7a9e7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9c7a9e7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9c7a9e7:  * See the License for the specific language governing permissions and
1:9c7a9e7:  * limitations under the License.
4:9c7a9e7:  */
7:9c7a9e7: 
4:9c7a9e7: /**
1:9c7a9e7:  * Adapted from the public domain Jama code.
1:9c7a9e7:  */
1:9c7a9e7: 
1:9c7a9e7: package org.apache.mahout.math.solver;
1:9c7a9e7: 
1:9c7a9e7: import org.apache.mahout.math.DenseMatrix;
1:9c7a9e7: import org.apache.mahout.math.DenseVector;
1:9c7a9e7: import org.apache.mahout.math.Matrix;
1:9c7a9e7: import org.apache.mahout.math.Vector;
1:9c7a9e7: import org.apache.mahout.math.function.Functions;
1:9c7a9e7: 
1:9c7a9e7: /**
1:9c7a9e7:  * Eigenvalues and eigenvectors of a real matrix.
1:9c7a9e7:  * <p/>
1:9c7a9e7:  * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector
1:9c7a9e7:  * matrix V is orthogonal. I.e. A = V.times(D.times(V.transpose())) and V.times(V.transpose())
1:9c7a9e7:  * equals the identity matrix.
1:9c7a9e7:  * <p/>
1:9c7a9e7:  * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues
1:9c7a9e7:  * in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu,
1:9c7a9e7:  * lambda].  The columns of V represent the eigenvectors in the sense that A*V = V*D, i.e.
1:9c7a9e7:  * A.times(V) equals V.times(D).  The matrix V may be badly conditioned, or even singular, so the
1:9c7a9e7:  * validity of the equation A = V*D*inverse(V) depends upon V.cond().
1:9c7a9e7:  */
1:9c7a9e7: public class EigenDecomposition {
1:9c7a9e7: 
1:229aeff:   /** Row and column dimension (square matrix). */
1:229aeff:   private final int n;
1:229aeff:   /** Arrays for internal storage of eigenvalues. */
1:229aeff:   private final Vector d;
1:229aeff:   private final Vector e;
1:229aeff:   /** Array for internal storage of eigenvectors. */
1:229aeff:   private final Matrix v;
1:9c7a9e7: 
1:9c7a9e7:   public EigenDecomposition(Matrix x) {
1:9c7a9e7:     this(x, isSymmetric(x));
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   public EigenDecomposition(Matrix x, boolean isSymmetric) {
1:9c7a9e7:     n = x.columnSize();
1:9c7a9e7:     d = new DenseVector(n);
1:9c7a9e7:     e = new DenseVector(n);
1:9c7a9e7:     v = new DenseMatrix(n, n);
1:9c7a9e7: 
1:9c7a9e7:     if (isSymmetric) {
1:9c7a9e7:       v.assign(x);
1:9c7a9e7: 
1:9c7a9e7:       // Tridiagonalize.
1:9c7a9e7:       tred2();
1:9c7a9e7: 
1:9c7a9e7:       // Diagonalize.
1:9c7a9e7:       tql2();
1:9c7a9e7: 
2:9c7a9e7:     } else {
1:9c7a9e7:       // Reduce to Hessenberg form.
1:9c7a9e7:       // Reduce Hessenberg to real Schur form.
1:9c7a9e7:       hqr2(orthes(x));
1:9c7a9e7:     }
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   /**
1:9c7a9e7:    * Return the eigenvector matrix
1:9c7a9e7:    *
1:9c7a9e7:    * @return V
1:9c7a9e7:    */
1:9c7a9e7:   public Matrix getV() {
1:9c7a9e7:     return v.like().assign(v);
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   /**
1:9c7a9e7:    * Return the real parts of the eigenvalues
1:9c7a9e7:    */
1:9c7a9e7:   public Vector getRealEigenvalues() {
1:9c7a9e7:     return d;
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   /**
1:9c7a9e7:    * Return the imaginary parts of the eigenvalues
1:9c7a9e7:    */
1:9c7a9e7:   public Vector getImagEigenvalues() {
1:9c7a9e7:     return e;
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   /**
1:9c7a9e7:    * Return the block diagonal eigenvalue matrix
1:9c7a9e7:    *
1:9c7a9e7:    * @return D
1:9c7a9e7:    */
1:9c7a9e7:   public Matrix getD() {
1:f514c82:     Matrix x = new DenseMatrix(n, n);
1:f514c82:     x.assign(0);
1:f514c82:     x.viewDiagonal().assign(d);
1:9c7a9e7:     for (int i = 0; i < n; i++) {
1:229aeff:       double v = e.getQuick(i);
1:9c7a9e7:       if (v > 0) {
1:f514c82:         x.setQuick(i, i + 1, v);
1:9c7a9e7:       } else if (v < 0) {
1:f514c82:         x.setQuick(i, i - 1, v);
1:9c7a9e7:       }
1:9c7a9e7:     }
1:f514c82:     return x;
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   // Symmetric Householder reduction to tridiagonal form.
1:9c7a9e7:   private void tred2() {
1:9c7a9e7:     //  This is derived from the Algol procedures tred2 by
1:9c7a9e7:     //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
1:9c7a9e7:     //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
1:9c7a9e7:     //  Fortran subroutine in EISPACK.
1:9c7a9e7: 
1:9c7a9e7:     d.assign(v.viewColumn(n - 1));
1:9c7a9e7: 
1:9c7a9e7:     // Householder reduction to tridiagonal form.
1:9c7a9e7: 
1:9c7a9e7:     for (int i = n - 1; i > 0; i--) {
1:9c7a9e7: 
1:9c7a9e7:       // Scale to avoid under/overflow.
1:9c7a9e7: 
1:2fd2aed:       double scale = d.viewPart(0, i).norm(1);
1:9c7a9e7:       double h = 0.0;
1:9c7a9e7: 
1:9c7a9e7: 
1:9c7a9e7:       if (scale == 0.0) {
1:9c7a9e7:         e.setQuick(i, d.getQuick(i - 1));
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           d.setQuick(j, v.getQuick(i - 1, j));
1:9c7a9e7:           v.setQuick(i, j, 0.0);
1:9c7a9e7:           v.setQuick(j, i, 0.0);
1:9c7a9e7:         }
1:9c7a9e7:       } else {
1:9c7a9e7: 
1:9c7a9e7:         // Generate Householder vector.
1:9c7a9e7: 
1:9c7a9e7:         for (int k = 0; k < i; k++) {
1:9c7a9e7:           d.setQuick(k, d.getQuick(k) / scale);
1:9c7a9e7:           h += d.getQuick(k) * d.getQuick(k);
1:9c7a9e7:         }
1:9c7a9e7:         double f = d.getQuick(i - 1);
1:9c7a9e7:         double g = Math.sqrt(h);
1:9c7a9e7:         if (f > 0) {
1:9c7a9e7:           g = -g;
1:9c7a9e7:         }
1:9c7a9e7:         e.setQuick(i, scale * g);
1:229aeff:         h -= f * g;
1:9c7a9e7:         d.setQuick(i - 1, f - g);
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           e.setQuick(j, 0.0);
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         // Apply similarity transformation to remaining columns.
1:9c7a9e7: 
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           f = d.getQuick(j);
1:9c7a9e7:           v.setQuick(j, i, f);
1:9c7a9e7:           g = e.getQuick(j) + v.getQuick(j, j) * f;
1:9c7a9e7:           for (int k = j + 1; k <= i - 1; k++) {
1:9c7a9e7:             g += v.getQuick(k, j) * d.getQuick(k);
1:9c7a9e7:             e.setQuick(k, e.getQuick(k) + v.getQuick(k, j) * f);
1:9c7a9e7:           }
1:9c7a9e7:           e.setQuick(j, g);
1:9c7a9e7:         }
1:9c7a9e7:         f = 0.0;
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           e.setQuick(j, e.getQuick(j) / h);
1:9c7a9e7:           f += e.getQuick(j) * d.getQuick(j);
1:9c7a9e7:         }
1:9c7a9e7:         double hh = f / (h + h);
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           e.setQuick(j, e.getQuick(j) - hh * d.getQuick(j));
1:9c7a9e7:         }
1:9c7a9e7:         for (int j = 0; j < i; j++) {
1:9c7a9e7:           f = d.getQuick(j);
1:9c7a9e7:           g = e.getQuick(j);
1:9c7a9e7:           for (int k = j; k <= i - 1; k++) {
1:9c7a9e7:             v.setQuick(k, j, v.getQuick(k, j) - (f * e.getQuick(k) + g * d.getQuick(k)));
1:9c7a9e7:           }
1:9c7a9e7:           d.setQuick(j, v.getQuick(i - 1, j));
1:9c7a9e7:           v.setQuick(i, j, 0.0);
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:       d.setQuick(i, h);
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     // Accumulate transformations.
1:9c7a9e7: 
1:9c7a9e7:     for (int i = 0; i < n - 1; i++) {
1:9c7a9e7:       v.setQuick(n - 1, i, v.getQuick(i, i));
1:9c7a9e7:       v.setQuick(i, i, 1.0);
1:9c7a9e7:       double h = d.getQuick(i + 1);
1:9c7a9e7:       if (h != 0.0) {
1:9c7a9e7:         for (int k = 0; k <= i; k++) {
1:9c7a9e7:           d.setQuick(k, v.getQuick(k, i + 1) / h);
1:9c7a9e7:         }
1:9c7a9e7:         for (int j = 0; j <= i; j++) {
1:9c7a9e7:           double g = 0.0;
1:9c7a9e7:           for (int k = 0; k <= i; k++) {
1:9c7a9e7:             g += v.getQuick(k, i + 1) * v.getQuick(k, j);
1:9c7a9e7:           }
1:9c7a9e7:           for (int k = 0; k <= i; k++) {
1:9c7a9e7:             v.setQuick(k, j, v.getQuick(k, j) - g * d.getQuick(k));
1:9c7a9e7:           }
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:       for (int k = 0; k <= i; k++) {
1:9c7a9e7:         v.setQuick(k, i + 1, 0.0);
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7:     d.assign(v.viewRow(n - 1));
1:9c7a9e7:     v.viewRow(n - 1).assign(0);
1:9c7a9e7:     v.setQuick(n - 1, n - 1, 1.0);
1:9c7a9e7:     e.setQuick(0, 0.0);
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   // Symmetric tridiagonal QL algorithm.
1:9c7a9e7:   private void tql2() {
1:9c7a9e7: 
1:9c7a9e7:     //  This is derived from the Algol procedures tql2, by
1:9c7a9e7:     //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
1:9c7a9e7:     //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
1:9c7a9e7:     //  Fortran subroutine in EISPACK.
1:9c7a9e7: 
1:9c7a9e7:     e.viewPart(0, n - 1).assign(e.viewPart(1, n - 1));
1:9c7a9e7:     e.setQuick(n - 1, 0.0);
1:9c7a9e7: 
1:9c7a9e7:     double f = 0.0;
1:9c7a9e7:     double tst1 = 0.0;
1:9c7a9e7:     double eps = Math.pow(2.0, -52.0);
1:9c7a9e7:     for (int l = 0; l < n; l++) {
1:9c7a9e7: 
1:9c7a9e7:       // Find small subdiagonal element
1:9c7a9e7: 
1:9c7a9e7:       tst1 = Math.max(tst1, Math.abs(d.getQuick(l)) + Math.abs(e.getQuick(l)));
1:9c7a9e7:       int m = l;
1:9c7a9e7:       while (m < n) {
1:9c7a9e7:         if (Math.abs(e.getQuick(m)) <= eps * tst1) {
1:9c7a9e7:           break;
1:9c7a9e7:         }
1:9c7a9e7:         m++;
1:9c7a9e7:       }
1:9c7a9e7: 
1:9c7a9e7:       // If m == l, d.getQuick(l) is an eigenvalue,
1:9c7a9e7:       // otherwise, iterate.
1:9c7a9e7: 
1:9c7a9e7:       if (m > l) {
1:9c7a9e7:         do {
1:9c7a9e7:           // Compute implicit shift
1:9c7a9e7: 
1:9c7a9e7:           double g = d.getQuick(l);
1:9c7a9e7:           double p = (d.getQuick(l + 1) - g) / (2.0 * e.getQuick(l));
1:9c7a9e7:           double r = Math.hypot(p, 1.0);
1:9c7a9e7:           if (p < 0) {
1:9c7a9e7:             r = -r;
1:9c7a9e7:           }
1:9c7a9e7:           d.setQuick(l, e.getQuick(l) / (p + r));
1:9c7a9e7:           d.setQuick(l + 1, e.getQuick(l) * (p + r));
1:9c7a9e7:           double dl1 = d.getQuick(l + 1);
1:9c7a9e7:           double h = g - d.getQuick(l);
1:9c7a9e7:           for (int i = l + 2; i < n; i++) {
1:9c7a9e7:             d.setQuick(i, d.getQuick(i) - h);
1:9c7a9e7:           }
1:229aeff:           f += h;
1:9c7a9e7: 
1:9c7a9e7:           // Implicit QL transformation.
1:9c7a9e7: 
1:9c7a9e7:           p = d.getQuick(m);
1:9c7a9e7:           double c = 1.0;
1:9c7a9e7:           double c2 = c;
1:9c7a9e7:           double c3 = c;
1:9c7a9e7:           double el1 = e.getQuick(l + 1);
1:9c7a9e7:           double s = 0.0;
1:9c7a9e7:           double s2 = 0.0;
1:9c7a9e7:           for (int i = m - 1; i >= l; i--) {
1:9c7a9e7:             c3 = c2;
1:9c7a9e7:             c2 = c;
1:9c7a9e7:             s2 = s;
1:9c7a9e7:             g = c * e.getQuick(i);
1:9c7a9e7:             h = c * p;
1:9c7a9e7:             r = Math.hypot(p, e.getQuick(i));
1:9c7a9e7:             e.setQuick(i + 1, s * r);
1:9c7a9e7:             s = e.getQuick(i) / r;
1:9c7a9e7:             c = p / r;
1:9c7a9e7:             p = c * d.getQuick(i) - s * g;
1:9c7a9e7:             d.setQuick(i + 1, h + s * (c * g + s * d.getQuick(i)));
1:9c7a9e7: 
1:9c7a9e7:             // Accumulate transformation.
1:9c7a9e7: 
1:9c7a9e7:             for (int k = 0; k < n; k++) {
1:9c7a9e7:               h = v.getQuick(k, i + 1);
1:9c7a9e7:               v.setQuick(k, i + 1, s * v.getQuick(k, i) + c * h);
1:9c7a9e7:               v.setQuick(k, i, c * v.getQuick(k, i) - s * h);
1:9c7a9e7:             }
1:9c7a9e7:           }
1:9c7a9e7:           p = -s * s2 * c3 * el1 * e.getQuick(l) / dl1;
1:9c7a9e7:           e.setQuick(l, s * p);
1:9c7a9e7:           d.setQuick(l, c * p);
1:9c7a9e7: 
1:9c7a9e7:           // Check for convergence.
1:9c7a9e7: 
1:9c7a9e7:         } while (Math.abs(e.getQuick(l)) > eps * tst1);
1:9c7a9e7:       }
1:9c7a9e7:       d.setQuick(l, d.getQuick(l) + f);
1:9c7a9e7:       e.setQuick(l, 0.0);
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     // Sort eigenvalues and corresponding vectors.
1:9c7a9e7: 
1:9c7a9e7:     for (int i = 0; i < n - 1; i++) {
1:9c7a9e7:       int k = i;
1:9c7a9e7:       double p = d.getQuick(i);
1:9c7a9e7:       for (int j = i + 1; j < n; j++) {
1:bc8eafd:         if (d.getQuick(j) > p) {
1:9c7a9e7:           k = j;
1:9c7a9e7:           p = d.getQuick(j);
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:       if (k != i) {
1:9c7a9e7:         d.setQuick(k, d.getQuick(i));
1:9c7a9e7:         d.setQuick(i, p);
1:9c7a9e7:         for (int j = 0; j < n; j++) {
1:9c7a9e7:           p = v.getQuick(j, i);
1:9c7a9e7:           v.setQuick(j, i, v.getQuick(j, k));
1:9c7a9e7:           v.setQuick(j, k, p);
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   // Nonsymmetric reduction to Hessenberg form.
1:9c7a9e7:   private Matrix orthes(Matrix x) {
1:9c7a9e7:     // Working storage for nonsymmetric algorithm.
1:9c7a9e7:     Vector ort = new DenseVector(n);
1:f514c82:     Matrix hessenBerg = new DenseMatrix(n, n).assign(x);
1:9c7a9e7: 
1:9c7a9e7:     //  This is derived from the Algol procedures orthes and ortran,
1:9c7a9e7:     //  by Martin and Wilkinson, Handbook for Auto. Comp.,
1:9c7a9e7:     //  Vol.ii-Linear Algebra, and the corresponding
1:9c7a9e7:     //  Fortran subroutines in EISPACK.
1:9c7a9e7: 
1:9c7a9e7:     int low = 0;
1:9c7a9e7:     int high = n - 1;
1:9c7a9e7: 
1:9c7a9e7:     for (int m = low + 1; m <= high - 1; m++) {
1:9c7a9e7: 
1:9c7a9e7:       // Scale column.
1:9c7a9e7: 
1:229aeff:       Vector hColumn = hessenBerg.viewColumn(m - 1).viewPart(m, high - m + 1);
1:f514c82:       double scale = hColumn.norm(1);
1:9c7a9e7: 
1:9c7a9e7:       if (scale != 0.0) {
1:9c7a9e7:         // Compute Householder transformation.
1:9c7a9e7: 
1:f514c82:         ort.viewPart(m, high - m + 1).assign(hColumn, Functions.plusMult(1 / scale));
1:9c7a9e7:         double h = ort.viewPart(m, high - m + 1).getLengthSquared();
1:9c7a9e7: 
1:9c7a9e7:         double g = Math.sqrt(h);
1:9c7a9e7:         if (ort.getQuick(m) > 0) {
1:9c7a9e7:           g = -g;
1:9c7a9e7:         }
1:229aeff:         h -= ort.getQuick(m) * g;
1:9c7a9e7:         ort.setQuick(m, ort.getQuick(m) - g);
1:9c7a9e7: 
1:9c7a9e7:         // Apply Householder similarity transformation
1:9c7a9e7:         // H = (I-u*u'/h)*H*(I-u*u')/h)
1:9c7a9e7: 
1:9c7a9e7:         Vector ortPiece = ort.viewPart(m, high - m + 1);
1:9c7a9e7:         for (int j = m; j < n; j++) {
1:f514c82:           double f = ortPiece.dot(hessenBerg.viewColumn(j).viewPart(m, high - m + 1)) / h;
1:f514c82:           hessenBerg.viewColumn(j).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         for (int i = 0; i <= high; i++) {
1:f514c82:           double f = ortPiece.dot(hessenBerg.viewRow(i).viewPart(m, high - m + 1)) / h;
1:f514c82:           hessenBerg.viewRow(i).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:9c7a9e7:         }
1:9c7a9e7:         ort.setQuick(m, scale * ort.getQuick(m));
1:f514c82:         hessenBerg.setQuick(m, m - 1, scale * g);
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     // Accumulate transformations (Algol's ortran).
1:9c7a9e7: 
1:9c7a9e7:     v.assign(0);
1:9c7a9e7:     v.viewDiagonal().assign(1);
1:9c7a9e7: 
1:9c7a9e7:     for (int m = high - 1; m >= low + 1; m--) {
1:f514c82:       if (hessenBerg.getQuick(m, m - 1) != 0.0) {
1:f514c82:         ort.viewPart(m + 1, high - m).assign(hessenBerg.viewColumn(m - 1).viewPart(m + 1, high - m));
1:9c7a9e7:         for (int j = m; j <= high; j++) {
1:9c7a9e7:           double g = ort.viewPart(m, high - m + 1).dot(v.viewColumn(j).viewPart(m, high - m + 1));
1:9c7a9e7:           // Double division avoids possible underflow
1:229aeff:           g = g / ort.getQuick(m) / hessenBerg.getQuick(m, m - 1);
1:9c7a9e7:           v.viewColumn(j).viewPart(m, high - m + 1).assign(ort.viewPart(m, high - m + 1), Functions.plusMult(g));
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:     }
1:f514c82:     return hessenBerg;
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7: 
1:9c7a9e7:   // Complex scalar division.
1:229aeff:   private double cdivr;
1:229aeff:   private double cdivi;
1:9c7a9e7: 
1:9c7a9e7:   private void cdiv(double xr, double xi, double yr, double yi) {
1:f514c82:     double r;
1:f514c82:     double d;
1:9c7a9e7:     if (Math.abs(yr) > Math.abs(yi)) {
1:9c7a9e7:       r = yi / yr;
1:9c7a9e7:       d = yr + r * yi;
1:9c7a9e7:       cdivr = (xr + r * xi) / d;
1:9c7a9e7:       cdivi = (xi - r * xr) / d;
1:9c7a9e7:     } else {
1:9c7a9e7:       r = yr / yi;
1:9c7a9e7:       d = yi + r * yr;
1:9c7a9e7:       cdivr = (r * xr + xi) / d;
1:9c7a9e7:       cdivi = (r * xi - xr) / d;
1:9c7a9e7:     }
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7: 
1:9c7a9e7:   // Nonsymmetric reduction from Hessenberg to real Schur form.
1:9c7a9e7: 
1:9c7a9e7:   private void hqr2(Matrix h) {
1:9c7a9e7: 
1:9c7a9e7:     //  This is derived from the Algol procedure hqr2,
1:9c7a9e7:     //  by Martin and Wilkinson, Handbook for Auto. Comp.,
1:9c7a9e7:     //  Vol.ii-Linear Algebra, and the corresponding
1:9c7a9e7:     //  Fortran subroutine in EISPACK.
1:9c7a9e7: 
1:9c7a9e7:     // Initialize
1:9c7a9e7: 
1:229aeff:     int nn = this.n;
1:9c7a9e7:     int n = nn - 1;
1:229aeff:     int low = 0;
1:229aeff:     int high = nn - 1;
1:9c7a9e7:     double eps = Math.pow(2.0, -52.0);
1:9c7a9e7:     double exshift = 0.0;
1:229aeff:     double p = 0;
1:229aeff:     double q = 0;
1:229aeff:     double r = 0;
1:229aeff:     double s = 0;
1:229aeff:     double z = 0;
1:229aeff:     double w;
1:229aeff:     double x;
1:229aeff:     double y;
1:9c7a9e7: 
1:9c7a9e7:     // Store roots isolated by balanc and compute matrix norm
1:9c7a9e7: 
1:9c7a9e7:     double norm = h.aggregate(Functions.PLUS, Functions.ABS);
1:9c7a9e7: 
1:9c7a9e7:     // Outer loop over eigenvalue index
1:9c7a9e7: 
2:9c7a9e7:     int iter = 0;
1:9c7a9e7:     while (n >= low) {
1:9c7a9e7: 
1:9c7a9e7:       // Look for single small sub-diagonal element
1:9c7a9e7: 
1:9c7a9e7:       int l = n;
1:9c7a9e7:       while (l > low) {
1:9c7a9e7:         s = Math.abs(h.getQuick(l - 1, l - 1)) + Math.abs(h.getQuick(l, l));
1:9c7a9e7:         if (s == 0.0) {
1:9c7a9e7:           s = norm;
1:9c7a9e7:         }
1:9c7a9e7:         if (Math.abs(h.getQuick(l, l - 1)) < eps * s) {
1:9c7a9e7:           break;
1:9c7a9e7:         }
1:9c7a9e7:         l--;
1:9c7a9e7:       }
1:9c7a9e7: 
1:9c7a9e7:       // Check for convergence
1:9c7a9e7: 
1:9c7a9e7:       if (l == n) {
1:9c7a9e7:         // One root found
1:9c7a9e7:         h.setQuick(n, n, h.getQuick(n, n) + exshift);
1:9c7a9e7:         d.setQuick(n, h.getQuick(n, n));
1:9c7a9e7:         e.setQuick(n, 0.0);
1:9c7a9e7:         n--;
1:9c7a9e7:         iter = 0;
1:9c7a9e7: 
1:9c7a9e7: 
1:9c7a9e7:       } else if (l == n - 1) {
1:9c7a9e7:         // Two roots found
1:9c7a9e7:         w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);
1:9c7a9e7:         p = (h.getQuick(n - 1, n - 1) - h.getQuick(n, n)) / 2.0;
1:9c7a9e7:         q = p * p + w;
1:9c7a9e7:         z = Math.sqrt(Math.abs(q));
1:9c7a9e7:         h.setQuick(n, n, h.getQuick(n, n) + exshift);
1:9c7a9e7:         h.setQuick(n - 1, n - 1, h.getQuick(n - 1, n - 1) + exshift);
1:9c7a9e7:         x = h.getQuick(n, n);
1:9c7a9e7: 
1:9c7a9e7:         // Real pair
1:9c7a9e7:         if (q >= 0) {
1:9c7a9e7:           if (p >= 0) {
1:9c7a9e7:             z = p + z;
1:9c7a9e7:           } else {
1:9c7a9e7:             z = p - z;
1:9c7a9e7:           }
1:9c7a9e7:           d.setQuick(n - 1, x + z);
1:9c7a9e7:           d.setQuick(n, d.getQuick(n - 1));
1:9c7a9e7:           if (z != 0.0) {
1:9c7a9e7:             d.setQuick(n, x - w / z);
1:9c7a9e7:           }
1:9c7a9e7:           e.setQuick(n - 1, 0.0);
1:9c7a9e7:           e.setQuick(n, 0.0);
1:9c7a9e7:           x = h.getQuick(n, n - 1);
1:9c7a9e7:           s = Math.abs(x) + Math.abs(z);
1:9c7a9e7:           p = x / s;
1:9c7a9e7:           q = z / s;
1:9c7a9e7:           r = Math.sqrt(p * p + q * q);
1:229aeff:           p /= r;
1:229aeff:           q /= r;
1:9c7a9e7: 
1:9c7a9e7:           // Row modification
1:9c7a9e7: 
1:9c7a9e7:           for (int j = n - 1; j < nn; j++) {
1:9c7a9e7:             z = h.getQuick(n - 1, j);
1:9c7a9e7:             h.setQuick(n - 1, j, q * z + p * h.getQuick(n, j));
1:9c7a9e7:             h.setQuick(n, j, q * h.getQuick(n, j) - p * z);
1:9c7a9e7:           }
1:9c7a9e7: 
1:9c7a9e7:           // Column modification
1:9c7a9e7: 
1:9c7a9e7:           for (int i = 0; i <= n; i++) {
1:9c7a9e7:             z = h.getQuick(i, n - 1);
1:9c7a9e7:             h.setQuick(i, n - 1, q * z + p * h.getQuick(i, n));
1:9c7a9e7:             h.setQuick(i, n, q * h.getQuick(i, n) - p * z);
1:9c7a9e7:           }
1:9c7a9e7: 
1:9c7a9e7:           // Accumulate transformations
1:9c7a9e7: 
1:9c7a9e7:           for (int i = low; i <= high; i++) {
1:9c7a9e7:             z = v.getQuick(i, n - 1);
1:9c7a9e7:             v.setQuick(i, n - 1, q * z + p * v.getQuick(i, n));
1:9c7a9e7:             v.setQuick(i, n, q * v.getQuick(i, n) - p * z);
1:9c7a9e7:           }
1:9c7a9e7: 
1:9c7a9e7:           // Complex pair
1:9c7a9e7: 
1:9c7a9e7:         } else {
1:9c7a9e7:           d.setQuick(n - 1, x + p);
1:9c7a9e7:           d.setQuick(n, x + p);
1:9c7a9e7:           e.setQuick(n - 1, z);
1:9c7a9e7:           e.setQuick(n, -z);
1:9c7a9e7:         }
1:229aeff:         n -= 2;
1:9c7a9e7:         iter = 0;
1:9c7a9e7: 
1:9c7a9e7:         // No convergence yet
1:9c7a9e7: 
1:9c7a9e7:       } else {
1:9c7a9e7: 
1:9c7a9e7:         // Form shift
1:9c7a9e7: 
1:9c7a9e7:         x = h.getQuick(n, n);
1:9c7a9e7:         y = 0.0;
1:9c7a9e7:         w = 0.0;
1:9c7a9e7:         if (l < n) {
1:9c7a9e7:           y = h.getQuick(n - 1, n - 1);
1:9c7a9e7:           w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         // Wilkinson's original ad hoc shift
1:9c7a9e7: 
1:9c7a9e7:         if (iter == 10) {
1:9c7a9e7:           exshift += x;
1:9c7a9e7:           for (int i = low; i <= n; i++) {
1:9c7a9e7:             h.setQuick(i, i, x);
1:9c7a9e7:           }
1:9c7a9e7:           s = Math.abs(h.getQuick(n, n - 1)) + Math.abs(h.getQuick(n - 1, n - 2));
1:9c7a9e7:           x = y = 0.75 * s;
1:9c7a9e7:           w = -0.4375 * s * s;
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         // MATLAB's new ad hoc shift
1:9c7a9e7: 
1:9c7a9e7:         if (iter == 30) {
1:9c7a9e7:           s = (y - x) / 2.0;
1:9c7a9e7:           s = s * s + w;
1:9c7a9e7:           if (s > 0) {
1:9c7a9e7:             s = Math.sqrt(s);
1:9c7a9e7:             if (y < x) {
1:9c7a9e7:               s = -s;
1:9c7a9e7:             }
1:9c7a9e7:             s = x - w / ((y - x) / 2.0 + s);
1:9c7a9e7:             for (int i = low; i <= n; i++) {
1:9c7a9e7:               h.setQuick(i, i, h.getQuick(i, i) - s);
1:9c7a9e7:             }
1:9c7a9e7:             exshift += s;
1:9c7a9e7:             x = y = w = 0.964;
1:9c7a9e7:           }
1:9c7a9e7:         }
1:9c7a9e7: 
1:229aeff:         iter++;   // (Could check iteration count here.)
1:9c7a9e7: 
1:9c7a9e7:         // Look for two consecutive small sub-diagonal elements
1:9c7a9e7: 
1:9c7a9e7:         int m = n - 2;
1:9c7a9e7:         while (m >= l) {
1:9c7a9e7:           z = h.getQuick(m, m);
1:9c7a9e7:           r = x - z;
1:9c7a9e7:           s = y - z;
1:9c7a9e7:           p = (r * s - w) / h.getQuick(m + 1, m) + h.getQuick(m, m + 1);
1:9c7a9e7:           q = h.getQuick(m + 1, m + 1) - z - r - s;
1:9c7a9e7:           r = h.getQuick(m + 2, m + 1);
1:9c7a9e7:           s = Math.abs(p) + Math.abs(q) + Math.abs(r);
1:229aeff:           p /= s;
1:229aeff:           q /= s;
1:229aeff:           r /= s;
1:9c7a9e7:           if (m == l) {
1:9c7a9e7:             break;
1:9c7a9e7:           }
1:229aeff:           double hmag = Math.abs(h.getQuick(m - 1, m - 1)) + Math.abs(h.getQuick(m + 1, m + 1));
1:229aeff:           double threshold = eps * Math.abs(p) * (Math.abs(z) + hmag);
1:f514c82:           if (Math.abs(h.getQuick(m, m - 1)) * (Math.abs(q) + Math.abs(r)) < threshold) {
1:9c7a9e7:             break;
1:9c7a9e7:           }
1:9c7a9e7:           m--;
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         for (int i = m + 2; i <= n; i++) {
1:9c7a9e7:           h.setQuick(i, i - 2, 0.0);
1:9c7a9e7:           if (i > m + 2) {
1:9c7a9e7:             h.setQuick(i, i - 3, 0.0);
1:9c7a9e7:           }
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         // Double QR step involving rows l:n and columns m:n
1:9c7a9e7: 
1:9c7a9e7:         for (int k = m; k <= n - 1; k++) {
1:f514c82:           boolean notlast = k != n - 1;
1:9c7a9e7:           if (k != m) {
1:9c7a9e7:             p = h.getQuick(k, k - 1);
1:9c7a9e7:             q = h.getQuick(k + 1, k - 1);
1:f514c82:             r = notlast ? h.getQuick(k + 2, k - 1) : 0.0;
1:9c7a9e7:             x = Math.abs(p) + Math.abs(q) + Math.abs(r);
1:9c7a9e7:             if (x != 0.0) {
1:229aeff:               p /= x;
1:229aeff:               q /= x;
1:229aeff:               r /= x;
1:9c7a9e7:             }
1:9c7a9e7:           }
1:9c7a9e7:           if (x == 0.0) {
1:9c7a9e7:             break;
1:9c7a9e7:           }
1:9c7a9e7:           s = Math.sqrt(p * p + q * q + r * r);
1:9c7a9e7:           if (p < 0) {
1:9c7a9e7:             s = -s;
1:9c7a9e7:           }
1:9c7a9e7:           if (s != 0) {
1:9c7a9e7:             if (k != m) {
1:9c7a9e7:               h.setQuick(k, k - 1, -s * x);
1:9c7a9e7:             } else if (l != m) {
1:9c7a9e7:               h.setQuick(k, k - 1, -h.getQuick(k, k - 1));
1:9c7a9e7:             }
1:229aeff:             p += s;
1:9c7a9e7:             x = p / s;
1:9c7a9e7:             y = q / s;
1:9c7a9e7:             z = r / s;
1:229aeff:             q /= p;
1:229aeff:             r /= p;
1:9c7a9e7: 
1:9c7a9e7:             // Row modification
1:9c7a9e7: 
1:9c7a9e7:             for (int j = k; j < nn; j++) {
1:9c7a9e7:               p = h.getQuick(k, j) + q * h.getQuick(k + 1, j);
1:9c7a9e7:               if (notlast) {
1:229aeff:                 p += r * h.getQuick(k + 2, j);
1:9c7a9e7:                 h.setQuick(k + 2, j, h.getQuick(k + 2, j) - p * z);
1:9c7a9e7:               }
1:9c7a9e7:               h.setQuick(k, j, h.getQuick(k, j) - p * x);
1:9c7a9e7:               h.setQuick(k + 1, j, h.getQuick(k + 1, j) - p * y);
1:9c7a9e7:             }
1:9c7a9e7: 
1:9c7a9e7:             // Column modification
1:9c7a9e7: 
1:9c7a9e7:             for (int i = 0; i <= Math.min(n, k + 3); i++) {
1:9c7a9e7:               p = x * h.getQuick(i, k) + y * h.getQuick(i, k + 1);
1:9c7a9e7:               if (notlast) {
1:229aeff:                 p += z * h.getQuick(i, k + 2);
1:9c7a9e7:                 h.setQuick(i, k + 2, h.getQuick(i, k + 2) - p * r);
1:9c7a9e7:               }
1:9c7a9e7:               h.setQuick(i, k, h.getQuick(i, k) - p);
1:9c7a9e7:               h.setQuick(i, k + 1, h.getQuick(i, k + 1) - p * q);
1:9c7a9e7:             }
1:9c7a9e7: 
1:9c7a9e7:             // Accumulate transformations
1:9c7a9e7: 
1:9c7a9e7:             for (int i = low; i <= high; i++) {
1:9c7a9e7:               p = x * v.getQuick(i, k) + y * v.getQuick(i, k + 1);
1:9c7a9e7:               if (notlast) {
1:229aeff:                 p += z * v.getQuick(i, k + 2);
1:9c7a9e7:                 v.setQuick(i, k + 2, v.getQuick(i, k + 2) - p * r);
1:9c7a9e7:               }
1:9c7a9e7:               v.setQuick(i, k, v.getQuick(i, k) - p);
1:9c7a9e7:               v.setQuick(i, k + 1, v.getQuick(i, k + 1) - p * q);
1:9c7a9e7:             }
1:9c7a9e7:           }  // (s != 0)
1:9c7a9e7:         }  // k loop
1:9c7a9e7:       }  // check convergence
1:9c7a9e7:     }  // while (n >= low)
1:9c7a9e7: 
1:9c7a9e7:     // Backsubstitute to find vectors of upper triangular form
1:9c7a9e7: 
1:9c7a9e7:     if (norm == 0.0) {
1:9c7a9e7:       return;
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     for (n = nn - 1; n >= 0; n--) {
1:9c7a9e7:       p = d.getQuick(n);
1:9c7a9e7:       q = e.getQuick(n);
1:9c7a9e7: 
1:9c7a9e7:       // Real vector
1:9c7a9e7: 
1:229aeff:       double t;
1:9c7a9e7:       if (q == 0) {
1:9c7a9e7:         int l = n;
1:9c7a9e7:         h.setQuick(n, n, 1.0);
1:9c7a9e7:         for (int i = n - 1; i >= 0; i--) {
1:9c7a9e7:           w = h.getQuick(i, i) - p;
1:9c7a9e7:           r = 0.0;
1:9c7a9e7:           for (int j = l; j <= n; j++) {
1:229aeff:             r += h.getQuick(i, j) * h.getQuick(j, n);
1:9c7a9e7:           }
1:9c7a9e7:           if (e.getQuick(i) < 0.0) {
1:9c7a9e7:             z = w;
1:9c7a9e7:             s = r;
1:9c7a9e7:           } else {
1:9c7a9e7:             l = i;
1:9c7a9e7:             if (e.getQuick(i) == 0.0) {
1:229aeff:               if (w == 0.0) {
1:9c7a9e7:                 h.setQuick(i, n, -r / (eps * norm));
1:229aeff:               } else {
1:229aeff:                 h.setQuick(i, n, -r / w);
1:9c7a9e7:               }
1:9c7a9e7: 
1:9c7a9e7:               // Solve real equations
1:9c7a9e7: 
1:9c7a9e7:             } else {
1:9c7a9e7:               x = h.getQuick(i, i + 1);
1:9c7a9e7:               y = h.getQuick(i + 1, i);
1:9c7a9e7:               q = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i);
1:9c7a9e7:               t = (x * s - z * r) / q;
1:9c7a9e7:               h.setQuick(i, n, t);
1:9c7a9e7:               if (Math.abs(x) > Math.abs(z)) {
1:9c7a9e7:                 h.setQuick(i + 1, n, (-r - w * t) / x);
1:9c7a9e7:               } else {
1:9c7a9e7:                 h.setQuick(i + 1, n, (-s - y * t) / z);
1:9c7a9e7:               }
1:9c7a9e7:             }
1:9c7a9e7: 
1:9c7a9e7:             // Overflow control
1:9c7a9e7: 
1:9c7a9e7:             t = Math.abs(h.getQuick(i, n));
1:229aeff:             if (eps * t * t > 1) {
1:9c7a9e7:               for (int j = i; j <= n; j++) {
1:9c7a9e7:                 h.setQuick(j, n, h.getQuick(j, n) / t);
1:9c7a9e7:               }
1:9c7a9e7:             }
1:9c7a9e7:           }
1:9c7a9e7:         }
1:9c7a9e7: 
1:9c7a9e7:         // Complex vector
1:9c7a9e7: 
1:9c7a9e7:       } else if (q < 0) {
1:9c7a9e7:         int l = n - 1;
1:9c7a9e7: 
1:9c7a9e7:         // Last vector component imaginary so matrix is triangular
1:9c7a9e7: 
1:9c7a9e7:         if (Math.abs(h.getQuick(n, n - 1)) > Math.abs(h.getQuick(n - 1, n))) {
1:9c7a9e7:           h.setQuick(n - 1, n - 1, q / h.getQuick(n, n - 1));
1:9c7a9e7:           h.setQuick(n - 1, n, -(h.getQuick(n, n) - p) / h.getQuick(n, n - 1));
1:9c7a9e7:         } else {
1:9c7a9e7:           cdiv(0.0, -h.getQuick(n - 1, n), h.getQuick(n - 1, n - 1) - p, q);
1:9c7a9e7:           h.setQuick(n - 1, n - 1, cdivr);
1:9c7a9e7:           h.setQuick(n - 1, n, cdivi);
1:9c7a9e7:         }
1:9c7a9e7:         h.setQuick(n, n - 1, 0.0);
1:9c7a9e7:         h.setQuick(n, n, 1.0);
1:9c7a9e7:         for (int i = n - 2; i >= 0; i--) {
1:229aeff:           double ra = 0.0;
1:229aeff:           double sa = 0.0;
1:9c7a9e7:           for (int j = l; j <= n; j++) {
1:229aeff:             ra += h.getQuick(i, j) * h.getQuick(j, n - 1);
1:229aeff:             sa += h.getQuick(i, j) * h.getQuick(j, n);
1:9c7a9e7:           }
1:9c7a9e7:           w = h.getQuick(i, i) - p;
1:9c7a9e7: 
1:9c7a9e7:           if (e.getQuick(i) < 0.0) {
1:9c7a9e7:             z = w;
1:9c7a9e7:             r = ra;
1:9c7a9e7:             s = sa;
1:9c7a9e7:           } else {
1:9c7a9e7:             l = i;
1:9c7a9e7:             if (e.getQuick(i) == 0) {
1:9c7a9e7:               cdiv(-ra, -sa, w, q);
1:9c7a9e7:               h.setQuick(i, n - 1, cdivr);
1:9c7a9e7:               h.setQuick(i, n, cdivi);
1:9c7a9e7:             } else {
1:9c7a9e7: 
1:9c7a9e7:               // Solve complex equations
1:9c7a9e7: 
1:9c7a9e7:               x = h.getQuick(i, i + 1);
1:9c7a9e7:               y = h.getQuick(i + 1, i);
1:229aeff:               double vr = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i) - q * q;
1:229aeff:               double vi = (d.getQuick(i) - p) * 2.0 * q;
1:229aeff:               if (vr == 0.0 && vi == 0.0) {
1:229aeff:                 double hmag = Math.abs(x) + Math.abs(y);
1:f514c82:                 vr = eps * norm * (Math.abs(w) + Math.abs(q) + hmag + Math.abs(z));
1:9c7a9e7:               }
1:9c7a9e7:               cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
1:9c7a9e7:               h.setQuick(i, n - 1, cdivr);
1:9c7a9e7:               h.setQuick(i, n, cdivi);
1:9c7a9e7:               if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
1:9c7a9e7:                 h.setQuick(i + 1, n - 1, (-ra - w * h.getQuick(i, n - 1) + q * h.getQuick(i, n)) / x);
1:9c7a9e7:                 h.setQuick(i + 1, n, (-sa - w * h.getQuick(i, n) - q * h.getQuick(i, n - 1)) / x);
1:9c7a9e7:               } else {
1:9c7a9e7:                 cdiv(-r - y * h.getQuick(i, n - 1), -s - y * h.getQuick(i, n), z, q);
1:9c7a9e7:                 h.setQuick(i + 1, n - 1, cdivr);
1:9c7a9e7:                 h.setQuick(i + 1, n, cdivi);
1:9c7a9e7:               }
1:9c7a9e7:             }
1:9c7a9e7: 
1:9c7a9e7:             // Overflow control
1:9c7a9e7: 
1:9c7a9e7:             t = Math.max(Math.abs(h.getQuick(i, n - 1)), Math.abs(h.getQuick(i, n)));
1:229aeff:             if (eps * t * t > 1) {
1:9c7a9e7:               for (int j = i; j <= n; j++) {
1:9c7a9e7:                 h.setQuick(j, n - 1, h.getQuick(j, n - 1) / t);
1:9c7a9e7:                 h.setQuick(j, n, h.getQuick(j, n) / t);
1:9c7a9e7:               }
1:9c7a9e7:             }
1:9c7a9e7:           }
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     // Vectors of isolated roots
1:9c7a9e7: 
1:9c7a9e7:     for (int i = 0; i < nn; i++) {
1:f514c82:       if (i < low || i > high) {
1:9c7a9e7:         for (int j = i; j < nn; j++) {
1:9c7a9e7:           v.setQuick(i, j, h.getQuick(i, j));
1:9c7a9e7:         }
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7: 
1:9c7a9e7:     // Back transformation to get eigenvectors of original matrix
1:9c7a9e7: 
1:9c7a9e7:     for (int j = nn - 1; j >= low; j--) {
1:9c7a9e7:       for (int i = low; i <= high; i++) {
1:9c7a9e7:         z = 0.0;
1:9c7a9e7:         for (int k = low; k <= Math.min(j, high); k++) {
1:229aeff:           z += v.getQuick(i, k) * h.getQuick(k, j);
1:9c7a9e7:         }
1:9c7a9e7:         v.setQuick(i, j, z);
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7:   }
1:9c7a9e7: 
1:9c7a9e7:   private static boolean isSymmetric(Matrix a) {
1:9c7a9e7:     /*
1:9c7a9e7:     Symmetry flag.
1:9c7a9e7:     */
1:9c7a9e7:     int n = a.columnSize();
1:9c7a9e7: 
1:9c7a9e7:     boolean isSymmetric = true;
1:229aeff:     for (int j = 0; (j < n) && isSymmetric; j++) {
1:229aeff:       for (int i = 0; (i < n) && isSymmetric; i++) {
1:f514c82:         isSymmetric = a.getQuick(i, j) == a.getQuick(j, i);
1:9c7a9e7:       }
1:9c7a9e7:     }
1:9c7a9e7:     return isSymmetric;
1:9c7a9e7:   }
1:9c7a9e7: }
============================================================================
author:Dmitriy Lyubimov
-------------------------------------------------------------------------------
commit:bc8eafd
/////////////////////////////////////////////////////////////////////////
1:         if (d.getQuick(j) > p) {
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:bdb1c48
/////////////////////////////////////////////////////////////////////////
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:229aeff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   /** Row and column dimension (square matrix). */
1:   private final int n;
1:   /** Arrays for internal storage of eigenvalues. */
1:   private final Vector d;
1:   private final Vector e;
1:   /** Array for internal storage of eigenvectors. */
1:   private final Matrix v;
/////////////////////////////////////////////////////////////////////////
1:       double v = e.getQuick(i);
/////////////////////////////////////////////////////////////////////////
1:         h -= f * g;
/////////////////////////////////////////////////////////////////////////
0:           iter++;  // (Could check iteration count here.)
/////////////////////////////////////////////////////////////////////////
1:           f += h;
/////////////////////////////////////////////////////////////////////////
1:       Vector hColumn = hessenBerg.viewColumn(m - 1).viewPart(m, high - m + 1);
/////////////////////////////////////////////////////////////////////////
1:         h -= ort.getQuick(m) * g;
/////////////////////////////////////////////////////////////////////////
1:           g = g / ort.getQuick(m) / hessenBerg.getQuick(m, m - 1);
/////////////////////////////////////////////////////////////////////////
1:   private double cdivr;
1:   private double cdivi;
/////////////////////////////////////////////////////////////////////////
1:     int nn = this.n;
1:     int low = 0;
1:     int high = nn - 1;
1:     double p = 0;
1:     double q = 0;
1:     double r = 0;
1:     double s = 0;
1:     double z = 0;
1:     double w;
1:     double x;
1:     double y;
/////////////////////////////////////////////////////////////////////////
1:           p /= r;
1:           q /= r;
/////////////////////////////////////////////////////////////////////////
1:         n -= 2;
/////////////////////////////////////////////////////////////////////////
1:         iter++;   // (Could check iteration count here.)
/////////////////////////////////////////////////////////////////////////
1:           p /= s;
1:           q /= s;
1:           r /= s;
1:           double hmag = Math.abs(h.getQuick(m - 1, m - 1)) + Math.abs(h.getQuick(m + 1, m + 1));
1:           double threshold = eps * Math.abs(p) * (Math.abs(z) + hmag);
/////////////////////////////////////////////////////////////////////////
1:               p /= x;
1:               q /= x;
1:               r /= x;
/////////////////////////////////////////////////////////////////////////
1:             p += s;
1:             q /= p;
1:             r /= p;
1:                 p += r * h.getQuick(k + 2, j);
/////////////////////////////////////////////////////////////////////////
1:                 p += z * h.getQuick(i, k + 2);
/////////////////////////////////////////////////////////////////////////
1:                 p += z * v.getQuick(i, k + 2);
/////////////////////////////////////////////////////////////////////////
1:       double t;
/////////////////////////////////////////////////////////////////////////
1:             r += h.getQuick(i, j) * h.getQuick(j, n);
/////////////////////////////////////////////////////////////////////////
1:               if (w == 0.0) {
1:               } else {
1:                 h.setQuick(i, n, -r / w);
/////////////////////////////////////////////////////////////////////////
1:             if (eps * t * t > 1) {
/////////////////////////////////////////////////////////////////////////
1:           double ra = 0.0;
1:           double sa = 0.0;
1:             ra += h.getQuick(i, j) * h.getQuick(j, n - 1);
1:             sa += h.getQuick(i, j) * h.getQuick(j, n);
/////////////////////////////////////////////////////////////////////////
1:               double vr = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i) - q * q;
1:               double vi = (d.getQuick(i) - p) * 2.0 * q;
1:               if (vr == 0.0 && vi == 0.0) {
1:                 double hmag = Math.abs(x) + Math.abs(y);
/////////////////////////////////////////////////////////////////////////
1:             if (eps * t * t > 1) {
/////////////////////////////////////////////////////////////////////////
1:           z += v.getQuick(i, k) * h.getQuick(k, j);
/////////////////////////////////////////////////////////////////////////
1:     for (int j = 0; (j < n) && isSymmetric; j++) {
1:       for (int i = 0; (i < n) && isSymmetric; i++) {
author:Ted Dunning
-------------------------------------------------------------------------------
commit:f514c82
/////////////////////////////////////////////////////////////////////////
0:   private Vector d;
0:   private Vector e;
/////////////////////////////////////////////////////////////////////////
1:     Matrix x = new DenseMatrix(n, n);
1:     x.assign(0);
1:     x.viewDiagonal().assign(d);
1:         x.setQuick(i, i + 1, v);
1:         x.setQuick(i, i - 1, v);
1:     return x;
/////////////////////////////////////////////////////////////////////////
1:     Matrix hessenBerg = new DenseMatrix(n, n).assign(x);
/////////////////////////////////////////////////////////////////////////
0:       final Vector hColumn = hessenBerg.viewColumn(m - 1).viewPart(m, high - m + 1);
1:       double scale = hColumn.norm(1);
1:         ort.viewPart(m, high - m + 1).assign(hColumn, Functions.plusMult(1 / scale));
/////////////////////////////////////////////////////////////////////////
1:           double f = ortPiece.dot(hessenBerg.viewColumn(j).viewPart(m, high - m + 1)) / h;
1:           hessenBerg.viewColumn(j).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:           double f = ortPiece.dot(hessenBerg.viewRow(i).viewPart(m, high - m + 1)) / h;
1:           hessenBerg.viewRow(i).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:         hessenBerg.setQuick(m, m - 1, scale * g);
/////////////////////////////////////////////////////////////////////////
1:       if (hessenBerg.getQuick(m, m - 1) != 0.0) {
1:         ort.viewPart(m + 1, high - m).assign(hessenBerg.viewColumn(m - 1).viewPart(m + 1, high - m));
0:           g = (g / ort.getQuick(m)) / hessenBerg.getQuick(m, m - 1);
1:     return hessenBerg;
0:   private transient double cdivr;
0:   private transient double cdivi;
1:     double r;
1:     double d;
/////////////////////////////////////////////////////////////////////////
0:           final double hmag = Math.abs(h.getQuick(m - 1, m - 1)) + Math.abs(h.getQuick(m + 1, m + 1));
0:           final double threshold = eps * Math.abs(p) * (Math.abs(z) + hmag);
1:           if (Math.abs(h.getQuick(m, m - 1)) * (Math.abs(q) + Math.abs(r)) < threshold) {
/////////////////////////////////////////////////////////////////////////
1:           boolean notlast = k != n - 1;
1:             r = notlast ? h.getQuick(k + 2, k - 1) : 0.0;
/////////////////////////////////////////////////////////////////////////
0:                 final double hmag = Math.abs(x) + Math.abs(y);
1:                 vr = eps * norm * (Math.abs(w) + Math.abs(q) + hmag + Math.abs(z));
/////////////////////////////////////////////////////////////////////////
1:       if (i < low || i > high) {
/////////////////////////////////////////////////////////////////////////
1:         isSymmetric = a.getQuick(i, j) == a.getQuick(j, i);
commit:2fd2aed
/////////////////////////////////////////////////////////////////////////
1:       double scale = d.viewPart(0, i).norm(1);
/////////////////////////////////////////////////////////////////////////
commit:9c7a9e7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: /**
1:  * Adapted from the public domain Jama code.
1:  */
1: 
1: package org.apache.mahout.math.solver;
1: 
1: 
1: import org.apache.mahout.math.DenseMatrix;
1: import org.apache.mahout.math.DenseVector;
1: import org.apache.mahout.math.Matrix;
1: import org.apache.mahout.math.Vector;
1: import org.apache.mahout.math.function.Functions;
1: 
1: /**
1:  * Eigenvalues and eigenvectors of a real matrix.
1:  * <p/>
1:  * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector
1:  * matrix V is orthogonal. I.e. A = V.times(D.times(V.transpose())) and V.times(V.transpose())
1:  * equals the identity matrix.
1:  * <p/>
1:  * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues
1:  * in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu,
1:  * lambda].  The columns of V represent the eigenvectors in the sense that A*V = V*D, i.e.
1:  * A.times(V) equals V.times(D).  The matrix V may be badly conditioned, or even singular, so the
1:  * validity of the equation A = V*D*inverse(V) depends upon V.cond().
1:  */
1: 
1: public class EigenDecomposition {
1:   /**
0:    * Row and column dimension (square matrix).
1:    */
0:   private int n;
1: 
1:   /**
0:    * Arrays for internal storage of eigenvalues.
1:    */
0:   private Vector d, e;
1: 
1:   /**
0:    * Array for internal storage of eigenvectors.
1:    */
0:   private Matrix v;
1: 
1:   public EigenDecomposition(Matrix x) {
1:     this(x, isSymmetric(x));
1:   }
1: 
1:   public EigenDecomposition(Matrix x, boolean isSymmetric) {
1:     n = x.columnSize();
1:     d = new DenseVector(n);
1:     e = new DenseVector(n);
1:     v = new DenseMatrix(n, n);
1: 
1:     if (isSymmetric) {
1:       v.assign(x);
1: 
1:       // Tridiagonalize.
1:       tred2();
1: 
1:       // Diagonalize.
1:       tql2();
1: 
1:     } else {
1:       // Reduce to Hessenberg form.
1:       // Reduce Hessenberg to real Schur form.
1:       hqr2(orthes(x));
1:     }
1:   }
1: 
1:   /**
1:    * Return the eigenvector matrix
1:    *
1:    * @return V
1:    */
1:   public Matrix getV() {
1:     return v.like().assign(v);
1:   }
1: 
1:   /**
1:    * Return the real parts of the eigenvalues
1:    */
1:   public Vector getRealEigenvalues() {
1:     return d;
1:   }
1: 
1:   /**
1:    * Return the imaginary parts of the eigenvalues
1:    */
1:   public Vector getImagEigenvalues() {
1:     return e;
1:   }
1: 
1:   /**
1:    * Return the block diagonal eigenvalue matrix
1:    *
1:    * @return D
1:    */
1:   public Matrix getD() {
0:     Matrix X = new DenseMatrix(n, n);
0:     X.assign(0);
0:     X.viewDiagonal().assign(d);
1:     for (int i = 0; i < n; i++) {
0:       final double v = e.getQuick(i);
1:       if (v > 0) {
0:         X.setQuick(i, i + 1, v);
1:       } else if (v < 0) {
0:         X.setQuick(i, i - 1, v);
1:       }
1:     }
0:     return X;
1:   }
1: 
1:   // Symmetric Householder reduction to tridiagonal form.
1:   private void tred2() {
1:     //  This is derived from the Algol procedures tred2 by
1:     //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
1:     //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
1:     //  Fortran subroutine in EISPACK.
1: 
1:     d.assign(v.viewColumn(n - 1));
1: 
1:     // Householder reduction to tridiagonal form.
1: 
1:     for (int i = n - 1; i > 0; i--) {
1: 
1:       // Scale to avoid under/overflow.
1: 
0:       double scale = d.norm(1);
1:       double h = 0.0;
1: 
1: 
1:       if (scale == 0.0) {
1:         e.setQuick(i, d.getQuick(i - 1));
1:         for (int j = 0; j < i; j++) {
1:           d.setQuick(j, v.getQuick(i - 1, j));
1:           v.setQuick(i, j, 0.0);
1:           v.setQuick(j, i, 0.0);
1:         }
1:       } else {
1: 
1:         // Generate Householder vector.
1: 
1:         for (int k = 0; k < i; k++) {
1:           d.setQuick(k, d.getQuick(k) / scale);
1:           h += d.getQuick(k) * d.getQuick(k);
1:         }
1:         double f = d.getQuick(i - 1);
1:         double g = Math.sqrt(h);
1:         if (f > 0) {
1:           g = -g;
1:         }
1:         e.setQuick(i, scale * g);
0:         h = h - f * g;
1:         d.setQuick(i - 1, f - g);
1:         for (int j = 0; j < i; j++) {
1:           e.setQuick(j, 0.0);
1:         }
1: 
1:         // Apply similarity transformation to remaining columns.
1: 
1:         for (int j = 0; j < i; j++) {
1:           f = d.getQuick(j);
1:           v.setQuick(j, i, f);
1:           g = e.getQuick(j) + v.getQuick(j, j) * f;
1:           for (int k = j + 1; k <= i - 1; k++) {
1:             g += v.getQuick(k, j) * d.getQuick(k);
1:             e.setQuick(k, e.getQuick(k) + v.getQuick(k, j) * f);
1:           }
1:           e.setQuick(j, g);
1:         }
1:         f = 0.0;
1:         for (int j = 0; j < i; j++) {
1:           e.setQuick(j, e.getQuick(j) / h);
1:           f += e.getQuick(j) * d.getQuick(j);
1:         }
1:         double hh = f / (h + h);
1:         for (int j = 0; j < i; j++) {
1:           e.setQuick(j, e.getQuick(j) - hh * d.getQuick(j));
1:         }
1:         for (int j = 0; j < i; j++) {
1:           f = d.getQuick(j);
1:           g = e.getQuick(j);
1:           for (int k = j; k <= i - 1; k++) {
1:             v.setQuick(k, j, v.getQuick(k, j) - (f * e.getQuick(k) + g * d.getQuick(k)));
1:           }
1:           d.setQuick(j, v.getQuick(i - 1, j));
1:           v.setQuick(i, j, 0.0);
1:         }
1:       }
1:       d.setQuick(i, h);
1:     }
1: 
1:     // Accumulate transformations.
1: 
1:     for (int i = 0; i < n - 1; i++) {
1:       v.setQuick(n - 1, i, v.getQuick(i, i));
1:       v.setQuick(i, i, 1.0);
1:       double h = d.getQuick(i + 1);
1:       if (h != 0.0) {
1:         for (int k = 0; k <= i; k++) {
1:           d.setQuick(k, v.getQuick(k, i + 1) / h);
1:         }
1:         for (int j = 0; j <= i; j++) {
1:           double g = 0.0;
1:           for (int k = 0; k <= i; k++) {
1:             g += v.getQuick(k, i + 1) * v.getQuick(k, j);
1:           }
1:           for (int k = 0; k <= i; k++) {
1:             v.setQuick(k, j, v.getQuick(k, j) - g * d.getQuick(k));
1:           }
1:         }
1:       }
1:       for (int k = 0; k <= i; k++) {
1:         v.setQuick(k, i + 1, 0.0);
1:       }
1:     }
1:     d.assign(v.viewRow(n - 1));
1:     v.viewRow(n - 1).assign(0);
1:     v.setQuick(n - 1, n - 1, 1.0);
1:     e.setQuick(0, 0.0);
1:   }
1: 
1:   // Symmetric tridiagonal QL algorithm.
1:   private void tql2() {
1: 
1:     //  This is derived from the Algol procedures tql2, by
1:     //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
1:     //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
1:     //  Fortran subroutine in EISPACK.
1: 
1:     e.viewPart(0, n - 1).assign(e.viewPart(1, n - 1));
1:     e.setQuick(n - 1, 0.0);
1: 
1:     double f = 0.0;
1:     double tst1 = 0.0;
1:     double eps = Math.pow(2.0, -52.0);
1:     for (int l = 0; l < n; l++) {
1: 
1:       // Find small subdiagonal element
1: 
1:       tst1 = Math.max(tst1, Math.abs(d.getQuick(l)) + Math.abs(e.getQuick(l)));
1:       int m = l;
1:       while (m < n) {
1:         if (Math.abs(e.getQuick(m)) <= eps * tst1) {
1:           break;
1:         }
1:         m++;
1:       }
1: 
1:       // If m == l, d.getQuick(l) is an eigenvalue,
1:       // otherwise, iterate.
1: 
1:       if (m > l) {
1:         int iter = 0;
1:         do {
0:           iter = iter + 1;  // (Could check iteration count here.)
1: 
1:           // Compute implicit shift
1: 
1:           double g = d.getQuick(l);
1:           double p = (d.getQuick(l + 1) - g) / (2.0 * e.getQuick(l));
1:           double r = Math.hypot(p, 1.0);
1:           if (p < 0) {
1:             r = -r;
1:           }
1:           d.setQuick(l, e.getQuick(l) / (p + r));
1:           d.setQuick(l + 1, e.getQuick(l) * (p + r));
1:           double dl1 = d.getQuick(l + 1);
1:           double h = g - d.getQuick(l);
1:           for (int i = l + 2; i < n; i++) {
1:             d.setQuick(i, d.getQuick(i) - h);
1:           }
0:           f = f + h;
1: 
1:           // Implicit QL transformation.
1: 
1:           p = d.getQuick(m);
1:           double c = 1.0;
1:           double c2 = c;
1:           double c3 = c;
1:           double el1 = e.getQuick(l + 1);
1:           double s = 0.0;
1:           double s2 = 0.0;
1:           for (int i = m - 1; i >= l; i--) {
1:             c3 = c2;
1:             c2 = c;
1:             s2 = s;
1:             g = c * e.getQuick(i);
1:             h = c * p;
1:             r = Math.hypot(p, e.getQuick(i));
1:             e.setQuick(i + 1, s * r);
1:             s = e.getQuick(i) / r;
1:             c = p / r;
1:             p = c * d.getQuick(i) - s * g;
1:             d.setQuick(i + 1, h + s * (c * g + s * d.getQuick(i)));
1: 
1:             // Accumulate transformation.
1: 
1:             for (int k = 0; k < n; k++) {
1:               h = v.getQuick(k, i + 1);
1:               v.setQuick(k, i + 1, s * v.getQuick(k, i) + c * h);
1:               v.setQuick(k, i, c * v.getQuick(k, i) - s * h);
1:             }
1:           }
1:           p = -s * s2 * c3 * el1 * e.getQuick(l) / dl1;
1:           e.setQuick(l, s * p);
1:           d.setQuick(l, c * p);
1: 
1:           // Check for convergence.
1: 
1:         } while (Math.abs(e.getQuick(l)) > eps * tst1);
1:       }
1:       d.setQuick(l, d.getQuick(l) + f);
1:       e.setQuick(l, 0.0);
1:     }
1: 
1:     // Sort eigenvalues and corresponding vectors.
1: 
1:     for (int i = 0; i < n - 1; i++) {
1:       int k = i;
1:       double p = d.getQuick(i);
1:       for (int j = i + 1; j < n; j++) {
0:         if (d.getQuick(j) < p) {
1:           k = j;
1:           p = d.getQuick(j);
1:         }
1:       }
1:       if (k != i) {
1:         d.setQuick(k, d.getQuick(i));
1:         d.setQuick(i, p);
1:         for (int j = 0; j < n; j++) {
1:           p = v.getQuick(j, i);
1:           v.setQuick(j, i, v.getQuick(j, k));
1:           v.setQuick(j, k, p);
1:         }
1:       }
1:     }
1:   }
1: 
1:   // Nonsymmetric reduction to Hessenberg form.
1:   private Matrix orthes(Matrix x) {
1:     // Working storage for nonsymmetric algorithm.
1:     Vector ort = new DenseVector(n);
0:     Matrix H = new DenseMatrix(n, n).assign(x);
1: 
1:     //  This is derived from the Algol procedures orthes and ortran,
1:     //  by Martin and Wilkinson, Handbook for Auto. Comp.,
1:     //  Vol.ii-Linear Algebra, and the corresponding
1:     //  Fortran subroutines in EISPACK.
1: 
1:     int low = 0;
1:     int high = n - 1;
1: 
1:     for (int m = low + 1; m <= high - 1; m++) {
1: 
1:       // Scale column.
1: 
0:       double scale = H.viewColumn(m - 1).viewPart(m, high - m + 1).norm(1);
1: 
1:       if (scale != 0.0) {
1:         // Compute Householder transformation.
1: 
0:         ort.viewPart(m, high - m + 1).assign(H.viewColumn(m - 1).viewPart(m, high - m + 1), Functions.plusMult(1 / scale));
1:         double h = ort.viewPart(m, high - m + 1).getLengthSquared();
1: 
1:         double g = Math.sqrt(h);
1:         if (ort.getQuick(m) > 0) {
1:           g = -g;
1:         }
0:         h = h - ort.getQuick(m) * g;
1:         ort.setQuick(m, ort.getQuick(m) - g);
1: 
1:         // Apply Householder similarity transformation
1:         // H = (I-u*u'/h)*H*(I-u*u')/h)
1: 
1:         Vector ortPiece = ort.viewPart(m, high - m + 1);
1:         for (int j = m; j < n; j++) {
0:           double f = ortPiece.dot(H.viewColumn(j).viewPart(m, high - m + 1)) / h;
0:           H.viewColumn(j).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:         }
1: 
1:         for (int i = 0; i <= high; i++) {
0:           double f = ortPiece.dot(H.viewRow(i).viewPart(m, high - m + 1)) / h;
0:           H.viewRow(i).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));
1:         }
1:         ort.setQuick(m, scale * ort.getQuick(m));
0:         H.setQuick(m, m - 1, scale * g);
1:       }
1:     }
1: 
1:     // Accumulate transformations (Algol's ortran).
1: 
1:     v.assign(0);
1:     v.viewDiagonal().assign(1);
1: 
1:     for (int m = high - 1; m >= low + 1; m--) {
0:       if (H.getQuick(m, m - 1) != 0.0) {
0:         ort.viewPart(m + 1, high - m).assign(H.viewColumn(m - 1).viewPart(m + 1, high - m));
1:         for (int j = m; j <= high; j++) {
1:           double g = ort.viewPart(m, high - m + 1).dot(v.viewColumn(j).viewPart(m, high - m + 1));
1:           // Double division avoids possible underflow
0:           g = (g / ort.getQuick(m)) / H.getQuick(m, m - 1);
1:           v.viewColumn(j).viewPart(m, high - m + 1).assign(ort.viewPart(m, high - m + 1), Functions.plusMult(g));
1:         }
1:       }
1:     }
0:     return H;
1:   }
1: 
1: 
1:   // Complex scalar division.
0:   private transient double cdivr, cdivi;
1: 
1:   private void cdiv(double xr, double xi, double yr, double yi) {
0:     double r, d;
1:     if (Math.abs(yr) > Math.abs(yi)) {
1:       r = yi / yr;
1:       d = yr + r * yi;
1:       cdivr = (xr + r * xi) / d;
1:       cdivi = (xi - r * xr) / d;
1:     } else {
1:       r = yr / yi;
1:       d = yi + r * yr;
1:       cdivr = (r * xr + xi) / d;
1:       cdivi = (r * xi - xr) / d;
1:     }
1:   }
1: 
1: 
1:   // Nonsymmetric reduction from Hessenberg to real Schur form.
1: 
1:   private void hqr2(Matrix h) {
1: 
1:     //  This is derived from the Algol procedure hqr2,
1:     //  by Martin and Wilkinson, Handbook for Auto. Comp.,
1:     //  Vol.ii-Linear Algebra, and the corresponding
1:     //  Fortran subroutine in EISPACK.
1: 
1:     // Initialize
1: 
0:     final int nn = this.n;
1:     int n = nn - 1;
0:     final int low = 0;
0:     final int high = nn - 1;
1:     double eps = Math.pow(2.0, -52.0);
1:     double exshift = 0.0;
0:     double p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;
1: 
1:     // Store roots isolated by balanc and compute matrix norm
1: 
1:     double norm = h.aggregate(Functions.PLUS, Functions.ABS);
1: 
1:     // Outer loop over eigenvalue index
1: 
1:     int iter = 0;
1:     while (n >= low) {
1: 
1:       // Look for single small sub-diagonal element
1: 
1:       int l = n;
1:       while (l > low) {
1:         s = Math.abs(h.getQuick(l - 1, l - 1)) + Math.abs(h.getQuick(l, l));
1:         if (s == 0.0) {
1:           s = norm;
1:         }
1:         if (Math.abs(h.getQuick(l, l - 1)) < eps * s) {
1:           break;
1:         }
1:         l--;
1:       }
1: 
1:       // Check for convergence
1: 
1:       if (l == n) {
1:         // One root found
1:         h.setQuick(n, n, h.getQuick(n, n) + exshift);
1:         d.setQuick(n, h.getQuick(n, n));
1:         e.setQuick(n, 0.0);
1:         n--;
1:         iter = 0;
1: 
1: 
1:       } else if (l == n - 1) {
1:         // Two roots found
1:         w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);
1:         p = (h.getQuick(n - 1, n - 1) - h.getQuick(n, n)) / 2.0;
1:         q = p * p + w;
1:         z = Math.sqrt(Math.abs(q));
1:         h.setQuick(n, n, h.getQuick(n, n) + exshift);
1:         h.setQuick(n - 1, n - 1, h.getQuick(n - 1, n - 1) + exshift);
1:         x = h.getQuick(n, n);
1: 
1:         // Real pair
1:         if (q >= 0) {
1:           if (p >= 0) {
1:             z = p + z;
1:           } else {
1:             z = p - z;
1:           }
1:           d.setQuick(n - 1, x + z);
1:           d.setQuick(n, d.getQuick(n - 1));
1:           if (z != 0.0) {
1:             d.setQuick(n, x - w / z);
1:           }
1:           e.setQuick(n - 1, 0.0);
1:           e.setQuick(n, 0.0);
1:           x = h.getQuick(n, n - 1);
1:           s = Math.abs(x) + Math.abs(z);
1:           p = x / s;
1:           q = z / s;
1:           r = Math.sqrt(p * p + q * q);
0:           p = p / r;
0:           q = q / r;
1: 
1:           // Row modification
1: 
1:           for (int j = n - 1; j < nn; j++) {
1:             z = h.getQuick(n - 1, j);
1:             h.setQuick(n - 1, j, q * z + p * h.getQuick(n, j));
1:             h.setQuick(n, j, q * h.getQuick(n, j) - p * z);
1:           }
1: 
1:           // Column modification
1: 
1:           for (int i = 0; i <= n; i++) {
1:             z = h.getQuick(i, n - 1);
1:             h.setQuick(i, n - 1, q * z + p * h.getQuick(i, n));
1:             h.setQuick(i, n, q * h.getQuick(i, n) - p * z);
1:           }
1: 
1:           // Accumulate transformations
1: 
1:           for (int i = low; i <= high; i++) {
1:             z = v.getQuick(i, n - 1);
1:             v.setQuick(i, n - 1, q * z + p * v.getQuick(i, n));
1:             v.setQuick(i, n, q * v.getQuick(i, n) - p * z);
1:           }
1: 
1:           // Complex pair
1: 
1:         } else {
1:           d.setQuick(n - 1, x + p);
1:           d.setQuick(n, x + p);
1:           e.setQuick(n - 1, z);
1:           e.setQuick(n, -z);
1:         }
0:         n = n - 2;
1:         iter = 0;
1: 
1:         // No convergence yet
1: 
1:       } else {
1: 
1:         // Form shift
1: 
1:         x = h.getQuick(n, n);
1:         y = 0.0;
1:         w = 0.0;
1:         if (l < n) {
1:           y = h.getQuick(n - 1, n - 1);
1:           w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);
1:         }
1: 
1:         // Wilkinson's original ad hoc shift
1: 
1:         if (iter == 10) {
1:           exshift += x;
1:           for (int i = low; i <= n; i++) {
1:             h.setQuick(i, i, x);
1:           }
1:           s = Math.abs(h.getQuick(n, n - 1)) + Math.abs(h.getQuick(n - 1, n - 2));
1:           x = y = 0.75 * s;
1:           w = -0.4375 * s * s;
1:         }
1: 
1:         // MATLAB's new ad hoc shift
1: 
1:         if (iter == 30) {
1:           s = (y - x) / 2.0;
1:           s = s * s + w;
1:           if (s > 0) {
1:             s = Math.sqrt(s);
1:             if (y < x) {
1:               s = -s;
1:             }
1:             s = x - w / ((y - x) / 2.0 + s);
1:             for (int i = low; i <= n; i++) {
1:               h.setQuick(i, i, h.getQuick(i, i) - s);
1:             }
1:             exshift += s;
1:             x = y = w = 0.964;
1:           }
1:         }
1: 
0:         iter = iter + 1;   // (Could check iteration count here.)
1: 
1:         // Look for two consecutive small sub-diagonal elements
1: 
1:         int m = n - 2;
1:         while (m >= l) {
1:           z = h.getQuick(m, m);
1:           r = x - z;
1:           s = y - z;
1:           p = (r * s - w) / h.getQuick(m + 1, m) + h.getQuick(m, m + 1);
1:           q = h.getQuick(m + 1, m + 1) - z - r - s;
1:           r = h.getQuick(m + 2, m + 1);
1:           s = Math.abs(p) + Math.abs(q) + Math.abs(r);
0:           p = p / s;
0:           q = q / s;
0:           r = r / s;
1:           if (m == l) {
1:             break;
1:           }
0:           if (Math.abs(h.getQuick(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <
0:             eps * (Math.abs(p) * (Math.abs(h.getQuick(m - 1, m - 1)) + Math.abs(z) +
0:               Math.abs(h.getQuick(m + 1, m + 1))))) {
1:             break;
1:           }
1:           m--;
1:         }
1: 
1:         for (int i = m + 2; i <= n; i++) {
1:           h.setQuick(i, i - 2, 0.0);
1:           if (i > m + 2) {
1:             h.setQuick(i, i - 3, 0.0);
1:           }
1:         }
1: 
1:         // Double QR step involving rows l:n and columns m:n
1: 
1:         for (int k = m; k <= n - 1; k++) {
0:           boolean notlast = (k != n - 1);
1:           if (k != m) {
1:             p = h.getQuick(k, k - 1);
1:             q = h.getQuick(k + 1, k - 1);
0:             r = (notlast ? h.getQuick(k + 2, k - 1) : 0.0);
1:             x = Math.abs(p) + Math.abs(q) + Math.abs(r);
1:             if (x != 0.0) {
0:               p = p / x;
0:               q = q / x;
0:               r = r / x;
1:             }
1:           }
1:           if (x == 0.0) {
1:             break;
1:           }
1:           s = Math.sqrt(p * p + q * q + r * r);
1:           if (p < 0) {
1:             s = -s;
1:           }
1:           if (s != 0) {
1:             if (k != m) {
1:               h.setQuick(k, k - 1, -s * x);
1:             } else if (l != m) {
1:               h.setQuick(k, k - 1, -h.getQuick(k, k - 1));
1:             }
0:             p = p + s;
1:             x = p / s;
1:             y = q / s;
1:             z = r / s;
0:             q = q / p;
0:             r = r / p;
1: 
1:             // Row modification
1: 
1:             for (int j = k; j < nn; j++) {
1:               p = h.getQuick(k, j) + q * h.getQuick(k + 1, j);
1:               if (notlast) {
0:                 p = p + r * h.getQuick(k + 2, j);
1:                 h.setQuick(k + 2, j, h.getQuick(k + 2, j) - p * z);
1:               }
1:               h.setQuick(k, j, h.getQuick(k, j) - p * x);
1:               h.setQuick(k + 1, j, h.getQuick(k + 1, j) - p * y);
1:             }
1: 
1:             // Column modification
1: 
1:             for (int i = 0; i <= Math.min(n, k + 3); i++) {
1:               p = x * h.getQuick(i, k) + y * h.getQuick(i, k + 1);
1:               if (notlast) {
0:                 p = p + z * h.getQuick(i, k + 2);
1:                 h.setQuick(i, k + 2, h.getQuick(i, k + 2) - p * r);
1:               }
1:               h.setQuick(i, k, h.getQuick(i, k) - p);
1:               h.setQuick(i, k + 1, h.getQuick(i, k + 1) - p * q);
1:             }
1: 
1:             // Accumulate transformations
1: 
1:             for (int i = low; i <= high; i++) {
1:               p = x * v.getQuick(i, k) + y * v.getQuick(i, k + 1);
1:               if (notlast) {
0:                 p = p + z * v.getQuick(i, k + 2);
1:                 v.setQuick(i, k + 2, v.getQuick(i, k + 2) - p * r);
1:               }
1:               v.setQuick(i, k, v.getQuick(i, k) - p);
1:               v.setQuick(i, k + 1, v.getQuick(i, k + 1) - p * q);
1:             }
1:           }  // (s != 0)
1:         }  // k loop
1:       }  // check convergence
1:     }  // while (n >= low)
1: 
1:     // Backsubstitute to find vectors of upper triangular form
1: 
1:     if (norm == 0.0) {
1:       return;
1:     }
1: 
1:     for (n = nn - 1; n >= 0; n--) {
1:       p = d.getQuick(n);
1:       q = e.getQuick(n);
1: 
1:       // Real vector
1: 
1:       if (q == 0) {
1:         int l = n;
1:         h.setQuick(n, n, 1.0);
1:         for (int i = n - 1; i >= 0; i--) {
1:           w = h.getQuick(i, i) - p;
1:           r = 0.0;
1:           for (int j = l; j <= n; j++) {
0:             r = r + h.getQuick(i, j) * h.getQuick(j, n);
1:           }
1:           if (e.getQuick(i) < 0.0) {
1:             z = w;
1:             s = r;
1:           } else {
1:             l = i;
1:             if (e.getQuick(i) == 0.0) {
0:               if (w != 0.0) {
0:                 h.setQuick(i, n, -r / w);
1:               } else {
1:                 h.setQuick(i, n, -r / (eps * norm));
1:               }
1: 
1:               // Solve real equations
1: 
1:             } else {
1:               x = h.getQuick(i, i + 1);
1:               y = h.getQuick(i + 1, i);
1:               q = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i);
1:               t = (x * s - z * r) / q;
1:               h.setQuick(i, n, t);
1:               if (Math.abs(x) > Math.abs(z)) {
1:                 h.setQuick(i + 1, n, (-r - w * t) / x);
1:               } else {
1:                 h.setQuick(i + 1, n, (-s - y * t) / z);
1:               }
1:             }
1: 
1:             // Overflow control
1: 
1:             t = Math.abs(h.getQuick(i, n));
0:             if ((eps * t) * t > 1) {
1:               for (int j = i; j <= n; j++) {
1:                 h.setQuick(j, n, h.getQuick(j, n) / t);
1:               }
1:             }
1:           }
1:         }
1: 
1:         // Complex vector
1: 
1:       } else if (q < 0) {
1:         int l = n - 1;
1: 
1:         // Last vector component imaginary so matrix is triangular
1: 
1:         if (Math.abs(h.getQuick(n, n - 1)) > Math.abs(h.getQuick(n - 1, n))) {
1:           h.setQuick(n - 1, n - 1, q / h.getQuick(n, n - 1));
1:           h.setQuick(n - 1, n, -(h.getQuick(n, n) - p) / h.getQuick(n, n - 1));
1:         } else {
1:           cdiv(0.0, -h.getQuick(n - 1, n), h.getQuick(n - 1, n - 1) - p, q);
1:           h.setQuick(n - 1, n - 1, cdivr);
1:           h.setQuick(n - 1, n, cdivi);
1:         }
1:         h.setQuick(n, n - 1, 0.0);
1:         h.setQuick(n, n, 1.0);
1:         for (int i = n - 2; i >= 0; i--) {
0:           double ra, sa, vr, vi;
0:           ra = 0.0;
0:           sa = 0.0;
1:           for (int j = l; j <= n; j++) {
0:             ra = ra + h.getQuick(i, j) * h.getQuick(j, n - 1);
0:             sa = sa + h.getQuick(i, j) * h.getQuick(j, n);
1:           }
1:           w = h.getQuick(i, i) - p;
1: 
1:           if (e.getQuick(i) < 0.0) {
1:             z = w;
1:             r = ra;
1:             s = sa;
1:           } else {
1:             l = i;
1:             if (e.getQuick(i) == 0) {
1:               cdiv(-ra, -sa, w, q);
1:               h.setQuick(i, n - 1, cdivr);
1:               h.setQuick(i, n, cdivi);
1:             } else {
1: 
1:               // Solve complex equations
1: 
1:               x = h.getQuick(i, i + 1);
1:               y = h.getQuick(i + 1, i);
0:               vr = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i) - q * q;
0:               vi = (d.getQuick(i) - p) * 2.0 * q;
0:               if (vr == 0.0 & vi == 0.0) {
0:                 vr = eps * norm * (Math.abs(w) + Math.abs(q) +
0:                   Math.abs(x) + Math.abs(y) + Math.abs(z));
1:               }
1:               cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
1:               h.setQuick(i, n - 1, cdivr);
1:               h.setQuick(i, n, cdivi);
1:               if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
1:                 h.setQuick(i + 1, n - 1, (-ra - w * h.getQuick(i, n - 1) + q * h.getQuick(i, n)) / x);
1:                 h.setQuick(i + 1, n, (-sa - w * h.getQuick(i, n) - q * h.getQuick(i, n - 1)) / x);
1:               } else {
1:                 cdiv(-r - y * h.getQuick(i, n - 1), -s - y * h.getQuick(i, n), z, q);
1:                 h.setQuick(i + 1, n - 1, cdivr);
1:                 h.setQuick(i + 1, n, cdivi);
1:               }
1:             }
1: 
1:             // Overflow control
1: 
1:             t = Math.max(Math.abs(h.getQuick(i, n - 1)), Math.abs(h.getQuick(i, n)));
0:             if ((eps * t) * t > 1) {
1:               for (int j = i; j <= n; j++) {
1:                 h.setQuick(j, n - 1, h.getQuick(j, n - 1) / t);
1:                 h.setQuick(j, n, h.getQuick(j, n) / t);
1:               }
1:             }
1:           }
1:         }
1:       }
1:     }
1: 
1:     // Vectors of isolated roots
1: 
1:     for (int i = 0; i < nn; i++) {
0:       if (i < low | i > high) {
1:         for (int j = i; j < nn; j++) {
1:           v.setQuick(i, j, h.getQuick(i, j));
1:         }
1:       }
1:     }
1: 
1:     // Back transformation to get eigenvectors of original matrix
1: 
1:     for (int j = nn - 1; j >= low; j--) {
1:       for (int i = low; i <= high; i++) {
1:         z = 0.0;
1:         for (int k = low; k <= Math.min(j, high); k++) {
0:           z = z + v.getQuick(i, k) * h.getQuick(k, j);
1:         }
1:         v.setQuick(i, j, z);
1:       }
1:     }
1:   }
1: 
1: 
1: 
1:   private static boolean isSymmetric(Matrix a) {
1:     /*
1:     Symmetry flag.
1:     */
1:     int n = a.columnSize();
1: 
1:     boolean isSymmetric = true;
0:     for (int j = 0; (j < n) & isSymmetric; j++) {
0:       for (int i = 0; (i < n) & isSymmetric; i++) {
0:         isSymmetric = (a.getQuick(i, j) == a.getQuick(j, i));
1:       }
1:     }
1:     return isSymmetric;
1:   }
1: }
============================================================================