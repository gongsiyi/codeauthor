1:1cdd095: /*
1:1cdd095:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1cdd095:  * contributor license agreements.  See the NOTICE file distributed with
1:1cdd095:  * this work for additional information regarding copyright ownership.
1:1cdd095:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1cdd095:  * (the "License"); you may not use this file except in compliance with
1:1cdd095:  * the License.  You may obtain a copy of the License at
1:1cdd095:  *
1:1cdd095:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1cdd095:  *
1:1cdd095:  * Unless required by applicable law or agreed to in writing, software
1:1cdd095:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1cdd095:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1cdd095:  * See the License for the specific language governing permissions and
1:1cdd095:  * limitations under the License.
1:1cdd095:  */
1:1cdd095: 
1:a8d3dbd: package org.apache.mahout.math;
1:a8d3dbd: 
1:dc62944: import org.apache.mahout.math.Vector.Element;
1:a8d3dbd: import org.apache.mahout.math.function.DoubleDoubleFunction;
1:a8d3dbd: import org.apache.mahout.math.set.OpenIntHashSet;
1:a8d3dbd: 
1:a8d3dbd: import java.util.Iterator;
1:a8d3dbd: 
1:a8d3dbd: /**
1:8b194c8:  * Abstract class encapsulating different algorithms that perform the Vector operations assign().
1:a8d3dbd:  * x.assign(y, f), for x and y Vectors and f a DoubleDouble function:
1:a8d3dbd:  * - applies the function f to every element in x and y, f(xi, yi)
1:a8d3dbd:  * - assigns xi = f(xi, yi) for all indices i
1:a8d3dbd:  *
1:a8d3dbd:  * The names of variables, methods and classes used here follow the following conventions:
1:a8d3dbd:  * The vector being assigned to (the left hand side) is called this or x.
1:a8d3dbd:  * The right hand side is called that or y.
1:a8d3dbd:  * The function to be applied is called f.
1:a8d3dbd:  *
1:a8d3dbd:  * The different algorithms take into account the different characteristics of vector classes:
1:a8d3dbd:  * - whether the vectors support sequential iteration (isSequential())
1:a8d3dbd:  * - whether the vectors support constant-time additions (isAddConstantTime())
1:a8d3dbd:  * - what the lookup cost is (getLookupCost())
1:a8d3dbd:  * - what the iterator advancement cost is (getIteratorAdvanceCost())
1:a8d3dbd:  *
1:a8d3dbd:  * The names of the actual classes (they're nested in VectorBinaryAssign) describe the used for assignment.
1:a8d3dbd:  * The most important optimization is iterating just through the nonzeros (only possible if f(0, 0) = 0).
1:a8d3dbd:  * There are 4 main possibilities:
1:a8d3dbd:  * - iterating through the nonzeros of just one vector and looking up the corresponding elements in the other
1:a8d3dbd:  * - iterating through the intersection of nonzeros (those indices where both vectors have nonzero values)
1:a8d3dbd:  * - iterating through the union of nonzeros (those indices where at least one of the vectors has a nonzero value)
1:a8d3dbd:  * - iterating through all the elements in some way (either through both at the same time, both one after the other,
1:a8d3dbd:  *   looking up both, looking up just one).
1:a8d3dbd:  * Then, there are two additional sub-possibilities:
1:a8d3dbd:  * - if a new value can be added to x in constant time (isAddConstantTime()), the *Inplace updates are used
1:a8d3dbd:  * - otherwise (really just for SequentialAccessSparseVectors right now), the *Merge updates are used, where
1:a8d3dbd:  *   a sorted list of (index, value) pairs is merged into the vector at the end.
1:a8d3dbd:  *
1:a8d3dbd:  * The internal details are not important and a particular algorithm should generally not be called explicitly.
1:a8d3dbd:  * The best one will be selected through assignBest(), which is itself called through Vector.assign().
1:a8d3dbd:  *
1:a8d3dbd:  * See https://docs.google.com/document/d/1g1PjUuvjyh2LBdq2_rKLIcUiDbeOORA1sCJiSsz-JVU/edit# for a more detailed
1:a8d3dbd:  * explanation.
1:a8d3dbd:  */
1:a8d3dbd: public abstract class VectorBinaryAssign {
1:58cc1ae:   public static final VectorBinaryAssign[] OPERATIONS = {
1:58cc1ae:     new AssignNonzerosIterateThisLookupThat(),
1:58cc1ae:     new AssignNonzerosIterateThatLookupThisMergeUpdates(),
1:58cc1ae:     new AssignNonzerosIterateThatLookupThisInplaceUpdates(),
1:a8d3dbd: 
1:58cc1ae:     new AssignIterateIntersection(),
1:a8d3dbd: 
1:58cc1ae:     new AssignIterateUnionSequentialMergeUpdates(),
1:58cc1ae:     new AssignIterateUnionSequentialInplaceUpdates(),
1:58cc1ae:     new AssignIterateUnionRandomMergeUpdates(),
1:58cc1ae:     new AssignIterateUnionRandomInplaceUpdates(),
1:a8d3dbd: 
1:58cc1ae:     new AssignAllIterateSequentialMergeUpdates(),
1:58cc1ae:     new AssignAllIterateSequentialInplaceUpdates(),
1:58cc1ae:     new AssignAllIterateThisLookupThatMergeUpdates(),
1:58cc1ae:     new AssignAllIterateThisLookupThatInplaceUpdates(),
1:58cc1ae:     new AssignAllIterateThatLookupThisMergeUpdates(),
1:58cc1ae:     new AssignAllIterateThatLookupThisInplaceUpdates(),
1:58cc1ae:     new AssignAllLoopMergeUpdates(),
1:58cc1ae:     new AssignAllLoopInplaceUpdates(),
1:a8d3dbd:   };
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Returns true iff we can use this algorithm to apply f to x and y component-wise and assign the result to x.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract boolean isValid(Vector x, Vector y, DoubleDoubleFunction f);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Estimates the cost of using this algorithm to compute the assignment. The algorithm is assumed to be valid.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract double estimateCost(Vector x, Vector y, DoubleDoubleFunction f);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * Main method that applies f to x and y component-wise assigning the results to x. It returns the modified vector,
1:a8d3dbd:    * x.
1:a8d3dbd:    */
1:a8d3dbd:   public abstract Vector assign(Vector x, Vector y, DoubleDoubleFunction f);
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * The best operation is the least expensive valid one.
1:a8d3dbd:    */
1:a8d3dbd:   public static VectorBinaryAssign getBestOperation(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:     int bestOperationIndex = -1;
1:a8d3dbd:     double bestCost = Double.POSITIVE_INFINITY;
1:58cc1ae:     for (int i = 0; i < OPERATIONS.length; ++i) {
1:58cc1ae:       if (OPERATIONS[i].isValid(x, y, f)) {
1:58cc1ae:         double cost = OPERATIONS[i].estimateCost(x, y, f);
1:a8d3dbd:         if (cost < bestCost) {
1:a8d3dbd:           bestCost = cost;
1:a8d3dbd:           bestOperationIndex = i;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:     }
1:58cc1ae:     return OPERATIONS[bestOperationIndex];
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * This is the method that should be used when assigning. It selects the best algorithm and applies it.
1:a8d3dbd:    * Note that it does NOT invalidate the cached length of the Vector and should only be used through the wrapprs
1:a8d3dbd:    * in AbstractVector.
1:a8d3dbd:    */
1:a8d3dbd:   public static Vector assignBest(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:     return getBestOperation(x, y, f).assign(x, y, f);
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(0, y) = 0, the zeros in x don't matter and we can simply iterate through the nonzeros of x.
1:a8d3dbd:    * To get the corresponding element of y, we perform a lookup.
1:a8d3dbd:    * There are no *Merge or *Inplace versions because in this case x cannot become more dense because of f, meaning
1:a8d3dbd:    * all changes will occur at indices whose values are already nonzero.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignNonzerosIterateThisLookupThat extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return f.isLikeLeftMult();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       for (Element xe : x.nonZeroes()) {
1:a8d3dbd:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(x, 0) = x, the zeros in y don't matter and we can simply iterate through the nonzeros of y.
1:a8d3dbd:    * We get the corresponding element of x through a lookup and update x inplace.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignNonzerosIterateThatLookupThisInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return f.isLikeRightPlus();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       for (Element ye : y.nonZeroes()) {
1:a8d3dbd:         x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(x, 0) = x, the zeros in y don't matter and we can simply iterate through the nonzeros of y.
1:a8d3dbd:    * We get the corresponding element of x through a lookup and update x by merging.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignNonzerosIterateThatLookupThisMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return f.isLikeRightPlus() && y.isSequentialAccess() && !x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:dc62944:       for (Element ye : y.nonZeroes()) {
1:a8d3dbd:         updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(x, 0) = x and f(0, y) = 0 the zeros in x and y don't matter and we can iterate through the nonzeros
1:a8d3dbd:    * in both x and y.
1:a8d3dbd:    * This is only possible if both x and y support sequential access.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignIterateIntersection extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return f.isLikeLeftMult() && f.isLikeRightPlus() && x.isSequentialAccess() && y.isSequentialAccess();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       Vector.Element xe = null;
1:a8d3dbd:       Vector.Element ye = null;
1:a8d3dbd:       boolean advanceThis = true;
1:a8d3dbd:       boolean advanceThat = true;
1:a8d3dbd:       while (true) {
1:a8d3dbd:         if (advanceThis) {
1:a8d3dbd:           if (xi.hasNext()) {
8:a8d3dbd:             xe = xi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             break;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (advanceThat) {
1:a8d3dbd:           if (yi.hasNext()) {
7:a8d3dbd:             ye = yi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             break;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (xe.index() == ye.index()) {
1:a8d3dbd:           xe.set(f.apply(xe.get(), ye.get()));
1:a8d3dbd:           advanceThis = true;
1:a8d3dbd:           advanceThat = true;
1:a8d3dbd:         } else {
1:a8d3dbd:           if (xe.index() < ye.index()) { // f(x, 0) = 0
1:a8d3dbd:             advanceThis = true;
1:a8d3dbd:             advanceThat = false;
1:a8d3dbd:           } else { // f(0, y) = 0
1:a8d3dbd:             advanceThis = false;
1:a8d3dbd:             advanceThat = true;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:a8d3dbd:    * In this case we iterate through them in parallel and update x by merging. Because we're iterating through
1:a8d3dbd:    * both vectors at the same time, x and y need to support sequential access.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignIterateUnionSequentialMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       Vector.Element xe = null;
1:a8d3dbd:       Vector.Element ye = null;
1:a8d3dbd:       boolean advanceThis = true;
1:a8d3dbd:       boolean advanceThat = true;
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:a8d3dbd:       while (true) {
1:a8d3dbd:         if (advanceThis) {
1:a8d3dbd:           if (xi.hasNext()) {
1:a8d3dbd:             xe = xi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             xe = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (advanceThat) {
1:a8d3dbd:           if (yi.hasNext()) {
1:a8d3dbd:             ye = yi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             ye = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:a8d3dbd:           if (xe.index() == ye.index()) {
1:a8d3dbd:             xe.set(f.apply(xe.get(), ye.get()));
1:a8d3dbd:             advanceThis = true;
1:a8d3dbd:             advanceThat = true;
1:a8d3dbd:           } else {
1:a8d3dbd:             if (xe.index() < ye.index()) { // f(x, 0)
1:a8d3dbd:               xe.set(f.apply(xe.get(), 0));
1:a8d3dbd:               advanceThis = true;
1:a8d3dbd:               advanceThat = false;
1:a8d3dbd:             } else {
1:a8d3dbd:               updates.set(ye.index(), f.apply(0, ye.get()));
1:a8d3dbd:               advanceThis = false;
1:a8d3dbd:               advanceThat = true;
1:a8d3dbd:             }
1:a8d3dbd:           }
1:a8d3dbd:         } else if (xe != null) { // just the first one still has nonzeros
1:a8d3dbd:           xe.set(f.apply(xe.get(), 0));
1:a8d3dbd:           advanceThis = true;
1:a8d3dbd:           advanceThat = false;
1:a8d3dbd:         } else if (ye != null) { // just the second one has nonzeros
1:a8d3dbd:           updates.set(ye.index(), f.apply(0, ye.get()));
1:a8d3dbd:           advanceThis = false;
1:a8d3dbd:           advanceThat = true;
1:a8d3dbd:         } else { // we're done, both are empty
1:a8d3dbd:           break;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:a8d3dbd:    * In this case we iterate through them in parallel and update x inplace. Because we're iterating through
1:a8d3dbd:    * both vectors at the same time, x and y need to support sequential access.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignIterateUnionSequentialInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
1:a8d3dbd:       Vector.Element xe = null;
1:a8d3dbd:       Vector.Element ye = null;
1:a8d3dbd:       boolean advanceThis = true;
1:a8d3dbd:       boolean advanceThat = true;
1:a8d3dbd:       while (true) {
1:a8d3dbd:         if (advanceThis) {
1:a8d3dbd:           if (xi.hasNext()) {
1:a8d3dbd:             xe = xi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             xe = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (advanceThat) {
1:a8d3dbd:           if (yi.hasNext()) {
1:a8d3dbd:             ye = yi.next();
1:a8d3dbd:           } else {
1:a8d3dbd:             ye = null;
1:a8d3dbd:           }
1:a8d3dbd:         }
1:a8d3dbd:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:a8d3dbd:           if (xe.index() == ye.index()) {
1:a8d3dbd:             xe.set(f.apply(xe.get(), ye.get()));
1:a8d3dbd:             advanceThis = true;
1:a8d3dbd:             advanceThat = true;
1:a8d3dbd:           } else {
1:a8d3dbd:             if (xe.index() < ye.index()) { // f(x, 0)
1:a8d3dbd:               xe.set(f.apply(xe.get(), 0));
1:a8d3dbd:               advanceThis = true;
1:a8d3dbd:               advanceThat = false;
1:a8d3dbd:             } else {
1:a8d3dbd:               x.setQuick(ye.index(), f.apply(0, ye.get()));
1:a8d3dbd:               advanceThis = false;
1:a8d3dbd:               advanceThat = true;
1:a8d3dbd:             }
1:a8d3dbd:           }
1:a8d3dbd:         } else if (xe != null) { // just the first one still has nonzeros
1:a8d3dbd:           xe.set(f.apply(xe.get(), 0));
1:a8d3dbd:           advanceThis = true;
1:a8d3dbd:           advanceThat = false;
1:a8d3dbd:         } else if (ye != null) { // just the second one has nonzeros
1:a8d3dbd:           x.setQuick(ye.index(), f.apply(0, ye.get()));
1:a8d3dbd:           advanceThis = false;
1:a8d3dbd:           advanceThat = true;
1:a8d3dbd:         } else { // we're done, both are empty
1:a8d3dbd:           break;
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:a8d3dbd:    * In this case, we iterate through the nozeros of x and y alternatively (this works even when one of them
1:a8d3dbd:    * doesn't support sequential access). Since we're merging the results into x, when iterating through y, the
1:a8d3dbd:    * order of iteration matters and y must support sequential access.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignIterateUnionRandomMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !f.isDensifying() && !x.isAddConstantTime() && y.isSequentialAccess();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OpenIntHashSet visited = new OpenIntHashSet();
1:dc62944:       for (Element xe : x.nonZeroes()) {
1:a8d3dbd:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:         visited.add(xe.index());
1:a8d3dbd:       }
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:dc62944:       for (Element ye : y.nonZeroes()) {
1:a8d3dbd:         if (!visited.contains(ye.index())) {
1:a8d3dbd:           updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   /**
1:a8d3dbd:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:a8d3dbd:    * In this case, we iterate through the nozeros of x and y alternatively (this works even when one of them
1:a8d3dbd:    * doesn't support sequential access). Because updates to x are inplace, neither x, nor y need to support
1:a8d3dbd:    * sequential access.
1:a8d3dbd:    */
1:a8d3dbd:   public static class AssignIterateUnionRandomInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !f.isDensifying() && x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:a8d3dbd:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:a8d3dbd:     }
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OpenIntHashSet visited = new OpenIntHashSet();
1:dc62944:       for (Element xe : x.nonZeroes()) {
1:a8d3dbd:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:         visited.add(xe.index());
1:a8d3dbd:       }
1:dc62944:       for (Element ye : y.nonZeroes()) {
1:a8d3dbd:         if (!visited.contains(ye.index())) {
1:a8d3dbd:           x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:         }
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateSequentialMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime() && !x.isDense() && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       Iterator<Vector.Element> xi = x.all().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.all().iterator();
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:a8d3dbd:       while (xi.hasNext() && yi.hasNext()) {
1:4ca6b86:         Element xe = xi.next();
1:a8d3dbd:         updates.set(xe.index(), f.apply(xe.get(), yi.next().get()));
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateSequentialInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime()
1:a8d3dbd:           && !x.isDense() && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       Iterator<Vector.Element> xi = x.all().iterator();
1:dc62944:       Iterator<Vector.Element> yi = y.all().iterator();
1:a8d3dbd:       while (xi.hasNext() && yi.hasNext()) {
1:4ca6b86:         Element xe = xi.next();
1:a8d3dbd:         x.setQuick(xe.index(), f.apply(xe.get(), yi.next().get()));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateThisLookupThatMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !x.isAddConstantTime() && !x.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:dc62944:       for (Element xe : x.all()) {
1:a8d3dbd:         updates.set(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateThisLookupThatInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.isAddConstantTime() && !x.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       for (Element xe : x.all()) {
1:a8d3dbd:         x.setQuick(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateThatLookupThisMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !x.isAddConstantTime() && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:dc62944:       for (Element ye : y.all()) {
1:a8d3dbd:         updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllIterateThatLookupThisInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.isAddConstantTime() && !y.isDense();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:dc62944:       for (Element ye : y.all()) {
1:a8d3dbd:         x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllLoopMergeUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return !x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:a8d3dbd:       for (int i = 0; i < x.size(); ++i) {
1:a8d3dbd:         updates.set(i, f.apply(x.getQuick(i), y.getQuick(i)));
1:a8d3dbd:       }
1:a8d3dbd:       x.mergeUpdates(updates);
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: 
1:a8d3dbd:   public static class AssignAllLoopInplaceUpdates extends VectorBinaryAssign {
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.isAddConstantTime();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:a8d3dbd:     }
1:a8d3dbd: 
1:a8d3dbd:     @Override
1:a8d3dbd:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:a8d3dbd:       for (int i = 0; i < x.size(); ++i) {
1:a8d3dbd:         x.setQuick(i, f.apply(x.getQuick(i), y.getQuick(i)));
1:a8d3dbd:       }
1:a8d3dbd:       return x;
1:a8d3dbd:     }
1:a8d3dbd:   }
1:a8d3dbd: }
============================================================================
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:1cdd095
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
0:   public static final VectorBinaryAssign[] operations = {
/////////////////////////////////////////////////////////////////////////
1:         Element xe = xi.next();
/////////////////////////////////////////////////////////////////////////
1:         Element xe = xi.next();
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:8b194c8
/////////////////////////////////////////////////////////////////////////
1:  * Abstract class encapsulating different algorithms that perform the Vector operations assign().
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
0:  * Abstract class encapsulating different algorithms that perform the Vector OPERATIONS assign().
/////////////////////////////////////////////////////////////////////////
1:   public static final VectorBinaryAssign[] OPERATIONS = {
1:     new AssignNonzerosIterateThisLookupThat(),
1:     new AssignNonzerosIterateThatLookupThisMergeUpdates(),
1:     new AssignNonzerosIterateThatLookupThisInplaceUpdates(),
1:     new AssignIterateIntersection(),
1:     new AssignIterateUnionSequentialMergeUpdates(),
1:     new AssignIterateUnionSequentialInplaceUpdates(),
1:     new AssignIterateUnionRandomMergeUpdates(),
1:     new AssignIterateUnionRandomInplaceUpdates(),
1:     new AssignAllIterateSequentialMergeUpdates(),
1:     new AssignAllIterateSequentialInplaceUpdates(),
1:     new AssignAllIterateThisLookupThatMergeUpdates(),
1:     new AssignAllIterateThisLookupThatInplaceUpdates(),
1:     new AssignAllIterateThatLookupThisMergeUpdates(),
1:     new AssignAllIterateThatLookupThisInplaceUpdates(),
1:     new AssignAllLoopMergeUpdates(),
1:     new AssignAllLoopInplaceUpdates(),
/////////////////////////////////////////////////////////////////////////
1:     for (int i = 0; i < OPERATIONS.length; ++i) {
1:       if (OPERATIONS[i].isValid(x, y, f)) {
1:         double cost = OPERATIONS[i].estimateCost(x, y, f);
1:     return OPERATIONS[bestOperationIndex];
author:Jacob Alexander Mannix
-------------------------------------------------------------------------------
commit:dc62944
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.math.Vector.Element;
/////////////////////////////////////////////////////////////////////////
1:       for (Element xe : x.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element ye : y.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element ye : y.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.nonZeroes().iterator();
1:       Iterator<Vector.Element> yi = y.nonZeroes().iterator();
/////////////////////////////////////////////////////////////////////////
1:       for (Element xe : x.nonZeroes()) {
1:       for (Element ye : y.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element xe : x.nonZeroes()) {
1:       for (Element ye : y.nonZeroes()) {
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.all().iterator();
1:       Iterator<Vector.Element> yi = y.all().iterator();
/////////////////////////////////////////////////////////////////////////
1:       Iterator<Vector.Element> xi = x.all().iterator();
1:       Iterator<Vector.Element> yi = y.all().iterator();
/////////////////////////////////////////////////////////////////////////
1:       for (Element xe : x.all()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element xe : x.all()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element ye : y.all()) {
/////////////////////////////////////////////////////////////////////////
1:       for (Element ye : y.all()) {
author:dfilimon
-------------------------------------------------------------------------------
commit:a8d3dbd
/////////////////////////////////////////////////////////////////////////
1: package org.apache.mahout.math;
1: 
1: import org.apache.mahout.math.function.DoubleDoubleFunction;
1: import org.apache.mahout.math.set.OpenIntHashSet;
1: 
1: import java.util.Iterator;
1: 
1: /**
0:  * Abstract class encapsulating different algorithms that perform the Vector operations assign().
1:  * x.assign(y, f), for x and y Vectors and f a DoubleDouble function:
1:  * - applies the function f to every element in x and y, f(xi, yi)
1:  * - assigns xi = f(xi, yi) for all indices i
1:  *
1:  * The names of variables, methods and classes used here follow the following conventions:
1:  * The vector being assigned to (the left hand side) is called this or x.
1:  * The right hand side is called that or y.
1:  * The function to be applied is called f.
1:  *
1:  * The different algorithms take into account the different characteristics of vector classes:
1:  * - whether the vectors support sequential iteration (isSequential())
1:  * - whether the vectors support constant-time additions (isAddConstantTime())
1:  * - what the lookup cost is (getLookupCost())
1:  * - what the iterator advancement cost is (getIteratorAdvanceCost())
1:  *
1:  * The names of the actual classes (they're nested in VectorBinaryAssign) describe the used for assignment.
1:  * The most important optimization is iterating just through the nonzeros (only possible if f(0, 0) = 0).
1:  * There are 4 main possibilities:
1:  * - iterating through the nonzeros of just one vector and looking up the corresponding elements in the other
1:  * - iterating through the intersection of nonzeros (those indices where both vectors have nonzero values)
1:  * - iterating through the union of nonzeros (those indices where at least one of the vectors has a nonzero value)
1:  * - iterating through all the elements in some way (either through both at the same time, both one after the other,
1:  *   looking up both, looking up just one).
1:  * Then, there are two additional sub-possibilities:
1:  * - if a new value can be added to x in constant time (isAddConstantTime()), the *Inplace updates are used
1:  * - otherwise (really just for SequentialAccessSparseVectors right now), the *Merge updates are used, where
1:  *   a sorted list of (index, value) pairs is merged into the vector at the end.
1:  *
1:  * The internal details are not important and a particular algorithm should generally not be called explicitly.
1:  * The best one will be selected through assignBest(), which is itself called through Vector.assign().
1:  *
1:  * See https://docs.google.com/document/d/1g1PjUuvjyh2LBdq2_rKLIcUiDbeOORA1sCJiSsz-JVU/edit# for a more detailed
1:  * explanation.
1:  */
1: public abstract class VectorBinaryAssign {
0:   public static final VectorBinaryAssign[] operations = new VectorBinaryAssign[] {
0:       new AssignNonzerosIterateThisLookupThat(),
0:       new AssignNonzerosIterateThatLookupThisMergeUpdates(),
0:       new AssignNonzerosIterateThatLookupThisInplaceUpdates(),
1: 
0:       new AssignIterateIntersection(),
1: 
0:       new AssignIterateUnionSequentialMergeUpdates(),
0:       new AssignIterateUnionSequentialInplaceUpdates(),
0:       new AssignIterateUnionRandomMergeUpdates(),
0:       new AssignIterateUnionRandomInplaceUpdates(),
1: 
0:       new AssignAllIterateSequentialMergeUpdates(),
0:       new AssignAllIterateSequentialInplaceUpdates(),
0:       new AssignAllIterateThisLookupThatMergeUpdates(),
0:       new AssignAllIterateThisLookupThatInplaceUpdates(),
0:       new AssignAllIterateThatLookupThisMergeUpdates(),
0:       new AssignAllIterateThatLookupThisInplaceUpdates(),
0:       new AssignAllLoopMergeUpdates(),
0:       new AssignAllLoopInplaceUpdates(),
1:   };
1: 
1:   /**
1:    * Returns true iff we can use this algorithm to apply f to x and y component-wise and assign the result to x.
1:    */
1:   public abstract boolean isValid(Vector x, Vector y, DoubleDoubleFunction f);
1: 
1:   /**
1:    * Estimates the cost of using this algorithm to compute the assignment. The algorithm is assumed to be valid.
1:    */
1:   public abstract double estimateCost(Vector x, Vector y, DoubleDoubleFunction f);
1: 
1:   /**
1:    * Main method that applies f to x and y component-wise assigning the results to x. It returns the modified vector,
1:    * x.
1:    */
1:   public abstract Vector assign(Vector x, Vector y, DoubleDoubleFunction f);
1: 
1:   /**
1:    * The best operation is the least expensive valid one.
1:    */
1:   public static VectorBinaryAssign getBestOperation(Vector x, Vector y, DoubleDoubleFunction f) {
1:     int bestOperationIndex = -1;
1:     double bestCost = Double.POSITIVE_INFINITY;
0:     for (int i = 0; i < operations.length; ++i) {
0:       if (operations[i].isValid(x, y, f)) {
0:         double cost = operations[i].estimateCost(x, y, f);
1:         if (cost < bestCost) {
1:           bestCost = cost;
1:           bestOperationIndex = i;
1:         }
1:       }
1:     }
0:     return operations[bestOperationIndex];
1:   }
1: 
1:   /**
1:    * This is the method that should be used when assigning. It selects the best algorithm and applies it.
1:    * Note that it does NOT invalidate the cached length of the Vector and should only be used through the wrapprs
1:    * in AbstractVector.
1:    */
1:   public static Vector assignBest(Vector x, Vector y, DoubleDoubleFunction f) {
1:     return getBestOperation(x, y, f).assign(x, y, f);
1:   }
1: 
1:   /**
1:    * If f(0, y) = 0, the zeros in x don't matter and we can simply iterate through the nonzeros of x.
1:    * To get the corresponding element of y, we perform a lookup.
1:    * There are no *Merge or *Inplace versions because in this case x cannot become more dense because of f, meaning
1:    * all changes will occur at indices whose values are already nonzero.
1:    */
1:   public static class AssignNonzerosIterateThisLookupThat extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return f.isLikeLeftMult();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Vector.Element xe;
0:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(x, 0) = x, the zeros in y don't matter and we can simply iterate through the nonzeros of y.
1:    * We get the corresponding element of x through a lookup and update x inplace.
1:    */
1:   public static class AssignNonzerosIterateThatLookupThisInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return f.isLikeRightPlus();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
0:       Vector.Element ye;
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(x, 0) = x, the zeros in y don't matter and we can simply iterate through the nonzeros of y.
1:    * We get the corresponding element of x through a lookup and update x by merging.
1:    */
1:   public static class AssignNonzerosIterateThatLookupThisMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return f.isLikeRightPlus() && y.isSequentialAccess() && !x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
0:       Vector.Element ye;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(x, 0) = x and f(0, y) = 0 the zeros in x and y don't matter and we can iterate through the nonzeros
1:    * in both x and y.
1:    * This is only possible if both x and y support sequential access.
1:    */
1:   public static class AssignIterateIntersection extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return f.isLikeLeftMult() && f.isLikeRightPlus() && x.isSequentialAccess() && y.isSequentialAccess();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       Vector.Element xe = null;
1:       Vector.Element ye = null;
1:       boolean advanceThis = true;
1:       boolean advanceThat = true;
1:       while (true) {
1:         if (advanceThis) {
1:           if (xi.hasNext()) {
1:             xe = xi.next();
1:           } else {
1:             break;
1:           }
1:         }
1:         if (advanceThat) {
1:           if (yi.hasNext()) {
1:             ye = yi.next();
1:           } else {
1:             break;
1:           }
1:         }
1:         if (xe.index() == ye.index()) {
1:           xe.set(f.apply(xe.get(), ye.get()));
1:           advanceThis = true;
1:           advanceThat = true;
1:         } else {
1:           if (xe.index() < ye.index()) { // f(x, 0) = 0
1:             advanceThis = true;
1:             advanceThat = false;
1:           } else { // f(0, y) = 0
1:             advanceThis = false;
1:             advanceThat = true;
1:           }
1:         }
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:    * In this case we iterate through them in parallel and update x by merging. Because we're iterating through
1:    * both vectors at the same time, x and y need to support sequential access.
1:    */
1:   public static class AssignIterateUnionSequentialMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       Vector.Element xe = null;
1:       Vector.Element ye = null;
1:       boolean advanceThis = true;
1:       boolean advanceThat = true;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:       while (true) {
1:         if (advanceThis) {
1:           if (xi.hasNext()) {
1:             xe = xi.next();
1:           } else {
1:             xe = null;
1:           }
1:         }
1:         if (advanceThat) {
1:           if (yi.hasNext()) {
1:             ye = yi.next();
1:           } else {
1:             ye = null;
1:           }
1:         }
1:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:           if (xe.index() == ye.index()) {
1:             xe.set(f.apply(xe.get(), ye.get()));
1:             advanceThis = true;
1:             advanceThat = true;
1:           } else {
1:             if (xe.index() < ye.index()) { // f(x, 0)
1:               xe.set(f.apply(xe.get(), 0));
1:               advanceThis = true;
1:               advanceThat = false;
1:             } else {
1:               updates.set(ye.index(), f.apply(0, ye.get()));
1:               advanceThis = false;
1:               advanceThat = true;
1:             }
1:           }
1:         } else if (xe != null) { // just the first one still has nonzeros
1:           xe.set(f.apply(xe.get(), 0));
1:           advanceThis = true;
1:           advanceThat = false;
1:         } else if (ye != null) { // just the second one has nonzeros
1:           updates.set(ye.index(), f.apply(0, ye.get()));
1:           advanceThis = false;
1:           advanceThat = true;
1:         } else { // we're done, both are empty
1:           break;
1:         }
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:    * In this case we iterate through them in parallel and update x inplace. Because we're iterating through
1:    * both vectors at the same time, x and y need to support sequential access.
1:    */
1:   public static class AssignIterateUnionSequentialInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
1:       Vector.Element xe = null;
1:       Vector.Element ye = null;
1:       boolean advanceThis = true;
1:       boolean advanceThat = true;
1:       while (true) {
1:         if (advanceThis) {
1:           if (xi.hasNext()) {
1:             xe = xi.next();
1:           } else {
1:             xe = null;
1:           }
1:         }
1:         if (advanceThat) {
1:           if (yi.hasNext()) {
1:             ye = yi.next();
1:           } else {
1:             ye = null;
1:           }
1:         }
1:         if (xe != null && ye != null) { // both vectors have nonzero elements
1:           if (xe.index() == ye.index()) {
1:             xe.set(f.apply(xe.get(), ye.get()));
1:             advanceThis = true;
1:             advanceThat = true;
1:           } else {
1:             if (xe.index() < ye.index()) { // f(x, 0)
1:               xe.set(f.apply(xe.get(), 0));
1:               advanceThis = true;
1:               advanceThat = false;
1:             } else {
1:               x.setQuick(ye.index(), f.apply(0, ye.get()));
1:               advanceThis = false;
1:               advanceThat = true;
1:             }
1:           }
1:         } else if (xe != null) { // just the first one still has nonzeros
1:           xe.set(f.apply(xe.get(), 0));
1:           advanceThis = true;
1:           advanceThat = false;
1:         } else if (ye != null) { // just the second one has nonzeros
1:           x.setQuick(ye.index(), f.apply(0, ye.get()));
1:           advanceThis = false;
1:           advanceThat = true;
1:         } else { // we're done, both are empty
1:           break;
1:         }
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:    * In this case, we iterate through the nozeros of x and y alternatively (this works even when one of them
1:    * doesn't support sequential access). Since we're merging the results into x, when iterating through y, the
1:    * order of iteration matters and y must support sequential access.
1:    */
1:   public static class AssignIterateUnionRandomMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !f.isDensifying() && !x.isAddConstantTime() && y.isSequentialAccess();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:       OpenIntHashSet visited = new OpenIntHashSet();
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Vector.Element xe;
0:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:         visited.add(xe.index());
1:       }
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
0:       Vector.Element ye;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         if (!visited.contains(ye.index())) {
1:           updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:         }
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   /**
1:    * If f(0, 0) = 0 we can iterate through the nonzeros in either x or y.
1:    * In this case, we iterate through the nozeros of x and y alternatively (this works even when one of them
1:    * doesn't support sequential access). Because updates to x are inplace, neither x, nor y need to support
1:    * sequential access.
1:    */
1:   public static class AssignIterateUnionRandomInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !f.isDensifying() && x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(),
1:           y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());
1:     }
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:       OpenIntHashSet visited = new OpenIntHashSet();
0:       Iterator<Vector.Element> xi = x.iterateNonZero();
0:       Vector.Element xe;
0:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         xe.set(f.apply(xe.get(), y.getQuick(xe.index())));
1:         visited.add(xe.index());
1:       }
0:       Iterator<Vector.Element> yi = y.iterateNonZero();
0:       Vector.Element ye;
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         if (!visited.contains(ye.index())) {
1:           x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:         }
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateSequentialMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime() && !x.isDense() && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element xe;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:       while (xi.hasNext() && yi.hasNext()) {
1:         xe = xi.next();
1:         updates.set(xe.index(), f.apply(xe.get(), yi.next().get()));
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateSequentialInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime()
1:           && !x.isDense() && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element xe;
1:       while (xi.hasNext() && yi.hasNext()) {
1:         xe = xi.next();
1:         x.setQuick(xe.index(), f.apply(xe.get(), yi.next().get()));
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateThisLookupThatMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !x.isAddConstantTime() && !x.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Vector.Element xe;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
0:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         updates.set(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateThisLookupThatInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.isAddConstantTime() && !x.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> xi = x.iterator();
0:       Vector.Element xe;
0:       while (xi.hasNext()) {
1:         xe = xi.next();
1:         x.setQuick(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateThatLookupThisMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !x.isAddConstantTime() && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element ye;
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllIterateThatLookupThisInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.isAddConstantTime() && !y.isDense();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
0:       Iterator<Vector.Element> yi = y.iterator();
0:       Vector.Element ye;
0:       while (yi.hasNext()) {
1:         ye = yi.next();
1:         x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));
1:       }
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllLoopMergeUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return !x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:       OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);
1:       for (int i = 0; i < x.size(); ++i) {
1:         updates.set(i, f.apply(x.getQuick(i), y.getQuick(i)));
1:       }
1:       x.mergeUpdates(updates);
1:       return x;
1:     }
1:   }
1: 
1:   public static class AssignAllLoopInplaceUpdates extends VectorBinaryAssign {
1: 
1:     @Override
1:     public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.isAddConstantTime();
1:     }
1: 
1:     @Override
1:     public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f) {
1:       return x.size() * x.getLookupCost() * y.getLookupCost();
1:     }
1: 
1:     @Override
1:     public Vector assign(Vector x, Vector y, DoubleDoubleFunction f) {
1:       for (int i = 0; i < x.size(); ++i) {
1:         x.setQuick(i, f.apply(x.getQuick(i), y.getQuick(i)));
1:       }
1:       return x;
1:     }
1:   }
1: }
============================================================================