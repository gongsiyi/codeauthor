1:ce3ac79: /**
1:ce3ac79:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:ce3ac79:  * contributor license agreements.  See the NOTICE file distributed with
1:ce3ac79:  * this work for additional information regarding copyright ownership.
1:ce3ac79:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:ce3ac79:  * (the "License"); you may not use this file except in compliance with
1:ce3ac79:  * the License.  You may obtain a copy of the License at
1:ce3ac79:  *
1:ce3ac79:  *     http://www.apache.org/licenses/LICENSE-2.0
1:ce3ac79:  *
1:ce3ac79:  * Unless required by applicable law or agreed to in writing, software
1:ce3ac79:  * distributed under the License is distributed on an "AS IS" BASIS,
1:ce3ac79:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ce3ac79:  * See the License for the specific language governing permissions and
1:ce3ac79:  * limitations under the License.
1:ce3ac79:  */
1:ce3ac79: 
1:ce3ac79: package org.apache.mahout.cf.taste.impl.model.cassandra;
1:ce3ac79: 
1:ce3ac79: import com.google.common.base.Preconditions;
1:ce3ac79: import me.prettyprint.cassandra.model.HColumnImpl;
1:ce3ac79: import me.prettyprint.cassandra.serializers.BytesArraySerializer;
1:ce3ac79: import me.prettyprint.cassandra.serializers.FloatSerializer;
1:ce3ac79: import me.prettyprint.cassandra.serializers.LongSerializer;
1:ce3ac79: import me.prettyprint.cassandra.service.OperationType;
1:ce3ac79: import me.prettyprint.hector.api.Cluster;
1:ce3ac79: import me.prettyprint.hector.api.ConsistencyLevelPolicy;
1:ce3ac79: import me.prettyprint.hector.api.HConsistencyLevel;
1:ce3ac79: import me.prettyprint.hector.api.Keyspace;
1:ce3ac79: import me.prettyprint.hector.api.beans.ColumnSlice;
1:ce3ac79: import me.prettyprint.hector.api.beans.HColumn;
1:ce3ac79: import me.prettyprint.hector.api.factory.HFactory;
1:ce3ac79: import me.prettyprint.hector.api.mutation.Mutator;
1:ce3ac79: import me.prettyprint.hector.api.query.ColumnQuery;
1:ce3ac79: import me.prettyprint.hector.api.query.CountQuery;
1:ce3ac79: import me.prettyprint.hector.api.query.SliceQuery;
1:ce3ac79: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1:ce3ac79: import org.apache.mahout.cf.taste.common.NoSuchUserException;
1:ce3ac79: import org.apache.mahout.cf.taste.common.Refreshable;
1:ce3ac79: import org.apache.mahout.cf.taste.common.TasteException;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.common.Cache;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.common.Retriever;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.model.GenericItemPreferenceArray;
1:ce3ac79: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1:ce3ac79: import org.apache.mahout.cf.taste.model.DataModel;
1:ce3ac79: import org.apache.mahout.cf.taste.model.PreferenceArray;
1:ce3ac79: 
1:ce3ac79: import java.io.Closeable;
1:ce3ac79: import java.util.Collection;
1:ce3ac79: import java.util.List;
1:ce3ac79: import java.util.concurrent.atomic.AtomicReference;
1:ce3ac79: 
1:ce3ac79: /**
1:ce3ac79:  * <p>A {@link DataModel} based on a Cassandra keyspace. By default it uses keyspace "recommender" but this
1:ce3ac79:  * can be configured. Create the keyspace before using this class; this can be done on the Cassandra command
1:ce3ac79:  * line with a command linke {@code create keyspace recommender;}.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>Within the keyspace, this model uses four column families:</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>First, it uses a column family called "users". This is keyed by the user ID as an 8-byte long.
1:ce3ac79:  * It contains a column for every preference the user expresses. The column name is item ID, again as
1:ce3ac79:  * an 8-byte long, and value is a floating point value represnted as an IEEE 32-bit floating poitn value.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>It uses an analogous column family called "items" for the same data, but keyed by item ID rather
1:ce3ac79:  * than user ID. In this column family, column names are user IDs instead.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>It uses a column family called "userIDs" as well, with an identical schema. It has one row under key
1:ce3ac79:  * 0. IT contains a column for every user ID in th emodel. It has no values.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>Finally it also uses an analogous column family "itemIDs" containing item IDs.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>Each of these four column families needs to be created ahead of time. Again the
1:ce3ac79:  * Cassandra CLI can be used to do so, with commands like {@code create column family users;}.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>Note that this thread uses a long-lived Cassandra client which will run until terminated. You
1:ce3ac79:  * must {@link #close()} this implementation when done or the JVM will not terminate.</p>
1:ce3ac79:  *
1:ce3ac79:  * <p>This implementation still relies heavily on reading data into memory and caching,
1:ce3ac79:  * as it remains too data-intensive to be effective even against Cassandra. It will take some time to
1:ce3ac79:  * "warm up" as the first few requests will block loading user and item data into caches. This is still going
1:ce3ac79:  * to send a great deal of query traffic to Cassandra. It would be advisable to employ caching wrapper
1:ce3ac79:  * classes in your implementation, like {@link org.apache.mahout.cf.taste.impl.recommender.CachingRecommender}
1:ce3ac79:  * or {@link org.apache.mahout.cf.taste.impl.similarity.CachingItemSimilarity}.</p>
1:ce3ac79:  */
1:ce3ac79: public final class CassandraDataModel implements DataModel, Closeable {
1:ce3ac79: 
1:ce3ac79:   /** Default Cassandra host. Default: localhost */
1:ce3ac79:   private static final String DEFAULT_HOST = "localhost";
1:ce3ac79: 
1:ce3ac79:   /** Default Cassandra port. Default: 9160 */
1:ce3ac79:   private static final int DEFAULT_PORT = 9160;
1:ce3ac79: 
1:ce3ac79:   /** Default Cassandra keyspace. Default: recommender */
1:ce3ac79:   private static final String DEFAULT_KEYSPACE = "recommender";
1:ce3ac79: 
1:ce3ac79:   static final String USERS_CF = "users";
1:ce3ac79:   static final String ITEMS_CF = "items";
1:ce3ac79:   static final String USER_IDS_CF = "userIDs";
1:ce3ac79:   static final String ITEM_IDS_CF = "itemIDs";
1:ce3ac79:   private static final long ID_ROW_KEY = 0L;
1:ce3ac79:   private static final byte[] EMPTY = new byte[0];
1:ce3ac79: 
1:ce3ac79:   private final Cluster cluster;
1:ce3ac79:   private final Keyspace keyspace;
1:ce3ac79:   private final Cache<Long,PreferenceArray> userCache;
1:ce3ac79:   private final Cache<Long,PreferenceArray> itemCache;
1:ce3ac79:   private final Cache<Long,FastIDSet> itemIDsFromUserCache;
1:ce3ac79:   private final Cache<Long,FastIDSet> userIDsFromItemCache;
1:ce3ac79:   private final AtomicReference<Integer> userCountCache;
1:ce3ac79:   private final AtomicReference<Integer> itemCountCache;
1:ce3ac79: 
1:ce3ac79:   /**
1:ce3ac79:    * Uses the standard Cassandra host and port (localhost:9160), and keyspace name ("recommender").
1:ce3ac79:    */
1:ce3ac79:   public CassandraDataModel() {
1:ce3ac79:     this(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_KEYSPACE);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   /**
1:ce3ac79:    * @param host Cassandra server host name
1:ce3ac79:    * @param port Cassandra server port
1:ce3ac79:    * @param keyspaceName name of Cassandra keyspace to use
1:ce3ac79:    */
1:ce3ac79:   public CassandraDataModel(String host, int port, String keyspaceName) {
1:ce3ac79:     
1:ce3ac79:     Preconditions.checkNotNull(host);
1:cd167f9:     Preconditions.checkArgument(port > 0, "port must be greater then 0!");
1:ce3ac79:     Preconditions.checkNotNull(keyspaceName);
1:ce3ac79: 
1:ce3ac79:     cluster = HFactory.getOrCreateCluster(CassandraDataModel.class.getSimpleName(), host + ':' + port);
1:ce3ac79:     keyspace = HFactory.createKeyspace(keyspaceName, cluster);
1:ce3ac79:     keyspace.setConsistencyLevelPolicy(new OneConsistencyLevelPolicy());
1:ce3ac79: 
1:87c15be:     userCache = new Cache<>(new UserPrefArrayRetriever(), 1 << 20);
1:87c15be:     itemCache = new Cache<>(new ItemPrefArrayRetriever(), 1 << 20);
1:87c15be:     itemIDsFromUserCache = new Cache<>(new ItemIDsFromUserRetriever(), 1 << 20);
1:87c15be:     userIDsFromItemCache = new Cache<>(new UserIDsFromItemRetriever(), 1 << 20);
1:87c15be:     userCountCache = new AtomicReference<>(null);
1:87c15be:     itemCountCache = new AtomicReference<>(null);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public LongPrimitiveIterator getUserIDs() {
1:ce3ac79:     SliceQuery<Long,Long,?> query = buildNoValueSliceQuery(USER_IDS_CF);
1:ce3ac79:     query.setKey(ID_ROW_KEY);
1:ce3ac79:     FastIDSet userIDs = new FastIDSet();
1:ce3ac79:     for (HColumn<Long,?> userIDColumn : query.execute().get().getColumns()) {
1:ce3ac79:       userIDs.add(userIDColumn.getName());
1:ce3ac79:     }
1:ce3ac79:     return userIDs.iterator();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public PreferenceArray getPreferencesFromUser(long userID) throws TasteException {
1:ce3ac79:     return userCache.get(userID);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:ce3ac79:     return itemIDsFromUserCache.get(userID);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public LongPrimitiveIterator getItemIDs() {
1:ce3ac79:     SliceQuery<Long,Long,?> query = buildNoValueSliceQuery(ITEM_IDS_CF);
1:ce3ac79:     query.setKey(ID_ROW_KEY);
1:ce3ac79:     FastIDSet itemIDs = new FastIDSet();
1:ce3ac79:     for (HColumn<Long,?> itemIDColumn : query.execute().get().getColumns()) {
1:ce3ac79:       itemIDs.add(itemIDColumn.getName());
1:ce3ac79:     }
1:ce3ac79:     return itemIDs.iterator();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:ce3ac79:     return itemCache.get(itemID);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public Float getPreferenceValue(long userID, long itemID) {
1:ce3ac79:     ColumnQuery<Long,Long,Float> query =
1:ce3ac79:         HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());
1:ce3ac79:     query.setColumnFamily(USERS_CF);
1:ce3ac79:     query.setKey(userID);
1:ce3ac79:     query.setName(itemID);
1:ce3ac79:     HColumn<Long,Float> column = query.execute().get();
1:ce3ac79:     return column == null ? null : column.getValue();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public Long getPreferenceTime(long userID, long itemID) {
1:ce3ac79:     ColumnQuery<Long,Long,?> query =
1:ce3ac79:         HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());
1:ce3ac79:     query.setColumnFamily(USERS_CF);
1:ce3ac79:     query.setKey(userID);
1:ce3ac79:     query.setName(itemID);
1:ce3ac79:     HColumn<Long,?> result = query.execute().get();
1:ce3ac79:     return result == null ? null : result.getClock();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public int getNumItems() {
1:ce3ac79:     Integer itemCount = itemCountCache.get();
1:ce3ac79:     if (itemCount == null) {
1:ce3ac79:       CountQuery<Long,Long> countQuery =
1:ce3ac79:           HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:ce3ac79:       countQuery.setKey(ID_ROW_KEY);
1:ce3ac79:       countQuery.setColumnFamily(ITEM_IDS_CF);
1:ce3ac79:       countQuery.setRange(null, null, Integer.MAX_VALUE);
1:ce3ac79:       itemCount = countQuery.execute().get();
1:ce3ac79:       itemCountCache.set(itemCount);
1:ce3ac79:     }
1:ce3ac79:     return itemCount;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public int getNumUsers() {
1:ce3ac79:     Integer userCount = userCountCache.get();
1:ce3ac79:     if (userCount == null) {
1:ce3ac79:       CountQuery<Long,Long> countQuery =
1:ce3ac79:           HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:ce3ac79:       countQuery.setKey(ID_ROW_KEY);
1:ce3ac79:       countQuery.setColumnFamily(USER_IDS_CF);
1:ce3ac79:       countQuery.setRange(null, null, Integer.MAX_VALUE);
1:ce3ac79:       userCount = countQuery.execute().get();
1:ce3ac79:       userCountCache.set(userCount);
1:ce3ac79:     }
1:ce3ac79:     return userCount;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:ce3ac79:     /*
1:ce3ac79:     CountQuery<Long,Long> query = HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:ce3ac79:     query.setColumnFamily(ITEMS_CF);
1:ce3ac79:     query.setKey(itemID);
1:ce3ac79:     query.setRange(null, null, Integer.MAX_VALUE);
1:ce3ac79:     return query.execute().get();
1:ce3ac79:      */
1:ce3ac79:     return userIDsFromItemCache.get(itemID).size();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:ce3ac79:     FastIDSet userIDs1 = userIDsFromItemCache.get(itemID1);
1:ce3ac79:     FastIDSet userIDs2 = userIDsFromItemCache.get(itemID2);
1:6d16230:     return userIDs1.size() < userIDs2.size()
1:6d16230:         ? userIDs2.intersectionSize(userIDs1)
1:6d16230:         : userIDs1.intersectionSize(userIDs2);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public void setPreference(long userID, long itemID, float value) {
1:ce3ac79: 
1:ce3ac79:     if (Float.isNaN(value)) {
1:ce3ac79:       value = 1.0f;
1:ce3ac79:     }
1:ce3ac79:     
1:ce3ac79:     long now = System.currentTimeMillis();
1:ce3ac79: 
1:ce3ac79:     Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());
1:ce3ac79: 
1:87c15be:     HColumn<Long,Float> itemForUsers = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());
1:ce3ac79:     itemForUsers.setName(itemID);
1:ce3ac79:     itemForUsers.setClock(now);
1:ce3ac79:     itemForUsers.setValue(value);
1:ce3ac79:     mutator.addInsertion(userID, USERS_CF, itemForUsers);
1:ce3ac79: 
1:87c15be:     HColumn<Long,Float> userForItems = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());
1:ce3ac79:     userForItems.setName(userID);
1:ce3ac79:     userForItems.setClock(now);
1:ce3ac79:     userForItems.setValue(value);
1:ce3ac79:     mutator.addInsertion(itemID, ITEMS_CF, userForItems);
1:ce3ac79: 
1:87c15be:     HColumn<Long,byte[]> userIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());
1:ce3ac79:     userIDs.setName(userID);
1:ce3ac79:     userIDs.setClock(now);
1:ce3ac79:     userIDs.setValue(EMPTY);
1:ce3ac79:     mutator.addInsertion(ID_ROW_KEY, USER_IDS_CF, userIDs);
1:ce3ac79: 
1:87c15be:     HColumn<Long,byte[]> itemIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());
1:ce3ac79:     itemIDs.setName(itemID);
1:ce3ac79:     itemIDs.setClock(now);
1:ce3ac79:     itemIDs.setValue(EMPTY);
1:ce3ac79:     mutator.addInsertion(ID_ROW_KEY, ITEM_IDS_CF, itemIDs);
1:ce3ac79: 
1:ce3ac79:     mutator.execute();
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public void removePreference(long userID, long itemID) {
1:ce3ac79:     Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());
1:ce3ac79:     mutator.addDeletion(userID, USERS_CF, itemID, LongSerializer.get());
1:ce3ac79:     mutator.addDeletion(itemID, ITEMS_CF, userID, LongSerializer.get());
1:ce3ac79:     mutator.execute();
1:ce3ac79:     // Not deleting from userIDs, itemIDs though
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   /**
1:ce3ac79:    * @return true
1:ce3ac79:    */
1:ce3ac79:   @Override
1:ce3ac79:   public boolean hasPreferenceValues() {
1:ce3ac79:     return true;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   /**
1:ce3ac79:    * @return Float#NaN
1:ce3ac79:    */
1:ce3ac79:   @Override
1:ce3ac79:   public float getMaxPreference() {
1:ce3ac79:     return Float.NaN;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   /**
1:ce3ac79:    * @return Float#NaN
1:ce3ac79:    */
1:ce3ac79:   @Override
1:ce3ac79:   public float getMinPreference() {
1:ce3ac79:     return Float.NaN;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
1:ce3ac79:     userCache.clear();
1:df391ca:     itemCache.clear();
1:df391ca:     userIDsFromItemCache.clear();
1:df391ca:     itemIDsFromUserCache.clear();
1:df391ca:     userCountCache.set(null);
1:df391ca:     itemCountCache.set(null);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public String toString() {
1:ce3ac79:     return "CassandraDataModel[" + keyspace + ']';
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   @Override
1:ce3ac79:   public void close() {
1:ce3ac79:     HFactory.shutdownCluster(cluster);
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79: 
1:ce3ac79:   private SliceQuery<Long,Long,byte[]> buildNoValueSliceQuery(String cf) {
1:ce3ac79:     SliceQuery<Long,Long,byte[]> query =
1:ce3ac79:         HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());
1:ce3ac79:     query.setColumnFamily(cf);
1:ce3ac79:     query.setRange(null, null, false, Integer.MAX_VALUE);
1:ce3ac79:     return query;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   private SliceQuery<Long,Long,Float> buildValueSliceQuery(String cf) {
1:ce3ac79:     SliceQuery<Long,Long,Float> query =
1:ce3ac79:         HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());
1:ce3ac79:     query.setColumnFamily(cf);
1:ce3ac79:     query.setRange(null, null, false, Integer.MAX_VALUE);
1:ce3ac79:     return query;
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79: 
1:ce3ac79:   private static final class OneConsistencyLevelPolicy implements ConsistencyLevelPolicy {
1:ce3ac79:     @Override
1:ce3ac79:     public HConsistencyLevel get(OperationType op) {
1:ce3ac79:       return HConsistencyLevel.ONE;
1:ce3ac79:     }
1:ce3ac79: 
1:ce3ac79:     @Override
1:ce3ac79:     public HConsistencyLevel get(OperationType op, String cfName) {
1:ce3ac79:       return HConsistencyLevel.ONE;
1:ce3ac79:     }
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   private final class UserPrefArrayRetriever implements Retriever<Long, PreferenceArray> {
1:ce3ac79:     @Override
1:ce3ac79:     public PreferenceArray get(Long userID) throws TasteException {
1:ce3ac79:       SliceQuery<Long,Long,Float> query = buildValueSliceQuery(USERS_CF);
1:ce3ac79:       query.setKey(userID);
1:ce3ac79: 
1:ce3ac79:       ColumnSlice<Long,Float> result = query.execute().get();
1:ce3ac79:       if (result == null) {
1:ce3ac79:         throw new NoSuchUserException(userID);
1:ce3ac79:       }
1:ce3ac79:       List<HColumn<Long,Float>> itemIDColumns = result.getColumns();
1:ce3ac79:       if (itemIDColumns.isEmpty()) {
1:ce3ac79:         throw new NoSuchUserException(userID);
1:ce3ac79:       }
1:ce3ac79:       int size = itemIDColumns.size();
1:ce3ac79:       PreferenceArray prefs = new GenericUserPreferenceArray(size);
1:ce3ac79:       prefs.setUserID(0, userID);
1:ce3ac79:       for (int i = 0; i < size; i++) {
1:ce3ac79:         HColumn<Long,Float> itemIDColumn = itemIDColumns.get(i);
1:ce3ac79:         prefs.setItemID(i, itemIDColumn.getName());
1:ce3ac79:         prefs.setValue(i, itemIDColumn.getValue());
1:ce3ac79:       }
1:ce3ac79:       return prefs;
1:ce3ac79:     }
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   private final class ItemPrefArrayRetriever implements Retriever<Long, PreferenceArray> {
1:ce3ac79:     @Override
1:ce3ac79:     public PreferenceArray get(Long itemID) throws TasteException {
1:ce3ac79:       SliceQuery<Long,Long,Float> query = buildValueSliceQuery(ITEMS_CF);
1:ce3ac79:       query.setKey(itemID);
1:ce3ac79:       ColumnSlice<Long,Float> result = query.execute().get();
1:ce3ac79:       if (result == null) {
1:ce3ac79:         throw new NoSuchItemException(itemID);
1:ce3ac79:       }
1:ce3ac79:       List<HColumn<Long,Float>> userIDColumns = result.getColumns();
1:ce3ac79:       if (userIDColumns.isEmpty()) {
1:ce3ac79:         throw new NoSuchItemException(itemID);
1:ce3ac79:       }
1:ce3ac79:       int size = userIDColumns.size();
1:ce3ac79:       PreferenceArray prefs = new GenericItemPreferenceArray(size);
1:ce3ac79:       prefs.setItemID(0, itemID);
1:ce3ac79:       for (int i = 0; i < size; i++) {
1:ce3ac79:         HColumn<Long,Float> userIDColumn = userIDColumns.get(i);
1:ce3ac79:         prefs.setUserID(i, userIDColumn.getName());
1:ce3ac79:         prefs.setValue(i, userIDColumn.getValue());
1:ce3ac79:       }
1:ce3ac79:       return prefs;
1:ce3ac79:     }
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   private final class UserIDsFromItemRetriever implements Retriever<Long, FastIDSet> {
1:ce3ac79:     @Override
1:ce3ac79:     public FastIDSet get(Long itemID) throws TasteException {
1:ce3ac79:       SliceQuery<Long,Long,byte[]> query = buildNoValueSliceQuery(ITEMS_CF);
1:ce3ac79:       query.setKey(itemID);
1:ce3ac79:       ColumnSlice<Long,byte[]> result = query.execute().get();
1:ce3ac79:       if (result == null) {
1:ce3ac79:         throw new NoSuchItemException(itemID);
1:ce3ac79:       }
1:ce3ac79:       List<HColumn<Long,byte[]>> columns = result.getColumns();
1:ce3ac79:       FastIDSet userIDs = new FastIDSet(columns.size());
1:ce3ac79:       for (HColumn<Long,?> userIDColumn : columns) {
1:ce3ac79:         userIDs.add(userIDColumn.getName());
1:ce3ac79:       }
1:ce3ac79:       return userIDs;
1:ce3ac79:     }
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79:   private final class ItemIDsFromUserRetriever implements Retriever<Long, FastIDSet> {
1:ce3ac79:     @Override
1:ce3ac79:     public FastIDSet get(Long userID) throws TasteException {
1:ce3ac79:       SliceQuery<Long,Long,byte[]> query = buildNoValueSliceQuery(USERS_CF);
1:ce3ac79:       query.setKey(userID);
1:ce3ac79:       FastIDSet itemIDs = new FastIDSet();
1:ce3ac79:       ColumnSlice<Long,byte[]> result = query.execute().get();
1:ce3ac79:       if (result == null) {
1:ce3ac79:         throw new NoSuchUserException(userID);
1:ce3ac79:       }
1:ce3ac79:       List<HColumn<Long,byte[]>> columns = result.getColumns();
1:ce3ac79:       if (columns.isEmpty()) {
1:ce3ac79:         throw new NoSuchUserException(userID);
1:ce3ac79:       }
1:ce3ac79:       for (HColumn<Long,?> itemIDColumn : columns) {
1:ce3ac79:         itemIDs.add(itemIDColumn.getName());
1:ce3ac79:       }
1:ce3ac79:       return itemIDs;
1:ce3ac79:     }
1:ce3ac79:   }
1:ce3ac79: 
1:ce3ac79: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:87c15be
/////////////////////////////////////////////////////////////////////////
1:     userCache = new Cache<>(new UserPrefArrayRetriever(), 1 << 20);
1:     itemCache = new Cache<>(new ItemPrefArrayRetriever(), 1 << 20);
1:     itemIDsFromUserCache = new Cache<>(new ItemIDsFromUserRetriever(), 1 << 20);
1:     userIDsFromItemCache = new Cache<>(new UserIDsFromItemRetriever(), 1 << 20);
1:     userCountCache = new AtomicReference<>(null);
1:     itemCountCache = new AtomicReference<>(null);
/////////////////////////////////////////////////////////////////////////
1:     HColumn<Long,Float> itemForUsers = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());
1:     HColumn<Long,Float> userForItems = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());
1:     HColumn<Long,byte[]> userIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());
1:     HColumn<Long,byte[]> itemIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());
author:smarthi
-------------------------------------------------------------------------------
commit:cd167f9
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(port > 0, "port must be greater then 0!");
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:     return userIDs1.size() < userIDs2.size()
1:         ? userIDs2.intersectionSize(userIDs1)
1:         : userIDs1.intersectionSize(userIDs2);
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:7bfa45c
/////////////////////////////////////////////////////////////////////////
0:     return userIDs1.size() < userIDs2.size() ?
0:         userIDs2.intersectionSize(userIDs1) :
0:         userIDs1.intersectionSize(userIDs2);
commit:df391ca
/////////////////////////////////////////////////////////////////////////
1:     itemCache.clear();
1:     userIDsFromItemCache.clear();
1:     itemIDsFromUserCache.clear();
1:     userCountCache.set(null);
1:     itemCountCache.set(null);
commit:ce3ac79
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.impl.model.cassandra;
1: 
1: import com.google.common.base.Preconditions;
1: import me.prettyprint.cassandra.model.HColumnImpl;
1: import me.prettyprint.cassandra.serializers.BytesArraySerializer;
1: import me.prettyprint.cassandra.serializers.FloatSerializer;
1: import me.prettyprint.cassandra.serializers.LongSerializer;
1: import me.prettyprint.cassandra.service.OperationType;
1: import me.prettyprint.hector.api.Cluster;
1: import me.prettyprint.hector.api.ConsistencyLevelPolicy;
1: import me.prettyprint.hector.api.HConsistencyLevel;
1: import me.prettyprint.hector.api.Keyspace;
1: import me.prettyprint.hector.api.beans.ColumnSlice;
1: import me.prettyprint.hector.api.beans.HColumn;
1: import me.prettyprint.hector.api.factory.HFactory;
1: import me.prettyprint.hector.api.mutation.Mutator;
1: import me.prettyprint.hector.api.query.ColumnQuery;
1: import me.prettyprint.hector.api.query.CountQuery;
1: import me.prettyprint.hector.api.query.SliceQuery;
1: import org.apache.mahout.cf.taste.common.NoSuchItemException;
1: import org.apache.mahout.cf.taste.common.NoSuchUserException;
1: import org.apache.mahout.cf.taste.common.Refreshable;
1: import org.apache.mahout.cf.taste.common.TasteException;
1: import org.apache.mahout.cf.taste.impl.common.Cache;
1: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1: import org.apache.mahout.cf.taste.impl.common.Retriever;
1: import org.apache.mahout.cf.taste.impl.model.GenericItemPreferenceArray;
1: import org.apache.mahout.cf.taste.impl.model.GenericUserPreferenceArray;
1: import org.apache.mahout.cf.taste.model.DataModel;
1: import org.apache.mahout.cf.taste.model.PreferenceArray;
1: 
1: import java.io.Closeable;
1: import java.util.Collection;
1: import java.util.List;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: /**
1:  * <p>A {@link DataModel} based on a Cassandra keyspace. By default it uses keyspace "recommender" but this
1:  * can be configured. Create the keyspace before using this class; this can be done on the Cassandra command
1:  * line with a command linke {@code create keyspace recommender;}.</p>
1:  *
1:  * <p>Within the keyspace, this model uses four column families:</p>
1:  *
1:  * <p>First, it uses a column family called "users". This is keyed by the user ID as an 8-byte long.
1:  * It contains a column for every preference the user expresses. The column name is item ID, again as
1:  * an 8-byte long, and value is a floating point value represnted as an IEEE 32-bit floating poitn value.</p>
1:  *
1:  * <p>It uses an analogous column family called "items" for the same data, but keyed by item ID rather
1:  * than user ID. In this column family, column names are user IDs instead.</p>
1:  *
1:  * <p>It uses a column family called "userIDs" as well, with an identical schema. It has one row under key
1:  * 0. IT contains a column for every user ID in th emodel. It has no values.</p>
1:  *
1:  * <p>Finally it also uses an analogous column family "itemIDs" containing item IDs.</p>
1:  *
1:  * <p>Each of these four column families needs to be created ahead of time. Again the
1:  * Cassandra CLI can be used to do so, with commands like {@code create column family users;}.</p>
1:  *
1:  * <p>Note that this thread uses a long-lived Cassandra client which will run until terminated. You
1:  * must {@link #close()} this implementation when done or the JVM will not terminate.</p>
1:  *
1:  * <p>This implementation still relies heavily on reading data into memory and caching,
1:  * as it remains too data-intensive to be effective even against Cassandra. It will take some time to
1:  * "warm up" as the first few requests will block loading user and item data into caches. This is still going
1:  * to send a great deal of query traffic to Cassandra. It would be advisable to employ caching wrapper
1:  * classes in your implementation, like {@link org.apache.mahout.cf.taste.impl.recommender.CachingRecommender}
1:  * or {@link org.apache.mahout.cf.taste.impl.similarity.CachingItemSimilarity}.</p>
1:  */
1: public final class CassandraDataModel implements DataModel, Closeable {
1: 
1:   /** Default Cassandra host. Default: localhost */
1:   private static final String DEFAULT_HOST = "localhost";
1: 
1:   /** Default Cassandra port. Default: 9160 */
1:   private static final int DEFAULT_PORT = 9160;
1: 
1:   /** Default Cassandra keyspace. Default: recommender */
1:   private static final String DEFAULT_KEYSPACE = "recommender";
1: 
1:   static final String USERS_CF = "users";
1:   static final String ITEMS_CF = "items";
1:   static final String USER_IDS_CF = "userIDs";
1:   static final String ITEM_IDS_CF = "itemIDs";
1:   private static final long ID_ROW_KEY = 0L;
1:   private static final byte[] EMPTY = new byte[0];
1: 
1:   private final Cluster cluster;
1:   private final Keyspace keyspace;
1:   private final Cache<Long,PreferenceArray> userCache;
1:   private final Cache<Long,PreferenceArray> itemCache;
1:   private final Cache<Long,FastIDSet> itemIDsFromUserCache;
1:   private final Cache<Long,FastIDSet> userIDsFromItemCache;
1:   private final AtomicReference<Integer> userCountCache;
1:   private final AtomicReference<Integer> itemCountCache;
1: 
1:   /**
1:    * Uses the standard Cassandra host and port (localhost:9160), and keyspace name ("recommender").
1:    */
1:   public CassandraDataModel() {
1:     this(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_KEYSPACE);
1:   }
1: 
1:   /**
1:    * @param host Cassandra server host name
1:    * @param port Cassandra server port
1:    * @param keyspaceName name of Cassandra keyspace to use
1:    */
1:   public CassandraDataModel(String host, int port, String keyspaceName) {
1:     
1:     Preconditions.checkNotNull(host);
0:     Preconditions.checkArgument(port > 0);
1:     Preconditions.checkNotNull(keyspaceName);
1: 
1:     cluster = HFactory.getOrCreateCluster(CassandraDataModel.class.getSimpleName(), host + ':' + port);
1:     keyspace = HFactory.createKeyspace(keyspaceName, cluster);
1:     keyspace.setConsistencyLevelPolicy(new OneConsistencyLevelPolicy());
1: 
0:     userCache = new Cache<Long,PreferenceArray>(new UserPrefArrayRetriever(), 1 << 20);
0:     itemCache = new Cache<Long,PreferenceArray>(new ItemPrefArrayRetriever(), 1 << 20);
0:     itemIDsFromUserCache = new Cache<Long,FastIDSet>(new ItemIDsFromUserRetriever(), 1 << 20);
0:     userIDsFromItemCache = new Cache<Long,FastIDSet>(new UserIDsFromItemRetriever(), 1 << 20);
0:     userCountCache = new AtomicReference<Integer>(null);
0:     itemCountCache = new AtomicReference<Integer>(null);
1:   }
1: 
1:   @Override
1:   public LongPrimitiveIterator getUserIDs() {
1:     SliceQuery<Long,Long,?> query = buildNoValueSliceQuery(USER_IDS_CF);
1:     query.setKey(ID_ROW_KEY);
1:     FastIDSet userIDs = new FastIDSet();
1:     for (HColumn<Long,?> userIDColumn : query.execute().get().getColumns()) {
1:       userIDs.add(userIDColumn.getName());
1:     }
1:     return userIDs.iterator();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesFromUser(long userID) throws TasteException {
1:     return userCache.get(userID);
1:   }
1: 
1:   @Override
1:   public FastIDSet getItemIDsFromUser(long userID) throws TasteException {
1:     return itemIDsFromUserCache.get(userID);
1:   }
1: 
1:   @Override
1:   public LongPrimitiveIterator getItemIDs() {
1:     SliceQuery<Long,Long,?> query = buildNoValueSliceQuery(ITEM_IDS_CF);
1:     query.setKey(ID_ROW_KEY);
1:     FastIDSet itemIDs = new FastIDSet();
1:     for (HColumn<Long,?> itemIDColumn : query.execute().get().getColumns()) {
1:       itemIDs.add(itemIDColumn.getName());
1:     }
1:     return itemIDs.iterator();
1:   }
1: 
1:   @Override
1:   public PreferenceArray getPreferencesForItem(long itemID) throws TasteException {
1:     return itemCache.get(itemID);
1:   }
1: 
1:   @Override
1:   public Float getPreferenceValue(long userID, long itemID) {
1:     ColumnQuery<Long,Long,Float> query =
1:         HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());
1:     query.setColumnFamily(USERS_CF);
1:     query.setKey(userID);
1:     query.setName(itemID);
1:     HColumn<Long,Float> column = query.execute().get();
1:     return column == null ? null : column.getValue();
1:   }
1: 
1:   @Override
1:   public Long getPreferenceTime(long userID, long itemID) {
1:     ColumnQuery<Long,Long,?> query =
1:         HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());
1:     query.setColumnFamily(USERS_CF);
1:     query.setKey(userID);
1:     query.setName(itemID);
1:     HColumn<Long,?> result = query.execute().get();
1:     return result == null ? null : result.getClock();
1:   }
1: 
1:   @Override
1:   public int getNumItems() {
1:     Integer itemCount = itemCountCache.get();
1:     if (itemCount == null) {
1:       CountQuery<Long,Long> countQuery =
1:           HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:       countQuery.setKey(ID_ROW_KEY);
1:       countQuery.setColumnFamily(ITEM_IDS_CF);
1:       countQuery.setRange(null, null, Integer.MAX_VALUE);
1:       itemCount = countQuery.execute().get();
1:       itemCountCache.set(itemCount);
1:     }
1:     return itemCount;
1:   }
1: 
1:   @Override
1:   public int getNumUsers() {
1:     Integer userCount = userCountCache.get();
1:     if (userCount == null) {
1:       CountQuery<Long,Long> countQuery =
1:           HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:       countQuery.setKey(ID_ROW_KEY);
1:       countQuery.setColumnFamily(USER_IDS_CF);
1:       countQuery.setRange(null, null, Integer.MAX_VALUE);
1:       userCount = countQuery.execute().get();
1:       userCountCache.set(userCount);
1:     }
1:     return userCount;
1:   }
1: 
1:   @Override
1:   public int getNumUsersWithPreferenceFor(long itemID) throws TasteException {
1:     /*
1:     CountQuery<Long,Long> query = HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());
1:     query.setColumnFamily(ITEMS_CF);
1:     query.setKey(itemID);
1:     query.setRange(null, null, Integer.MAX_VALUE);
1:     return query.execute().get();
1:      */
1:     return userIDsFromItemCache.get(itemID).size();
1:   }
1: 
1:   @Override
1:   public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException {
1:     FastIDSet userIDs1 = userIDsFromItemCache.get(itemID1);
1:     FastIDSet userIDs2 = userIDsFromItemCache.get(itemID2);
0:     return userIDs1.intersectionSize(userIDs2);
1:   }
1: 
1:   @Override
1:   public void setPreference(long userID, long itemID, float value) {
1: 
1:     if (Float.isNaN(value)) {
1:       value = 1.0f;
1:     }
1:     
1:     long now = System.currentTimeMillis();
1: 
1:     Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());
1: 
0:     HColumn<Long,Float> itemForUsers = new HColumnImpl<Long,Float>(LongSerializer.get(), FloatSerializer.get());
1:     itemForUsers.setName(itemID);
1:     itemForUsers.setClock(now);
1:     itemForUsers.setValue(value);
1:     mutator.addInsertion(userID, USERS_CF, itemForUsers);
1: 
0:     HColumn<Long,Float> userForItems = new HColumnImpl<Long,Float>(LongSerializer.get(), FloatSerializer.get());
1:     userForItems.setName(userID);
1:     userForItems.setClock(now);
1:     userForItems.setValue(value);
1:     mutator.addInsertion(itemID, ITEMS_CF, userForItems);
1: 
0:     HColumn<Long,byte[]> userIDs = new HColumnImpl<Long,byte[]>(LongSerializer.get(), BytesArraySerializer.get());
1:     userIDs.setName(userID);
1:     userIDs.setClock(now);
1:     userIDs.setValue(EMPTY);
1:     mutator.addInsertion(ID_ROW_KEY, USER_IDS_CF, userIDs);
1: 
0:     HColumn<Long,byte[]> itemIDs = new HColumnImpl<Long,byte[]>(LongSerializer.get(), BytesArraySerializer.get());
1:     itemIDs.setName(itemID);
1:     itemIDs.setClock(now);
1:     itemIDs.setValue(EMPTY);
1:     mutator.addInsertion(ID_ROW_KEY, ITEM_IDS_CF, itemIDs);
1: 
1:     mutator.execute();
1:   }
1: 
1:   @Override
1:   public void removePreference(long userID, long itemID) {
1:     Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());
1:     mutator.addDeletion(userID, USERS_CF, itemID, LongSerializer.get());
1:     mutator.addDeletion(itemID, ITEMS_CF, userID, LongSerializer.get());
1:     mutator.execute();
1:     // Not deleting from userIDs, itemIDs though
1:   }
1: 
1:   /**
1:    * @return true
1:    */
1:   @Override
1:   public boolean hasPreferenceValues() {
1:     return true;
1:   }
1: 
1:   /**
1:    * @return Float#NaN
1:    */
1:   @Override
1:   public float getMaxPreference() {
1:     return Float.NaN;
1:   }
1: 
1:   /**
1:    * @return Float#NaN
1:    */
1:   @Override
1:   public float getMinPreference() {
1:     return Float.NaN;
1:   }
1: 
1:   @Override
1:   public void refresh(Collection<Refreshable> alreadyRefreshed) {
1:     userCache.clear();
1:   }
1: 
1:   @Override
1:   public String toString() {
1:     return "CassandraDataModel[" + keyspace + ']';
1:   }
1: 
1:   @Override
1:   public void close() {
1:     HFactory.shutdownCluster(cluster);
1:   }
1: 
1: 
1:   private SliceQuery<Long,Long,byte[]> buildNoValueSliceQuery(String cf) {
1:     SliceQuery<Long,Long,byte[]> query =
1:         HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());
1:     query.setColumnFamily(cf);
1:     query.setRange(null, null, false, Integer.MAX_VALUE);
1:     return query;
1:   }
1: 
1:   private SliceQuery<Long,Long,Float> buildValueSliceQuery(String cf) {
1:     SliceQuery<Long,Long,Float> query =
1:         HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());
1:     query.setColumnFamily(cf);
1:     query.setRange(null, null, false, Integer.MAX_VALUE);
1:     return query;
1:   }
1: 
1: 
1:   private static final class OneConsistencyLevelPolicy implements ConsistencyLevelPolicy {
1:     @Override
1:     public HConsistencyLevel get(OperationType op) {
1:       return HConsistencyLevel.ONE;
1:     }
1: 
1:     @Override
1:     public HConsistencyLevel get(OperationType op, String cfName) {
1:       return HConsistencyLevel.ONE;
1:     }
1:   }
1: 
1:   private final class UserPrefArrayRetriever implements Retriever<Long, PreferenceArray> {
1:     @Override
1:     public PreferenceArray get(Long userID) throws TasteException {
1:       SliceQuery<Long,Long,Float> query = buildValueSliceQuery(USERS_CF);
1:       query.setKey(userID);
1: 
1:       ColumnSlice<Long,Float> result = query.execute().get();
1:       if (result == null) {
1:         throw new NoSuchUserException(userID);
1:       }
1:       List<HColumn<Long,Float>> itemIDColumns = result.getColumns();
1:       if (itemIDColumns.isEmpty()) {
1:         throw new NoSuchUserException(userID);
1:       }
1:       int size = itemIDColumns.size();
1:       PreferenceArray prefs = new GenericUserPreferenceArray(size);
1:       prefs.setUserID(0, userID);
1:       for (int i = 0; i < size; i++) {
1:         HColumn<Long,Float> itemIDColumn = itemIDColumns.get(i);
1:         prefs.setItemID(i, itemIDColumn.getName());
1:         prefs.setValue(i, itemIDColumn.getValue());
1:       }
1:       return prefs;
1:     }
1:   }
1: 
1:   private final class ItemPrefArrayRetriever implements Retriever<Long, PreferenceArray> {
1:     @Override
1:     public PreferenceArray get(Long itemID) throws TasteException {
1:       SliceQuery<Long,Long,Float> query = buildValueSliceQuery(ITEMS_CF);
1:       query.setKey(itemID);
1:       ColumnSlice<Long,Float> result = query.execute().get();
1:       if (result == null) {
1:         throw new NoSuchItemException(itemID);
1:       }
1:       List<HColumn<Long,Float>> userIDColumns = result.getColumns();
1:       if (userIDColumns.isEmpty()) {
1:         throw new NoSuchItemException(itemID);
1:       }
1:       int size = userIDColumns.size();
1:       PreferenceArray prefs = new GenericItemPreferenceArray(size);
1:       prefs.setItemID(0, itemID);
1:       for (int i = 0; i < size; i++) {
1:         HColumn<Long,Float> userIDColumn = userIDColumns.get(i);
1:         prefs.setUserID(i, userIDColumn.getName());
1:         prefs.setValue(i, userIDColumn.getValue());
1:       }
1:       return prefs;
1:     }
1:   }
1: 
1:   private final class UserIDsFromItemRetriever implements Retriever<Long, FastIDSet> {
1:     @Override
1:     public FastIDSet get(Long itemID) throws TasteException {
1:       SliceQuery<Long,Long,byte[]> query = buildNoValueSliceQuery(ITEMS_CF);
1:       query.setKey(itemID);
1:       ColumnSlice<Long,byte[]> result = query.execute().get();
1:       if (result == null) {
1:         throw new NoSuchItemException(itemID);
1:       }
1:       List<HColumn<Long,byte[]>> columns = result.getColumns();
1:       FastIDSet userIDs = new FastIDSet(columns.size());
1:       for (HColumn<Long,?> userIDColumn : columns) {
1:         userIDs.add(userIDColumn.getName());
1:       }
1:       return userIDs;
1:     }
1:   }
1: 
1:   private final class ItemIDsFromUserRetriever implements Retriever<Long, FastIDSet> {
1:     @Override
1:     public FastIDSet get(Long userID) throws TasteException {
1:       SliceQuery<Long,Long,byte[]> query = buildNoValueSliceQuery(USERS_CF);
1:       query.setKey(userID);
1:       FastIDSet itemIDs = new FastIDSet();
1:       ColumnSlice<Long,byte[]> result = query.execute().get();
1:       if (result == null) {
1:         throw new NoSuchUserException(userID);
1:       }
1:       List<HColumn<Long,byte[]>> columns = result.getColumns();
1:       if (columns.isEmpty()) {
1:         throw new NoSuchUserException(userID);
1:       }
1:       for (HColumn<Long,?> itemIDColumn : columns) {
1:         itemIDs.add(itemIDColumn.getName());
1:       }
1:       return itemIDs;
1:     }
1:   }
1: 
1: }
============================================================================