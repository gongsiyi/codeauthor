1:35fa73f: /**
1:35fa73f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:35fa73f:  * contributor license agreements.  See the NOTICE file distributed with
1:35fa73f:  * this work for additional information regarding copyright ownership.
1:35fa73f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:35fa73f:  * (the "License"); you may not use this file except in compliance with
1:35fa73f:  * the License.  You may obtain a copy of the License at
1:35fa73f:  *
1:35fa73f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:35fa73f:  *
1:35fa73f:  * Unless required by applicable law or agreed to in writing, software
1:35fa73f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:35fa73f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:35fa73f:  * See the License for the specific language governing permissions and
1:35fa73f:  * limitations under the License.
1:35fa73f:  */
1:35fa73f: /*
1:35fa73f: Copyright 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:35fa73f: */
1:35fa73f: package org.apache.mahout.math.set;
1:35fa73f: 
1:35fa73f: import org.apache.mahout.math.PersistentObject;
1:35fa73f: import org.apache.mahout.math.map.PrimeFinder;
1:35fa73f: 
1:35fa73f: public abstract class AbstractSet extends PersistentObject {
1:35fa73f:   //public static boolean debug = false; // debug only
1:35fa73f: 
1:35fa73f:   /** The number of distinct associations in the map; its "size()". */
1:35fa73f:   protected int distinct;
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * The table capacity c=table.length always satisfies the invariant <tt>c * minLoadFactor <= s <= c *
1:35fa73f:    * maxLoadFactor</tt>, where s=size() is the number of associations currently contained. The term "c * minLoadFactor"
1:35fa73f:    * is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark". In other words, the table capacity
1:35fa73f:    * (and proportionally the memory used by this class) oscillates within these constraints. The terms are precomputed
1:35fa73f:    * and cached to avoid recalculating them each time put(..) or removeKey(...) is called.
1:35fa73f:    */
1:35fa73f:   protected int lowWaterMark;
1:35fa73f:   protected int highWaterMark;
1:35fa73f: 
1:35fa73f:   /** The minimum load factor for the hashtable. */
1:35fa73f:   protected double minLoadFactor;
1:35fa73f: 
1:35fa73f:   /** The maximum load factor for the hashtable. */
1:35fa73f:   protected double maxLoadFactor;
1:35fa73f: 
1:35fa73f:   // these are public access for unit tests.
1:6d16230:   public static final int DEFAULT_CAPACITY = 277;
1:6d16230:   public static final double DEFAULT_MIN_LOAD_FACTOR = 0.2;
1:6d16230:   public static final double DEFAULT_MAX_LOAD_FACTOR = 0.5;
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant <tt>c *
1:35fa73f:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
1:35fa73f:    */
1:35fa73f:   protected int chooseGrowCapacity(int size, double minLoad, double maxLoad) {
1:35fa73f:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (3 * minLoad + maxLoad)))));
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns new high water mark threshold based on current capacity and maxLoadFactor.
1:35fa73f:    *
1:35fa73f:    * @return int the new threshold.
1:35fa73f:    */
1:35fa73f:   protected int chooseHighWaterMark(int capacity, double maxLoad) {
1:35fa73f:     return Math.min(capacity - 2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns new low water mark threshold based on current capacity and minLoadFactor.
1:35fa73f:    *
1:35fa73f:    * @return int the new threshold.
1:35fa73f:    */
1:35fa73f:   protected int chooseLowWaterMark(int capacity, double minLoad) {
1:35fa73f:     return (int) (capacity * minLoad);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Chooses a new prime table capacity neither favoring shrinking nor growing, that (approximately) satisfies the
1:35fa73f:    * invariant <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given
1:35fa73f:    * size.
1:35fa73f:    */
1:35fa73f:   protected int chooseMeanCapacity(int size, double minLoad, double maxLoad) {
1:35fa73f:     return nextPrime(Math.max(size + 1, (int) ((2 * size / (minLoad + maxLoad)))));
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant <tt>c *
1:35fa73f:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
1:35fa73f:    */
1:35fa73f:   protected int chooseShrinkCapacity(int size, double minLoad, double maxLoad) {
1:35fa73f:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (minLoad + 3 * maxLoad)))));
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /** Removes all (key,value) associations from the receiver. */
1:35fa73f:   public abstract void clear();
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
1:35fa73f:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:35fa73f:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
1:35fa73f:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:35fa73f:    * many times. <p> <b>This default implementation does nothing.</b> Override this method if necessary.
1:35fa73f:    *
1:35fa73f:    * @param minCapacity the desired minimum capacity.
1:35fa73f:    */
1:35fa73f:   public void ensureCapacity(int minCapacity) {
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns <tt>true</tt> if the receiver contains no (key,value) associations.
1:35fa73f:    *
1:35fa73f:    * @return <tt>true</tt> if the receiver contains no (key,value) associations.
1:35fa73f:    */
1:35fa73f:   public boolean isEmpty() {
1:35fa73f:     return distinct == 0;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code>
1:35fa73f:    * (within 11% if <code>desiredCapacity &gt;= 1000</code>).
1:35fa73f:    *
1:35fa73f:    * @param desiredCapacity the capacity desired by the user.
1:35fa73f:    * @return the capacity which should be used for a hashtable.
1:35fa73f:    */
1:35fa73f:   protected int nextPrime(int desiredCapacity) {
1:35fa73f:     return PrimeFinder.nextPrime(desiredCapacity);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Initializes the receiver. You will almost certainly need to override this method in subclasses to initialize the
1:35fa73f:    * hash table.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the receiver.
1:35fa73f:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:35fa73f:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     if (initialCapacity < 0) {
1:35fa73f:       throw new IllegalArgumentException("Initial Capacity must not be less than zero: " + initialCapacity);
1:35fa73f:     }
1:35fa73f:     if (minLoadFactor < 0.0 || minLoadFactor >= 1.0) {
1:35fa73f:       throw new IllegalArgumentException("Illegal minLoadFactor: " + minLoadFactor);
1:35fa73f:     }
1:35fa73f:     if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) {
1:35fa73f:       throw new IllegalArgumentException("Illegal maxLoadFactor: " + maxLoadFactor);
1:35fa73f:     }
1:35fa73f:     if (minLoadFactor >= maxLoadFactor) {
1:35fa73f:       throw new IllegalArgumentException(
1:35fa73f:           "Illegal minLoadFactor: " + minLoadFactor + " and maxLoadFactor: " + maxLoadFactor);
1:35fa73f:     }
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Returns the number of (key,value) associations currently contained.
1:35fa73f:    *
1:35fa73f:    * @return the number of (key,value) associations currently contained.
1:35fa73f:    */
1:35fa73f:   public int size() {
1:35fa73f:     return distinct;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:35fa73f:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
1:35fa73f:    * nothing. Override this method if necessary.
1:35fa73f:    */
1:35fa73f:   public void trimToSize() {
1:35fa73f:   }
1:35fa73f:   
1:35fa73f:   protected static boolean equalsMindTheNull(Object a, Object b) {
1:35fa73f:     if (a == null && b == null) {
1:35fa73f:       return true;
1:35fa73f:     }
1:35fa73f:     if (a == null || b == null) {
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f:     return a.equals(b);
1:35fa73f:   }
1:35fa73f: }
============================================================================
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:   public static final int DEFAULT_CAPACITY = 277;
1:   public static final double DEFAULT_MIN_LOAD_FACTOR = 0.2;
1:   public static final double DEFAULT_MAX_LOAD_FACTOR = 0.5;
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: /*
1: Copyright 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
1: */
1: package org.apache.mahout.math.set;
1: 
1: import org.apache.mahout.math.PersistentObject;
1: import org.apache.mahout.math.map.PrimeFinder;
1: 
1: public abstract class AbstractSet extends PersistentObject {
1:   //public static boolean debug = false; // debug only
1: 
1:   /** The number of distinct associations in the map; its "size()". */
1:   protected int distinct;
1: 
1:   /**
1:    * The table capacity c=table.length always satisfies the invariant <tt>c * minLoadFactor <= s <= c *
1:    * maxLoadFactor</tt>, where s=size() is the number of associations currently contained. The term "c * minLoadFactor"
1:    * is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark". In other words, the table capacity
1:    * (and proportionally the memory used by this class) oscillates within these constraints. The terms are precomputed
1:    * and cached to avoid recalculating them each time put(..) or removeKey(...) is called.
1:    */
1:   protected int lowWaterMark;
1:   protected int highWaterMark;
1: 
1:   /** The minimum load factor for the hashtable. */
1:   protected double minLoadFactor;
1: 
1:   /** The maximum load factor for the hashtable. */
1:   protected double maxLoadFactor;
1: 
1:   // these are public access for unit tests.
0:   public static final int defaultCapacity = 277;
0:   public static final double defaultMinLoadFactor = 0.2;
0:   public static final double defaultMaxLoadFactor = 0.5;
1: 
1:   /**
1:    * Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant <tt>c *
1:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
1:    */
1:   protected int chooseGrowCapacity(int size, double minLoad, double maxLoad) {
1:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (3 * minLoad + maxLoad)))));
1:   }
1: 
1:   /**
1:    * Returns new high water mark threshold based on current capacity and maxLoadFactor.
1:    *
1:    * @return int the new threshold.
1:    */
1:   protected int chooseHighWaterMark(int capacity, double maxLoad) {
1:     return Math.min(capacity - 2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot
1:   }
1: 
1:   /**
1:    * Returns new low water mark threshold based on current capacity and minLoadFactor.
1:    *
1:    * @return int the new threshold.
1:    */
1:   protected int chooseLowWaterMark(int capacity, double minLoad) {
1:     return (int) (capacity * minLoad);
1:   }
1: 
1:   /**
1:    * Chooses a new prime table capacity neither favoring shrinking nor growing, that (approximately) satisfies the
1:    * invariant <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given
1:    * size.
1:    */
1:   protected int chooseMeanCapacity(int size, double minLoad, double maxLoad) {
1:     return nextPrime(Math.max(size + 1, (int) ((2 * size / (minLoad + maxLoad)))));
1:   }
1: 
1:   /**
1:    * Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant <tt>c *
1:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
1:    */
1:   protected int chooseShrinkCapacity(int size, double minLoad, double maxLoad) {
1:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (minLoad + 3 * maxLoad)))));
1:   }
1: 
1:   /** Removes all (key,value) associations from the receiver. */
1:   public abstract void clear();
1: 
1:   /**
1:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
1:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
1:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
1:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
1:    * many times. <p> <b>This default implementation does nothing.</b> Override this method if necessary.
1:    *
1:    * @param minCapacity the desired minimum capacity.
1:    */
1:   public void ensureCapacity(int minCapacity) {
1:   }
1: 
1:   /**
1:    * Returns <tt>true</tt> if the receiver contains no (key,value) associations.
1:    *
1:    * @return <tt>true</tt> if the receiver contains no (key,value) associations.
1:    */
1:   public boolean isEmpty() {
1:     return distinct == 0;
1:   }
1: 
1:   /**
1:    * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code>
1:    * (within 11% if <code>desiredCapacity &gt;= 1000</code>).
1:    *
1:    * @param desiredCapacity the capacity desired by the user.
1:    * @return the capacity which should be used for a hashtable.
1:    */
1:   protected int nextPrime(int desiredCapacity) {
1:     return PrimeFinder.nextPrime(desiredCapacity);
1:   }
1: 
1:   /**
1:    * Initializes the receiver. You will almost certainly need to override this method in subclasses to initialize the
1:    * hash table.
1:    *
1:    * @param initialCapacity the initial capacity of the receiver.
1:    * @param minLoadFactor   the minLoadFactor of the receiver.
1:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     if (initialCapacity < 0) {
1:       throw new IllegalArgumentException("Initial Capacity must not be less than zero: " + initialCapacity);
1:     }
1:     if (minLoadFactor < 0.0 || minLoadFactor >= 1.0) {
1:       throw new IllegalArgumentException("Illegal minLoadFactor: " + minLoadFactor);
1:     }
1:     if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) {
1:       throw new IllegalArgumentException("Illegal maxLoadFactor: " + maxLoadFactor);
1:     }
1:     if (minLoadFactor >= maxLoadFactor) {
1:       throw new IllegalArgumentException(
1:           "Illegal minLoadFactor: " + minLoadFactor + " and maxLoadFactor: " + maxLoadFactor);
1:     }
1:   }
1: 
1:   /**
1:    * Returns the number of (key,value) associations currently contained.
1:    *
1:    * @return the number of (key,value) associations currently contained.
1:    */
1:   public int size() {
1:     return distinct;
1:   }
1: 
1:   /**
1:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
1:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
1:    * nothing. Override this method if necessary.
1:    */
1:   public void trimToSize() {
1:   }
1:   
1:   protected static boolean equalsMindTheNull(Object a, Object b) {
1:     if (a == null && b == null) {
1:       return true;
1:     }
1:     if (a == null || b == null) {
1:       return false;
1:     }
1:     return a.equals(b);
1:   }
1: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
commit:d7351cc
/////////////////////////////////////////////////////////////////////////
0:   
0:   protected static boolean equalsMindTheNull(Object a, Object b) {
0:     if (a == null && b == null) {
0:       return true;
0:     }
0:     if (a == null || b == null) {
0:       return false;
0:     }
0:     return a.equals(b);
0:   }
commit:7ea6efc
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.set;
0: import org.apache.mahout.math.map.PrimeFinder;
0: public abstract class AbstractSet extends PersistentObject {
/////////////////////////////////////////////////////////////////////////
0:   // these are public access for unit tests.
0:   static public final int defaultCapacity = 277;
0:   static public final double defaultMinLoadFactor = 0.2;
0:   static public final double defaultMaxLoadFactor = 0.5;
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:ea65197
/////////////////////////////////////////////////////////////////////////
0:   public static final int defaultCapacity = 277;
0:   public static final double defaultMinLoadFactor = 0.2;
0:   public static final double defaultMaxLoadFactor = 0.5;
/////////////////////////////////////////////////////////////////////////
0:   protected int nextPrime(int desiredCapacity) {
commit:cfe7f01
/////////////////////////////////////////////////////////////////////////
0:   // these are package access for unit tests.
0:   static final int defaultCapacity = 277;
0:   static final double defaultMinLoadFactor = 0.2;
0:   static final double defaultMaxLoadFactor = 0.5;
commit:7369cd5
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0:  First see the <a href="package-summary.html">package summary</a> 
0:  and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: protected int nextPrime(int desiredCapacity) {
commit:7627de6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.matrix.PersistentObject;
0: 
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractMap extends PersistentObject {
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
0:  Abstract base class for hash maps holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc. as keys and/or values.
0:  First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0:  <p>
0:  Note that implementations are not synchronized.
0:  @author wolfgang.hoschek@cern.ch
0:  @version 1.0, 09/24/99
0:  @see      java.util.HashMap
0: 
0: /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
0: 
0:   /** The number of distinct associations in the map; its "size()". */
0:    * The table capacity c=table.length always satisfies the invariant <tt>c * minLoadFactor <= s <= c *
0:    * maxLoadFactor</tt>, where s=size() is the number of associations currently contained. The term "c * minLoadFactor"
0:    * is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark". In other words, the table capacity
0:    * (and proportionally the memory used by this class) oscillates within these constraints. The terms are precomputed
0:    * and cached to avoid recalculating them each time put(..) or removeKey(...) is called.
0:   /** The minimum load factor for the hashtable. */
0:   /** The maximum load factor for the hashtable. */
0: 
0:   /** Makes this class non instantiable, but still let's others inherit from it. */
0:   protected AbstractMap() {
0:   }
0: 
0:   /**
0:    * Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant <tt>c *
0:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
0:    */
0:   protected int chooseGrowCapacity(int size, double minLoad, double maxLoad) {
0:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (3 * minLoad + maxLoad)))));
0:   }
0: 
0:   /**
0:    * Returns new high water mark threshold based on current capacity and maxLoadFactor.
0:    *
0:    * @return int the new threshold.
0:    */
0:   protected int chooseHighWaterMark(int capacity, double maxLoad) {
0:     return Math.min(capacity - 2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot
0:   }
0: 
0:   /**
0:    * Returns new low water mark threshold based on current capacity and minLoadFactor.
0:    *
0:    * @return int the new threshold.
0:    */
0:   protected int chooseLowWaterMark(int capacity, double minLoad) {
0:     return (int) (capacity * minLoad);
0:   }
0: 
0:   /**
0:    * Chooses a new prime table capacity neither favoring shrinking nor growing, that (approximately) satisfies the
0:    * invariant <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given
0:    * size.
0:    */
0:   protected int chooseMeanCapacity(int size, double minLoad, double maxLoad) {
0:     return nextPrime(Math.max(size + 1, (int) ((2 * size / (minLoad + maxLoad)))));
0:   }
0: 
0:   /**
0:    * Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant <tt>c *
0:    * minLoadFactor <= size <= c * maxLoadFactor</tt> and has at least one FREE slot for the given size.
0:    */
0:   protected int chooseShrinkCapacity(int size, double minLoad, double maxLoad) {
0:     return nextPrime(Math.max(size + 1, (int) ((4 * size / (minLoad + 3 * maxLoad)))));
0:   }
0: 
0:   /** Removes all (key,value) associations from the receiver. */
0:   public abstract void clear();
0: 
0:   /**
0:    * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new
0:    * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This
0:    * method never need be called; it is for performance tuning only. Calling this method before <tt>put()</tt>ing a
0:    * large number of associations boosts performance, because the receiver will grow only once instead of potentially
0:    * many times. <p> <b>This default implementation does nothing.</b> Override this method if necessary.
0:    *
0:    * @param minCapacity the desired minimum capacity.
0:    */
0:   public void ensureCapacity(int minCapacity) {
0:   }
0: 
0:   /**
0:    * Returns <tt>true</tt> if the receiver contains no (key,value) associations.
0:    *
0:    * @return <tt>true</tt> if the receiver contains no (key,value) associations.
0:    */
0:   public boolean isEmpty() {
0:     return distinct == 0;
0:   }
0: 
0:   /**
0:    * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code>
0:    * (within 11% if <code>desiredCapacity &gt;= 1000</code>).
0:    *
0:    * @param desiredCapacity the capacity desired by the user.
0:    * @return the capacity which should be used for a hashtable.
0:    */
0:   protected int nextPrime(int desiredCapacity) {
0:     return PrimeFinder.nextPrime(desiredCapacity);
0:   }
0: 
0:   /**
0:    * Initializes the receiver. You will almost certainly need to override this method in subclasses to initialize the
0:    * hash table.
0:    *
0:    * @param initialCapacity the initial capacity of the receiver.
0:    * @param minLoadFactor   the minLoadFactor of the receiver.
0:    * @param maxLoadFactor   the maxLoadFactor of the receiver.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     if (initialCapacity < 0) {
0:       throw new IllegalArgumentException("Initial Capacity must not be less than zero: " + initialCapacity);
0:     }
0:     if (minLoadFactor < 0.0 || minLoadFactor >= 1.0) {
0:       throw new IllegalArgumentException("Illegal minLoadFactor: " + minLoadFactor);
0:     }
0:     if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) {
0:       throw new IllegalArgumentException("Illegal maxLoadFactor: " + maxLoadFactor);
0:     }
0:     if (minLoadFactor >= maxLoadFactor) {
0:       throw new IllegalArgumentException(
0:           "Illegal minLoadFactor: " + minLoadFactor + " and maxLoadFactor: " + maxLoadFactor);
0:     }
0:   }
0: 
0:   /**
0:    * Returns the number of (key,value) associations currently contained.
0:    *
0:    * @return the number of (key,value) associations currently contained.
0:    */
0:   public int size() {
0:     return distinct;
0:   }
0: 
0:   /**
0:    * Trims the capacity of the receiver to be the receiver's current size. Releases any superfluous internal memory. An
0:    * application can use this operation to minimize the storage of the receiver. <p> This default implementation does
0:    * nothing. Override this method if necessary.
0:    */
0:   public void trimToSize() {
0:   }
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
0: @see      java.util.HashMap
0:   //public static boolean debug = false; // debug only
0:   
0:   /**
0:    * The number of distinct associations in the map; its "size()".
0:    */
0:   protected int distinct;
0:   /**
0:    * The table capacity c=table.length always satisfies the invariant
0:    * <tt>c * minLoadFactor <= s <= c * maxLoadFactor</tt>, where s=size() is the number of associations currently contained.
0:    * The term "c * minLoadFactor" is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark".
0:    * In other words, the table capacity (and proportionally the memory used by this class) oscillates within these constraints.
0:    * The terms are precomputed and cached to avoid recalculating them each time put(..) or removeKey(...) is called.
0:    */
0:   protected int lowWaterMark;
0:   protected int highWaterMark;
0:   /**
0:    * The minimum load factor for the hashtable.
0:    */
0:   protected double minLoadFactor;
0:   /**
0:    * The maximum load factor for the hashtable.
0:    */
0:   protected double maxLoadFactor;
0:   protected static final int defaultCapacity = 277;
0:   protected static final double defaultMinLoadFactor = 0.2;
0:   protected static final double defaultMaxLoadFactor = 0.5;
/////////////////////////////////////////////////////////////////////////
0:   return nextPrime(Math.max(size+1, (int) ((4*size / (3*minLoad+maxLoad)))));
0:   return Math.min(capacity-2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot
0:   return (int) (capacity * minLoad);
/////////////////////////////////////////////////////////////////////////
0:   return nextPrime(Math.max(size+1, (int) ((2*size / (minLoad+maxLoad)))));
/////////////////////////////////////////////////////////////////////////
0:   return nextPrime(Math.max(size+1, (int) ((4*size / (minLoad+3*maxLoad)))));
/////////////////////////////////////////////////////////////////////////
0:   return distinct == 0;
/////////////////////////////////////////////////////////////////////////
0:   return PrimeFinder.nextPrime(desiredCapacity);
/////////////////////////////////////////////////////////////////////////
0:  * @throws  IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.
0:   if (initialCapacity < 0)
0:       throw new IllegalArgumentException("Initial Capacity must not be less than zero: "+ initialCapacity);
0:   if (minLoadFactor < 0.0 || minLoadFactor >= 1.0)
0:     throw new IllegalArgumentException("Illegal minLoadFactor: "+ minLoadFactor);
0:   if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0)
0:     throw new IllegalArgumentException("Illegal maxLoadFactor: "+ maxLoadFactor);
0:   if (minLoadFactor >= maxLoadFactor)
0:     throw new IllegalArgumentException("Illegal minLoadFactor: "+ minLoadFactor+" and maxLoadFactor: "+ maxLoadFactor);
/////////////////////////////////////////////////////////////////////////
0:   return distinct;
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.map;
0: import org.apache.mahout.math.PersistentObject;
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix.map;
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractMap extends org.apache.mahout.matrix.PersistentObject {
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
0: Copyright 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.colt.map;
0: 
0: /**
0: Abstract base class for hash maps holding objects or primitive data types such as <code>int</code>, <code>float</code>, etc. as keys and/or values.
0: First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0: <p>
0: Note that implementations are not synchronized.
0: 
0: @author wolfgang.hoschek@cern.ch
0: @version 1.0, 09/24/99
0: @see	    java.util.HashMap
0: */
0: /** 
0:  * @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported.
0:  */
0: @Deprecated
0: public abstract class AbstractMap extends org.apache.mahout.colt.PersistentObject {
0: 	//public static boolean debug = false; // debug only
0: 	
0: 	/**
0: 	 * The number of distinct associations in the map; its "size()".
0: 	 */
0: 	protected int distinct;
0: 
0: 	/**
0: 	 * The table capacity c=table.length always satisfies the invariant
0: 	 * <tt>c * minLoadFactor <= s <= c * maxLoadFactor</tt>, where s=size() is the number of associations currently contained.
0: 	 * The term "c * minLoadFactor" is called the "lowWaterMark", "c * maxLoadFactor" is called the "highWaterMark".
0: 	 * In other words, the table capacity (and proportionally the memory used by this class) oscillates within these constraints.
0: 	 * The terms are precomputed and cached to avoid recalculating them each time put(..) or removeKey(...) is called.
0: 	 */
0: 	protected int lowWaterMark;
0: 	protected int highWaterMark;
0: 
0: 	/**
0: 	 * The minimum load factor for the hashtable.
0: 	 */
0: 	protected double minLoadFactor;
0: 
0: 	/**
0: 	 * The maximum load factor for the hashtable.
0: 	 */
0: 	protected double maxLoadFactor;
0: 
0: 	protected static final int defaultCapacity = 277;
0: 	protected static final double defaultMinLoadFactor = 0.2;
0: 	protected static final double defaultMaxLoadFactor = 0.5;
0: /**
0:  * Makes this class non instantiable, but still let's others inherit from it.
0:  */
0: protected AbstractMap() {}
0: /**
0:  * Chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant
0:  * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
0:  * and has at least one FREE slot for the given size.
0:  */
0: protected int chooseGrowCapacity(int size, double minLoad, double maxLoad) {
0: 	return nextPrime(Math.max(size+1, (int) ((4*size / (3*minLoad+maxLoad)))));
0: }
0: /**
0:  * Returns new high water mark threshold based on current capacity and maxLoadFactor.
0:  * @return int the new threshold.
0:  */
0: protected int chooseHighWaterMark(int capacity, double maxLoad) {
0: 	return Math.min(capacity-2, (int) (capacity * maxLoad)); //makes sure there is always at least one FREE slot
0: }
0: /**
0:  * Returns new low water mark threshold based on current capacity and minLoadFactor.
0:  * @return int the new threshold.
0:  */
0: protected int chooseLowWaterMark(int capacity, double minLoad) {
0: 	return (int) (capacity * minLoad);
0: }
0: /**
0:  * Chooses a new prime table capacity neither favoring shrinking nor growing,
0:  * that (approximately) satisfies the invariant
0:  * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
0:  * and has at least one FREE slot for the given size.
0:  */
0: protected int chooseMeanCapacity(int size, double minLoad, double maxLoad) {
0: 	return nextPrime(Math.max(size+1, (int) ((2*size / (minLoad+maxLoad)))));
0: }
0: /**
0:  * Chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant
0:  * <tt>c * minLoadFactor <= size <= c * maxLoadFactor</tt>
0:  * and has at least one FREE slot for the given size.
0:  */
0: protected int chooseShrinkCapacity(int size, double minLoad, double maxLoad) {
0: 	return nextPrime(Math.max(size+1, (int) ((4*size / (minLoad+3*maxLoad)))));
0: }
0: /**
0:  * Removes all (key,value) associations from the receiver.
0:  */
0: public abstract void clear();
0: /**
0:  * Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
0:  * If necessary, allocates new internal memory and increases the capacity of the receiver.
0:  * <p>
0:  * This method never need be called; it is for performance tuning only.
0:  * Calling this method before <tt>put()</tt>ing a large number of associations boosts performance,
0:  * because the receiver will grow only once instead of potentially many times.
0:  * <p>
0:  * <b>This default implementation does nothing.</b> Override this method if necessary.
0:  *
0:  * @param   minCapacity   the desired minimum capacity.
0:  */
0: public void ensureCapacity(int minCapacity) {}
0: /**
0:  * Returns <tt>true</tt> if the receiver contains no (key,value) associations.
0:  *
0:  * @return <tt>true</tt> if the receiver contains no (key,value) associations.
0:  */
0: public boolean isEmpty() {
0: 	return distinct == 0;
0: }
0: /**
0:  * Returns a prime number which is <code>&gt;= desiredCapacity</code> and very close to <code>desiredCapacity</code> (within 11% if <code>desiredCapacity &gt;= 1000</code>).
0:  * @param desiredCapacity the capacity desired by the user.
0:  * @return the capacity which should be used for a hashtable.
0:  */
0: protected int nextPrime(int desiredCapacity) {
0: 	return PrimeFinder.nextPrime(desiredCapacity);
0: }
0: /**
0:  * Initializes the receiver.
0:  * You will almost certainly need to override this method in subclasses to initialize the hash table.
0:  *
0:  * @param      initialCapacity   the initial capacity of the receiver.
0:  * @param      minLoadFactor     the minLoadFactor of the receiver.
0:  * @param      maxLoadFactor     the maxLoadFactor of the receiver.
0:  * @throws	IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.
0:  */
0: protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0: 	if (initialCapacity < 0)
0: 	    throw new IllegalArgumentException("Initial Capacity must not be less than zero: "+ initialCapacity);
0: 	if (minLoadFactor < 0.0 || minLoadFactor >= 1.0)
0: 		throw new IllegalArgumentException("Illegal minLoadFactor: "+ minLoadFactor);
0: 	if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0)
0: 		throw new IllegalArgumentException("Illegal maxLoadFactor: "+ maxLoadFactor);
0: 	if (minLoadFactor >= maxLoadFactor)
0: 		throw new IllegalArgumentException("Illegal minLoadFactor: "+ minLoadFactor+" and maxLoadFactor: "+ maxLoadFactor);
0: }
0: /**
0:  * Returns the number of (key,value) associations currently contained.
0:  *
0:  * @return the number of (key,value) associations currently contained.
0:  */
0: public int size() {
0: 	return distinct;
0: }
0: /**
0:  * Trims the capacity of the receiver to be the receiver's current 
0:  * size. Releases any superfluous internal memory. An application can use this operation to minimize the 
0:  * storage of the receiver.
0:  * <p>
0:  * This default implementation does nothing. Override this method if necessary.
0:  */
0: public void trimToSize() {}
0: }
============================================================================