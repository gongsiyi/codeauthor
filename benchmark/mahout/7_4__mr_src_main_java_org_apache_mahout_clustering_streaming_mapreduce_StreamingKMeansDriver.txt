1:1d6dc49: /**
1:1d6dc49:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1d6dc49:  * contributor license agreements.  See the NOTICE file distributed with
1:1d6dc49:  * this work for additional information regarding copyright ownership.
1:1d6dc49:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1d6dc49:  * (the "License"); you may not use this file except in compliance with
1:1d6dc49:  * the License.  You may obtain a copy of the License at
1:1d6dc49:  *
1:1d6dc49:  *     http://www.apache.org/licenses/LICENSE-2.0
1:1d6dc49:  *
1:1d6dc49:  * Unless required by applicable law or agreed to in writing, software
1:1d6dc49:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1d6dc49:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1d6dc49:  * See the License for the specific language governing permissions and
1:1d6dc49:  * limitations under the License.
1:1d6dc49:  */
1:1d6dc49: 
1:1d6dc49: package org.apache.mahout.clustering.streaming.mapreduce;
1:a330664: 
1:1d6dc49: import java.io.IOException;
1:85f9ece: import java.util.ArrayList;
1:1d6dc49: import java.util.List;
1:1d6dc49: import java.util.concurrent.ExecutionException;
1:1d6dc49: import java.util.concurrent.ExecutorService;
1:1d6dc49: import java.util.concurrent.Executors;
1:1d6dc49: import java.util.concurrent.Future;
1:1d6dc49: import java.util.concurrent.TimeUnit;
1:1d6dc49: 
1:1d6dc49: import com.google.common.base.Preconditions;
1:1d6dc49: import org.apache.hadoop.conf.Configuration;
1:1d6dc49: import org.apache.hadoop.fs.FileStatus;
1:1d6dc49: import org.apache.hadoop.fs.FileSystem;
1:1d6dc49: import org.apache.hadoop.fs.Path;
1:1d6dc49: import org.apache.hadoop.io.IntWritable;
1:1d6dc49: import org.apache.hadoop.io.SequenceFile;
1:1d6dc49: import org.apache.hadoop.mapreduce.Job;
1:1d6dc49: import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
1:1d6dc49: import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
1:1d6dc49: import org.apache.hadoop.util.ToolRunner;
1:1d6dc49: import org.apache.mahout.common.AbstractJob;
1:1d6dc49: import org.apache.mahout.common.HadoopUtil;
1:1d6dc49: import org.apache.mahout.common.commandline.DefaultOptionCreator;
1:06205a6: import org.apache.mahout.common.iterator.sequencefile.PathFilters;
1:1d6dc49: import org.apache.mahout.math.Centroid;
1:1d6dc49: import org.apache.mahout.math.Vector;
1:1d6dc49: import org.apache.mahout.math.neighborhood.BruteSearch;
1:1d6dc49: import org.apache.mahout.math.neighborhood.ProjectionSearch;
1:1d6dc49: import org.slf4j.Logger;
1:1d6dc49: import org.slf4j.LoggerFactory;
1:1d6dc49: 
1:1d6dc49: /**
1:1d6dc49:  * Classifies the vectors into different clusters found by the clustering
1:1d6dc49:  * algorithm.
1:1d6dc49:  */
1:1d6dc49: public final class StreamingKMeansDriver extends AbstractJob {
1:1d6dc49:   /**
1:1d6dc49:    * Streaming KMeans options
1:1d6dc49:    */
1:1d6dc49:   /**
1:1d6dc49:    * The number of cluster that Mappers will use should be \(O(k log n)\) where k is the number of clusters
1:1d6dc49:    * to get at the end and n is the number of points to cluster. This doesn't need to be exact.
1:1d6dc49:    * It will be adjusted at runtime.
1:1d6dc49:    */
1:1d6dc49:   public static final String ESTIMATED_NUM_MAP_CLUSTERS = "estimatedNumMapClusters";
1:1d6dc49:   /**
1:1d6dc49:    * The initial estimated distance cutoff between two points for forming new clusters.
1:1d6dc49:    * @see org.apache.mahout.clustering.streaming.cluster.StreamingKMeans
1:1d6dc49:    * Defaults to 10e-6.
1:1d6dc49:    */
1:1d6dc49:   public static final String ESTIMATED_DISTANCE_CUTOFF = "estimatedDistanceCutoff";
1:1d6dc49: 
1:1d6dc49:   /**
1:1d6dc49:    * Ball KMeans options
1:1d6dc49:    */
1:1d6dc49:   /**
1:1d6dc49:    * After mapping finishes, we get an intermediate set of vectors that represent approximate
1:1d6dc49:    * clusterings of the data from each Mapper. These can be clustered by the Reducer using
1:1d6dc49:    * BallKMeans in memory. This variable is the maximum number of iterations in the final
1:1d6dc49:    * BallKMeans algorithm.
1:1d6dc49:    * Defaults to 10.
1:1d6dc49:    */
1:1d6dc49:   public static final String MAX_NUM_ITERATIONS = "maxNumIterations";
1:1d6dc49:   /**
1:1d6dc49:    * The "ball" aspect of ball k-means means that only the closest points to the centroid will actually be used
1:1d6dc49:    * for updating. The fraction of the points to be used is those points whose distance to the center is within
1:1d6dc49:    * trimFraction * distance to the closest other center.
1:1d6dc49:    * Defaults to 0.9.
1:1d6dc49:    */
1:1d6dc49:   public static final String TRIM_FRACTION = "trimFraction";
1:1d6dc49:   /**
1:1d6dc49:    * Whether to use k-means++ initialization or random initialization of the seed centroids.
1:1d6dc49:    * Essentially, k-means++ provides better clusters, but takes longer, whereas random initialization takes less
1:1d6dc49:    * time, but produces worse clusters, and tends to fail more often and needs multiple runs to compare to
1:1d6dc49:    * k-means++. If set, uses randomInit.
1:1d6dc49:    * @see org.apache.mahout.clustering.streaming.cluster.BallKMeans
1:1d6dc49:    */
1:1d6dc49:   public static final String RANDOM_INIT = "randomInit";
1:1d6dc49:   /**
1:1d6dc49:    * Whether to correct the weights of the centroids after the clustering is done. The weights end up being wrong
1:1d6dc49:    * because of the trimFraction and possible train/test splits. In some cases, especially in a pipeline, having
1:1d6dc49:    * an accurate count of the weights is useful. If set, ignores the final weights.
1:1d6dc49:    */
1:1d6dc49:   public static final String IGNORE_WEIGHTS = "ignoreWeights";
1:1d6dc49:   /**
1:1d6dc49:    * The percentage of points that go into the "test" set when evaluating BallKMeans runs in the reducer.
1:1d6dc49:    */
1:1d6dc49:   public static final String TEST_PROBABILITY = "testProbability";
1:1d6dc49:   /**
1:1d6dc49:    * The percentage of points that go into the "training" set when evaluating BallKMeans runs in the reducer.
1:1d6dc49:    */
1:1d6dc49:   public static final String NUM_BALLKMEANS_RUNS = "numBallKMeansRuns";
1:1d6dc49: 
1:1d6dc49:   /**
1:1d6dc49:    Searcher options
1:1d6dc49:    */
1:1d6dc49:   /**
1:1d6dc49:    * The Searcher class when performing nearest neighbor search in StreamingKMeans.
1:1d6dc49:    * Defaults to ProjectionSearch.
1:1d6dc49:    */
1:1d6dc49:   public static final String SEARCHER_CLASS_OPTION = "searcherClass";
1:1d6dc49:   /**
1:1d6dc49:    * The number of projections to use when using a projection searcher like ProjectionSearch or
1:1d6dc49:    * FastProjectionSearch. Projection searches work by projection the all the vectors on to a set of
1:1d6dc49:    * basis vectors and searching for the projected query in that totally ordered set. This
1:1d6dc49:    * however can produce false positives (vectors that are closer when projected than they would
1:1d6dc49:    * actually be.
1:1d6dc49:    * So, there must be more than one projection vectors in the basis. This variable is the number
1:1d6dc49:    * of vectors in a basis.
1:1d6dc49:    * Defaults to 3
1:1d6dc49:    */
1:1d6dc49:   public static final String NUM_PROJECTIONS_OPTION = "numProjections";
1:1d6dc49:   /**
1:1d6dc49:    * When using approximate searches (anything that's not BruteSearch),
1:1d6dc49:    * more than just the seemingly closest element must be considered. This variable has different
1:1d6dc49:    * meanings depending on the actual Searcher class used but is a measure of how many candidates
1:1d6dc49:    * will be considered.
1:1d6dc49:    * See the ProjectionSearch, FastProjectionSearch, LocalitySensitiveHashSearch classes for more
1:1d6dc49:    * details.
1:1d6dc49:    * Defaults to 2.
1:1d6dc49:    */
1:1d6dc49:   public static final String SEARCH_SIZE_OPTION = "searchSize";
1:1d6dc49: 
1:a330664:   /**
1:a330664:    * Whether to run another pass of StreamingKMeans on the reducer's points before BallKMeans. On some data sets
1:6b6b8a0:    * with a large number of mappers, the intermediate number of clusters passed to the reducer is too large to
1:6b6b8a0:    * fit into memory directly, hence the option to collapse the clusters further with StreamingKMeans.
1:a330664:    */
1:a330664:   public static final String REDUCE_STREAMING_KMEANS = "reduceStreamingKMeans";
1:a330664: 
1:1d6dc49:   private static final Logger log = LoggerFactory.getLogger(StreamingKMeansDriver.class);
1:1d6dc49: 
1:6b6b8a0:   public static final float INVALID_DISTANCE_CUTOFF = -1;
1:1d6dc49: 
1:1d6dc49:   @Override
1:1d6dc49:   public int run(String[] args) throws Exception {
1:1d6dc49:     // Standard options for any Mahout job.
1:1d6dc49:     addInputOption();
1:1d6dc49:     addOutputOption();
1:1d6dc49:     addOption(DefaultOptionCreator.overwriteOption().create());
1:1d6dc49: 
1:1d6dc49:     // The number of clusters to create for the data.
1:1d6dc49:     addOption(DefaultOptionCreator.numClustersOption().withDescription(
1:1d6dc49:         "The k in k-Means. Approximately this many clusters will be generated.").create());
1:1d6dc49: 
1:1d6dc49:     // StreamingKMeans (mapper) options
1:1d6dc49:     // There will be k final clusters, but in the Map phase to get a good approximation of the data, O(k log n)
1:1d6dc49:     // clusters are needed. Since n is the number of data points and not knowable until reading all the vectors,
1:1d6dc49:     // provide a decent estimate.
1:58cc1ae:     addOption(ESTIMATED_NUM_MAP_CLUSTERS, "km", "The estimated number of clusters to use for the "
1:58cc1ae:         + "Map phase of the job when running StreamingKMeans. This should be around k * log(n), "
1:58cc1ae:         + "where k is the final number of clusters and n is the total number of data points to "
1:ec8a5a0:         + "cluster.", String.valueOf(1));
1:1d6dc49: 
1:58cc1ae:     addOption(ESTIMATED_DISTANCE_CUTOFF, "e", "The initial estimated distance cutoff between two "
1:58cc1ae:         + "points for forming new clusters. If no value is given, it's estimated from the data set",
1:1d6dc49:         String.valueOf(INVALID_DISTANCE_CUTOFF));
1:1d6dc49: 
1:1d6dc49:     // BallKMeans (reducer) options
1:58cc1ae:     addOption(MAX_NUM_ITERATIONS, "mi", "The maximum number of iterations to run for the "
1:58cc1ae:         + "BallKMeans algorithm used by the reducer. If no value is given, defaults to 10.", String.valueOf(10));
1:1d6dc49: 
1:58cc1ae:     addOption(TRIM_FRACTION, "tf", "The 'ball' aspect of ball k-means means that only the closest points "
1:58cc1ae:         + "to the centroid will actually be used for updating. The fraction of the points to be used is those "
1:58cc1ae:         + "points whose distance to the center is within trimFraction * distance to the closest other center. "
1:58cc1ae:         + "If no value is given, defaults to 0.9.", String.valueOf(0.9));
1:1d6dc49: 
1:58cc1ae:     addFlag(RANDOM_INIT, "ri", "Whether to use k-means++ initialization or random initialization "
1:58cc1ae:         + "of the seed centroids. Essentially, k-means++ provides better clusters, but takes longer, whereas random "
1:58cc1ae:         + "initialization takes less time, but produces worse clusters, and tends to fail more often and needs "
1:58cc1ae:         + "multiple runs to compare to k-means++. If set, uses the random initialization.");
1:1d6dc49: 
1:58cc1ae:     addFlag(IGNORE_WEIGHTS, "iw", "Whether to correct the weights of the centroids after the clustering is done. "
1:58cc1ae:         + "The weights end up being wrong because of the trimFraction and possible train/test splits. In some cases, "
1:58cc1ae:         + "especially in a pipeline, having an accurate count of the weights is useful. If set, ignores the final "
1:58cc1ae:         + "weights");
1:1d6dc49: 
1:58cc1ae:     addOption(TEST_PROBABILITY, "testp", "A double value between 0 and 1 that represents the percentage of "
1:58cc1ae:         + "points to be used for 'testing' different clustering runs in the final BallKMeans "
1:58cc1ae:         + "step. If no value is given, defaults to 0.1", String.valueOf(0.1));
1:1d6dc49: 
1:58cc1ae:     addOption(NUM_BALLKMEANS_RUNS, "nbkm", "Number of BallKMeans runs to use at the end to try to cluster the "
1:58cc1ae:         + "points. If no value is given, defaults to 4", String.valueOf(4));
1:1d6dc49: 
1:1d6dc49:     // Nearest neighbor search options
1:1d6dc49:     // The distance measure used for computing the distance between two points. Generally, the
1:1d6dc49:     // SquaredEuclideanDistance is used for clustering problems (it's equivalent to CosineDistance for normalized
1:1d6dc49:     // vectors).
1:1d6dc49:     // WARNING! You can use any metric but most of the literature is for the squared euclidean distance.
1:1d6dc49:     addOption(DefaultOptionCreator.distanceMeasureOption().create());
1:1d6dc49: 
1:1d6dc49:     // The default searcher should be something more efficient that BruteSearch (ProjectionSearch, ...). See
1:1d6dc49:     // o.a.m.math.neighborhood.*
1:58cc1ae:     addOption(SEARCHER_CLASS_OPTION, "sc", "The type of searcher to be used when performing nearest "
1:58cc1ae:         + "neighbor searches. Defaults to ProjectionSearch.", ProjectionSearch.class.getCanonicalName());
1:1d6dc49: 
1:1d6dc49:     // In the original paper, the authors used 1 projection vector.
1:58cc1ae:     addOption(NUM_PROJECTIONS_OPTION, "np", "The number of projections considered in estimating the "
1:58cc1ae:         + "distances between vectors. Only used when the distance measure requested is either "
1:58cc1ae:         + "ProjectionSearch or FastProjectionSearch. If no value is given, defaults to 3.", String.valueOf(3));
1:1d6dc49: 
1:58cc1ae:     addOption(SEARCH_SIZE_OPTION, "s", "In more efficient searches (non BruteSearch), "
1:58cc1ae:         + "not all distances are calculated for determining the nearest neighbors. The number of "
1:58cc1ae:         + "elements whose distances from the query vector is actually computer is proportional to "
1:58cc1ae:         + "searchSize. If no value is given, defaults to 1.", String.valueOf(2));
1:1d6dc49: 
1:58cc1ae:     addFlag(REDUCE_STREAMING_KMEANS, "rskm", "There might be too many intermediate clusters from the mapper "
1:58cc1ae:         + "to fit into memory, so the reducer can run another pass of StreamingKMeans to collapse them down to a "
1:58cc1ae:         + "fewer clusters");
1:1d6dc49: 
1:1d6dc49:     addOption(DefaultOptionCreator.methodOption().create());
1:1d6dc49: 
1:1d6dc49:     if (parseArguments(args) == null) {
1:1d6dc49:       return -1;
1:1d6dc49:     }
1:1d6dc49:     Path output = getOutputPath();
1:1d6dc49:     if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
1:1d6dc49:       HadoopUtil.delete(getConf(), output);
1:1d6dc49:     }
1:1d6dc49:     configureOptionsForWorkers();
1:1d6dc49:     run(getConf(), getInputPath(), output);
1:1d6dc49:     return 0;
1:1d6dc49:   }
1:1d6dc49: 
1:1d6dc49:   private void configureOptionsForWorkers() throws ClassNotFoundException {
1:1d6dc49:     log.info("Starting to configure options for workers");
1:1d6dc49: 
1:1d6dc49:     String method = getOption(DefaultOptionCreator.METHOD_OPTION);
1:1d6dc49: 
1:1d6dc49:     int numClusters = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));
1:1d6dc49: 
1:1d6dc49:     // StreamingKMeans
1:1d6dc49:     int estimatedNumMapClusters = Integer.parseInt(getOption(ESTIMATED_NUM_MAP_CLUSTERS));
1:1d6dc49:     float estimatedDistanceCutoff = Float.parseFloat(getOption(ESTIMATED_DISTANCE_CUTOFF));
1:1d6dc49: 
1:1d6dc49:     // BallKMeans
1:1d6dc49:     int maxNumIterations = Integer.parseInt(getOption(MAX_NUM_ITERATIONS));
1:1d6dc49:     float trimFraction = Float.parseFloat(getOption(TRIM_FRACTION));
1:1d6dc49:     boolean randomInit = hasOption(RANDOM_INIT);
1:1d6dc49:     boolean ignoreWeights = hasOption(IGNORE_WEIGHTS);
1:1d6dc49:     float testProbability = Float.parseFloat(getOption(TEST_PROBABILITY));
1:1d6dc49:     int numBallKMeansRuns = Integer.parseInt(getOption(NUM_BALLKMEANS_RUNS));
1:1d6dc49: 
1:1d6dc49:     // Nearest neighbor search
1:1d6dc49:     String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);
1:1d6dc49:     String searcherClass = getOption(SEARCHER_CLASS_OPTION);
1:1d6dc49: 
1:1d6dc49:     // Get more parameters depending on the kind of search class we're working with. BruteSearch
1:1d6dc49:     // doesn't need anything else.
1:1d6dc49:     // LocalitySensitiveHashSearch and ProjectionSearches need searchSize.
1:1d6dc49:     // ProjectionSearches also need the number of projections.
1:1d6dc49:     boolean getSearchSize = false;
1:1d6dc49:     boolean getNumProjections = false;
1:1d6dc49:     if (!searcherClass.equals(BruteSearch.class.getName())) {
1:1d6dc49:       getSearchSize = true;
1:1d6dc49:       getNumProjections = true;
1:1d6dc49:     }
1:1d6dc49: 
1:1d6dc49:     // The search size to use. This is quite fuzzy and might end up not being configurable at all.
1:1d6dc49:     int searchSize = 0;
1:1d6dc49:     if (getSearchSize) {
1:1d6dc49:       searchSize = Integer.parseInt(getOption(SEARCH_SIZE_OPTION));
1:1d6dc49:     }
1:1d6dc49: 
1:1d6dc49:     // The number of projections to use. This is only useful in projection searches which
1:1d6dc49:     // project the vectors on multiple basis vectors to get distance estimates that are faster to
1:1d6dc49:     // calculate.
1:1d6dc49:     int numProjections = 0;
1:1d6dc49:     if (getNumProjections) {
1:1d6dc49:       numProjections = Integer.parseInt(getOption(NUM_PROJECTIONS_OPTION));
1:1d6dc49:     }
1:1d6dc49: 
1:a330664:     boolean reduceStreamingKMeans = hasOption(REDUCE_STREAMING_KMEANS);
1:a330664: 
1:1d6dc49:     configureOptionsForWorkers(getConf(), numClusters,
1:1d6dc49:         /* StreamingKMeans */
1:1d6dc49:         estimatedNumMapClusters,  estimatedDistanceCutoff,
1:1d6dc49:         /* BallKMeans */
1:1d6dc49:         maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns,
1:1d6dc49:         /* Searcher */
1:1d6dc49:         measureClass, searcherClass,  searchSize, numProjections,
1:a330664:         method,
1:a330664:         reduceStreamingKMeans);
1:1d6dc49:   }
1:1d6dc49: 
1:1d6dc49:   /**
1:1d6dc49:    * Checks the parameters for a StreamingKMeans job and prepares a Configuration with them.
1:1d6dc49:    *
1:1d6dc49:    * @param conf the Configuration to populate
1:1d6dc49:    * @param numClusters k, the number of clusters at the end
1:1d6dc49:    * @param estimatedNumMapClusters O(k log n), the number of clusters requested from each mapper
1:1d6dc49:    * @param estimatedDistanceCutoff an estimate of the minimum distance that separates two clusters (can be smaller and
1:1d6dc49:    *                                will be increased dynamically)
1:1d6dc49:    * @param maxNumIterations the maximum number of iterations of BallKMeans
1:1d6dc49:    * @param trimFraction the fraction of the points to be considered in updating a ball k-means
1:1d6dc49:    * @param randomInit whether to initialize the ball k-means seeds randomly
1:1d6dc49:    * @param ignoreWeights whether to ignore the invalid final ball k-means weights
1:1d6dc49:    * @param testProbability the percentage of vectors assigned to the test set for selecting the best final centers
1:1d6dc49:    * @param numBallKMeansRuns the number of BallKMeans runs in the reducer that determine the centroids to return
1:1d6dc49:    *                          (clusters are computed for the training set and the error is computed on the test set)
1:1d6dc49:    * @param measureClass string, name of the distance measure class; theory works for Euclidean-like distances
1:1d6dc49:    * @param searcherClass string, name of the searcher that will be used for nearest neighbor search
1:1d6dc49:    * @param searchSize the number of closest neighbors to look at for selecting the closest one in approximate nearest
1:1d6dc49:    *                   neighbor searches
1:1d6dc49:    * @param numProjections the number of projected vectors to use for faster searching (only useful for ProjectionSearch
1:1d6dc49:    *                       or FastProjectionSearch); @see org.apache.mahout.math.neighborhood.ProjectionSearch
1:1d6dc49:    */
1:1d6dc49:   public static void configureOptionsForWorkers(Configuration conf,
1:1d6dc49:                                                 int numClusters,
1:1d6dc49:                                                 /* StreamingKMeans */
1:1d6dc49:                                                 int estimatedNumMapClusters, float estimatedDistanceCutoff,
1:1d6dc49:                                                 /* BallKMeans */
1:1d6dc49:                                                 int maxNumIterations, float trimFraction, boolean randomInit,
1:1d6dc49:                                                 boolean ignoreWeights, float testProbability, int numBallKMeansRuns,
1:1d6dc49:                                                 /* Searcher */
1:1d6dc49:                                                 String measureClass, String searcherClass,
1:1d6dc49:                                                 int searchSize, int numProjections,
1:a330664:                                                 String method,
1:a330664:                                                 boolean reduceStreamingKMeans) throws ClassNotFoundException {
1:1d6dc49:     // Checking preconditions for the parameters.
1:cd167f9:     Preconditions.checkArgument(numClusters > 0, 
1:cd167f9:         "Invalid number of clusters requested: " + numClusters + ". Must be: numClusters > 0!");
1:1d6dc49: 
1:1d6dc49:     // StreamingKMeans
1:58cc1ae:     Preconditions.checkArgument(estimatedNumMapClusters > numClusters, "Invalid number of estimated map "
1:58cc1ae:         + "clusters; There must be more than the final number of clusters (k log n vs k)");
1:1d6dc49:     Preconditions.checkArgument(estimatedDistanceCutoff == INVALID_DISTANCE_CUTOFF || estimatedDistanceCutoff > 0,
1:cd167f9:         "estimatedDistanceCutoff must be equal to -1 or must be greater then 0!");
1:1d6dc49: 
1:1d6dc49:     // BallKMeans
1:1d6dc49:     Preconditions.checkArgument(maxNumIterations > 0, "Must have at least one BallKMeans iteration");
1:1d6dc49:     Preconditions.checkArgument(trimFraction > 0, "trimFraction must be positive");
1:58cc1ae:     Preconditions.checkArgument(testProbability >= 0 && testProbability < 1, "test probability is not in the "
1:58cc1ae:         + "interval [0, 1)");
1:1d6dc49:     Preconditions.checkArgument(numBallKMeansRuns > 0, "numBallKMeans cannot be negative");
1:1d6dc49: 
1:1d6dc49:     // Searcher
1:1d6dc49:     if (!searcherClass.contains("Brute")) {
1:1d6dc49:       // These tests only make sense when a relevant searcher is being used.
1:1d6dc49:       Preconditions.checkArgument(searchSize > 0, "Invalid searchSize. Must be positive.");
1:1d6dc49:       if (searcherClass.contains("Projection")) {
1:1d6dc49:         Preconditions.checkArgument(numProjections > 0, "Invalid numProjections. Must be positive");
1:1d6dc49:       }
1:1d6dc49:     }
1:1d6dc49: 
1:1d6dc49:     // Setting the parameters in the Configuration.
1:1d6dc49:     conf.setInt(DefaultOptionCreator.NUM_CLUSTERS_OPTION, numClusters);
1:1d6dc49:     /* StreamingKMeans */
1:1d6dc49:     conf.setInt(ESTIMATED_NUM_MAP_CLUSTERS, estimatedNumMapClusters);
1:1d6dc49:     if (estimatedDistanceCutoff != INVALID_DISTANCE_CUTOFF) {
1:1d6dc49:       conf.setFloat(ESTIMATED_DISTANCE_CUTOFF, estimatedDistanceCutoff);
1:1d6dc49:     }
1:1d6dc49:     /* BallKMeans */
1:1d6dc49:     conf.setInt(MAX_NUM_ITERATIONS, maxNumIterations);
1:1d6dc49:     conf.setFloat(TRIM_FRACTION, trimFraction);
1:1d6dc49:     conf.setBoolean(RANDOM_INIT, randomInit);
1:1d6dc49:     conf.setBoolean(IGNORE_WEIGHTS, ignoreWeights);
1:1d6dc49:     conf.setFloat(TEST_PROBABILITY, testProbability);
1:1d6dc49:     conf.setInt(NUM_BALLKMEANS_RUNS, numBallKMeansRuns);
1:1d6dc49:     /* Searcher */
1:1d6dc49:     // Checks if the measureClass is available, throws exception otherwise.
1:1d6dc49:     Class.forName(measureClass);
1:1d6dc49:     conf.set(DefaultOptionCreator.DISTANCE_MEASURE_OPTION, measureClass);
1:1d6dc49:     // Checks if the searcherClass is available, throws exception otherwise.
1:1d6dc49:     Class.forName(searcherClass);
1:1d6dc49:     conf.set(SEARCHER_CLASS_OPTION, searcherClass);
1:1d6dc49:     conf.setInt(SEARCH_SIZE_OPTION, searchSize);
1:1d6dc49:     conf.setInt(NUM_PROJECTIONS_OPTION, numProjections);
1:1d6dc49:     conf.set(DefaultOptionCreator.METHOD_OPTION, method);
1:a330664: 
1:a330664:     conf.setBoolean(REDUCE_STREAMING_KMEANS, reduceStreamingKMeans);
1:a330664: 
1:58cc1ae:     log.info("Parameters are: [k] numClusters {}; "
1:58cc1ae:         + "[SKM] estimatedNumMapClusters {}; estimatedDistanceCutoff {} "
1:58cc1ae:         + "[BKM] maxNumIterations {}; trimFraction {}; randomInit {}; ignoreWeights {}; "
1:58cc1ae:         + "testProbability {}; numBallKMeansRuns {}; "
1:58cc1ae:         + "[S] measureClass {}; searcherClass {}; searcherSize {}; numProjections {}; "
1:58cc1ae:         + "method {}; reduceStreamingKMeans {}", numClusters, estimatedNumMapClusters, estimatedDistanceCutoff,
1:1d6dc49:         maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns,
1:a330664:         measureClass, searcherClass, searchSize, numProjections, method, reduceStreamingKMeans);
1:1d6dc49:   }
1:1d6dc49: 
1:1d6dc49:   /**
1:1d6dc49:    * Iterate over the input vectors to produce clusters and, if requested, use the results of the final iteration to
1:1d6dc49:    * cluster the input vectors.
1:1d6dc49:    *
1:1d6dc49:    * @param input the directory pathname for input points.
1:1d6dc49:    * @param output the directory pathname for output points.
1:1d6dc49:    * @return 0 on success, -1 on failure.
1:1d6dc49:    */
1:6b6b8a0:   public static int run(Configuration conf, Path input, Path output)
1:6b6b8a0:       throws IOException, InterruptedException, ClassNotFoundException, ExecutionException {
1:1d6dc49:     log.info("Starting StreamingKMeans clustering for vectors in {}; results are output to {}",
1:1d6dc49:         input.toString(), output.toString());
1:1d6dc49: 
1:1d6dc49:     if (conf.get(DefaultOptionCreator.METHOD_OPTION,
1:1d6dc49:         DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {
1:1d6dc49:       return runSequentially(conf, input, output);
1:1d6dc49:     } else {
1:1d6dc49:       return runMapReduce(conf, input, output);
1:1d6dc49:     }
1:1d6dc49:   }
1:1d6dc49: 
1:1d6dc49:   private static int runSequentially(Configuration conf, Path input, Path output)
1:1d6dc49:     throws IOException, ExecutionException, InterruptedException {
1:1d6dc49:     long start = System.currentTimeMillis();
1:1d6dc49:     // Run StreamingKMeans step in parallel by spawning 1 thread per input path to process.
1:1d6dc49:     ExecutorService pool = Executors.newCachedThreadPool();
1:85f9ece:     List<Future<Iterable<Centroid>>> intermediateCentroidFutures = new ArrayList<>();
1:06205a6:     for (FileStatus status : HadoopUtil.listStatus(FileSystem.get(conf), input, PathFilters.logsCRCFilter())) {
1:1d6dc49:       intermediateCentroidFutures.add(pool.submit(new StreamingKMeansThread(status.getPath(), conf)));
1:1d6dc49:     }
1:1d6dc49:     log.info("Finished running Mappers");
1:1d6dc49:     // Merge the resulting "mapper" centroids.
1:85f9ece:     List<Centroid> intermediateCentroids = new ArrayList<>();
1:1d6dc49:     for (Future<Iterable<Centroid>> futureIterable : intermediateCentroidFutures) {
1:1d6dc49:       for (Centroid centroid : futureIterable.get()) {
1:1d6dc49:         intermediateCentroids.add(centroid);
1:1d6dc49:       }
1:1d6dc49:     }
1:1d6dc49:     pool.shutdown();
1:1d6dc49:     pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
1:1d6dc49:     log.info("Finished StreamingKMeans");
1:b0dc01b:     SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, new Path(output, "part-r-00000"), IntWritable.class,
1:1d6dc49:         CentroidWritable.class);
1:1d6dc49:     int numCentroids = 0;
1:1d6dc49:     // Run BallKMeans on the intermediate centroids.
1:1d6dc49:     for (Vector finalVector : StreamingKMeansReducer.getBestCentroids(intermediateCentroids, conf)) {
1:1d6dc49:       Centroid finalCentroid = (Centroid)finalVector;
1:1d6dc49:       writer.append(new IntWritable(numCentroids++), new CentroidWritable(finalCentroid));
1:1d6dc49:     }
1:1d6dc49:     writer.close();
1:1d6dc49:     long end = System.currentTimeMillis();
1:1d6dc49:     log.info("Finished BallKMeans. Took {}.", (end - start) / 1000.0);
1:1d6dc49:     return 0;
1:1d6dc49:   }
1:1d6dc49: 
1:58cc1ae:   public static int runMapReduce(Configuration conf, Path input, Path output)
1:58cc1ae:     throws IOException, ClassNotFoundException, InterruptedException {
1:1d6dc49:     // Prepare Job for submission.
1:1d6dc49:     Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class,
1:1d6dc49:         StreamingKMeansMapper.class, IntWritable.class, CentroidWritable.class,
1:1d6dc49:         StreamingKMeansReducer.class, IntWritable.class, CentroidWritable.class, SequenceFileOutputFormat.class,
1:1d6dc49:         conf);
1:1d6dc49:     job.setJobName(HadoopUtil.getCustomJobName(StreamingKMeansDriver.class.getSimpleName(), job,
1:1d6dc49:         StreamingKMeansMapper.class, StreamingKMeansReducer.class));
1:1d6dc49: 
1:1d6dc49:     // There is only one reducer so that the intermediate centroids get collected on one
1:1d6dc49:     // machine and are clustered in memory to get the right number of clusters.
1:1d6dc49:     job.setNumReduceTasks(1);
1:1d6dc49: 
1:1d6dc49:     // Set the JAR (so that the required libraries are available) and run.
1:1d6dc49:     job.setJarByClass(StreamingKMeansDriver.class);
1:1d6dc49: 
1:1d6dc49:     // Run job!
1:1d6dc49:     long start = System.currentTimeMillis();
1:1d6dc49:     if (!job.waitForCompletion(true)) {
1:1d6dc49:       return -1;
1:1d6dc49:     }
1:1d6dc49:     long end = System.currentTimeMillis();
1:1d6dc49: 
1:1d6dc49:     log.info("StreamingKMeans clustering complete. Results are in {}. Took {} ms", output.toString(), end - start);
1:1d6dc49:     return 0;
1:1d6dc49:   }
1:1d6dc49: 
1:1d6dc49:   /**
1:1d6dc49:    * Constructor to be used by the ToolRunner.
1:1d6dc49:    */
1:1d6dc49:   private StreamingKMeansDriver() {}
1:1d6dc49: 
1:1d6dc49:   public static void main(String[] args) throws Exception {
1:1d6dc49:     ToolRunner.run(new StreamingKMeansDriver(), args);
1:1d6dc49:   }
1:1d6dc49: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     List<Future<Iterable<Centroid>>> intermediateCentroidFutures = new ArrayList<>();
1:     List<Centroid> intermediateCentroids = new ArrayList<>();
commit:ec8a5a0
/////////////////////////////////////////////////////////////////////////
1:         + "cluster.", String.valueOf(1));
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:smarthi
-------------------------------------------------------------------------------
commit:b0dc01b
/////////////////////////////////////////////////////////////////////////
1:     SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, new Path(output, "part-r-00000"), IntWritable.class,
commit:6a8cfcd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:06205a6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.iterator.sequencefile.PathFilters;
/////////////////////////////////////////////////////////////////////////
1:     for (FileStatus status : HadoopUtil.listStatus(FileSystem.get(conf), input, PathFilters.logsCRCFilter())) {
commit:cd167f9
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(numClusters > 0, 
1:         "Invalid number of clusters requested: " + numClusters + ". Must be: numClusters > 0!");
1:         "estimatedDistanceCutoff must be equal to -1 or must be greater then 0!");
author:dfilimon
-------------------------------------------------------------------------------
commit:6b6b8a0
/////////////////////////////////////////////////////////////////////////
1:    * with a large number of mappers, the intermediate number of clusters passed to the reducer is too large to
1:    * fit into memory directly, hence the option to collapse the clusters further with StreamingKMeans.
1:   public static final float INVALID_DISTANCE_CUTOFF = -1;
/////////////////////////////////////////////////////////////////////////
1:   public static int run(Configuration conf, Path input, Path output)
1:       throws IOException, InterruptedException, ClassNotFoundException, ExecutionException {
commit:a330664
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * Whether to run another pass of StreamingKMeans on the reducer's points before BallKMeans. On some data sets
0:    * with a large number of mappers, the intermediate number of
1:    */
1:   public static final String REDUCE_STREAMING_KMEANS = "reduceStreamingKMeans";
1: 
/////////////////////////////////////////////////////////////////////////
0:     addFlag(REDUCE_STREAMING_KMEANS, "rskm", "There might be too many intermediate clusters from the mapper " +
0:         "to fit into memory, so the reducer can run another pass of StreamingKMeans to collapse them down to a " +
0:         "fewer clusters");
1: 
/////////////////////////////////////////////////////////////////////////
1:     boolean reduceStreamingKMeans = hasOption(REDUCE_STREAMING_KMEANS);
1: 
/////////////////////////////////////////////////////////////////////////
1:         method,
1:         reduceStreamingKMeans);
/////////////////////////////////////////////////////////////////////////
1:                                                 String method,
1:                                                 boolean reduceStreamingKMeans) throws ClassNotFoundException {
/////////////////////////////////////////////////////////////////////////
1: 
1:     conf.setBoolean(REDUCE_STREAMING_KMEANS, reduceStreamingKMeans);
1: 
0:         "method {}; reduceStreamingKMeans {}", numClusters, estimatedNumMapClusters, estimatedDistanceCutoff,
1:         measureClass, searcherClass, searchSize, numProjections, method, reduceStreamingKMeans);
commit:1d6dc49
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.clustering.streaming.mapreduce;
1: 
1: import java.io.IOException;
1: import java.util.List;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
1: 
1: import com.google.common.base.Preconditions;
0: import com.google.common.collect.Lists;
1: import org.apache.hadoop.conf.Configuration;
1: import org.apache.hadoop.fs.FileStatus;
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
1: import org.apache.hadoop.io.IntWritable;
1: import org.apache.hadoop.io.SequenceFile;
1: import org.apache.hadoop.mapreduce.Job;
1: import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
1: import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
1: import org.apache.hadoop.util.ToolRunner;
1: import org.apache.mahout.common.AbstractJob;
1: import org.apache.mahout.common.HadoopUtil;
1: import org.apache.mahout.common.commandline.DefaultOptionCreator;
1: import org.apache.mahout.math.Centroid;
1: import org.apache.mahout.math.Vector;
1: import org.apache.mahout.math.neighborhood.BruteSearch;
1: import org.apache.mahout.math.neighborhood.ProjectionSearch;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Classifies the vectors into different clusters found by the clustering
1:  * algorithm.
1:  */
1: public final class StreamingKMeansDriver extends AbstractJob {
1:   /**
1:    * Streaming KMeans options
1:    */
1:   /**
1:    * The number of cluster that Mappers will use should be \(O(k log n)\) where k is the number of clusters
1:    * to get at the end and n is the number of points to cluster. This doesn't need to be exact.
1:    * It will be adjusted at runtime.
1:    */
1:   public static final String ESTIMATED_NUM_MAP_CLUSTERS = "estimatedNumMapClusters";
1:   /**
1:    * The initial estimated distance cutoff between two points for forming new clusters.
1:    * @see org.apache.mahout.clustering.streaming.cluster.StreamingKMeans
1:    * Defaults to 10e-6.
1:    */
1:   public static final String ESTIMATED_DISTANCE_CUTOFF = "estimatedDistanceCutoff";
1: 
1:   /**
1:    * Ball KMeans options
1:    */
1:   /**
1:    * After mapping finishes, we get an intermediate set of vectors that represent approximate
1:    * clusterings of the data from each Mapper. These can be clustered by the Reducer using
1:    * BallKMeans in memory. This variable is the maximum number of iterations in the final
1:    * BallKMeans algorithm.
1:    * Defaults to 10.
1:    */
1:   public static final String MAX_NUM_ITERATIONS = "maxNumIterations";
1:   /**
1:    * The "ball" aspect of ball k-means means that only the closest points to the centroid will actually be used
1:    * for updating. The fraction of the points to be used is those points whose distance to the center is within
1:    * trimFraction * distance to the closest other center.
1:    * Defaults to 0.9.
1:    */
1:   public static final String TRIM_FRACTION = "trimFraction";
1:   /**
1:    * Whether to use k-means++ initialization or random initialization of the seed centroids.
1:    * Essentially, k-means++ provides better clusters, but takes longer, whereas random initialization takes less
1:    * time, but produces worse clusters, and tends to fail more often and needs multiple runs to compare to
1:    * k-means++. If set, uses randomInit.
1:    * @see org.apache.mahout.clustering.streaming.cluster.BallKMeans
1:    */
1:   public static final String RANDOM_INIT = "randomInit";
1:   /**
1:    * Whether to correct the weights of the centroids after the clustering is done. The weights end up being wrong
1:    * because of the trimFraction and possible train/test splits. In some cases, especially in a pipeline, having
1:    * an accurate count of the weights is useful. If set, ignores the final weights.
1:    */
1:   public static final String IGNORE_WEIGHTS = "ignoreWeights";
1:   /**
1:    * The percentage of points that go into the "test" set when evaluating BallKMeans runs in the reducer.
1:    */
1:   public static final String TEST_PROBABILITY = "testProbability";
1:   /**
1:    * The percentage of points that go into the "training" set when evaluating BallKMeans runs in the reducer.
1:    */
1:   public static final String NUM_BALLKMEANS_RUNS = "numBallKMeansRuns";
1: 
1:   /**
1:    Searcher options
1:    */
1:   /**
1:    * The Searcher class when performing nearest neighbor search in StreamingKMeans.
1:    * Defaults to ProjectionSearch.
1:    */
1:   public static final String SEARCHER_CLASS_OPTION = "searcherClass";
1:   /**
1:    * The number of projections to use when using a projection searcher like ProjectionSearch or
1:    * FastProjectionSearch. Projection searches work by projection the all the vectors on to a set of
1:    * basis vectors and searching for the projected query in that totally ordered set. This
1:    * however can produce false positives (vectors that are closer when projected than they would
1:    * actually be.
1:    * So, there must be more than one projection vectors in the basis. This variable is the number
1:    * of vectors in a basis.
1:    * Defaults to 3
1:    */
1:   public static final String NUM_PROJECTIONS_OPTION = "numProjections";
1:   /**
1:    * When using approximate searches (anything that's not BruteSearch),
1:    * more than just the seemingly closest element must be considered. This variable has different
1:    * meanings depending on the actual Searcher class used but is a measure of how many candidates
1:    * will be considered.
1:    * See the ProjectionSearch, FastProjectionSearch, LocalitySensitiveHashSearch classes for more
1:    * details.
1:    * Defaults to 2.
1:    */
1:   public static final String SEARCH_SIZE_OPTION = "searchSize";
1: 
1:   private static final Logger log = LoggerFactory.getLogger(StreamingKMeansDriver.class);
1: 
0:   private static final double INVALID_DISTANCE_CUTOFF = -1;
1: 
1:   @Override
1:   public int run(String[] args) throws Exception {
1:     // Standard options for any Mahout job.
1:     addInputOption();
1:     addOutputOption();
1:     addOption(DefaultOptionCreator.overwriteOption().create());
1: 
1:     // The number of clusters to create for the data.
1:     addOption(DefaultOptionCreator.numClustersOption().withDescription(
1:         "The k in k-Means. Approximately this many clusters will be generated.").create());
1: 
1:     // StreamingKMeans (mapper) options
1:     // There will be k final clusters, but in the Map phase to get a good approximation of the data, O(k log n)
1:     // clusters are needed. Since n is the number of data points and not knowable until reading all the vectors,
1:     // provide a decent estimate.
0:     addOption(ESTIMATED_NUM_MAP_CLUSTERS, "km", "The estimated number of clusters to use for the " +
0:         "Map phase of the job when running StreamingKMeans. This should be around k * log(n), " +
0:         "where k is the final number of clusters and n is the total number of data points to " +
0:         "cluster.");
1: 
0:     addOption(ESTIMATED_DISTANCE_CUTOFF, "e", "The initial estimated distance cutoff between two " +
0:         "points for forming new clusters. If no value is given, it's estimated from the data set",
1:         String.valueOf(INVALID_DISTANCE_CUTOFF));
1: 
1:     // BallKMeans (reducer) options
0:     addOption(MAX_NUM_ITERATIONS, "mi", "The maximum number of iterations to run for the " +
0:         "BallKMeans algorithm used by the reducer. If no value is given, defaults to 10.", String.valueOf(10));
1: 
0:     addOption(TRIM_FRACTION, "tf", "The 'ball' aspect of ball k-means means that only the closest points " +
0:         "to the centroid will actually be used for updating. The fraction of the points to be used is those " +
0:         "points whose distance to the center is within trimFraction * distance to the closest other center. " +
0:         "If no value is given, defaults to 0.9.", String.valueOf(0.9));
1: 
0:     addFlag(RANDOM_INIT, "ri", "Whether to use k-means++ initialization or random initialization " +
0:         "of the seed centroids. Essentially, k-means++ provides better clusters, but takes longer, whereas random " +
0:         "initialization takes less time, but produces worse clusters, and tends to fail more often and needs " +
0:         "multiple runs to compare to k-means++. If set, uses the random initialization.");
1: 
0:     addFlag(IGNORE_WEIGHTS, "iw", "Whether to correct the weights of the centroids after the clustering is done. " +
0:         "The weights end up being wrong because of the trimFraction and possible train/test splits. In some cases, " +
0:         "especially in a pipeline, having an accurate count of the weights is useful. If set, ignores the final " +
0:         "weights");
1: 
0:     addOption(TEST_PROBABILITY, "testp", "A double value between 0 and 1 that represents the percentage of " +
0:         "points to be used for 'testing' different clustering runs in the final BallKMeans " +
0:         "step. If no value is given, defaults to 0.1", String.valueOf(0.1));
1: 
0:     addOption(NUM_BALLKMEANS_RUNS, "nbkm", "Number of BallKMeans runs to use at the end to try to cluster the " +
0:         "points. If no value is given, defaults to 4", String.valueOf(4));
1: 
1:     // Nearest neighbor search options
1:     // The distance measure used for computing the distance between two points. Generally, the
1:     // SquaredEuclideanDistance is used for clustering problems (it's equivalent to CosineDistance for normalized
1:     // vectors).
1:     // WARNING! You can use any metric but most of the literature is for the squared euclidean distance.
1:     addOption(DefaultOptionCreator.distanceMeasureOption().create());
1: 
1:     // The default searcher should be something more efficient that BruteSearch (ProjectionSearch, ...). See
1:     // o.a.m.math.neighborhood.*
0:     addOption(SEARCHER_CLASS_OPTION, "sc", "The type of searcher to be used when performing nearest " +
0:         "neighbor searches. Defaults to ProjectionSearch.", ProjectionSearch.class.getCanonicalName());
1: 
1:     // In the original paper, the authors used 1 projection vector.
0:     addOption(NUM_PROJECTIONS_OPTION, "np", "The number of projections considered in estimating the " +
0:         "distances between vectors. Only used when the distance measure requested is either " +
0:         "ProjectionSearch or FastProjectionSearch. If no value is given, defaults to 3.", String.valueOf(3));
1: 
0:     addOption(SEARCH_SIZE_OPTION, "s", "In more efficient searches (non BruteSearch), " +
0:         "not all distances are calculated for determining the nearest neighbors. The number of " +
0:         "elements whose distances from the query vector is actually computer is proportional to " +
0:         "searchSize. If no value is given, defaults to 1.", String.valueOf(2));
1: 
1:     addOption(DefaultOptionCreator.methodOption().create());
1: 
1:     if (parseArguments(args) == null) {
1:       return -1;
1:     }
1:     Path output = getOutputPath();
1:     if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {
1:       HadoopUtil.delete(getConf(), output);
1:     }
1:     configureOptionsForWorkers();
1:     run(getConf(), getInputPath(), output);
1:     return 0;
1:   }
1: 
1:   private void configureOptionsForWorkers() throws ClassNotFoundException {
1:     log.info("Starting to configure options for workers");
1: 
1:     String method = getOption(DefaultOptionCreator.METHOD_OPTION);
1: 
1:     int numClusters = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));
1: 
1:     // StreamingKMeans
1:     int estimatedNumMapClusters = Integer.parseInt(getOption(ESTIMATED_NUM_MAP_CLUSTERS));
1:     float estimatedDistanceCutoff = Float.parseFloat(getOption(ESTIMATED_DISTANCE_CUTOFF));
1: 
1:     // BallKMeans
1:     int maxNumIterations = Integer.parseInt(getOption(MAX_NUM_ITERATIONS));
1:     float trimFraction = Float.parseFloat(getOption(TRIM_FRACTION));
1:     boolean randomInit = hasOption(RANDOM_INIT);
1:     boolean ignoreWeights = hasOption(IGNORE_WEIGHTS);
1:     float testProbability = Float.parseFloat(getOption(TEST_PROBABILITY));
1:     int numBallKMeansRuns = Integer.parseInt(getOption(NUM_BALLKMEANS_RUNS));
1: 
1:     // Nearest neighbor search
1:     String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);
1:     String searcherClass = getOption(SEARCHER_CLASS_OPTION);
1: 
1:     // Get more parameters depending on the kind of search class we're working with. BruteSearch
1:     // doesn't need anything else.
1:     // LocalitySensitiveHashSearch and ProjectionSearches need searchSize.
1:     // ProjectionSearches also need the number of projections.
1:     boolean getSearchSize = false;
1:     boolean getNumProjections = false;
1:     if (!searcherClass.equals(BruteSearch.class.getName())) {
1:       getSearchSize = true;
1:       getNumProjections = true;
1:     }
1: 
1:     // The search size to use. This is quite fuzzy and might end up not being configurable at all.
1:     int searchSize = 0;
1:     if (getSearchSize) {
1:       searchSize = Integer.parseInt(getOption(SEARCH_SIZE_OPTION));
1:     }
1: 
1:     // The number of projections to use. This is only useful in projection searches which
1:     // project the vectors on multiple basis vectors to get distance estimates that are faster to
1:     // calculate.
1:     int numProjections = 0;
1:     if (getNumProjections) {
1:       numProjections = Integer.parseInt(getOption(NUM_PROJECTIONS_OPTION));
1:     }
1: 
1:     configureOptionsForWorkers(getConf(), numClusters,
1:         /* StreamingKMeans */
1:         estimatedNumMapClusters,  estimatedDistanceCutoff,
1:         /* BallKMeans */
1:         maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns,
1:         /* Searcher */
1:         measureClass, searcherClass,  searchSize, numProjections,
0:         method);
1:   }
1: 
1:   /**
1:    * Checks the parameters for a StreamingKMeans job and prepares a Configuration with them.
1:    *
1:    * @param conf the Configuration to populate
1:    * @param numClusters k, the number of clusters at the end
1:    * @param estimatedNumMapClusters O(k log n), the number of clusters requested from each mapper
1:    * @param estimatedDistanceCutoff an estimate of the minimum distance that separates two clusters (can be smaller and
1:    *                                will be increased dynamically)
1:    * @param maxNumIterations the maximum number of iterations of BallKMeans
1:    * @param trimFraction the fraction of the points to be considered in updating a ball k-means
1:    * @param randomInit whether to initialize the ball k-means seeds randomly
1:    * @param ignoreWeights whether to ignore the invalid final ball k-means weights
1:    * @param testProbability the percentage of vectors assigned to the test set for selecting the best final centers
1:    * @param numBallKMeansRuns the number of BallKMeans runs in the reducer that determine the centroids to return
1:    *                          (clusters are computed for the training set and the error is computed on the test set)
1:    * @param measureClass string, name of the distance measure class; theory works for Euclidean-like distances
1:    * @param searcherClass string, name of the searcher that will be used for nearest neighbor search
1:    * @param searchSize the number of closest neighbors to look at for selecting the closest one in approximate nearest
1:    *                   neighbor searches
1:    * @param numProjections the number of projected vectors to use for faster searching (only useful for ProjectionSearch
1:    *                       or FastProjectionSearch); @see org.apache.mahout.math.neighborhood.ProjectionSearch
1:    */
1:   public static void configureOptionsForWorkers(Configuration conf,
1:                                                 int numClusters,
1:                                                 /* StreamingKMeans */
1:                                                 int estimatedNumMapClusters, float estimatedDistanceCutoff,
1:                                                 /* BallKMeans */
1:                                                 int maxNumIterations, float trimFraction, boolean randomInit,
1:                                                 boolean ignoreWeights, float testProbability, int numBallKMeansRuns,
1:                                                 /* Searcher */
1:                                                 String measureClass, String searcherClass,
1:                                                 int searchSize, int numProjections,
0:                                                 String method) throws ClassNotFoundException {
1:     // Checking preconditions for the parameters.
0:     Preconditions.checkArgument(numClusters > 0, "Invalid number of clusters requested");
1: 
1:     // StreamingKMeans
0:     Preconditions.checkArgument(estimatedNumMapClusters > numClusters, "Invalid number of estimated map " +
0:         "clusters; There must be more than the final number of clusters (k log n vs k)");
1:     Preconditions.checkArgument(estimatedDistanceCutoff == INVALID_DISTANCE_CUTOFF || estimatedDistanceCutoff > 0,
0:         "estimatedDistanceCutoff cannot be negative");
1: 
1:     // BallKMeans
1:     Preconditions.checkArgument(maxNumIterations > 0, "Must have at least one BallKMeans iteration");
1:     Preconditions.checkArgument(trimFraction > 0, "trimFraction must be positive");
0:     Preconditions.checkArgument(testProbability >= 0 && testProbability < 1, "test probability is not in the " +
0:         "interval [0, 1)");
1:     Preconditions.checkArgument(numBallKMeansRuns > 0, "numBallKMeans cannot be negative");
1: 
1:     // Searcher
1:     if (!searcherClass.contains("Brute")) {
1:       // These tests only make sense when a relevant searcher is being used.
1:       Preconditions.checkArgument(searchSize > 0, "Invalid searchSize. Must be positive.");
1:       if (searcherClass.contains("Projection")) {
1:         Preconditions.checkArgument(numProjections > 0, "Invalid numProjections. Must be positive");
1:       }
1:     }
1: 
1:     // Setting the parameters in the Configuration.
1:     conf.setInt(DefaultOptionCreator.NUM_CLUSTERS_OPTION, numClusters);
1:     /* StreamingKMeans */
1:     conf.setInt(ESTIMATED_NUM_MAP_CLUSTERS, estimatedNumMapClusters);
1:     if (estimatedDistanceCutoff != INVALID_DISTANCE_CUTOFF) {
1:       conf.setFloat(ESTIMATED_DISTANCE_CUTOFF, estimatedDistanceCutoff);
1:     }
1:     /* BallKMeans */
1:     conf.setInt(MAX_NUM_ITERATIONS, maxNumIterations);
1:     conf.setFloat(TRIM_FRACTION, trimFraction);
1:     conf.setBoolean(RANDOM_INIT, randomInit);
1:     conf.setBoolean(IGNORE_WEIGHTS, ignoreWeights);
1:     conf.setFloat(TEST_PROBABILITY, testProbability);
1:     conf.setInt(NUM_BALLKMEANS_RUNS, numBallKMeansRuns);
1:     /* Searcher */
1:     // Checks if the measureClass is available, throws exception otherwise.
1:     Class.forName(measureClass);
1:     conf.set(DefaultOptionCreator.DISTANCE_MEASURE_OPTION, measureClass);
1:     // Checks if the searcherClass is available, throws exception otherwise.
1:     Class.forName(searcherClass);
1:     conf.set(SEARCHER_CLASS_OPTION, searcherClass);
1:     conf.setInt(SEARCH_SIZE_OPTION, searchSize);
1:     conf.setInt(NUM_PROJECTIONS_OPTION, numProjections);
1:     conf.set(DefaultOptionCreator.METHOD_OPTION, method);
0:     log.info("Parameters are: [k] numClusters {}; " +
0:         "[SKM] estimatedNumMapClusters {}; estimatedDistanceCutoff {} " +
0:         "[BKM] maxNumIterations {}; trimFraction {}; randomInit {}; ignoreWeights {}; " +
0:         "testProbability {}; numBallKMeansRuns {}; " +
0:         "[S] measureClass {}; searcherClass {}; searcherSize {}; numProjections {}; " +
0:         "method {}", numClusters, estimatedNumMapClusters, estimatedDistanceCutoff,
1:         maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns,
0:         measureClass, searcherClass, searchSize, numProjections, method);
1:   }
1: 
1:   /**
1:    * Iterate over the input vectors to produce clusters and, if requested, use the results of the final iteration to
1:    * cluster the input vectors.
1:    *
1:    * @param input the directory pathname for input points.
1:    * @param output the directory pathname for output points.
1:    * @return 0 on success, -1 on failure.
1:    */
0:   @SuppressWarnings("unchecked")
0:   public static int run(Configuration conf, Path input, Path output)
0:       throws IOException, InterruptedException, ClassNotFoundException, ExecutionException {
1:     log.info("Starting StreamingKMeans clustering for vectors in {}; results are output to {}",
1:         input.toString(), output.toString());
1: 
1:     if (conf.get(DefaultOptionCreator.METHOD_OPTION,
1:         DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {
1:       return runSequentially(conf, input, output);
1:     } else {
1:       return runMapReduce(conf, input, output);
1:     }
1:   }
1: 
1:   private static int runSequentially(Configuration conf, Path input, Path output)
1:       throws IOException, ExecutionException, InterruptedException {
1:     long start = System.currentTimeMillis();
1:     // Run StreamingKMeans step in parallel by spawning 1 thread per input path to process.
1:     ExecutorService pool = Executors.newCachedThreadPool();
0:     List<Future<Iterable<Centroid>>> intermediateCentroidFutures = Lists.newArrayList();
0:     for (FileStatus status : HadoopUtil.listStatus(FileSystem.get(conf), input)) {
1:       intermediateCentroidFutures.add(pool.submit(new StreamingKMeansThread(status.getPath(), conf)));
1:     }
1:     log.info("Finished running Mappers");
1:     // Merge the resulting "mapper" centroids.
0:     List<Centroid> intermediateCentroids = Lists.newArrayList();
1:     for (Future<Iterable<Centroid>> futureIterable : intermediateCentroidFutures) {
1:       for (Centroid centroid : futureIterable.get()) {
1:         intermediateCentroids.add(centroid);
1:       }
1:     }
1:     pool.shutdown();
1:     pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
1:     log.info("Finished StreamingKMeans");
0:     SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, output, IntWritable.class,
1:         CentroidWritable.class);
1:     int numCentroids = 0;
1:     // Run BallKMeans on the intermediate centroids.
1:     for (Vector finalVector : StreamingKMeansReducer.getBestCentroids(intermediateCentroids, conf)) {
1:       Centroid finalCentroid = (Centroid)finalVector;
1:       writer.append(new IntWritable(numCentroids++), new CentroidWritable(finalCentroid));
1:     }
1:     writer.close();
1:     long end = System.currentTimeMillis();
1:     log.info("Finished BallKMeans. Took {}.", (end - start) / 1000.0);
1:     return 0;
1:   }
1: 
0:   @SuppressWarnings("unchecked")
0:   public static int runMapReduce(Configuration conf, Path input, Path output) throws IOException, ClassNotFoundException, InterruptedException {
1:     // Prepare Job for submission.
1:     Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class,
1:         StreamingKMeansMapper.class, IntWritable.class, CentroidWritable.class,
1:         StreamingKMeansReducer.class, IntWritable.class, CentroidWritable.class, SequenceFileOutputFormat.class,
1:         conf);
1:     job.setJobName(HadoopUtil.getCustomJobName(StreamingKMeansDriver.class.getSimpleName(), job,
1:         StreamingKMeansMapper.class, StreamingKMeansReducer.class));
1: 
1:     // There is only one reducer so that the intermediate centroids get collected on one
1:     // machine and are clustered in memory to get the right number of clusters.
1:     job.setNumReduceTasks(1);
1: 
1:     // Set the JAR (so that the required libraries are available) and run.
1:     job.setJarByClass(StreamingKMeansDriver.class);
1: 
1:     // Run job!
1:     long start = System.currentTimeMillis();
1:     if (!job.waitForCompletion(true)) {
1:       return -1;
1:     }
1:     long end = System.currentTimeMillis();
1: 
1:     log.info("StreamingKMeans clustering complete. Results are in {}. Took {} ms", output.toString(), end - start);
1:     return 0;
1:   }
1: 
1:   /**
1:    * Constructor to be used by the ToolRunner.
1:    */
1:   private StreamingKMeansDriver() {}
1: 
1:   public static void main(String[] args) throws Exception {
1:     ToolRunner.run(new StreamingKMeansDriver(), args);
1:   }
1: }
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:58cc1ae
/////////////////////////////////////////////////////////////////////////
1:     addOption(ESTIMATED_NUM_MAP_CLUSTERS, "km", "The estimated number of clusters to use for the "
1:         + "Map phase of the job when running StreamingKMeans. This should be around k * log(n), "
1:         + "where k is the final number of clusters and n is the total number of data points to "
0:         + "cluster.");
1:     addOption(ESTIMATED_DISTANCE_CUTOFF, "e", "The initial estimated distance cutoff between two "
1:         + "points for forming new clusters. If no value is given, it's estimated from the data set",
1:     addOption(MAX_NUM_ITERATIONS, "mi", "The maximum number of iterations to run for the "
1:         + "BallKMeans algorithm used by the reducer. If no value is given, defaults to 10.", String.valueOf(10));
1:     addOption(TRIM_FRACTION, "tf", "The 'ball' aspect of ball k-means means that only the closest points "
1:         + "to the centroid will actually be used for updating. The fraction of the points to be used is those "
1:         + "points whose distance to the center is within trimFraction * distance to the closest other center. "
1:         + "If no value is given, defaults to 0.9.", String.valueOf(0.9));
1:     addFlag(RANDOM_INIT, "ri", "Whether to use k-means++ initialization or random initialization "
1:         + "of the seed centroids. Essentially, k-means++ provides better clusters, but takes longer, whereas random "
1:         + "initialization takes less time, but produces worse clusters, and tends to fail more often and needs "
1:         + "multiple runs to compare to k-means++. If set, uses the random initialization.");
1:     addFlag(IGNORE_WEIGHTS, "iw", "Whether to correct the weights of the centroids after the clustering is done. "
1:         + "The weights end up being wrong because of the trimFraction and possible train/test splits. In some cases, "
1:         + "especially in a pipeline, having an accurate count of the weights is useful. If set, ignores the final "
1:         + "weights");
1:     addOption(TEST_PROBABILITY, "testp", "A double value between 0 and 1 that represents the percentage of "
1:         + "points to be used for 'testing' different clustering runs in the final BallKMeans "
1:         + "step. If no value is given, defaults to 0.1", String.valueOf(0.1));
1:     addOption(NUM_BALLKMEANS_RUNS, "nbkm", "Number of BallKMeans runs to use at the end to try to cluster the "
1:         + "points. If no value is given, defaults to 4", String.valueOf(4));
/////////////////////////////////////////////////////////////////////////
1:     addOption(SEARCHER_CLASS_OPTION, "sc", "The type of searcher to be used when performing nearest "
1:         + "neighbor searches. Defaults to ProjectionSearch.", ProjectionSearch.class.getCanonicalName());
1:     addOption(NUM_PROJECTIONS_OPTION, "np", "The number of projections considered in estimating the "
1:         + "distances between vectors. Only used when the distance measure requested is either "
1:         + "ProjectionSearch or FastProjectionSearch. If no value is given, defaults to 3.", String.valueOf(3));
1:     addOption(SEARCH_SIZE_OPTION, "s", "In more efficient searches (non BruteSearch), "
1:         + "not all distances are calculated for determining the nearest neighbors. The number of "
1:         + "elements whose distances from the query vector is actually computer is proportional to "
1:         + "searchSize. If no value is given, defaults to 1.", String.valueOf(2));
1:     addFlag(REDUCE_STREAMING_KMEANS, "rskm", "There might be too many intermediate clusters from the mapper "
1:         + "to fit into memory, so the reducer can run another pass of StreamingKMeans to collapse them down to a "
1:         + "fewer clusters");
/////////////////////////////////////////////////////////////////////////
1:     Preconditions.checkArgument(estimatedNumMapClusters > numClusters, "Invalid number of estimated map "
1:         + "clusters; There must be more than the final number of clusters (k log n vs k)");
1:     Preconditions.checkArgument(testProbability >= 0 && testProbability < 1, "test probability is not in the "
1:         + "interval [0, 1)");
/////////////////////////////////////////////////////////////////////////
1:     log.info("Parameters are: [k] numClusters {}; "
1:         + "[SKM] estimatedNumMapClusters {}; estimatedDistanceCutoff {} "
1:         + "[BKM] maxNumIterations {}; trimFraction {}; randomInit {}; ignoreWeights {}; "
1:         + "testProbability {}; numBallKMeansRuns {}; "
1:         + "[S] measureClass {}; searcherClass {}; searcherSize {}; numProjections {}; "
1:         + "method {}; reduceStreamingKMeans {}", numClusters, estimatedNumMapClusters, estimatedDistanceCutoff,
/////////////////////////////////////////////////////////////////////////
0:     throws IOException, ExecutionException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:   public static int runMapReduce(Configuration conf, Path input, Path output)
1:     throws IOException, ClassNotFoundException, InterruptedException {
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:4ca6b86
/////////////////////////////////////////////////////////////////////////
0:   public static int run(Configuration conf, Path input, Path output) throws Exception {
============================================================================