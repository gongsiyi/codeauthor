1:35fa73f: /*
1:35fa73f: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1:35fa73f: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1:35fa73f: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1:35fa73f: that both that copyright notice and this permission notice appear in supporting documentation. 
1:35fa73f: CERN makes no representations about the suitability of this software for any purpose. 
1:35fa73f: It is provided "as is" without expressed or implied warranty.
1:35fa73f: */
1:35fa73f: package org.apache.mahout.math.map;
1:35fa73f: 
1:35fa73f: /**
1:35fa73f:  * Status: Experimental; Do not use for production yet. Hash map holding (key,value) associations of type
1:35fa73f:  * <tt>(int-->int)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double
1:35fa73f:  * hashing. First see the <a href="package-summary.html">package summary</a> and javadoc <a
1:35fa73f:  * href="package-tree.html">tree view</a> to get the broad picture.
1:35fa73f:  *
1:35fa73f:  * Implements open addressing with double hashing, using "Brent's variation". Brent's variation slows insertions a bit
1:35fa73f:  * down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors. (It
1:35fa73f:  * does not improve unsuccessful searches.) See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
1:35fa73f:  *
1:35fa73f:  * @author wolfgang.hoschek@cern.ch
1:35fa73f:  * @version 1.0, 09/24/99
1:35fa73f:  * @see java.util.HashMap
1:35fa73f:  */
1:35fa73f: class QuickOpenIntIntHashMap extends OpenIntIntHashMap {
1:35fa73f:   //public int totalProbesSaved = 0; // benchmark only
1:35fa73f: 
1:35fa73f:   /** Constructs an empty map with default capacity and default load factors. */
1:35fa73f:   QuickOpenIntIntHashMap() {
1:6d16230:     this(DEFAULT_CAPACITY);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and default load factors.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity of the map.
1:35fa73f:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:35fa73f:    */
1:35fa73f:   QuickOpenIntIntHashMap(int initialCapacity) {
1:6d16230:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:35fa73f:    *
1:35fa73f:    * @param initialCapacity the initial capacity.
1:35fa73f:    * @param minLoadFactor   the minimum load factor.
1:35fa73f:    * @param maxLoadFactor   the maximum load factor.
1:35fa73f:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:35fa73f:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:35fa73f:    *                                  maxLoadFactor)</tt>.
1:35fa73f:    */
1:35fa73f:   QuickOpenIntIntHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:35fa73f:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
1:35fa73f:    * existing.
1:35fa73f:    *
1:35fa73f:    * @param key   the key the value shall be associated with.
1:35fa73f:    * @param value the value to be associated.
1:35fa73f:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
1:35fa73f:    *         already contain such a key - the new value has now replaced the formerly associated value.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   public boolean put(int key, int value) {
1:35fa73f:     /*
1:35fa73f:        This is open addressing with double hashing, using "Brent's variation".
1:6d16230:        Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches,
1:6d16230:        in particular for large load factors.
1:35fa73f:        (It does not improve unsuccessful searches.)
1:35fa73f:        See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
1:35fa73f: 
1:35fa73f:        h1(key) = hash % M
1:35fa73f:        h2(key) = decrement = Max(1, hash/M % M)
1:35fa73f:        M is prime = capacity = table.length
1:35fa73f:        probing positions are table[(h1-j*h2) % M] for j=0,1,...
1:35fa73f:        (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)
1:35fa73f:     */
1:35fa73f: 
1:35fa73f:     int[] tab = table;
1:35fa73f:     byte[] stat = state;
1:35fa73f:     int length = tab.length;
1:35fa73f: 
1:35fa73f:     int hash = HashFunctions.hash(key) & 0x7FFFFFFF;
1:35fa73f:     int i = hash % length;
1:35fa73f:     int decrement = (hash / length) % length;
1:35fa73f:     if (decrement == 0) {
1:35fa73f:       decrement = 1;
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     // stop if we find a removed or free slot, or if we find the key itself
1:35fa73f:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:35fa73f:     //int comp = comparisons;
1:35fa73f:     int t = 0;  // the number of probes
1:35fa73f:     int p0 = i; // the first position to probe
1:35fa73f:     while (stat[i] == FULL && tab[i] != key) {
1:35fa73f:       t++;
1:35fa73f:       i -= decrement;
1:35fa73f:       //hashCollisions++;
1:35fa73f:       if (i < 0) {
1:35fa73f:         i += length;
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     if (stat[i] == FULL) {
1:35fa73f:       // key already contained at slot i.
1:35fa73f:       this.values[i] = value;
1:35fa73f:       return false;
1:35fa73f:     }
1:35fa73f:     // not already contained, should be inserted at slot i.
1:35fa73f: 
1:35fa73f:     if (this.distinct > this.highWaterMark) {
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:       return put(key, value);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     /*
1:35fa73f:     Brent's variation does a local reorganization to reduce probes. It essentially means:
1:35fa73f:     We test whether it is possible to move the association we probed first (table[p0]) out of the way.
1:6d16230:     If this is possible, it will reduce probes for the key to be inserted, since it takes its place;
1:6d16230:     it gets hit earlier.
1:35fa73f:     However, future probes for the key that we move out of the way will increase.
1:35fa73f:     Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.
1:35fa73f:     For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).
1:35fa73f:     If the first probe cannot be moved out of the way, we try the next probe (p1).
1:35fa73f:     Now we safe more than we loose if t>=3.
1:35fa73f:     We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.
1:35fa73f: 
1:35fa73f:     Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.
1:35fa73f:     */
1:35fa73f:     while (t > 1) {
1:35fa73f:       int key0 = tab[p0];
1:35fa73f:       hash = HashFunctions.hash(key0) & 0x7FFFFFFF;
1:35fa73f:       decrement = (hash / length) % length;
1:35fa73f:       if (decrement == 0) {
1:35fa73f:         decrement = 1;
1:35fa73f:       }
1:35fa73f:       int pc = p0 - decrement; // pc = (p0-j*decrement) % M, j=1,2,..
1:35fa73f:       if (pc < 0) {
1:35fa73f:         pc += length;
1:35fa73f:       }
1:35fa73f: 
1:35fa73f:       if (stat[pc] != FREE) { // not a free slot, continue searching for free slot to move to, or break.
1:35fa73f:         p0 = pc;
1:35fa73f:         t--;
1:35fa73f:       } else { // free or removed slot found, now move...
1:35fa73f:         tab[pc] = key0;
1:35fa73f:         stat[pc] = FULL;
1:35fa73f:         values[pc] = values[p0];
1:35fa73f:         i = p0; // prepare to insert: table[p0]=key
1:35fa73f:         t = 0; // break loop
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     this.table[i] = key;
1:35fa73f:     this.values[i] = value;
1:35fa73f:     if (this.state[i] == FREE) {
1:35fa73f:       this.freeEntries--;
1:35fa73f:     }
1:35fa73f:     this.state[i] = FULL;
1:35fa73f:     this.distinct++;
1:35fa73f: 
1:35fa73f:     if (this.freeEntries < 1) { //delta
1:35fa73f:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:35fa73f:       rehash(newCapacity);
1:35fa73f:     }
1:35fa73f: 
1:35fa73f:     return true;
1:35fa73f:   }
1:35fa73f: 
1:35fa73f:   /**
1:35fa73f:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:35fa73f:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:35fa73f:    * mark.
1:35fa73f:    */
1:35fa73f:   @Override
1:35fa73f:   protected void rehash(int newCapacity) {
1:35fa73f:     int oldCapacity = table.length;
1:35fa73f:     //if (oldCapacity == newCapacity) return;
1:35fa73f: 
1:35fa73f:     int[] oldTable = table;
1:35fa73f:     int[] oldValues = values;
1:35fa73f:     byte[] oldState = state;
1:35fa73f: 
1:35fa73f:     int[] newTable = new int[newCapacity];
1:35fa73f:     int[] newValues = new int[newCapacity];
1:35fa73f:     byte[] newState = new byte[newCapacity];
1:35fa73f: 
1:35fa73f:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:35fa73f:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1:35fa73f: 
1:35fa73f:     this.table = newTable;
1:35fa73f:     this.values = newValues;
1:35fa73f:     this.state = newState;
1:35fa73f:     this.freeEntries = newCapacity - this.distinct; // delta
1:35fa73f: 
1:35fa73f:     int tmp = this.distinct;
1:35fa73f:     this.distinct = Integer.MIN_VALUE; // switch of watermarks
1:35fa73f:     for (int i = oldCapacity; i-- > 0;) {
1:35fa73f:       if (oldState[i] == FULL) {
1:35fa73f:         put(oldTable[i], oldValues[i]);
1:35fa73f:         /*
1:35fa73f:         int element = oldTable[i];
1:35fa73f:         int index = indexOfInsertion(element);
1:35fa73f:         newTable[index]=element;
1:35fa73f:         newValues[index]=oldValues[i];
1:35fa73f:         newState[index]=FULL;
1:35fa73f:         */
1:35fa73f:       }
1:35fa73f:     }
1:35fa73f:     this.distinct = tmp;
1:35fa73f:   }
1:35fa73f: }
============================================================================
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
1:     this(DEFAULT_CAPACITY);
/////////////////////////////////////////////////////////////////////////
1:     this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);
/////////////////////////////////////////////////////////////////////////
1:        Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches,
1:        in particular for large load factors.
/////////////////////////////////////////////////////////////////////////
1:     If this is possible, it will reduce probes for the key to be inserted, since it takes its place;
1:     it gets hit earlier.
author:Ted Dunning
-------------------------------------------------------------------------------
commit:35fa73f
/////////////////////////////////////////////////////////////////////////
1: /*
1: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
1: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
1: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
1: that both that copyright notice and this permission notice appear in supporting documentation. 
1: CERN makes no representations about the suitability of this software for any purpose. 
1: It is provided "as is" without expressed or implied warranty.
1: */
1: package org.apache.mahout.math.map;
1: 
1: /**
1:  * Status: Experimental; Do not use for production yet. Hash map holding (key,value) associations of type
1:  * <tt>(int-->int)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double
1:  * hashing. First see the <a href="package-summary.html">package summary</a> and javadoc <a
1:  * href="package-tree.html">tree view</a> to get the broad picture.
1:  *
1:  * Implements open addressing with double hashing, using "Brent's variation". Brent's variation slows insertions a bit
1:  * down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors. (It
1:  * does not improve unsuccessful searches.) See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
1:  *
1:  * @author wolfgang.hoschek@cern.ch
1:  * @version 1.0, 09/24/99
1:  * @see java.util.HashMap
1:  */
1: class QuickOpenIntIntHashMap extends OpenIntIntHashMap {
1:   //public int totalProbesSaved = 0; // benchmark only
1: 
1:   /** Constructs an empty map with default capacity and default load factors. */
1:   QuickOpenIntIntHashMap() {
0:     this(defaultCapacity);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and default load factors.
1:    *
1:    * @param initialCapacity the initial capacity of the map.
1:    * @throws IllegalArgumentException if the initial capacity is less than zero.
1:    */
1:   QuickOpenIntIntHashMap(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
1:   }
1: 
1:   /**
1:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
1:    *
1:    * @param initialCapacity the initial capacity.
1:    * @param minLoadFactor   the minimum load factor.
1:    * @param maxLoadFactor   the maximum load factor.
1:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
1:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
1:    *                                  maxLoadFactor)</tt>.
1:    */
1:   QuickOpenIntIntHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
1:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
1:   }
1: 
1:   /**
1:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
1:    * existing.
1:    *
1:    * @param key   the key the value shall be associated with.
1:    * @param value the value to be associated.
1:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
1:    *         already contain such a key - the new value has now replaced the formerly associated value.
1:    */
1:   @Override
1:   public boolean put(int key, int value) {
1:     /*
1:        This is open addressing with double hashing, using "Brent's variation".
0:        Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors.
1:        (It does not improve unsuccessful searches.)
1:        See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
1: 
1:        h1(key) = hash % M
1:        h2(key) = decrement = Max(1, hash/M % M)
1:        M is prime = capacity = table.length
1:        probing positions are table[(h1-j*h2) % M] for j=0,1,...
1:        (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)
1:     */
1: 
1:     int[] tab = table;
1:     byte[] stat = state;
1:     int length = tab.length;
1: 
1:     int hash = HashFunctions.hash(key) & 0x7FFFFFFF;
1:     int i = hash % length;
1:     int decrement = (hash / length) % length;
1:     if (decrement == 0) {
1:       decrement = 1;
1:     }
1: 
1:     // stop if we find a removed or free slot, or if we find the key itself
1:     // do NOT skip over removed slots (yes, open addressing is like that...)
1:     //int comp = comparisons;
1:     int t = 0;  // the number of probes
1:     int p0 = i; // the first position to probe
1:     while (stat[i] == FULL && tab[i] != key) {
1:       t++;
1:       i -= decrement;
1:       //hashCollisions++;
1:       if (i < 0) {
1:         i += length;
1:       }
1:     }
1:     if (stat[i] == FULL) {
1:       // key already contained at slot i.
1:       this.values[i] = value;
1:       return false;
1:     }
1:     // not already contained, should be inserted at slot i.
1: 
1:     if (this.distinct > this.highWaterMark) {
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:       return put(key, value);
1:     }
1: 
1:     /*
1:     Brent's variation does a local reorganization to reduce probes. It essentially means:
1:     We test whether it is possible to move the association we probed first (table[p0]) out of the way.
0:     If this is possible, it will reduce probes for the key to be inserted, since it takes its place; it gets hit earlier.
1:     However, future probes for the key that we move out of the way will increase.
1:     Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.
1:     For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).
1:     If the first probe cannot be moved out of the way, we try the next probe (p1).
1:     Now we safe more than we loose if t>=3.
1:     We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.
1: 
1:     Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.
1:     */
1:     while (t > 1) {
1:       int key0 = tab[p0];
1:       hash = HashFunctions.hash(key0) & 0x7FFFFFFF;
1:       decrement = (hash / length) % length;
1:       if (decrement == 0) {
1:         decrement = 1;
1:       }
1:       int pc = p0 - decrement; // pc = (p0-j*decrement) % M, j=1,2,..
1:       if (pc < 0) {
1:         pc += length;
1:       }
1: 
1:       if (stat[pc] != FREE) { // not a free slot, continue searching for free slot to move to, or break.
1:         p0 = pc;
1:         t--;
1:       } else { // free or removed slot found, now move...
1:         tab[pc] = key0;
1:         stat[pc] = FULL;
1:         values[pc] = values[p0];
1:         i = p0; // prepare to insert: table[p0]=key
1:         t = 0; // break loop
1:       }
1:     }
1: 
1:     this.table[i] = key;
1:     this.values[i] = value;
1:     if (this.state[i] == FREE) {
1:       this.freeEntries--;
1:     }
1:     this.state[i] = FULL;
1:     this.distinct++;
1: 
1:     if (this.freeEntries < 1) { //delta
1:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
1:       rehash(newCapacity);
1:     }
1: 
1:     return true;
1:   }
1: 
1:   /**
1:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
1:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
1:    * mark.
1:    */
1:   @Override
1:   protected void rehash(int newCapacity) {
1:     int oldCapacity = table.length;
1:     //if (oldCapacity == newCapacity) return;
1: 
1:     int[] oldTable = table;
1:     int[] oldValues = values;
1:     byte[] oldState = state;
1: 
1:     int[] newTable = new int[newCapacity];
1:     int[] newValues = new int[newCapacity];
1:     byte[] newState = new byte[newCapacity];
1: 
1:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
1:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
1: 
1:     this.table = newTable;
1:     this.values = newValues;
1:     this.state = newState;
1:     this.freeEntries = newCapacity - this.distinct; // delta
1: 
1:     int tmp = this.distinct;
1:     this.distinct = Integer.MIN_VALUE; // switch of watermarks
1:     for (int i = oldCapacity; i-- > 0;) {
1:       if (oldState[i] == FULL) {
1:         put(oldTable[i], oldValues[i]);
1:         /*
1:         int element = oldTable[i];
1:         int index = indexOfInsertion(element);
1:         newTable[index]=element;
1:         newValues[index]=oldValues[i];
1:         newState[index]=FULL;
1:         */
1:       }
1:     }
1:     this.distinct = tmp;
1:   }
1: }
author:Benson Margulies
-------------------------------------------------------------------------------
commit:ebf9a4d
/////////////////////////////////////////////////////////////////////////
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:ea65197
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a90e57e
/////////////////////////////////////////////////////////////////////////
0:     //log.info("insert search for (key,value)=("+key+","+value+") at i="+i+", dec="+decrement);
/////////////////////////////////////////////////////////////////////////
0:     //if (comparisons-comp>0) log.info("probed "+(comparisons-comp)+" slots.");
/////////////////////////////////////////////////////////////////////////
0:       //log.info("grow rehashing ");
0:       //log.info("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
/////////////////////////////////////////////////////////////////////////
0:       //log.info("t="+t);
/////////////////////////////////////////////////////////////////////////
0:         //log.info("copying p0="+p0+" to pc="+pc+", (key,val)=("+tab[p0]+","+values[p0]+"), saving "+(t-1)+" probes.");
/////////////////////////////////////////////////////////////////////////
0:     //log.info("inserting at i="+i);
commit:7926fcb
/////////////////////////////////////////////////////////////////////////
0:  * Status: Experimental; Do not use for production yet. Hash map holding (key,value) associations of type
0:  * <tt>(int-->int)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double
0:  * hashing. First see the <a href="package-summary.html">package summary</a> and javadoc <a
0:  * href="package-tree.html">tree view</a> to get the broad picture.
0:  *
0:  * Implements open addressing with double hashing, using "Brent's variation". Brent's variation slows insertions a bit
0:  * down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors. (It
0:  * does not improve unsuccessful searches.) See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
0:  *
0:  * @author wolfgang.hoschek@cern.ch
0:  * @version 1.0, 09/24/99
0:  * @see java.util.HashMap
0:  */
0:   //public int totalProbesSaved = 0; // benchmark only
0:   /** Constructs an empty map with default capacity and default load factors. */
0:   QuickOpenIntIntHashMap() {
0:     this(defaultCapacity);
0:   /**
0:    * Constructs an empty map with the specified initial capacity and default load factors.
0:    *
0:    * @param initialCapacity the initial capacity of the map.
0:    * @throws IllegalArgumentException if the initial capacity is less than zero.
0:    */
0:   QuickOpenIntIntHashMap(int initialCapacity) {
0:     this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
0:   }
0:   /**
0:    * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.
0:    *
0:    * @param initialCapacity the initial capacity.
0:    * @param minLoadFactor   the minimum load factor.
0:    * @param maxLoadFactor   the maximum load factor.
0:    * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||
0:    *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=
0:    *                                  maxLoadFactor)</tt>.
0:    */
0:   QuickOpenIntIntHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0:     setUp(initialCapacity, minLoadFactor, maxLoadFactor);
0:   }
0: 
0:   /**
0:    * Associates the given key with the given value. Replaces any old <tt>(key,someOtherValue)</tt> association, if
0:    * existing.
0:    *
0:    * @param key   the key the value shall be associated with.
0:    * @param value the value to be associated.
0:    * @return <tt>true</tt> if the receiver did not already contain such a key; <tt>false</tt> if the receiver did
0:    *         already contain such a key - the new value has now replaced the formerly associated value.
0:    */
0:   @Override
0:   public boolean put(int key, int value) {
0:     /*
0:        This is open addressing with double hashing, using "Brent's variation".
0:        Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors.
0:        (It does not improve unsuccessful searches.)
0:        See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
0: 
0:        h1(key) = hash % M
0:        h2(key) = decrement = Max(1, hash/M % M)
0:        M is prime = capacity = table.length
0:        probing positions are table[(h1-j*h2) % M] for j=0,1,...
0:        (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)
0:     */
0: 
0:     int[] tab = table;
0:     byte[] stat = state;
0:     int length = tab.length;
0: 
0:     int hash = HashFunctions.hash(key) & 0x7FFFFFFF;
0:     int i = hash % length;
0:     int decrement = (hash / length) % length;
0:     if (decrement == 0) {
0:       decrement = 1;
0:     //System.out.println("insert search for (key,value)=("+key+","+value+") at i="+i+", dec="+decrement);
0: 
0:     // stop if we find a removed or free slot, or if we find the key itself
0:     // do NOT skip over removed slots (yes, open addressing is like that...)
0:     //int comp = comparisons;
0:     int t = 0;  // the number of probes
0:     int p0 = i; // the first position to probe
0:     while (stat[i] == FULL && tab[i] != key) {
0:       t++;
0:       i -= decrement;
0:       //hashCollisions++;
0:       if (i < 0) {
0:         i += length;
0:       }
0:     //if (comparisons-comp>0) System.out.println("probed "+(comparisons-comp)+" slots.");
0:     if (stat[i] == FULL) {
0:       // key already contained at slot i.
0:       this.values[i] = value;
0:       return false;
0:     // not already contained, should be inserted at slot i.
0: 
0:     if (this.distinct > this.highWaterMark) {
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0: 
0:       //System.out.print("grow rehashing ");
0:       //System.out.println("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0: 
0:       rehash(newCapacity);
0:       return put(key, value);
0:     }
0: 
0:     /*
0:     Brent's variation does a local reorganization to reduce probes. It essentially means:
0:     We test whether it is possible to move the association we probed first (table[p0]) out of the way.
0:     If this is possible, it will reduce probes for the key to be inserted, since it takes its place; it gets hit earlier.
0:     However, future probes for the key that we move out of the way will increase.
0:     Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.
0:     For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).
0:     If the first probe cannot be moved out of the way, we try the next probe (p1).
0:     Now we safe more than we loose if t>=3.
0:     We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.
0: 
0:     Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.
0:     */
0:     while (t > 1) {
0:       //System.out.println("t="+t);
0:       int key0 = tab[p0];
0:       hash = HashFunctions.hash(key0) & 0x7FFFFFFF;
0:       decrement = (hash / length) % length;
0:       if (decrement == 0) {
0:         decrement = 1;
0:       }
0:       int pc = p0 - decrement; // pc = (p0-j*decrement) % M, j=1,2,..
0:       if (pc < 0) {
0:         pc += length;
0:       }
0: 
0:       if (stat[pc] != FREE) { // not a free slot, continue searching for free slot to move to, or break.
0:         p0 = pc;
0:         t--;
0:       } else { // free or removed slot found, now move...
0:         //System.out.println("copying p0="+p0+" to pc="+pc+", (key,val)=("+tab[p0]+","+values[p0]+"), saving "+(t-1)+" probes.");
0:         //this.totalProbesSaved += (t - 1);
0:         tab[pc] = key0;
0:         stat[pc] = FULL;
0:         values[pc] = values[p0];
0:         i = p0; // prepare to insert: table[p0]=key
0:         t = 0; // break loop
0:       }
0:     }
0: 
0:     //System.out.println("inserting at i="+i);
0:     this.table[i] = key;
0:     this.values[i] = value;
0:     if (this.state[i] == FREE) {
0:       this.freeEntries--;
0:     }
0:     this.state[i] = FULL;
0:     this.distinct++;
0: 
0:     if (this.freeEntries < 1) { //delta
0:       int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
0:       rehash(newCapacity);
0:     }
0: 
0:     return true;
0: 
0:   /**
0:    * Rehashes the contents of the receiver into a new table with a smaller or larger capacity. This method is called
0:    * automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water
0:    * mark.
0:    */
0:   @Override
0:   protected void rehash(int newCapacity) {
0:     int oldCapacity = table.length;
0:     //if (oldCapacity == newCapacity) return;
0: 
0:     int[] oldTable = table;
0:     int[] oldValues = values;
0:     byte[] oldState = state;
0: 
0:     int[] newTable = new int[newCapacity];
0:     int[] newValues = new int[newCapacity];
0:     byte[] newState = new byte[newCapacity];
0: 
0:     this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);
0:     this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);
0: 
0:     this.table = newTable;
0:     this.values = newValues;
0:     this.state = newState;
0:     this.freeEntries = newCapacity - this.distinct; // delta
0: 
0:     int tmp = this.distinct;
0:     this.distinct = Integer.MIN_VALUE; // switch of watermarks
0:     for (int i = oldCapacity; i-- > 0;) {
0:       if (oldState[i] == FULL) {
0:         put(oldTable[i], oldValues[i]);
0:         /*
0:         int element = oldTable[i];
0:         int index = indexOfInsertion(element);
0:         newTable[index]=element;
0:         newValues[index]=oldValues[i];
0:         newState[index]=FULL;
0:         */
0:       }
0:     }
0:     this.distinct = tmp;
0:   }
commit:fcbc54a
/////////////////////////////////////////////////////////////////////////
0: @see      java.util.HashMap
0:   public int totalProbesSaved = 0; // benchmark only
0:   this(defaultCapacity);
/////////////////////////////////////////////////////////////////////////
0:   this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
/////////////////////////////////////////////////////////////////////////
0:  * @throws  IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.
0:   setUp(initialCapacity,minLoadFactor,maxLoadFactor);
/////////////////////////////////////////////////////////////////////////
0:   /* 
0:      This is open addressing with double hashing, using "Brent's variation".
0:      Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors.
0:      (It does not improve unsuccessful searches.)
0:      See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
0:   
0:      h1(key) = hash % M
0:      h2(key) = decrement = Max(1, hash/M % M)
0:      M is prime = capacity = table.length
0:      probing positions are table[(h1-j*h2) % M] for j=0,1,...
0:      (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)
0:   */
0:   
0:   int key0;
0:   final int tab[] = table;
0:   final byte stat[] = state;
0:   final int length = tab.length;
0:   int hash = HashFunctions.hash(key) & 0x7FFFFFFF;
0:   int i = hash % length;
0:   int decrement = (hash / length) % length;
0:   if (decrement == 0) decrement = 1;
0:   //System.out.println("insert search for (key,value)=("+key+","+value+") at i="+i+", dec="+decrement);
0:   // stop if we find a removed or free slot, or if we find the key itself
0:   // do NOT skip over removed slots (yes, open addressing is like that...)
0:   //int comp = comparisons;
0:   int t = 0;  // the number of probes
0:   int p0 = i; // the first position to probe
0:   while (stat[i] == FULL && tab[i] != key) {
0:     t++;
0:     i -= decrement;
0:     //hashCollisions++;
0:     if (i<0) i+=length;    
0:   }
0:   //if (comparisons-comp>0) System.out.println("probed "+(comparisons-comp)+" slots.");
0:   if (stat[i] == FULL) {
0:     // key already contained at slot i.
0:     this.values[i]=value;
0:     return false;
0:   }
0:   // not already contained, should be inserted at slot i.
0:   
0:   if (this.distinct > this.highWaterMark) {
0:     int newCapacity = chooseGrowCapacity(this.distinct+1,this.minLoadFactor, this.maxLoadFactor);
0:     
0:     //System.out.print("grow rehashing ");
0:     //System.out.println("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0:     
0:     rehash(newCapacity);
0:     return put(key, value);
0:   }
0:   /*
0:   Brent's variation does a local reorganization to reduce probes. It essentially means:
0:   We test whether it is possible to move the association we probed first (table[p0]) out of the way.
0:   If this is possible, it will reduce probes for the key to be inserted, since it takes its place; it gets hit earlier.
0:   However, future probes for the key that we move out of the way will increase.
0:   Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.
0:   For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).
0:   If the first probe cannot be moved out of the way, we try the next probe (p1).
0:   Now we safe more than we loose if t>=3.
0:   We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.
0:   Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.
0:   */
0:   while (t>1) {
0:     //System.out.println("t="+t);
0:     key0 = tab[p0];
0:     hash = HashFunctions.hash(key0) & 0x7FFFFFFF;
0:     decrement = (hash / length) % length;
0:     if (decrement == 0) decrement = 1;
0:     int pc = p0-decrement; // pc = (p0-j*decrement) % M, j=1,2,..
0:     if (pc<0) pc += length;
0:     
0:     if (stat[pc] != FREE) { // not a free slot, continue searching for free slot to move to, or break.
0:       p0 = pc;
0:       t--;
0:     }
0:     else { // free or removed slot found, now move...
0:       //System.out.println("copying p0="+p0+" to pc="+pc+", (key,val)=("+tab[p0]+","+values[p0]+"), saving "+(t-1)+" probes.");
0:       this.totalProbesSaved += (t-1);
0:       tab[pc] = key0;
0:       stat[pc] = FULL;
0:       values[pc] = values[p0];
0:       i = p0; // prepare to insert: table[p0]=key
0:       t = 0; // break loop 
0:     }
0:   }
0:   //System.out.println("inserting at i="+i);
0:   this.table[i]=key;
0:   this.values[i]=value;
0:   if (this.state[i]==FREE) this.freeEntries--;
0:   this.state[i]=FULL;
0:   this.distinct++;
0:   if (this.freeEntries < 1) { //delta
0:     int newCapacity = chooseGrowCapacity(this.distinct+1,this.minLoadFactor, this.maxLoadFactor);
0:     rehash(newCapacity);
0:   }
0:   return true;
/////////////////////////////////////////////////////////////////////////
0:   int oldCapacity = table.length;
0:   //if (oldCapacity == newCapacity) return;
0:   
0:   int oldTable[] = table;
0:   int oldValues[] = values;
0:   byte oldState[] = state;
0:   int newTable[] = new int[newCapacity];
0:   int newValues[] = new int[newCapacity];
0:   byte newState[] = new byte[newCapacity];
0:   this.lowWaterMark  = chooseLowWaterMark(newCapacity,this.minLoadFactor);
0:   this.highWaterMark = chooseHighWaterMark(newCapacity,this.maxLoadFactor);
0:   this.table = newTable;
0:   this.values = newValues;
0:   this.state = newState;
0:   this.freeEntries = newCapacity-this.distinct; // delta
0:   int tmp = this.distinct;
0:   this.distinct = Integer.MIN_VALUE; // switch of watermarks
0:   for (int i = oldCapacity ; i-- > 0 ;) {
0:     if (oldState[i]==FULL) {
0:       put(oldTable[i], oldValues[i]);
0:       /*
0:       int element = oldTable[i];
0:       int index = indexOfInsertion(element);
0:       newTable[index]=element;
0:       newValues[index]=oldValues[i];
0:       newState[index]=FULL;
0:       */
0:     }
0:   }
0:   this.distinct = tmp;
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:a435efb
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.math.map;
commit:f49424e
/////////////////////////////////////////////////////////////////////////
0: package org.apache.mahout.matrix.map;
commit:7550a10
/////////////////////////////////////////////////////////////////////////
0: /*
0: Copyright ï¿? 1999 CERN - European Organization for Nuclear Research.
0: Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
0: is hereby granted without fee, provided that the above copyright notice appear in all copies and 
0: that both that copyright notice and this permission notice appear in supporting documentation. 
0: CERN makes no representations about the suitability of this software for any purpose. 
0: It is provided "as is" without expressed or implied warranty.
0: */
0: package org.apache.mahout.colt.map;
0: 
0: /**
0: Status: Experimental; Do not use for production yet. Hash map holding (key,value) associations of type <tt>(int-->int)</tt>; Automatically grows and shrinks as needed; Implemented using open addressing with double hashing.
0: First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
0: 
0: Implements open addressing with double hashing, using "Brent's variation".
0: Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors.
0: (It does not improve unsuccessful searches.)
0: See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
0:  
0: @author wolfgang.hoschek@cern.ch
0: @version 1.0, 09/24/99
0: @see	    java.util.HashMap
0: */
0: class QuickOpenIntIntHashMap extends OpenIntIntHashMap {
0: 	public int totalProbesSaved = 0; // benchmark only
0: /**
0:  * Constructs an empty map with default capacity and default load factors.
0:  */
0: public QuickOpenIntIntHashMap() {
0: 	this(defaultCapacity);
0: }
0: /**
0:  * Constructs an empty map with the specified initial capacity and default load factors.
0:  *
0:  * @param      initialCapacity   the initial capacity of the map.
0:  * @throws     IllegalArgumentException if the initial capacity is less
0:  *             than zero.
0:  */
0: public QuickOpenIntIntHashMap(int initialCapacity) {
0: 	this(initialCapacity, defaultMinLoadFactor, defaultMaxLoadFactor);
0: }
0: /**
0:  * Constructs an empty map with
0:  * the specified initial capacity and the specified minimum and maximum load factor.
0:  *
0:  * @param      initialCapacity   the initial capacity.
0:  * @param      minLoadFactor        the minimum load factor.
0:  * @param      maxLoadFactor        the maximum load factor.
0:  * @throws	IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.
0:  */
0: public QuickOpenIntIntHashMap(int initialCapacity, double minLoadFactor, double maxLoadFactor) {
0: 	setUp(initialCapacity,minLoadFactor,maxLoadFactor);
0: }
0: /**
0:  * Associates the given key with the given value.
0:  * Replaces any old <tt>(key,someOtherValue)</tt> association, if existing.
0:  *
0:  * @param key the key the value shall be associated with.
0:  * @param value the value to be associated.
0:  * @return <tt>true</tt> if the receiver did not already contain such a key;
0:  *         <tt>false</tt> if the receiver did already contain such a key - the new value has now replaced the formerly associated value.
0:  */
0: public boolean put(int key, int value) {
0: 	/* 
0: 	   This is open addressing with double hashing, using "Brent's variation".
0: 	   Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors.
0: 	   (It does not improve unsuccessful searches.)
0: 	   See D. Knuth, Searching and Sorting, 3rd ed., p.533-545
0: 	
0: 	   h1(key) = hash % M
0: 	   h2(key) = decrement = Max(1, hash/M % M)
0: 	   M is prime = capacity = table.length
0: 	   probing positions are table[(h1-j*h2) % M] for j=0,1,...
0: 	   (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)
0: 	*/
0: 	
0: 	int key0;
0: 	final int tab[] = table;
0: 	final byte stat[] = state;
0: 	final int length = tab.length;
0: 
0: 	int hash = HashFunctions.hash(key) & 0x7FFFFFFF;
0: 	int i = hash % length;
0: 	int decrement = (hash / length) % length;
0: 	if (decrement == 0) decrement = 1;
0: 	//System.out.println("insert search for (key,value)=("+key+","+value+") at i="+i+", dec="+decrement);
0: 
0: 	// stop if we find a removed or free slot, or if we find the key itself
0: 	// do NOT skip over removed slots (yes, open addressing is like that...)
0: 	//int comp = comparisons;
0: 	int t = 0;  // the number of probes
0: 	int p0 = i; // the first position to probe
0: 	while (stat[i] == FULL && tab[i] != key) {
0: 		t++;
0: 		i -= decrement;
0: 		//hashCollisions++;
0: 		if (i<0) i+=length;		
0: 	}
0: 	//if (comparisons-comp>0) System.out.println("probed "+(comparisons-comp)+" slots.");
0: 	if (stat[i] == FULL) {
0: 		// key already contained at slot i.
0: 		this.values[i]=value;
0: 		return false;
0: 	}
0: 	// not already contained, should be inserted at slot i.
0: 	
0: 	if (this.distinct > this.highWaterMark) {
0: 		int newCapacity = chooseGrowCapacity(this.distinct+1,this.minLoadFactor, this.maxLoadFactor);
0: 		
0: 		//System.out.print("grow rehashing ");
0: 		//System.out.println("at distinct="+distinct+", capacity="+table.length+" to newCapacity="+newCapacity+" ...");
0: 		
0: 		rehash(newCapacity);
0: 		return put(key, value);
0: 	}
0: 
0: 	/*
0: 	Brent's variation does a local reorganization to reduce probes. It essentially means:
0: 	We test whether it is possible to move the association we probed first (table[p0]) out of the way.
0: 	If this is possible, it will reduce probes for the key to be inserted, since it takes its place; it gets hit earlier.
0: 	However, future probes for the key that we move out of the way will increase.
0: 	Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.
0: 	For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).
0: 	If the first probe cannot be moved out of the way, we try the next probe (p1).
0: 	Now we safe more than we loose if t>=3.
0: 	We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.
0: 
0: 	Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.
0: 	*/
0: 	while (t>1) {
0: 		//System.out.println("t="+t);
0: 		key0 = tab[p0];
0: 		hash = HashFunctions.hash(key0) & 0x7FFFFFFF;
0: 		decrement = (hash / length) % length;
0: 		if (decrement == 0) decrement = 1;
0: 		int pc = p0-decrement; // pc = (p0-j*decrement) % M, j=1,2,..
0: 		if (pc<0) pc += length;
0: 		
0: 		if (stat[pc] != FREE) { // not a free slot, continue searching for free slot to move to, or break.
0: 			p0 = pc;
0: 			t--;
0: 		}
0: 		else { // free or removed slot found, now move...
0: 			//System.out.println("copying p0="+p0+" to pc="+pc+", (key,val)=("+tab[p0]+","+values[p0]+"), saving "+(t-1)+" probes.");
0: 			this.totalProbesSaved += (t-1);
0: 			tab[pc] = key0;
0: 			stat[pc] = FULL;
0: 			values[pc] = values[p0];
0: 			i = p0; // prepare to insert: table[p0]=key
0: 			t = 0; // break loop 
0: 		}
0: 	}
0: 
0: 	//System.out.println("inserting at i="+i);
0: 	this.table[i]=key;
0: 	this.values[i]=value;
0: 	if (this.state[i]==FREE) this.freeEntries--;
0: 	this.state[i]=FULL;
0: 	this.distinct++;
0: 
0: 	if (this.freeEntries < 1) { //delta
0: 		int newCapacity = chooseGrowCapacity(this.distinct+1,this.minLoadFactor, this.maxLoadFactor);
0: 		rehash(newCapacity);
0: 	}
0: 
0: 	return true;
0: }
0: /**
0:  * Rehashes the contents of the receiver into a new table
0:  * with a smaller or larger capacity.
0:  * This method is called automatically when the
0:  * number of keys in the receiver exceeds the high water mark or falls below the low water mark.
0:  */
0: protected void rehash(int newCapacity) {
0: 	int oldCapacity = table.length;
0: 	//if (oldCapacity == newCapacity) return;
0: 	
0: 	int oldTable[] = table;
0: 	int oldValues[] = values;
0: 	byte oldState[] = state;
0: 
0: 	int newTable[] = new int[newCapacity];
0: 	int newValues[] = new int[newCapacity];
0: 	byte newState[] = new byte[newCapacity];
0: 
0: 	this.lowWaterMark  = chooseLowWaterMark(newCapacity,this.minLoadFactor);
0: 	this.highWaterMark = chooseHighWaterMark(newCapacity,this.maxLoadFactor);
0: 
0: 	this.table = newTable;
0: 	this.values = newValues;
0: 	this.state = newState;
0: 	this.freeEntries = newCapacity-this.distinct; // delta
0: 
0: 	int tmp = this.distinct;
0: 	this.distinct = Integer.MIN_VALUE; // switch of watermarks
0: 	for (int i = oldCapacity ; i-- > 0 ;) {
0: 		if (oldState[i]==FULL) {
0: 			put(oldTable[i], oldValues[i]);
0: 			/*
0: 			int element = oldTable[i];
0: 			int index = indexOfInsertion(element);
0: 			newTable[index]=element;
0: 			newValues[index]=oldValues[i];
0: 			newState[index]=FULL;
0: 			*/
0: 		}
0: 	}
0: 	this.distinct = tmp;
0: }
0: }
============================================================================