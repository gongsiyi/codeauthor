1:c36923f: /**
1:c36923f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c36923f:  * contributor license agreements.  See the NOTICE file distributed with
1:c36923f:  * this work for additional information regarding copyright ownership.
1:c36923f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c36923f:  * (the "License"); you may not use this file except in compliance with
1:c36923f:  * the License.  You may obtain a copy of the License at
1:c36923f:  *
1:c36923f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:c36923f:  *
1:c36923f:  * Unless required by applicable law or agreed to in writing, software
1:c36923f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c36923f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c36923f:  * See the License for the specific language governing permissions and
1:c36923f:  * limitations under the License.
1:c36923f:  */
1:c36923f: package org.apache.mahout.text;
1:fcc3260: 
1:31f5865: import org.apache.commons.io.DirectoryWalker;
1:fcc3260: import org.apache.commons.io.comparator.CompositeFileComparator;
1:fcc3260: import org.apache.commons.io.comparator.DirectoryFileComparator;
1:fcc3260: import org.apache.commons.io.comparator.PathFileComparator;
1:c36923f: import org.apache.hadoop.conf.Configuration;
1:d711ac1: import org.apache.hadoop.fs.FileStatus;
1:d711ac1: import org.apache.hadoop.fs.FileSystem;
1:c36923f: import org.apache.hadoop.fs.Path;
1:d711ac1: import org.apache.hadoop.io.Text;
1:d711ac1: import org.apache.hadoop.mapreduce.Job;
1:d711ac1: import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
1:d711ac1: import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
1:86b1196: import org.apache.hadoop.util.ToolRunner;
1:86b1196: import org.apache.mahout.common.AbstractJob;
1:22533ae: import org.apache.mahout.common.HadoopUtil;
1:763c94c: import org.apache.mahout.common.commandline.DefaultOptionCreator;
1:29a7f38: import org.apache.mahout.utils.email.MailOptions;
1:29a7f38: import org.apache.mahout.utils.email.MailProcessor;
1:29a7f38: import org.apache.mahout.utils.io.ChunkedWriter;
1:c36923f: import org.slf4j.Logger;
1:c36923f: import org.slf4j.LoggerFactory;
1:3b9f635: 
1:74078b6: import java.io.File;
1:74078b6: import java.io.IOException;
1:74078b6: import java.nio.charset.Charset;
1:31f5865: import java.util.ArrayDeque;
1:85f9ece: import java.util.ArrayList;
1:fcc3260: import java.util.Arrays;
1:31f5865: import java.util.Collection;
1:fcc3260: import java.util.Comparator;
1:31f5865: import java.util.Deque;
1:85f9ece: import java.util.HashMap;
1:74078b6: import java.util.List;
1:74078b6: import java.util.Map;
1:74078b6: import java.util.regex.Pattern;
1:74078b6: 
1:c36923f: /**
1:86b1196:  * Converts a directory of gzipped mail archives into SequenceFiles of specified
1:86b1196:  * chunkSize. This class is similar to {@link SequenceFilesFromDirectory} except
1:3c22856:  * it uses block-compressed {@link org.apache.hadoop.io.SequenceFile}s and parses out the subject and
1:86b1196:  * body text of each mail message into a separate key/value pair.
1:c36923f:  */
1:86b1196: public final class SequenceFilesFromMailArchives extends AbstractJob {
1:87d4b2e: 
1:d711ac1:   private static final Logger log = LoggerFactory.getLogger(SequenceFilesFromMailArchives.class);
1:29a7f38: 
1:74078b6:   public static final String[] CHUNK_SIZE_OPTION     = {"chunkSize", "chunk"};
1:74078b6:   public static final String[] KEY_PREFIX_OPTION     = {"keyPrefix", "prefix"};
1:74078b6:   public static final String[] CHARSET_OPTION        = {"charset", "c"};
1:74078b6:   public static final String[] SUBJECT_OPTION        = {"subject", "s"};
1:74078b6:   public static final String[] TO_OPTION             = {"to", "to"};
1:74078b6:   public static final String[] FROM_OPTION           = {"from", "from"};
1:74078b6:   public static final String[] REFERENCES_OPTION     = {"references", "refs"};
1:74078b6:   public static final String[] BODY_OPTION           = {"body", "b"};
1:74078b6:   public static final String[] STRIP_QUOTED_OPTION   = {"stripQuoted", "q"};
1:74078b6:   public static final String[] QUOTED_REGEX_OPTION   = {"quotedRegex", "regex"};
1:74078b6:   public static final String[] SEPARATOR_OPTION      = {"separator", "sep"};
1:74078b6:   public static final String[] BODY_SEPARATOR_OPTION = {"bodySeparator", "bodySep"};
1:74078b6:   public static final String BASE_INPUT_PATH         = "baseinputpath";
1:74078b6: 
1:74078b6:   private static final int MAX_JOB_SPLIT_LOCATIONS = 1000000;
1:fcc3260: 
1:29a7f38:   public void createSequenceFiles(MailOptions options) throws IOException {
1:85f9ece:     try (ChunkedWriter writer =
1:85f9ece:              new ChunkedWriter(getConf(), options.getChunkSize(), new Path(options.getOutputDir()))){
1:85f9ece:       MailProcessor processor = new MailProcessor(options, options.getPrefix(), writer);
1:763c94c:       if (options.getInput().isDirectory()) {
1:31f5865:         PrefixAdditionDirectoryWalker walker = new PrefixAdditionDirectoryWalker(processor, writer);
1:31f5865:         walker.walk(options.getInput());
1:31f5865:         log.info("Parsed {} messages from {}", walker.getMessageCount(), options.getInput().getAbsolutePath());
1:29a7f38:       } else {
1:29a7f38:         long start = System.currentTimeMillis();
1:763c94c:         long cnt = processor.parseMboxLineByLine(options.getInput());
1:29a7f38:         long finish = System.currentTimeMillis();
1:8396a27:         log.info("Parsed {} messages from {} in time: {}", cnt, options.getInput().getAbsolutePath(), finish - start);
1:fcc3260:       }
1:69f324d:     }
1:29a7f38:   }
1:74078b6: 
1:31f5865:   private static class PrefixAdditionDirectoryWalker extends DirectoryWalker<Object> {
1:d711ac1: 
1:31f5865:     @SuppressWarnings("unchecked")
1:31f5865:     private static final Comparator<File> FILE_COMPARATOR = new CompositeFileComparator(
1:31f5865:         DirectoryFileComparator.DIRECTORY_REVERSE, PathFileComparator.PATH_COMPARATOR);
1:31f5865: 
1:87c15be:     private final Deque<MailProcessor> processors = new ArrayDeque<>();
1:31f5865:     private final ChunkedWriter writer;
1:87c15be:     private final Deque<Long> messageCounts = new ArrayDeque<>();
1:31f5865: 
1:31f5865:     public PrefixAdditionDirectoryWalker(MailProcessor processor, ChunkedWriter writer) {
1:31f5865:       processors.addFirst(processor);
1:c36923f:       this.writer = writer;
1:31f5865:       messageCounts.addFirst(0L);
1:31f5865:     }
1:31f5865: 
1:31f5865:     public void walk(File startDirectory) throws IOException {
1:31f5865:       super.walk(startDirectory, null);
22:c36923f:     }
1:29a7f38: 
1:29a7f38:     public long getMessageCount() {
1:31f5865:       return messageCounts.getFirst();
1:c36923f:     }
5:29a7f38: 
1:c36923f:     @Override
1:31f5865:     protected void handleDirectoryStart(File current, int depth, Collection<Object> results) throws IOException {
1:31f5865:       if (depth > 0) {
1:763c94c:         log.info("At {}", current.getAbsolutePath());
1:31f5865:         MailProcessor processor = processors.getFirst();
1:31f5865:         MailProcessor subDirProcessor = new MailProcessor(processor.getOptions(), processor.getPrefix()
1:31f5865:             + File.separator + current.getName(), writer);
1:31f5865:         processors.push(subDirProcessor);
1:31f5865:         messageCounts.push(0L);
1:31f5865:       }
1:c36923f:     }
1:31f5865: 
1:31f5865:     @Override
1:31f5865:     protected File[] filterDirectoryContents(File directory, int depth, File[] files) throws IOException {
1:31f5865:       Arrays.sort(files, FILE_COMPARATOR);
1:31f5865:       return files;
1:31f5865:     }
1:31f5865: 
1:31f5865:     @Override
1:31f5865:     protected void handleFile(File current, int depth, Collection<Object> results) throws IOException {
1:31f5865:       MailProcessor processor = processors.getFirst();
1:31f5865:       long currentDirMessageCount = messageCounts.pop();
1:31f5865:       try {
1:31f5865:         currentDirMessageCount += processor.parseMboxLineByLine(current);
1:31f5865:       } catch (IOException e) {
1:31f5865:         throw new IllegalStateException("Error processing " + current, e);
1:31f5865:       }
1:31f5865:       messageCounts.push(currentDirMessageCount);
1:31f5865:     }
1:31f5865: 
1:31f5865:     @Override
1:31f5865:     protected void handleDirectoryEnd(File current, int depth, Collection<Object> results) throws IOException {
1:31f5865:       if (depth > 0) {
1:31f5865:         final long currentDirMessageCount = messageCounts.pop();
1:31f5865:         log.info("Parsed {} messages from directory {}", currentDirMessageCount, current.getAbsolutePath());
1:31f5865: 
1:31f5865:         processors.pop();
1:31f5865: 
1:31f5865:         // aggregate message counts
1:31f5865:         long parentDirMessageCount = messageCounts.pop();
1:31f5865:         parentDirMessageCount += currentDirMessageCount;
1:31f5865:         messageCounts.push(parentDirMessageCount);
1:31f5865:       }
1:fcc3260:     }
1:c36923f:   }
1:29a7f38: 
1:c36923f:   public static void main(String[] args) throws Exception {
1:86b1196:     ToolRunner.run(new Configuration(), new SequenceFilesFromMailArchives(), args);
1:c36923f:   }
1:29a7f38: 
1:c36923f:   @Override
1:86b1196:   public int run(String[] args) throws Exception {
1:86b1196:     addInputOption();
1:86b1196:     addOutputOption();
1:d711ac1:     addOption(DefaultOptionCreator.methodOption().create());
1:29a7f38: 
1:74078b6:     addOption(CHUNK_SIZE_OPTION[0], CHUNK_SIZE_OPTION[1], "The chunkSize in MegaBytes. Defaults to 64", "64");
1:74078b6:     addOption(KEY_PREFIX_OPTION[0], KEY_PREFIX_OPTION[1], "The prefix to be prepended to the key", "");
1:74078b6:     addOption(CHARSET_OPTION[0], CHARSET_OPTION[1],
1:74078b6:       "The name of the character encoding of the input files. Default to UTF-8", "UTF-8");
1:74078b6:     addFlag(SUBJECT_OPTION[0], SUBJECT_OPTION[1], "Include the Mail subject as part of the text.  Default is false");
1:74078b6:     addFlag(TO_OPTION[0], TO_OPTION[1], "Include the to field in the text.  Default is false");
1:74078b6:     addFlag(FROM_OPTION[0], FROM_OPTION[1], "Include the from field in the text.  Default is false");
1:74078b6:     addFlag(REFERENCES_OPTION[0], REFERENCES_OPTION[1],
1:74078b6:       "Include the references field in the text.  Default is false");
1:74078b6:     addFlag(BODY_OPTION[0], BODY_OPTION[1], "Include the body in the output.  Default is false");
1:74078b6:     addFlag(STRIP_QUOTED_OPTION[0], STRIP_QUOTED_OPTION[1],
1:74078b6:       "Strip (remove) quoted email text in the body.  Default is false");
1:74078b6:     addOption(QUOTED_REGEX_OPTION[0], QUOTED_REGEX_OPTION[1],
1:d711ac1:         "Specify the regex that identifies quoted text.  "
1:74078b6:           + "Default is to look for > or | at the beginning of the line.");
1:74078b6:     addOption(SEPARATOR_OPTION[0], SEPARATOR_OPTION[1],
1:74078b6:         "The separator to use between metadata items (to, from, etc.).  Default is \\n", "\n");
1:74078b6:     addOption(BODY_SEPARATOR_OPTION[0], BODY_SEPARATOR_OPTION[1],
1:d711ac1:         "The separator to use between lines in the body.  Default is \\n.  "
1:74078b6:           + "Useful to change if you wish to have the message be on one line", "\n");
1:74078b6: 
1:86b1196:     addOption(DefaultOptionCreator.helpOption());
1:86b1196:     Map<String, List<String>> parsedArgs = parseArguments(args);
1:86b1196:     if (parsedArgs == null) {
1:86b1196:       return -1;
1:c36923f:     }
1:86b1196:     File input = getInputFile();
1:86b1196:     String outputDir = getOutputPath().toString();
1:29a7f38: 
1:c36923f:     int chunkSize = 64;
1:74078b6:     if (hasOption(CHUNK_SIZE_OPTION[0])) {
1:74078b6:       chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));
1:c36923f:     }
1:29a7f38: 
1:c36923f:     String prefix = "";
1:74078b6:     if (hasOption(KEY_PREFIX_OPTION[0])) {
1:74078b6:       prefix = getOption(KEY_PREFIX_OPTION[0]);
1:c36923f:     }
1:29a7f38: 
1:74078b6:     Charset charset = Charset.forName(getOption(CHARSET_OPTION[0]));
1:29a7f38:     MailOptions options = new MailOptions();
1:763c94c:     options.setInput(input);
1:763c94c:     options.setOutputDir(outputDir);
1:763c94c:     options.setPrefix(prefix);
1:763c94c:     options.setChunkSize(chunkSize);
1:763c94c:     options.setCharset(charset);
1:29a7f38: 
1:85f9ece:     List<Pattern> patterns = new ArrayList<>(5);
1:86b1196:     // patternOrder is used downstream so that we can know what order the text
1:d711ac1:     // is in instead of encoding it in the string, which
1:763c94c:     // would require more processing later to remove it pre feature selection.
1:85f9ece:     Map<String, Integer> patternOrder = new HashMap<>();
1:3b9f635:     int order = 0;
1:74078b6:     if (hasOption(FROM_OPTION[0])) {
1:29a7f38:       patterns.add(MailProcessor.FROM_PREFIX);
1:3b9f635:       patternOrder.put(MailOptions.FROM, order++);
1:29a7f38:     }
1:74078b6:     if (hasOption(TO_OPTION[0])) {
1:29a7f38:       patterns.add(MailProcessor.TO_PREFIX);
1:3b9f635:       patternOrder.put(MailOptions.TO, order++);
1:29a7f38:     }
1:74078b6:     if (hasOption(REFERENCES_OPTION[0])) {
1:29a7f38:       patterns.add(MailProcessor.REFS_PREFIX);
1:3b9f635:       patternOrder.put(MailOptions.REFS, order++);
1:29a7f38:     }
1:74078b6:     if (hasOption(SUBJECT_OPTION[0])) {
1:29a7f38:       patterns.add(MailProcessor.SUBJECT_PREFIX);
1:74078b6:       patternOrder.put(MailOptions.SUBJECT, order += 1);
1:29a7f38:     }
1:74078b6:     options.setStripQuotedText(hasOption(STRIP_QUOTED_OPTION[0]));
1:69f324d: 
1:763c94c:     options.setPatternsToMatch(patterns.toArray(new Pattern[patterns.size()]));
1:763c94c:     options.setPatternOrder(patternOrder);
1:74078b6:     options.setIncludeBody(hasOption(BODY_OPTION[0]));
1:74078b6: 
1:74078b6:     if (hasOption(SEPARATOR_OPTION[0])) {
1:74078b6:       options.setSeparator(getOption(SEPARATOR_OPTION[0]));
1:74078b6:     } else {
1:74078b6:       options.setSeparator("\n");
1:29a7f38:     }
1:74078b6: 
1:74078b6:     if (hasOption(BODY_SEPARATOR_OPTION[0])) {
1:74078b6:       options.setBodySeparator(getOption(BODY_SEPARATOR_OPTION[0]));
1:29a7f38:     }
1:74078b6: 
1:74078b6:     if (hasOption(QUOTED_REGEX_OPTION[0])) {
1:74078b6:       options.setQuotedTextPattern(Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])));
1:29a7f38:     }
1:29a7f38: 
1:d711ac1:     if (getOption(DefaultOptionCreator.METHOD_OPTION,
1:d711ac1:       DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {
1:d711ac1:       runSequential(options);
1:d711ac1:     } else {
1:d711ac1:       runMapReduce(getInputPath(), getOutputPath());
1:d711ac1:     }
1:d711ac1: 
1:d711ac1:     return 0;
1:d711ac1:   }
1:d711ac1: 
1:d711ac1:   private int runSequential(MailOptions options)
1:d711ac1:     throws IOException, InterruptedException, NoSuchMethodException {
1:d711ac1: 
1:29a7f38:     long start = System.currentTimeMillis();
1:86b1196:     createSequenceFiles(options);
1:29a7f38:     long finish = System.currentTimeMillis();
1:763c94c:     log.info("Conversion took {}ms", finish - start);
1:d711ac1: 
1:d711ac1:     return 0;
1:d711ac1:   }
1:d711ac1: 
1:d711ac1:   private int runMapReduce(Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException {
1:d711ac1: 
1:d711ac1:     Job job = prepareJob(input, output, MultipleTextFileInputFormat.class, SequenceFilesFromMailArchivesMapper.class,
1:d711ac1:       Text.class, Text.class, SequenceFileOutputFormat.class, "SequentialFilesFromMailArchives");
1:d711ac1: 
1:d711ac1:     Configuration jobConfig = job.getConfiguration();
1:d711ac1: 
1:74078b6:     if (hasOption(KEY_PREFIX_OPTION[0])) {
1:74078b6:       jobConfig.set(KEY_PREFIX_OPTION[1], getOption(KEY_PREFIX_OPTION[0]));
1:d711ac1:     }
1:d711ac1: 
1:d711ac1:     int chunkSize = 0;
1:74078b6:     if (hasOption(CHUNK_SIZE_OPTION[0])) {
1:74078b6:       chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));
1:74078b6:       jobConfig.set(CHUNK_SIZE_OPTION[0], String.valueOf(chunkSize));
1:d711ac1:     }
1:d711ac1: 
1:d711ac1:     Charset charset;
1:74078b6:     if (hasOption(CHARSET_OPTION[0])) {
1:74078b6:       charset = Charset.forName(getOption(CHARSET_OPTION[0]));
1:74078b6:       jobConfig.set(CHARSET_OPTION[0], charset.displayName());
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(FROM_OPTION[0])) {
1:74078b6:       jobConfig.set(FROM_OPTION[1], "true");
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(TO_OPTION[0])) {
1:74078b6:       jobConfig.set(TO_OPTION[1], "true");
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(REFERENCES_OPTION[0])) {
1:74078b6:       jobConfig.set(REFERENCES_OPTION[1], "true");
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(SUBJECT_OPTION[0])) {
1:74078b6:       jobConfig.set(SUBJECT_OPTION[1], "true");
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(QUOTED_REGEX_OPTION[0])) {
1:74078b6:       jobConfig.set(QUOTED_REGEX_OPTION[1], Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])).toString());
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(SEPARATOR_OPTION[0])) {
1:74078b6:       jobConfig.set(SEPARATOR_OPTION[1], getOption(SEPARATOR_OPTION[0]));
1:d711ac1:     } else {
1:74078b6:       jobConfig.set(SEPARATOR_OPTION[1], "\n");
1:d711ac1:     }
1:d711ac1: 
1:74078b6:     if (hasOption(BODY_OPTION[0])) {
1:74078b6:       jobConfig.set(BODY_OPTION[1], "true");
1:d711ac1:     } else {
1:74078b6:       jobConfig.set(BODY_OPTION[1], "false");
1:74078b6:     }
1:74078b6: 
1:74078b6:     if (hasOption(BODY_SEPARATOR_OPTION[0])) {
1:74078b6:       jobConfig.set(BODY_SEPARATOR_OPTION[1], getOption(BODY_SEPARATOR_OPTION[0]));
1:74078b6:     } else {
1:74078b6:       jobConfig.set(BODY_SEPARATOR_OPTION[1], "\n");
1:d711ac1:     }
1:d711ac1: 
1:d711ac1:     FileSystem fs = FileSystem.get(jobConfig);
1:53fe357:     FileStatus fsFileStatus = fs.getFileStatus(inputPath);
1:d711ac1: 
1:74078b6:     jobConfig.set(BASE_INPUT_PATH, inputPath.toString());
1:22533ae:     String inputDirList = HadoopUtil.buildDirList(fs, fsFileStatus);
1:d711ac1:     FileInputFormat.setInputPaths(job, inputDirList);
1:d711ac1: 
1:d711ac1:     long chunkSizeInBytes = chunkSize * 1024 * 1024;
1:d711ac1:     // need to set this to a multiple of the block size, or no split happens
1:d711ac1:     FileInputFormat.setMaxInputSplitSize(job, chunkSizeInBytes);
1:d711ac1: 
1:d711ac1:     // set the max split locations, otherwise we get nasty debug stuff
1:74078b6:     jobConfig.set("mapreduce.job.max.split.locations", String.valueOf(MAX_JOB_SPLIT_LOCATIONS));
1:d711ac1: 
1:d711ac1:     boolean succeeded = job.waitForCompletion(true);
1:d711ac1:     if (!succeeded) {
1:d711ac1:       return -1;
1:d711ac1:     }
1:86b1196:     return 0;
1:c36923f:   }
1:c36923f: }
============================================================================
author:Suneel Marthi
-------------------------------------------------------------------------------
commit:85f9ece
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     try (ChunkedWriter writer =
1:              new ChunkedWriter(getConf(), options.getChunkSize(), new Path(options.getOutputDir()))){
1:       MailProcessor processor = new MailProcessor(options, options.getPrefix(), writer);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     List<Pattern> patterns = new ArrayList<>(5);
1:     Map<String, Integer> patternOrder = new HashMap<>();
commit:87c15be
/////////////////////////////////////////////////////////////////////////
1:     private final Deque<MailProcessor> processors = new ArrayDeque<>();
1:     private final Deque<Long> messageCounts = new ArrayDeque<>();
author:sslavic
-------------------------------------------------------------------------------
commit:09127f5
/////////////////////////////////////////////////////////////////////////
0:     private final Deque<Long> messageCounts = new ArrayDeque<Long>();
commit:31f5865
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.io.DirectoryWalker;
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayDeque;
1: import java.util.Collection;
1: import java.util.Deque;
/////////////////////////////////////////////////////////////////////////
1:         PrefixAdditionDirectoryWalker walker = new PrefixAdditionDirectoryWalker(processor, writer);
1:         walker.walk(options.getInput());
1:         log.info("Parsed {} messages from {}", walker.getMessageCount(), options.getInput().getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
1:   private static class PrefixAdditionDirectoryWalker extends DirectoryWalker<Object> {
1:     @SuppressWarnings("unchecked")
1:     private static final Comparator<File> FILE_COMPARATOR = new CompositeFileComparator(
1:         DirectoryFileComparator.DIRECTORY_REVERSE, PathFileComparator.PATH_COMPARATOR);
1: 
0:     private final Deque<MailProcessor> processors = new ArrayDeque<MailProcessor>();
1:     private final ChunkedWriter writer;
0:     private Deque<Long> messageCounts = new ArrayDeque<Long>();
1: 
1:     public PrefixAdditionDirectoryWalker(MailProcessor processor, ChunkedWriter writer) {
1:       processors.addFirst(processor);
1:       messageCounts.addFirst(0L);
1:     }
1: 
1:     public void walk(File startDirectory) throws IOException {
1:       super.walk(startDirectory, null);
1:       return messageCounts.getFirst();
1:     protected void handleDirectoryStart(File current, int depth, Collection<Object> results) throws IOException {
1:       if (depth > 0) {
1:         MailProcessor processor = processors.getFirst();
1:         MailProcessor subDirProcessor = new MailProcessor(processor.getOptions(), processor.getPrefix()
1:             + File.separator + current.getName(), writer);
1:         processors.push(subDirProcessor);
1:         messageCounts.push(0L);
1:     }
1: 
1:     @Override
1:     protected File[] filterDirectoryContents(File directory, int depth, File[] files) throws IOException {
1:       Arrays.sort(files, FILE_COMPARATOR);
1:       return files;
1:     }
1: 
1:     @Override
1:     protected void handleFile(File current, int depth, Collection<Object> results) throws IOException {
1:       MailProcessor processor = processors.getFirst();
1:       long currentDirMessageCount = messageCounts.pop();
1:       try {
1:         currentDirMessageCount += processor.parseMboxLineByLine(current);
1:       } catch (IOException e) {
1:         throw new IllegalStateException("Error processing " + current, e);
1:       }
1:       messageCounts.push(currentDirMessageCount);
1:     }
1: 
1:     @Override
1:     protected void handleDirectoryEnd(File current, int depth, Collection<Object> results) throws IOException {
1:       if (depth > 0) {
1:         final long currentDirMessageCount = messageCounts.pop();
1:         log.info("Parsed {} messages from directory {}", currentDirMessageCount, current.getAbsolutePath());
1: 
1:         processors.pop();
1: 
1:         // aggregate message counts
1:         long parentDirMessageCount = messageCounts.pop();
1:         parentDirMessageCount += currentDirMessageCount;
1:         messageCounts.push(parentDirMessageCount);
1:       }
commit:fcc3260
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.commons.io.comparator.CompositeFileComparator;
1: import org.apache.commons.io.comparator.DirectoryFileComparator;
1: import org.apache.commons.io.comparator.PathFileComparator;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
0:   @SuppressWarnings("unchecked")
0:   private static final Comparator<File> FILE_COMPARATOR = new CompositeFileComparator(
0:       DirectoryFileComparator.DIRECTORY_REVERSE, PathFileComparator.PATH_COMPARATOR);
1: 
0:         File[] inputFilesAndDirs = options.getInput().listFiles();
0:         Arrays.sort(inputFilesAndDirs, FILE_COMPARATOR);
0:         for (File aFile : inputFilesAndDirs) {
0:           filter.accept(aFile);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         File[] nestedInputFilesAndDirs = current.listFiles();
0:         Arrays.sort(nestedInputFilesAndDirs, FILE_COMPARATOR);
0:         for (File aFile : nestedInputFilesAndDirs) {
0:           nested.accept(aFile);
1:         }
author:smarthi
-------------------------------------------------------------------------------
commit:74078b6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
0: import java.io.FileFilter;
1: import java.io.IOException;
1: import java.nio.charset.Charset;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.regex.Pattern;
1: 
/////////////////////////////////////////////////////////////////////////
1:   public static final String[] CHUNK_SIZE_OPTION     = {"chunkSize", "chunk"};
1:   public static final String[] KEY_PREFIX_OPTION     = {"keyPrefix", "prefix"};
1:   public static final String[] CHARSET_OPTION        = {"charset", "c"};
1:   public static final String[] SUBJECT_OPTION        = {"subject", "s"};
1:   public static final String[] TO_OPTION             = {"to", "to"};
1:   public static final String[] FROM_OPTION           = {"from", "from"};
1:   public static final String[] REFERENCES_OPTION     = {"references", "refs"};
1:   public static final String[] BODY_OPTION           = {"body", "b"};
1:   public static final String[] STRIP_QUOTED_OPTION   = {"stripQuoted", "q"};
1:   public static final String[] QUOTED_REGEX_OPTION   = {"quotedRegex", "regex"};
1:   public static final String[] SEPARATOR_OPTION      = {"separator", "sep"};
1:   public static final String[] BODY_SEPARATOR_OPTION = {"bodySeparator", "bodySep"};
1:   public static final String BASE_INPUT_PATH         = "baseinputpath";
1: 
1:   private static final int MAX_JOB_SPLIT_LOCATIONS = 1000000;
1: 
/////////////////////////////////////////////////////////////////////////
1:     addOption(CHUNK_SIZE_OPTION[0], CHUNK_SIZE_OPTION[1], "The chunkSize in MegaBytes. Defaults to 64", "64");
1:     addOption(KEY_PREFIX_OPTION[0], KEY_PREFIX_OPTION[1], "The prefix to be prepended to the key", "");
1:     addOption(CHARSET_OPTION[0], CHARSET_OPTION[1],
1:       "The name of the character encoding of the input files. Default to UTF-8", "UTF-8");
1:     addFlag(SUBJECT_OPTION[0], SUBJECT_OPTION[1], "Include the Mail subject as part of the text.  Default is false");
1:     addFlag(TO_OPTION[0], TO_OPTION[1], "Include the to field in the text.  Default is false");
1:     addFlag(FROM_OPTION[0], FROM_OPTION[1], "Include the from field in the text.  Default is false");
1:     addFlag(REFERENCES_OPTION[0], REFERENCES_OPTION[1],
1:       "Include the references field in the text.  Default is false");
1:     addFlag(BODY_OPTION[0], BODY_OPTION[1], "Include the body in the output.  Default is false");
1:     addFlag(STRIP_QUOTED_OPTION[0], STRIP_QUOTED_OPTION[1],
1:       "Strip (remove) quoted email text in the body.  Default is false");
1:     addOption(QUOTED_REGEX_OPTION[0], QUOTED_REGEX_OPTION[1],
1:           + "Default is to look for > or | at the beginning of the line.");
1:     addOption(SEPARATOR_OPTION[0], SEPARATOR_OPTION[1],
1:         "The separator to use between metadata items (to, from, etc.).  Default is \\n", "\n");
1:     addOption(BODY_SEPARATOR_OPTION[0], BODY_SEPARATOR_OPTION[1],
1:           + "Useful to change if you wish to have the message be on one line", "\n");
1: 
/////////////////////////////////////////////////////////////////////////
1:     if (hasOption(CHUNK_SIZE_OPTION[0])) {
1:       chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));
1:     if (hasOption(KEY_PREFIX_OPTION[0])) {
1:       prefix = getOption(KEY_PREFIX_OPTION[0]);
1:     Charset charset = Charset.forName(getOption(CHARSET_OPTION[0]));
/////////////////////////////////////////////////////////////////////////
1:     if (hasOption(FROM_OPTION[0])) {
1:     if (hasOption(TO_OPTION[0])) {
1:     if (hasOption(REFERENCES_OPTION[0])) {
1:     if (hasOption(SUBJECT_OPTION[0])) {
1:       patternOrder.put(MailOptions.SUBJECT, order += 1);
1:     options.setStripQuotedText(hasOption(STRIP_QUOTED_OPTION[0]));
1:     options.setIncludeBody(hasOption(BODY_OPTION[0]));
1: 
1:     if (hasOption(SEPARATOR_OPTION[0])) {
1:       options.setSeparator(getOption(SEPARATOR_OPTION[0]));
1:     } else {
1:       options.setSeparator("\n");
1: 
1:     if (hasOption(BODY_SEPARATOR_OPTION[0])) {
1:       options.setBodySeparator(getOption(BODY_SEPARATOR_OPTION[0]));
1: 
1:     if (hasOption(QUOTED_REGEX_OPTION[0])) {
1:       options.setQuotedTextPattern(Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])));
/////////////////////////////////////////////////////////////////////////
1:     if (hasOption(KEY_PREFIX_OPTION[0])) {
1:       jobConfig.set(KEY_PREFIX_OPTION[1], getOption(KEY_PREFIX_OPTION[0]));
1:     if (hasOption(CHUNK_SIZE_OPTION[0])) {
1:       chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));
1:       jobConfig.set(CHUNK_SIZE_OPTION[0], String.valueOf(chunkSize));
1:     if (hasOption(CHARSET_OPTION[0])) {
1:       charset = Charset.forName(getOption(CHARSET_OPTION[0]));
1:       jobConfig.set(CHARSET_OPTION[0], charset.displayName());
1:     if (hasOption(FROM_OPTION[0])) {
1:       jobConfig.set(FROM_OPTION[1], "true");
1:     if (hasOption(TO_OPTION[0])) {
1:       jobConfig.set(TO_OPTION[1], "true");
1:     if (hasOption(REFERENCES_OPTION[0])) {
1:       jobConfig.set(REFERENCES_OPTION[1], "true");
1:     if (hasOption(SUBJECT_OPTION[0])) {
1:       jobConfig.set(SUBJECT_OPTION[1], "true");
1:     if (hasOption(QUOTED_REGEX_OPTION[0])) {
1:       jobConfig.set(QUOTED_REGEX_OPTION[1], Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])).toString());
1:     if (hasOption(SEPARATOR_OPTION[0])) {
1:       jobConfig.set(SEPARATOR_OPTION[1], getOption(SEPARATOR_OPTION[0]));
1:       jobConfig.set(SEPARATOR_OPTION[1], "\n");
1:     if (hasOption(BODY_OPTION[0])) {
1:       jobConfig.set(BODY_OPTION[1], "true");
1:       jobConfig.set(BODY_OPTION[1], "false");
1:     }
1: 
1:     if (hasOption(BODY_SEPARATOR_OPTION[0])) {
1:       jobConfig.set(BODY_SEPARATOR_OPTION[1], getOption(BODY_SEPARATOR_OPTION[0]));
1:     } else {
1:       jobConfig.set(BODY_SEPARATOR_OPTION[1], "\n");
1:     jobConfig.set(BASE_INPUT_PATH, inputPath.toString());
/////////////////////////////////////////////////////////////////////////
1:     jobConfig.set("mapreduce.job.max.split.locations", String.valueOf(MAX_JOB_SPLIT_LOCATIONS));
commit:53fe357
/////////////////////////////////////////////////////////////////////////
1:     FileStatus fsFileStatus = fs.getFileStatus(inputPath);
commit:22533ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.HadoopUtil;
/////////////////////////////////////////////////////////////////////////
0:     FileStatus fsFileStatus = HadoopUtil.listStatus(fs, inputPath)[0];
1:     String inputDirList = HadoopUtil.buildDirList(fs, fsFileStatus);
commit:d711ac1
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Maps;
1: import org.apache.hadoop.fs.FileStatus;
1: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.io.Text;
1: import org.apache.hadoop.mapreduce.Job;
1: import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
1: import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
/////////////////////////////////////////////////////////////////////////
1:   private static final Logger log = LoggerFactory.getLogger(SequenceFilesFromMailArchives.class);
0:     ChunkedWriter writer = new ChunkedWriter(getConf(), options.getChunkSize(), new Path(options.getOutputDir()));
0:     MailProcessor processor = new MailProcessor(options, options.getPrefix(), writer);
0:         PrefixAdditionFilter filter = new PrefixAdditionFilter(processor, writer);
0:         log.info("Parsed {} messages from {}", filter.getMessageCount(), options.getInput().getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
0:           new MailProcessor(processor.getOptions(), processor.getPrefix()
0:             + File.separator + current.getName(), writer), writer);
0:         log.info("Parsed {} messages from directory {}", dirCount, current.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
0:     DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();
0:     ArgumentBuilder argumentBuilder = new ArgumentBuilder();
1:     addOption(DefaultOptionCreator.methodOption().create());
0:     addOption(optionBuilder.withLongName("chunkSize").withArgument(
0:       argumentBuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create())
0:       .withDescription("The chunkSize in MegaBytes. Defaults to 64")
0:       .withShortName("chunk").create());
0:     addOption(optionBuilder.withLongName("keyPrefix").withArgument(
0:       argumentBuilder.withName("keyPrefix").withMinimum(1).withMaximum(1).create())
0:       .withDescription("The prefix to be prepended to the key")
0:       .withShortName("prefix").create());
0:     addOption(optionBuilder.withLongName("charset")
0:       .withRequired(true).withArgument(argumentBuilder.withName("charset")
0:         .withMinimum(1).withMaximum(1).create()).withDescription(
0:         "The name of the character encoding of the input files")
0:       .withShortName("c").create());
0:     addOption(optionBuilder.withLongName("subject")
0:       .withRequired(false).withDescription(
0:         "Include the Mail subject as part of the text.  Default is false")
0:       .withShortName("s").create());
0:     addOption(optionBuilder.withLongName("to").withRequired(false)
0:       .withDescription("Include the to field in the text.  Default is false")
0:       .withShortName("to").create());
0:     addOption(optionBuilder.withLongName("from").withRequired(false).withDescription(
0:       "Include the from field in the text.  Default is false")
0:       .withShortName("from").create());
0:     addOption(optionBuilder.withLongName("references")
0:       .withRequired(false).withDescription(
0:         "Include the references field in the text.  Default is false")
0:       .withShortName("refs").create());
0:     addOption(optionBuilder.withLongName("body").withRequired(false)
0:       .withDescription("Include the body in the output.  Default is false")
0:       .withShortName("b").create());
0:     addOption(optionBuilder.withLongName("stripQuoted")
0:       .withRequired(false).withDescription(
0:         "Strip (remove) quoted email text in the body.  Default is false")
0:       .withShortName("q").create());
0:     addOption(
0:       optionBuilder.withLongName("quotedRegex")
0:         .withRequired(false).withArgument(argumentBuilder.withName("regex")
0:         .withMinimum(1).withMaximum(1).create()).withDescription(
1:         "Specify the regex that identifies quoted text.  "
0:           + "Default is to look for > or | at the beginning of the line.")
0:       optionBuilder.withLongName("separator")
0:         .withRequired(false).withArgument(argumentBuilder.withName("separator")
0:         .withMinimum(1).withMaximum(1).create()).withDescription(
0:         "The separator to use between metadata items (to, from, etc.).  Default is \\n")
0:         .withShortName("sep").create());
0:       optionBuilder.withLongName("bodySeparator")
0:         .withRequired(false).withArgument(argumentBuilder.withName("bodySeparator")
0:         .withMinimum(1).withMaximum(1).create()).withDescription(
1:         "The separator to use between lines in the body.  Default is \\n.  "
0:           + "Useful to change if you wish to have the message be on one line")
0:         .withShortName("bodySep").create());
/////////////////////////////////////////////////////////////////////////
1:     // is in instead of encoding it in the string, which
0:     Map<String, Integer> patternOrder = Maps.newHashMap();
/////////////////////////////////////////////////////////////////////////
1: 
1:     if (getOption(DefaultOptionCreator.METHOD_OPTION,
1:       DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {
1:       runSequential(options);
1:     } else {
1:       runMapReduce(getInputPath(), getOutputPath());
1:     }
1: 
1:     return 0;
1:   }
1: 
1:   private int runSequential(MailOptions options)
1:     throws IOException, InterruptedException, NoSuchMethodException {
1: 
1: 
1:     return 0;
1:   }
1: 
1:   private int runMapReduce(Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException {
1: 
1:     Job job = prepareJob(input, output, MultipleTextFileInputFormat.class, SequenceFilesFromMailArchivesMapper.class,
1:       Text.class, Text.class, SequenceFileOutputFormat.class, "SequentialFilesFromMailArchives");
1: 
1:     Configuration jobConfig = job.getConfiguration();
1: 
0:     if (hasOption("keyPrefix")) {
0:       jobConfig.set("prefix", getOption("keyPrefix"));
1:     }
1: 
1:     int chunkSize = 0;
0:     if (hasOption("chunkSize")) {
0:       chunkSize = Integer.parseInt(getOption("chunkSize"));
0:       jobConfig.set("chunkSize", String.valueOf(chunkSize));
1:     }
1: 
1:     Charset charset;
0:     if (hasOption("charset")) {
0:       charset = Charset.forName(getOption("charset"));
0:       jobConfig.set("charset", charset.displayName());
1:     }
1: 
0:     if (hasOption("from")) {
0:       jobConfig.set("fromOpt", "true");
1:     }
1: 
0:     if (hasOption("to")) {
0:       jobConfig.set("toOpt", "true");
1:     }
1: 
0:     if (hasOption("references")) {
0:       jobConfig.set("refsOpt", "true");
1:     }
1: 
0:     if (hasOption("subject")) {
0:       jobConfig.set("subjectOpt", "true");
1:     }
1: 
0:     if (hasOption("quotedRegex")) {
0:       jobConfig.set("quotedRegex", Pattern.compile(getOption("quotedRegex")).toString());
1:     }
1: 
0:     if (hasOption("separatorOpt")) {
0:       jobConfig.set("separatorOpt", getOption("separatorOpt"));
1:     } else {
0:       jobConfig.set("separatorOpt", "\n");
1:     }
1: 
0:     if (hasOption("body")) {
0:       jobConfig.set("bodyOpt", "true");
1:     } else {
0:       jobConfig.set("bodyOpt", "false");
1:     }
1: 
1:     FileSystem fs = FileSystem.get(jobConfig);
0:     FileStatus fsFileStatus = fs.getFileStatus(inputPath);
1: 
0:     jobConfig.set("baseinputpath", inputPath.toString());
0:     String inputDirList = buildDirList(fs, fsFileStatus);
1:     FileInputFormat.setInputPaths(job, inputDirList);
1: 
1:     long chunkSizeInBytes = chunkSize * 1024 * 1024;
1:     // need to set this to a multiple of the block size, or no split happens
1:     FileInputFormat.setMaxInputSplitSize(job, chunkSizeInBytes);
1: 
1:     // set the max split locations, otherwise we get nasty debug stuff
0:     jobConfig.set("mapreduce.job.max.split.locations", "1000000");
1: 
1:     boolean succeeded = job.waitForCompletion(true);
1:     if (!succeeded) {
1:       return -1;
1:     }
author:dfilimon
-------------------------------------------------------------------------------
commit:87d4b2e
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.FileFilter;
0: import java.io.IOException;
0: import java.nio.charset.Charset;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.regex.Pattern;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(writer, false);
author:Grant Ingersoll
-------------------------------------------------------------------------------
commit:31cb292
/////////////////////////////////////////////////////////////////////////
0:       Closeables.close(writer, true);
commit:69f324d
/////////////////////////////////////////////////////////////////////////
0:     Option quotedOpt = obuilder.withLongName("stripQuoted").withRequired(false).
0:             withDescription("Strip (remove) quoted email text in the body.  Default is false").withShortName("q").create();
0:     Option quotedRegexOpt = obuilder.withLongName("quotedRegex").withRequired(false).withArgument(abuilder.withName("regex").withMinimum(1).withMaximum(1).create())
0:             .withDescription("Specify the regex that identifies quoted text.  Default is to look for > or | at the beginning of the line.").withShortName("q").create();
/////////////////////////////////////////////////////////////////////////
0:             .withOption(fromOpt).withOption(bodyOpt).withOption(quotedOpt).withOption(refsOpt).withOption(bodySeparatorOpt)
0:             .withOption(quotedRegexOpt)
/////////////////////////////////////////////////////////////////////////
0:       options.setStripQuotedText(cmdLine.hasOption(quotedOpt));
1: 
/////////////////////////////////////////////////////////////////////////
0:       if (cmdLine.hasOption(quotedRegexOpt)){
0:         options.setQuotedTextPattern(Pattern.compile(cmdLine.getValue(quotedRegexOpt).toString()));
1:       }
commit:3b9f635
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: 
0:       List<Pattern> patterns = new ArrayList<Pattern>(5);
0:       //patternOrder is used downstream so that we can know what order the text is in instead of encoding it in the string, which
0:       //would require more processing later to remove it pre feature selection.
0:       Map<String, Integer> patternOrder = new HashMap<String, Integer>();
1:       int order = 0;
1:         patternOrder.put(MailOptions.FROM, order++);
1:         patternOrder.put(MailOptions.TO, order++);
1:         patternOrder.put(MailOptions.REFS, order++);
0:         patternOrder.put(MailOptions.SUBJECT, order++);
0:       options.patternOrder = patternOrder;
commit:29a7f38
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.mahout.utils.email.MailProcessor;
1: import org.apache.mahout.utils.email.MailOptions;
1: import org.apache.mahout.utils.io.ChunkedWriter;
0: import java.io.File;
0: import java.io.FileFilter;
0: import java.io.IOException;
0: import java.nio.charset.Charset;
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.regex.Pattern;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:   public void createSequenceFiles(MailOptions options) throws IOException {
0:     ChunkedWriter writer = new ChunkedWriter(new Configuration(), options.chunkSize, new Path(options.outputDir));
0:     MailProcessor processor = new MailProcessor(options, options.prefix, writer);
0:       if (options.input.isDirectory()) {
0:         PrefixAdditionFilter filter = new PrefixAdditionFilter(processor, writer);
0:         options.input.listFiles(filter);
0:         log.info("Parsed " + filter.getMessageCount() + " messages from " + options.input.getAbsolutePath());
1:       } else {
1:         long start = System.currentTimeMillis();
0:         long cnt = processor.parseMboxLineByLine(options.input);
1:         long finish = System.currentTimeMillis();
0:         log.info("Parsed " + cnt + " messages from " + options.input.getAbsolutePath() + " in time: " + (finish - start));
1:       }
1: 
0:     private MailProcessor processor;
0:     private ChunkedWriter writer;
0:     private long messageCount;
1: 
0:     public PrefixAdditionFilter(MailProcessor processor, ChunkedWriter writer) {
0:       this.processor = processor;
1: 
1:     public long getMessageCount() {
1: 
0:         log.info("At " + current.getAbsolutePath());
0:         PrefixAdditionFilter nested =
0:                 new PrefixAdditionFilter(new MailProcessor(processor.getOptions(), processor.getPrefix() + File.separator + current.getName(), writer),
0:                         writer);
0:         long dirCount = nested.getMessageCount();
0:         log.info("Parsed " + dirCount + " messages from directory " + current.getAbsolutePath());
0:           messageCount += processor.parseMboxLineByLine(current);
1: 
1: 
0:     Option inputOpt = obuilder.withLongName("input").withRequired(true).withArgument(
0:             abuilder.withName("input").withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The input file/dir containing the documents").withShortName("i").create();
1: 
0:             abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The output directory").withShortName("o").create();
1: 
0:             abuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The chunkSize in MegaBytes. Defaults to 64").withShortName("chunk").create();
1: 
0:             abuilder.withName("keyPrefix").withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The prefix to be prepended to the key").withShortName("prefix").create();
0:             abuilder.withName("charset").withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The name of the character encoding of the input files").withShortName("c").create();
0:     Option subjectOpt = obuilder.withLongName("subject").withRequired(false).
0:             withDescription("Include the Mail subject as part of the text.  Default is false").withShortName("s").create();
0:     Option toOpt = obuilder.withLongName("to").withRequired(false).
0:             withDescription("Include the to field in the text.  Default is false").withShortName("to").create();
0:     Option fromOpt = obuilder.withLongName("from").withRequired(false).
0:             withDescription("Include the from field in the text.  Default is false").withShortName("from").create();
0:     Option refsOpt = obuilder.withLongName("references").withRequired(false).
0:             withDescription("Include the references field in the text.  Default is false").withShortName("refs").create();
0:     Option bodyOpt = obuilder.withLongName("body").withRequired(false).
0:             withDescription("Include the body in the output.  Default is false").withShortName("b").create();
0:     Option separatorOpt = obuilder.withLongName("separator").withRequired(false).withArgument(
0:             abuilder.withName("separator").withMinimum(1).withMaximum(1).create()).
0:             withDescription("The separator to use between metadata items (to, from, etc.).  Default is \\n").withShortName("sep").create();
1: 
0:     Option bodySeparatorOpt = obuilder.withLongName("bodySeparator").withRequired(false).withArgument(
0:             abuilder.withName("bodySeparator").withMinimum(1).withMaximum(1).create()).
0:             withDescription("The separator to use between lines in the body.  Default is \\n.  Useful to change if you wish to have the message be on one line").withShortName("bodySep").create();
0:             .create();
1: 
0:             charsetOpt).withOption(outputDirOpt).withOption(helpOpt).withOption(inputOpt).withOption(subjectOpt).withOption(toOpt)
0:             .withOption(fromOpt).withOption(bodyOpt).withOption(refsOpt).withOption(bodySeparatorOpt)
0:             .withOption(separatorOpt).create();
1: 
/////////////////////////////////////////////////////////////////////////
0:       File input = new File((String) cmdLine.getValue(inputOpt));
0: 
0: 
0: 
1:       MailOptions options = new MailOptions();
0:       options.input = input;
0:       options.outputDir = outputDir;
0:       options.prefix = prefix;
0:       options.chunkSize = chunkSize;
0:       options.charset = charset;
0: 
0:       //If this order changes, must change FromEmailToDictionaryMapper, potentially, as it expects From to be first
0:       List<Pattern> patterns = new ArrayList<Pattern>();
0:       //new Pattern[]{MailProcessor.FROM_PREFIX, MailProcessor.TO_PREFIX, MailProcessor.REFS_PREFIX, MailProcessor.SUBJECT_PREFIX, };
0:       if (cmdLine.hasOption(fromOpt)) {
1:         patterns.add(MailProcessor.FROM_PREFIX);
1:       }
0:       if (cmdLine.hasOption(toOpt)) {
1:         patterns.add(MailProcessor.TO_PREFIX);
1:       }
0:       if (cmdLine.hasOption(refsOpt)) {
1:         patterns.add(MailProcessor.REFS_PREFIX);
1:       }
0:       if (cmdLine.hasOption(subjectOpt)) {
1:         patterns.add(MailProcessor.SUBJECT_PREFIX);
1:       }
0:       options.patternsToMatch = patterns.toArray(new Pattern[patterns.size()]);
0:       options.includeBody = cmdLine.hasOption(bodyOpt);
0:       options.separator = "\n";
0:       if (cmdLine.hasOption(separatorOpt)) {
0:         options.separator = cmdLine.getValue(separatorOpt).toString();
1:       }
0:       if (cmdLine.hasOption(bodySeparatorOpt)) {
0:         options.bodySeparator = cmdLine.getValue(bodySeparatorOpt).toString();
1:       }
1:       long start = System.currentTimeMillis();
0:       dir.createSequenceFiles(options);
1:       long finish = System.currentTimeMillis();
0:       if (log.isInfoEnabled()) {
0:         log.info("Conversion took " + (finish - start) + " ms");
1:       }
0: 
commit:020e3be
/////////////////////////////////////////////////////////////////////////
0:           throw new IllegalStateException("Error processing " + current, e);
commit:c36923f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.mahout.text;
0: 
0: import java.io.Closeable;
0: import java.io.File;
0: import java.io.FileFilter;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: import java.nio.charset.Charset;
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
0: 
0: import org.apache.commons.cli2.CommandLine;
0: import org.apache.commons.cli2.Group;
0: import org.apache.commons.cli2.Option;
0: import org.apache.commons.cli2.OptionException;
0: import org.apache.commons.cli2.builder.ArgumentBuilder;
0: import org.apache.commons.cli2.builder.DefaultOptionBuilder;
0: import org.apache.commons.cli2.builder.GroupBuilder;
0: import org.apache.commons.cli2.commandline.Parser;
1: import org.apache.hadoop.conf.Configuration;
0: import org.apache.hadoop.fs.FileSystem;
1: import org.apache.hadoop.fs.Path;
0: import org.apache.hadoop.io.SequenceFile;
0: import org.apache.hadoop.io.Text;
0: import org.apache.mahout.common.CommandLineUtil;
0: import org.apache.mahout.common.FileLineIterable;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.hadoop.io.SequenceFile.CompressionType;
0: 
1: /**
0:  * Converts a directory of gzipped mail archives into SequenceFiles of specified chunkSize.
0:  * This class is similar to {@link SequenceFilesFromDirectory} except it uses block-compressed
0:  * {@link SequenceFile}s and parses out the subject and body text of each mail message into
0:  * a separate key/value pair.
1:  */
0: public final class SequenceFilesFromMailArchives {
0: 
0:   private static final Logger log = LoggerFactory.getLogger(SequenceFilesFromMailArchives.class);
0:   
0:   private static ChunkedWriter createNewChunkedWriter(int chunkSizeInMB, String outputDir) throws IOException {
0:     return new ChunkedWriter(chunkSizeInMB, outputDir);
1:   }
0:   
0:   public void createSequenceFiles(File parentDir,
0:                                   String outputDir,
0:                                   String prefix,
0:                                   int chunkSizeInMB,
0:                                   Charset charset) throws IOException {
0:     ChunkedWriter writer = createNewChunkedWriter(chunkSizeInMB, outputDir);
0:     PrefixAdditionFilter filter = new PrefixAdditionFilter(prefix, writer, charset);
0:     parentDir.listFiles(filter);
0:     writer.close();
0:     
0:     log.info("Parsed "+filter.getMessageCount()+" messages from "+parentDir.getAbsolutePath());
1:   }
0:   
0:   public static class ChunkedWriter implements Closeable {
0:     private final int maxChunkSizeInBytes;
0:     private final String outputDir;
0:     private SequenceFile.Writer writer;
0:     private int currentChunkID;
0:     private int currentChunkSize;
0:     private final Configuration conf = new Configuration();
0:     private final FileSystem fs;
0:     
0:     public ChunkedWriter(int chunkSizeInMB, String outputDir) throws IOException {
0:       if (chunkSizeInMB > 1984) {
0:         chunkSizeInMB = 1984;
1:       }
0:       maxChunkSizeInBytes = chunkSizeInMB * 1024 * 1024;
0:       this.outputDir = outputDir;
0:       fs = FileSystem.get(conf);
0:       currentChunkID = 0;
0:       
0:       writer = SequenceFile.createWriter(fs, conf, getPath(currentChunkID), Text.class, Text.class, SequenceFile.CompressionType.BLOCK);      
1:     }
0:     
0:     private Path getPath(int chunkID) {
0:       return new Path(outputDir + "/chunk-" + chunkID);
1:     }
0:     
0:     public void write(String key, String value) throws IOException {
0:       if (currentChunkSize > maxChunkSizeInBytes) {
0:         writer.close();
0:         log.info("Chunk size ("+currentChunkSize+") reached MAX; creating new chunk "+(currentChunkID+1));
0:         writer = SequenceFile.createWriter(fs, conf, getPath(currentChunkID++), Text.class, Text.class, SequenceFile.CompressionType.BLOCK);
0:         currentChunkSize = 0;        
1:       }
0:       
0:       Text keyT = new Text(key);
0:       Text valueT = new Text(value);
0:       currentChunkSize += keyT.getBytes().length + valueT.getBytes().length; // Overhead
0:       writer.append(keyT, valueT);
1:     }
0:     
1:     @Override
0:     public void close() throws IOException {
0:       writer.close();
1:     }
1:   }
0:   
0:   // regular expressions used to parse individual messages
0:   private static final Pattern MESSAGE_START = 
0:     Pattern.compile("^From \\S+@\\S.*\\d{4}$", Pattern.CASE_INSENSITIVE);
0:   private static final Pattern MESSAGE_ID_PREFIX = 
0:     Pattern.compile("^message-id: <(.*)>$", Pattern.CASE_INSENSITIVE);
0:   private static final Pattern SUBJECT_PREFIX = 
0:     Pattern.compile("^subject: (.*)$", Pattern.CASE_INSENSITIVE);  
0:   
0:   public class PrefixAdditionFilter implements FileFilter {
0:     private final String prefix;
0:     private final ChunkedWriter writer;
0:     private final Charset charset;
0:     private final StringBuilder file;
0:     private int messageCount;
0:     
0:     public PrefixAdditionFilter(String prefix, ChunkedWriter writer, Charset charset) {
0:       this.prefix = prefix;
1:       this.writer = writer;
0:       this.charset = charset;
0:       this.file = new StringBuilder();
0:       this.messageCount = 0;
1:     }
0:     
0:     public int getMessageCount() {
0:       return messageCount;
1:     }
0:     
1:     @Override
0:     public boolean accept(File current) {
0:       if (current.isDirectory()) {
0:         log.info("At "+current.getAbsolutePath());
0:         PrefixAdditionFilter nested = 
0:           new PrefixAdditionFilter(prefix + File.separator + current.getName(), writer, charset);
0:         current.listFiles(nested);
0:         int dirCount = nested.getMessageCount();
0:         log.info("Parsed "+dirCount+" messages from directory "+current.getAbsolutePath());
0:         messageCount += dirCount;
0:       } else {
0:         parseFileLineByLine(current);
1:       }
0:       return false;
1:     }
0:     
0:     // extracts mail subject and body text from 0 or more mail messages
0:     // embedded in the supplied file using simple pattern matching
0:     private final void parseFileLineByLine(File current) {      
0:       try {
0:         file.setLength(0); // reset the buffer
0:         
0:         // tmps used during mail message parsing
0:         String messageId = null;
0:         boolean inBody = false;
0:         Matcher subjectMatcher = SUBJECT_PREFIX.matcher("");
0:         Matcher messageIdMatcher = MESSAGE_ID_PREFIX.matcher("");
0:         Matcher messageBoundaryMatcher = MESSAGE_START.matcher("");
0:         
0:         for (String nextLine : new FileLineIterable(current, charset, false)) {
0: 
0:           // subject may come before message ID
0:           subjectMatcher.reset(nextLine);
0:           if (subjectMatcher.matches()) {
0:             file.append(subjectMatcher.group(1)).append('\n');
1:           }
0:           
0:           // only start appending body content after we've seen a message ID
0:           if (messageId != null) {            
0:             // first, see if we hit the end of the message
0:             messageBoundaryMatcher.reset(nextLine);              
0:             if (messageBoundaryMatcher.matches()) {
0:                 // done parsing this message ... write it out
0:                 String key = prefix + File.separator + current.getName() + File.separator + messageId;
0:                 writer.write(key, file.toString());
0:                 file.setLength(0); // reset the buffer
0:                 messageId = null;
0:                 inBody = false;
0:             } else {
0:               if (inBody) {
0:                 if (nextLine.length() > 0) {
0:                   file.append(nextLine).append('\n');
1:                 }
0:               } else {
0:                 // first empty line we see after reading the message Id
0:                 // indicates that we are in the body ...
0:                 inBody = (nextLine.length() == 0);
1:               }
1:             }
0:           } else {
0:             if (nextLine.length() > 14) {
0:               messageIdMatcher.reset(nextLine);
0:               if (messageIdMatcher.matches()) {
0:                 messageId = messageIdMatcher.group(1);
0:                 ++messageCount;
1:               }
1:             }
1:           }
1:         }
0: 
0:         // write the last message in the file if available
0:         if (messageId != null) {
0:           String key = prefix + File.separator + current.getName() + File.separator + messageId;
0:           writer.write(key, file.toString());
0:           file.setLength(0); // reset the buffer
0:           messageId = null;
0:           inBody = false;
1:         }
0:       } catch (FileNotFoundException e) {
0:         // Skip file.
0:       } catch (IOException e) {
0:         // TODO: report exceptions and continue;
0:         throw new IllegalStateException(e);
1:       }      
1:     }
1:   }
0:   
1:   public static void main(String[] args) throws Exception {
0:     DefaultOptionBuilder obuilder = new DefaultOptionBuilder();
0:     ArgumentBuilder abuilder = new ArgumentBuilder();
0:     GroupBuilder gbuilder = new GroupBuilder();
0:     
0:     Option parentOpt = obuilder.withLongName("input").withRequired(true).withArgument(
0:       abuilder.withName("input").withMinimum(1).withMaximum(1).create()).withDescription(
0:       "The input dir containing the documents").withShortName("i").create();
0:     
0:     Option outputDirOpt = obuilder.withLongName("output").withRequired(true).withArgument(
0:       abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription(
0:       "The output directory").withShortName("o").create();
0:     
0:     Option chunkSizeOpt = obuilder.withLongName("chunkSize").withArgument(
0:       abuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create()).withDescription(
0:       "The chunkSize in MegaBytes. Defaults to 64").withShortName("chunk").create();
0:     
0:     Option keyPrefixOpt = obuilder.withLongName("keyPrefix").withArgument(
0:       abuilder.withName("keyPrefix").withMinimum(1).withMaximum(1).create()).withDescription(
0:       "The prefix to be prepended to the key").withShortName("prefix").create();
0:     
0:     Option charsetOpt = obuilder.withLongName("charset").withRequired(true).withArgument(
0:       abuilder.withName("charset").withMinimum(1).withMaximum(1).create()).withDescription(
0:       "The name of the character encoding of the input files").withShortName("c").create();
0:     
0:     Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h")
0:         .create();
0:     
0:     Group group = gbuilder.withName("Options").withOption(keyPrefixOpt).withOption(chunkSizeOpt).withOption(
0:       charsetOpt).withOption(outputDirOpt).withOption(helpOpt).withOption(parentOpt).create();
0:     
0:     try {
0:       Parser parser = new Parser();
0:       parser.setGroup(group);
0:       parser.setHelpOption(helpOpt);
0:       CommandLine cmdLine = parser.parse(args);
0:       if (cmdLine.hasOption(helpOpt)) {
0:         CommandLineUtil.printHelp(group);
0:         return;
1:       }
0:       File parentDir = new File((String) cmdLine.getValue(parentOpt));
0:       String outputDir = (String) cmdLine.getValue(outputDirOpt);
0:       
1:       int chunkSize = 64;
0:       if (cmdLine.hasOption(chunkSizeOpt)) {
0:         chunkSize = Integer.parseInt((String) cmdLine.getValue(chunkSizeOpt));
1:       }
0:       
1:       String prefix = "";
0:       if (cmdLine.hasOption(keyPrefixOpt)) {
0:         prefix = (String) cmdLine.getValue(keyPrefixOpt);
1:       }
0:       Charset charset = Charset.forName((String) cmdLine.getValue(charsetOpt));
0:       SequenceFilesFromMailArchives dir = new SequenceFilesFromMailArchives();
0:       
0:       dir.createSequenceFiles(parentDir, outputDir, prefix, chunkSize, charset);
0:     } catch (OptionException e) {
0:       log.error("Exception", e);
0:       CommandLineUtil.printHelp(group);
1:     }
1:   }
1: }
author:Sebastian Schelter
-------------------------------------------------------------------------------
commit:6d16230
/////////////////////////////////////////////////////////////////////////
0:                 "Specify the regex that identifies quoted text.  "
0:                     + "Default is to look for > or | at the beginning of the line.")
/////////////////////////////////////////////////////////////////////////
0:                 "The separator to use between lines in the body.  Default is \\n.  "
0:                     + "Useful to change if you wish to have the message be on one line")
commit:3c22856
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * it uses block-compressed {@link org.apache.hadoop.io.SequenceFile}s and parses out the subject and
/////////////////////////////////////////////////////////////////////////
0:                 "Specify the regex that identifies quoted text.  " +
0:                 "Default is to look for > or | at the beginning of the line.")
/////////////////////////////////////////////////////////////////////////
0:                 "The separator to use between lines in the body.  Default is \\n.  " +
0:                 "Useful to change if you wish to have the message be on one line")
commit:210b265
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
0:     List<Pattern> patterns = Lists.newArrayListWithCapacity(5);
commit:d608a88
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.io.Closeables;
/////////////////////////////////////////////////////////////////////////
0:     try {
0:       PrefixAdditionFilter filter = new PrefixAdditionFilter(prefix, writer, charset);
0:       parentDir.listFiles(filter);
0:       log.info("Parsed "+filter.getMessageCount()+" messages from "+parentDir.getAbsolutePath());
0:     } finally {
0:       Closeables.closeQuietly(writer);
0:     }
/////////////////////////////////////////////////////////////////////////
0:         Closeables.closeQuietly(writer);
/////////////////////////////////////////////////////////////////////////
0:       Closeables.closeQuietly(writer);
author:Ted Dunning
-------------------------------------------------------------------------------
commit:402e296
/////////////////////////////////////////////////////////////////////////
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:8396a27
/////////////////////////////////////////////////////////////////////////
1:         log.info("Parsed {} messages from {} in time: {}", cnt, options.getInput().getAbsolutePath(), finish - start);
commit:229aeff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     //GroupBuilder gbuilder = new GroupBuilder();
commit:763c94c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.mahout.common.commandline.DefaultOptionCreator;
/////////////////////////////////////////////////////////////////////////
0:     ChunkedWriter writer = new ChunkedWriter(new Configuration(), options.getChunkSize(), new Path(options.getOutputDir()));
0:     MailProcessor processor = new MailProcessor(options, options.getPrefix(), writer);
1:       if (options.getInput().isDirectory()) {
0:         options.getInput().listFiles(filter);
0:         log.info("Parsed {} messages from {}", filter.getMessageCount(), options.getInput().getAbsolutePath());
1:         long cnt = processor.parseMboxLineByLine(options.getInput());
0:         log.info("Parsed {} messages from {} in time: {}",
0:                  new Object[] { cnt, options.getInput().getAbsolutePath(), (finish - start) });
/////////////////////////////////////////////////////////////////////////
0:     private final MailProcessor processor;
0:     private final ChunkedWriter writer;
/////////////////////////////////////////////////////////////////////////
1:         log.info("At {}", current.getAbsolutePath());
0:         PrefixAdditionFilter nested = new PrefixAdditionFilter(new MailProcessor(
0:             processor.getOptions(), processor.getPrefix() + File.separator + current.getName(), writer), writer);
0:         log.info("Parsed {} messages from directory {}", dirCount, current.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
0:     Option inputOpt = DefaultOptionCreator.inputOption().create();
0:     Option outputDirOpt = DefaultOptionCreator.outputOption().create();
/////////////////////////////////////////////////////////////////////////
0:     Option helpOpt = DefaultOptionCreator.helpOption();
/////////////////////////////////////////////////////////////////////////
1:       options.setInput(input);
1:       options.setOutputDir(outputDir);
1:       options.setPrefix(prefix);
1:       options.setChunkSize(chunkSize);
1:       options.setCharset(charset);
0:       // patternOrder is used downstream so that we can know what order the text is in instead 
0:       // of encoding it in the string, which
1:       // would require more processing later to remove it pre feature selection.
/////////////////////////////////////////////////////////////////////////
1:       options.setPatternsToMatch(patterns.toArray(new Pattern[patterns.size()]));
1:       options.setPatternOrder(patternOrder);
0:       options.setIncludeBody(cmdLine.hasOption(bodyOpt));
0:       options.setSeparator("\n");
0:         options.setSeparator(cmdLine.getValue(separatorOpt).toString());
0:         options.setBodySeparator(cmdLine.getValue(bodySeparatorOpt).toString());
1:       log.info("Conversion took {}ms", finish - start);
commit:e4dfc93
/////////////////////////////////////////////////////////////////////////
commit:50fd693
commit:39fe224
/////////////////////////////////////////////////////////////////////////
0:                 inBody = nextLine.length() == 0;
commit:a13b4b7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.mahout.common.iterator.FileLineIterable;
/////////////////////////////////////////////////////////////////////////
0:         try {
0:           parseFileLineByLine(current);
0:         } catch (IOException e) {
0:           throw new IllegalStateException(e);
0:         }
0:     private void parseFileLineByLine(File current) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:       }
0:       // TODO: report exceptions and continue;
0: 
author:Robin Anil
-------------------------------------------------------------------------------
commit:86b1196
/////////////////////////////////////////////////////////////////////////
0: 
1: import org.apache.hadoop.util.ToolRunner;
1: import org.apache.mahout.common.AbstractJob;
0: import org.apache.mahout.utils.email.MailProcessor;
/////////////////////////////////////////////////////////////////////////
1:  * Converts a directory of gzipped mail archives into SequenceFiles of specified
1:  * chunkSize. This class is similar to {@link SequenceFilesFromDirectory} except
0:  * it uses block-compressed {@link SequenceFile}s and parses out the subject and
1:  * body text of each mail message into a separate key/value pair.
1: public final class SequenceFilesFromMailArchives extends AbstractJob {
0:   private static final Logger log = LoggerFactory.getLogger(
0:       SequenceFilesFromMailArchives.class);
0:     ChunkedWriter writer = new ChunkedWriter(
0:         getConf(), options.getChunkSize(), new Path(options.getOutputDir()));
0:     MailProcessor processor = new MailProcessor(
0:         options, options.getPrefix(), writer);
0:         PrefixAdditionFilter filter = new PrefixAdditionFilter(
0:             processor, writer);
0:         log.info("Parsed {} messages from {}", filter.getMessageCount(),
0:             options.getInput().getAbsolutePath());
0:         log.info("Parsed {} messages from {} in time: {}", new Object[] {
0:             cnt, options.getInput().getAbsolutePath(), finish - start});
/////////////////////////////////////////////////////////////////////////
0:         PrefixAdditionFilter nested = new PrefixAdditionFilter(
0:             new MailProcessor(processor.getOptions(), processor.getPrefix()
0:                 + File.separator + current.getName(), writer), writer);
0:         log.info("Parsed {} messages from directory {}", dirCount,
0:             current.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
1:     ToolRunner.run(new Configuration(), new SequenceFilesFromMailArchives(), args);
0:   }
0: 
0:   @Override
1:   public int run(String[] args) throws Exception {
1:     addInputOption();
1:     addOutputOption();
0:     addOption(obuilder.withLongName("chunkSize").withArgument(
0:         abuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create())
0:         .withDescription("The chunkSize in MegaBytes. Defaults to 64")
0:         .withShortName("chunk").create());
0:     addOption(obuilder.withLongName("keyPrefix").withArgument(
0:         abuilder.withName("keyPrefix").withMinimum(1).withMaximum(1).create())
0:         .withDescription("The prefix to be prepended to the key")
0:         .withShortName("prefix").create());
0:     addOption(obuilder.withLongName("charset")
0:         .withRequired(true).withArgument(abuilder.withName("charset")
0:             .withMinimum(1).withMaximum(1).create()).withDescription(
0:             "The name of the character encoding of the input files")
0:         .withShortName("c").create());
0:     addOption(obuilder.withLongName("subject")
0:         .withRequired(false).withDescription(
0:             "Include the Mail subject as part of the text.  Default is false")
0:         .withShortName("s").create());
0:     addOption(obuilder.withLongName("to").withRequired(false)
0:         .withDescription("Include the to field in the text.  Default is false")
0:         .withShortName("to").create());
0:     addOption(obuilder.withLongName("from").withRequired(false).withDescription(
0:         "Include the from field in the text.  Default is false")
0:         .withShortName("from").create());
0:     addOption(obuilder.withLongName("references")
0:         .withRequired(false).withDescription(
0:             "Include the references field in the text.  Default is false")
0:         .withShortName("refs").create());
0:     addOption(obuilder.withLongName("body").withRequired(false)
0:         .withDescription("Include the body in the output.  Default is false")
0:         .withShortName("b").create());
0:     addOption(obuilder.withLongName("stripQuoted")
0:         .withRequired(false).withDescription(
0:             "Strip (remove) quoted email text in the body.  Default is false")
0:         .withShortName("q").create());
0:     addOption(
0:         obuilder.withLongName("quotedRegex")
0:             .withRequired(false).withArgument(abuilder.withName("regex")
0:                 .withMinimum(1).withMaximum(1).create()).withDescription(
0:                 "Specify the regex that identifies quoted text.  Default is to look for > or | at the beginning of the line.")
0:             .withShortName("q").create());
0:     addOption(
0:         obuilder.withLongName("separator")
0:             .withRequired(false).withArgument(abuilder.withName("separator")
0:                 .withMinimum(1).withMaximum(1).create()).withDescription(
0:                 "The separator to use between metadata items (to, from, etc.).  Default is \\n")
0:             .withShortName("sep").create());
0:     addOption(
0:         obuilder.withLongName("bodySeparator")
0:             .withRequired(false).withArgument(abuilder.withName("bodySeparator")
0:                 .withMinimum(1).withMaximum(1).create()).withDescription(
0:                 "The separator to use between lines in the body.  Default is \\n.  Useful to change if you wish to have the message be on one line")
0:             .withShortName("bodySep").create());
1:     addOption(DefaultOptionCreator.helpOption());
1:     Map<String, List<String>> parsedArgs = parseArguments(args);
1:     if (parsedArgs == null) {
1:       return -1;
1:     File input = getInputFile();
1:     String outputDir = getOutputPath().toString();
0:     int chunkSize = 64;
0:     if (hasOption("chunkSize")) {
0:       chunkSize = Integer.parseInt(getOption("chunkSize"));
0:     }
0: 
0:     String prefix = "";
0:     if (hasOption("keyPrefix")) {
0:       prefix = getOption("keyPrefix");
0:     }
0: 
0:     Charset charset = Charset.forName(getOption("charset"));
0:     MailOptions options = new MailOptions();
0:     options.setInput(input);
0:     options.setOutputDir(outputDir);
0:     options.setPrefix(prefix);
0:     options.setChunkSize(chunkSize);
0:     options.setCharset(charset);
0: 
0:     List<Pattern> patterns = new ArrayList<Pattern>(5);
1:     // patternOrder is used downstream so that we can know what order the text
0:     // is in instead
0:     // of encoding it in the string, which
0:     // would require more processing later to remove it pre feature selection.
0:     Map<String,Integer> patternOrder = new HashMap<String,Integer>();
0:     int order = 0;
0:     if (hasOption("from")) {
0:       patterns.add(MailProcessor.FROM_PREFIX);
0:       patternOrder.put(MailOptions.FROM, order++);
0:     }
0:     if (hasOption("to")) {
0:       patterns.add(MailProcessor.TO_PREFIX);
0:       patternOrder.put(MailOptions.TO, order++);
0:     }
0:     if (hasOption("references")) {
0:       patterns.add(MailProcessor.REFS_PREFIX);
0:       patternOrder.put(MailOptions.REFS, order++);
0:     }
0:     if (hasOption("subject")) {
0:       patterns.add(MailProcessor.SUBJECT_PREFIX);
0:       patternOrder.put(MailOptions.SUBJECT, order++);
0:     }
0:     options.setStripQuotedText(hasOption("stripQuoted"));
0: 
0:     options.setPatternsToMatch(patterns.toArray(new Pattern[patterns.size()]));
0:     options.setPatternOrder(patternOrder);
0:     options.setIncludeBody(hasOption("body"));
0:     options.setSeparator("\n");
0:     if (hasOption("separator")) {
0:       options.setSeparator(getOption("separator"));
0:     }
0:     if (hasOption("bodySeparator")) {
0:       options.setBodySeparator(getOption("bodySeparator"));
0:     }
0:     if (hasOption("quotedRegex")) {
0:       options.setQuotedTextPattern(Pattern.compile(getOption("quotedRegex")));
0:     }
0:     long start = System.currentTimeMillis();
1:     createSequenceFiles(options);
0:     long finish = System.currentTimeMillis();
0:     log.info("Conversion took {}ms", finish - start);
1:     return 0;
0:   }
author:tcp
-------------------------------------------------------------------------------
commit:e64dd36
/////////////////////////////////////////////////////////////////////////
0:       if (cmdLine.hasOption(quotedRegexOpt)) {
============================================================================