1:5bde30b: /**
1:5bde30b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:5bde30b:  * contributor license agreements.  See the NOTICE file distributed with
1:5bde30b:  * this work for additional information regarding copyright ownership.
1:5bde30b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:5bde30b:  * (the "License"); you may not use this file except in compliance with
1:5bde30b:  * the License.  You may obtain a copy of the License at
1:5bde30b:  *
1:5bde30b:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5bde30b:  *
1:5bde30b:  * Unless required by applicable law or agreed to in writing, software
1:5bde30b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5bde30b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5bde30b:  * See the License for the specific language governing permissions and
1:5bde30b:  * limitations under the License.
1:5bde30b:  */
1:5bde30b: 
1:5bde30b: package org.apache.mahout.cf.taste.impl.eval;
1:5bde30b: 
1:5bde30b: import java.util.Arrays;
1:5bde30b: import java.util.List;
1:5bde30b: 
1:5bde30b: import org.apache.mahout.cf.taste.common.TasteException;
1:5bde30b: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1:5bde30b: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1:5bde30b: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
1:5bde30b: import org.apache.mahout.cf.taste.model.DataModel;
1:5bde30b: import org.apache.mahout.cf.taste.model.PreferenceArray;
1:5bde30b: import org.apache.mahout.cf.taste.recommender.RecommendedItem;
1:5bde30b: import org.apache.mahout.cf.taste.recommender.Recommender;
1:5bde30b: import org.slf4j.Logger;
1:5bde30b: import org.slf4j.LoggerFactory;
1:5bde30b: 
1:5bde30b: /**
1:5bde30b:  * Evaluate recommender by comparing order of all raw prefs with order in 
1:5bde30b:  * recommender's output for that user. Can also compare data models.
1:5bde30b:  */
1:5bde30b: public final class OrderBasedRecommenderEvaluator {
1:5bde30b: 
1:5bde30b:   private static final Logger log = LoggerFactory.getLogger(OrderBasedRecommenderEvaluator.class);
1:5bde30b: 
1:39fe224:   private OrderBasedRecommenderEvaluator() {
1:39fe224:   }
1:39fe224: 
1:39fe224:   public static void evaluate(Recommender recommender1,
1:39fe224:                               Recommender recommender2,
1:39fe224:                               int samples,
1:39fe224:                               RunningAverage tracker,
1:39fe224:                               String tag) throws TasteException {
1:5bde30b:     printHeader();
1:5bde30b:     LongPrimitiveIterator users = recommender1.getDataModel().getUserIDs();
1:5bde30b: 
1:5bde30b:     while (users.hasNext()) {
1:5bde30b:       long userID = users.nextLong();
1:5bde30b:       List<RecommendedItem> recs1 = recommender1.recommend(userID, samples);
1:5bde30b:       List<RecommendedItem> recs2 = recommender2.recommend(userID, samples);
1:5bde30b:       FastIDSet commonSet = new FastIDSet();
1:5bde30b:       long maxItemID = setBits(commonSet, recs1, samples);
1:5bde30b:       FastIDSet otherSet = new FastIDSet();
1:5bde30b:       maxItemID = Math.max(maxItemID, setBits(otherSet, recs2, samples));
1:5bde30b:       int max = mask(commonSet, otherSet, maxItemID);
1:5bde30b:       max = Math.min(max, samples);
1:5bde30b:       if (max < 2) {
1:5bde30b:         continue;
1:5bde30b:       }
1:5bde30b:       Long[] items1 = getCommonItems(commonSet, recs1, max);
1:5bde30b:       Long[] items2 = getCommonItems(commonSet, recs2, max);
1:5bde30b:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:5bde30b:       tracker.addDatum(variance);
1:5bde30b:     }
1:5bde30b:   }
1:5bde30b: 
1:39fe224:   public static void evaluate(Recommender recommender,
1:39fe224:                               DataModel model,
1:39fe224:                               int samples,
1:39fe224:                               RunningAverage tracker,
1:39fe224:                               String tag) throws TasteException {
1:5bde30b:     printHeader();
1:5bde30b:     LongPrimitiveIterator users = recommender.getDataModel().getUserIDs();
1:5bde30b:     while (users.hasNext()) {
1:5bde30b:       long userID = users.nextLong();
1:5bde30b:       List<RecommendedItem> recs1 = recommender.recommend(userID, model.getNumItems());
1:5bde30b:       PreferenceArray prefs2 = model.getPreferencesFromUser(userID);
1:5bde30b:       prefs2.sortByValueReversed();
1:5bde30b:       FastIDSet commonSet = new FastIDSet();
1:5bde30b:       long maxItemID = setBits(commonSet, recs1, samples);
1:5bde30b:       FastIDSet otherSet = new FastIDSet();
1:5bde30b:       maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));
1:5bde30b:       int max = mask(commonSet, otherSet, maxItemID);
1:5bde30b:       max = Math.min(max, samples);
1:5bde30b:       if (max < 2) {
1:5bde30b:         continue;
1:5bde30b:       }
1:5bde30b:       Long[] items1 = getCommonItems(commonSet, recs1, max);
1:5bde30b:       Long[] items2 = getCommonItems(commonSet, prefs2, max);
1:5bde30b:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:5bde30b:       tracker.addDatum(variance);
1:5bde30b:     }
1:5bde30b:   }
1:5bde30b: 
1:39fe224:   public static void evaluate(DataModel model1,
1:39fe224:                               DataModel model2,
1:39fe224:                               int samples,
1:39fe224:                               RunningAverage tracker,
1:39fe224:                               String tag) throws TasteException {
1:5bde30b:     printHeader();
1:5bde30b:     LongPrimitiveIterator users = model1.getUserIDs();
1:5bde30b:     while (users.hasNext()) {
1:5bde30b:       long userID = users.nextLong();
1:5bde30b:       PreferenceArray prefs1 = model1.getPreferencesFromUser(userID);
1:5bde30b:       PreferenceArray prefs2 = model2.getPreferencesFromUser(userID);
1:5bde30b:       prefs1.sortByValueReversed();
1:5bde30b:       prefs2.sortByValueReversed();
1:5bde30b:       FastIDSet commonSet = new FastIDSet();
1:5bde30b:       long maxItemID = setBits(commonSet, prefs1, samples);
1:5bde30b:       FastIDSet otherSet = new FastIDSet();
1:5bde30b:       maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));
1:5bde30b:       int max = mask(commonSet, otherSet, maxItemID);
1:5bde30b:       max = Math.min(max, samples);
1:5bde30b:       if (max < 2) {
1:5bde30b:         continue;
1:5bde30b:       }
1:5bde30b:       Long[] items1 = getCommonItems(commonSet, prefs1, max);
1:5bde30b:       Long[] items2 = getCommonItems(commonSet, prefs2, max);
1:5bde30b:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:5bde30b:       tracker.addDatum(variance);
1:5bde30b:     }
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * This exists because FastIDSet has 'retainAll' as MASK, but there is 
1:5bde30b:    * no count of the number of items in the set. size() is supposed to do 
1:5bde30b:    * this but does not work.
1:5bde30b:    */
1:5bde30b:   private static int mask(FastIDSet commonSet, FastIDSet otherSet, long maxItemID) {
1:5bde30b:     int count = 0;
1:5bde30b:     for (int i = 0; i <= maxItemID; i++) {
1:5bde30b:       if (commonSet.contains(i)) {
1:5bde30b:         if (otherSet.contains(i)) {
1:5bde30b:           count++;
1:5bde30b:         } else {
1:5bde30b:           commonSet.remove(i);
1:5bde30b:         }
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return count;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static Long[] getCommonItems(FastIDSet commonSet, Iterable<RecommendedItem> recs, int max) {
1:5bde30b:     Long[] commonItems = new Long[max];
1:5bde30b:     int index = 0;
1:5bde30b:     for (RecommendedItem rec : recs) {
1:5bde30b:       Long item = rec.getItemID();
1:5bde30b:       if (commonSet.contains(item)) {
1:5bde30b:         commonItems[index++] = item;
1:5bde30b:       }
1:5bde30b:       if (index == max) {
1:5bde30b:         break;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return commonItems;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static Long[] getCommonItems(FastIDSet commonSet, PreferenceArray prefs1, int max) {
1:5bde30b:     Long[] commonItems = new Long[max];
1:5bde30b:     int index = 0;
1:5bde30b:     for (int i = 0; i < prefs1.length(); i++) {
1:5bde30b:       Long item = prefs1.getItemID(i);
1:5bde30b:       if (commonSet.contains(item)) {
1:5bde30b:         commonItems[index++] = item;
1:5bde30b:       }
1:5bde30b:       if (index == max) {
1:5bde30b:         break;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return commonItems;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static long setBits(FastIDSet modelSet, List<RecommendedItem> items, int max) {
1:5bde30b:     long maxItem = -1;
1:5bde30b:     for (int i = 0; i < items.size() && i < max; i++) {
1:5bde30b:       long itemID = items.get(i).getItemID();
1:5bde30b:       modelSet.add(itemID);
1:5bde30b:       if (itemID > maxItem) {
1:5bde30b:         maxItem = itemID;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return maxItem;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static long setBits(FastIDSet modelSet, PreferenceArray prefs, int max) {
1:5bde30b:     long maxItem = -1;
1:5bde30b:     for (int i = 0; i < prefs.length() && i < max; i++) {
1:5bde30b:       long itemID = prefs.getItemID(i);
1:5bde30b:       modelSet.add(itemID);
1:5bde30b:       if (itemID > maxItem) {
1:5bde30b:         maxItem = itemID;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return maxItem;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static void printHeader() {
1:5bde30b:     log.info("tag,user,samples,common,hamming,bubble,rank,normal,score");
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * Common Subset Scoring
1:5bde30b:    *
1:5bde30b:    * These measurements are given the set of results that are common to both
1:5bde30b:    * recommendation lists. They only get ordered lists.
1:5bde30b:    *
1:5bde30b:    * These measures all return raw numbers do not correlate among the tests.
1:5bde30b:    * The numbers are not corrected against the total number of samples or the
1:5bde30b:    * number of common items.
1:5bde30b:    * The one contract is that all measures are 0 for an exact match and an
1:5bde30b:    * increasing positive number as differences increase.
1:5bde30b:    */
1:39fe224:   private static double scoreCommonSubset(String tag,
1:39fe224:                                           long userID,
1:39fe224:                                           int samples,
1:39fe224:                                           int subset,
1:39fe224:                                           Long[] itemsL,
1:39fe224:                                           Long[] itemsR) {
1:5bde30b:     int[] vectorZ = new int[subset];
1:5bde30b:     int[] vectorZabs = new int[subset];
1:5bde30b: 
1:5bde30b:     long bubble = sort(itemsL, itemsR);
1:5bde30b:     int hamming = slidingWindowHamming(itemsR, itemsL);
1:5bde30b:     if (hamming > samples) {
1:5bde30b:       throw new IllegalStateException();
1:5bde30b:     }
1:5bde30b:     getVectorZ(itemsR, itemsL, vectorZ, vectorZabs);
1:5bde30b:     double normalW = normalWilcoxon(vectorZ, vectorZabs);
1:5bde30b:     double meanRank = getMeanRank(vectorZabs);
1:5bde30b:     // case statement for requested value
1:5bde30b:     double variance = Math.sqrt(meanRank);
1:5bde30b:     log.info("{},{},{},{},{},{},{},{},{}",
1:8396a27:              tag, userID, samples, subset, hamming, bubble, meanRank, normalW, variance);
1:5bde30b:     return variance;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   // simple sliding-window hamming distance: a[i or plus/minus 1] == b[i]
1:5bde30b:   private static int slidingWindowHamming(Long[] itemsR, Long[] itemsL) {
1:5bde30b:     int count = 0;
1:5bde30b:     int samples = itemsR.length;
1:5bde30b: 
1:5bde30b:     if (itemsR[0].equals(itemsL[0]) || itemsR[0].equals(itemsL[1])) {
1:5bde30b:       count++;
1:5bde30b:     }
1:5bde30b:     for (int i = 1; i < samples - 1; i++) {
1:5bde30b:       long itemID = itemsL[i];
1:d61a0ee:       if (itemsR[i] == itemID || itemsR[i - 1] == itemID || itemsR[i + 1] == itemID) {
1:5bde30b:         count++;
1:5bde30b:       }
1:5bde30b:     }
1:d61a0ee:     if (itemsR[samples - 1].equals(itemsL[samples - 1]) || itemsR[samples - 1].equals(itemsL[samples - 2])) {
1:5bde30b:       count++;
1:5bde30b:     }
1:5bde30b:     return count;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * Normal-distribution probability value for matched sets of values.
1:5bde30b:    * Based upon:
1:5bde30b:    * http://comp9.psych.cornell.edu/Darlington/normscor.htm
1:5bde30b:    * 
1:5bde30b:    * The Standard Wilcoxon is not used because it requires a lookup table.
1:5bde30b:    */
1:39fe224:   static double normalWilcoxon(int[] vectorZ, int[] vectorZabs) {
1:5bde30b:     int nitems = vectorZ.length;
1:5bde30b: 
1:5bde30b:     double[] ranks = new double[nitems];
1:5bde30b:     double[] ranksAbs = new double[nitems];
1:5bde30b:     wilcoxonRanks(vectorZ, vectorZabs, ranks, ranksAbs);
1:5bde30b:     return Math.min(getMeanWplus(ranks), getMeanWminus(ranks));
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * vector Z is a list of distances between the correct value and the recommended value
1:5bde30b:    * Z[i] = position i of correct itemID - position of correct itemID in recommendation list
1:3218e95:    * can be positive or negative
1:3218e95:    * the smaller the better - means recommendations are closer
1:5bde30b:    * both are the same length, and both sample from the same set
1:5bde30b:    * 
1:5bde30b:    * destructive to items arrays - allows N log N instead of N^2 order
1:5bde30b:    */
1:5bde30b:   private static void getVectorZ(Long[] itemsR, Long[] itemsL, int[] vectorZ, int[] vectorZabs) {
1:5bde30b:     int nitems = itemsR.length;
1:5bde30b:     int bottom = 0;
1:5bde30b:     int top = nitems - 1;
4:5bde30b:     for (int i = 0; i < nitems; i++) {
1:5bde30b:       long itemID = itemsR[i];
1:5bde30b:       for (int j = bottom; j <= top; j++) {
1:5bde30b:         if (itemsL[j] == null) {
1:5bde30b:           continue;
1:5bde30b:         }
1:5bde30b:         long test = itemsL[j];
1:5bde30b:         if (itemID == test) {
1:5bde30b:           vectorZ[i] = i - j;
1:5bde30b:           vectorZabs[i] = Math.abs(i - j);
1:5bde30b:           if (j == bottom) {
1:5bde30b:             bottom++;
1:5bde30b:           } else if (j == top) {
1:5bde30b:             top--;
1:5bde30b:           } else {
1:5bde30b:             itemsL[j] = null;
1:5bde30b:           }
1:5bde30b:           break;
1:5bde30b:         }
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * Ranks are the position of the value from low to high, divided by the # of values.
1:5bde30b:    * I had to walk through it a few times.
1:5bde30b:    */
1:5bde30b:   private static void wilcoxonRanks(int[] vectorZ, int[] vectorZabs, double[] ranks, double[] ranksAbs) {
1:5bde30b:     int nitems = vectorZ.length;
1:5bde30b:     int[] sorted = vectorZabs.clone();
1:5bde30b:     Arrays.sort(sorted);
1:5bde30b:     int zeros = 0;
1:5bde30b:     for (; zeros < nitems; zeros++) {
1:5bde30b:       if (sorted[zeros] > 0) {
1:5bde30b:         break;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     for (int i = 0; i < nitems; i++) {
1:5bde30b:       double rank = 0.0;
1:5bde30b:       int count = 0;
1:5bde30b:       int score = vectorZabs[i];
1:5bde30b:       for (int j = 0; j < nitems; j++) {
1:5bde30b:         if (score == sorted[j]) {
1:39fe224:           rank += j + 1 - zeros;
1:5bde30b:           count++;
1:5bde30b:         } else if (score < sorted[j]) {
1:5bde30b:           break;
1:5bde30b:         }
1:5bde30b:       }
1:5bde30b:       if (vectorZ[i] != 0) {
1:39fe224:         ranks[i] = (rank / count) * (vectorZ[i] < 0 ? -1 : 1);  // better be at least 1
1:5bde30b:         ranksAbs[i] = Math.abs(ranks[i]);
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static double getMeanRank(int[] ranks) {
1:5bde30b:     int nitems = ranks.length;
1:5bde30b:     double sum = 0.0;
1:229aeff:     for (int rank : ranks) {
1:229aeff:       sum += rank;
1:5bde30b:     }
1:5bde30b:     return sum / nitems;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static double getMeanWplus(double[] ranks) {
1:5bde30b:     int nitems = ranks.length;
1:5bde30b:     double sum = 0.0;
1:229aeff:     for (double rank : ranks) {
1:229aeff:       if (rank > 0) {
1:229aeff:         sum += rank;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return sum / nitems;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   private static double getMeanWminus(double[] ranks) {
1:5bde30b:     int nitems = ranks.length;
1:5bde30b:     double sum = 0.0;
1:229aeff:     for (double rank : ranks) {
1:229aeff:       if (rank < 0) {
1:229aeff:         sum -= rank;
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return sum / nitems;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b:   /**
1:5bde30b:    * Do bubble sort and return number of swaps needed to match preference lists.
1:5bde30b:    * Sort itemsR using itemsL as the reference order.
1:5bde30b:    */
1:39fe224:   static long sort(Long[] itemsL, Long[] itemsR) {
1:5bde30b:     int length = itemsL.length;
1:5bde30b:     if (length < 2) {
1:5bde30b:       return 0;
1:5bde30b:     }
1:5bde30b:     if (length == 2) {
1:5bde30b:       return itemsL[0].longValue() == itemsR[0].longValue() ? 0 : 1;
1:5bde30b:     }
1:5bde30b:     // 1) avoid changing originals; 2) primitive type is more efficient
1:5bde30b:     long[] reference = new long[length];
1:5bde30b:     long[] sortable = new long[length];
1:5bde30b:     for (int i = 0; i < length; i++) {
1:5bde30b:       reference[i] = itemsL[i];
1:5bde30b:       sortable[i] = itemsR[i];
1:5bde30b:     }
1:5bde30b:     int sorted = 0;
1:5bde30b:     long swaps = 0;
1:5bde30b:     while (sorted < length - 1) {
1:5bde30b:       // opportunistically trim back the top
1:5bde30b:       while (length > 0 && reference[length - 1] == sortable[length - 1]) {
1:5bde30b:         length--;
1:5bde30b:       }
1:5bde30b:       if (length == 0) {
1:5bde30b:         break;
1:5bde30b:       }
1:5bde30b:       if (reference[sorted] == sortable[sorted]) {
1:5bde30b:         sorted++;
1:5bde30b:       } else {
1:5bde30b:         for (int j = sorted; j < length - 1; j++) {
1:5bde30b:           // do not swap anything already in place
1:5bde30b:           int jump = 1;
1:5bde30b:           if (reference[j] == sortable[j]) {
1:39fe224:             while (j + jump < length && reference[j + jump] == sortable[j + jump]) {
1:5bde30b:               jump++;
1:5bde30b:             }
1:5bde30b:           }
1:39fe224:           if (j + jump < length && !(reference[j] == sortable[j] && reference[j + jump] == sortable[j + jump])) {
1:5bde30b:             long tmp = sortable[j];
1:5bde30b:             sortable[j] = sortable[j + 1];
1:5bde30b:             sortable[j + 1] = tmp;
1:5bde30b:             swaps++;
1:5bde30b:           }
1:5bde30b:         }
1:5bde30b:       }
1:5bde30b:     }
1:5bde30b:     return swaps;
1:5bde30b:   }
1:5bde30b: 
1:5bde30b: }
============================================================================
author:pferrel
-------------------------------------------------------------------------------
commit:b988c49
author:frankscholten
-------------------------------------------------------------------------------
commit:1a42d85
author:Sean R. Owen
-------------------------------------------------------------------------------
commit:8396a27
/////////////////////////////////////////////////////////////////////////
1:              tag, userID, samples, subset, hamming, bubble, meanRank, normalW, variance);
commit:229aeff
/////////////////////////////////////////////////////////////////////////
1:     for (int rank : ranks) {
1:       sum += rank;
/////////////////////////////////////////////////////////////////////////
1:     for (double rank : ranks) {
1:       if (rank > 0) {
1:         sum += rank;
/////////////////////////////////////////////////////////////////////////
1:     for (double rank : ranks) {
1:       if (rank < 0) {
1:         sum -= rank;
commit:39fe224
/////////////////////////////////////////////////////////////////////////
1:   private OrderBasedRecommenderEvaluator() {
1:   }
1: 
1:   public static void evaluate(Recommender recommender1,
1:                               Recommender recommender2,
1:                               int samples,
1:                               RunningAverage tracker,
1:                               String tag) throws TasteException {
/////////////////////////////////////////////////////////////////////////
1:   public static void evaluate(Recommender recommender,
1:                               DataModel model,
1:                               int samples,
1:                               RunningAverage tracker,
1:                               String tag) throws TasteException {
/////////////////////////////////////////////////////////////////////////
1:   public static void evaluate(DataModel model1,
1:                               DataModel model2,
1:                               int samples,
1:                               RunningAverage tracker,
1:                               String tag) throws TasteException {
/////////////////////////////////////////////////////////////////////////
1:   private static double scoreCommonSubset(String tag,
1:                                           long userID,
1:                                           int samples,
1:                                           int subset,
1:                                           Long[] itemsL,
1:                                           Long[] itemsR) {
/////////////////////////////////////////////////////////////////////////
1:   static double normalWilcoxon(int[] vectorZ, int[] vectorZabs) {
/////////////////////////////////////////////////////////////////////////
1:           rank += j + 1 - zeros;
1:         ranks[i] = (rank / count) * (vectorZ[i] < 0 ? -1 : 1);  // better be at least 1
/////////////////////////////////////////////////////////////////////////
1:   static long sort(Long[] itemsL, Long[] itemsR) {
/////////////////////////////////////////////////////////////////////////
1:             while (j + jump < length && reference[j + jump] == sortable[j + jump]) {
1:           if (j + jump < length && !(reference[j] == sortable[j] && reference[j + jump] == sortable[j + jump])) {
commit:3218e95
/////////////////////////////////////////////////////////////////////////
1:    * can be positive or negative
1:    * the smaller the better - means recommendations are closer
commit:d61a0ee
/////////////////////////////////////////////////////////////////////////
1:       if (itemsR[i] == itemID || itemsR[i - 1] == itemID || itemsR[i + 1] == itemID) {
1:     if (itemsR[samples - 1].equals(itemsL[samples - 1]) || itemsR[samples - 1].equals(itemsL[samples - 2])) {
/////////////////////////////////////////////////////////////////////////
0:           if ((j + jump < length) && !(reference[j] == sortable[j] && reference[j + jump] == sortable[j + jump])) {
commit:5bde30b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.mahout.cf.taste.impl.eval;
1: 
1: import java.util.Arrays;
1: import java.util.List;
1: 
1: import org.apache.mahout.cf.taste.common.TasteException;
1: import org.apache.mahout.cf.taste.impl.common.FastIDSet;
1: import org.apache.mahout.cf.taste.impl.common.LongPrimitiveIterator;
1: import org.apache.mahout.cf.taste.impl.common.RunningAverage;
1: import org.apache.mahout.cf.taste.model.DataModel;
1: import org.apache.mahout.cf.taste.model.PreferenceArray;
1: import org.apache.mahout.cf.taste.recommender.RecommendedItem;
1: import org.apache.mahout.cf.taste.recommender.Recommender;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Evaluate recommender by comparing order of all raw prefs with order in 
1:  * recommender's output for that user. Can also compare data models.
1:  */
1: public final class OrderBasedRecommenderEvaluator {
1: 
1:   private static final Logger log = LoggerFactory.getLogger(OrderBasedRecommenderEvaluator.class);
1: 
0:   public void evaluate(Recommender recommender1,
0:                        Recommender recommender2,
0:                        int samples,
0:                        RunningAverage tracker,
0:                        String tag) throws TasteException {
1:     printHeader();
1:     LongPrimitiveIterator users = recommender1.getDataModel().getUserIDs();
1: 
1:     while (users.hasNext()) {
1:       long userID = users.nextLong();
1:       List<RecommendedItem> recs1 = recommender1.recommend(userID, samples);
1:       List<RecommendedItem> recs2 = recommender2.recommend(userID, samples);
1:       FastIDSet commonSet = new FastIDSet();
1:       long maxItemID = setBits(commonSet, recs1, samples);
1:       FastIDSet otherSet = new FastIDSet();
1:       maxItemID = Math.max(maxItemID, setBits(otherSet, recs2, samples));
1:       int max = mask(commonSet, otherSet, maxItemID);
1:       max = Math.min(max, samples);
1:       if (max < 2) {
1:         continue;
1:       }
1:       Long[] items1 = getCommonItems(commonSet, recs1, max);
1:       Long[] items2 = getCommonItems(commonSet, recs2, max);
1:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:       tracker.addDatum(variance);
1:     }
1:   }
1: 
0:   public void evaluate(Recommender recommender,
0:                        DataModel model,
0:                        int samples,
0:                        RunningAverage tracker,
0:                        String tag) throws TasteException {
1:     printHeader();
1:     LongPrimitiveIterator users = recommender.getDataModel().getUserIDs();
1:     while (users.hasNext()) {
1:       long userID = users.nextLong();
1:       List<RecommendedItem> recs1 = recommender.recommend(userID, model.getNumItems());
1:       PreferenceArray prefs2 = model.getPreferencesFromUser(userID);
1:       prefs2.sortByValueReversed();
1:       FastIDSet commonSet = new FastIDSet();
1:       long maxItemID = setBits(commonSet, recs1, samples);
1:       FastIDSet otherSet = new FastIDSet();
1:       maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));
1:       int max = mask(commonSet, otherSet, maxItemID);
1:       max = Math.min(max, samples);
1:       if (max < 2) {
1:         continue;
1:       }
1:       Long[] items1 = getCommonItems(commonSet, recs1, max);
1:       Long[] items2 = getCommonItems(commonSet, prefs2, max);
1:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:       tracker.addDatum(variance);
1:     }
1:   }
1: 
0:   public void evaluate(DataModel model1,
0:                        DataModel model2,
0:                        int samples,
0:                        RunningAverage tracker,
0:                        String tag) throws TasteException {
1:     printHeader();
1:     LongPrimitiveIterator users = model1.getUserIDs();
1:     while (users.hasNext()) {
1:       long userID = users.nextLong();
1:       PreferenceArray prefs1 = model1.getPreferencesFromUser(userID);
1:       PreferenceArray prefs2 = model2.getPreferencesFromUser(userID);
1:       prefs1.sortByValueReversed();
1:       prefs2.sortByValueReversed();
1:       FastIDSet commonSet = new FastIDSet();
1:       long maxItemID = setBits(commonSet, prefs1, samples);
1:       FastIDSet otherSet = new FastIDSet();
1:       maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));
1:       int max = mask(commonSet, otherSet, maxItemID);
1:       max = Math.min(max, samples);
1:       if (max < 2) {
1:         continue;
1:       }
1:       Long[] items1 = getCommonItems(commonSet, prefs1, max);
1:       Long[] items2 = getCommonItems(commonSet, prefs2, max);
1:       double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);
1:       tracker.addDatum(variance);
1:     }
1:   }
1: 
1:   /**
1:    * This exists because FastIDSet has 'retainAll' as MASK, but there is 
1:    * no count of the number of items in the set. size() is supposed to do 
1:    * this but does not work.
1:    */
1:   private static int mask(FastIDSet commonSet, FastIDSet otherSet, long maxItemID) {
1:     int count = 0;
1:     for (int i = 0; i <= maxItemID; i++) {
1:       if (commonSet.contains(i)) {
1:         if (otherSet.contains(i)) {
1:           count++;
1:         } else {
1:           commonSet.remove(i);
1:         }
1:       }
1:     }
1:     return count;
1:   }
1: 
1:   private static Long[] getCommonItems(FastIDSet commonSet, Iterable<RecommendedItem> recs, int max) {
1:     Long[] commonItems = new Long[max];
1:     int index = 0;
1:     for (RecommendedItem rec : recs) {
1:       Long item = rec.getItemID();
1:       if (commonSet.contains(item)) {
1:         commonItems[index++] = item;
1:       }
1:       if (index == max) {
1:         break;
1:       }
1:     }
1:     return commonItems;
1:   }
1: 
1:   private static Long[] getCommonItems(FastIDSet commonSet, PreferenceArray prefs1, int max) {
1:     Long[] commonItems = new Long[max];
1:     int index = 0;
1:     for (int i = 0; i < prefs1.length(); i++) {
1:       Long item = prefs1.getItemID(i);
1:       if (commonSet.contains(item)) {
1:         commonItems[index++] = item;
1:       }
1:       if (index == max) {
1:         break;
1:       }
1:     }
1:     return commonItems;
1:   }
1: 
1:   private static long setBits(FastIDSet modelSet, List<RecommendedItem> items, int max) {
1:     long maxItem = -1;
1:     for (int i = 0; i < items.size() && i < max; i++) {
1:       long itemID = items.get(i).getItemID();
1:       modelSet.add(itemID);
1:       if (itemID > maxItem) {
1:         maxItem = itemID;
1:       }
1:     }
1:     return maxItem;
1:   }
1: 
1:   private static long setBits(FastIDSet modelSet, PreferenceArray prefs, int max) {
1:     long maxItem = -1;
1:     for (int i = 0; i < prefs.length() && i < max; i++) {
1:       long itemID = prefs.getItemID(i);
1:       modelSet.add(itemID);
1:       if (itemID > maxItem) {
1:         maxItem = itemID;
1:       }
1:     }
1:     return maxItem;
1:   }
1: 
1:   private static void printHeader() {
1:     log.info("tag,user,samples,common,hamming,bubble,rank,normal,score");
1:   }
1: 
1:   /**
1:    * Common Subset Scoring
1:    *
1:    * These measurements are given the set of results that are common to both
1:    * recommendation lists. They only get ordered lists.
1:    *
1:    * These measures all return raw numbers do not correlate among the tests.
1:    * The numbers are not corrected against the total number of samples or the
1:    * number of common items.
1:    * The one contract is that all measures are 0 for an exact match and an
1:    * increasing positive number as differences increase.
1:    */
0:   private double scoreCommonSubset(String tag,
0:                                    long userID,
0:                                    int samples,
0:                                    int subset,
0:                                    Long[] itemsL,
0:                                    Long[] itemsR) {
1:     int[] vectorZ = new int[subset];
1:     int[] vectorZabs = new int[subset];
1: 
1:     long bubble = sort(itemsL, itemsR);
1:     int hamming = slidingWindowHamming(itemsR, itemsL);
1:     if (hamming > samples) {
1:       throw new IllegalStateException();
1:     }
1:     getVectorZ(itemsR, itemsL, vectorZ, vectorZabs);
1:     double normalW = normalWilcoxon(vectorZ, vectorZabs);
1:     double meanRank = getMeanRank(vectorZabs);
1:     // case statement for requested value
1:     double variance = Math.sqrt(meanRank);
1:     log.info("{},{},{},{},{},{},{},{},{}",
0:              new Object[] {tag, userID, samples, subset, hamming, bubble, meanRank, normalW, variance});
1:     return variance;
1:   }
1: 
1:   // simple sliding-window hamming distance: a[i or plus/minus 1] == b[i]
1:   private static int slidingWindowHamming(Long[] itemsR, Long[] itemsL) {
1:     int count = 0;
1:     int samples = itemsR.length;
1: 
1:     if (itemsR[0].equals(itemsL[0]) || itemsR[0].equals(itemsL[1])) {
1:       count++;
1:     }
1:     for (int i = 1; i < samples - 1; i++) {
1:       long itemID = itemsL[i];
0:       if ((itemsR[i] == itemID) ||
0:           (itemsR[i - 1] == itemID) ||
0:           (itemsR[i + 1] == itemID)) {
1:         count++;
1:       }
1:     }
0:     if (itemsR[samples - 1].equals(itemsL[samples - 1]) ||
0:         itemsR[samples - 1].equals(itemsL[samples - 2])) {
1:       count++;
1:     }
1:     return count;
1:   }
1: 
1:   /**
1:    * Normal-distribution probability value for matched sets of values.
1:    * Based upon:
1:    * http://comp9.psych.cornell.edu/Darlington/normscor.htm
1:    * 
1:    * The Standard Wilcoxon is not used because it requires a lookup table.
1:    */
0:   double normalWilcoxon(int[] vectorZ, int[] vectorZabs) {
1:     int nitems = vectorZ.length;
1: 
1:     double[] ranks = new double[nitems];
1:     double[] ranksAbs = new double[nitems];
1:     wilcoxonRanks(vectorZ, vectorZabs, ranks, ranksAbs);
1:     return Math.min(getMeanWplus(ranks), getMeanWminus(ranks));
1:   }
1: 
1:   /**
1:    * vector Z is a list of distances between the correct value and the recommended value
1:    * Z[i] = position i of correct itemID - position of correct itemID in recommendation list
0:    * 	can be positive or negative
0:    * 	the smaller the better - means recommendations are closer
1:    * both are the same length, and both sample from the same set
1:    * 
1:    * destructive to items arrays - allows N log N instead of N^2 order
1:    */
1:   private static void getVectorZ(Long[] itemsR, Long[] itemsL, int[] vectorZ, int[] vectorZabs) {
1:     int nitems = itemsR.length;
1:     int bottom = 0;
1:     int top = nitems - 1;
1:     for (int i = 0; i < nitems; i++) {
1:       long itemID = itemsR[i];
1:       for (int j = bottom; j <= top; j++) {
1:         if (itemsL[j] == null) {
1:           continue;
1:         }
1:         long test = itemsL[j];
1:         if (itemID == test) {
1:           vectorZ[i] = i - j;
1:           vectorZabs[i] = Math.abs(i - j);
1:           if (j == bottom) {
1:             bottom++;
1:           } else if (j == top) {
1:             top--;
1:           } else {
1:             itemsL[j] = null;
1:           }
1:           break;
1:         }
1:       }
1:     }
1:   }
1: 
1:   /**
1:    * Ranks are the position of the value from low to high, divided by the # of values.
1:    * I had to walk through it a few times.
1:    */
1:   private static void wilcoxonRanks(int[] vectorZ, int[] vectorZabs, double[] ranks, double[] ranksAbs) {
1:     int nitems = vectorZ.length;
1:     int[] sorted = vectorZabs.clone();
1:     Arrays.sort(sorted);
1:     int zeros = 0;
1:     for (; zeros < nitems; zeros++) {
1:       if (sorted[zeros] > 0) {
1:         break;
1:       }
1:     }
1:     for (int i = 0; i < nitems; i++) {
1:       double rank = 0.0;
1:       int count = 0;
1:       int score = vectorZabs[i];
1:       for (int j = 0; j < nitems; j++) {
1:         if (score == sorted[j]) {
0:           rank += (j + 1) - zeros;
1:           count++;
1:         } else if (score < sorted[j]) {
1:           break;
1:         }
1:       }
1:       if (vectorZ[i] != 0) {
0:         ranks[i] = (rank / count) * ((vectorZ[i] < 0) ? -1 : 1);  // better be at least 1
1:         ranksAbs[i] = Math.abs(ranks[i]);
1:       }
1:     }
1:   }
1: 
1:   private static double getMeanRank(int[] ranks) {
1:     int nitems = ranks.length;
1:     double sum = 0.0;
1:     for (int i = 0; i < nitems; i++) {
0:       sum += ranks[i];
1:     }
1:     return sum / nitems;
1:   }
1: 
1:   private static double getMeanWplus(double[] ranks) {
1:     int nitems = ranks.length;
1:     double sum = 0.0;
1:     for (int i = 0; i < nitems; i++) {
0:       if (ranks[i] > 0) {
0:         sum += ranks[i];
1:       }
1:     }
1:     return sum / nitems;
1:   }
1: 
1:   private static double getMeanWminus(double[] ranks) {
1:     int nitems = ranks.length;
1:     double sum = 0.0;
1:     for (int i = 0; i < nitems; i++) {
0:       if (ranks[i] < 0) {
0:         sum -= ranks[i];
1:       }
1:     }
1:     return sum / nitems;
1:   }
1: 
1:   /**
1:    * Do bubble sort and return number of swaps needed to match preference lists.
1:    * Sort itemsR using itemsL as the reference order.
1:    */
0:   long sort(Long[] itemsL, Long[] itemsR) {
1:     int length = itemsL.length;
1:     if (length < 2) {
1:       return 0;
1:     }
1:     if (length == 2) {
1:       return itemsL[0].longValue() == itemsR[0].longValue() ? 0 : 1;
1:     }
1:     // 1) avoid changing originals; 2) primitive type is more efficient
1:     long[] reference = new long[length];
1:     long[] sortable = new long[length];
1:     for (int i = 0; i < length; i++) {
1:       reference[i] = itemsL[i];
1:       sortable[i] = itemsR[i];
1:     }
1:     int sorted = 0;
1:     long swaps = 0;
1:     while (sorted < length - 1) {
1:       // opportunistically trim back the top
1:       while (length > 0 && reference[length - 1] == sortable[length - 1]) {
1:         length--;
1:       }
1:       if (length == 0) {
1:         break;
1:       }
1:       if (reference[sorted] == sortable[sorted]) {
1:         sorted++;
1:       } else {
1:         for (int j = sorted; j < length - 1; j++) {
1:           // do not swap anything already in place
1:           int jump = 1;
1:           if (reference[j] == sortable[j]) {
0:             while ((j + jump < length) && reference[j + jump] == sortable[j + jump]) {
1:               jump++;
1:             }
1:           }
0:           if ((j + jump < length) &&
0:               !(reference[j] == sortable[j] && reference[j + jump] == sortable[j + jump])) {
1:             long tmp = sortable[j];
1:             sortable[j] = sortable[j + 1];
1:             sortable[j + 1] = tmp;
1:             swaps++;
1:           }
1:         }
1:       }
1:     }
1:     return swaps;
1:   }
1: 
1: }
============================================================================