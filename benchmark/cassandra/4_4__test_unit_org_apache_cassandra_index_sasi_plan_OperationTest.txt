1:72790dc: /*
1:72790dc:  * Licensed to the Apache Software Foundation (ASF) under one
1:72790dc:  * or more contributor license agreements.  See the NOTICE file
1:72790dc:  * distributed with this work for additional information
1:72790dc:  * regarding copyright ownership.  The ASF licenses this file
1:72790dc:  * to you under the Apache License, Version 2.0 (the
1:72790dc:  * "License"); you may not use this file except in compliance
1:72790dc:  * with the License.  You may obtain a copy of the License at
1:72790dc:  *
1:72790dc:  *     http://www.apache.org/licenses/LICENSE-2.0
1:72790dc:  *
1:72790dc:  * Unless required by applicable law or agreed to in writing, software
1:72790dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72790dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72790dc:  * See the License for the specific language governing permissions and
1:72790dc:  * limitations under the License.
1:72790dc:  */
1:72790dc: package org.apache.cassandra.index.sasi.plan;
1:72790dc: 
1:72790dc: import java.nio.ByteBuffer;
1:72790dc: import java.util.*;
1:72790dc: import java.util.concurrent.TimeUnit;
1:72790dc: 
1:72790dc: import com.google.common.collect.ListMultimap;
1:72790dc: import com.google.common.collect.Multimap;
1:72790dc: import com.google.common.collect.Sets;
1:72790dc: import org.apache.cassandra.SchemaLoader;
1:72790dc: import org.apache.cassandra.config.CFMetaData;
1:72790dc: import org.apache.cassandra.config.ColumnDefinition;
1:72790dc: import org.apache.cassandra.cql3.Operator;
1:72790dc: import org.apache.cassandra.db.*;
1:72790dc: import org.apache.cassandra.db.filter.RowFilter;
1:72790dc: import org.apache.cassandra.db.marshal.DoubleType;
1:72790dc: import org.apache.cassandra.db.rows.*;
1:72790dc: import org.apache.cassandra.index.sasi.plan.Operation.OperationType;
1:72790dc: import org.apache.cassandra.db.marshal.Int32Type;
1:72790dc: import org.apache.cassandra.db.marshal.LongType;
1:72790dc: import org.apache.cassandra.db.marshal.UTF8Type;
1:72790dc: import org.apache.cassandra.exceptions.ConfigurationException;
1:72790dc: import org.apache.cassandra.schema.KeyspaceMetadata;
1:72790dc: import org.apache.cassandra.schema.KeyspaceParams;
1:72790dc: import org.apache.cassandra.schema.Tables;
1:72790dc: import org.apache.cassandra.service.MigrationManager;
1:72790dc: import org.apache.cassandra.utils.FBUtilities;
1:72790dc: 
1:72790dc: import org.junit.*;
1:72790dc: 
1:72790dc: public class OperationTest extends SchemaLoader
1:72790dc: {
1:7d857b4:     private static final String KS_NAME = "operation_test";
1:72790dc:     private static final String CF_NAME = "test_cf";
1:72790dc:     private static final String CLUSTERING_CF_NAME = "clustering_test_cf";
1:b7d1d44:     private static final String STATIC_CF_NAME = "static_sasi_test_cf";
1:72790dc: 
1:72790dc:     private static ColumnFamilyStore BACKEND;
1:72790dc:     private static ColumnFamilyStore CLUSTERING_BACKEND;
1:b7d1d44:     private static ColumnFamilyStore STATIC_BACKEND;
1:72790dc: 
1:72790dc:     @BeforeClass
1:72790dc:     public static void loadSchema() throws ConfigurationException
1:72790dc:     {
1:72790dc:         System.setProperty("cassandra.config", "cassandra-murmur.yaml");
1:72790dc:         SchemaLoader.loadSchema();
1:72790dc:         MigrationManager.announceNewKeyspace(KeyspaceMetadata.create(KS_NAME,
1:72790dc:                                                                      KeyspaceParams.simpleTransient(1),
1:72790dc:                                                                      Tables.of(SchemaLoader.sasiCFMD(KS_NAME, CF_NAME),
1:b7d1d44:                                                                                SchemaLoader.clusteringSASICFMD(KS_NAME, CLUSTERING_CF_NAME),
1:b7d1d44:                                                                                SchemaLoader.staticSASICFMD(KS_NAME, STATIC_CF_NAME))));
1:72790dc: 
1:72790dc:         BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);
1:72790dc:         CLUSTERING_BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(CLUSTERING_CF_NAME);
1:b7d1d44:         STATIC_BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(STATIC_CF_NAME);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private QueryController controller;
1:72790dc: 
1:72790dc:     @Before
1:72790dc:     public void beforeTest()
1:72790dc:     {
1:72790dc:         controller = new QueryController(BACKEND,
1:72790dc:                                          PartitionRangeReadCommand.allDataRead(BACKEND.metadata, FBUtilities.nowInSeconds()),
1:72790dc:                                          TimeUnit.SECONDS.toMillis(10));
1:72790dc:     }
1:72790dc: 
1:72790dc:     @After
1:72790dc:     public void afterTest()
1:72790dc:     {
1:72790dc:         controller.finish();
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testAnalyze() throws Exception
1:72790dc:     {
1:72790dc:         final ColumnDefinition firstName = getColumn(UTF8Type.instance.decompose("first_name"));
1:72790dc:         final ColumnDefinition age = getColumn(UTF8Type.instance.decompose("age"));
1:72790dc:         final ColumnDefinition comment = getColumn(UTF8Type.instance.decompose("comment"));
1:72790dc: 
1:72790dc:         // age != 5 AND age > 1 AND age != 6 AND age <= 10
1:72790dc:         Map<Expression.Op, Expression> expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:72790dc:                                                                                 Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:72790dc:                                                                                               new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:72790dc:                                                                                               new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(6)),
1:72790dc:                                                                                               new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(10)))));
1:72790dc: 
1:72790dc:         Expression expected = new Expression("age", Int32Type.instance)
1:72790dc:         {{
1:72790dc:             operation = Op.RANGE;
1:72790dc:             lower = new Bound(Int32Type.instance.decompose(1), false);
1:72790dc:             upper = new Bound(Int32Type.instance.decompose(10), true);
1:72790dc: 
1:72790dc:             exclusions.add(Int32Type.instance.decompose(5));
1:72790dc:             exclusions.add(Int32Type.instance.decompose(6));
1:72790dc:         }};
1:72790dc: 
1:72790dc:         Assert.assertEquals(1, expressions.size());
1:72790dc:         Assert.assertEquals(expected, expressions.get(Expression.Op.RANGE));
1:72790dc: 
1:72790dc:         // age != 5 OR age >= 7
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:72790dc:                                                     Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:72790dc:                                                                   new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(7)))));
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.NOT_EQ;
1:72790dc:                                     lower = new Bound(Int32Type.instance.decompose(5), true);
1:72790dc:                                     upper = lower;
1:72790dc:                             }}, expressions.get(Expression.Op.NOT_EQ));
1:72790dc: 
1:72790dc:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.RANGE;
1:72790dc:                                     lower = new Bound(Int32Type.instance.decompose(7), true);
1:72790dc:                             }}, expressions.get(Expression.Op.RANGE));
1:72790dc: 
1:72790dc:         // age != 5 OR age < 7
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:72790dc:                                                     Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:72790dc:                                                                   new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(7)))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.RANGE;
1:72790dc:                                     upper = new Bound(Int32Type.instance.decompose(7), false);
1:72790dc:                             }}, expressions.get(Expression.Op.RANGE));
1:72790dc:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.NOT_EQ;
1:72790dc:                                     lower = new Bound(Int32Type.instance.decompose(5), true);
1:72790dc:                                     upper = lower;
1:72790dc:                             }}, expressions.get(Expression.Op.NOT_EQ));
1:72790dc: 
1:72790dc:         // age > 1 AND age < 7
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:72790dc:                                                     Arrays.asList(new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:72790dc:                                                                   new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(7)))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(1, expressions.size());
1:72790dc:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.RANGE;
1:72790dc:                                     lower = new Bound(Int32Type.instance.decompose(1), false);
1:72790dc:                                     upper = new Bound(Int32Type.instance.decompose(7), false);
1:72790dc:                             }}, expressions.get(Expression.Op.RANGE));
1:72790dc: 
1:72790dc:         // first_name = 'a' OR first_name != 'b'
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:72790dc:                                                     Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:72790dc:                                                                   new SimpleExpression(firstName, Operator.NEQ, UTF8Type.instance.decompose("b")))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc:         Assert.assertEquals(new Expression("first_name", UTF8Type.instance)
1:72790dc:                             {{
1:72790dc:                                     operation = Op.NOT_EQ;
1:72790dc:                                     lower = new Bound(UTF8Type.instance.decompose("b"), true);
1:72790dc:                                     upper = lower;
1:72790dc:                             }}, expressions.get(Expression.Op.NOT_EQ));
1:72790dc:         Assert.assertEquals(new Expression("first_name", UTF8Type.instance)
1:72790dc:                             {{
3:72790dc:                                     operation = Op.EQ;
1:72790dc:                                     lower = upper = new Bound(UTF8Type.instance.decompose("a"), true);
1:72790dc:                             }}, expressions.get(Expression.Op.EQ));
1:72790dc: 
1:72790dc:         // comment = 'soft eng' and comment != 'likes do'
1:72790dc:         ListMultimap<ColumnDefinition, Expression> e = Operation.analyzeGroup(controller, OperationType.OR,
1:479e8af:                                                     Arrays.asList(new SimpleExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose("soft eng")),
1:72790dc:                                                                   new SimpleExpression(comment, Operator.NEQ, UTF8Type.instance.decompose("likes do"))));
1:72790dc: 
1:72790dc:         List<Expression> expectedExpressions = new ArrayList<Expression>(2)
1:72790dc:         {{
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:479e8af:                         operation = Op.MATCH;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("soft"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc: 
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:479e8af:                         operation = Op.MATCH;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("eng"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc: 
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("likes"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc: 
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("do"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc:         }};
1:72790dc: 
1:72790dc:         Assert.assertEquals(expectedExpressions, e.get(comment));
1:72790dc: 
1:72790dc:         // first_name = 'j' and comment != 'likes do'
1:72790dc:         e = Operation.analyzeGroup(controller, OperationType.OR,
1:72790dc:                         Arrays.asList(new SimpleExpression(comment, Operator.NEQ, UTF8Type.instance.decompose("likes do")),
1:72790dc:                                       new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("j"))));
1:72790dc: 
1:72790dc:         expectedExpressions = new ArrayList<Expression>(2)
1:72790dc:         {{
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("likes"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc: 
1:72790dc:                 add(new Expression("comment", UTF8Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(UTF8Type.instance.decompose("do"), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc:         }};
1:72790dc: 
1:72790dc:         Assert.assertEquals(expectedExpressions, e.get(comment));
1:72790dc: 
1:72790dc:         // age != 27 first_name = 'j' and age != 25
1:72790dc:         e = Operation.analyzeGroup(controller, OperationType.OR,
1:72790dc:                         Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(27)),
1:72790dc:                                       new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("j")),
1:72790dc:                                       new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(25))));
1:72790dc: 
1:72790dc:         expectedExpressions = new ArrayList<Expression>(2)
1:72790dc:         {{
1:72790dc:                 add(new Expression("age", Int32Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(Int32Type.instance.decompose(27), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc: 
1:72790dc:                 add(new Expression("age", Int32Type.instance)
1:72790dc:                 {{
1:72790dc:                         operation = Op.NOT_EQ;
1:72790dc:                         lower = new Bound(Int32Type.instance.decompose(25), true);
1:72790dc:                         upper = lower;
1:72790dc:                 }});
1:72790dc:         }};
1:72790dc: 
1:72790dc:         Assert.assertEquals(expectedExpressions, e.get(age));
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSatisfiedBy() throws Exception
1:72790dc:     {
1:72790dc:         final ColumnDefinition timestamp = getColumn(UTF8Type.instance.decompose("timestamp"));
1:72790dc:         final ColumnDefinition age = getColumn(UTF8Type.instance.decompose("age"));
1:72790dc: 
1:72790dc:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller, new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)));
1:72790dc:         Operation op = builder.complete();
1:72790dc: 
1:72790dc:         Unfiltered row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1:b7d1d44:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()));
1:72790dc: 
1:72790dc:         // and reject incorrect value
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         // range with exclusions - age != 5 AND age > 1 AND age != 6 AND age <= 10
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller,
1:72790dc:                                         new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:72790dc:                                         new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:72790dc:                                         new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(6)),
1:72790dc:                                         new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(10)));
1:72790dc:         op = builder.complete();
1:72790dc: 
1:72790dc:         Set<Integer> exclusions = Sets.newHashSet(0, 1, 5, 6, 11);
1:72790dc:         for (int i = 0; i <= 11; i++)
1:72790dc:         {
1:72790dc:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:             boolean result = op.satisfiedBy(row, staticRow, false);
1:72790dc:             Assert.assertTrue(exclusions.contains(i) != result);
1:72790dc:         }
1:72790dc: 
1:72790dc:         // now let's do something more complex - age = 5 OR age = 6
1:72790dc:         builder = new Operation.Builder(OperationType.OR, controller,
1:72790dc:                                         new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(5)),
1:72790dc:                                         new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(6)));
1:72790dc: 
1:72790dc:         op = builder.complete();
1:72790dc: 
1:72790dc:         exclusions = Sets.newHashSet(0, 1, 2, 3, 4, 7, 8, 9, 10);
1:72790dc:         for (int i = 0; i <= 10; i++)
1:72790dc:         {
1:72790dc:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:             boolean result = op.satisfiedBy(row, staticRow, false);
1:72790dc:             Assert.assertTrue(exclusions.contains(i) != result);
1:72790dc:         }
1:72790dc: 
1:72790dc:         // now let's test aggregated AND commands
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc: 
1:72790dc:         // logical should be ignored by analyzer, but we still what to make sure that it is
1:72790dc:         //IndexExpression logical = new IndexExpression(ByteBufferUtil.EMPTY_BYTE_BUFFER, IndexOperator.EQ, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:72790dc:         //logical.setLogicalOp(LogicalIndexOperator.AND);
1:72790dc: 
1:72790dc:         //builder.add(logical);
1:72790dc:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(0)));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(10)));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(7)));
1:72790dc: 
1:72790dc:         op = builder.complete();
1:72790dc: 
1:72790dc:         exclusions = Sets.newHashSet(7);
1:72790dc:         for (int i = 0; i < 10; i++)
1:72790dc:         {
1:72790dc:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:             boolean result = op.satisfiedBy(row, staticRow, false);
1:72790dc:             Assert.assertTrue(exclusions.contains(i) != result);
1:72790dc:         }
1:72790dc: 
1:72790dc:         // multiple analyzed expressions in the Operation timestamp >= 10 AND age = 5
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(timestamp, Operator.GTE, LongType.instance.decompose(10L)));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(5)));
1:72790dc: 
1:72790dc:         op = builder.complete();
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(11L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(22L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         // operation with internal expressions and right child
1:72790dc:         builder = new Operation.Builder(OperationType.OR, controller,
1:72790dc:                                         new SimpleExpression(timestamp, Operator.GT, LongType.instance.decompose(10L)));
1:72790dc:         builder.setRight(new Operation.Builder(OperationType.AND, controller,
1:72790dc:                                                new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(0)),
1:72790dc:                                                new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(10))));
1:72790dc:         op = builder.complete();
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(20), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(11L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(buildCell(age, Int32Type.instance.decompose(0), System.currentTimeMillis()),
1:72790dc:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         // and for desert let's try out null and deleted rows etc.
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(30)));
1:72790dc:         op = builder.complete();
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(null, staticRow, false));
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, null, false));
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         long now = System.currentTimeMillis();
1:72790dc: 
1:72790dc:         row = OperationTest.buildRow(
1:72790dc:                 Row.Deletion.regular(new DeletionTime(now - 10, (int) (now / 1000))),
1:72790dc:                           buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         row = buildRow(deletedCell(age, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, true));
1:72790dc: 
1:72790dc:         try
1:72790dc:         {
1:b7d1d44:             Assert.assertFalse(op.satisfiedBy(buildRow(), staticRow, false));
1:72790dc:         }
1:72790dc:         catch (IllegalStateException e)
1:72790dc:         {
1:72790dc:             // expected
1:72790dc:         }
1:72790dc: 
1:72790dc:         try
1:72790dc:         {
1:b7d1d44:             Assert.assertFalse(op.satisfiedBy(buildRow(), staticRow, true));
1:72790dc:         }
1:72790dc:         catch (IllegalStateException e)
1:72790dc:         {
1:72790dc:             Assert.fail("IllegalStateException should not be thrown when missing column and allowMissingColumns=true");
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testAnalyzeNotIndexedButDefinedColumn() throws Exception
1:72790dc:     {
1:72790dc:         final ColumnDefinition firstName = getColumn(UTF8Type.instance.decompose("first_name"));
1:72790dc:         final ColumnDefinition height = getColumn(UTF8Type.instance.decompose("height"));
1:72790dc: 
1:72790dc:         // first_name = 'a' AND height != 10
1:72790dc:         Map<Expression.Op, Expression> expressions;
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:72790dc:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:72790dc:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:72790dc:         {{
1:72790dc:                 operation = Op.NOT_EQ;
1:72790dc:                 lower = new Bound(Int32Type.instance.decompose(5), true);
1:72790dc:                 upper = lower;
1:72790dc:         }}, expressions.get(Expression.Op.NOT_EQ));
1:72790dc: 
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:72790dc:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:72790dc:                               new SimpleExpression(height, Operator.GT, Int32Type.instance.decompose(0)),
1:72790dc:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:72790dc:         {{
1:72790dc:             operation = Op.RANGE;
1:72790dc:             lower = new Bound(Int32Type.instance.decompose(0), false);
1:72790dc:             exclusions.add(Int32Type.instance.decompose(5));
1:72790dc:         }}, expressions.get(Expression.Op.RANGE));
1:72790dc: 
1:72790dc:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:72790dc:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:72790dc:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)),
1:72790dc:                               new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(0)),
1:72790dc:                               new SimpleExpression(height, Operator.LT, Int32Type.instance.decompose(10)))));
1:72790dc: 
1:72790dc:         Assert.assertEquals(2, expressions.size());
1:72790dc: 
1:72790dc:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:72790dc:         {{
1:72790dc:                 operation = Op.RANGE;
1:72790dc:                 lower = new Bound(Int32Type.instance.decompose(0), true);
1:72790dc:                 upper = new Bound(Int32Type.instance.decompose(10), false);
1:72790dc:                 exclusions.add(Int32Type.instance.decompose(5));
1:72790dc:         }}, expressions.get(Expression.Op.RANGE));
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSatisfiedByWithMultipleTerms()
1:72790dc:     {
1:72790dc:         final ColumnDefinition comment = getColumn(UTF8Type.instance.decompose("comment"));
1:72790dc: 
1:b7d1d44:         Unfiltered row = buildRow(buildCell(comment,UTF8Type.instance.decompose("software engineer is working on a project"),System.currentTimeMillis()));
1:b7d1d44:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:72790dc: 
1:72790dc:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller,
1:3928665:                                             new SimpleExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("eng is a work")));
1:72790dc:         Operation op = builder.complete();
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller,
1:3928665:                                             new SimpleExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("soft works fine")));
1:72790dc:         op = builder.complete();
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:72790dc:     }
1:72790dc: 
1:72790dc:     @Test
1:72790dc:     public void testSatisfiedByWithClustering()
1:72790dc:     {
1:72790dc:         ColumnDefinition location = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("location"));
1:72790dc:         ColumnDefinition age = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("age"));
1:72790dc:         ColumnDefinition height = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("height"));
1:72790dc:         ColumnDefinition score = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("score"));
1:72790dc: 
1:670b6c6:         Unfiltered row = buildRow(Clustering.make(UTF8Type.instance.fromString("US"), Int32Type.instance.decompose(27)),
1:72790dc:                                   buildCell(height, Int32Type.instance.decompose(182), System.currentTimeMillis()),
1:72790dc:                                   buildCell(score, DoubleType.instance.decompose(1.0d), System.currentTimeMillis()));
1:b7d1d44:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:72790dc: 
1:72790dc:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(27)));
1:72790dc:         builder.add(new SimpleExpression(height, Operator.EQ, Int32Type.instance.decompose(182)));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc: 
1:72790dc:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(28)));
1:72790dc:         builder.add(new SimpleExpression(height, Operator.EQ, Int32Type.instance.decompose(182)));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(27)));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("BY")));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(28)));
1:72790dc: 
1:b7d1d44:         Assert.assertFalse(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:72790dc:         builder.add(new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(27)));
1:72790dc:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:72790dc:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1:72790dc:         builder.add(new SimpleExpression(score, Operator.EQ, DoubleType.instance.decompose(1.0d)));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc: 
1:72790dc:         builder = new Operation.Builder(OperationType.AND, controller);
1:72790dc:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1:72790dc:         builder.add(new SimpleExpression(score, Operator.EQ, DoubleType.instance.decompose(1.0d)));
1:72790dc: 
1:b7d1d44:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:72790dc:     }
1:72790dc: 
1:72790dc:     private Map<Expression.Op, Expression> convert(Multimap<ColumnDefinition, Expression> expressions)
1:72790dc:     {
1:72790dc:         Map<Expression.Op, Expression> converted = new HashMap<>();
1:72790dc:         for (Expression expression : expressions.values())
1:72790dc:         {
1:72790dc:             Expression column = converted.get(expression.getOp());
1:72790dc:             assert column == null; // sanity check
1:72790dc:             converted.put(expression.getOp(), expression);
1:72790dc:         }
1:72790dc: 
1:72790dc:         return converted;
1:72790dc:     }
1:72790dc: 
1:b7d1d44:     @Test
1:b7d1d44:     public void testSatisfiedByWithStatic()
1:b7d1d44:     {
1:b7d1d44:         final ColumnDefinition sensorType = getColumn(STATIC_BACKEND, UTF8Type.instance.decompose("sensor_type"));
1:b7d1d44:         final ColumnDefinition value = getColumn(STATIC_BACKEND, UTF8Type.instance.decompose("value"));
1:b7d1d44: 
1:b7d1d44:         Unfiltered row = buildRow(Clustering.make(UTF8Type.instance.fromString("date"), LongType.instance.decompose(20160401L)),
1:b7d1d44:                           buildCell(value, DoubleType.instance.decompose(24.56), System.currentTimeMillis()));
1:b7d1d44:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING,
1:b7d1d44:                          buildCell(sensorType, UTF8Type.instance.decompose("TEMPERATURE"), System.currentTimeMillis()));
1:b7d1d44: 
1:b7d1d44:         // sensor_type ='TEMPERATURE' AND value = 24.56
1:b7d1d44:         Operation op = new Operation.Builder(OperationType.AND, controller,
1:b7d1d44:                                         new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:b7d1d44:                                         new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:b7d1d44: 
1:b7d1d44:         // sensor_type ='TEMPERATURE' AND value = 30
1:b7d1d44:         op = new Operation.Builder(OperationType.AND, controller,
1:b7d1d44:                                              new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:b7d1d44:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(30.00))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:b7d1d44: 
1:b7d1d44:         // sensor_type ='PRESSURE' OR value = 24.56
1:b7d1d44:         op = new Operation.Builder(OperationType.OR, controller,
1:b7d1d44:                                              new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:b7d1d44:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:b7d1d44: 
1:b7d1d44:         // sensor_type ='PRESSURE' OR value = 30
1:b7d1d44:         op = new Operation.Builder(OperationType.AND, controller,
1:b7d1d44:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("PRESSURE")),
1:b7d1d44:                                    new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(30.00))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:b7d1d44: 
1:b7d1d44:         // (sensor_type = 'TEMPERATURE' OR sensor_type = 'PRESSURE') AND value = 24.56
1:b7d1d44:         op = new Operation.Builder(OperationType.OR, controller,
1:b7d1d44:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:b7d1d44:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("PRESSURE")))
1:b7d1d44:              .setRight(new Operation.Builder(OperationType.AND, controller,
1:b7d1d44:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56)))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:b7d1d44: 
1:b7d1d44:         // sensor_type = LIKE 'TEMP%'  AND value = 24.56
1:b7d1d44:         op = new Operation.Builder(OperationType.AND, controller,
1:b7d1d44:                                    new SimpleExpression(sensorType, Operator.LIKE_PREFIX, UTF8Type.instance.decompose("TEMP")),
1:b7d1d44:                                    new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1:b7d1d44: 
1:b7d1d44:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:b7d1d44:     }
1:b7d1d44: 
1:72790dc:     private static class SimpleExpression extends RowFilter.Expression
1:72790dc:     {
1:bdae452:         SimpleExpression(ColumnDefinition column, Operator operator, ByteBuffer value)
1:72790dc:         {
1:72790dc:             super(column, operator, value);
1:72790dc:         }
1:72790dc: 
1:72790dc:         @Override
1:72790dc:         protected Kind kind()
1:72790dc:         {
1:72790dc:             return Kind.SIMPLE;
1:72790dc:         }
1:72790dc: 
1:72790dc:         @Override
1:72790dc:         public boolean isSatisfiedBy(CFMetaData metadata, DecoratedKey partitionKey, Row row)
1:72790dc:         {
1:72790dc:             throw new UnsupportedOperationException();
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Unfiltered buildRow(Cell... cells)
1:72790dc:     {
1:72790dc:         return buildRow(Clustering.EMPTY, null, cells);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Row buildRow(Row.Deletion deletion, Cell... cells)
1:72790dc:     {
1:72790dc:         return buildRow(Clustering.EMPTY, deletion, cells);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Row buildRow(Clustering clustering, Cell... cells)
1:72790dc:     {
1:72790dc:         return buildRow(clustering, null, cells);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Row buildRow(Clustering clustering, Row.Deletion deletion, Cell... cells)
1:72790dc:     {
1:72790dc:         Row.Builder rowBuilder = BTreeRow.sortedBuilder();
1:72790dc:         rowBuilder.newRow(clustering);
1:72790dc:         for (Cell c : cells)
1:72790dc:             rowBuilder.addCell(c);
1:72790dc: 
1:72790dc:         if (deletion != null)
1:72790dc:             rowBuilder.addRowDeletion(deletion);
1:72790dc: 
1:72790dc:         return rowBuilder.build();
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Cell buildCell(ColumnDefinition column, ByteBuffer value, long timestamp)
1:72790dc:     {
1:e017f94:         return BufferCell.live(column, timestamp, value);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static Cell deletedCell(ColumnDefinition column, long timestamp, int nowInSeconds)
1:72790dc:     {
1:72790dc:         return BufferCell.tombstone(column, timestamp, nowInSeconds);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static ColumnDefinition getColumn(ByteBuffer name)
1:72790dc:     {
1:72790dc:         return getColumn(BACKEND, name);
1:72790dc:     }
1:72790dc: 
1:72790dc:     private static ColumnDefinition getColumn(ColumnFamilyStore cfs, ByteBuffer name)
1:72790dc:     {
1:72790dc:         return cfs.metadata.getColumnDefinition(name);
1:72790dc:     }
1:72790dc: }
============================================================================
author:Alex Petrov
-------------------------------------------------------------------------------
commit:7d857b4
/////////////////////////////////////////////////////////////////////////
1:     private static final String KS_NAME = "operation_test";
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:b7d1d44
/////////////////////////////////////////////////////////////////////////
1:     private static final String STATIC_CF_NAME = "static_sasi_test_cf";
1:     private static ColumnFamilyStore STATIC_BACKEND;
/////////////////////////////////////////////////////////////////////////
1:                                                                                SchemaLoader.clusteringSASICFMD(KS_NAME, CLUSTERING_CF_NAME),
1:                                                                                SchemaLoader.staticSASICFMD(KS_NAME, STATIC_CF_NAME))));
1:         STATIC_BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(STATIC_CF_NAME);
/////////////////////////////////////////////////////////////////////////
1:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:             boolean result = op.satisfiedBy(row, staticRow, false);
/////////////////////////////////////////////////////////////////////////
1:             boolean result = op.satisfiedBy(row, staticRow, false);
/////////////////////////////////////////////////////////////////////////
1:             boolean result = op.satisfiedBy(row, staticRow, false);
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(null, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(row, null, false));
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, true));
1:             Assert.assertFalse(op.satisfiedBy(buildRow(), staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:             Assert.assertFalse(op.satisfiedBy(buildRow(), staticRow, true));
/////////////////////////////////////////////////////////////////////////
1:         Unfiltered row = buildRow(buildCell(comment,UTF8Type.instance.decompose("software engineer is working on a project"),System.currentTimeMillis()));
1:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING);
1:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertFalse(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
1:         Assert.assertTrue(builder.complete().satisfiedBy(row, staticRow, false));
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testSatisfiedByWithStatic()
1:     {
1:         final ColumnDefinition sensorType = getColumn(STATIC_BACKEND, UTF8Type.instance.decompose("sensor_type"));
1:         final ColumnDefinition value = getColumn(STATIC_BACKEND, UTF8Type.instance.decompose("value"));
1: 
1:         Unfiltered row = buildRow(Clustering.make(UTF8Type.instance.fromString("date"), LongType.instance.decompose(20160401L)),
1:                           buildCell(value, DoubleType.instance.decompose(24.56), System.currentTimeMillis()));
1:         Row staticRow = buildRow(Clustering.STATIC_CLUSTERING,
1:                          buildCell(sensorType, UTF8Type.instance.decompose("TEMPERATURE"), System.currentTimeMillis()));
1: 
1:         // sensor_type ='TEMPERATURE' AND value = 24.56
1:         Operation op = new Operation.Builder(OperationType.AND, controller,
1:                                         new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:                                         new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1: 
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1: 
1:         // sensor_type ='TEMPERATURE' AND value = 30
1:         op = new Operation.Builder(OperationType.AND, controller,
1:                                              new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(30.00))).complete();
1: 
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1: 
1:         // sensor_type ='PRESSURE' OR value = 24.56
1:         op = new Operation.Builder(OperationType.OR, controller,
1:                                              new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1: 
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1: 
1:         // sensor_type ='PRESSURE' OR value = 30
1:         op = new Operation.Builder(OperationType.AND, controller,
1:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("PRESSURE")),
1:                                    new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(30.00))).complete();
1: 
1:         Assert.assertFalse(op.satisfiedBy(row, staticRow, false));
1: 
1:         // (sensor_type = 'TEMPERATURE' OR sensor_type = 'PRESSURE') AND value = 24.56
1:         op = new Operation.Builder(OperationType.OR, controller,
1:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("TEMPERATURE")),
1:                                    new SimpleExpression(sensorType, Operator.EQ, UTF8Type.instance.decompose("PRESSURE")))
1:              .setRight(new Operation.Builder(OperationType.AND, controller,
1:                                              new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56)))).complete();
1: 
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1: 
1:         // sensor_type = LIKE 'TEMP%'  AND value = 24.56
1:         op = new Operation.Builder(OperationType.AND, controller,
1:                                    new SimpleExpression(sensorType, Operator.LIKE_PREFIX, UTF8Type.instance.decompose("TEMP")),
1:                                    new SimpleExpression(value, Operator.EQ, DoubleType.instance.decompose(24.56))).complete();
1: 
1:         Assert.assertTrue(op.satisfiedBy(row, staticRow, false));
1:     }
1: 
commit:479e8af
/////////////////////////////////////////////////////////////////////////
1:                                                     Arrays.asList(new SimpleExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose("soft eng")),
1:                         operation = Op.MATCH;
1:                         operation = Op.MATCH;
commit:3928665
/////////////////////////////////////////////////////////////////////////
1:                                             new SimpleExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("eng is a work")));
1:                                             new SimpleExpression(comment, Operator.LIKE_CONTAINS, UTF8Type.instance.decompose("soft works fine")));
commit:72790dc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.index.sasi.plan;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: import java.util.concurrent.TimeUnit;
1: 
1: import com.google.common.collect.ListMultimap;
1: import com.google.common.collect.Multimap;
1: import com.google.common.collect.Sets;
1: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.Operator;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.db.filter.RowFilter;
1: import org.apache.cassandra.db.marshal.DoubleType;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.index.sasi.plan.Operation.OperationType;
1: import org.apache.cassandra.db.marshal.Int32Type;
1: import org.apache.cassandra.db.marshal.LongType;
1: import org.apache.cassandra.db.marshal.UTF8Type;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.schema.KeyspaceMetadata;
1: import org.apache.cassandra.schema.KeyspaceParams;
1: import org.apache.cassandra.schema.Tables;
1: import org.apache.cassandra.service.MigrationManager;
1: import org.apache.cassandra.utils.FBUtilities;
1: 
1: import org.junit.*;
1: 
1: public class OperationTest extends SchemaLoader
1: {
0:     private static final String KS_NAME = "sasi";
1:     private static final String CF_NAME = "test_cf";
1:     private static final String CLUSTERING_CF_NAME = "clustering_test_cf";
1: 
1:     private static ColumnFamilyStore BACKEND;
1:     private static ColumnFamilyStore CLUSTERING_BACKEND;
1: 
1:     @BeforeClass
1:     public static void loadSchema() throws ConfigurationException
1:     {
1:         System.setProperty("cassandra.config", "cassandra-murmur.yaml");
1:         SchemaLoader.loadSchema();
1:         MigrationManager.announceNewKeyspace(KeyspaceMetadata.create(KS_NAME,
1:                                                                      KeyspaceParams.simpleTransient(1),
1:                                                                      Tables.of(SchemaLoader.sasiCFMD(KS_NAME, CF_NAME),
0:                                                                                SchemaLoader.clusteringSASICFMD(KS_NAME, CLUSTERING_CF_NAME))));
1: 
1:         BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME);
1:         CLUSTERING_BACKEND = Keyspace.open(KS_NAME).getColumnFamilyStore(CLUSTERING_CF_NAME);
1:     }
1: 
1:     private QueryController controller;
1: 
1:     @Before
1:     public void beforeTest()
1:     {
1:         controller = new QueryController(BACKEND,
1:                                          PartitionRangeReadCommand.allDataRead(BACKEND.metadata, FBUtilities.nowInSeconds()),
1:                                          TimeUnit.SECONDS.toMillis(10));
1:     }
1: 
1:     @After
1:     public void afterTest()
1:     {
1:         controller.finish();
1:     }
1: 
1:     @Test
1:     public void testAnalyze() throws Exception
1:     {
1:         final ColumnDefinition firstName = getColumn(UTF8Type.instance.decompose("first_name"));
1:         final ColumnDefinition age = getColumn(UTF8Type.instance.decompose("age"));
1:         final ColumnDefinition comment = getColumn(UTF8Type.instance.decompose("comment"));
1: 
1:         // age != 5 AND age > 1 AND age != 6 AND age <= 10
1:         Map<Expression.Op, Expression> expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:                                                                                 Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:                                                                                               new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:                                                                                               new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(6)),
1:                                                                                               new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(10)))));
1: 
1:         Expression expected = new Expression("age", Int32Type.instance)
1:         {{
1:             operation = Op.RANGE;
1:             lower = new Bound(Int32Type.instance.decompose(1), false);
1:             upper = new Bound(Int32Type.instance.decompose(10), true);
1: 
1:             exclusions.add(Int32Type.instance.decompose(5));
1:             exclusions.add(Int32Type.instance.decompose(6));
1:         }};
1: 
1:         Assert.assertEquals(1, expressions.size());
1:         Assert.assertEquals(expected, expressions.get(Expression.Op.RANGE));
1: 
1:         // age != 5 OR age >= 7
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:                                                     Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:                                                                   new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(7)))));
1:         Assert.assertEquals(2, expressions.size());
1: 
1:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:                             {{
1:                                     operation = Op.NOT_EQ;
1:                                     lower = new Bound(Int32Type.instance.decompose(5), true);
1:                                     upper = lower;
1:                             }}, expressions.get(Expression.Op.NOT_EQ));
1: 
1:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:                             {{
1:                                     operation = Op.RANGE;
1:                                     lower = new Bound(Int32Type.instance.decompose(7), true);
1:                             }}, expressions.get(Expression.Op.RANGE));
1: 
1:         // age != 5 OR age < 7
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:                                                     Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:                                                                   new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(7)))));
1: 
1:         Assert.assertEquals(2, expressions.size());
1:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:                             {{
1:                                     operation = Op.RANGE;
1:                                     upper = new Bound(Int32Type.instance.decompose(7), false);
1:                             }}, expressions.get(Expression.Op.RANGE));
1:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:                             {{
1:                                     operation = Op.NOT_EQ;
1:                                     lower = new Bound(Int32Type.instance.decompose(5), true);
1:                                     upper = lower;
1:                             }}, expressions.get(Expression.Op.NOT_EQ));
1: 
1:         // age > 1 AND age < 7
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:                                                     Arrays.asList(new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:                                                                   new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(7)))));
1: 
1:         Assert.assertEquals(1, expressions.size());
1:         Assert.assertEquals(new Expression("age", Int32Type.instance)
1:                             {{
1:                                     operation = Op.RANGE;
1:                                     lower = new Bound(Int32Type.instance.decompose(1), false);
1:                                     upper = new Bound(Int32Type.instance.decompose(7), false);
1:                             }}, expressions.get(Expression.Op.RANGE));
1: 
1:         // first_name = 'a' OR first_name != 'b'
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.OR,
1:                                                     Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:                                                                   new SimpleExpression(firstName, Operator.NEQ, UTF8Type.instance.decompose("b")))));
1: 
1:         Assert.assertEquals(2, expressions.size());
1:         Assert.assertEquals(new Expression("first_name", UTF8Type.instance)
1:                             {{
1:                                     operation = Op.NOT_EQ;
1:                                     lower = new Bound(UTF8Type.instance.decompose("b"), true);
1:                                     upper = lower;
1:                             }}, expressions.get(Expression.Op.NOT_EQ));
1:         Assert.assertEquals(new Expression("first_name", UTF8Type.instance)
1:                             {{
1:                                     operation = Op.EQ;
1:                                     lower = upper = new Bound(UTF8Type.instance.decompose("a"), true);
1:                             }}, expressions.get(Expression.Op.EQ));
1: 
1:         // comment = 'soft eng' and comment != 'likes do'
1:         ListMultimap<ColumnDefinition, Expression> e = Operation.analyzeGroup(controller, OperationType.OR,
0:                                                     Arrays.asList(new SimpleExpression(comment, Operator.EQ, UTF8Type.instance.decompose("soft eng")),
1:                                                                   new SimpleExpression(comment, Operator.NEQ, UTF8Type.instance.decompose("likes do"))));
1: 
1:         List<Expression> expectedExpressions = new ArrayList<Expression>(2)
1:         {{
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("soft"), true);
1:                         upper = lower;
1:                 }});
1: 
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("eng"), true);
1:                         upper = lower;
1:                 }});
1: 
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("likes"), true);
1:                         upper = lower;
1:                 }});
1: 
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("do"), true);
1:                         upper = lower;
1:                 }});
1:         }};
1: 
1:         Assert.assertEquals(expectedExpressions, e.get(comment));
1: 
1:         // first_name = 'j' and comment != 'likes do'
1:         e = Operation.analyzeGroup(controller, OperationType.OR,
1:                         Arrays.asList(new SimpleExpression(comment, Operator.NEQ, UTF8Type.instance.decompose("likes do")),
1:                                       new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("j"))));
1: 
1:         expectedExpressions = new ArrayList<Expression>(2)
1:         {{
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("likes"), true);
1:                         upper = lower;
1:                 }});
1: 
1:                 add(new Expression("comment", UTF8Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(UTF8Type.instance.decompose("do"), true);
1:                         upper = lower;
1:                 }});
1:         }};
1: 
1:         Assert.assertEquals(expectedExpressions, e.get(comment));
1: 
1:         // age != 27 first_name = 'j' and age != 25
1:         e = Operation.analyzeGroup(controller, OperationType.OR,
1:                         Arrays.asList(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(27)),
1:                                       new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("j")),
1:                                       new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(25))));
1: 
1:         expectedExpressions = new ArrayList<Expression>(2)
1:         {{
1:                 add(new Expression("age", Int32Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(Int32Type.instance.decompose(27), true);
1:                         upper = lower;
1:                 }});
1: 
1:                 add(new Expression("age", Int32Type.instance)
1:                 {{
1:                         operation = Op.NOT_EQ;
1:                         lower = new Bound(Int32Type.instance.decompose(25), true);
1:                         upper = lower;
1:                 }});
1:         }};
1: 
1:         Assert.assertEquals(expectedExpressions, e.get(age));
1:     }
1: 
1:     @Test
1:     public void testSatisfiedBy() throws Exception
1:     {
1:         final ColumnDefinition timestamp = getColumn(UTF8Type.instance.decompose("timestamp"));
1:         final ColumnDefinition age = getColumn(UTF8Type.instance.decompose("age"));
1: 
1:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller, new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)));
1:         Operation op = builder.complete();
1: 
1:         Unfiltered row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()));
1: 
1:         // and reject incorrect value
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         // range with exclusions - age != 5 AND age > 1 AND age != 6 AND age <= 10
1:         builder = new Operation.Builder(OperationType.AND, controller,
1:                                         new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(5)),
1:                                         new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(1)),
1:                                         new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(6)),
1:                                         new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(10)));
1:         op = builder.complete();
1: 
1:         Set<Integer> exclusions = Sets.newHashSet(0, 1, 5, 6, 11);
1:         for (int i = 0; i <= 11; i++)
1:         {
1:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1: 
0:             boolean result = op.satisfiedBy(row, false);
1:             Assert.assertTrue(exclusions.contains(i) != result);
1:         }
1: 
1:         // now let's do something more complex - age = 5 OR age = 6
1:         builder = new Operation.Builder(OperationType.OR, controller,
1:                                         new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(5)),
1:                                         new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(6)));
1: 
1:         op = builder.complete();
1: 
1:         exclusions = Sets.newHashSet(0, 1, 2, 3, 4, 7, 8, 9, 10);
1:         for (int i = 0; i <= 10; i++)
1:         {
1:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1: 
0:             boolean result = op.satisfiedBy(row, false);
1:             Assert.assertTrue(exclusions.contains(i) != result);
1:         }
1: 
1:         // now let's test aggregated AND commands
1:         builder = new Operation.Builder(OperationType.AND, controller);
1: 
1:         // logical should be ignored by analyzer, but we still what to make sure that it is
1:         //IndexExpression logical = new IndexExpression(ByteBufferUtil.EMPTY_BYTE_BUFFER, IndexOperator.EQ, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         //logical.setLogicalOp(LogicalIndexOperator.AND);
1: 
1:         //builder.add(logical);
1:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(0)));
1:         builder.add(new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(10)));
1:         builder.add(new SimpleExpression(age, Operator.NEQ, Int32Type.instance.decompose(7)));
1: 
1:         op = builder.complete();
1: 
1:         exclusions = Sets.newHashSet(7);
1:         for (int i = 0; i < 10; i++)
1:         {
1:             row = buildRow(buildCell(age, Int32Type.instance.decompose(i), System.currentTimeMillis()));
1: 
0:             boolean result = op.satisfiedBy(row, false);
1:             Assert.assertTrue(exclusions.contains(i) != result);
1:         }
1: 
1:         // multiple analyzed expressions in the Operation timestamp >= 10 AND age = 5
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(timestamp, Operator.GTE, LongType.instance.decompose(10L)));
1:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(5)));
1: 
1:         op = builder.complete();
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(11L), System.currentTimeMillis()));
1: 
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(22L), System.currentTimeMillis()));
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1: 
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         // operation with internal expressions and right child
1:         builder = new Operation.Builder(OperationType.OR, controller,
1:                                         new SimpleExpression(timestamp, Operator.GT, LongType.instance.decompose(10L)));
1:         builder.setRight(new Operation.Builder(OperationType.AND, controller,
1:                                                new SimpleExpression(age, Operator.GT, Int32Type.instance.decompose(0)),
1:                                                new SimpleExpression(age, Operator.LT, Int32Type.instance.decompose(10))));
1:         op = builder.complete();
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(5), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(20), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(11L), System.currentTimeMillis()));
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(buildCell(age, Int32Type.instance.decompose(0), System.currentTimeMillis()),
1:                                   buildCell(timestamp, LongType.instance.decompose(9L), System.currentTimeMillis()));
1: 
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         // and for desert let's try out null and deleted rows etc.
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(30)));
1:         op = builder.complete();
1: 
0:         Assert.assertFalse(op.satisfiedBy(null, false));
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         long now = System.currentTimeMillis();
1: 
1:         row = OperationTest.buildRow(
1:                 Row.Deletion.regular(new DeletionTime(now - 10, (int) (now / 1000))),
1:                           buildCell(age, Int32Type.instance.decompose(6), System.currentTimeMillis()));
1: 
0:         Assert.assertFalse(op.satisfiedBy(row, false));
1: 
1:         row = buildRow(deletedCell(age, System.currentTimeMillis(), FBUtilities.nowInSeconds()));
1: 
0:         Assert.assertFalse(op.satisfiedBy(row, true));
1: 
1:         try
1:         {
0:             Assert.assertFalse(op.satisfiedBy(buildRow(), false));
1:         }
1:         catch (IllegalStateException e)
1:         {
1:             // expected
1:         }
1: 
1:         try
1:         {
0:             Assert.assertFalse(op.satisfiedBy(buildRow(), true));
1:         }
1:         catch (IllegalStateException e)
1:         {
1:             Assert.fail("IllegalStateException should not be thrown when missing column and allowMissingColumns=true");
1:         }
1:     }
1: 
1:     @Test
1:     public void testAnalyzeNotIndexedButDefinedColumn() throws Exception
1:     {
1:         final ColumnDefinition firstName = getColumn(UTF8Type.instance.decompose("first_name"));
1:         final ColumnDefinition height = getColumn(UTF8Type.instance.decompose("height"));
1: 
1:         // first_name = 'a' AND height != 10
1:         Map<Expression.Op, Expression> expressions;
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)))));
1: 
1:         Assert.assertEquals(2, expressions.size());
1: 
1:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:         {{
1:                 operation = Op.NOT_EQ;
1:                 lower = new Bound(Int32Type.instance.decompose(5), true);
1:                 upper = lower;
1:         }}, expressions.get(Expression.Op.NOT_EQ));
1: 
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:                               new SimpleExpression(height, Operator.GT, Int32Type.instance.decompose(0)),
1:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)))));
1: 
1:         Assert.assertEquals(2, expressions.size());
1: 
1:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:         {{
1:             operation = Op.RANGE;
1:             lower = new Bound(Int32Type.instance.decompose(0), false);
1:             exclusions.add(Int32Type.instance.decompose(5));
1:         }}, expressions.get(Expression.Op.RANGE));
1: 
1:         expressions = convert(Operation.analyzeGroup(controller, OperationType.AND,
1:                 Arrays.asList(new SimpleExpression(firstName, Operator.EQ, UTF8Type.instance.decompose("a")),
1:                               new SimpleExpression(height, Operator.NEQ, Int32Type.instance.decompose(5)),
1:                               new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(0)),
1:                               new SimpleExpression(height, Operator.LT, Int32Type.instance.decompose(10)))));
1: 
1:         Assert.assertEquals(2, expressions.size());
1: 
1:         Assert.assertEquals(new Expression("height", Int32Type.instance)
1:         {{
1:                 operation = Op.RANGE;
1:                 lower = new Bound(Int32Type.instance.decompose(0), true);
1:                 upper = new Bound(Int32Type.instance.decompose(10), false);
1:                 exclusions.add(Int32Type.instance.decompose(5));
1:         }}, expressions.get(Expression.Op.RANGE));
1:     }
1: 
1:     @Test
1:     public void testSatisfiedByWithMultipleTerms()
1:     {
1:         final ColumnDefinition comment = getColumn(UTF8Type.instance.decompose("comment"));
1: 
0:         Unfiltered row = buildRow(
0:                 buildCell(comment,
0:                                                           UTF8Type.instance.decompose("software engineer is working on a project"),
0:                                                           System.currentTimeMillis()));
1: 
1:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller,
0:                                             new SimpleExpression(comment, Operator.EQ, UTF8Type.instance.decompose("eng is a work")));
1:         Operation op = builder.complete();
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller,
0:                                             new SimpleExpression(comment, Operator.EQ, UTF8Type.instance.decompose("soft works fine")));
1:         op = builder.complete();
1: 
0:         Assert.assertTrue(op.satisfiedBy(row, false));
1:     }
1: 
1:     @Test
1:     public void testSatisfiedByWithClustering()
1:     {
1:         ColumnDefinition location = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("location"));
1:         ColumnDefinition age = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("age"));
1:         ColumnDefinition height = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("height"));
1:         ColumnDefinition score = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("score"));
1: 
0:         Unfiltered row = buildRow(new Clustering(UTF8Type.instance.fromString("US"), Int32Type.instance.decompose(27)),
1:                                   buildCell(height, Int32Type.instance.decompose(182), System.currentTimeMillis()),
1:                                   buildCell(score, DoubleType.instance.decompose(1.0d), System.currentTimeMillis()));
1: 
1:         Operation.Builder builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(27)));
1:         builder.add(new SimpleExpression(height, Operator.EQ, Int32Type.instance.decompose(182)));
1: 
0:         Assert.assertTrue(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1: 
1:         builder.add(new SimpleExpression(age, Operator.EQ, Int32Type.instance.decompose(28)));
1:         builder.add(new SimpleExpression(height, Operator.EQ, Int32Type.instance.decompose(182)));
1: 
0:         Assert.assertFalse(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(27)));
1: 
0:         Assert.assertTrue(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("BY")));
1:         builder.add(new SimpleExpression(age, Operator.GTE, Int32Type.instance.decompose(28)));
1: 
0:         Assert.assertFalse(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:         builder.add(new SimpleExpression(age, Operator.LTE, Int32Type.instance.decompose(27)));
1:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1: 
0:         Assert.assertTrue(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(location, Operator.EQ, UTF8Type.instance.decompose("US")));
1:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1:         builder.add(new SimpleExpression(score, Operator.EQ, DoubleType.instance.decompose(1.0d)));
1: 
0:         Assert.assertTrue(builder.complete().satisfiedBy(row, false));
1: 
1:         builder = new Operation.Builder(OperationType.AND, controller);
1:         builder.add(new SimpleExpression(height, Operator.GTE, Int32Type.instance.decompose(182)));
1:         builder.add(new SimpleExpression(score, Operator.EQ, DoubleType.instance.decompose(1.0d)));
1: 
0:         Assert.assertTrue(builder.complete().satisfiedBy(row, false));
1:     }
1: 
1:     private Map<Expression.Op, Expression> convert(Multimap<ColumnDefinition, Expression> expressions)
1:     {
1:         Map<Expression.Op, Expression> converted = new HashMap<>();
1:         for (Expression expression : expressions.values())
1:         {
1:             Expression column = converted.get(expression.getOp());
1:             assert column == null; // sanity check
1:             converted.put(expression.getOp(), expression);
1:         }
1: 
1:         return converted;
1:     }
1: 
1:     private static class SimpleExpression extends RowFilter.Expression
1:     {
0:         protected SimpleExpression(ColumnDefinition column, Operator operator, ByteBuffer value)
1:         {
1:             super(column, operator, value);
1:         }
1: 
1:         @Override
1:         protected Kind kind()
1:         {
1:             return Kind.SIMPLE;
1:         }
1: 
1:         @Override
1:         public boolean isSatisfiedBy(CFMetaData metadata, DecoratedKey partitionKey, Row row)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
1: 
1:     private static Unfiltered buildRow(Cell... cells)
1:     {
1:         return buildRow(Clustering.EMPTY, null, cells);
1:     }
1: 
1:     private static Row buildRow(Row.Deletion deletion, Cell... cells)
1:     {
1:         return buildRow(Clustering.EMPTY, deletion, cells);
1:     }
1: 
1:     private static Row buildRow(Clustering clustering, Cell... cells)
1:     {
1:         return buildRow(clustering, null, cells);
1:     }
1: 
1:     private static Row buildRow(Clustering clustering, Row.Deletion deletion, Cell... cells)
1:     {
1:         Row.Builder rowBuilder = BTreeRow.sortedBuilder();
1:         rowBuilder.newRow(clustering);
1:         for (Cell c : cells)
1:             rowBuilder.addCell(c);
1: 
1:         if (deletion != null)
1:             rowBuilder.addRowDeletion(deletion);
1: 
1:         return rowBuilder.build();
1:     }
1: 
1:     private static Cell buildCell(ColumnDefinition column, ByteBuffer value, long timestamp)
1:     {
0:         return BufferCell.live(BACKEND.metadata, column, timestamp, value);
1:     }
1: 
1:     private static Cell deletedCell(ColumnDefinition column, long timestamp, int nowInSeconds)
1:     {
1:         return BufferCell.tombstone(column, timestamp, nowInSeconds);
1:     }
1: 
1:     private static ColumnDefinition getColumn(ByteBuffer name)
1:     {
1:         return getColumn(BACKEND, name);
1:     }
1: 
1:     private static ColumnDefinition getColumn(ColumnFamilyStore cfs, ByteBuffer name)
1:     {
1:         return cfs.metadata.getColumnDefinition(name);
1:     }
1: }
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:bdae452
/////////////////////////////////////////////////////////////////////////
1:         SimpleExpression(ColumnDefinition column, Operator operator, ByteBuffer value)
commit:670b6c6
/////////////////////////////////////////////////////////////////////////
1:         Unfiltered row = buildRow(Clustering.make(UTF8Type.instance.fromString("US"), Int32Type.instance.decompose(27)),
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1:         return BufferCell.live(column, timestamp, value);
============================================================================