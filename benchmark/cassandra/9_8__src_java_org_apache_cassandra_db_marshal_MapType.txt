1:91bdf7f: /*
1:91bdf7f:  * Licensed to the Apache Software Foundation (ASF) under one
1:91bdf7f:  * or more contributor license agreements.  See the NOTICE file
1:91bdf7f:  * distributed with this work for additional information
1:91bdf7f:  * regarding copyright ownership.  The ASF licenses this file
1:91bdf7f:  * to you under the Apache License, Version 2.0 (the
1:91bdf7f:  * "License"); you may not use this file except in compliance
1:91bdf7f:  * with the License.  You may obtain a copy of the License at
1:91bdf7f:  *
1:91bdf7f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:91bdf7f:  *
1:91bdf7f:  * Unless required by applicable law or agreed to in writing, software
1:91bdf7f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:91bdf7f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:91bdf7f:  * See the License for the specific language governing permissions and
1:91bdf7f:  * limitations under the License.
1:91bdf7f:  */
1:91bdf7f: package org.apache.cassandra.db.marshal;
6:91bdf7f: 
1:91bdf7f: import java.nio.ByteBuffer;
1:5e5fbc6: import java.util.*;
1:91bdf7f: 
1:b7be198: import org.apache.cassandra.cql3.Json;
1:c7b02d1: import org.apache.cassandra.cql3.Maps;
1:c7b02d1: import org.apache.cassandra.cql3.Term;
1:a991b64: import org.apache.cassandra.db.rows.Cell;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:3b299c4: import org.apache.cassandra.serializers.CollectionSerializer;
1:c7b02d1: import org.apache.cassandra.serializers.MarshalException;
1:fc8b76f: import org.apache.cassandra.serializers.MapSerializer;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:91bdf7f: import org.apache.cassandra.utils.Pair;
1:91bdf7f: 
1:5e5fbc6: public class MapType<K, V> extends CollectionType<Map<K, V>>
7:91bdf7f: {
1:91bdf7f:     // interning instances
1:ee55f36:     private static final Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> instances = new HashMap<>();
1:ee55f36:     private static final Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> frozenInstances = new HashMap<>();
1:f634ac7: 
1:ee55f36:     private final AbstractType<K> keys;
1:ee55f36:     private final AbstractType<V> values;
1:daff1fc:     private final MapSerializer<K, V> serializer;
1:ee55f36:     private final boolean isMultiCell;
1:8b00f3a: 
1:3a2faf9:     public static MapType<?, ?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:8b00f3a:     {
1:91bdf7f:         List<AbstractType<?>> l = parser.getTypeParameters();
1:91bdf7f:         if (l.size() != 2)
1:91bdf7f:             throw new ConfigurationException("MapType takes exactly 2 type parameters");
1:91bdf7f: 
1:ee55f36:         return getInstance(l.get(0), l.get(1), true);
1:8b00f3a:     }
1:91bdf7f: 
1:ee55f36:     public static synchronized <K, V> MapType<K, V> getInstance(AbstractType<K> keys, AbstractType<V> values, boolean isMultiCell)
1:8b00f3a:     {
1:ee55f36:         Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> internMap = isMultiCell ? instances : frozenInstances;
1:91bdf7f:         Pair<AbstractType<?>, AbstractType<?>> p = Pair.<AbstractType<?>, AbstractType<?>>create(keys, values);
1:ee55f36:         MapType<K, V> t = internMap.get(p);
1:91bdf7f:         if (t == null)
1:91bdf7f:         {
1:ee55f36:             t = new MapType<>(keys, values, isMultiCell);
1:ee55f36:             internMap.put(p, t);
1:8b00f3a:         }
1:91bdf7f:         return t;
7:91bdf7f:     }
1:91bdf7f: 
1:ee55f36:     private MapType(AbstractType<K> keys, AbstractType<V> values, boolean isMultiCell)
1:91bdf7f:     {
1:07594ee:         super(ComparisonType.CUSTOM, Kind.MAP);
1:91bdf7f:         this.keys = keys;
1:91bdf7f:         this.values = values;
1:70819bf:         this.serializer = MapSerializer.getInstance(keys.getSerializer(), values.getSerializer(), keys);
1:ee55f36:         this.isMultiCell = isMultiCell;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:7a3c3ab:     public boolean referencesUserType(String userTypeName)
1:d62b2cf:     {
1:7a3c3ab:         return getKeysType().referencesUserType(userTypeName) ||
1:7a3c3ab:                getValuesType().referencesUserType(userTypeName);
1:98c4a7c:     }
1:d62b2cf: 
1:ecf05b8:     @Override
1:ecf05b8:     public boolean referencesDuration()
1:ecf05b8:     {
1:ecf05b8:         // Maps cannot be created with duration as keys
1:ecf05b8:         return getValuesType().referencesDuration();
1:ecf05b8:     }
1:ecf05b8: 
1:ee55f36:     public AbstractType<K> getKeysType()
1:ee55f36:     {
1:ee55f36:         return keys;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     public AbstractType<V> getValuesType()
1:ee55f36:     {
1:ee55f36:         return values;
1:e9c6742:     }
1:98c4a7c: 
1:5e5fbc6:     public AbstractType<K> nameComparator()
1:98c4a7c:     {
1:91bdf7f:         return keys;
1:91bdf7f:     }
1:f4b9f16: 
1:5e5fbc6:     public AbstractType<V> valueComparator()
1:f4b9f16:     {
1:91bdf7f:         return values;
1:91bdf7f:     }
1:e9c6742: 
1:98c4a7c:     @Override
1:ee55f36:     public boolean isMultiCell()
1:ee55f36:     {
1:ee55f36:         return isMultiCell;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:ee55f36:     public AbstractType<?> freeze()
1:ee55f36:     {
1:ee55f36:         if (isMultiCell)
1:ee55f36:             return getInstance(this.keys, this.values, false);
1:ee55f36:         else
1:ee55f36:             return this;
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:dee84cc:     public AbstractType<?> freezeNestedMulticellTypes()
1:e9c6742:     {
1:dee84cc:         if (!isMultiCell())
1:dee84cc:             return this;
1:91bdf7f: 
1:dee84cc:         AbstractType<?> keyType = (keys.isFreezable() && keys.isMultiCell())
1:dee84cc:                                 ? keys.freeze()
1:dee84cc:                                 : keys.freezeNestedMulticellTypes();
1:dee84cc: 
1:dee84cc:         AbstractType<?> valueType = (values.isFreezable() && values.isMultiCell())
1:d62b2cf:                                   ? values.freeze()
1:dee84cc:                                   : values.freezeNestedMulticellTypes();
1:d62b2cf: 
1:d62b2cf:         return getInstance(keyType, valueType, isMultiCell);
1:d62b2cf:     }
1:d62b2cf: 
1:d62b2cf:     @Override
1:ee55f36:     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
1:ee55f36:     {
1:ee55f36:         assert !isMultiCell;
1:ee55f36:         MapType tprev = (MapType) previous;
1:ee55f36:         return keys.isCompatibleWith(tprev.keys) && values.isCompatibleWith(tprev.values);
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:ee55f36:     public boolean isValueCompatibleWithFrozen(CollectionType<?> previous)
1:ee55f36:     {
1:ee55f36:         assert !isMultiCell;
1:ee55f36:         MapType tprev = (MapType) previous;
1:ee55f36:         return keys.isCompatibleWith(tprev.keys) && values.isValueCompatibleWith(tprev.values);
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     @Override
1:07594ee:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
1:91bdf7f:     {
1:ee55f36:         return compareMaps(keys, values, o1, o2);
1:ee55f36:     }
1:ee55f36: 
1:ee55f36:     public static int compareMaps(AbstractType<?> keysComparator, AbstractType<?> valuesComparator, ByteBuffer o1, ByteBuffer o2)
1:ee55f36:     {
1:ee55f36:          if (!o1.hasRemaining() || !o2.hasRemaining())
1:acf1b18:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
1:91bdf7f: 
1:f4b9f16:         ByteBuffer bb1 = o1.duplicate();
1:f4b9f16:         ByteBuffer bb2 = o2.duplicate();
1:f4b9f16: 
1:e0adc16:         ProtocolVersion protocolVersion = ProtocolVersion.V3;
1:ee55f36:         int size1 = CollectionSerializer.readCollectionSize(bb1, protocolVersion);
1:ee55f36:         int size2 = CollectionSerializer.readCollectionSize(bb2, protocolVersion);
1:f4b9f16: 
1:f4b9f16:         for (int i = 0; i < Math.min(size1, size2); i++)
1:f4b9f16:         {
1:ee55f36:             ByteBuffer k1 = CollectionSerializer.readValue(bb1, protocolVersion);
1:ee55f36:             ByteBuffer k2 = CollectionSerializer.readValue(bb2, protocolVersion);
1:ee55f36:             int cmp = keysComparator.compare(k1, k2);
1:f4b9f16:             if (cmp != 0)
1:f4b9f16:                 return cmp;
1:f4b9f16: 
1:ee55f36:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, protocolVersion);
1:ee55f36:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, protocolVersion);
1:ee55f36:             cmp = valuesComparator.compare(v1, v2);
1:f4b9f16:             if (cmp != 0)
1:f4b9f16:                 return cmp;
1:f4b9f16:         }
1:f4b9f16: 
1:f4b9f16:         return size1 == size2 ? 0 : (size1 < size2 ? -1 : 1);
1:f4b9f16:     }
1:f4b9f16: 
1:f4b9f16:     @Override
1:9872b74:     public MapSerializer<K, V> getSerializer()
1:91bdf7f:     {
1:daff1fc:         return serializer;
1:91bdf7f:     }
1:91bdf7f: 
1:e9c6742:     @Override
1:a991b64:     protected int collectionSize(List<ByteBuffer> values)
1:a991b64:     {
1:a991b64:         return values.size() / 2;
1:a991b64:     }
1:a991b64: 
1:ee55f36:     public String toString(boolean ignoreFreezing)
1:91bdf7f:     {
1:ee55f36:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
1:ee55f36: 
1:ee55f36:         StringBuilder sb = new StringBuilder();
1:ee55f36:         if (includeFrozenType)
1:ee55f36:             sb.append(FrozenType.class.getName()).append("(");
1:ee55f36:         sb.append(getClass().getName()).append(TypeParser.stringifyTypeParameters(Arrays.asList(keys, values), ignoreFreezing || !isMultiCell));
1:ee55f36:         if (includeFrozenType)
1:ee55f36:             sb.append(")");
1:ee55f36:         return sb.toString();
1:91bdf7f:     }
1:91bdf7f: 
1:a991b64:     public List<ByteBuffer> serializedValues(Iterator<Cell> cells)
1:91bdf7f:     {
1:ee55f36:         assert isMultiCell;
1:a991b64:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>();
1:a991b64:         while (cells.hasNext())
1:91bdf7f:         {
1:a991b64:             Cell c = cells.next();
1:a991b64:             bbs.add(c.path().get(0));
1:9872b74:             bbs.add(c.value());
1:91bdf7f:         }
1:9872b74:         return bbs;
1:91bdf7f:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:c7b02d1:     public Term fromJSONObject(Object parsed) throws MarshalException
1:c7b02d1:     {
1:b7be198:         if (parsed instanceof String)
1:b7be198:             parsed = Json.decodeJson((String) parsed);
1:b7be198: 
1:c7b02d1:         if (!(parsed instanceof Map))
1:c7b02d1:             throw new MarshalException(String.format(
1:c7b02d1:                     "Expected a map, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
1:c7b02d1: 
1:c7b02d1:         Map<Object, Object> map = (Map<Object, Object>) parsed;
1:c7b02d1:         Map<Term, Term> terms = new HashMap<>(map.size());
1:c7b02d1:         for (Map.Entry<Object, Object> entry : map.entrySet())
1:c7b02d1:         {
1:c7b02d1:             if (entry.getKey() == null)
1:c7b02d1:                 throw new MarshalException("Invalid null key in map");
1:c7b02d1: 
1:c7b02d1:             if (entry.getValue() == null)
1:c7b02d1:                 throw new MarshalException("Invalid null value in map");
1:c7b02d1: 
1:c7b02d1:             terms.put(keys.fromJSONObject(entry.getKey()), values.fromJSONObject(entry.getValue()));
1:c7b02d1:         }
1:c7b02d1:         return new Maps.DelayedValue(keys, terms);
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:e0adc16:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:c7b02d1:     {
1:c7b02d1:         StringBuilder sb = new StringBuilder("{");
1:c7b02d1:         int size = CollectionSerializer.readCollectionSize(buffer, protocolVersion);
1:c7b02d1:         for (int i = 0; i < size; i++)
1:c7b02d1:         {
1:c7b02d1:             if (i > 0)
1:c7b02d1:                 sb.append(", ");
1:c7b02d1: 
1:b7be198:             // map keys must be JSON strings, so convert non-string keys to strings
1:b7be198:             String key = keys.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion);
1:b7be198:             if (key.startsWith("\""))
1:b7be198:                 sb.append(key);
1:b7be198:             else
1:6b1bd17:                 sb.append('"').append(Json.quoteAsJsonString(key)).append('"');
1:b7be198: 
1:c7b02d1:             sb.append(": ");
1:c7b02d1:             sb.append(values.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
1:c7b02d1:         }
1:c7b02d1:         return sb.append("}").toString();
1:c7b02d1:     }
1:91bdf7f: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         ProtocolVersion protocolVersion = ProtocolVersion.V3;
/////////////////////////////////////////////////////////////////////////
1:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesDuration()
1:     {
1:         // Maps cannot be created with duration as keys
1:         return getValuesType().referencesDuration();
1:     }
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:dee84cc
/////////////////////////////////////////////////////////////////////////
1:     public AbstractType<?> freezeNestedMulticellTypes()
1:         if (!isMultiCell())
1:             return this;
1:         AbstractType<?> keyType = (keys.isFreezable() && keys.isMultiCell())
1:                                 ? keys.freeze()
1:                                 : keys.freezeNestedMulticellTypes();
1: 
1:         AbstractType<?> valueType = (values.isFreezable() && values.isMultiCell())
1:                                   : values.freezeNestedMulticellTypes();
commit:d62b2cf
/////////////////////////////////////////////////////////////////////////
0:     public AbstractType<?> freezeNestedUDTs()
1:     {
0:         AbstractType<?> keyType = (keys.isUDT() && keys.isMultiCell())
0:                                 ? keys.freeze()
0:                                 : keys.freezeNestedUDTs();
1: 
0:         AbstractType<?> valueType = (values.isUDT() && values.isMultiCell())
1:                                   ? values.freeze()
0:                                   : values.freezeNestedUDTs();
1: 
1:         return getInstance(keyType, valueType, isMultiCell);
1:     }
1: 
1:     @Override
commit:9b5af91
commit:6b1bd17
/////////////////////////////////////////////////////////////////////////
1:                 sb.append('"').append(Json.quoteAsJsonString(key)).append('"');
commit:b7be198
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Json;
/////////////////////////////////////////////////////////////////////////
1:         if (parsed instanceof String)
1:             parsed = Json.decodeJson((String) parsed);
1: 
/////////////////////////////////////////////////////////////////////////
1:             // map keys must be JSON strings, so convert non-string keys to strings
1:             String key = keys.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion);
1:             if (key.startsWith("\""))
1:                 sb.append(key);
1:             else
0:                 sb.append('"').append(Json.JSON_STRING_ENCODER.quoteAsString(key)).append('"');
1: 
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Maps;
1: import org.apache.cassandra.cql3.Term;
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public Term fromJSONObject(Object parsed) throws MarshalException
1:     {
1:         if (!(parsed instanceof Map))
1:             throw new MarshalException(String.format(
1:                     "Expected a map, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
1: 
1:         Map<Object, Object> map = (Map<Object, Object>) parsed;
1:         Map<Term, Term> terms = new HashMap<>(map.size());
1:         for (Map.Entry<Object, Object> entry : map.entrySet())
1:         {
1:             if (entry.getKey() == null)
1:                 throw new MarshalException("Invalid null key in map");
1: 
1:             if (entry.getValue() == null)
1:                 throw new MarshalException("Invalid null value in map");
1: 
1:             terms.put(keys.fromJSONObject(entry.getKey()), values.fromJSONObject(entry.getValue()));
1:         }
1:         return new Maps.DelayedValue(keys, terms);
1:     }
1: 
1:     @Override
0:     public String toJSONString(ByteBuffer buffer, int protocolVersion)
1:     {
1:         StringBuilder sb = new StringBuilder("{");
1:         int size = CollectionSerializer.readCollectionSize(buffer, protocolVersion);
1:         for (int i = 0; i < size; i++)
1:         {
1:             if (i > 0)
1:                 sb.append(", ");
1: 
0:             sb.append(keys.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
1:             sb.append(": ");
1:             sb.append(values.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
1:         }
1:         return sb.append("}").toString();
1:     }
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.transport.Server;
1:     private static final Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> instances = new HashMap<>();
1:     private static final Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> frozenInstances = new HashMap<>();
1:     private final AbstractType<K> keys;
1:     private final AbstractType<V> values;
1:     private final boolean isMultiCell;
/////////////////////////////////////////////////////////////////////////
1:         return getInstance(l.get(0), l.get(1), true);
1:     public static synchronized <K, V> MapType<K, V> getInstance(AbstractType<K> keys, AbstractType<V> values, boolean isMultiCell)
1:         Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> internMap = isMultiCell ? instances : frozenInstances;
1:         MapType<K, V> t = internMap.get(p);
1:             t = new MapType<>(keys, values, isMultiCell);
1:             internMap.put(p, t);
1:     private MapType(AbstractType<K> keys, AbstractType<V> values, boolean isMultiCell)
1:         this.isMultiCell = isMultiCell;
1:     }
1: 
1:     public AbstractType<K> getKeysType()
1:     {
1:         return keys;
1:     }
1: 
1:     public AbstractType<V> getValuesType()
1:     {
1:         return values;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isMultiCell()
1:     {
1:         return isMultiCell;
1:     }
1: 
1:     @Override
1:     public AbstractType<?> freeze()
1:     {
1:         if (isMultiCell)
1:             return getInstance(this.keys, this.values, false);
1:         else
1:             return this;
1:     }
1: 
1:     @Override
1:     public boolean isCompatibleWithFrozen(CollectionType<?> previous)
1:     {
1:         assert !isMultiCell;
1:         MapType tprev = (MapType) previous;
1:         return keys.isCompatibleWith(tprev.keys) && values.isCompatibleWith(tprev.values);
1:     }
1: 
1:     @Override
1:     public boolean isValueCompatibleWithFrozen(CollectionType<?> previous)
1:     {
1:         assert !isMultiCell;
1:         MapType tprev = (MapType) previous;
1:         return keys.isCompatibleWith(tprev.keys) && values.isValueCompatibleWith(tprev.values);
1:     }
1: 
1:     @Override
1:         return compareMaps(keys, values, o1, o2);
1:     }
1: 
1:     public static int compareMaps(AbstractType<?> keysComparator, AbstractType<?> valuesComparator, ByteBuffer o1, ByteBuffer o2)
1:     {
1:          if (!o1.hasRemaining() || !o2.hasRemaining())
0:         int protocolVersion = Server.VERSION_3;
1:         int size1 = CollectionSerializer.readCollectionSize(bb1, protocolVersion);
1:         int size2 = CollectionSerializer.readCollectionSize(bb2, protocolVersion);
1:             ByteBuffer k1 = CollectionSerializer.readValue(bb1, protocolVersion);
1:             ByteBuffer k2 = CollectionSerializer.readValue(bb2, protocolVersion);
1:             int cmp = keysComparator.compare(k1, k2);
1:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, protocolVersion);
1:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, protocolVersion);
1:             cmp = valuesComparator.compare(v1, v2);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString(boolean ignoreFreezing)
1:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
1: 
1:         StringBuilder sb = new StringBuilder();
1:         if (includeFrozenType)
1:             sb.append(FrozenType.class.getName()).append("(");
1:         sb.append(getClass().getName()).append(TypeParser.stringifyTypeParameters(Arrays.asList(keys, values), ignoreFreezing || !isMultiCell));
1:         if (includeFrozenType)
1:             sb.append(")");
1:         return sb.toString();
1:         assert isMultiCell;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesUserType(String userTypeName)
1:         return getKeysType().referencesUserType(userTypeName) ||
1:                getValuesType().referencesUserType(userTypeName);
commit:e6f23e6
commit:1de63e9
commit:98c4a7c
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public boolean references(AbstractType<?> check)
1:     {
0:         return super.references(check) || keys.references(check) || values.references(check);
1:     }
1: 
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:07594ee
/////////////////////////////////////////////////////////////////////////
1:         super(ComparisonType.CUSTOM, Kind.MAP);
/////////////////////////////////////////////////////////////////////////
1:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:70819bf
/////////////////////////////////////////////////////////////////////////
1:         this.serializer = MapSerializer.getInstance(keys.getSerializer(), values.getSerializer(), keys);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.Cell;
/////////////////////////////////////////////////////////////////////////
1:     protected int collectionSize(List<ByteBuffer> values)
1:     {
1:         return values.size() / 2;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public List<ByteBuffer> serializedValues(Iterator<Cell> cells)
1:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>();
1:         while (cells.hasNext())
1:             Cell c = cells.next();
1:             bbs.add(c.path().get(0));
commit:3b299c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.CollectionSerializer;
/////////////////////////////////////////////////////////////////////////
0:         int size1 = CollectionSerializer.readCollectionSize(bb1, 3);
0:         int size2 = CollectionSerializer.readCollectionSize(bb2, 3);
0:             ByteBuffer k1 = CollectionSerializer.readValue(bb1, 3);
0:             ByteBuffer k2 = CollectionSerializer.readValue(bb2, 3);
0:             ByteBuffer v1 = CollectionSerializer.readValue(bb1, 3);
0:             ByteBuffer v2 = CollectionSerializer.readValue(bb2, 3);
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:     public MapSerializer<K, V> getSerializer()
/////////////////////////////////////////////////////////////////////////
0:     public List<ByteBuffer> serializedValues(List<Cell> cells)
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(cells.size() * 2);
0:             bbs.add(c.name().collectionElement());
1:             bbs.add(c.value());
1:         return bbs;
commit:f4b9f16
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:     public int compare(ByteBuffer o1, ByteBuffer o2)
1:     {
0:         // Note that this is only used if the collection is inside an UDT
0:         if (o1 == null || !o1.hasRemaining())
0:             return o2 == null || !o2.hasRemaining() ? 0 : -1;
0:         if (o2 == null || !o2.hasRemaining())
0:             return 1;
1: 
1:         ByteBuffer bb1 = o1.duplicate();
1:         ByteBuffer bb2 = o2.duplicate();
1: 
0:         int size1 = ByteBufferUtil.readShortLength(bb1);
0:         int size2 = ByteBufferUtil.readShortLength(bb2);
1: 
1:         for (int i = 0; i < Math.min(size1, size2); i++)
1:         {
0:             ByteBuffer k1 = ByteBufferUtil.readBytesWithShortLength(bb1);
0:             ByteBuffer k2 = ByteBufferUtil.readBytesWithShortLength(bb2);
0:             int cmp = keys.compare(k1, k2);
1:             if (cmp != 0)
1:                 return cmp;
1: 
0:             ByteBuffer v1 = ByteBufferUtil.readBytesWithShortLength(bb1);
0:             ByteBuffer v2 = ByteBufferUtil.readBytesWithShortLength(bb2);
0:             cmp = values.compare(v1, v2);
1:             if (cmp != 0)
1:                 return cmp;
1:         }
1: 
1:         return size1 == size2 ? 0 : (size1 < size2 ? -1 : 1);
1:     }
1: 
1:     @Override
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Cell;
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Cell> cells)
0:         cells = enforceLimit(cells);
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(2 * cells.size());
0:         for (Cell c : cells)
/////////////////////////////////////////////////////////////////////////
0:         return pack(bbs, cells.size(), size);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Column> columns)
0:         for (Column c : columns)
0:             ByteBuffer key = c.name().collectionElement();
0:             ByteBuffer value = c.value();
0:             bbs.add(key);
0:             bbs.add(value);
0:             size += 4 + key.remaining() + value.remaining();
commit:b2da839
commit:f634ac7
/////////////////////////////////////////////////////////////////////////
0:         columns = enforceLimit(columns);
1: 
commit:daff1fc
/////////////////////////////////////////////////////////////////////////
1:     private final MapSerializer<K, V> serializer;
/////////////////////////////////////////////////////////////////////////
0:         this.serializer = MapSerializer.getInstance(keys.getSerializer(), values.getSerializer());
/////////////////////////////////////////////////////////////////////////
1:         return serializer;
/////////////////////////////////////////////////////////////////////////
0:      * Creates the same output than serialize, but from the internal representation.
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.TypeSerializer;
1: import org.apache.cassandra.serializers.MapSerializer;
0: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
0:         this.composer = MapSerializer.getInstance(keys.getSerializer(), values.getSerializer());
/////////////////////////////////////////////////////////////////////////
0:     public TypeSerializer<Map<K, V>> getSerializer()
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.AbstractSerializer;
0: import org.apache.cassandra.type.MapSerializer;
0: import org.apache.cassandra.type.MarshalException;
/////////////////////////////////////////////////////////////////////////
0:     private final MapSerializer<K, V> composer;
/////////////////////////////////////////////////////////////////////////
0:         this.composer = MapSerializer.getInstance(keys.asComposer(), values.asComposer());
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public AbstractSerializer<Map<K, V>> asComposer()
1:     {
0:         return composer;
1:     }
1: 
0:      * Creates the same output than deserialize, but from the internal representation.
commit:c47f407
commit:9f268d1
/////////////////////////////////////////////////////////////////////////
0:             int n = getUnsignedShort(input);
0:                 int sk = getUnsignedShort(input);
0:                 int sv = getUnsignedShort(input);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Column;
/////////////////////////////////////////////////////////////////////////
0:     public ByteBuffer serialize(List<Pair<ByteBuffer, Column>> columns)
0:         for (Pair<ByteBuffer, Column> p : columns)
commit:8b00f3a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.BufferUnderflowException;
/////////////////////////////////////////////////////////////////////////
0:         try
0:             ByteBuffer input = bytes.duplicate();
0:             int n = input.getShort();
0:             Map<K, V> m = new LinkedHashMap<K, V>(n);
0:             for (int i = 0; i < n; i++)
1:             {
0:                 int sk = input.getShort();
0:                 byte[] datak = new byte[sk];
0:                 input.get(datak);
0:                 ByteBuffer kbb = ByteBuffer.wrap(datak);
0:                 keys.validate(kbb);
0:                 int sv = input.getShort();
0:                 byte[] datav = new byte[sv];
0:                 input.get(datav);
0:                 ByteBuffer vbb = ByteBuffer.wrap(datav);
0:                 values.validate(vbb);
1: 
0:                 m.put(keys.compose(kbb), values.compose(vbb));
1:             }
0:             return m;
0:         catch (BufferUnderflowException e)
1:         {
0:             throw new MarshalException("Not enough bytes to read a map");
1:         }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     public static MapType<?, ?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public AbstractType<?> nameComparator()
0:     public AbstractType<?> valueComparator()
/////////////////////////////////////////////////////////////////////////
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.Arrays;
0: import java.util.Iterator;
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.LinkedHashMap;
0: import java.util.Map;
1: 
0: import org.apache.cassandra.cql3.ColumnNameBuilder;
0: import org.apache.cassandra.cql3.Term;
0: import org.apache.cassandra.cql3.UpdateParameters;
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.IColumn;
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.Pair;
1: 
0: public class MapType extends CollectionType
1: {
1:     // interning instances
0:     private static final Map<Pair<AbstractType<?>, AbstractType<?>>, MapType> instances = new HashMap<Pair<AbstractType<?>, AbstractType<?>>, MapType>();
1: 
0:     public final AbstractType<?> keys;
0:     public final AbstractType<?> values;
1: 
0:     public static MapType getInstance(TypeParser parser) throws ConfigurationException
1:     {
1:         List<AbstractType<?>> l = parser.getTypeParameters();
1:         if (l.size() != 2)
1:             throw new ConfigurationException("MapType takes exactly 2 type parameters");
1: 
0:         return getInstance(l.get(0), l.get(1));
1:     }
1: 
0:     public static synchronized MapType getInstance(AbstractType<?> keys, AbstractType<?> values)
1:     {
1:         Pair<AbstractType<?>, AbstractType<?>> p = Pair.<AbstractType<?>, AbstractType<?>>create(keys, values);
0:         MapType t = instances.get(p);
1:         if (t == null)
1:         {
0:             t = new MapType(keys, values);
0:             instances.put(p, t);
1:         }
1:         return t;
1:     }
1: 
0:     private MapType(AbstractType<?> keys, AbstractType<?> values)
1:     {
0:         super(Kind.MAP);
1:         this.keys = keys;
1:         this.values = values;
1:     }
1: 
0:     protected AbstractType<?> nameComparator()
1:     {
1:         return keys;
1:     }
1: 
0:     protected AbstractType<?> valueComparator()
1:     {
1:         return values;
1:     }
1: 
0:     protected void appendToStringBuilder(StringBuilder sb)
1:     {
0:         sb.append(getClass().getName()).append(TypeParser.stringifyTypeParameters(Arrays.asList(keys, values)));
1:     }
1: 
0:     public void executeFunction(ColumnFamily cf, ColumnNameBuilder fullPath, Function fct, List<Term> args, UpdateParameters params) throws InvalidRequestException
1:     {
0:         switch (fct)
1:         {
0:             case SET:
0:                 doPut(cf, fullPath, args, params);
0:                 break;
0:             case DISCARD_KEY:
0:                 doDiscard(cf, fullPath, args.get(0), params);
0:                 break;
0:             default:
0:                 throw new AssertionError("Unsupported function " + fct);
1:         }
1:     }
1: 
0:     private void doPut(ColumnFamily cf, ColumnNameBuilder builder, List<Term> args, UpdateParameters params) throws InvalidRequestException
1:     {
0:         assert args.size() % 2 == 0;
0:         Iterator<Term> iter = args.iterator();
0:         while (iter.hasNext())
1:         {
0:             ByteBuffer name = builder.copy().add(iter.next().getByteBuffer(keys, params.variables)).build();
0:             ByteBuffer value = iter.next().getByteBuffer(values, params.variables);
0:             cf.addColumn(params.makeColumn(name, value));
1:         }
1:     }
1: 
0:     private void doDiscard(ColumnFamily cf, ColumnNameBuilder builder, Term value, UpdateParameters params) throws InvalidRequestException
1:     {
0:         ByteBuffer name = builder.add(value.getByteBuffer(keys, params.variables)).build();
0:         cf.addColumn(params.makeTombstone(name));
1:     }
1: 
0:     public ByteBuffer serializeForThrift(List<Pair<ByteBuffer, IColumn>> columns)
1:     {
0:         Map<String, Object> m = new LinkedHashMap<String, Object>();
0:         for (Pair<ByteBuffer, IColumn> p : columns)
0:             m.put(keys.getString(p.left), values.compose(p.right.value()));
0:         return ByteBufferUtil.bytes(FBUtilities.json(m));
1:     }
1: }
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
0:         if (!o1.hasRemaining() || !o2.hasRemaining())
1:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
/////////////////////////////////////////////////////////////////////////
0:     public boolean isByteOrderComparable()
0:     {
0:         return keys.isByteOrderComparable();
0:     }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:6f217f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:95f94a4
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:d54a93f
/////////////////////////////////////////////////////////////////////////
0:         MapType<K, V> t = instances.get(p);
0:             t = new MapType<K, V>(keys, values);
commit:5e5fbc6
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: public class MapType<K, V> extends CollectionType<Map<K, V>>
0:     public final AbstractType<K> keys;
0:     public final AbstractType<V> values;
0:     public static MapType<?, ?> getInstance(TypeParser parser) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:     public static synchronized <K, V> MapType<K, V> getInstance(AbstractType<K> keys, AbstractType<V> values)
/////////////////////////////////////////////////////////////////////////
0:     private MapType(AbstractType<K> keys, AbstractType<V> values)
1:     public AbstractType<K> nameComparator()
1:     public AbstractType<V> valueComparator()
0:     public Map<K, V> compose(ByteBuffer bytes)
0:     {
0:         ByteBuffer input = bytes.duplicate();
0:         int n = input.getShort();
0:         Map<K, V> m = new LinkedHashMap<K, V>(n);
0:         for (int i = 0; i < n; i++)
0:         {
0:             int sk = input.getShort();
0:             byte[] datak = new byte[sk];
0:             input.get(datak);
0: 
0:             int sv = input.getShort();
0:             byte[] datav = new byte[sv];
0:             input.get(datav);
0:             m.put(keys.compose(ByteBuffer.wrap(datak)), values.compose(ByteBuffer.wrap(datav)));
0:         }
0:         return m;
0:     }
0: 
0:     /**
0:      * Layout is: {@code <n><sk_1><k_1><sv_1><v_1>...<sk_n><k_n><sv_n><v_n> }
0:      * where:
0:      *   n is the number of elements
0:      *   sk_i is the number of bytes composing the ith key k_i
0:      *   k_i is the sk_i bytes composing the ith key
0:      *   sv_i is the number of bytes composing the ith value v_i
0:      *   v_i is the sv_i bytes composing the ith value
0:      */
0:     public ByteBuffer decompose(Map<K, V> value)
0:     {
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(2 * value.size());
0:         int size = 0;
0:         for (Map.Entry<K, V> entry : value.entrySet())
0:         {
0:             ByteBuffer bbk = keys.decompose(entry.getKey());
0:             ByteBuffer bbv = values.decompose(entry.getValue());
0:             bbs.add(bbk);
0:             bbs.add(bbv);
0:             size += 4 + bbk.remaining() + bbv.remaining();
0:         }
0:         return pack(bbs, value.size(), size);
0:     }
0: 
0:     /**
0:      * Creates the same output than decompose, but from the internal representation.
0:      */
0:     public ByteBuffer serialize(List<Pair<ByteBuffer, IColumn>> columns)
0:         List<ByteBuffer> bbs = new ArrayList<ByteBuffer>(2 * columns.size());
0:         int size = 0;
0:         {
0:             bbs.add(p.left);
0:             bbs.add(p.right.value());
0:             size += 4 + p.left.remaining() + p.right.value().remaining();
0:         }
0:         return pack(bbs, columns.size(), size);
============================================================================