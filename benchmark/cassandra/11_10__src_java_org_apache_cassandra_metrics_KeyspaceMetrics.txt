1:68dd634: /*
1:68dd634:  * Licensed to the Apache Software Foundation (ASF) under one
1:68dd634:  * or more contributor license agreements.  See the NOTICE file
1:68dd634:  * distributed with this work for additional information
1:68dd634:  * regarding copyright ownership.  The ASF licenses this file
1:68dd634:  * to you under the Apache License, Version 2.0 (the
1:68dd634:  * "License"); you may not use this file except in compliance
1:68dd634:  * with the License.  You may obtain a copy of the License at
1:68dd634:  *
1:68dd634:  *     http://www.apache.org/licenses/LICENSE-2.0
1:68dd634:  *
1:68dd634:  * Unless required by applicable law or agreed to in writing, software
1:68dd634:  * distributed under the License is distributed on an "AS IS" BASIS,
1:68dd634:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:68dd634:  * See the License for the specific language governing permissions and
1:68dd634:  * limitations under the License.
3:94ff639:  */
1:68dd634: package org.apache.cassandra.metrics;
1:1bd6960: 
1:ae0f634: import java.util.Set;
1:ca16e5b: 
1:8896a70: import com.codahale.metrics.Gauge;
1:8896a70: import com.codahale.metrics.Histogram;
1:62ffa35: import com.codahale.metrics.Timer;
1:68dd634: import org.apache.cassandra.db.ColumnFamilyStore;
1:68dd634: import org.apache.cassandra.db.Keyspace;
1:ae0f634: 
1:ae0f634: import com.google.common.collect.Lists;
1:ae0f634: import com.google.common.collect.Sets;
1:8896a70: 
1:8896a70: import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
1:8896a70: 
1:5b8ac8c: /**
1:68dd634:  * Metrics for {@link ColumnFamilyStore}.
1:5b8ac8c:  */
1:68dd634: public class KeyspaceMetrics
30:68dd634: {
1:ae0f634:     /** Total amount of live data stored in the memtable, excluding any data structure overhead */
1:9baae7b:     public final Gauge<Long> memtableLiveDataSize;
1:0bd5170:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
1:9baae7b:     public final Gauge<Long> memtableOnHeapDataSize;
1:0bd5170:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
1:9baae7b:     public final Gauge<Long> memtableOffHeapDataSize;
1:ae0f634:     /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
1:ae0f634:     public final Gauge<Long> allMemtablesLiveDataSize;
1:9baae7b:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
1:9baae7b:     public final Gauge<Long> allMemtablesOnHeapDataSize;
1:9baae7b:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
1:9baae7b:     public final Gauge<Long> allMemtablesOffHeapDataSize;
1:68dd634:     /** Total number of columns present in the memtable. */
1:68dd634:     public final Gauge<Long> memtableColumnsCount;
1:68dd634:     /** Number of times flush has resulted in the memtable being switched out. */
1:68dd634:     public final Gauge<Long> memtableSwitchCount;
1:68dd634:     /** Estimated number of tasks pending for this column family */
1:ae0f634:     public final Gauge<Long> pendingFlushes;
1:68dd634:     /** Estimate of number of pending compactios for this CF */
1:ae0f634:     public final Gauge<Long> pendingCompactions;
1:68dd634:     /** Disk space used by SSTables belonging to this CF */
1:68dd634:     public final Gauge<Long> liveDiskSpaceUsed;
1:68dd634:     /** Total disk space used by SSTables belonging to this CF, including obsolete ones waiting to be GC'd */
1:68dd634:     public final Gauge<Long> totalDiskSpaceUsed;
1:68dd634:     /** Disk space used by bloom filter */
1:68dd634:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
1:7a14a77:     /** Off heap memory used by bloom filter */
1:7a14a77:     public final Gauge<Long> bloomFilterOffHeapMemoryUsed;
1:7a14a77:     /** Off heap memory used by index summary */
1:7a14a77:     public final Gauge<Long> indexSummaryOffHeapMemoryUsed;
1:7a14a77:     /** Off heap memory used by compression meta data*/
1:7a14a77:     public final Gauge<Long> compressionMetadataOffHeapMemoryUsed;
1:ae0f634:     /** (Local) read metrics */
1:ae0f634:     public final LatencyMetrics readLatency;
1:ae0f634:     /** (Local) range slice metrics */
1:ae0f634:     public final LatencyMetrics rangeLatency;
1:ae0f634:     /** (Local) write metrics */
1:ae0f634:     public final LatencyMetrics writeLatency;
1:ae0f634:     /** Histogram of the number of sstable data files accessed per read */
1:ae0f634:     public final Histogram sstablesPerReadHistogram;
1:ae0f634:     /** Tombstones scanned in queries on this Keyspace */
1:ae0f634:     public final Histogram tombstoneScannedHistogram;
1:ae0f634:     /** Live cells scanned in queries on this Keyspace */
1:ae0f634:     public final Histogram liveScannedHistogram;
1:e019760:     /** Column update time delta on this Keyspace */
1:e019760:     public final Histogram colUpdateTimeDeltaHistogram;
1:62ffa35:     /** time taken acquiring the partition lock for materialized view updates on this keyspace */
1:62ffa35:     public final Timer viewLockAcquireTime;
1:62ffa35:     /** time taken during the local read of a materialized view update */
1:62ffa35:     public final Timer viewReadTime;
1:1bd6960:     /** CAS Prepare metric */
1:1bd6960:     public final LatencyMetrics casPrepare;
1:1bd6960:     /** CAS Propose metrics */
1:1bd6960:     public final LatencyMetrics casPropose;
1:1bd6960:     /** CAS Commit metrics */
1:1bd6960:     public final LatencyMetrics casCommit;
1:3c43775: 
1:ae0f634:     public final MetricNameFactory factory;
1:ae0f634:     private Keyspace keyspace;
1:68d2526: 
1:ae0f634:     /** set containing names of all the metrics stored here, for releasing later */
1:ae0f634:     private Set<String> allMetrics = Sets.newHashSet();
1:68d2526: 
1:5b8ac8c:     /**
1:68dd634:      * Creates metrics for given {@link ColumnFamilyStore}.
1:68dd634:      *
1:68dd634:      * @param ks Keyspace to measure metrics
1:5b8ac8c:      */
1:68dd634:     public KeyspaceMetrics(final Keyspace ks)
1:94ff639:     {
1:68dd634:         factory = new KeyspaceMetricNameFactory(ks);
1:ae0f634:         keyspace = ks;
1:ae0f634:         memtableColumnsCount = createKeyspaceGauge("MemtableColumnsCount", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return metric.memtableColumnsCount.getValue();
1:5b8ac8c:             }
1:5b8ac8c:         });
1:ae0f634:         memtableLiveDataSize = createKeyspaceGauge("MemtableLiveDataSize", new MetricValue()
1:5b8ac8c:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:5b8ac8c:             {
1:8896a70:                 return metric.memtableLiveDataSize.getValue();
1:ae0f634:             }
1:68d2526:         });
1:ae0f634:         memtableOnHeapDataSize = createKeyspaceGauge("MemtableOnHeapDataSize", new MetricValue()
1:ae0f634:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:ae0f634:             {
1:8896a70:                 return metric.memtableOnHeapSize.getValue();
1:5b8ac8c:             }
1:ae0f634:         });
1:ae0f634:         memtableOffHeapDataSize = createKeyspaceGauge("MemtableOffHeapDataSize", new MetricValue()
1:5b8ac8c:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:5b8ac8c:             {
1:8896a70:                 return metric.memtableOffHeapSize.getValue();
1:5b8ac8c:             }
1:5b8ac8c:         });
1:ae0f634:         allMemtablesLiveDataSize = createKeyspaceGauge("AllMemtablesLiveDataSize", new MetricValue()
1:94ff639:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:94ff639:             {
1:8896a70:                 return metric.allMemtablesLiveDataSize.getValue();
1:5b8ac8c:             }
1:94ff639:         });
1:ae0f634:         allMemtablesOnHeapDataSize = createKeyspaceGauge("AllMemtablesOnHeapDataSize", new MetricValue()
1:94ff639:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:94ff639:             {
1:8896a70:                 return metric.allMemtablesOnHeapSize.getValue();
1:94ff639:             }
1:94ff639:         });
1:ae0f634:         allMemtablesOffHeapDataSize = createKeyspaceGauge("AllMemtablesOffHeapDataSize", new MetricValue()
1:94ff639:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:94ff639:             {
1:8896a70:                 return metric.allMemtablesOffHeapSize.getValue();
1:94ff639:             }
1:9baae7b:         });
1:ae0f634:         memtableSwitchCount = createKeyspaceGauge("MemtableSwitchCount", new MetricValue()
1:94ff639:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return metric.memtableSwitchCount.getCount();
1:94ff639:             }
1:9baae7b:         });
1:ae0f634:         pendingCompactions = createKeyspaceGauge("PendingCompactions", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return (long) metric.pendingCompactions.getValue();
1:94ff639:             }
1:9baae7b:         });
1:ae0f634:         pendingFlushes = createKeyspaceGauge("PendingFlushes", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return (long) metric.pendingFlushes.getCount();
3:9baae7b:             }
1:9baae7b:         });
1:ae0f634:         liveDiskSpaceUsed = createKeyspaceGauge("LiveDiskSpaceUsed", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return metric.liveDiskSpaceUsed.getCount();
1:9baae7b:             }
7:68dd634:         });
1:ae0f634:         totalDiskSpaceUsed = createKeyspaceGauge("TotalDiskSpaceUsed", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return metric.totalDiskSpaceUsed.getCount();
1:9baae7b:             }
1:68dd634:         });
1:ae0f634:         bloomFilterDiskSpaceUsed = createKeyspaceGauge("BloomFilterDiskSpaceUsed", new MetricValue()
1:9baae7b:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:9baae7b:             {
1:8896a70:                 return metric.bloomFilterDiskSpaceUsed.getValue();
1:9baae7b:             }
1:68dd634:         });
1:7a14a77:         bloomFilterOffHeapMemoryUsed = createKeyspaceGauge("BloomFilterOffHeapMemoryUsed", new MetricValue()
1:7a14a77:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:7a14a77:             {
1:8896a70:                 return metric.bloomFilterOffHeapMemoryUsed.getValue();
1:7a14a77:             }
1:7a14a77:         });
1:7a14a77:         indexSummaryOffHeapMemoryUsed = createKeyspaceGauge("IndexSummaryOffHeapMemoryUsed", new MetricValue()
1:7a14a77:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:7a14a77:             {
1:8896a70:                 return metric.indexSummaryOffHeapMemoryUsed.getValue();
1:7a14a77:             }
1:7a14a77:         });
1:7a14a77:         compressionMetadataOffHeapMemoryUsed = createKeyspaceGauge("CompressionMetadataOffHeapMemoryUsed", new MetricValue()
1:7a14a77:         {
1:0bd5170:             public Long getValue(TableMetrics metric)
1:7a14a77:             {
1:8896a70:                 return metric.compressionMetadataOffHeapMemoryUsed.getValue();
1:7a14a77:             }
1:7a14a77:         });
1:0bd5170:         // latency metrics for TableMetrics to update
1:ae0f634:         readLatency = new LatencyMetrics(factory, "Read");
1:ae0f634:         writeLatency = new LatencyMetrics(factory, "Write");
1:ae0f634:         rangeLatency = new LatencyMetrics(factory, "Range");
1:0bd5170:         // create histograms for TableMetrics to replicate updates to
1:5aa19cb:         sstablesPerReadHistogram = Metrics.histogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
1:5aa19cb:         tombstoneScannedHistogram = Metrics.histogram(factory.createMetricName("TombstoneScannedHistogram"), false);
1:5aa19cb:         liveScannedHistogram = Metrics.histogram(factory.createMetricName("LiveScannedHistogram"), false);
1:5aa19cb:         colUpdateTimeDeltaHistogram = Metrics.histogram(factory.createMetricName("ColUpdateTimeDeltaHistogram"), false);
1:62ffa35:         viewLockAcquireTime =  Metrics.timer(factory.createMetricName("ViewLockAcquireTime"));
1:62ffa35:         viewReadTime = Metrics.timer(factory.createMetricName("ViewReadTime"));
1:ae0f634:         // add manually since histograms do not use createKeyspaceGauge method
1:ae0f634:         allMetrics.addAll(Lists.newArrayList("SSTablesPerReadHistogram", "TombstoneScannedHistogram", "LiveScannedHistogram"));
1:24d185d: 
1:1bd6960:         casPrepare = new LatencyMetrics(factory, "CasPrepare");
1:1bd6960:         casPropose = new LatencyMetrics(factory, "CasPropose");
1:1bd6960:         casCommit = new LatencyMetrics(factory, "CasCommit");
1:9baae7b:     }
1:3bdcaa3: 
1:5b8ac8c:     /**
1:68dd634:      * Release all associated metrics.
1:5b8ac8c:      */
1:68dd634:     public void release()
1:5b8ac8c:     {
1:68d2526:         for(String name : allMetrics)
1:ae0f634:         {
1:8896a70:             Metrics.remove(factory.createMetricName(name));
1:ae0f634:         }
1:ae0f634:         // latency metrics contain multiple metrics internally and need to be released manually
1:ae0f634:         readLatency.release();
1:ae0f634:         writeLatency.release();
1:ae0f634:         rangeLatency.release();
1:ae0f634:     }
1:68d2526: 
1:ae0f634:     /**
1:ae0f634:      * Represents a column family metric value.
1:ae0f634:      */
1:ae0f634:     private interface MetricValue
1:ae0f634:     {
1:ae0f634:         /**
1:ae0f634:          * get value of a metric
1:8896a70:          * @param metric of a column family in this keyspace
1:ae0f634:          * @return current value of a metric
1:ae0f634:          */
1:0bd5170:         public Long getValue(TableMetrics metric);
1:ae0f634:     }
1:ae0f634: 
1:ae0f634:     /**
1:ae0f634:      * Creates a gauge that will sum the current value of a metric for all column families in this keyspace
1:ae0f634:      * @param name
1:8896a70:      * @param extractor
1:ae0f634:      * @return Gauge&gt;Long> that computes sum of MetricValue.getValue()
1:ae0f634:      */
1:19b7d56:     private Gauge<Long> createKeyspaceGauge(String name, final MetricValue extractor)
1:ae0f634:     {
1:ae0f634:         allMetrics.add(name);
1:8896a70:         return Metrics.register(factory.createMetricName(name), new Gauge<Long>()
1:ae0f634:         {
1:8896a70:             public Long getValue()
1:ae0f634:             {
1:ae0f634:                 long sum = 0;
1:ae0f634:                 for (ColumnFamilyStore cf : keyspace.getColumnFamilyStores())
1:ae0f634:                 {
1:ae0f634:                     sum += extractor.getValue(cf.metric);
1:ae0f634:                 }
1:ae0f634:                 return sum;
1:ae0f634:             }
1:ae0f634:         });
1:5b8ac8c:     }
1:ae0f634: 
1:be13d35:     static class KeyspaceMetricNameFactory implements MetricNameFactory
1:5b8ac8c:     {
1:68dd634:         private final String keyspaceName;
1:ae0f634: 
1:68dd634:         KeyspaceMetricNameFactory(Keyspace ks)
1:5b8ac8c:         {
1:68dd634:             this.keyspaceName = ks.getName();
1:5b8ac8c:         }
1:ae0f634: 
1:8896a70:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
1:5b8ac8c:         {
1:0bd5170:             String groupName = TableMetrics.class.getPackage().getName();
1:ae0f634: 
1:68dd634:             StringBuilder mbeanName = new StringBuilder();
1:68dd634:             mbeanName.append(groupName).append(":");
1:68dd634:             mbeanName.append("type=Keyspace");
1:68dd634:             mbeanName.append(",keyspace=").append(keyspaceName);
1:68dd634:             mbeanName.append(",name=").append(metricName);
1:5b8ac8c: 
1:8896a70:             return new CassandraMetricsRegistry.MetricName(groupName, "keyspace", metricName, keyspaceName, mbeanName.toString());
1:94ff639:         }
1:94ff639:     }
1:9baae7b: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         });
/////////////////////////////////////////////////////////////////////////
1:         for(String name : allMetrics)
/////////////////////////////////////////////////////////////////////////
1: 
commit:be13d35
/////////////////////////////////////////////////////////////////////////
1:     static class KeyspaceMetricNameFactory implements MetricNameFactory
commit:19b7d56
/////////////////////////////////////////////////////////////////////////
1:     private Gauge<Long> createKeyspaceGauge(String name, final MetricValue extractor)
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:5aa19cb
/////////////////////////////////////////////////////////////////////////
1:         sstablesPerReadHistogram = Metrics.histogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
1:         tombstoneScannedHistogram = Metrics.histogram(factory.createMetricName("TombstoneScannedHistogram"), false);
1:         liveScannedHistogram = Metrics.histogram(factory.createMetricName("LiveScannedHistogram"), false);
1:         colUpdateTimeDeltaHistogram = Metrics.histogram(factory.createMetricName("ColUpdateTimeDeltaHistogram"), false);
commit:254cd85
commit:f7f4ddb
author:Chris Lohfink
-------------------------------------------------------------------------------
commit:62ffa35
/////////////////////////////////////////////////////////////////////////
1: import com.codahale.metrics.Timer;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** time taken acquiring the partition lock for materialized view updates on this keyspace */
1:     public final Timer viewLockAcquireTime;
1:     /** time taken during the local read of a materialized view update */
1:     public final Timer viewReadTime;
/////////////////////////////////////////////////////////////////////////
1:         viewLockAcquireTime =  Metrics.timer(factory.createMetricName("ViewLockAcquireTime"));
1:         viewReadTime = Metrics.timer(factory.createMetricName("ViewReadTime"));
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:3c43775
/////////////////////////////////////////////////////////////////////////
1: 
commit:8896a70
/////////////////////////////////////////////////////////////////////////
1: import com.codahale.metrics.Gauge;
1: import com.codahale.metrics.Histogram;
0: import com.codahale.metrics.MetricRegistry;
1: 
1: import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 return metric.memtableColumnsCount.getValue();
1:                 return metric.memtableLiveDataSize.getValue();
1:                 return metric.memtableOnHeapSize.getValue();
1:                 return metric.memtableOffHeapSize.getValue();
1:                 return metric.allMemtablesLiveDataSize.getValue();
1:                 return metric.allMemtablesOnHeapSize.getValue();
1:                 return metric.allMemtablesOffHeapSize.getValue();
1:                 return metric.memtableSwitchCount.getCount();
1:                 return (long) metric.pendingCompactions.getValue();
1:                 return (long) metric.pendingFlushes.getCount();
1:                 return metric.liveDiskSpaceUsed.getCount();
1:                 return metric.totalDiskSpaceUsed.getCount();
1:                 return metric.bloomFilterDiskSpaceUsed.getValue();
1:                 return metric.bloomFilterOffHeapMemoryUsed.getValue();
1:                 return metric.indexSummaryOffHeapMemoryUsed.getValue();
1:                 return metric.compressionMetadataOffHeapMemoryUsed.getValue();
/////////////////////////////////////////////////////////////////////////
0:         sstablesPerReadHistogram = Metrics.histogram(factory.createMetricName("SSTablesPerReadHistogram"));
0:         tombstoneScannedHistogram = Metrics.histogram(factory.createMetricName("TombstoneScannedHistogram"));
0:         liveScannedHistogram = Metrics.histogram(factory.createMetricName("LiveScannedHistogram"));
0:         colUpdateTimeDeltaHistogram = Metrics.histogram(factory.createMetricName("ColUpdateTimeDeltaHistogram"));
/////////////////////////////////////////////////////////////////////////
1:             Metrics.remove(factory.createMetricName(name));
/////////////////////////////////////////////////////////////////////////
1:          * @param metric of a column family in this keyspace
/////////////////////////////////////////////////////////////////////////
1:      * @param extractor
1:         return Metrics.register(factory.createMetricName(name), new Gauge<Long>()
1:             public Long getValue()
/////////////////////////////////////////////////////////////////////////
1:         public CassandraMetricsRegistry.MetricName createMetricName(String metricName)
/////////////////////////////////////////////////////////////////////////
1:             return new CassandraMetricsRegistry.MetricName(groupName, "keyspace", metricName, keyspaceName, mbeanName.toString());
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:24d185d
/////////////////////////////////////////////////////////////////////////
1:     
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:3bdcaa3
/////////////////////////////////////////////////////////////////////////
1: 
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:0bd5170
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and partitions overwritten. */
1:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and partitions overwritten. */
/////////////////////////////////////////////////////////////////////////
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:             public Long getValue(TableMetrics metric)
1:         // latency metrics for TableMetrics to update
1:         // create histograms for TableMetrics to replicate updates to
/////////////////////////////////////////////////////////////////////////
1:         public Long getValue(TableMetrics metric);
/////////////////////////////////////////////////////////////////////////
1:             String groupName = TableMetrics.class.getPackage().getName();
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:371ad9e
commit:9aaea24
author:blerer
-------------------------------------------------------------------------------
commit:7a14a77
/////////////////////////////////////////////////////////////////////////
1:     /** Off heap memory used by bloom filter */
1:     public final Gauge<Long> bloomFilterOffHeapMemoryUsed;
1:     /** Off heap memory used by index summary */
1:     public final Gauge<Long> indexSummaryOffHeapMemoryUsed;
1:     /** Off heap memory used by compression meta data*/
1:     public final Gauge<Long> compressionMetadataOffHeapMemoryUsed;
/////////////////////////////////////////////////////////////////////////
1:         bloomFilterOffHeapMemoryUsed = createKeyspaceGauge("BloomFilterOffHeapMemoryUsed", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.bloomFilterOffHeapMemoryUsed.value();
1:             }
1:         });
1:         indexSummaryOffHeapMemoryUsed = createKeyspaceGauge("IndexSummaryOffHeapMemoryUsed", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.indexSummaryOffHeapMemoryUsed.value();
1:             }
1:         });
1:         compressionMetadataOffHeapMemoryUsed = createKeyspaceGauge("CompressionMetadataOffHeapMemoryUsed", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.compressionMetadataOffHeapMemoryUsed.value();
1:             }
1:         });
author:Sankalp Kohli
-------------------------------------------------------------------------------
commit:e019760
/////////////////////////////////////////////////////////////////////////
1:     /** Column update time delta on this Keyspace */
1:     public final Histogram colUpdateTimeDeltaHistogram;
/////////////////////////////////////////////////////////////////////////
0:         colUpdateTimeDeltaHistogram = Metrics.newHistogram(factory.createMetricName("ColUpdateTimeDeltaHistogram"), true);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:1bd6960
/////////////////////////////////////////////////////////////////////////
1:     /** CAS Prepare metric */
1:     public final LatencyMetrics casPrepare;
1:     /** CAS Propose metrics */
1:     public final LatencyMetrics casPropose;
1:     /** CAS Commit metrics */
1:     public final LatencyMetrics casCommit;
/////////////////////////////////////////////////////////////////////////
1: 
1:         casPrepare = new LatencyMetrics(factory, "CasPrepare");
1:         casPropose = new LatencyMetrics(factory, "CasPropose");
1:         casCommit = new LatencyMetrics(factory, "CasCommit");
commit:4eb6535
commit:ca16e5b
/////////////////////////////////////////////////////////////////////////
0:     /** CAS Prepare metric */
0:     public final LatencyMetrics casPrepare;
0:     /** CAS Propose metrics */
0:     public final LatencyMetrics casPropose;
0:     /** CAS Commit metrics */
0:     public final LatencyMetrics casCommit;
/////////////////////////////////////////////////////////////////////////
1: 
0:         casPrepare = new LatencyMetrics(factory, "CasPrepare");
0:         casPropose = new LatencyMetrics(factory, "CasPropose");
0:         casCommit = new LatencyMetrics(factory, "CasCommit");
commit:ae0f634
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: import com.google.common.collect.Lists;
1: import com.google.common.collect.Sets;
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
1: 
1:     /** Total amount of live data stored in the memtable, excluding any data structure overhead */
1:     /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
1:     public final Gauge<Long> allMemtablesLiveDataSize;
1:     public final Gauge<Long> pendingFlushes;
1:     public final Gauge<Long> pendingCompactions;
1:     /** (Local) read metrics */
1:     public final LatencyMetrics readLatency;
1:     /** (Local) range slice metrics */
1:     public final LatencyMetrics rangeLatency;
1:     /** (Local) write metrics */
1:     public final LatencyMetrics writeLatency;
1:     /** Histogram of the number of sstable data files accessed per read */
1:     public final Histogram sstablesPerReadHistogram;
1:     /** Tombstones scanned in queries on this Keyspace */
1:     public final Histogram tombstoneScannedHistogram;
1:     /** Live cells scanned in queries on this Keyspace */
1:     public final Histogram liveScannedHistogram;
1:     
1:     public final MetricNameFactory factory;
1:     private Keyspace keyspace;
1:     
1:     /** set containing names of all the metrics stored here, for releasing later */
1:     private Set<String> allMetrics = Sets.newHashSet();
1:     
/////////////////////////////////////////////////////////////////////////
1:         keyspace = ks;
1:         memtableColumnsCount = createKeyspaceGauge("MemtableColumnsCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableColumnsCount.value();
1:         memtableLiveDataSize = createKeyspaceGauge("MemtableLiveDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableLiveDataSize.value();
1:             }
1:         }); 
1:         memtableOnHeapDataSize = createKeyspaceGauge("MemtableOnHeapDataSize", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.memtableOnHeapSize.value();
1:         memtableOffHeapDataSize = createKeyspaceGauge("MemtableOffHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableOffHeapSize.value();
1:         allMemtablesLiveDataSize = createKeyspaceGauge("AllMemtablesLiveDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesLiveDataSize.value();
1:         allMemtablesOnHeapDataSize = createKeyspaceGauge("AllMemtablesOnHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesOnHeapSize.value();
1:         allMemtablesOffHeapDataSize = createKeyspaceGauge("AllMemtablesOffHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesOffHeapSize.value();
1:         memtableSwitchCount = createKeyspaceGauge("MemtableSwitchCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableSwitchCount.count();
1:         pendingCompactions = createKeyspaceGauge("PendingCompactions", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return (long) metric.pendingCompactions.value();
1:         pendingFlushes = createKeyspaceGauge("PendingFlushes", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return (long) metric.pendingFlushes.count();
1:         liveDiskSpaceUsed = createKeyspaceGauge("LiveDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.liveDiskSpaceUsed.count();
1:         totalDiskSpaceUsed = createKeyspaceGauge("TotalDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.totalDiskSpaceUsed.count();
1:         bloomFilterDiskSpaceUsed = createKeyspaceGauge("BloomFilterDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.bloomFilterDiskSpaceUsed.value();
0:         // latency metrics for ColumnFamilyMetrics to update
1:         readLatency = new LatencyMetrics(factory, "Read");
1:         writeLatency = new LatencyMetrics(factory, "Write");
1:         rangeLatency = new LatencyMetrics(factory, "Range");
0:         // create histograms for ColumnFamilyMetrics to replicate updates to
0:         sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
0:         tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName("TombstoneScannedHistogram"), true);
0:         liveScannedHistogram = Metrics.newHistogram(factory.createMetricName("LiveScannedHistogram"), true);
1:         // add manually since histograms do not use createKeyspaceGauge method
1:         allMetrics.addAll(Lists.newArrayList("SSTablesPerReadHistogram", "TombstoneScannedHistogram", "LiveScannedHistogram"));
/////////////////////////////////////////////////////////////////////////
0:         for(String name : allMetrics) 
1:         {
0:             Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
1:         }
1:         // latency metrics contain multiple metrics internally and need to be released manually
1:         readLatency.release();
1:         writeLatency.release();
1:         rangeLatency.release();
1:     }
1:     
1:     /**
1:      * Represents a column family metric value.
1:      */
1:     private interface MetricValue
1:     {
1:         /**
1:          * get value of a metric
0:          * @param columnfamilymetrics of a column family in this keyspace
1:          * @return current value of a metric
1:          */
0:         public Long getValue(ColumnFamilyMetrics metric);
1:     }
1: 
1:     /**
1:      * Creates a gauge that will sum the current value of a metric for all column families in this keyspace
1:      * @param name
0:      * @param MetricValue 
1:      * @return Gauge&gt;Long> that computes sum of MetricValue.getValue()
1:      */
0:     private <T extends Number> Gauge<Long> createKeyspaceGauge(String name, final MetricValue extractor)
1:     {
1:         allMetrics.add(name);
0:         return Metrics.newGauge(factory.createMetricName(name), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
1:                 long sum = 0;
1:                 for (ColumnFamilyStore cf : keyspace.getColumnFamilyStores())
1:                 {
1:                     sum += extractor.getValue(cf.metric);
1:                 }
1:                 return sum;
1:             }
1:         });
commit:5b8ac8c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import com.google.common.collect.Lists;
0: import com.google.common.collect.Sets;
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
1: 
/////////////////////////////////////////////////////////////////////////
0:     public final Gauge<Long> pendingFlushes;
0:     public final Gauge<Long> pendingCompactions;
0:     /** (Local) read metrics */
0:     public final LatencyMetrics readLatency;
0:     /** (Local) range slice metrics */
0:     public final LatencyMetrics rangeLatency;
0:     /** (Local) write metrics */
0:     public final LatencyMetrics writeLatency;
0:     /** Histogram of the number of sstable data files accessed per read */
0:     public final Histogram sstablesPerReadHistogram;
0:     /** Tombstones scanned in queries on this Keyspace */
0:     public final Histogram tombstoneScannedHistogram;
0:     /** Live cells scanned in queries on this Keyspace */
0:     public final Histogram liveScannedHistogram;
0:     
0:     public final MetricNameFactory factory;
0:     private Keyspace keyspace;
0:     
0:     /** set containing names of all the metrics stored here, for releasing later */
0:     private Set<String> allMetrics = Sets.newHashSet();
0:     
/////////////////////////////////////////////////////////////////////////
0:         keyspace = ks;
0:         memtableColumnsCount = createKeyspaceGauge("MemtableColumnsCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableColumnsCount.value();
0:         memtableLiveDataSize = createKeyspaceGauge("MemtableLiveDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableLiveDataSize.value();
1:             }
1:         }); 
0:         memtableOnHeapDataSize = createKeyspaceGauge("MemtableOnHeapDataSize", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.memtableOnHeapSize.value();
0:         memtableOffHeapDataSize = createKeyspaceGauge("MemtableOffHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableOffHeapSize.value();
0:         allMemtablesLiveDataSize = createKeyspaceGauge("AllMemtablesLiveDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesLiveDataSize.value();
0:         allMemtablesOnHeapDataSize = createKeyspaceGauge("AllMemtablesOnHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesOnHeapSize.value();
0:         allMemtablesOffHeapDataSize = createKeyspaceGauge("AllMemtablesOffHeapDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.allMemtablesOffHeapSize.value();
0:         memtableSwitchCount = createKeyspaceGauge("MemtableSwitchCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableSwitchCount.count();
0:         pendingCompactions = createKeyspaceGauge("PendingCompactions", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return (long) metric.pendingCompactions.value();
0:         pendingFlushes = createKeyspaceGauge("PendingFlushes", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return (long) metric.pendingFlushes.count();
0:         liveDiskSpaceUsed = createKeyspaceGauge("LiveDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.liveDiskSpaceUsed.count();
0:         totalDiskSpaceUsed = createKeyspaceGauge("TotalDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.totalDiskSpaceUsed.count();
0:         bloomFilterDiskSpaceUsed = createKeyspaceGauge("BloomFilterDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.bloomFilterDiskSpaceUsed.value();
0:         // latency metrics for ColumnFamilyMetrics to update
0:         readLatency = new LatencyMetrics(factory, "Read");
0:         writeLatency = new LatencyMetrics(factory, "Write");
0:         rangeLatency = new LatencyMetrics(factory, "Range");
0:         // create histograms for ColumnFamilyMetrics to replicate updates to
0:         sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
0:         tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName("TombstoneScannedHistogram"), true);
0:         liveScannedHistogram = Metrics.newHistogram(factory.createMetricName("LiveScannedHistogram"), true);
0:         // add manually since histograms do not use createKeyspaceGauge method
0:         allMetrics.addAll(Lists.newArrayList("SSTablesPerReadHistogram", "TombstoneScannedHistogram", "LiveScannedHistogram"));
/////////////////////////////////////////////////////////////////////////
0:         for(String name : allMetrics) 
1:         {
0:             Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
1:         }
0:         // latency metrics contain multiple metrics internally and need to be released manually
0:         readLatency.release();
0:         writeLatency.release();
0:         rangeLatency.release();
1:     }
0:     
1:     /**
0:      * Represents a column family metric value.
1:      */
0:     private interface MetricValue
1:     {
1:         /**
0:          * get value of a metric
0:          * @param columnfamilymetrics of a column family in this keyspace
0:          * @return current value of a metric
1:          */
0:         public Long getValue(ColumnFamilyMetrics metric);
1:     }
0: 
1:     /**
0:      * Creates a gauge that will sum the current value of a metric for all column families in this keyspace
0:      * @param name
0:      * @param MetricValue 
0:      * @return Gauge&gt;Long> that computes sum of MetricValue.getValue()
1:      */
0:     private <T extends Number> Gauge<Long> createKeyspaceGauge(String name, final MetricValue extractor)
1:     {
0:         allMetrics.add(name);
0:         return Metrics.newGauge(factory.createMetricName(name), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : keyspace.getColumnFamilyStores())
1:                 {
0:                     sum += extractor.getValue(cf.metric);
1:                 }
0:                 return sum;
1:             }
1:         });
commit:94ff639
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import com.google.common.collect.Lists;
0: import com.google.common.collect.Sets;
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public final Gauge<Long> pendingCompactions;
0:     /** (Local) read metrics */
0:     public final LatencyMetrics readLatency;
0:     /** (Local) range slice metrics */
0:     public final LatencyMetrics rangeLatency;
0:     /** (Local) write metrics */
0:     public final LatencyMetrics writeLatency;
0:     /** Histogram of the number of sstable data files accessed per read */
0:     public final Histogram sstablesPerReadHistogram;
0:     /** Tombstones scanned in queries on this Keyspace */
0:     public final Histogram tombstoneScannedHistogram;
0:     /** Live cells scanned in queries on this Keyspace */
0:     public final Histogram liveScannedHistogram;
0:     private Keyspace keyspace;
0:     
0:     /** set containing names of all the metrics stored here, for releasing later */
0:     private Set<String> allMetrics = Sets.newHashSet();
0:     
/////////////////////////////////////////////////////////////////////////
0:         keyspace = ks;
0:         memtableColumnsCount = createKeyspaceGauge("MemtableColumnsCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableColumnsCount.value();
0:         memtableDataSize = createKeyspaceGauge("MemtableDataSize", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableDataSize.value();
1:             }
1:         }); 
0:         allMemtablesDataSize = createKeyspaceGauge("AllMemtablesDataSize", new MetricValue()
1:         {
0:             public Long getValue(ColumnFamilyMetrics metric)
1:             {
0:                 return metric.allMemtablesDataSize.value();
0:         memtableSwitchCount = createKeyspaceGauge("MemtableSwitchCount", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.memtableSwitchCount.count();
0:         pendingCompactions = createKeyspaceGauge("PendingCompactions", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return (long) metric.pendingCompactions.value();
/////////////////////////////////////////////////////////////////////////
0:         liveDiskSpaceUsed = createKeyspaceGauge("LiveDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.liveDiskSpaceUsed.count();
0:         totalDiskSpaceUsed = createKeyspaceGauge("TotalDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.totalDiskSpaceUsed.count();
0:         bloomFilterDiskSpaceUsed = createKeyspaceGauge("BloomFilterDiskSpaceUsed", new MetricValue()
0:             public Long getValue(ColumnFamilyMetrics metric)
0:                 return metric.bloomFilterDiskSpaceUsed.value();
0:         // latency metrics for ColumnFamilyMetrics to update
0:         readLatency = new LatencyMetrics(factory, "Read");
0:         writeLatency = new LatencyMetrics(factory, "Write");
0:         rangeLatency = new LatencyMetrics(factory, "Range");
0:         // create histograms for ColumnFamilyMetrics to replicate updates to
0:         sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName("SSTablesPerReadHistogram"), true);
0:         tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName("TombstoneScannedHistogram"), true);
0:         liveScannedHistogram = Metrics.newHistogram(factory.createMetricName("LiveScannedHistogram"), true);
0:         // add manually since histograms do not use createKeyspaceGauge method
0:         allMetrics.addAll(Lists.newArrayList("SSTablesPerReadHistogram", "TombstoneScannedHistogram", "LiveScannedHistogram"));
/////////////////////////////////////////////////////////////////////////
0:         for(String name : allMetrics) 
1:         {
0:             Metrics.defaultRegistry().removeMetric(factory.createMetricName(name));
1:         }
0:         // latency metrics contain multiple metrics internally and need to be released manually
0:         readLatency.release();
0:         writeLatency.release();
0:         rangeLatency.release();
1:     }
0:     
0:     /**
0:      * Represents a column family metric value.
1:      */
0:     private interface MetricValue
1:     {
0:         /**
0:          * get value of a metric
0:          * @param columnfamilymetrics of a column family in this keyspace
0:          * @return current value of a metric
1:          */
0:         public Long getValue(ColumnFamilyMetrics metric);
1:     }
0: 
0:     /**
0:      * Creates a gauge that will sum the current value of a metric for all column families in this keyspace
0:      * @param name
0:      * @param MetricValue 
0:      * @return Gauge&gt;Long> that computes sum of MetricValue.getValue()
1:      */
0:     private <T extends Number> Gauge<Long> createKeyspaceGauge(String name, final MetricValue extractor)
1:     {
0:         allMetrics.add(name);
0:         return Metrics.newGauge(factory.createMetricName(name), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : keyspace.getColumnFamilyStores())
1:                 {
0:                     sum += extractor.getValue(cf.metric);
1:                 }
0:                 return sum;
1:             }
1:         });
commit:b47d8a8
commit:a8f5278
/////////////////////////////////////////////////////////////////////////
0:         memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOffHeapDataSize"), new Gauge<Long>()
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
commit:7765e0e
commit:9baae7b
/////////////////////////////////////////////////////////////////////////
0:     /** Total amount of live data stored in the memtable, excluding any data structure overhead */
1:     public final Gauge<Long> memtableLiveDataSize;
0:     /** Total amount of data stored in the memtable that resides on-heap, including column related overhead and overwritten rows. */
1:     public final Gauge<Long> memtableOnHeapDataSize;
0:     /** Total amount of data stored in the memtable that resides off-heap, including column related overhead and overwritten rows. */
1:     public final Gauge<Long> memtableOffHeapDataSize;
0:     /** Total amount of live data stored in the memtables (2i and pending flush memtables included) that resides off-heap, excluding any data structure overhead */
0:     public final Gauge<Long> allMemtablesLiveDataSize;
1:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides on-heap. */
1:     public final Gauge<Long> allMemtablesOnHeapDataSize;
1:     /** Total amount of data stored in the memtables (2i and pending flush memtables included) that resides off-heap. */
1:     public final Gauge<Long> allMemtablesOffHeapDataSize;
0:     public final Gauge<Integer> pendingFlushes;
/////////////////////////////////////////////////////////////////////////
0:         memtableLiveDataSize = Metrics.newGauge(factory.createMetricName("MemtableLiveDataSize"), new Gauge<Long>()
0:                     total += cf.metric.memtableLiveDataSize.value();
0:         memtableOnHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOnHeapDataSize"), new Gauge<Long>()
0:                     total += cf.metric.memtableOnHeapSize.value();
1:                 }
0:                 return total;
1:             }
1:         });
0:         memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableiOffHeapDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.memtableOffHeapSize.value();
1:                 }
0:                 return total;
1:             }
1:         });
0:         allMemtablesLiveDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesLiveDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.allMemtablesLiveDataSize.value();
1:                 }
0:                 return total;
1:             }
1:         });
0:         allMemtablesOnHeapDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesOnHeapDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.allMemtablesOnHeapSize.value();
1:                 }
0:                 return total;
1:             }
1:         });
0:         allMemtablesOffHeapDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesOffHeapDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.allMemtablesOffHeapSize.value();
/////////////////////////////////////////////////////////////////////////
0:         pendingFlushes = Metrics.newGauge(factory.createMetricName("PendingFlushes"), new Gauge<Integer>()
0:                 int sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     sum += cf.metric.pendingFlushes.count();
0:                 }
0:                 return sum;
/////////////////////////////////////////////////////////////////////////
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDateSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOnHeapDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOffHeapDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableLiveDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOnHeapDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOffHeapDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingFlushes"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingCompactions"));
commit:3aa0305
commit:68dd634
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.cassandra.metrics;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: 
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: import com.yammer.metrics.stats.Snapshot;
0: 
1: import org.apache.cassandra.db.ColumnFamilyStore;
1: import org.apache.cassandra.db.Keyspace;
0: 
0: /**
1:  * Metrics for {@link ColumnFamilyStore}.
0:  */
1: public class KeyspaceMetrics
1: {
0:     /** Total amount of data stored in the memtable, including column related overhead. */
0:     public final Gauge<Long> memtableDataSize;
0:     /** Total amount of data stored in the memtables (2i and pending flush memtables included). */
0:     public final Gauge<Long> allMemtablesDataSize;
1:     /** Total number of columns present in the memtable. */
1:     public final Gauge<Long> memtableColumnsCount;
1:     /** Number of times flush has resulted in the memtable being switched out. */
1:     public final Gauge<Long> memtableSwitchCount;
1:     /** Estimated number of tasks pending for this column family */
0:     public final Gauge<Integer> pendingTasks;
1:     /** Estimate of number of pending compactios for this CF */
0:     public final Gauge<Integer> pendingCompactions;
1:     /** Disk space used by SSTables belonging to this CF */
1:     public final Gauge<Long> liveDiskSpaceUsed;
1:     /** Total disk space used by SSTables belonging to this CF, including obsolete ones waiting to be GC'd */
1:     public final Gauge<Long> totalDiskSpaceUsed;
1:     /** Disk space used by bloom filter */
1:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
0: 
0:     private final MetricNameFactory factory;
0: 
0:     /**
1:      * Creates metrics for given {@link ColumnFamilyStore}.
1:      *
1:      * @param ks Keyspace to measure metrics
0:      */
1:     public KeyspaceMetrics(final Keyspace ks)
1:     {
1:         factory = new KeyspaceMetricNameFactory(ks);
0: 
0:         memtableColumnsCount = Metrics.newGauge(factory.createMetricName("MemtableColumnsCount"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.memtableColumnsCount.value();
0:                 }
0:                 return total;
0:             }
1:         });
0:         memtableDataSize = Metrics.newGauge(factory.createMetricName("MemtableDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.memtableDataSize.value();
0:                 }
0:                 return total;
0:             }
1:         });
0:         allMemtablesDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesDataSize"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     total += cf.metric.allMemtablesDataSize.value();
0:                 }
0:                 return total;
0:             }
1:         });
0:         memtableSwitchCount = Metrics.newGauge(factory.createMetricName("MemtableSwitchCount"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     sum += cf.metric.memtableSwitchCount.count();
0:                 return sum;
0:             }
1:         });
0:         pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
1:         {
0:             public Integer value()
1:             {
0:                 int sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     sum += cf.metric.pendingCompactions.value();
0:                 }
0:                 return sum;
0:             }
1:         });
0:         pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
1:         {
0:             public Integer value()
1:             {
0:                 return Keyspace.switchLock.getQueueLength();
0:             }
1:         });
0:         liveDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("LiveDiskSpaceUsed"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     sum += cf.metric.liveDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
1:         });
0:         totalDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("TotalDiskSpaceUsed"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
1:                 {
0:                     sum += cf.metric.totalDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
1:         });
0:         bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("BloomFilterDiskSpaceUsed"), new Gauge<Long>()
1:         {
0:             public Long value()
1:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     total += cf.metric.bloomFilterDiskSpaceUsed.value();
0:                 return total;
0:             }
1:         });
0:     }
0: 
0:     /**
1:      * Release all associated metrics.
0:      */
1:     public void release()
1:     {
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
0:     }
0: 
0:     class KeyspaceMetricNameFactory implements MetricNameFactory
1:     {
1:         private final String keyspaceName;
0: 
1:         KeyspaceMetricNameFactory(Keyspace ks)
1:         {
1:             this.keyspaceName = ks.getName();
0:         }
0: 
0:         public MetricName createMetricName(String metricName)
1:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName();
0: 
1:             StringBuilder mbeanName = new StringBuilder();
1:             mbeanName.append(groupName).append(":");
1:             mbeanName.append("type=Keyspace");
1:             mbeanName.append(",keyspace=").append(keyspaceName);
1:             mbeanName.append(",name=").append(metricName);
0: 
0:             return new MetricName(groupName, "keyspace", metricName, keyspaceName, mbeanName.toString());
0:         }
0:     }
0: }
commit:cecd1da
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.cassandra.metrics;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: 
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: import com.yammer.metrics.stats.Snapshot;
0: 
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.Keyspace;
0: 
0: /**
0:  * Metrics for {@link ColumnFamilyStore}.
0:  */
0: public class KeyspaceMetrics
0: {
0:     /** Total amount of data stored in the memtable, including column related overhead. */
0:     public final Gauge<Long> memtableDataSize;
0:     /** Total amount of data stored in the memtables (2i and pending flush memtables included). */
0:     public final Gauge<Long> allMemtablesDataSize;
0:     /** Total number of columns present in the memtable. */
0:     public final Gauge<Long> memtableColumnsCount;
0:     /** Number of times flush has resulted in the memtable being switched out. */
0:     public final Gauge<Long> memtableSwitchCount;
0:     /** Estimated number of tasks pending for this column family */
0:     public final Gauge<Integer> pendingTasks;
0:     /** Estimate of number of pending compactios for this CF */
0:     public final Gauge<Integer> pendingCompactions;
0:     /** Disk space used by SSTables belonging to this CF */
0:     public final Gauge<Long> liveDiskSpaceUsed;
0:     /** Total disk space used by SSTables belonging to this CF, including obsolete ones waiting to be GC'd */
0:     public final Gauge<Long> totalDiskSpaceUsed;
0:     /** Disk space used by bloom filter */
0:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
0: 
0:     private final MetricNameFactory factory;
0: 
0:     /**
0:      * Creates metrics for given {@link ColumnFamilyStore}.
0:      *
0:      * @param ks Keyspace to measure metrics
0:      */
0:     public KeyspaceMetrics(final Keyspace ks)
0:     {
0:         factory = new KeyspaceMetricNameFactory(ks);
0: 
0:         memtableColumnsCount = Metrics.newGauge(factory.createMetricName("MemtableColumnsCount"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.memtableColumnsCount.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         memtableDataSize = Metrics.newGauge(factory.createMetricName("MemtableDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.memtableDataSize.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         allMemtablesDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.allMemtablesDataSize.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         memtableSwitchCount = Metrics.newGauge(factory.createMetricName("MemtableSwitchCount"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     sum += cf.metric.memtableSwitchCount.count();
0:                 return sum;
0:             }
0:         });
0:         pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 int sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.pendingCompactions.value();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 return Keyspace.switchLock.getQueueLength();
0:             }
0:         });
0:         liveDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("LiveDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.liveDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         totalDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("TotalDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.totalDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("BloomFilterDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     total += cf.metric.bloomFilterDiskSpaceUsed.value();
0:                 return total;
0:             }
0:         });
0:     }
0: 
0:     /**
0:      * Release all associated metrics.
0:      */
0:     public void release()
0:     {
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
0:     }
0: 
0:     class KeyspaceMetricNameFactory implements MetricNameFactory
0:     {
0:         private final String keyspaceName;
0: 
0:         KeyspaceMetricNameFactory(Keyspace ks)
0:         {
0:             this.keyspaceName = ks.getName();
0:         }
0: 
0:         public MetricName createMetricName(String metricName)
0:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName();
0: 
0:             StringBuilder mbeanName = new StringBuilder();
0:             mbeanName.append(groupName).append(":");
0:             mbeanName.append("type=Keyspace");
0:             mbeanName.append(",keyspace=").append(keyspaceName);
0:             mbeanName.append(",name=").append(metricName);
0: 
0:             return new MetricName(groupName, "keyspace", metricName, keyspaceName, mbeanName.toString());
0:         }
0:     }
0: }
commit:5871b26
commit:bbd130e
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.cassandra.metrics;
0: 
0: import java.util.ArrayList;
0: import java.util.List;
0: 
0: import com.yammer.metrics.Metrics;
0: import com.yammer.metrics.core.*;
0: import com.yammer.metrics.stats.Snapshot;
0: 
0: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.db.Keyspace;
0: 
0: /**
0:  * Metrics for {@link ColumnFamilyStore}.
0:  */
0: public class KeyspaceMetrics
0: {
0:     /** Total amount of data stored in the memtable, including column related overhead. */
0:     public final Gauge<Long> memtableDataSize;
0:     /** Total amount of data stored in the memtables (2i and pending flush memtables included). */
0:     public final Gauge<Long> allMemtablesDataSize;
0:     /** Total number of columns present in the memtable. */
0:     public final Gauge<Long> memtableColumnsCount;
0:     /** Number of times flush has resulted in the memtable being switched out. */
0:     public final Gauge<Long> memtableSwitchCount;
0:     /** Estimated number of tasks pending for this column family */
0:     public final Gauge<Integer> pendingTasks;
0:     /** Estimate of number of pending compactios for this CF */
0:     public final Gauge<Integer> pendingCompactions;
0:     /** Disk space used by SSTables belonging to this CF */
0:     public final Gauge<Long> liveDiskSpaceUsed;
0:     /** Total disk space used by SSTables belonging to this CF, including obsolete ones waiting to be GC'd */
0:     public final Gauge<Long> totalDiskSpaceUsed;
0:     /** Disk space used by bloom filter */
0:     public final Gauge<Long> bloomFilterDiskSpaceUsed;
0: 
0:     private final MetricNameFactory factory;
0: 
0:     /**
0:      * Creates metrics for given {@link ColumnFamilyStore}.
0:      *
0:      * @param ks Keyspace to measure metrics
0:      */
0:     public KeyspaceMetrics(final Keyspace ks)
0:     {
0:         factory = new KeyspaceMetricNameFactory(ks);
0: 
0:         memtableColumnsCount = Metrics.newGauge(factory.createMetricName("MemtableColumnsCount"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.memtableColumnsCount.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         memtableDataSize = Metrics.newGauge(factory.createMetricName("MemtableDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.memtableDataSize.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         allMemtablesDataSize = Metrics.newGauge(factory.createMetricName("AllMemtablesDataSize"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     total += cf.metric.allMemtablesDataSize.value();
0:                 }
0:                 return total;
0:             }
0:         });
0:         memtableSwitchCount = Metrics.newGauge(factory.createMetricName("MemtableSwitchCount"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     sum += cf.metric.memtableSwitchCount.count();
0:                 return sum;
0:             }
0:         });
0:         pendingCompactions = Metrics.newGauge(factory.createMetricName("PendingCompactions"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 int sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.pendingCompactions.value();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         pendingTasks = Metrics.newGauge(factory.createMetricName("PendingTasks"), new Gauge<Integer>()
0:         {
0:             public Integer value()
0:             {
0:                 return Keyspace.switchLock.getQueueLength();
0:             }
0:         });
0:         liveDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("LiveDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.liveDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         totalDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("TotalDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long sum = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                 {
0:                     sum += cf.metric.totalDiskSpaceUsed.count();
0:                 }
0:                 return sum;
0:             }
0:         });
0:         bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName("BloomFilterDiskSpaceUsed"), new Gauge<Long>()
0:         {
0:             public Long value()
0:             {
0:                 long total = 0;
0:                 for (ColumnFamilyStore cf : ks.getColumnFamilyStores())
0:                     total += cf.metric.bloomFilterDiskSpaceUsed.value();
0:                 return total;
0:             }
0:         });
0:     }
0: 
0:     /**
0:      * Release all associated metrics.
0:      */
0:     public void release()
0:     {
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingTasks"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TotalDiskSpaceUsed"));
0:         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
0:     }
0: 
0:     class KeyspaceMetricNameFactory implements MetricNameFactory
0:     {
0:         private final String keyspaceName;
0: 
0:         KeyspaceMetricNameFactory(Keyspace ks)
0:         {
0:             this.keyspaceName = ks.getName();
0:         }
0: 
0:         public MetricName createMetricName(String metricName)
0:         {
0:             String groupName = ColumnFamilyMetrics.class.getPackage().getName();
0: 
0:             StringBuilder mbeanName = new StringBuilder();
0:             mbeanName.append(groupName).append(":");
0:             mbeanName.append("type=Keyspace");
0:             mbeanName.append(",keyspace=").append(keyspaceName);
0:             mbeanName.append(",name=").append(metricName);
0: 
0:             return new MetricName(groupName, "keyspace", metricName, keyspaceName, mbeanName.toString());
0:         }
0:     }
0: }
============================================================================