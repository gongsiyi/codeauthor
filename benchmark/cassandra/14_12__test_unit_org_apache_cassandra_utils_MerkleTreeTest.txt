1:c270904: /*
1:c270904: * Licensed to the Apache Software Foundation (ASF) under one
1:c270904: * or more contributor license agreements.  See the NOTICE file
1:c270904: * distributed with this work for additional information
1:c270904: * regarding copyten ownership.  The ASF licenses this file
1:c270904: * to you under the Apache License, Version 2.0 (the
1:c270904: * "License"); you may not use this file except in compliance
1:c270904: * with the License.  You may obtain a copy of the License at
1:c270904: *
1:c270904: *    http://www.apache.org/licenses/LICENSE-2.0
1:c270904: *
1:c270904: * Unless required by applicable law or agreed to in writing,
1:c270904: * software distributed under the License is distributed on an
1:c270904: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:c270904: * KIND, either express or implied.  See the License for the
1:c270904: * specific language governing permissions and limitations
1:c270904: * under the License.
1:c270904: */
1:c270904: package org.apache.cassandra.utils;
1:e7a385a: 
1:c270904: import java.math.BigInteger;
1:eb4fa4a: import java.util.*;
1:03f72ac: 
1:489a9e8: import org.apache.cassandra.utils.AbstractIterator;
1:a991b64: 
1:e7a385a: import org.junit.Before;
1:e7a385a: import org.junit.Test;
1:eb4fa4a: import org.apache.cassandra.config.DatabaseDescriptor;
1:e7a385a: import org.apache.cassandra.dht.IPartitioner;
1:e7a385a: import org.apache.cassandra.dht.RandomPartitioner;
1:07893d7: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:e7a385a: import org.apache.cassandra.dht.Range;
1:e7a385a: import org.apache.cassandra.dht.Token;
1:c4c9eae: import org.apache.cassandra.io.util.DataInputBuffer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputBuffer;
1:eb4fa4a: import org.apache.cassandra.net.MessagingService;
1:e7a385a: import org.apache.cassandra.utils.MerkleTree.Hashable;
1:e7a385a: import org.apache.cassandra.utils.MerkleTree.RowHash;
1:e7a385a: import org.apache.cassandra.utils.MerkleTree.TreeRange;
1:e7a385a: import org.apache.cassandra.utils.MerkleTree.TreeRangeIterator;
1:07cdfd0: 
1:e7a385a: import static org.apache.cassandra.utils.MerkleTree.RECOMMENDED_DEPTH;
1:eb4fa4a: import static org.junit.Assert.*;
1:07cdfd0: 
1:c270904: public class MerkleTreeTest
3:c270904: {
1:c270904:     public static byte[] DUMMY = "blah".getBytes();
1:2fd3268: 
1:c270904:     /**
1:c270904:      * If a test assumes that the tree is 8 units wide, then it should set this value
1:c270904:      * to 8.
1:c270904:      */
1:c270904:     public static BigInteger TOKEN_SCALE = new BigInteger("8");
1:2fd3268: 
1:c270904:     protected IPartitioner partitioner;
1:c270904:     protected MerkleTree mt;
1:2fd3268: 
1:eb4fa4a:     private Range<Token> fullRange()
1:dc89826:     {
1:eb4fa4a:         return new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
1:dc89826:     }
1:2fd3268: 
1:c270904:     @Before
1:c270904:     public void clear()
1:c270904:     {
1:c270904:         TOKEN_SCALE = new BigInteger("8");
1:07893d7:         partitioner = RandomPartitioner.instance;
1:eb4fa4a:         // TODO need to trickle TokenSerializer
1:0a08525:         DatabaseDescriptor.setPartitionerUnsafe(partitioner);
1:dc89826:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
3:c270904:     }
1:2fd3268: 
1:c270904:     public static void assertHashEquals(final byte[] left, final byte[] right)
1:c270904:     {
1:c270904:         assertHashEquals("", left, right);
1:c270904:     }
1:2fd3268: 
1:c270904:     public static void assertHashEquals(String message, final byte[] left, final byte[] right)
1:c270904:     {
1:2ede7fc:         String lstring = left == null ? "null" : Hex.bytesToHex(left);
1:2ede7fc:         String rstring = right == null ? "null" : Hex.bytesToHex(right);
1:c270904:         assertEquals(message, lstring, rstring);
1:c270904:     }
1:2fd3268: 
1:c270904:     /**
1:c270904:      * The value returned by this method is affected by TOKEN_SCALE: setting TOKEN_SCALE
1:0fd507b:      * to 8 means that passing -1 through 8 for this method will return values mapped
1:0fd507b:      * between -1 and Token.MAX_VALUE.
1:c270904:      */
1:eb4fa4a:     public static Token tok(int i)
1:c270904:     {
1:0fd507b:         if (i == -1)
1:0fd507b:             return new BigIntegerToken(new BigInteger("-1"));
1:9a5c679:         BigInteger bint = RandomPartitioner.MAXIMUM.divide(TOKEN_SCALE).multiply(new BigInteger(""+i));
1:c270904:         return new BigIntegerToken(bint);
1:c270904:     }
1:dc89826: 
3:c270904:     @Test
1:c270904:     public void testSplit()
1:c270904:     {
1:c270904:         // split the range  (zero, zero] into:
1:c270904:         //  (zero,four], (four,six], (six,seven] and (seven, zero]
3:c270904:         mt.split(tok(4));
2:c270904:         mt.split(tok(6));
2:c270904:         mt.split(tok(7));
1:2fd3268: 
2:c270904:         assertEquals(4, mt.size());
1:eb4fa4a:         assertEquals(new Range<>(tok(7), tok(-1)), mt.get(tok(-1)));
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(3)));
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(4)));
1:eb4fa4a:         assertEquals(new Range<>(tok(4), tok(6)), mt.get(tok(6)));
1:eb4fa4a:         assertEquals(new Range<>(tok(6), tok(7)), mt.get(tok(7)));
1:18f0234: 
1:c270904:         // check depths
1:c270904:         assertEquals((byte)1, mt.get(tok(4)).depth);
1:c270904:         assertEquals((byte)2, mt.get(tok(6)).depth);
1:c270904:         assertEquals((byte)3, mt.get(tok(7)).depth);
1:0fd507b:         assertEquals((byte)3, mt.get(tok(-1)).depth);
1:eb4fa4a: 
1:c270904:         try
1:c270904:         {
1:c270904:             mt.split(tok(-1));
1:c270904:             fail("Shouldn't be able to split outside the initial range.");
1:c270904:         }
1:c270904:         catch (AssertionError e)
1:c270904:         {
1:c270904:             // pass
1:c270904:         }
1:c270904:     }
53:c270904: 
1:c270904:     @Test
1:c270904:     public void testSplitLimitDepth()
1:c270904:     {
1:dc89826:         mt = new MerkleTree(partitioner, fullRange(), (byte)2, Integer.MAX_VALUE);
1:c270904: 
1:c270904:         assertTrue(mt.split(tok(4)));
1:c270904:         assertTrue(mt.split(tok(2)));
2:c270904:         assertEquals(3, mt.size());
1:07cdfd0: 
1:c270904:         // should fail to split below hashdepth
1:c270904:         assertFalse(mt.split(tok(1)));
1:c270904:         assertEquals(3, mt.size());
1:eb4fa4a:         assertEquals(new Range<>(tok(4), tok(-1)), mt.get(tok(-1)));
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(2)), mt.get(tok(2)));
1:eb4fa4a:         assertEquals(new Range<>(tok(2), tok(4)), mt.get(tok(4)));
1:c270904:     }
1:2fd3268: 
1:c270904:     @Test
1:c270904:     public void testSplitLimitSize()
1:c270904:     {
1:dc89826:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, 2);
1:c270904: 
1:c270904:         assertTrue(mt.split(tok(4)));
2:c270904:         assertEquals(2, mt.size());
1:07cdfd0: 
1:c270904:         // should fail to split above maxsize
1:c270904:         assertFalse(mt.split(tok(2)));
1:c270904:         assertEquals(2, mt.size());
1:eb4fa4a:         assertEquals(new Range<>(tok(4), tok(-1)), mt.get(tok(-1)));
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(4)));
1:c270904:     }
1:c270904: 
1:c270904:     @Test
1:c270904:     public void testInvalids()
1:c270904:     {
1:c270904:         Iterator<TreeRange> ranges;
1:07cdfd0: 
1:c270904:         // (zero, zero]
1:dc89826:         ranges = mt.invalids();
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(-1)), ranges.next());
4:c270904:         assertFalse(ranges.hasNext());
1:2fd3268: 
1:c270904:         // all invalid
1:c270904:         mt.split(tok(4));
2:c270904:         mt.split(tok(2));
1:c270904:         mt.split(tok(6));
2:c270904:         mt.split(tok(3));
2:c270904:         mt.split(tok(5));
1:dc89826:         ranges = mt.invalids();
1:eb4fa4a:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(-1), tok(2)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(2), tok(3)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(3), tok(4)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(4), tok(5)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(5), tok(6)), ranges.next());
1:eb4fa4a:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:c270904:         assertFalse(ranges.hasNext());
1:c270904:     }
1:2fd3268: 
1:dc89826: 
1:c270904:     @Test
1:c270904:     public void testHashFull()
1:c270904:     {
2:c270904:         byte[] val = DUMMY;
1:eb4fa4a:         Range<Token> range = new Range<>(tok(-1), tok(-1));
1:c270904: 
1:c270904:         // (zero, zero]
1:c270904:         assertNull(mt.hash(range));
1:07cdfd0: 
1:c270904:         // validate the range
1:0fd507b:         mt.get(tok(-1)).hash(val);
1:07cdfd0: 
1:c270904:         assertHashEquals(val, mt.hash(range));
1:c270904:     }
1:2fd3268: 
1:c270904:     @Test
1:c270904:     public void testHashPartial()
1:c270904:     {
1:c270904:         byte[] val = DUMMY;
1:c270904:         byte[] leftval = hashed(val, 1, 1);
1:c270904:         byte[] partialval = hashed(val, 1);
1:eb4fa4a:         Range<Token> left = new Range<>(tok(-1), tok(4));
1:eb4fa4a:         Range<Token> partial = new Range<>(tok(2), tok(4));
1:eb4fa4a:         Range<Token> right = new Range<>(tok(4), tok(-1));
1:eb4fa4a:         Range<Token> linvalid = new Range<>(tok(1), tok(4));
1:eb4fa4a:         Range<Token> rinvalid = new Range<>(tok(4), tok(6));
1:c270904: 
1:c270904:         // (zero,two] (two,four] (four, zero]
1:c270904:         mt.split(tok(4));
1:c270904:         mt.split(tok(2));
1:c270904:         assertNull(mt.hash(left));
1:c270904:         assertNull(mt.hash(partial));
1:c270904:         assertNull(mt.hash(right));
1:c270904:         assertNull(mt.hash(linvalid));
1:c270904:         assertNull(mt.hash(rinvalid));
1:07cdfd0: 
1:c270904:         // validate the range
1:c270904:         mt.get(tok(2)).hash(val);
2:c270904:         mt.get(tok(4)).hash(val);
1:0fd507b:         mt.get(tok(-1)).hash(val);
1:07cdfd0: 
1:c270904:         assertHashEquals(leftval, mt.hash(left));
1:c270904:         assertHashEquals(partialval, mt.hash(partial));
1:c270904:         assertHashEquals(val, mt.hash(right));
1:c270904:         assertNull(mt.hash(linvalid));
1:c270904:         assertNull(mt.hash(rinvalid));
1:c270904:     }
1:2fd3268: 
1:c270904:     @Test
1:c270904:     public void testHashInner()
1:c270904:     {
1:c270904:         byte[] val = DUMMY;
1:c270904:         byte[] lchildval = hashed(val, 3, 3, 2);
1:c270904:         byte[] rchildval = hashed(val, 2, 2);
1:c270904:         byte[] fullval = hashed(val, 3, 3, 2, 2, 2);
1:eb4fa4a:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:eb4fa4a:         Range<Token> lchild = new Range<>(tok(-1), tok(4));
1:eb4fa4a:         Range<Token> rchild = new Range<>(tok(4), tok(-1));
1:eb4fa4a:         Range<Token> invalid = new Range<>(tok(1), tok(-1));
1:c270904: 
1:c270904:         // (zero,one] (one, two] (two,four] (four, six] (six, zero]
1:c270904:         mt.split(tok(4));
1:c270904:         mt.split(tok(2));
1:c270904:         mt.split(tok(6));
2:c270904:         mt.split(tok(1));
1:c270904:         assertNull(mt.hash(full));
1:c270904:         assertNull(mt.hash(lchild));
1:c270904:         assertNull(mt.hash(rchild));
1:c270904:         assertNull(mt.hash(invalid));
1:07cdfd0: 
1:c270904:         // validate the range
1:c270904:         mt.get(tok(1)).hash(val);
1:c270904:         mt.get(tok(2)).hash(val);
1:c270904:         mt.get(tok(4)).hash(val);
1:c270904:         mt.get(tok(6)).hash(val);
1:0fd507b:         mt.get(tok(-1)).hash(val);
1:07cdfd0: 
1:c270904:         assertHashEquals(fullval, mt.hash(full));
1:c270904:         assertHashEquals(lchildval, mt.hash(lchild));
1:c270904:         assertHashEquals(rchildval, mt.hash(rchild));
1:c270904:         assertNull(mt.hash(invalid));
1:c270904:     }
1:2fd3268: 
1:c270904:     @Test
1:c270904:     public void testHashDegenerate()
1:c270904:     {
1:c270904:         TOKEN_SCALE = new BigInteger("32");
1:2fd3268: 
1:c270904:         byte[] val = DUMMY;
1:c270904:         byte[] childfullval = hashed(val, 5, 5, 4);
1:c270904:         byte[] fullval = hashed(val, 5, 5, 4, 3, 2, 1);
1:eb4fa4a:         Range<Token> childfull = new Range<>(tok(-1), tok(4));
1:eb4fa4a:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:eb4fa4a:         Range<Token> invalid = new Range<>(tok(4), tok(-1));
1:c270904: 
1:dc89826:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:c270904:         mt.split(tok(16));
1:c270904:         mt.split(tok(8));
1:c270904:         mt.split(tok(4));
1:c270904:         mt.split(tok(2));
1:c270904:         mt.split(tok(1));
1:c270904:         assertNull(mt.hash(full));
1:c270904:         assertNull(mt.hash(childfull));
1:c270904:         assertNull(mt.hash(invalid));
1:07cdfd0: 
1:c270904:         // validate the range
1:c270904:         mt.get(tok(1)).hash(val);
1:c270904:         mt.get(tok(2)).hash(val);
1:c270904:         mt.get(tok(4)).hash(val);
1:c270904:         mt.get(tok(8)).hash(val);
1:c270904:         mt.get(tok(16)).hash(val);
1:0fd507b:         mt.get(tok(-1)).hash(val);
1:c270904: 
1:c270904:         assertHashEquals(fullval, mt.hash(full));
1:c270904:         assertHashEquals(childfullval, mt.hash(childfull));
1:c270904:         assertNull(mt.hash(invalid));
1:c270904:     }
1:c270904: 
1:c270904:     @Test
1:c270904:     public void testHashRandom()
1:c270904:     {
1:c270904:         int max = 1000000;
1:c270904:         TOKEN_SCALE = new BigInteger("" + max);
1:c270904: 
1:dc89826:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, 32);
1:c270904:         Random random = new Random();
1:c270904:         while (true)
1:c270904:         {
1:c270904:             if (!mt.split(tok(random.nextInt(max))))
1:c270904:                 break;
1:c270904:         }
1:c270904: 
1:c270904:         // validate the tree
1:dc89826:         TreeRangeIterator ranges = mt.invalids();
1:c270904:         for (TreeRange range : ranges)
1:18f0234:             range.addHash(new RowHash(range.right, new byte[0], 0));
1:c270904: 
1:eb4fa4a:         assert mt.hash(new Range<>(tok(-1), tok(-1))) != null :
1:c270904:             "Could not hash tree " + mt;
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * Generate two trees with different splits, but containing the same keys, and
1:c270904:      * check that they compare equally.
1:c270904:      *
1:c270904:      * The set of keys used in this test is: #{2,4,6,8,12,14,0}
1:c270904:      */
1:c270904:     @Test
1:c270904:     public void testValidateTree()
1:c270904:     {
1:c270904:         TOKEN_SCALE = new BigInteger("16"); // this test needs slightly more resolution
1:c270904: 
1:eb4fa4a:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:c270904:         Iterator<TreeRange> ranges;
1:dc89826:         MerkleTree mt2 = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:c270904: 
1:c270904:         mt.split(tok(8));
1:c270904:         mt.split(tok(4));
1:c270904:         mt.split(tok(12));
1:c270904:         mt.split(tok(6));
1:c270904:         mt.split(tok(10));
1:07cdfd0: 
1:dc89826:         ranges = mt.invalids();
1:0fd507b:         ranges.next().addAll(new HIterator(2, 4)); // (-1,4]: depth 2
1:c52be53:         ranges.next().addAll(new HIterator(6)); // (4,6]
1:c52be53:         ranges.next().addAll(new HIterator(8)); // (6,8]
1:c52be53:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,10]
1:c52be53:         ranges.next().addAll(new HIterator(12)); // (10,12]
1:0fd507b:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1:c270904: 
1:c270904: 
1:c270904:         mt2.split(tok(8));
1:c270904:         mt2.split(tok(4));
1:c270904:         mt2.split(tok(12));
1:c270904:         mt2.split(tok(2));
1:c270904:         mt2.split(tok(10));
1:c270904:         mt2.split(tok(9));
1:c270904:         mt2.split(tok(11));
1:c270904: 
1:dc89826:         ranges = mt2.invalids();
1:0fd507b:         ranges.next().addAll(new HIterator(2)); // (-1,2]
1:c52be53:         ranges.next().addAll(new HIterator(4)); // (2,4]
1:c52be53:         ranges.next().addAll(new HIterator(6, 8)); // (4,8]: depth 2
1:c52be53:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,9]
1:c52be53:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (9,10]
1:c52be53:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (10,11]: depth 4
1:c52be53:         ranges.next().addAll(new HIterator(12)); // (11,12]: depth 4
1:0fd507b:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
1:c270904: 
1:c270904:         byte[] mthash = mt.hash(full);
1:c270904:         byte[] mt2hash = mt2.hash(full);
1:c270904:         assertHashEquals("Tree hashes did not match: " + mt + " && " + mt2, mthash, mt2hash);
1:c270904:     }
1:c270904: 
1:c270904:     @Test
1:c270904:     public void testSerialization() throws Exception
1:c270904:     {
1:eb4fa4a:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:c270904: 
1:c270904:         // populate and validate the tree
1:c270904:         mt.maxsize(256);
1:c270904:         mt.init();
1:dc89826:         for (TreeRange range : mt.invalids())
1:30f0216:             range.addAll(new HIterator(range.right));
1:c270904: 
1:c270904:         byte[] initialhash = mt.hash(full);
1:c270904: 
1:75508ec:         DataOutputBuffer out = new DataOutputBuffer();
1:eb4fa4a:         MerkleTree.serializer.serialize(mt, out, MessagingService.current_version);
1:eb4fa4a:         byte[] serialized = out.toByteArray();
1:c270904: 
1:c4c9eae:         DataInputPlus in = new DataInputBuffer(serialized);
1:eb4fa4a:         MerkleTree restored = MerkleTree.serializer.deserialize(in, MessagingService.current_version);
1:c270904: 
1:c270904:         assertHashEquals(initialhash, restored.hash(full));
1:c270904:     }
1:c270904: 
1:c270904:     @Test
1:c270904:     public void testDifference()
1:c270904:     {
1:c270904:         int maxsize = 16;
1:c270904:         mt.maxsize(maxsize);
1:dc89826:         MerkleTree mt2 = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, maxsize);
1:c270904:         mt.init();
1:c270904:         mt2.init();
1:c270904: 
1:dc89826:         // add dummy hashes to both trees
1:dc89826:         for (TreeRange range : mt.invalids())
1:30f0216:             range.addAll(new HIterator(range.right));
1:dc89826:         for (TreeRange range : mt2.invalids())
1:30f0216:             range.addAll(new HIterator(range.right));
1:dc89826: 
1:c270904:         TreeRange leftmost = null;
1:c270904:         TreeRange middle = null;
1:c270904: 
1:dc89826:         mt.maxsize(maxsize + 2); // give some room for splitting
1:dc89826: 
1:dc89826:         // split the leftmost
1:dc89826:         Iterator<TreeRange> ranges = mt.invalids();
1:c270904:         leftmost = ranges.next();
1:f759cb1:         mt.split(leftmost.right);
1:f759cb1: 
1:f759cb1:         // set the hashes for the leaf of the created split
1:dc89826:         middle = mt.get(leftmost.right);
1:c270904:         middle.hash("arbitrary!".getBytes());
1:f759cb1:         mt.get(partitioner.midpoint(leftmost.left, leftmost.right)).hash("even more arbitrary!".getBytes());
1:c270904: 
1:f759cb1:         // trees should disagree for (leftmost.left, middle.right]
1:71084e3:         List<TreeRange> diffs = MerkleTree.difference(mt, mt2);
1:dc89826:         assertEquals(diffs + " contains wrong number of differences:", 1, diffs.size());
1:eb4fa4a:         assertTrue(diffs.contains(new Range<>(leftmost.left, middle.right)));
1:c270904:     }
1:c270904: 
1:c270904:     /**
1:c270904:      * Return the root hash of a binary tree with leaves at the given depths
1:c270904:      * and with the given hash val in each leaf.
1:c270904:      */
1:c270904:     byte[] hashed(byte[] val, Integer... depths)
1:c270904:     {
1:c270904:         ArrayDeque<Integer> dstack = new ArrayDeque<Integer>();
1:c270904:         ArrayDeque<byte[]> hstack = new ArrayDeque<byte[]>();
1:c270904:         Iterator<Integer> depthiter = Arrays.asList(depths).iterator();
1:c270904:         if (depthiter.hasNext())
1:c270904:         {
1:c270904:             dstack.push(depthiter.next());
1:c270904:             hstack.push(val);
1:c270904:         }
1:c270904:         while (depthiter.hasNext())
1:c270904:         {
1:c270904:             Integer depth = depthiter.next();
1:c270904:             byte[] hash = val;
1:6d6a5e3:             while (depth.equals(dstack.peek()))
1:c270904:             {
1:c270904:                 // consume the stack
1:c270904:                 hash = Hashable.binaryHash(hstack.pop(), hash);
1:c270904:                 depth = dstack.pop()-1;
1:c270904:             }
1:c270904:             dstack.push(depth);
1:c270904:             hstack.push(hash);
1:c270904:         }
1:c270904:         assert hstack.size() == 1;
1:c270904:         return hstack.pop();
1:c270904:     }
1:c270904: 
1:c52be53:     static class HIterator extends AbstractIterator<RowHash>
1:c270904:     {
1:c270904:         private Iterator<Token> tokens;
1:c270904: 
1:c270904:         public HIterator(int... tokens)
1:c270904:         {
1:c270904:             List<Token> tlist = new LinkedList<Token>();
1:c270904:             for (int token : tokens)
1:c270904:                 tlist.add(tok(token));
1:c270904:             this.tokens = tlist.iterator();
1:c270904:         }
1:07cdfd0: 
1:c270904:         public HIterator(Token... tokens)
1:c270904:         {
1:c270904:             this.tokens = Arrays.asList(tokens).iterator();
1:c270904:         }
1:07cdfd0: 
1:c270904:         public RowHash computeNext()
1:c270904:         {
1:c270904:             if (tokens.hasNext())
1:18f0234:                 return new RowHash(tokens.next(), DUMMY, DUMMY.length);
1:c270904:             return endOfData();
1:c270904:         }
1:c270904:     }
1:c270904: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AbstractIterator;
author:Marcus Olsson
-------------------------------------------------------------------------------
commit:0dd50a6
/////////////////////////////////////////////////////////////////////////
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.setPartitionerUnsafe(partitioner);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitioner(partitioner);
commit:d7468ea
/////////////////////////////////////////////////////////////////////////
0:         assert mt.hash(new Range(tok(-1), tok(-1))) != null :
commit:9a5c679
/////////////////////////////////////////////////////////////////////////
1:         BigInteger bint = RandomPartitioner.MAXIMUM.divide(TOKEN_SCALE).multiply(new BigInteger(""+i));
commit:5e75a7f
/////////////////////////////////////////////////////////////////////////
commit:0fd507b
/////////////////////////////////////////////////////////////////////////
1:      * to 8 means that passing -1 through 8 for this method will return values mapped
1:      * between -1 and Token.MAX_VALUE.
1:         if (i == -1)
1:             return new BigIntegerToken(new BigInteger("-1"));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new Range(tok(7), tok(-1)), mt.get(tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(4)), mt.get(tok(3)));
0:         assertEquals(new Range(tok(-1), tok(4)), mt.get(tok(4)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals((byte)3, mt.get(tok(-1)).depth);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new Range(tok(4), tok(-1)), mt.get(tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(2)), mt.get(tok(2)));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new Range(tok(4), tok(-1)), mt.get(tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(4)), mt.get(tok(4)));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new Range(tok(-1), tok(2)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(7), tok(-1)), mt.get(tok(-1)));
0:         for (int i : new int[]{3,4,7,-1}){ assertEquals((byte)3, mt.get(tok(i)).depth); }
0:         assertEquals(new Range(tok(-1), tok(2)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(6), tok(-1)), mt.get(tok(-1)));
0:         for (int i : new int[]{2,4,5,-1}){ assertEquals((byte)2, mt.get(tok(i)).depth); }
0:         assertEquals(new Range(tok(-1), tok(4)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(6), tok(-1)), mt.get(tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(4)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(4), tok(-1)), mt.get(tok(6)));
0:         assertEquals(new Range(tok(-1), tok(-1)), mt.get(tok(-1)));
0:         assertEquals((byte)0, mt.get(tok(-1)).depth);
/////////////////////////////////////////////////////////////////////////
1:         mt.get(tok(-1)).hash(val);
0:         assertHashEquals(valXval, mt.get(tok(-1)).hash());
/////////////////////////////////////////////////////////////////////////
0:         ranges = mt.invalids(new Range(tok(-1), tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(-1)), ranges.next());
/////////////////////////////////////////////////////////////////////////
0:         ranges = mt.invalids(new Range(tok(-1), tok(-1)));
0:         assertEquals(new Range(tok(-1), tok(2)), ranges.next());
0:         assertEquals(new Range(tok(6), tok(-1)), ranges.next());
0:         mt.get(tok(-1)).hash("non-null!".getBytes());
0:         ranges = mt.invalids(new Range(tok(-1), tok(-1)));
0:         ranges = mt.invalids(new Range(tok(-1), tok(6)));
0:         ranges = mt.invalids(new Range(tok(2), tok(-1)));
/////////////////////////////////////////////////////////////////////////
0:         Range range = new Range(tok(-1), tok(-1));
1:         mt.get(tok(-1)).hash(val);
/////////////////////////////////////////////////////////////////////////
0:         Range left = new Range(tok(-1), tok(4));
0:         Range right = new Range(tok(4), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         mt.get(tok(-1)).hash(val);
/////////////////////////////////////////////////////////////////////////
0:         Range full = new Range(tok(-1), tok(-1));
0:         Range lchild = new Range(tok(-1), tok(4));
0:         Range rchild = new Range(tok(4), tok(-1));
0:         Range invalid = new Range(tok(1), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         mt.get(tok(-1)).hash(val);
/////////////////////////////////////////////////////////////////////////
0:         Range childfull = new Range(tok(-1), tok(4));
0:         Range full = new Range(tok(-1), tok(-1));
0:         Range invalid = new Range(tok(4), tok(-1));
/////////////////////////////////////////////////////////////////////////
0:         mt.get(tok(-1)).hash(val);
/////////////////////////////////////////////////////////////////////////
0:         TreeRangeIterator ranges = mt.invalids(new Range(tok(-1), tok(-1)));
0:         assert null != mt.hash(new Range(tok(-1), tok(-1))) :
/////////////////////////////////////////////////////////////////////////
0:         Range full = new Range(tok(-1), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         ranges.next().addAll(new HIterator(2, 4)); // (-1,4]: depth 2
1:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
/////////////////////////////////////////////////////////////////////////
1:         ranges.next().addAll(new HIterator(2)); // (-1,2]
1:         ranges.next().addAll(new HIterator(14, -1)); // (12,-1]: depth 2
/////////////////////////////////////////////////////////////////////////
0:         Range full = new Range(tok(-1), tok(-1));
/////////////////////////////////////////////////////////////////////////
0:         Range full = new Range(tok(-1), tok(-1));
commit:187761a
/////////////////////////////////////////////////////////////////////////
0:         String lstring = left == null ? "null" : FBUtilities.bytesToHex(left);
0:         String rstring = right == null ? "null" : FBUtilities.bytesToHex(right);
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.utils.MerkleTree.RECOMMENDED_DEPTH;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
1: 
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.nio.ByteBuffer;
0: import java.util.ArrayDeque;
0: import java.util.Arrays;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Random;
0: import org.apache.cassandra.dht.BigIntegerToken;
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.RandomPartitioner;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
1: import org.apache.cassandra.utils.MerkleTree.Hashable;
1: import org.apache.cassandra.utils.MerkleTree.RowHash;
1: import org.apache.cassandra.utils.MerkleTree.TreeRange;
1: import org.apache.cassandra.utils.MerkleTree.TreeRangeIterator;
1: import org.junit.Before;
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
0:         String lstring = left == null ? "null" : FBUtilities.bytesToHex(ByteBuffer.wrap(left));
0:         String rstring = right == null ? "null" : FBUtilities.bytesToHex(ByteBuffer.wrap(right));
commit:30f0216
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             range.addHash(new RowHash(range.right, new byte[0]));
/////////////////////////////////////////////////////////////////////////
1:             range.addAll(new HIterator(range.right));
/////////////////////////////////////////////////////////////////////////
0:         mt.compact(leftmost.right);
0:         leftmost = mt.get(leftmost.right); // leftmost is now a larger range
0:         mt.split(rightmost.right);
0:         middle = mt.get(rightmost.left);
1:             range.addAll(new HIterator(range.right));
1:             range.addAll(new HIterator(range.right));
0:         assertTrue(diffs.contains(new Range(middle.left, rightmost.right)));
commit:71084e3
/////////////////////////////////////////////////////////////////////////
1:         List<TreeRange> diffs = MerkleTree.difference(mt, mt2);
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitionerUnsafe(partitioner);
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
/////////////////////////////////////////////////////////////////////////
1:         partitioner = RandomPartitioner.instance;
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:c4c9eae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputBuffer;
/////////////////////////////////////////////////////////////////////////
1:         DataInputPlus in = new DataInputBuffer(serialized);
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.io.util.DataInputPlus;
0: import org.apache.cassandra.io.util.NIODataInputStream;
/////////////////////////////////////////////////////////////////////////
0:         DataInputPlus in = new NIODataInputStream(serialized);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.RandomPartitioner;
0: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.dht.Token;
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:f759cb1
/////////////////////////////////////////////////////////////////////////
1:         mt.split(leftmost.right);
1: 
1:         // set the hashes for the leaf of the created split
1:         mt.get(partitioner.midpoint(leftmost.left, leftmost.right)).hash("even more arbitrary!".getBytes());
1:         // trees should disagree for (leftmost.left, middle.right]
commit:dc89826
/////////////////////////////////////////////////////////////////////////
0:     private Range fullRange()
1:     {
0:         return new Range(partitioner.getMinimumToken(), partitioner.getMinimumToken());
1:     }
1: 
1:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
1:         mt = new MerkleTree(partitioner, fullRange(), (byte)2, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
1:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, 2);
/////////////////////////////////////////////////////////////////////////
1:         ranges = mt.invalids();
/////////////////////////////////////////////////////////////////////////
1:         ranges = mt.invalids();
0:         assertEquals(new Range(tok(6), tok(-1)), ranges.next());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
1:         mt = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, 32);
/////////////////////////////////////////////////////////////////////////
1:         TreeRangeIterator ranges = mt.invalids();
/////////////////////////////////////////////////////////////////////////
1:         MerkleTree mt2 = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, Integer.MAX_VALUE);
/////////////////////////////////////////////////////////////////////////
1:         ranges = mt.invalids();
/////////////////////////////////////////////////////////////////////////
1:         ranges = mt2.invalids();
/////////////////////////////////////////////////////////////////////////
1:         for (TreeRange range : mt.invalids())
/////////////////////////////////////////////////////////////////////////
0:         restored.fullRange = fullRange();
/////////////////////////////////////////////////////////////////////////
1:         MerkleTree mt2 = new MerkleTree(partitioner, fullRange(), RECOMMENDED_DEPTH, maxsize);
1:         // add dummy hashes to both trees
1:         for (TreeRange range : mt.invalids())
0:             range.addAll(new HIterator(range.right));
1:         for (TreeRange range : mt2.invalids())
0:             range.addAll(new HIterator(range.right));
1: 
1:         mt.maxsize(maxsize + 2); // give some room for splitting
1: 
1:         // split the leftmost
1:         Iterator<TreeRange> ranges = mt.invalids();
0:         mt.split(leftmost.left);
1:         middle = mt.get(leftmost.right);
0:         // trees should disagree for (middle.left, rightmost.right]
1:         assertEquals(diffs + " contains wrong number of differences:", 1, diffs.size());
0:         assertTrue(diffs.contains(new Range(leftmost.left, middle.right)));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:b30cdd9
/////////////////////////////////////////////////////////////////////////
commit:9639f95
/////////////////////////////////////////////////////////////////////////
commit:6d6a5e3
/////////////////////////////////////////////////////////////////////////
1:             while (depth.equals(dstack.peek()))
commit:7588f74
/////////////////////////////////////////////////////////////////////////
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputBuffer;
/////////////////////////////////////////////////////////////////////////
1:         DataOutputBuffer out = new DataOutputBuffer();
author:Benedict
-------------------------------------------------------------------------------
commit:18f0234
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.utils.MerkleTree.TreeDifference;
/////////////////////////////////////////////////////////////////////////
1:             range.addHash(new RowHash(range.right, new byte[0], 0));
/////////////////////////////////////////////////////////////////////////
1:                 return new RowHash(tokens.next(), DUMMY, DUMMY.length);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:eb4fa4a
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import com.google.common.collect.AbstractIterator;
0: import com.google.common.io.ByteArrayDataInput;
0: import com.google.common.io.ByteArrayDataOutput;
0: import com.google.common.io.ByteStreams;
0: import org.apache.hadoop.hdfs.server.common.Storage;
0: import org.junit.Before;
0: import org.junit.Test;
1: 
1: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.*;
1: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.StorageService;
0: import static org.apache.cassandra.utils.MerkleTree.RECOMMENDED_DEPTH;
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1:     private Range<Token> fullRange()
1:         return new Range<>(partitioner.getMinimumToken(), partitioner.getMinimumToken());
/////////////////////////////////////////////////////////////////////////
1:         // TODO need to trickle TokenSerializer
0:         DatabaseDescriptor.setPartitioner(partitioner);
/////////////////////////////////////////////////////////////////////////
1:     public static Token tok(int i)
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new Range<>(tok(7), tok(-1)), mt.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(3)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(4)));
1:         assertEquals(new Range<>(tok(4), tok(6)), mt.get(tok(6)));
1:         assertEquals(new Range<>(tok(6), tok(7)), mt.get(tok(7)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new Range<>(tok(4), tok(-1)), mt.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(2)), mt.get(tok(2)));
1:         assertEquals(new Range<>(tok(2), tok(4)), mt.get(tok(4)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new Range<>(tok(4), tok(-1)), mt.get(tok(-1)));
1:         assertEquals(new Range<>(tok(-1), tok(4)), mt.get(tok(4)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new Range<>(tok(-1), tok(-1)), ranges.next());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
1:         assertEquals(new Range<>(tok(-1), tok(2)), ranges.next());
1:         assertEquals(new Range<>(tok(2), tok(3)), ranges.next());
1:         assertEquals(new Range<>(tok(3), tok(4)), ranges.next());
1:         assertEquals(new Range<>(tok(4), tok(5)), ranges.next());
1:         assertEquals(new Range<>(tok(5), tok(6)), ranges.next());
1:         assertEquals(new Range<>(tok(6), tok(-1)), ranges.next());
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> range = new Range<>(tok(-1), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> left = new Range<>(tok(-1), tok(4));
1:         Range<Token> partial = new Range<>(tok(2), tok(4));
1:         Range<Token> right = new Range<>(tok(4), tok(-1));
1:         Range<Token> linvalid = new Range<>(tok(1), tok(4));
1:         Range<Token> rinvalid = new Range<>(tok(4), tok(6));
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:         Range<Token> lchild = new Range<>(tok(-1), tok(4));
1:         Range<Token> rchild = new Range<>(tok(4), tok(-1));
1:         Range<Token> invalid = new Range<>(tok(1), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> childfull = new Range<>(tok(-1), tok(4));
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
1:         Range<Token> invalid = new Range<>(tok(4), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         assert mt.hash(new Range<>(tok(-1), tok(-1))) != null :
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
/////////////////////////////////////////////////////////////////////////
1:         Range<Token> full = new Range<>(tok(-1), tok(-1));
/////////////////////////////////////////////////////////////////////////
0:         ByteArrayDataOutput out = ByteStreams.newDataOutput();
1:         MerkleTree.serializer.serialize(mt, out, MessagingService.current_version);
1:         byte[] serialized = out.toByteArray();
0:         ByteArrayDataInput in = ByteStreams.newDataInput(serialized);
1:         MerkleTree restored = MerkleTree.serializer.deserialize(in, MessagingService.current_version);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(diffs.contains(new Range<>(leftmost.left, middle.right)));
author:Eric Evans
-------------------------------------------------------------------------------
commit:2ede7fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String lstring = left == null ? "null" : Hex.bytesToHex(left);
1:         String rstring = right == null ? "null" : Hex.bytesToHex(right);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:0095f0c
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(MerkleTreeTest.class);
author:Jun Rao
-------------------------------------------------------------------------------
commit:c52be53
/////////////////////////////////////////////////////////////////////////
0:             range.addHash(new RowHash(range.right(), new byte[0]));
/////////////////////////////////////////////////////////////////////////
0:         ranges.next().addAll(new HIterator(2, 4)); // (0,4]: depth 2
1:         ranges.next().addAll(new HIterator(6)); // (4,6]
1:         ranges.next().addAll(new HIterator(8)); // (6,8]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,10]
1:         ranges.next().addAll(new HIterator(12)); // (10,12]
0:         ranges.next().addAll(new HIterator(14, 0)); // (12,0]: depth 2
/////////////////////////////////////////////////////////////////////////
0:         ranges.next().addAll(new HIterator(2)); // (0,2]
1:         ranges.next().addAll(new HIterator(4)); // (2,4]
1:         ranges.next().addAll(new HIterator(6, 8)); // (4,8]: depth 2
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (8,9]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (9,10]
1:         ranges.next().addAll(new HIterator(/*empty*/ new int[0])); // (10,11]: depth 4
1:         ranges.next().addAll(new HIterator(12)); // (11,12]: depth 4
0:         ranges.next().addAll(new HIterator(14, 0)); // (12,0]: depth 2
/////////////////////////////////////////////////////////////////////////
0:             range.addAll(new HIterator(range.right()));
/////////////////////////////////////////////////////////////////////////
0:             range.addAll(new HIterator(range.right()));
0:             range.addAll(new HIterator(range.right()));
/////////////////////////////////////////////////////////////////////////
1:     static class HIterator extends AbstractIterator<RowHash>
commit:c270904
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyten ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.utils;
1: 
0: import java.io.*;
0: import java.util.*;
1: import java.math.BigInteger;
1: 
0: import org.apache.cassandra.dht.*;
0: import static org.apache.cassandra.utils.MerkleTree.*;
1: 
0: import org.apache.log4j.Logger;
1: 
0: import com.google.common.collect.AbstractIterator;
0: import com.google.common.collect.PeekingIterator;
1: 
0: import org.junit.Before;
0: import org.junit.Test;
0: import static org.junit.Assert.*;
1: 
1: public class MerkleTreeTest
1: {
0:     private static final Logger logger = Logger.getLogger(MerkleTreeTest.class);
1: 
1:     public static byte[] DUMMY = "blah".getBytes();
1: 
1:     /**
1:      * If a test assumes that the tree is 8 units wide, then it should set this value
1:      * to 8.
1:      */
1:     public static BigInteger TOKEN_SCALE = new BigInteger("8");
1: 
1:     protected IPartitioner partitioner;
1:     protected MerkleTree mt;
1: 
1:     @Before
1:     public void clear()
1:     {
1:         TOKEN_SCALE = new BigInteger("8");
0:         partitioner = new RandomPartitioner();
0:         mt = new MerkleTree(partitioner, RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:     }
1: 
1:     public static void assertHashEquals(final byte[] left, final byte[] right)
1:     {
1:         assertHashEquals("", left, right);
1:     }
1: 
1:     public static void assertHashEquals(String message, final byte[] left, final byte[] right)
1:     {
0:         String lstring = left == null ? "null" : FBUtilities.bytesToHex(left);
0:         String rstring = right == null ? "null" : FBUtilities.bytesToHex(right);
1:         assertEquals(message, lstring, rstring);
1:     }
1: 
1:     /**
1:      * The value returned by this method is affected by TOKEN_SCALE: setting TOKEN_SCALE
0:      * to 8 means that passing 0 through 8 for this method will return values mapped
0:      * between 0 and Token.MAX_VALUE.
1:      */
0:     public static BigIntegerToken tok(int i)
1:     {
0:         BigInteger md5_max = new BigInteger("2").pow(127);
0:         BigInteger bint = md5_max.divide(TOKEN_SCALE).multiply(new BigInteger(""+i));
1:         return new BigIntegerToken(bint);
1:     }
1: 
1:     @Test
1:     public void testSplit()
1:     {
1:         // split the range  (zero, zero] into:
1:         //  (zero,four], (four,six], (six,seven] and (seven, zero]
1:         mt.split(tok(4));
1:         mt.split(tok(6));
1:         mt.split(tok(7));
1: 
1:         assertEquals(4, mt.size());
0:         assertEquals(new Range(tok(7), tok(0)), mt.get(tok(0)));
0:         assertEquals(new Range(tok(0), tok(4)), mt.get(tok(3)));
0:         assertEquals(new Range(tok(0), tok(4)), mt.get(tok(4)));
0:         assertEquals(new Range(tok(4), tok(6)), mt.get(tok(6)));
0:         assertEquals(new Range(tok(6), tok(7)), mt.get(tok(7)));
1: 
1:         // check depths
1:         assertEquals((byte)1, mt.get(tok(4)).depth);
1:         assertEquals((byte)2, mt.get(tok(6)).depth);
1:         assertEquals((byte)3, mt.get(tok(7)).depth);
0:         assertEquals((byte)3, mt.get(tok(0)).depth);
1: 
1:         try
1:         {
1:             mt.split(tok(-1));
1:             fail("Shouldn't be able to split outside the initial range.");
1:         }
1:         catch (AssertionError e)
1:         {
1:             // pass
1:         }
1:     }
1: 
1:     @Test
1:     public void testSplitLimitDepth()
1:     {
0:         mt = new MerkleTree(partitioner, (byte)2, Integer.MAX_VALUE);
1: 
1:         assertTrue(mt.split(tok(4)));
1:         assertTrue(mt.split(tok(2)));
1:         assertEquals(3, mt.size());
1:         
1:         // should fail to split below hashdepth
1:         assertFalse(mt.split(tok(1)));
1:         assertEquals(3, mt.size());
0:         assertEquals(new Range(tok(4), tok(0)), mt.get(tok(0)));
0:         assertEquals(new Range(tok(0), tok(2)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(2), tok(4)), mt.get(tok(4)));
1:     }
1: 
1:     @Test
1:     public void testSplitLimitSize()
1:     {
0:         mt = new MerkleTree(partitioner, RECOMMENDED_DEPTH, 2);
1: 
1:         assertTrue(mt.split(tok(4)));
1:         assertEquals(2, mt.size());
1:         
1:         // should fail to split above maxsize
1:         assertFalse(mt.split(tok(2)));
1:         assertEquals(2, mt.size());
0:         assertEquals(new Range(tok(4), tok(0)), mt.get(tok(0)));
0:         assertEquals(new Range(tok(0), tok(4)), mt.get(tok(4)));
1:     }
1: 
1:     @Test
0:     public void testCompact()
1:     {
0:         // (zero, one], (one,two], ... (seven, zero]
1:         mt.split(tok(4));
1:         mt.split(tok(2)); 
1:         mt.split(tok(6));
1:         mt.split(tok(1));
1:         mt.split(tok(3));
1:         mt.split(tok(5));
1:         mt.split(tok(7));
1: 
0:         // compact (zero,two] and then (four,six]
0:         mt.compact(tok(1));
0:         mt.compact(tok(5));
0:         assertEquals(6, mt.size());
0:         assertEquals(new Range(tok(0), tok(2)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(2), tok(3)), mt.get(tok(3)));
0:         assertEquals(new Range(tok(3), tok(4)), mt.get(tok(4)));
0:         assertEquals(new Range(tok(4), tok(6)), mt.get(tok(5)));
0:         assertEquals(new Range(tok(6), tok(7)), mt.get(tok(7)));
0:         assertEquals(new Range(tok(7), tok(0)), mt.get(tok(0)));
0:         // compacted ranges should be at depth 2, and the rest at 3
0:         for (int i : new int[]{2,6}){ assertEquals((byte)2, mt.get(tok(i)).depth); }
0:         for (int i : new int[]{3,4,7,0}){ assertEquals((byte)3, mt.get(tok(i)).depth); }
1: 
0:         // compact (two,four] and then (six,zero]
0:         mt.compact(tok(3));
0:         mt.compact(tok(7));
1:         assertEquals(4, mt.size());
0:         assertEquals(new Range(tok(0), tok(2)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(2), tok(4)), mt.get(tok(4)));
0:         assertEquals(new Range(tok(4), tok(6)), mt.get(tok(5)));
0:         assertEquals(new Range(tok(6), tok(0)), mt.get(tok(0)));
0:         for (int i : new int[]{2,4,5,0}){ assertEquals((byte)2, mt.get(tok(i)).depth); }
1: 
0:         // compact (zero,four]
0:         mt.compact(tok(2));
1:         assertEquals(3, mt.size());
0:         assertEquals(new Range(tok(0), tok(4)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(4), tok(6)), mt.get(tok(6)));
0:         assertEquals(new Range(tok(6), tok(0)), mt.get(tok(0)));
1: 
0:         // compact (four, zero]
0:         mt.compact(tok(6));
1:         assertEquals(2, mt.size());
0:         assertEquals(new Range(tok(0), tok(4)), mt.get(tok(2)));
0:         assertEquals(new Range(tok(4), tok(0)), mt.get(tok(6)));
0:         assertEquals((byte)1, mt.get(tok(2)).depth);
0:         assertEquals((byte)1, mt.get(tok(6)).depth);
1: 
0:         // compact (zero, zero] (the root)
0:         mt.compact(tok(4));
0:         assertEquals(1, mt.size());
0:         assertEquals(new Range(tok(0), tok(0)), mt.get(tok(0)));
0:         assertEquals((byte)0, mt.get(tok(0)).depth);
1:     }
1: 
1:     @Test
0:     public void testCompactHash()
1:     {
1:         byte[] val = DUMMY;
0:         byte[] valXval = hashed(val, 1, 1);
1: 
0:         // (zero, four], (four,zero]
1:         mt.split(tok(4));
1: 
0:         // validate both ranges
1:         mt.get(tok(4)).hash(val);
0:         mt.get(tok(0)).hash(val);
1: 
0:         // compact (zero, eight]
0:         mt.compact(tok(4));
0:         assertHashEquals(valXval, mt.get(tok(0)).hash());
1:     }
1: 
1:     @Test
1:     public void testInvalids()
1:     {
1:         Iterator<TreeRange> ranges;
1:         
1:         // (zero, zero]
0:         ranges = mt.invalids(new Range(tok(0), tok(0)));
0:         assertEquals(new Range(tok(0), tok(0)), ranges.next());
1:         assertFalse(ranges.hasNext());
1: 
1:         // all invalid
1:         mt.split(tok(4));
1:         mt.split(tok(2));
1:         mt.split(tok(6));
1:         mt.split(tok(3));
1:         mt.split(tok(5));
0:         ranges = mt.invalids(new Range(tok(0), tok(0)));
0:         assertEquals(new Range(tok(0), tok(2)), ranges.next());
0:         assertEquals(new Range(tok(2), tok(3)), ranges.next());
0:         assertEquals(new Range(tok(3), tok(4)), ranges.next());
0:         assertEquals(new Range(tok(4), tok(5)), ranges.next());
0:         assertEquals(new Range(tok(5), tok(6)), ranges.next());
0:         assertEquals(new Range(tok(6), tok(0)), ranges.next());
1:         assertFalse(ranges.hasNext());
1:         
0:         // some invalid
0:         mt.get(tok(2)).hash("non-null!".getBytes());
0:         mt.get(tok(4)).hash("non-null!".getBytes());
0:         mt.get(tok(5)).hash("non-null!".getBytes());
0:         mt.get(tok(0)).hash("non-null!".getBytes());
0:         ranges = mt.invalids(new Range(tok(0), tok(0)));
0:         assertEquals(new Range(tok(2), tok(3)), ranges.next());
0:         assertEquals(new Range(tok(5), tok(6)), ranges.next());
1:         assertFalse(ranges.hasNext());
1:         
0:         // some invalid in left subrange
0:         ranges = mt.invalids(new Range(tok(0), tok(6)));
0:         assertEquals(new Range(tok(2), tok(3)), ranges.next());
0:         assertEquals(new Range(tok(5), tok(6)), ranges.next());
1:         assertFalse(ranges.hasNext());
1: 
0:         // some invalid in right subrange
0:         ranges = mt.invalids(new Range(tok(2), tok(0)));
0:         assertEquals(new Range(tok(2), tok(3)), ranges.next());
0:         assertEquals(new Range(tok(5), tok(6)), ranges.next());
1:         assertFalse(ranges.hasNext());
1:     }
1: 
1:     @Test
1:     public void testHashFull()
1:     {
1:         byte[] val = DUMMY;
0:         Range range = new Range(tok(0), tok(0));
1: 
1:         // (zero, zero]
1:         assertNull(mt.hash(range));
1:         
1:         // validate the range
0:         mt.get(tok(0)).hash(val);
1:         
1:         assertHashEquals(val, mt.hash(range));
1:     }
1: 
1:     @Test
1:     public void testHashPartial()
1:     {
1:         byte[] val = DUMMY;
1:         byte[] leftval = hashed(val, 1, 1);
1:         byte[] partialval = hashed(val, 1);
0:         Range left = new Range(tok(0), tok(4));
0:         Range partial = new Range(tok(2), tok(4));
0:         Range right = new Range(tok(4), tok(0));
0:         Range linvalid = new Range(tok(1), tok(4));
0:         Range rinvalid = new Range(tok(4), tok(6));
1: 
1:         // (zero,two] (two,four] (four, zero]
1:         mt.split(tok(4));
1:         mt.split(tok(2));
1:         assertNull(mt.hash(left));
1:         assertNull(mt.hash(partial));
1:         assertNull(mt.hash(right));
1:         assertNull(mt.hash(linvalid));
1:         assertNull(mt.hash(rinvalid));
1:         
1:         // validate the range
1:         mt.get(tok(2)).hash(val);
1:         mt.get(tok(4)).hash(val);
0:         mt.get(tok(0)).hash(val);
1:         
1:         assertHashEquals(leftval, mt.hash(left));
1:         assertHashEquals(partialval, mt.hash(partial));
1:         assertHashEquals(val, mt.hash(right));
1:         assertNull(mt.hash(linvalid));
1:         assertNull(mt.hash(rinvalid));
1:     }
1: 
1:     @Test
1:     public void testHashInner()
1:     {
1:         byte[] val = DUMMY;
1:         byte[] lchildval = hashed(val, 3, 3, 2);
1:         byte[] rchildval = hashed(val, 2, 2);
1:         byte[] fullval = hashed(val, 3, 3, 2, 2, 2);
0:         Range full = new Range(tok(0), tok(0));
0:         Range lchild = new Range(tok(0), tok(4));
0:         Range rchild = new Range(tok(4), tok(0));
0:         Range invalid = new Range(tok(1), tok(0));
1: 
1:         // (zero,one] (one, two] (two,four] (four, six] (six, zero]
1:         mt.split(tok(4));
1:         mt.split(tok(2));
1:         mt.split(tok(6));
1:         mt.split(tok(1));
1:         assertNull(mt.hash(full));
1:         assertNull(mt.hash(lchild));
1:         assertNull(mt.hash(rchild));
1:         assertNull(mt.hash(invalid));
1:         
1:         // validate the range
1:         mt.get(tok(1)).hash(val);
1:         mt.get(tok(2)).hash(val);
1:         mt.get(tok(4)).hash(val);
1:         mt.get(tok(6)).hash(val);
0:         mt.get(tok(0)).hash(val);
1:         
1:         assertHashEquals(fullval, mt.hash(full));
1:         assertHashEquals(lchildval, mt.hash(lchild));
1:         assertHashEquals(rchildval, mt.hash(rchild));
1:         assertNull(mt.hash(invalid));
1:     }
1: 
1:     @Test
1:     public void testHashDegenerate()
1:     {
1:         TOKEN_SCALE = new BigInteger("32");
1: 
1:         byte[] val = DUMMY;
1:         byte[] childfullval = hashed(val, 5, 5, 4);
1:         byte[] fullval = hashed(val, 5, 5, 4, 3, 2, 1);
0:         Range childfull = new Range(tok(0), tok(4));
0:         Range full = new Range(tok(0), tok(0));
0:         Range invalid = new Range(tok(4), tok(0));
1: 
0:         mt = new MerkleTree(partitioner, RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1:         mt.split(tok(16));
1:         mt.split(tok(8));
1:         mt.split(tok(4));
1:         mt.split(tok(2));
1:         mt.split(tok(1));
1:         assertNull(mt.hash(full));
1:         assertNull(mt.hash(childfull));
1:         assertNull(mt.hash(invalid));
1:         
1:         // validate the range
1:         mt.get(tok(1)).hash(val);
1:         mt.get(tok(2)).hash(val);
1:         mt.get(tok(4)).hash(val);
1:         mt.get(tok(8)).hash(val);
1:         mt.get(tok(16)).hash(val);
0:         mt.get(tok(0)).hash(val);
1: 
1:         assertHashEquals(fullval, mt.hash(full));
1:         assertHashEquals(childfullval, mt.hash(childfull));
1:         assertNull(mt.hash(invalid));
1:     }
1: 
1:     @Test
1:     public void testHashRandom()
1:     {
1:         int max = 1000000;
1:         TOKEN_SCALE = new BigInteger("" + max);
1: 
0:         mt = new MerkleTree(partitioner, RECOMMENDED_DEPTH, 32);
1:         Random random = new Random();
1:         while (true)
1:         {
1:             if (!mt.split(tok(random.nextInt(max))))
1:                 break;
1:         }
1: 
1:         // validate the tree
0:         TreeRangeIterator ranges = mt.invalids(new Range(tok(0), tok(0)));
1:         for (TreeRange range : ranges)
0:             range.validate(new HIterator(/*empty*/ new int[0]));
1: 
0:         assert null != mt.hash(new Range(tok(0), tok(0))) :
1:             "Could not hash tree " + mt;
1:     }
1: 
1:     /**
1:      * Generate two trees with different splits, but containing the same keys, and
1:      * check that they compare equally.
1:      *
1:      * The set of keys used in this test is: #{2,4,6,8,12,14,0}
1:      */
1:     @Test
1:     public void testValidateTree()
1:     {
1:         TOKEN_SCALE = new BigInteger("16"); // this test needs slightly more resolution
1: 
0:         Range full = new Range(tok(0), tok(0));
1:         Iterator<TreeRange> ranges;
0:         MerkleTree mt2 = new MerkleTree(partitioner, RECOMMENDED_DEPTH, Integer.MAX_VALUE);
1: 
1:         mt.split(tok(8));
1:         mt.split(tok(4));
1:         mt.split(tok(12));
1:         mt.split(tok(6));
1:         mt.split(tok(10));
1:         
0:         ranges = mt.invalids(full);
0:         ranges.next().validate(new HIterator(2, 4)); // (0,4]: depth 2
0:         ranges.next().validate(new HIterator(6)); // (4,6]
0:         ranges.next().validate(new HIterator(8)); // (6,8]
0:         ranges.next().validate(new HIterator(/*empty*/ new int[0])); // (8,10]
0:         ranges.next().validate(new HIterator(12)); // (10,12]
0:         ranges.next().validate(new HIterator(14, 0)); // (12,0]: depth 2
1: 
1: 
1:         mt2.split(tok(8));
1:         mt2.split(tok(4));
1:         mt2.split(tok(12));
1:         mt2.split(tok(2));
1:         mt2.split(tok(10));
1:         mt2.split(tok(9));
1:         mt2.split(tok(11));
1: 
0:         ranges = mt2.invalids(full);
0:         ranges.next().validate(new HIterator(2)); // (0,2]
0:         ranges.next().validate(new HIterator(4)); // (2,4]
0:         ranges.next().validate(new HIterator(6, 8)); // (4,8]: depth 2
0:         ranges.next().validate(new HIterator(/*empty*/ new int[0])); // (8,9]
0:         ranges.next().validate(new HIterator(/*empty*/ new int[0])); // (9,10]
0:         ranges.next().validate(new HIterator(/*empty*/ new int[0])); // (10,11]: depth 4
0:         ranges.next().validate(new HIterator(12)); // (11,12]: depth 4
0:         ranges.next().validate(new HIterator(14, 0)); // (12,0]: depth 2
1: 
1:         byte[] mthash = mt.hash(full);
1:         byte[] mt2hash = mt2.hash(full);
1:         assertHashEquals("Tree hashes did not match: " + mt + " && " + mt2, mthash, mt2hash);
1:     }
1: 
1:     @Test
1:     public void testSerialization() throws Exception
1:     {
0:         Range full = new Range(tok(0), tok(0));
0:         ByteArrayOutputStream bout = new ByteArrayOutputStream();
0:         ObjectOutputStream oout = new ObjectOutputStream(bout);
1:     
1:         // populate and validate the tree
1:         mt.maxsize(256);
1:         mt.init();
0:         for (TreeRange range : mt.invalids(full))
0:             range.validate(new HIterator(range.right()));
1: 
1:         byte[] initialhash = mt.hash(full);
0:         oout.writeObject(mt);
0:         oout.close();
1: 
0:         ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
0:         ObjectInputStream oin = new ObjectInputStream(bin);
0:         MerkleTree restored = (MerkleTree)oin.readObject();
1:     
0:         // restore partitioner after serialization
0:         restored.partitioner(partitioner);
1: 
1:         assertHashEquals(initialhash, restored.hash(full));
1:     }
1: 
1:     @Test
1:     public void testDifference()
1:     {
0:         Range full = new Range(tok(0), tok(0));
1:         int maxsize = 16;
1:         mt.maxsize(maxsize);
0:         MerkleTree mt2 = new MerkleTree(partitioner, RECOMMENDED_DEPTH, maxsize);
1:         mt.init();
1:         mt2.init();
1: 
1:         TreeRange leftmost = null;
1:         TreeRange middle = null;
0:         TreeRange rightmost = null;
1: 
0:         // compact the leftmost, and split the rightmost
0:         Iterator<TreeRange> ranges = mt.invalids(full);
1:         leftmost = ranges.next();
0:         rightmost = null;
0:         while (ranges.hasNext())
0:             rightmost = ranges.next();
0:         mt.compact(leftmost.right());
0:         leftmost = mt.get(leftmost.right()); // leftmost is now a larger range
0:         mt.split(rightmost.right());
1:         
0:         // set the hash for the left neighbor of rightmost
0:         middle = mt.get(rightmost.left());
1:         middle.hash("arbitrary!".getBytes());
0:         byte depth = middle.depth;
1: 
0:         // add dummy hashes to the rest of both trees
0:         for (TreeRange range : mt.invalids(full))
0:             range.validate(new HIterator(range.right()));
0:         for (TreeRange range : mt2.invalids(full))
0:             range.validate(new HIterator(range.right()));
1:         
0:         // trees should disagree for leftmost, (middle.left, rightmost.right]
0:         List<Range> diffs = MerkleTree.difference(mt, mt2);
0:         assertEquals(diffs + " contains wrong number of differences:", 2, diffs.size());
0:         assertTrue(diffs.contains(leftmost));
0:         assertTrue(diffs.contains(new Range(middle.left(), rightmost.right())));
1:     }
1: 
1:     /**
1:      * Return the root hash of a binary tree with leaves at the given depths
1:      * and with the given hash val in each leaf.
1:      */
1:     byte[] hashed(byte[] val, Integer... depths)
1:     {
1:         ArrayDeque<Integer> dstack = new ArrayDeque<Integer>();
1:         ArrayDeque<byte[]> hstack = new ArrayDeque<byte[]>();
1:         Iterator<Integer> depthiter = Arrays.asList(depths).iterator();
1:         if (depthiter.hasNext())
1:         {
1:             dstack.push(depthiter.next());
1:             hstack.push(val);
1:         }
1:         while (depthiter.hasNext())
1:         {
1:             Integer depth = depthiter.next();
1:             byte[] hash = val;
0:             while (dstack.peek() == depth)
1:             {
1:                 // consume the stack
1:                 hash = Hashable.binaryHash(hstack.pop(), hash);
1:                 depth = dstack.pop()-1;
1:             }
1:             dstack.push(depth);
1:             hstack.push(hash);
1:         }
1:         assert hstack.size() == 1;
1:         return hstack.pop();
1:     }
1: 
0:     static class HIterator extends AbstractIterator<RowHash> implements PeekingIterator<RowHash>
1:     {
1:         private Iterator<Token> tokens;
1: 
1:         public HIterator(int... tokens)
1:         {
1:             List<Token> tlist = new LinkedList<Token>();
1:             for (int token : tokens)
1:                 tlist.add(tok(token));
1:             this.tokens = tlist.iterator();
1:         }
1:     
1:         public HIterator(Token... tokens)
1:         {
1:             this.tokens = Arrays.asList(tokens).iterator();
1:         }
1:     
0:         @Override
1:         public RowHash computeNext()
1:         {
1:             if (tokens.hasNext())
0:                 return new RowHash(tokens.next(), DUMMY);
1:             return endOfData();
1:         }
1:     }
1: }
============================================================================