1:07cf56f: /*
1:5d98581:  * Licensed to the Apache Software Foundation (ASF) under one
1:5d98581:  * or more contributor license agreements.  See the NOTICE file
1:5d98581:  * distributed with this work for additional information
1:5d98581:  * regarding copyright ownership.  The ASF licenses this file
1:5d98581:  * to you under the Apache License, Version 2.0 (the
1:5d98581:  * "License"); you may not use this file except in compliance
1:5d98581:  * with the License.  You may obtain a copy of the License at
1:5d98581:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5d98581:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
2:5d98581:  */
1:5d98581: package org.apache.cassandra.db.marshal;
4:5d98581: 
1:debb15e: import java.io.IOException;
1:5d98581: import java.nio.ByteBuffer;
1:5d98581: import java.util.ArrayList;
1:bee48eb: import java.util.Arrays;
1:5d98581: import java.util.List;
1:bee48eb: import java.util.concurrent.ConcurrentHashMap;
1:bee48eb: import java.util.concurrent.ConcurrentMap;
1:5d98581: 
1:91bdf7f: import com.google.common.collect.ImmutableList;
1:91bdf7f: 
1:5f5905d: import org.apache.cassandra.cql3.ColumnIdentifier;
1:5117a5d: import org.apache.cassandra.cql3.Operator;
1:bee48eb: import org.apache.cassandra.exceptions.ConfigurationException;
1:bee48eb: import org.apache.cassandra.exceptions.SyntaxException;
1:9252ee9: import org.apache.cassandra.io.util.DataOutputBuffer;
1:c2ecfe7: import org.apache.cassandra.io.util.DataOutputBufferFixed;
1:fc8b76f: import org.apache.cassandra.serializers.MarshalException;
1:655ccc3: import org.apache.cassandra.utils.ByteBufferUtil;
1:5d98581: 
1:655ccc3: /*
1:5d98581:  * The encoding of a CompositeType column name should be:
1:5d98581:  *   <component><component><component> ...
1:5d98581:  * where <component> is:
1:5d98581:  *   <length of value><value><'end-of-component' byte>
1:b09d876:  * where <length of value> is a 2 bytes unsigned short (but 0xFFFF is invalid, see
1:b09d876:  * below) and the 'end-of-component' byte should always be 0 for actual column name.
1:5d98581:  * However, it can set to 1 for query bounds. This allows to query for the
1:5d98581:  * equivalent of 'give me the full super-column'. That is, if during a slice
1:5d98581:  * query uses:
1:5d98581:  *   start = <3><"foo".getBytes()><0>
1:5d98581:  *   end   = <3><"foo".getBytes()><1>
1:5d98581:  * then he will be sure to get *all* the columns whose first component is "foo".
1:5d98581:  * If for a component, the 'end-of-component' is != 0, there should not be any
1:5d98581:  * following component. The end-of-component can also be -1 to allow
1:5d98581:  * non-inclusive query. For instance:
1:5d98581:  *   start = <3><"foo".getBytes()><-1>
1:5d98581:  * allows to query everything that is greater than <3><"foo".getBytes()>, but
1:5d98581:  * not <3><"foo".getBytes()> itself.
1:b09d876:  *
1:b09d876:  * On top of that, CQL3 uses a specific prefix (0xFFFF) to encode "static columns"
1:b09d876:  * (CASSANDRA-6561). This does mean the maximum size of the first component of a
1:b09d876:  * composite is 65534, not 65535 (or we wouldn't be able to detect if the first 2
1:b09d876:  * bytes is the static prefix or not).
1:655ccc3:  */
1:5d98581: public class CompositeType extends AbstractCompositeType
7:5d98581: {
1:b09d876:     public static final int STATIC_MARKER = 0xFFFF;
1:b09d876: 
1:655ccc3:     public final List<AbstractType<?>> types;
1:655ccc3: 
1:5d98581:     // interning instances
1:bee48eb:     private static final ConcurrentMap<List<AbstractType<?>>, CompositeType> instances = new ConcurrentHashMap<List<AbstractType<?>>, CompositeType>();
1:655ccc3: 
1:3a2faf9:     public static CompositeType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:58202a8:     {
1:58202a8:         return getInstance(parser.getTypeParameters());
1:58202a8:     }
1:58202a8: 
1:3a005df:     public static CompositeType getInstance(AbstractType... types)
1:98c4a7c:     {
1:3a005df:         return getInstance(Arrays.<AbstractType<?>>asList(types));
1:3a005df:     }
1:3a005df: 
1:b09d876:     protected boolean readIsStatic(ByteBuffer bb)
1:b09d876:     {
1:b09d876:         return readStatic(bb);
1:b09d876:     }
1:b09d876: 
1:b09d876:     private static boolean readStatic(ByteBuffer bb)
1:b09d876:     {
1:b09d876:         if (bb.remaining() < 2)
1:b09d876:             return false;
1:b09d876: 
1:9d06ea6:         int header = ByteBufferUtil.getShortLength(bb, bb.position());
1:b09d876:         if ((header & 0xFFFF) != STATIC_MARKER)
1:b09d876:             return false;
1:b09d876: 
1:9d06ea6:         ByteBufferUtil.readShortLength(bb); // Skip header
1:98c4a7c:         return true;
1:b09d876:     }
1:b09d876: 
1:bee48eb:     public static CompositeType getInstance(List<AbstractType<?>> types)
1:3a005df:     {
1:96ecaff:         assert types != null && !types.isEmpty();
1:655ccc3: 
1:5d98581:         CompositeType ct = instances.get(types);
1:5d98581:         if (ct == null)
1:3a005df:         {
1:5d98581:             ct = new CompositeType(types);
1:bee48eb:             CompositeType previous = instances.putIfAbsent(types, ct);
1:bee48eb:             if (previous != null)
1:bee48eb:             {
1:bee48eb:                 ct = previous;
1:bee48eb:             }
1:655ccc3:         }
1:5d98581:         return ct;
1:655ccc3:     }
1:655ccc3: 
1:a552b30:     protected CompositeType(List<AbstractType<?>> types)
1:655ccc3:     {
1:91bdf7f:         this.types = ImmutableList.copyOf(types);
1:98c4a7c:     }
1:98c4a7c: 
1:bfe2dfb:     protected AbstractType<?> getComparator(int i, ByteBuffer bb)
1:655ccc3:     {
1:b09d876:         try
1:d387240:         {
1:d387240:             return types.get(i);
1:d387240:         }
1:d387240:         catch (IndexOutOfBoundsException e)
1:d387240:         {
1:d387240:             // We shouldn't get there in general because 1) we shouldn't construct broken composites
1:d387240:             // from CQL and 2) broken composites coming from thrift should be rejected by validate.
1:d387240:             // There is a few cases however where, if the schema has changed since we created/validated
1:d387240:             // the composite, this will be thrown (see #6262). Those cases are a user error but
1:d387240:             // throwing a more meaningful error message to make understanding such error easier. .
1:d387240:             throw new RuntimeException("Cannot get comparator " + i + " in " + this + ". "
1:d387240:                                      + "This might due to a mismatch between the schema and the data read", e);
1:d387240:         }
1:655ccc3:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:655ccc3:     {
1:d387240:         return getComparator(i, bb1);
1:655ccc3:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb)
1:655ccc3:     {
3:5d98581:         return types.get(i);
1:655ccc3:     }
1:5d98581: 
1:bfe2dfb:     protected ParsedComparator parseComparator(int i, String part)
1:655ccc3:     {
1:5d98581:         return new StaticParsedComparator(types.get(i), part);
7:5d98581:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException
1:655ccc3:     {
1:5d98581:         if (i >= types.size())
1:5d98581:             throw new MarshalException("Too many bytes for comparator");
1:5d98581:         return types.get(i);
1:5d98581:     }
1:5d98581: 
1:8ea2d2a:     public ByteBuffer decompose(Object... objects)
1:655ccc3:     {
1:8ea2d2a:         assert objects.length == types.size();
1:5d98581: 
1:80ea03f:         ByteBuffer[] serialized = new ByteBuffer[objects.length];
1:8ea2d2a:         for (int i = 0; i < objects.length; i++)
1:5d98581:         {
1:8ea2d2a:             ByteBuffer buffer = ((AbstractType) types.get(i)).decompose(objects[i]);
1:80ea03f:             serialized[i] = buffer;
1:5d98581:         }
1:80ea03f:         return build(serialized);
1:5d98581:     }
1:5d98581: 
1:a552b30:     // Overriding the one of AbstractCompositeType because we can do a tad better
1:98c4a7c:     @Override
1:a552b30:     public ByteBuffer[] split(ByteBuffer name)
1:a552b30:     {
1:a552b30:         // Assume all components, we'll trunk the array afterwards if need be, but
1:a552b30:         // most names will be complete.
1:a552b30:         ByteBuffer[] l = new ByteBuffer[types.size()];
1:a552b30:         ByteBuffer bb = name.duplicate();
1:a991b64:         readStatic(bb);
1:a552b30:         int i = 0;
1:a552b30:         while (bb.remaining() > 0)
1:a552b30:         {
1:8a52f5a:             l[i++] = ByteBufferUtil.readBytesWithShortLength(bb);
1:a552b30:             bb.get(); // skip end-of-component
1:a552b30:         }
1:a552b30:         return i == l.length ? l : Arrays.copyOfRange(l, 0, i);
1:a552b30:     }
1:a552b30: 
1:a991b64:     public static List<ByteBuffer> splitName(ByteBuffer name)
1:a991b64:     {
1:a991b64:         List<ByteBuffer> l = new ArrayList<>();
1:a991b64:         ByteBuffer bb = name.duplicate();
1:a991b64:         readStatic(bb);
1:a991b64:         while (bb.remaining() > 0)
1:a991b64:         {
1:a991b64:             l.add(ByteBufferUtil.readBytesWithShortLength(bb));
1:a991b64:             bb.get(); // skip end-of-component
1:a991b64:         }
1:a991b64:         return l;
1:a991b64:     }
1:a991b64: 
1:f009272:     public static byte lastEOC(ByteBuffer name)
1:f009272:     {
1:f009272:         return name.get(name.limit() - 1);
1:f009272:     }
1:f009272: 
1:3a005df:     // Extract component idx from bb. Return null if there is not enough component.
1:3a005df:     public static ByteBuffer extractComponent(ByteBuffer bb, int idx)
1:189a607:     {
1:3a005df:         bb = bb.duplicate();
1:b09d876:         readStatic(bb);
1:3a005df:         int i = 0;
1:3a005df:         while (bb.remaining() > 0)
1:3a005df:         {
1:9d06ea6:             ByteBuffer c = ByteBufferUtil.readBytesWithShortLength(bb);
1:3a005df:             if (i == idx)
1:3a005df:                 return c;
1:3a005df: 
1:3a005df:             bb.get(); // skip end-of-component
1:3a005df:             ++i;
1:3a005df:         }
1:3a005df:         return null;
1:3a005df:     }
1:3a005df: 
1:73b0ffb:     // Extract CQL3 column name from the full column name.
1:73b0ffb:     public ByteBuffer extractLastComponent(ByteBuffer bb)
1:5d98581:     {
1:73b0ffb:         int idx = types.get(types.size() - 1) instanceof ColumnToCollectionType ? types.size() - 2 : types.size() - 1;
1:73b0ffb:         return extractComponent(bb, idx);
1:5d98581:     }
1:0fdab63: 
1:b09d876:     public static boolean isStaticName(ByteBuffer bb)
1:b09d876:     {
1:9d06ea6:         return bb.remaining() >= 2 && (ByteBufferUtil.getShortLength(bb, bb.position()) & 0xFFFF) == STATIC_MARKER;
1:b09d876:     }
1:b09d876: 
1:a552b30:     @Override
1:a950b92:     public int componentsCount()
1:a950b92:     {
1:a950b92:         return types.size();
1:a950b92:     }
1:a950b92: 
1:5f5905d:     @Override
1:a950b92:     public List<AbstractType<?>> getComponents()
1:a950b92:     {
1:a950b92:         return types;
1:a950b92:     }
1:a950b92: 
1:5f5905d:     @Override
1:0fdab63:     public boolean isCompatibleWith(AbstractType<?> previous)
1:0fdab63:     {
1:189a607:         if (this == previous)
1:98c4a7c:             return true;
1:189a607: 
1:189a607:         if (!(previous instanceof CompositeType))
1:98c4a7c:             return false;
1:189a607: 
1:189a607:         // Extending with new components is fine
1:189a607:         CompositeType cp = (CompositeType)previous;
1:189a607:         if (types.size() < cp.types.size())
1:acea716:             return false;
1:189a607: 
1:189a607:         for (int i = 0; i < cp.types.size(); i++)
1:189a607:         {
1:189a607:             AbstractType tprev = cp.types.get(i);
1:189a607:             AbstractType tnew = types.get(i);
1:0fdab63:             if (!tnew.isCompatibleWith(tprev))
1:189a607:                 return false;
1:189a607:         }
1:b09d876:         return true;
1:0fdab63:     }
1:0fdab63: 
1:189a607:     @Override
1:9da742d:     public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
1:0fdab63:     {
1:9da742d:         if (this == otherType)
1:731f58f:             return true;
1:0fdab63: 
1:9da742d:         if (!(otherType instanceof CompositeType))
1:189a607:             return false;
1:0fdab63: 
1:0fdab63:         // Extending with new components is fine
1:9da742d:         CompositeType cp = (CompositeType) otherType;
1:0fdab63:         if (types.size() < cp.types.size())
3:0fdab63:             return false;
1:5d98581: 
1:0fdab63:         for (int i = 0; i < cp.types.size(); i++)
1:5d98581:         {
1:0fdab63:             AbstractType tprev = cp.types.get(i);
1:0fdab63:             AbstractType tnew = types.get(i);
1:189a607:             if (!tnew.isValueCompatibleWith(tprev))
1:189a607:                 return false;
1:189a607:         }
1:acea716:         return true;
1:0fdab63:     }
1:189a607: 
1:5d98581:     private static class StaticParsedComparator implements ParsedComparator
1:5d98581:     {
1:2bc0d4d:         final AbstractType<?> type;
1:5d98581:         final String part;
1:5d98581: 
1:2bc0d4d:         StaticParsedComparator(AbstractType<?> type, String part)
1:5d98581:         {
1:5d98581:             this.type = type;
1:5d98581:             this.part = part;
1:5d98581:         }
1:5d98581: 
1:2bc0d4d:         public AbstractType<?> getAbstractType()
1:5d98581:         {
1:5d98581:             return type;
1:5d98581:         }
1:5d98581: 
1:5d98581:         public String getRemainingPart()
1:5d98581:         {
1:5d98581:             return part;
1:5d98581:         }
1:5d98581: 
1:5d98581:         public int getComparatorSerializedSize()
1:5d98581:         {
1:5d98581:             return 0;
1:5d98581:         }
1:5d98581: 
1:5d98581:         public void serializeComparator(ByteBuffer bb) {}
1:5d98581:     }
1:5d98581: 
2:a950b92:     @Override
1:5d98581:     public String toString()
1:5d98581:     {
1:5d98581:         return getClass().getName() + TypeParser.stringifyTypeParameters(types);
1:655ccc3:     }
1:80ea03f: 
1:80ea03f:     public Builder builder()
1:80ea03f:     {
1:80ea03f:         return new Builder(this);
1:80ea03f:     }
1:a950b92: 
1:3a005df:     public static ByteBuffer build(ByteBuffer... buffers)
1:80ea03f:     {
1:a991b64:         return build(false, buffers);
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static ByteBuffer build(boolean isStatic, ByteBuffer... buffers)
1:a991b64:     {
1:a991b64:         int totalLength = isStatic ? 2 : 0;
1:80ea03f:         for (ByteBuffer bb : buffers)
1:80ea03f:             totalLength += 2 + bb.remaining() + 1;
1:80ea03f: 
1:80ea03f:         ByteBuffer out = ByteBuffer.allocate(totalLength);
1:a991b64: 
1:a991b64:         if (isStatic)
1:a991b64:             out.putShort((short)STATIC_MARKER);
1:a991b64: 
1:80ea03f:         for (ByteBuffer bb : buffers)
1:80ea03f:         {
1:9d06ea6:             ByteBufferUtil.writeShortLength(out, bb.remaining());
1:2d991a7:             int toCopy = bb.remaining();
1:2d991a7:             ByteBufferUtil.arrayCopy(bb, bb.position(), out, out.position(), toCopy);
1:2d991a7:             out.position(out.position() + toCopy);
1:80ea03f:             out.put((byte) 0);
1:80ea03f:         }
1:80ea03f:         out.flip();
1:80ea03f:         return out;
1:80ea03f:     }
1:80ea03f: 
1:362cc05:     public static class Builder
1:655ccc3:     {
1:655ccc3:         private final CompositeType composite;
1:655ccc3: 
1:91bdf7f:         private final List<ByteBuffer> components;
1:91bdf7f:         private final byte[] endOfComponents;
1:91bdf7f:         private int serializedSize;
1:b09d876:         private final boolean isStatic;
1:655ccc3: 
1:655ccc3:         public Builder(CompositeType composite)
1:91bdf7f:         {
1:b09d876:             this(composite, new ArrayList<ByteBuffer>(composite.types.size()), new byte[composite.types.size()], false);
1:91bdf7f:         }
1:91bdf7f: 
1:b09d876:         public static Builder staticBuilder(CompositeType composite)
1:b09d876:         {
1:b09d876:             return new Builder(composite, new ArrayList<ByteBuffer>(composite.types.size()), new byte[composite.types.size()], true);
1:b09d876:         }
1:b09d876: 
1:b09d876:         private Builder(CompositeType composite, List<ByteBuffer> components, byte[] endOfComponents, boolean isStatic)
1:655ccc3:         {
1:91bdf7f:             assert endOfComponents.length == composite.types.size();
1:91bdf7f: 
1:655ccc3:             this.composite = composite;
1:91bdf7f:             this.components = components;
1:91bdf7f:             this.endOfComponents = endOfComponents;
1:b09d876:             this.isStatic = isStatic;
1:b09d876:             if (isStatic)
1:b09d876:                 serializedSize = 2;
1:655ccc3:         }
1:655ccc3: 
1:655ccc3:         private Builder(Builder b)
1:655ccc3:         {
1:b09d876:             this(b.composite, new ArrayList<ByteBuffer>(b.components), Arrays.copyOf(b.endOfComponents, b.endOfComponents.length), b.isStatic);
1:91bdf7f:             this.serializedSize = b.serializedSize;
1:655ccc3:         }
1:655ccc3: 
1:652ec6a:         public Builder add(ByteBuffer bb)
1:655ccc3:         {
1:2b62df2:             if (components.size() >= composite.types.size())
3:655ccc3:                 throw new IllegalStateException("Composite column is already fully constructed");
1:655ccc3: 
1:652ec6a:             components.add(bb);
1:b09d876:             serializedSize += 3 + bb.remaining(); // 2 bytes lenght + 1 byte eoc
2:655ccc3:             return this;
1:655ccc3:         }
1:655ccc3: 
1:5f5905d:         public Builder add(ColumnIdentifier name)
1:5f5905d:         {
1:5f5905d:             return add(name.bytes);
1:5f5905d:         }
1:5f5905d: 
1:655ccc3:         public int componentCount()
1:655ccc3:         {
1:2b62df2:             return components.size();
1:655ccc3:         }
1:655ccc3: 
1:daac1ed:         public int remainingCount()
1:daac1ed:         {
1:daac1ed:             return composite.types.size() - components.size();
1:daac1ed:         }
1:daac1ed: 
1:a950b92:         public ByteBuffer get(int i)
1:a950b92:         {
1:a950b92:             return components.get(i);
1:a950b92:         }
1:a950b92: 
1:655ccc3:         public ByteBuffer build()
1:655ccc3:         {
1:7aafe05:             try (DataOutputBuffer out = new DataOutputBufferFixed(serializedSize))
1:655ccc3:             {
1:b09d876:                 if (isStatic)
1:b09d876:                     out.writeShort(STATIC_MARKER);
1:b09d876: 
1:b09d876:                 for (int i = 0; i < components.size(); i++)
1:91bdf7f:                 {
1:91bdf7f:                     ByteBufferUtil.writeWithShortLength(components.get(i), out);
1:b09d876:                     out.write(endOfComponents[i]);
1:91bdf7f:                 }
1:b09d876:                 return ByteBuffer.wrap(out.getData(), 0, out.getLength());
1:655ccc3:             }
1:b09d876:             catch (IOException e)
1:b09d876:             {
1:b09d876:                 throw new RuntimeException(e);
1:b09d876:             }
1:655ccc3:         }
1:655ccc3: 
1:655ccc3:         public ByteBuffer buildAsEndOfRange()
1:655ccc3:         {
1:2b62df2:             if (components.isEmpty())
1:655ccc3:                 return ByteBufferUtil.EMPTY_BYTE_BUFFER;
1:655ccc3: 
1:655ccc3:             ByteBuffer bb = build();
1:655ccc3:             bb.put(bb.remaining() - 1, (byte)1);
1:655ccc3:             return bb;
1:655ccc3:         }
1:655ccc3: 
1:5117a5d:         public ByteBuffer buildForRelation(Operator op)
1:652ec6a:         {
1:652ec6a:             /*
1:652ec6a:              * Given the rules for eoc (end-of-component, see AbstractCompositeType.compare()),
1:652ec6a:              * We can select:
1:652ec6a:              *   - = 'a' by using <'a'><0>
1:652ec6a:              *   - < 'a' by using <'a'><-1>
1:652ec6a:              *   - <= 'a' by using <'a'><1>
1:652ec6a:              *   - > 'a' by using <'a'><1>
1:652ec6a:              *   - >= 'a' by using <'a'><0>
1:652ec6a:              */
1:652ec6a:             int current = components.size() - 1;
1:652ec6a:             switch (op)
1:652ec6a:             {
1:652ec6a:                 case LT:
1:652ec6a:                     endOfComponents[current] = (byte) -1;
1:652ec6a:                     break;
1:652ec6a:                 case GT:
1:652ec6a:                 case LTE:
1:652ec6a:                     endOfComponents[current] = (byte) 1;
1:652ec6a:                     break;
1:652ec6a:                 default:
1:652ec6a:                     endOfComponents[current] = (byte) 0;
1:652ec6a:                     break;
1:652ec6a:             }
1:652ec6a:             return build();
1:652ec6a:         }
1:652ec6a: 
1:655ccc3:         public Builder copy()
1:655ccc3:         {
1:655ccc3:             return new Builder(this);
1:655ccc3:         }
1:655ccc3: 
1:a950b92:         public ByteBuffer getComponent(int i)
1:a950b92:         {
1:a950b92:             if (i >= components.size())
1:a950b92:                 throw new IllegalArgumentException();
1:a950b92: 
1:a950b92:             return components.get(i);
1:a950b92:         }
1:655ccc3:     }
1:655ccc3: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:64f12ab
commit:d600f51
/////////////////////////////////////////////////////////////////////////
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:0d8e853
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
commit:e6f23e6
commit:1de63e9
commit:98c4a7c
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public boolean references(AbstractType<?> check)
1:     {
0:         if (super.references(check))
1:             return true;
0:         for (AbstractType<?> type : types)
0:             if (type.references(check))
1:                 return true;
1:         return false;
1:     }
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:29576a4
commit:b42a0cf
commit:bee48eb
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     private static final ConcurrentMap<List<AbstractType<?>>, CompositeType> instances = new ConcurrentHashMap<List<AbstractType<?>>, CompositeType>();
/////////////////////////////////////////////////////////////////////////
1:     public static CompositeType getInstance(List<AbstractType<?>> types)
/////////////////////////////////////////////////////////////////////////
1:             CompositeType previous = instances.putIfAbsent(types, ct);
1:             if (previous != null)
1:             {
1:                 ct = previous;
1:             }
commit:2d991a7
/////////////////////////////////////////////////////////////////////////
1:             int toCopy = bb.remaining();
1:             ByteBufferUtil.arrayCopy(bb, bb.position(), out, out.position(), toCopy);
1:             out.position(out.position() + toCopy);
commit:f009272
/////////////////////////////////////////////////////////////////////////
1:     public static byte lastEOC(ByteBuffer name)
1:     {
1:         return name.get(name.limit() - 1);
1:     }
1: 
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:         readStatic(bb);
/////////////////////////////////////////////////////////////////////////
1:     public static List<ByteBuffer> splitName(ByteBuffer name)
1:     {
1:         List<ByteBuffer> l = new ArrayList<>();
1:         ByteBuffer bb = name.duplicate();
1:         readStatic(bb);
1:         while (bb.remaining() > 0)
1:         {
1:             l.add(ByteBufferUtil.readBytesWithShortLength(bb));
1:             bb.get(); // skip end-of-component
1:         }
1:         return l;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return build(false, buffers);
1:     }
1: 
1:     public static ByteBuffer build(boolean isStatic, ByteBuffer... buffers)
1:     {
1:         int totalLength = isStatic ? 2 : 0;
1: 
1:         if (isStatic)
1:             out.putShort((short)STATIC_MARKER);
1: 
commit:9d06ea6
/////////////////////////////////////////////////////////////////////////
1:         int header = ByteBufferUtil.getShortLength(bb, bb.position());
1:         ByteBufferUtil.readShortLength(bb); // Skip header
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer c = ByteBufferUtil.readBytesWithShortLength(bb);
/////////////////////////////////////////////////////////////////////////
1:         return bb.remaining() >= 2 && (ByteBufferUtil.getShortLength(bb, bb.position()) & 0xFFFF) == STATIC_MARKER;
/////////////////////////////////////////////////////////////////////////
1:             ByteBufferUtil.writeShortLength(out, bb.remaining());
commit:8a52f5a
/////////////////////////////////////////////////////////////////////////
0:         int header = ByteBufferUtil.getShortLength(bb, bb.position());
0:         ByteBufferUtil.readShortLength(bb); // Skip header
/////////////////////////////////////////////////////////////////////////
1:             l[i++] = ByteBufferUtil.readBytesWithShortLength(bb);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer c = ByteBufferUtil.readBytesWithShortLength(bb);
/////////////////////////////////////////////////////////////////////////
0:         return bb.remaining() >= 2 && (ByteBufferUtil.getShortLength(bb, bb.position()) & 0xFFFF) == STATIC_MARKER;
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeShortLength(out, bb.remaining());
commit:63b1ef4
commit:b09d876
/////////////////////////////////////////////////////////////////////////
1:  * where <length of value> is a 2 bytes unsigned short (but 0xFFFF is invalid, see
1:  * below) and the 'end-of-component' byte should always be 0 for actual column name.
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * On top of that, CQL3 uses a specific prefix (0xFFFF) to encode "static columns"
1:  * (CASSANDRA-6561). This does mean the maximum size of the first component of a
1:  * composite is 65534, not 65535 (or we wouldn't be able to detect if the first 2
1:  * bytes is the static prefix or not).
1:     public static final int STATIC_MARKER = 0xFFFF;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected boolean readIsStatic(ByteBuffer bb)
1:     {
1:         return readStatic(bb);
1:     }
1: 
1:     private static boolean readStatic(ByteBuffer bb)
1:     {
1:         if (bb.remaining() < 2)
1:             return false;
1: 
0:         int header = getShortLength(bb, bb.position());
1:         if ((header & 0xFFFF) != STATIC_MARKER)
1:             return false;
1: 
0:         getShortLength(bb); // Skip header
1:         return true;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         readStatic(bb);
/////////////////////////////////////////////////////////////////////////
1:     public static boolean isStaticName(ByteBuffer bb)
1:     {
0:         return bb.remaining() >= 2 && (getShortLength(bb, bb.position()) & 0xFFFF) == STATIC_MARKER;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         private final boolean isStatic;
1:             this(composite, new ArrayList<ByteBuffer>(composite.types.size()), new byte[composite.types.size()], false);
1:         public static Builder staticBuilder(CompositeType composite)
1:         {
1:             return new Builder(composite, new ArrayList<ByteBuffer>(composite.types.size()), new byte[composite.types.size()], true);
1:         }
1: 
1:         private Builder(CompositeType composite, List<ByteBuffer> components, byte[] endOfComponents, boolean isStatic)
1:             this.isStatic = isStatic;
1:             if (isStatic)
1:                 serializedSize = 2;
1:             this(b.composite, new ArrayList<ByteBuffer>(b.components), Arrays.copyOf(b.endOfComponents, b.endOfComponents.length), b.isStatic);
/////////////////////////////////////////////////////////////////////////
1:             serializedSize += 3 + bb.remaining(); // 2 bytes lenght + 1 byte eoc
/////////////////////////////////////////////////////////////////////////
1:             try
0:                 DataOutputBuffer out = new DataOutputBuffer(serializedSize);
1:                 if (isStatic)
1:                     out.writeShort(STATIC_MARKER);
1: 
1:                 for (int i = 0; i < components.size(); i++)
1:                     out.write(endOfComponents[i]);
1:                 return ByteBuffer.wrap(out.getData(), 0, out.getLength());
1:             catch (IOException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
commit:4c727f6
commit:652ec6a
/////////////////////////////////////////////////////////////////////////
1:         public Builder add(ByteBuffer bb)
1:             components.add(bb);
/////////////////////////////////////////////////////////////////////////
0:         public ByteBuffer buildForRelation(Relation.Type op)
1:         {
1:             /*
1:              * Given the rules for eoc (end-of-component, see AbstractCompositeType.compare()),
1:              * We can select:
1:              *   - = 'a' by using <'a'><0>
1:              *   - < 'a' by using <'a'><-1>
1:              *   - <= 'a' by using <'a'><1>
1:              *   - > 'a' by using <'a'><1>
1:              *   - >= 'a' by using <'a'><0>
1:              */
1:             int current = components.size() - 1;
1:             switch (op)
1:             {
1:                 case LT:
1:                     endOfComponents[current] = (byte) -1;
1:                     break;
1:                 case GT:
1:                 case LTE:
1:                     endOfComponents[current] = (byte) 1;
1:                     break;
1:                 default:
1:                     endOfComponents[current] = (byte) 0;
1:                     break;
1:             }
1:             return build();
1:         }
1: 
commit:8e1000f
commit:e9a57fb
commit:d387240
/////////////////////////////////////////////////////////////////////////
0:         try
1:         {
1:             return types.get(i);
1:         }
1:         catch (IndexOutOfBoundsException e)
1:         {
1:             // We shouldn't get there in general because 1) we shouldn't construct broken composites
1:             // from CQL and 2) broken composites coming from thrift should be rejected by validate.
1:             // There is a few cases however where, if the schema has changed since we created/validated
1:             // the composite, this will be thrown (see #6262). Those cases are a user error but
1:             // throwing a more meaningful error message to make understanding such error easier. .
1:             throw new RuntimeException("Cannot get comparator " + i + " in " + this + ". "
1:                                      + "This might due to a mismatch between the schema and the data read", e);
1:         }
1:         return getComparator(i, bb1);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static class Builder
/////////////////////////////////////////////////////////////////////////
commit:c41eedf
commit:731f58f
/////////////////////////////////////////////////////////////////////////
0:         outer:
0:             // This slices intersects if all component intersect. And we don't intersect
0:             // only if no slice intersects
/////////////////////////////////////////////////////////////////////////
0:                 if (!t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
0:                     continue outer;
1:             return true;
commit:bfd0144
commit:acea716
/////////////////////////////////////////////////////////////////////////
0:                 if (t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
1:                     return true;
1:         return false;
commit:a552b30
/////////////////////////////////////////////////////////////////////////
1:     protected CompositeType(List<AbstractType<?>> types)
/////////////////////////////////////////////////////////////////////////
1:     // Overriding the one of AbstractCompositeType because we can do a tad better
1:     @Override
1:     public ByteBuffer[] split(ByteBuffer name)
1:     {
1:         // Assume all components, we'll trunk the array afterwards if need be, but
1:         // most names will be complete.
1:         ByteBuffer[] l = new ByteBuffer[types.size()];
1:         ByteBuffer bb = name.duplicate();
1:         int i = 0;
1:         while (bb.remaining() > 0)
1:         {
0:             l[i++] = getWithShortLength(bb);
1:             bb.get(); // skip end-of-component
1:         }
1:         return i == l.length ? l : Arrays.copyOfRange(l, 0, i);
1:     }
1: 
commit:5f5905d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.ColumnIdentifier;
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:         public Builder add(ColumnIdentifier name)
1:         {
1:             return add(name.bytes);
1:         }
1: 
commit:5c54262
commit:189a607
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public boolean isValueCompatibleWith(AbstractType<?> previous)
1:     {
1:         if (this == previous)
0:             return true;
1: 
1:         if (!(previous instanceof CompositeType))
1:             return false;
1: 
1:         // Extending with new components is fine
1:         CompositeType cp = (CompositeType)previous;
1:         if (types.size() < cp.types.size())
1:             return false;
1: 
1:         for (int i = 0; i < cp.types.size(); i++)
1:         {
1:             AbstractType tprev = cp.types.get(i);
1:             AbstractType tnew = types.get(i);
1:             if (!tnew.isValueCompatibleWith(tprev))
1:                 return false;
1:         }
0:         return true;
1:     }
1: 
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.MarshalException;
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.MarshalException;
commit:a950b92
/////////////////////////////////////////////////////////////////////////
1:     public int componentsCount()
1:     {
1:         return types.size();
1:     }
1: 
1:     @Override
1:     public List<AbstractType<?>> getComponents()
1:     {
1:         return types;
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer get(int i)
1:         {
1:             return components.get(i);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         public ByteBuffer getComponent(int i)
1:         {
1:             if (i >= components.size())
1:                 throw new IllegalArgumentException();
1: 
1:             return components.get(i);
1:         }
commit:aae62a7
commit:31e669a
/////////////////////////////////////////////////////////////////////////
0:         public Builder add(ByteBuffer buffer, Relation.Type op)
/////////////////////////////////////////////////////////////////////////
0:             return add(bb, Relation.Type.EQ);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
1:     public static CompositeType getInstance(AbstractType... types)
1:     {
1:         return getInstance(Arrays.<AbstractType<?>>asList(types));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Extract component idx from bb. Return null if there is not enough component.
1:     public static ByteBuffer extractComponent(ByteBuffer bb, int idx)
1:     {
1:         bb = bb.duplicate();
1:         int i = 0;
1:         while (bb.remaining() > 0)
1:         {
0:             ByteBuffer c = getWithShortLength(bb);
1:             if (i == idx)
1:                 return c;
1: 
1:             bb.get(); // skip end-of-component
1:             ++i;
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static ByteBuffer build(ByteBuffer... buffers)
/////////////////////////////////////////////////////////////////////////
0:             out.put(bb.duplicate());
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.exceptions.InvalidRequestException;
0: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     public static CompositeType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
commit:80ea03f
/////////////////////////////////////////////////////////////////////////
1:         ByteBuffer[] serialized = new ByteBuffer[objects.length];
1:             serialized[i] = buffer;
1:         return build(serialized);
/////////////////////////////////////////////////////////////////////////
1:     public Builder builder()
1:     {
1:         return new Builder(this);
1:     }
1: 
0:     public ByteBuffer build(ByteBuffer... buffers)
1:     {
0:         int totalLength = 0;
1:         for (ByteBuffer bb : buffers)
1:             totalLength += 2 + bb.remaining() + 1;
1: 
1:         ByteBuffer out = ByteBuffer.allocate(totalLength);
1:         for (ByteBuffer bb : buffers)
1:         {
0:             putShortLength(out, bb.remaining());
0:             out.put(bb);
1:             out.put((byte) 0);
1:         }
1:         out.flip();
1:         return out;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:daac1ed
/////////////////////////////////////////////////////////////////////////
1:         public int remainingCount()
1:         {
1:             return composite.types.size() - components.size();
1:         }
1: 
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (components.size() >= composite.types.size())
0:             int current = components.size();
/////////////////////////////////////////////////////////////////////////
0:             int current = components.size();
0:             endOfComponents[current] = (byte) 0;
1:             return components.size();
/////////////////////////////////////////////////////////////////////////
0:             if (components.size() >= composite.types.size())
1:             if (components.isEmpty())
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
1: import com.google.common.collect.ImmutableList;
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.types = ImmutableList.copyOf(types);
/////////////////////////////////////////////////////////////////////////
1:         private final List<ByteBuffer> components;
1:         private final byte[] endOfComponents;
1:         private int serializedSize;
0:             this(composite, new ArrayList<ByteBuffer>(composite.types.size()), new byte[composite.types.size()]);
1:         }
1: 
0:         public Builder(CompositeType composite, List<ByteBuffer> components, byte[] endOfComponents)
1:         {
1:             assert endOfComponents.length == composite.types.size();
1: 
1:             this.components = components;
1:             this.endOfComponents = endOfComponents;
0:             this(b.composite, new ArrayList<ByteBuffer>(b.components), Arrays.copyOf(b.endOfComponents, b.endOfComponents.length));
1:             this.serializedSize = b.serializedSize;
/////////////////////////////////////////////////////////////////////////
0:             AbstractType currentType = composite.types.get(current);
0:             components.add(buffer);
/////////////////////////////////////////////////////////////////////////
0:                     endOfComponents[current] = (byte) -1;
0:                     endOfComponents[current] = (byte) 1;
0:                     endOfComponents[current] = (byte) 0;
0:             ++current;
/////////////////////////////////////////////////////////////////////////
0:             components.add(bb);
0:             endOfComponents[current++] = (byte) 0;
/////////////////////////////////////////////////////////////////////////
0:             DataOutputBuffer out = new DataOutputBuffer(serializedSize);
0:             for (int i = 0; i < components.size(); i++)
1:             {
1:                 ByteBufferUtil.writeWithShortLength(components.get(i), out);
0:                 out.write(endOfComponents[i]);
1:             }
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:58202a8
/////////////////////////////////////////////////////////////////////////
0:     public static CompositeType getInstance(TypeParser parser) throws ConfigurationException
1:     {
1:         return getInstance(parser.getTypeParameters());
1:     }
1: 
commit:0fdab63
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:     public boolean isCompatibleWith(AbstractType<?> previous)
1:     {
0:         if (this == previous)
0:             return true;
1: 
0:         if (!(previous instanceof CompositeType))
1:             return false;
1: 
1:         // Extending with new components is fine
0:         CompositeType cp = (CompositeType)previous;
1:         if (types.size() < cp.types.size())
1:             return false;
1: 
1:         for (int i = 0; i < cp.types.size(); i++)
1:         {
1:             AbstractType tprev = cp.types.get(i);
1:             AbstractType tnew = types.get(i);
1:             if (!tnew.isCompatibleWith(tprev))
1:                 return false;
1:         }
0:         return true;
1:     }
1: 
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import java.util.*;
0: import org.apache.cassandra.cql3.ColumnNameBuilder;
0: import org.apache.cassandra.cql3.Relation;
0: import org.apache.cassandra.cql3.Term;
0: import org.apache.cassandra.io.util.FastByteArrayOutputStream;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.thrift.InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:     public final List<AbstractType<?>> types;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static class Builder implements ColumnNameBuilder
1:     {
1:         private final CompositeType composite;
0:         private int current;
1: 
0:         private final FastByteArrayOutputStream baos = new FastByteArrayOutputStream();
0:         private final DataOutput out = new DataOutputStream(baos);
1: 
1:         public Builder(CompositeType composite)
1:         {
1:             this.composite = composite;
1:         }
1: 
1:         private Builder(Builder b)
1:         {
0:             this(b.composite);
0:             this.current = b.current;
0:             try
1:             {
0:                 out.write(b.baos.toByteArray());
1:             }
0:             catch (IOException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public Builder add(Term t, Relation.Type op, List<ByteBuffer> variables) throws InvalidRequestException
1:         {
0:             if (current >= composite.types.size())
1:                 throw new IllegalStateException("Composite column is already fully constructed");
1: 
0:             AbstractType currentType = composite.types.get(current++);
0:             ByteBuffer buffer = t.getByteBuffer(currentType, variables);
0:             try
1:             {
0:                 ByteBufferUtil.writeWithShortLength(buffer, out);
1: 
1:                 /*
0:                  * Given the rules for eoc (end-of-component, see AbstractCompositeType.compare()),
0:                  * We can select:
0:                  *   - = 'a' by using <'a'><0>
0:                  *   - < 'a' by using <'a'><-1>
0:                  *   - <= 'a' by using <'a'><1>
0:                  *   - > 'a' by using <'a'><1>
0:                  *   - >= 'a' by using <'a'><0>
1:                  */
0:                 switch (op)
1:                 {
0:                     case LT:
0:                         out.write((byte) -1);
0:                         break;
0:                     case GT:
0:                     case LTE:
0:                         out.write((byte) 1);
0:                         break;
0:                     default:
0:                         out.write((byte) 0);
0:                         break;
1:                 }
1:                 return this;
1:             }
0:             catch (IOException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public Builder add(ByteBuffer bb)
1:         {
0:             if (current >= composite.types.size())
1:                 throw new IllegalStateException("Composite column is already fully constructed");
1: 
0:             try
1:             {
0:                 ByteBufferUtil.writeWithShortLength(bb, out);
0:                 out.write((byte) 0);
1:                 return this;
1:             }
0:             catch (IOException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
1:         public int componentCount()
1:         {
0:             return current;
1:         }
1: 
1:         public ByteBuffer build()
1:         {
0:             return ByteBuffer.wrap(baos.toByteArray());
1:         }
1: 
1:         public ByteBuffer buildAsEndOfRange()
1:         {
0:             if (current >= composite.types.size())
1:                 throw new IllegalStateException("Composite column is already fully constructed");
1: 
0:             if (current == 0)
1:                 return ByteBufferUtil.EMPTY_BYTE_BUFFER;
1: 
1:             ByteBuffer bb = build();
1:             bb.put(bb.remaining() - 1, (byte)1);
1:             return bb;
1:         }
1: 
1:         public Builder copy()
1:         {
1:             return new Builder(this);
1:         }
1:     }
commit:5d98581
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.Iterator;
1: import java.util.ArrayList;
0: import java.util.HashMap;
1: import java.util.List;
0: import java.util.Map;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: /*
1:  * The encoding of a CompositeType column name should be:
1:  *   <component><component><component> ...
1:  * where <component> is:
1:  *   <length of value><value><'end-of-component' byte>
0:  * where <length of value> is a 2 bytes unsigned short the and the
0:  * 'end-of-component' byte should always be 0 for actual column name.
1:  * However, it can set to 1 for query bounds. This allows to query for the
1:  * equivalent of 'give me the full super-column'. That is, if during a slice
1:  * query uses:
1:  *   start = <3><"foo".getBytes()><0>
1:  *   end   = <3><"foo".getBytes()><1>
1:  * then he will be sure to get *all* the columns whose first component is "foo".
1:  * If for a component, the 'end-of-component' is != 0, there should not be any
1:  * following component. The end-of-component can also be -1 to allow
1:  * non-inclusive query. For instance:
1:  *   start = <3><"foo".getBytes()><-1>
1:  * allows to query everything that is greater than <3><"foo".getBytes()>, but
1:  * not <3><"foo".getBytes()> itself.
1:  */
1: public class CompositeType extends AbstractCompositeType
1: {
0:     // package protected for unit tests sake
0:     final List<AbstractType> types;
1: 
1:     // interning instances
0:     private static final Map<List<AbstractType>, CompositeType> instances = new HashMap<List<AbstractType>, CompositeType>();
1: 
0:     public static CompositeType getInstance(TypeParser parser) throws ConfigurationException
1:     {
0:         return getInstance(parser.getTypeParameters());
1:     }
1: 
0:     public static synchronized CompositeType getInstance(List<AbstractType> types) throws ConfigurationException
1:     {
0:         if (types == null || types.isEmpty())
0:             throw new ConfigurationException("Nonsensical empty parameter list for CompositeType");
1: 
1:         CompositeType ct = instances.get(types);
1:         if (ct == null)
1:         {
1:             ct = new CompositeType(types);
0:             instances.put(types, ct);
1:         }
1:         return ct;
1:     }
1: 
0:     private CompositeType(List<AbstractType> types)
1:     {
0:         this.types = types;
1:     }
1: 
0:     protected AbstractType getNextComparator(int i, ByteBuffer bb)
1:     {
1:         return types.get(i);
1:     }
1: 
0:     protected AbstractType getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:     {
1:         return types.get(i);
1:     }
1: 
0:     protected AbstractType getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb)
1:     {
1:         return types.get(i);
1:     }
1: 
0:     protected ParsedComparator parseNextComparator(int i, String part)
1:     {
1:         return new StaticParsedComparator(types.get(i), part);
1:     }
1: 
0:     protected AbstractType validateNextComparator(int i, ByteBuffer bb) throws MarshalException
1:     {
1:         if (i >= types.size())
1:             throw new MarshalException("Too many bytes for comparator");
1:         return types.get(i);
1:     }
1: 
1:     private static class StaticParsedComparator implements ParsedComparator
1:     {
0:         final AbstractType type;
1:         final String part;
1: 
0:         StaticParsedComparator(AbstractType type, String part)
1:         {
1:             this.type = type;
1:             this.part = part;
1:         }
1: 
0:         public AbstractType getAbstractType()
1:         {
1:             return type;
1:         }
1: 
1:         public String getRemainingPart()
1:         {
1:             return part;
1:         }
1: 
1:         public int getComparatorSerializedSize()
1:         {
1:             return 0;
1:         }
1: 
1:         public void serializeComparator(ByteBuffer bb) {}
1:     }
1: 
0:     @Override
1:     public String toString()
1:     {
1:         return getClass().getName() + TypeParser.stringifyTypeParameters(types);
1:     }
1: }
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
0:     public static class CompositeComponent
0:     {
0:         public ByteBuffer value;
0:         public byte eoc;
0: 
0:         public CompositeComponent(ByteBuffer value, byte eoc)
0:         {
0:             this.value = value;
0:             this.eoc = eoc;
0:         }
0:     }
0: 
0:     public static List<CompositeComponent> deconstruct(ByteBuffer bytes)
0:     {
0:         List<CompositeComponent> list = new ArrayList<>();
0:         ByteBuffer bb = bytes.duplicate();
0:         readStatic(bb);
0:         while (bb.remaining() > 0)
0:         {
0:             ByteBuffer value = ByteBufferUtil.readBytesWithShortLength(bb);
0:             byte eoc = bb.get();
0:             list.add(new CompositeComponent(value, eoc));
0:         }
0:         return list;
0:     }
0: 
commit:9dcdb8b
commit:9da742d
/////////////////////////////////////////////////////////////////////////
1:     public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
1:         if (this == otherType)
1:         if (!(otherType instanceof CompositeType))
1:         CompositeType cp = (CompositeType) otherType;
commit:0e98f5b
/////////////////////////////////////////////////////////////////////////
0:             for (int i = 0; i < minColumnNames.size(); i++)
0:                 ByteBuffer s = i < start.length ? start[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                 ByteBuffer f = i < finish.length ? finish[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                 if (i > 0 && !t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
0:                 if (i >= start.length || i >= finish.length || t.compare(s, f) != 0)
commit:b218536
/////////////////////////////////////////////////////////////////////////
0: 
0:         // If any of the slices in the filter intersect, return true
0: 
0:             if (compare(start, maxColumnNames, true) > 0 || compare(finish, minColumnNames, false) < 0)
0:                 continue;  // slice does not intersect
0: 
0:             // We could safely return true here, but there's a minor optimization: if the first component is restricted
0:             // to a single value, we can check that the second component falls within the min/max for that component
0:             // (and repeat for all components).
0:             for (int i = 0; i < Math.min(Math.min(start.length, finish.length), minColumnNames.size()); i++)
0: 
0:                 // we already know the first component falls within its min/max range (otherwise we wouldn't get here)
0:                 if (i > 0 && !t.intersects(minColumnNames.get(i), maxColumnNames.get(i), start[i], finish[i]))
0: 
0:                 // if this component isn't equal in the start and finish, we don't need to check any more
0:                 if (t.compare(start[i], finish[i]) != 0)
0:                     break;
0: 
0:         // none of the slices intersected
0:     /** Helper method for intersects() */
0:     private int compare(ByteBuffer[] sliceBounds, List<ByteBuffer> sstableBounds, boolean isSliceStart)
0:     {
0:         for (int i = 0; i < sstableBounds.size(); i++)
0:         {
0:             if (i >= sliceBounds.length)
0:                 return isSliceStart ? -1 : 1;
0: 
0:             int comparison = types.get(i).compare(sliceBounds[i], sstableBounds.get(i));
0:             if (comparison != 0)
0:                 return comparison;
0:         }
0:         return 0;
0:     }
0: 
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
1:             try (DataOutputBuffer out = new DataOutputBufferFixed(serializedSize))
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:c2ecfe7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputBufferFixed;
/////////////////////////////////////////////////////////////////////////
0:                 DataOutputBuffer out = new DataOutputBufferFixed(serializedSize);
author:blerer
-------------------------------------------------------------------------------
commit:5117a5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Operator;
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer buildForRelation(Operator op)
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:73b0ffb
/////////////////////////////////////////////////////////////////////////
0:     // Extract component idx from bb. Return null if there is not enough component.
0:     public static ByteBuffer extractComponent(ByteBuffer bb, int idx)
0:     {
0:         bb = bb.duplicate();
0:         int i = 0;
0:         while (bb.remaining() > 0)
0:         {
0:             ByteBuffer c = getWithShortLength(bb);
0:             if (i == idx)
0:                 return c;
0: 
0:             bb.get(); // skip end-of-component
0:             ++i;
0:         }
0:         return null;
0:     }
0: 
1:     // Extract CQL3 column name from the full column name.
1:     public ByteBuffer extractLastComponent(ByteBuffer bb)
0:     {
1:         int idx = types.get(types.size() - 1) instanceof ColumnToCollectionType ? types.size() - 2 : types.size() - 1;
1:         return extractComponent(bb, idx);
0:     }
0: 
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.ColumnSlice;
0: import org.apache.cassandra.db.filter.SliceQueryFilter;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Deconstructs the composite and fills out any missing components with EMPTY_BYTE_BUFFER.
0:      */
0:     public List<AbstractCompositeType.CompositeComponent> deconstructAndExpand(ByteBuffer composite)
0:     {
0:         List<AbstractCompositeType.CompositeComponent> components = deconstruct(composite);
0:         for (int i = components.size(); i < types.size(); i++)
0:             components.add(new AbstractCompositeType.CompositeComponent(this.types.get(i), ByteBufferUtil.EMPTY_BYTE_BUFFER));
0:         return components;
0:     }
0: 
0:     @Override
0:     public boolean intersects(List<ByteBuffer> minColumnNames, List<ByteBuffer> maxColumnNames, SliceQueryFilter filter)
0:     {
0:         int typeCount = types.get(types.size() - 1) instanceof ColumnToCollectionType ? types.size() - 1 : types.size();
0: 
0:         assert minColumnNames.size() == typeCount;
0: 
0:         for (ColumnSlice slice : filter.slices)
0:         {
0:             List<AbstractCompositeType.CompositeComponent> start = deconstructAndExpand(filter.isReversed() ? slice.finish : slice.start);
0:             List<AbstractCompositeType.CompositeComponent> finish = deconstructAndExpand(filter.isReversed() ? slice.start : slice.finish);
0:             for (int i = 0; i < typeCount; i++)
0:             {
0:                 AbstractType<?> t = types.get(i);
0:                 if (!t.intersects(minColumnNames.get(i), maxColumnNames.get(i), start.get(i).value, finish.get(i).value))
0:                     return false;
0:             }
0:         }
0:         return true;
0:     }
0: 
commit:debb15e
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:                 try
0:                 {
0:                     ByteBufferUtil.writeWithShortLength(components.get(i), out);
0:                 }
0:                 catch (IOException e)
0:                 {
0:                     throw new RuntimeException(e);
0:                 }
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer decompose(Object... objects)
0:     {
1:         assert objects.length == types.size();
0: 
0:         List<ByteBuffer> serialized = new ArrayList<ByteBuffer>(objects.length);
0:         int totalLength = 0;
1:         for (int i = 0; i < objects.length; i++)
0:         {
1:             ByteBuffer buffer = ((AbstractType) types.get(i)).decompose(objects[i]);
0:             serialized.add(buffer);
0:             totalLength += 2 + buffer.remaining() + 1;
0:         }
0:         ByteBuffer out = ByteBuffer.allocate(totalLength);
0:         for (ByteBuffer bb : serialized)
0:         {
0:             putShortLength(out, bb.remaining());
0:             out.put(bb);
0:             out.put((byte) 0);
0:         }
0:         out.flip();
0:         return out;
0:     }
0: 
commit:bfe2dfb
/////////////////////////////////////////////////////////////////////////
1:     protected AbstractType<?> getComparator(int i, ByteBuffer bb)
1:     protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:     protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb)
1:     protected ParsedComparator parseComparator(int i, String part)
1:     protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException
commit:ad37161
commit:9252ee9
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.List;
0: import java.util.Map;
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.io.util.DataOutputBuffer;
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         private final DataOutputBuffer out = new DataOutputBuffer();
/////////////////////////////////////////////////////////////////////////
0:             out.write(b.out.getData(), 0, b.out.getLength());
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithShortLength(buffer, out);
0:             /*
0:              * Given the rules for eoc (end-of-component, see AbstractCompositeType.compare()),
0:              * We can select:
0:              *   - = 'a' by using <'a'><0>
0:              *   - < 'a' by using <'a'><-1>
0:              *   - <= 'a' by using <'a'><1>
0:              *   - > 'a' by using <'a'><1>
0:              *   - >= 'a' by using <'a'><0>
0:              */
0:             switch (op)
0:                 case LT:
0:                     out.write((byte) -1);
0:                     break;
0:                 case GT:
0:                 case LTE:
0:                     out.write((byte) 1);
0:                     break;
0:                 default:
0:                     out.write((byte) 0);
0:                     break;
0:             return this;
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeWithShortLength(bb, out);
0:             out.write((byte) 0);
0:             return this;
/////////////////////////////////////////////////////////////////////////
0:             // potentially slightly space-wasteful in favor of avoiding a copy
0:             return ByteBuffer.wrap(out.getData(), 0, out.getLength());
commit:96ecaff
/////////////////////////////////////////////////////////////////////////
0:     public static synchronized CompositeType getInstance(List<AbstractType<?>> types)
1:         assert types != null && !types.isEmpty();
commit:2bc0d4d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     final List<AbstractType<?>> types;
0:     private static final Map<List<AbstractType<?>>, CompositeType> instances = new HashMap<List<AbstractType<?>>, CompositeType>();
0:     public static synchronized CompositeType getInstance(List<AbstractType<?>> types) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:     private CompositeType(List<AbstractType<?>> types)
0:     protected AbstractType<?> getNextComparator(int i, ByteBuffer bb)
0:     protected AbstractType<?> getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
0:     protected AbstractType<?> getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb)
/////////////////////////////////////////////////////////////////////////
0:     protected AbstractType<?> validateNextComparator(int i, ByteBuffer bb) throws MarshalException
/////////////////////////////////////////////////////////////////////////
1:         final AbstractType<?> type;
1:         StaticParsedComparator(AbstractType<?> type, String part)
1:         public AbstractType<?> getAbstractType()
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:1ea5059
/////////////////////////////////////////////////////////////////////////
0:         assert minColumnNames.size() == maxColumnNames.size();
0:             ByteBuffer[] start = split(filter.isReversed() ? slice.finish : slice.start);
0:             ByteBuffer[] finish = split(filter.isReversed() ? slice.start : slice.finish);
0:             for (int i = 0; i < minColumnNames.size(); i++)
0:                 ByteBuffer s = i < start.length ? start[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                 ByteBuffer f = i < finish.length ? finish[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
0:                 if (!t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:883c34b
/////////////////////////////////////////////////////////////////////////
0:     // Extract CQL3 column name from the full column name.
0:     public ByteBuffer extractLastComponent(ByteBuffer bb)
0:     {
0:         int idx = types.get(types.size() - 1) instanceof ColumnToCollectionType ? types.size() - 2 : types.size() - 1;
0:         return extractComponent(bb, idx);
0:     }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:bc6b5f4
commit:56f35db
/////////////////////////////////////////////////////////////////////////
============================================================================